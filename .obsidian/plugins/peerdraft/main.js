/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all2) => {
  for (var name in all2)
    __defProp(target, name, { get: all2[name], enumerable: true });
};
var __copyProps = (to, from2, except, desc) => {
  if (from2 && typeof from2 === "object" || typeof from2 === "function") {
    for (let key of __getOwnPropNames(from2))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from2[key], enumerable: !(desc = __getOwnPropDesc(from2, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/cuint/lib/uint32.js
var require_uint32 = __commonJS({
  "node_modules/cuint/lib/uint32.js"(exports, module2) {
    (function(root) {
      var radixPowerCache = {
        36: UINT32(Math.pow(36, 5)),
        16: UINT32(Math.pow(16, 7)),
        10: UINT32(Math.pow(10, 9)),
        2: UINT32(Math.pow(2, 30))
      };
      var radixCache = {
        36: UINT32(36),
        16: UINT32(16),
        10: UINT32(10),
        2: UINT32(2)
      };
      function UINT32(l, h) {
        if (!(this instanceof UINT32))
          return new UINT32(l, h);
        this._low = 0;
        this._high = 0;
        this.remainder = null;
        if (typeof h == "undefined")
          return fromNumber.call(this, l);
        if (typeof l == "string")
          return fromString.call(this, l, h);
        fromBits.call(this, l, h);
      }
      function fromBits(l, h) {
        this._low = l | 0;
        this._high = h | 0;
        return this;
      }
      UINT32.prototype.fromBits = fromBits;
      function fromNumber(value) {
        this._low = value & 65535;
        this._high = value >>> 16;
        return this;
      }
      UINT32.prototype.fromNumber = fromNumber;
      function fromString(s, radix) {
        var value = parseInt(s, radix || 10);
        this._low = value & 65535;
        this._high = value >>> 16;
        return this;
      }
      UINT32.prototype.fromString = fromString;
      UINT32.prototype.toNumber = function() {
        return this._high * 65536 + this._low;
      };
      UINT32.prototype.toString = function(radix) {
        return this.toNumber().toString(radix || 10);
      };
      UINT32.prototype.add = function(other) {
        var a00 = this._low + other._low;
        var a16 = a00 >>> 16;
        a16 += this._high + other._high;
        this._low = a00 & 65535;
        this._high = a16 & 65535;
        return this;
      };
      UINT32.prototype.subtract = function(other) {
        return this.add(other.clone().negate());
      };
      UINT32.prototype.multiply = function(other) {
        var a16 = this._high;
        var a00 = this._low;
        var b16 = other._high;
        var b00 = other._low;
        var c16, c00;
        c00 = a00 * b00;
        c16 = c00 >>> 16;
        c16 += a16 * b00;
        c16 &= 65535;
        c16 += a00 * b16;
        this._low = c00 & 65535;
        this._high = c16 & 65535;
        return this;
      };
      UINT32.prototype.div = function(other) {
        if (other._low == 0 && other._high == 0)
          throw Error("division by zero");
        if (other._high == 0 && other._low == 1) {
          this.remainder = new UINT32(0);
          return this;
        }
        if (other.gt(this)) {
          this.remainder = this.clone();
          this._low = 0;
          this._high = 0;
          return this;
        }
        if (this.eq(other)) {
          this.remainder = new UINT32(0);
          this._low = 1;
          this._high = 0;
          return this;
        }
        var _other = other.clone();
        var i = -1;
        while (!this.lt(_other)) {
          _other.shiftLeft(1, true);
          i++;
        }
        this.remainder = this.clone();
        this._low = 0;
        this._high = 0;
        for (; i >= 0; i--) {
          _other.shiftRight(1);
          if (!this.remainder.lt(_other)) {
            this.remainder.subtract(_other);
            if (i >= 16) {
              this._high |= 1 << i - 16;
            } else {
              this._low |= 1 << i;
            }
          }
        }
        return this;
      };
      UINT32.prototype.negate = function() {
        var v = (~this._low & 65535) + 1;
        this._low = v & 65535;
        this._high = ~this._high + (v >>> 16) & 65535;
        return this;
      };
      UINT32.prototype.equals = UINT32.prototype.eq = function(other) {
        return this._low == other._low && this._high == other._high;
      };
      UINT32.prototype.greaterThan = UINT32.prototype.gt = function(other) {
        if (this._high > other._high)
          return true;
        if (this._high < other._high)
          return false;
        return this._low > other._low;
      };
      UINT32.prototype.lessThan = UINT32.prototype.lt = function(other) {
        if (this._high < other._high)
          return true;
        if (this._high > other._high)
          return false;
        return this._low < other._low;
      };
      UINT32.prototype.or = function(other) {
        this._low |= other._low;
        this._high |= other._high;
        return this;
      };
      UINT32.prototype.and = function(other) {
        this._low &= other._low;
        this._high &= other._high;
        return this;
      };
      UINT32.prototype.not = function() {
        this._low = ~this._low & 65535;
        this._high = ~this._high & 65535;
        return this;
      };
      UINT32.prototype.xor = function(other) {
        this._low ^= other._low;
        this._high ^= other._high;
        return this;
      };
      UINT32.prototype.shiftRight = UINT32.prototype.shiftr = function(n) {
        if (n > 16) {
          this._low = this._high >> n - 16;
          this._high = 0;
        } else if (n == 16) {
          this._low = this._high;
          this._high = 0;
        } else {
          this._low = this._low >> n | this._high << 16 - n & 65535;
          this._high >>= n;
        }
        return this;
      };
      UINT32.prototype.shiftLeft = UINT32.prototype.shiftl = function(n, allowOverflow) {
        if (n > 16) {
          this._high = this._low << n - 16;
          this._low = 0;
          if (!allowOverflow) {
            this._high &= 65535;
          }
        } else if (n == 16) {
          this._high = this._low;
          this._low = 0;
        } else {
          this._high = this._high << n | this._low >> 16 - n;
          this._low = this._low << n & 65535;
          if (!allowOverflow) {
            this._high &= 65535;
          }
        }
        return this;
      };
      UINT32.prototype.rotateLeft = UINT32.prototype.rotl = function(n) {
        var v = this._high << 16 | this._low;
        v = v << n | v >>> 32 - n;
        this._low = v & 65535;
        this._high = v >>> 16;
        return this;
      };
      UINT32.prototype.rotateRight = UINT32.prototype.rotr = function(n) {
        var v = this._high << 16 | this._low;
        v = v >>> n | v << 32 - n;
        this._low = v & 65535;
        this._high = v >>> 16;
        return this;
      };
      UINT32.prototype.clone = function() {
        return new UINT32(this._low, this._high);
      };
      if (typeof define != "undefined" && define.amd) {
        define([], function() {
          return UINT32;
        });
      } else if (typeof module2 != "undefined" && module2.exports) {
        module2.exports = UINT32;
      } else {
        root["UINT32"] = UINT32;
      }
    })(exports);
  }
});

// node_modules/cuint/lib/uint64.js
var require_uint64 = __commonJS({
  "node_modules/cuint/lib/uint64.js"(exports, module2) {
    (function(root) {
      var radixPowerCache = {
        16: UINT64(Math.pow(16, 5)),
        10: UINT64(Math.pow(10, 5)),
        2: UINT64(Math.pow(2, 5))
      };
      var radixCache = {
        16: UINT64(16),
        10: UINT64(10),
        2: UINT64(2)
      };
      function UINT64(a00, a16, a32, a48) {
        if (!(this instanceof UINT64))
          return new UINT64(a00, a16, a32, a48);
        this.remainder = null;
        if (typeof a00 == "string")
          return fromString.call(this, a00, a16);
        if (typeof a16 == "undefined")
          return fromNumber.call(this, a00);
        fromBits.apply(this, arguments);
      }
      function fromBits(a00, a16, a32, a48) {
        if (typeof a32 == "undefined") {
          this._a00 = a00 & 65535;
          this._a16 = a00 >>> 16;
          this._a32 = a16 & 65535;
          this._a48 = a16 >>> 16;
          return this;
        }
        this._a00 = a00 | 0;
        this._a16 = a16 | 0;
        this._a32 = a32 | 0;
        this._a48 = a48 | 0;
        return this;
      }
      UINT64.prototype.fromBits = fromBits;
      function fromNumber(value) {
        this._a00 = value & 65535;
        this._a16 = value >>> 16;
        this._a32 = 0;
        this._a48 = 0;
        return this;
      }
      UINT64.prototype.fromNumber = fromNumber;
      function fromString(s, radix) {
        radix = radix || 10;
        this._a00 = 0;
        this._a16 = 0;
        this._a32 = 0;
        this._a48 = 0;
        var radixUint = radixPowerCache[radix] || new UINT64(Math.pow(radix, 5));
        for (var i = 0, len = s.length; i < len; i += 5) {
          var size = Math.min(5, len - i);
          var value = parseInt(s.slice(i, i + size), radix);
          this.multiply(
            size < 5 ? new UINT64(Math.pow(radix, size)) : radixUint
          ).add(new UINT64(value));
        }
        return this;
      }
      UINT64.prototype.fromString = fromString;
      UINT64.prototype.toNumber = function() {
        return this._a16 * 65536 + this._a00;
      };
      UINT64.prototype.toString = function(radix) {
        radix = radix || 10;
        var radixUint = radixCache[radix] || new UINT64(radix);
        if (!this.gt(radixUint))
          return this.toNumber().toString(radix);
        var self2 = this.clone();
        var res = new Array(64);
        for (var i = 63; i >= 0; i--) {
          self2.div(radixUint);
          res[i] = self2.remainder.toNumber().toString(radix);
          if (!self2.gt(radixUint))
            break;
        }
        res[i - 1] = self2.toNumber().toString(radix);
        return res.join("");
      };
      UINT64.prototype.add = function(other) {
        var a00 = this._a00 + other._a00;
        var a16 = a00 >>> 16;
        a16 += this._a16 + other._a16;
        var a32 = a16 >>> 16;
        a32 += this._a32 + other._a32;
        var a48 = a32 >>> 16;
        a48 += this._a48 + other._a48;
        this._a00 = a00 & 65535;
        this._a16 = a16 & 65535;
        this._a32 = a32 & 65535;
        this._a48 = a48 & 65535;
        return this;
      };
      UINT64.prototype.subtract = function(other) {
        return this.add(other.clone().negate());
      };
      UINT64.prototype.multiply = function(other) {
        var a00 = this._a00;
        var a16 = this._a16;
        var a32 = this._a32;
        var a48 = this._a48;
        var b00 = other._a00;
        var b16 = other._a16;
        var b32 = other._a32;
        var b48 = other._a48;
        var c00 = a00 * b00;
        var c16 = c00 >>> 16;
        c16 += a00 * b16;
        var c32 = c16 >>> 16;
        c16 &= 65535;
        c16 += a16 * b00;
        c32 += c16 >>> 16;
        c32 += a00 * b32;
        var c48 = c32 >>> 16;
        c32 &= 65535;
        c32 += a16 * b16;
        c48 += c32 >>> 16;
        c32 &= 65535;
        c32 += a32 * b00;
        c48 += c32 >>> 16;
        c48 += a00 * b48;
        c48 &= 65535;
        c48 += a16 * b32;
        c48 &= 65535;
        c48 += a32 * b16;
        c48 &= 65535;
        c48 += a48 * b00;
        this._a00 = c00 & 65535;
        this._a16 = c16 & 65535;
        this._a32 = c32 & 65535;
        this._a48 = c48 & 65535;
        return this;
      };
      UINT64.prototype.div = function(other) {
        if (other._a16 == 0 && other._a32 == 0 && other._a48 == 0) {
          if (other._a00 == 0)
            throw Error("division by zero");
          if (other._a00 == 1) {
            this.remainder = new UINT64(0);
            return this;
          }
        }
        if (other.gt(this)) {
          this.remainder = this.clone();
          this._a00 = 0;
          this._a16 = 0;
          this._a32 = 0;
          this._a48 = 0;
          return this;
        }
        if (this.eq(other)) {
          this.remainder = new UINT64(0);
          this._a00 = 1;
          this._a16 = 0;
          this._a32 = 0;
          this._a48 = 0;
          return this;
        }
        var _other = other.clone();
        var i = -1;
        while (!this.lt(_other)) {
          _other.shiftLeft(1, true);
          i++;
        }
        this.remainder = this.clone();
        this._a00 = 0;
        this._a16 = 0;
        this._a32 = 0;
        this._a48 = 0;
        for (; i >= 0; i--) {
          _other.shiftRight(1);
          if (!this.remainder.lt(_other)) {
            this.remainder.subtract(_other);
            if (i >= 48) {
              this._a48 |= 1 << i - 48;
            } else if (i >= 32) {
              this._a32 |= 1 << i - 32;
            } else if (i >= 16) {
              this._a16 |= 1 << i - 16;
            } else {
              this._a00 |= 1 << i;
            }
          }
        }
        return this;
      };
      UINT64.prototype.negate = function() {
        var v = (~this._a00 & 65535) + 1;
        this._a00 = v & 65535;
        v = (~this._a16 & 65535) + (v >>> 16);
        this._a16 = v & 65535;
        v = (~this._a32 & 65535) + (v >>> 16);
        this._a32 = v & 65535;
        this._a48 = ~this._a48 + (v >>> 16) & 65535;
        return this;
      };
      UINT64.prototype.equals = UINT64.prototype.eq = function(other) {
        return this._a48 == other._a48 && this._a00 == other._a00 && this._a32 == other._a32 && this._a16 == other._a16;
      };
      UINT64.prototype.greaterThan = UINT64.prototype.gt = function(other) {
        if (this._a48 > other._a48)
          return true;
        if (this._a48 < other._a48)
          return false;
        if (this._a32 > other._a32)
          return true;
        if (this._a32 < other._a32)
          return false;
        if (this._a16 > other._a16)
          return true;
        if (this._a16 < other._a16)
          return false;
        return this._a00 > other._a00;
      };
      UINT64.prototype.lessThan = UINT64.prototype.lt = function(other) {
        if (this._a48 < other._a48)
          return true;
        if (this._a48 > other._a48)
          return false;
        if (this._a32 < other._a32)
          return true;
        if (this._a32 > other._a32)
          return false;
        if (this._a16 < other._a16)
          return true;
        if (this._a16 > other._a16)
          return false;
        return this._a00 < other._a00;
      };
      UINT64.prototype.or = function(other) {
        this._a00 |= other._a00;
        this._a16 |= other._a16;
        this._a32 |= other._a32;
        this._a48 |= other._a48;
        return this;
      };
      UINT64.prototype.and = function(other) {
        this._a00 &= other._a00;
        this._a16 &= other._a16;
        this._a32 &= other._a32;
        this._a48 &= other._a48;
        return this;
      };
      UINT64.prototype.xor = function(other) {
        this._a00 ^= other._a00;
        this._a16 ^= other._a16;
        this._a32 ^= other._a32;
        this._a48 ^= other._a48;
        return this;
      };
      UINT64.prototype.not = function() {
        this._a00 = ~this._a00 & 65535;
        this._a16 = ~this._a16 & 65535;
        this._a32 = ~this._a32 & 65535;
        this._a48 = ~this._a48 & 65535;
        return this;
      };
      UINT64.prototype.shiftRight = UINT64.prototype.shiftr = function(n) {
        n %= 64;
        if (n >= 48) {
          this._a00 = this._a48 >> n - 48;
          this._a16 = 0;
          this._a32 = 0;
          this._a48 = 0;
        } else if (n >= 32) {
          n -= 32;
          this._a00 = (this._a32 >> n | this._a48 << 16 - n) & 65535;
          this._a16 = this._a48 >> n & 65535;
          this._a32 = 0;
          this._a48 = 0;
        } else if (n >= 16) {
          n -= 16;
          this._a00 = (this._a16 >> n | this._a32 << 16 - n) & 65535;
          this._a16 = (this._a32 >> n | this._a48 << 16 - n) & 65535;
          this._a32 = this._a48 >> n & 65535;
          this._a48 = 0;
        } else {
          this._a00 = (this._a00 >> n | this._a16 << 16 - n) & 65535;
          this._a16 = (this._a16 >> n | this._a32 << 16 - n) & 65535;
          this._a32 = (this._a32 >> n | this._a48 << 16 - n) & 65535;
          this._a48 = this._a48 >> n & 65535;
        }
        return this;
      };
      UINT64.prototype.shiftLeft = UINT64.prototype.shiftl = function(n, allowOverflow) {
        n %= 64;
        if (n >= 48) {
          this._a48 = this._a00 << n - 48;
          this._a32 = 0;
          this._a16 = 0;
          this._a00 = 0;
        } else if (n >= 32) {
          n -= 32;
          this._a48 = this._a16 << n | this._a00 >> 16 - n;
          this._a32 = this._a00 << n & 65535;
          this._a16 = 0;
          this._a00 = 0;
        } else if (n >= 16) {
          n -= 16;
          this._a48 = this._a32 << n | this._a16 >> 16 - n;
          this._a32 = (this._a16 << n | this._a00 >> 16 - n) & 65535;
          this._a16 = this._a00 << n & 65535;
          this._a00 = 0;
        } else {
          this._a48 = this._a48 << n | this._a32 >> 16 - n;
          this._a32 = (this._a32 << n | this._a16 >> 16 - n) & 65535;
          this._a16 = (this._a16 << n | this._a00 >> 16 - n) & 65535;
          this._a00 = this._a00 << n & 65535;
        }
        if (!allowOverflow) {
          this._a48 &= 65535;
        }
        return this;
      };
      UINT64.prototype.rotateLeft = UINT64.prototype.rotl = function(n) {
        n %= 64;
        if (n == 0)
          return this;
        if (n >= 32) {
          var v = this._a00;
          this._a00 = this._a32;
          this._a32 = v;
          v = this._a48;
          this._a48 = this._a16;
          this._a16 = v;
          if (n == 32)
            return this;
          n -= 32;
        }
        var high = this._a48 << 16 | this._a32;
        var low = this._a16 << 16 | this._a00;
        var _high = high << n | low >>> 32 - n;
        var _low = low << n | high >>> 32 - n;
        this._a00 = _low & 65535;
        this._a16 = _low >>> 16;
        this._a32 = _high & 65535;
        this._a48 = _high >>> 16;
        return this;
      };
      UINT64.prototype.rotateRight = UINT64.prototype.rotr = function(n) {
        n %= 64;
        if (n == 0)
          return this;
        if (n >= 32) {
          var v = this._a00;
          this._a00 = this._a32;
          this._a32 = v;
          v = this._a48;
          this._a48 = this._a16;
          this._a16 = v;
          if (n == 32)
            return this;
          n -= 32;
        }
        var high = this._a48 << 16 | this._a32;
        var low = this._a16 << 16 | this._a00;
        var _high = high >>> n | low << 32 - n;
        var _low = low >>> n | high << 32 - n;
        this._a00 = _low & 65535;
        this._a16 = _low >>> 16;
        this._a32 = _high & 65535;
        this._a48 = _high >>> 16;
        return this;
      };
      UINT64.prototype.clone = function() {
        return new UINT64(this._a00, this._a16, this._a32, this._a48);
      };
      if (typeof define != "undefined" && define.amd) {
        define([], function() {
          return UINT64;
        });
      } else if (typeof module2 != "undefined" && module2.exports) {
        module2.exports = UINT64;
      } else {
        root["UINT64"] = UINT64;
      }
    })(exports);
  }
});

// node_modules/cuint/index.js
var require_cuint = __commonJS({
  "node_modules/cuint/index.js"(exports) {
    exports.UINT32 = require_uint32();
    exports.UINT64 = require_uint64();
  }
});

// node_modules/xxhashjs/lib/xxhash.js
var require_xxhash = __commonJS({
  "node_modules/xxhashjs/lib/xxhash.js"(exports, module2) {
    var UINT32 = require_cuint().UINT32;
    UINT32.prototype.xxh_update = function(low, high) {
      var b00 = PRIME32_2._low;
      var b16 = PRIME32_2._high;
      var c16, c00;
      c00 = low * b00;
      c16 = c00 >>> 16;
      c16 += high * b00;
      c16 &= 65535;
      c16 += low * b16;
      var a00 = this._low + (c00 & 65535);
      var a16 = a00 >>> 16;
      a16 += this._high + (c16 & 65535);
      var v = a16 << 16 | a00 & 65535;
      v = v << 13 | v >>> 19;
      a00 = v & 65535;
      a16 = v >>> 16;
      b00 = PRIME32_1._low;
      b16 = PRIME32_1._high;
      c00 = a00 * b00;
      c16 = c00 >>> 16;
      c16 += a16 * b00;
      c16 &= 65535;
      c16 += a00 * b16;
      this._low = c00 & 65535;
      this._high = c16 & 65535;
    };
    var PRIME32_1 = UINT32("2654435761");
    var PRIME32_2 = UINT32("2246822519");
    var PRIME32_3 = UINT32("3266489917");
    var PRIME32_4 = UINT32("668265263");
    var PRIME32_5 = UINT32("374761393");
    function toUTF8Array(str) {
      var utf8 = [];
      for (var i = 0, n = str.length; i < n; i++) {
        var charcode = str.charCodeAt(i);
        if (charcode < 128)
          utf8.push(charcode);
        else if (charcode < 2048) {
          utf8.push(
            192 | charcode >> 6,
            128 | charcode & 63
          );
        } else if (charcode < 55296 || charcode >= 57344) {
          utf8.push(
            224 | charcode >> 12,
            128 | charcode >> 6 & 63,
            128 | charcode & 63
          );
        } else {
          i++;
          charcode = 65536 + ((charcode & 1023) << 10 | str.charCodeAt(i) & 1023);
          utf8.push(
            240 | charcode >> 18,
            128 | charcode >> 12 & 63,
            128 | charcode >> 6 & 63,
            128 | charcode & 63
          );
        }
      }
      return new Uint8Array(utf8);
    }
    function XXH2() {
      if (arguments.length == 2)
        return new XXH2(arguments[1]).update(arguments[0]).digest();
      if (!(this instanceof XXH2))
        return new XXH2(arguments[0]);
      init.call(this, arguments[0]);
    }
    function init(seed) {
      this.seed = seed instanceof UINT32 ? seed.clone() : UINT32(seed);
      this.v1 = this.seed.clone().add(PRIME32_1).add(PRIME32_2);
      this.v2 = this.seed.clone().add(PRIME32_2);
      this.v3 = this.seed.clone();
      this.v4 = this.seed.clone().subtract(PRIME32_1);
      this.total_len = 0;
      this.memsize = 0;
      this.memory = null;
      return this;
    }
    XXH2.prototype.init = init;
    XXH2.prototype.update = function(input) {
      var isString = typeof input == "string";
      var isArrayBuffer;
      if (isString) {
        input = toUTF8Array(input);
        isString = false;
        isArrayBuffer = true;
      }
      if (typeof ArrayBuffer !== "undefined" && input instanceof ArrayBuffer) {
        isArrayBuffer = true;
        input = new Uint8Array(input);
      }
      var p = 0;
      var len = input.length;
      var bEnd = p + len;
      if (len == 0)
        return this;
      this.total_len += len;
      if (this.memsize == 0) {
        if (isString) {
          this.memory = "";
        } else if (isArrayBuffer) {
          this.memory = new Uint8Array(16);
        } else {
          this.memory = new Buffer(16);
        }
      }
      if (this.memsize + len < 16) {
        if (isString) {
          this.memory += input;
        } else if (isArrayBuffer) {
          this.memory.set(input.subarray(0, len), this.memsize);
        } else {
          input.copy(this.memory, this.memsize, 0, len);
        }
        this.memsize += len;
        return this;
      }
      if (this.memsize > 0) {
        if (isString) {
          this.memory += input.slice(0, 16 - this.memsize);
        } else if (isArrayBuffer) {
          this.memory.set(input.subarray(0, 16 - this.memsize), this.memsize);
        } else {
          input.copy(this.memory, this.memsize, 0, 16 - this.memsize);
        }
        var p32 = 0;
        if (isString) {
          this.v1.xxh_update(
            this.memory.charCodeAt(p32 + 1) << 8 | this.memory.charCodeAt(p32),
            this.memory.charCodeAt(p32 + 3) << 8 | this.memory.charCodeAt(p32 + 2)
          );
          p32 += 4;
          this.v2.xxh_update(
            this.memory.charCodeAt(p32 + 1) << 8 | this.memory.charCodeAt(p32),
            this.memory.charCodeAt(p32 + 3) << 8 | this.memory.charCodeAt(p32 + 2)
          );
          p32 += 4;
          this.v3.xxh_update(
            this.memory.charCodeAt(p32 + 1) << 8 | this.memory.charCodeAt(p32),
            this.memory.charCodeAt(p32 + 3) << 8 | this.memory.charCodeAt(p32 + 2)
          );
          p32 += 4;
          this.v4.xxh_update(
            this.memory.charCodeAt(p32 + 1) << 8 | this.memory.charCodeAt(p32),
            this.memory.charCodeAt(p32 + 3) << 8 | this.memory.charCodeAt(p32 + 2)
          );
        } else {
          this.v1.xxh_update(
            this.memory[p32 + 1] << 8 | this.memory[p32],
            this.memory[p32 + 3] << 8 | this.memory[p32 + 2]
          );
          p32 += 4;
          this.v2.xxh_update(
            this.memory[p32 + 1] << 8 | this.memory[p32],
            this.memory[p32 + 3] << 8 | this.memory[p32 + 2]
          );
          p32 += 4;
          this.v3.xxh_update(
            this.memory[p32 + 1] << 8 | this.memory[p32],
            this.memory[p32 + 3] << 8 | this.memory[p32 + 2]
          );
          p32 += 4;
          this.v4.xxh_update(
            this.memory[p32 + 1] << 8 | this.memory[p32],
            this.memory[p32 + 3] << 8 | this.memory[p32 + 2]
          );
        }
        p += 16 - this.memsize;
        this.memsize = 0;
        if (isString)
          this.memory = "";
      }
      if (p <= bEnd - 16) {
        var limit = bEnd - 16;
        do {
          if (isString) {
            this.v1.xxh_update(
              input.charCodeAt(p + 1) << 8 | input.charCodeAt(p),
              input.charCodeAt(p + 3) << 8 | input.charCodeAt(p + 2)
            );
            p += 4;
            this.v2.xxh_update(
              input.charCodeAt(p + 1) << 8 | input.charCodeAt(p),
              input.charCodeAt(p + 3) << 8 | input.charCodeAt(p + 2)
            );
            p += 4;
            this.v3.xxh_update(
              input.charCodeAt(p + 1) << 8 | input.charCodeAt(p),
              input.charCodeAt(p + 3) << 8 | input.charCodeAt(p + 2)
            );
            p += 4;
            this.v4.xxh_update(
              input.charCodeAt(p + 1) << 8 | input.charCodeAt(p),
              input.charCodeAt(p + 3) << 8 | input.charCodeAt(p + 2)
            );
          } else {
            this.v1.xxh_update(
              input[p + 1] << 8 | input[p],
              input[p + 3] << 8 | input[p + 2]
            );
            p += 4;
            this.v2.xxh_update(
              input[p + 1] << 8 | input[p],
              input[p + 3] << 8 | input[p + 2]
            );
            p += 4;
            this.v3.xxh_update(
              input[p + 1] << 8 | input[p],
              input[p + 3] << 8 | input[p + 2]
            );
            p += 4;
            this.v4.xxh_update(
              input[p + 1] << 8 | input[p],
              input[p + 3] << 8 | input[p + 2]
            );
          }
          p += 4;
        } while (p <= limit);
      }
      if (p < bEnd) {
        if (isString) {
          this.memory += input.slice(p);
        } else if (isArrayBuffer) {
          this.memory.set(input.subarray(p, bEnd), this.memsize);
        } else {
          input.copy(this.memory, this.memsize, p, bEnd);
        }
        this.memsize = bEnd - p;
      }
      return this;
    };
    XXH2.prototype.digest = function() {
      var input = this.memory;
      var isString = typeof input == "string";
      var p = 0;
      var bEnd = this.memsize;
      var h322, h;
      var u = new UINT32();
      if (this.total_len >= 16) {
        h322 = this.v1.rotl(1).add(this.v2.rotl(7).add(this.v3.rotl(12).add(this.v4.rotl(18))));
      } else {
        h322 = this.seed.clone().add(PRIME32_5);
      }
      h322.add(u.fromNumber(this.total_len));
      while (p <= bEnd - 4) {
        if (isString) {
          u.fromBits(
            input.charCodeAt(p + 1) << 8 | input.charCodeAt(p),
            input.charCodeAt(p + 3) << 8 | input.charCodeAt(p + 2)
          );
        } else {
          u.fromBits(
            input[p + 1] << 8 | input[p],
            input[p + 3] << 8 | input[p + 2]
          );
        }
        h322.add(u.multiply(PRIME32_3)).rotl(17).multiply(PRIME32_4);
        p += 4;
      }
      while (p < bEnd) {
        u.fromBits(isString ? input.charCodeAt(p++) : input[p++], 0);
        h322.add(u.multiply(PRIME32_5)).rotl(11).multiply(PRIME32_1);
      }
      h = h322.clone().shiftRight(15);
      h322.xor(h).multiply(PRIME32_2);
      h = h322.clone().shiftRight(13);
      h322.xor(h).multiply(PRIME32_3);
      h = h322.clone().shiftRight(16);
      h322.xor(h);
      this.init(this.seed);
      return h322;
    };
    module2.exports = XXH2;
  }
});

// node_modules/xxhashjs/lib/xxhash64.js
var require_xxhash64 = __commonJS({
  "node_modules/xxhashjs/lib/xxhash64.js"(exports, module2) {
    var UINT64 = require_cuint().UINT64;
    var PRIME64_1 = UINT64("11400714785074694791");
    var PRIME64_2 = UINT64("14029467366897019727");
    var PRIME64_3 = UINT64("1609587929392839161");
    var PRIME64_4 = UINT64("9650029242287828579");
    var PRIME64_5 = UINT64("2870177450012600261");
    function toUTF8Array(str) {
      var utf8 = [];
      for (var i = 0, n = str.length; i < n; i++) {
        var charcode = str.charCodeAt(i);
        if (charcode < 128)
          utf8.push(charcode);
        else if (charcode < 2048) {
          utf8.push(
            192 | charcode >> 6,
            128 | charcode & 63
          );
        } else if (charcode < 55296 || charcode >= 57344) {
          utf8.push(
            224 | charcode >> 12,
            128 | charcode >> 6 & 63,
            128 | charcode & 63
          );
        } else {
          i++;
          charcode = 65536 + ((charcode & 1023) << 10 | str.charCodeAt(i) & 1023);
          utf8.push(
            240 | charcode >> 18,
            128 | charcode >> 12 & 63,
            128 | charcode >> 6 & 63,
            128 | charcode & 63
          );
        }
      }
      return new Uint8Array(utf8);
    }
    function XXH64() {
      if (arguments.length == 2)
        return new XXH64(arguments[1]).update(arguments[0]).digest();
      if (!(this instanceof XXH64))
        return new XXH64(arguments[0]);
      init.call(this, arguments[0]);
    }
    function init(seed) {
      this.seed = seed instanceof UINT64 ? seed.clone() : UINT64(seed);
      this.v1 = this.seed.clone().add(PRIME64_1).add(PRIME64_2);
      this.v2 = this.seed.clone().add(PRIME64_2);
      this.v3 = this.seed.clone();
      this.v4 = this.seed.clone().subtract(PRIME64_1);
      this.total_len = 0;
      this.memsize = 0;
      this.memory = null;
      return this;
    }
    XXH64.prototype.init = init;
    XXH64.prototype.update = function(input) {
      var isString = typeof input == "string";
      var isArrayBuffer;
      if (isString) {
        input = toUTF8Array(input);
        isString = false;
        isArrayBuffer = true;
      }
      if (typeof ArrayBuffer !== "undefined" && input instanceof ArrayBuffer) {
        isArrayBuffer = true;
        input = new Uint8Array(input);
      }
      var p = 0;
      var len = input.length;
      var bEnd = p + len;
      if (len == 0)
        return this;
      this.total_len += len;
      if (this.memsize == 0) {
        if (isString) {
          this.memory = "";
        } else if (isArrayBuffer) {
          this.memory = new Uint8Array(32);
        } else {
          this.memory = new Buffer(32);
        }
      }
      if (this.memsize + len < 32) {
        if (isString) {
          this.memory += input;
        } else if (isArrayBuffer) {
          this.memory.set(input.subarray(0, len), this.memsize);
        } else {
          input.copy(this.memory, this.memsize, 0, len);
        }
        this.memsize += len;
        return this;
      }
      if (this.memsize > 0) {
        if (isString) {
          this.memory += input.slice(0, 32 - this.memsize);
        } else if (isArrayBuffer) {
          this.memory.set(input.subarray(0, 32 - this.memsize), this.memsize);
        } else {
          input.copy(this.memory, this.memsize, 0, 32 - this.memsize);
        }
        var p64 = 0;
        if (isString) {
          var other;
          other = UINT64(
            this.memory.charCodeAt(p64 + 1) << 8 | this.memory.charCodeAt(p64),
            this.memory.charCodeAt(p64 + 3) << 8 | this.memory.charCodeAt(p64 + 2),
            this.memory.charCodeAt(p64 + 5) << 8 | this.memory.charCodeAt(p64 + 4),
            this.memory.charCodeAt(p64 + 7) << 8 | this.memory.charCodeAt(p64 + 6)
          );
          this.v1.add(other.multiply(PRIME64_2)).rotl(31).multiply(PRIME64_1);
          p64 += 8;
          other = UINT64(
            this.memory.charCodeAt(p64 + 1) << 8 | this.memory.charCodeAt(p64),
            this.memory.charCodeAt(p64 + 3) << 8 | this.memory.charCodeAt(p64 + 2),
            this.memory.charCodeAt(p64 + 5) << 8 | this.memory.charCodeAt(p64 + 4),
            this.memory.charCodeAt(p64 + 7) << 8 | this.memory.charCodeAt(p64 + 6)
          );
          this.v2.add(other.multiply(PRIME64_2)).rotl(31).multiply(PRIME64_1);
          p64 += 8;
          other = UINT64(
            this.memory.charCodeAt(p64 + 1) << 8 | this.memory.charCodeAt(p64),
            this.memory.charCodeAt(p64 + 3) << 8 | this.memory.charCodeAt(p64 + 2),
            this.memory.charCodeAt(p64 + 5) << 8 | this.memory.charCodeAt(p64 + 4),
            this.memory.charCodeAt(p64 + 7) << 8 | this.memory.charCodeAt(p64 + 6)
          );
          this.v3.add(other.multiply(PRIME64_2)).rotl(31).multiply(PRIME64_1);
          p64 += 8;
          other = UINT64(
            this.memory.charCodeAt(p64 + 1) << 8 | this.memory.charCodeAt(p64),
            this.memory.charCodeAt(p64 + 3) << 8 | this.memory.charCodeAt(p64 + 2),
            this.memory.charCodeAt(p64 + 5) << 8 | this.memory.charCodeAt(p64 + 4),
            this.memory.charCodeAt(p64 + 7) << 8 | this.memory.charCodeAt(p64 + 6)
          );
          this.v4.add(other.multiply(PRIME64_2)).rotl(31).multiply(PRIME64_1);
        } else {
          var other;
          other = UINT64(
            this.memory[p64 + 1] << 8 | this.memory[p64],
            this.memory[p64 + 3] << 8 | this.memory[p64 + 2],
            this.memory[p64 + 5] << 8 | this.memory[p64 + 4],
            this.memory[p64 + 7] << 8 | this.memory[p64 + 6]
          );
          this.v1.add(other.multiply(PRIME64_2)).rotl(31).multiply(PRIME64_1);
          p64 += 8;
          other = UINT64(
            this.memory[p64 + 1] << 8 | this.memory[p64],
            this.memory[p64 + 3] << 8 | this.memory[p64 + 2],
            this.memory[p64 + 5] << 8 | this.memory[p64 + 4],
            this.memory[p64 + 7] << 8 | this.memory[p64 + 6]
          );
          this.v2.add(other.multiply(PRIME64_2)).rotl(31).multiply(PRIME64_1);
          p64 += 8;
          other = UINT64(
            this.memory[p64 + 1] << 8 | this.memory[p64],
            this.memory[p64 + 3] << 8 | this.memory[p64 + 2],
            this.memory[p64 + 5] << 8 | this.memory[p64 + 4],
            this.memory[p64 + 7] << 8 | this.memory[p64 + 6]
          );
          this.v3.add(other.multiply(PRIME64_2)).rotl(31).multiply(PRIME64_1);
          p64 += 8;
          other = UINT64(
            this.memory[p64 + 1] << 8 | this.memory[p64],
            this.memory[p64 + 3] << 8 | this.memory[p64 + 2],
            this.memory[p64 + 5] << 8 | this.memory[p64 + 4],
            this.memory[p64 + 7] << 8 | this.memory[p64 + 6]
          );
          this.v4.add(other.multiply(PRIME64_2)).rotl(31).multiply(PRIME64_1);
        }
        p += 32 - this.memsize;
        this.memsize = 0;
        if (isString)
          this.memory = "";
      }
      if (p <= bEnd - 32) {
        var limit = bEnd - 32;
        do {
          if (isString) {
            var other;
            other = UINT64(
              input.charCodeAt(p + 1) << 8 | input.charCodeAt(p),
              input.charCodeAt(p + 3) << 8 | input.charCodeAt(p + 2),
              input.charCodeAt(p + 5) << 8 | input.charCodeAt(p + 4),
              input.charCodeAt(p + 7) << 8 | input.charCodeAt(p + 6)
            );
            this.v1.add(other.multiply(PRIME64_2)).rotl(31).multiply(PRIME64_1);
            p += 8;
            other = UINT64(
              input.charCodeAt(p + 1) << 8 | input.charCodeAt(p),
              input.charCodeAt(p + 3) << 8 | input.charCodeAt(p + 2),
              input.charCodeAt(p + 5) << 8 | input.charCodeAt(p + 4),
              input.charCodeAt(p + 7) << 8 | input.charCodeAt(p + 6)
            );
            this.v2.add(other.multiply(PRIME64_2)).rotl(31).multiply(PRIME64_1);
            p += 8;
            other = UINT64(
              input.charCodeAt(p + 1) << 8 | input.charCodeAt(p),
              input.charCodeAt(p + 3) << 8 | input.charCodeAt(p + 2),
              input.charCodeAt(p + 5) << 8 | input.charCodeAt(p + 4),
              input.charCodeAt(p + 7) << 8 | input.charCodeAt(p + 6)
            );
            this.v3.add(other.multiply(PRIME64_2)).rotl(31).multiply(PRIME64_1);
            p += 8;
            other = UINT64(
              input.charCodeAt(p + 1) << 8 | input.charCodeAt(p),
              input.charCodeAt(p + 3) << 8 | input.charCodeAt(p + 2),
              input.charCodeAt(p + 5) << 8 | input.charCodeAt(p + 4),
              input.charCodeAt(p + 7) << 8 | input.charCodeAt(p + 6)
            );
            this.v4.add(other.multiply(PRIME64_2)).rotl(31).multiply(PRIME64_1);
          } else {
            var other;
            other = UINT64(
              input[p + 1] << 8 | input[p],
              input[p + 3] << 8 | input[p + 2],
              input[p + 5] << 8 | input[p + 4],
              input[p + 7] << 8 | input[p + 6]
            );
            this.v1.add(other.multiply(PRIME64_2)).rotl(31).multiply(PRIME64_1);
            p += 8;
            other = UINT64(
              input[p + 1] << 8 | input[p],
              input[p + 3] << 8 | input[p + 2],
              input[p + 5] << 8 | input[p + 4],
              input[p + 7] << 8 | input[p + 6]
            );
            this.v2.add(other.multiply(PRIME64_2)).rotl(31).multiply(PRIME64_1);
            p += 8;
            other = UINT64(
              input[p + 1] << 8 | input[p],
              input[p + 3] << 8 | input[p + 2],
              input[p + 5] << 8 | input[p + 4],
              input[p + 7] << 8 | input[p + 6]
            );
            this.v3.add(other.multiply(PRIME64_2)).rotl(31).multiply(PRIME64_1);
            p += 8;
            other = UINT64(
              input[p + 1] << 8 | input[p],
              input[p + 3] << 8 | input[p + 2],
              input[p + 5] << 8 | input[p + 4],
              input[p + 7] << 8 | input[p + 6]
            );
            this.v4.add(other.multiply(PRIME64_2)).rotl(31).multiply(PRIME64_1);
          }
          p += 8;
        } while (p <= limit);
      }
      if (p < bEnd) {
        if (isString) {
          this.memory += input.slice(p);
        } else if (isArrayBuffer) {
          this.memory.set(input.subarray(p, bEnd), this.memsize);
        } else {
          input.copy(this.memory, this.memsize, p, bEnd);
        }
        this.memsize = bEnd - p;
      }
      return this;
    };
    XXH64.prototype.digest = function() {
      var input = this.memory;
      var isString = typeof input == "string";
      var p = 0;
      var bEnd = this.memsize;
      var h64, h;
      var u = new UINT64();
      if (this.total_len >= 32) {
        h64 = this.v1.clone().rotl(1);
        h64.add(this.v2.clone().rotl(7));
        h64.add(this.v3.clone().rotl(12));
        h64.add(this.v4.clone().rotl(18));
        h64.xor(this.v1.multiply(PRIME64_2).rotl(31).multiply(PRIME64_1));
        h64.multiply(PRIME64_1).add(PRIME64_4);
        h64.xor(this.v2.multiply(PRIME64_2).rotl(31).multiply(PRIME64_1));
        h64.multiply(PRIME64_1).add(PRIME64_4);
        h64.xor(this.v3.multiply(PRIME64_2).rotl(31).multiply(PRIME64_1));
        h64.multiply(PRIME64_1).add(PRIME64_4);
        h64.xor(this.v4.multiply(PRIME64_2).rotl(31).multiply(PRIME64_1));
        h64.multiply(PRIME64_1).add(PRIME64_4);
      } else {
        h64 = this.seed.clone().add(PRIME64_5);
      }
      h64.add(u.fromNumber(this.total_len));
      while (p <= bEnd - 8) {
        if (isString) {
          u.fromBits(
            input.charCodeAt(p + 1) << 8 | input.charCodeAt(p),
            input.charCodeAt(p + 3) << 8 | input.charCodeAt(p + 2),
            input.charCodeAt(p + 5) << 8 | input.charCodeAt(p + 4),
            input.charCodeAt(p + 7) << 8 | input.charCodeAt(p + 6)
          );
        } else {
          u.fromBits(
            input[p + 1] << 8 | input[p],
            input[p + 3] << 8 | input[p + 2],
            input[p + 5] << 8 | input[p + 4],
            input[p + 7] << 8 | input[p + 6]
          );
        }
        u.multiply(PRIME64_2).rotl(31).multiply(PRIME64_1);
        h64.xor(u).rotl(27).multiply(PRIME64_1).add(PRIME64_4);
        p += 8;
      }
      if (p + 4 <= bEnd) {
        if (isString) {
          u.fromBits(
            input.charCodeAt(p + 1) << 8 | input.charCodeAt(p),
            input.charCodeAt(p + 3) << 8 | input.charCodeAt(p + 2),
            0,
            0
          );
        } else {
          u.fromBits(
            input[p + 1] << 8 | input[p],
            input[p + 3] << 8 | input[p + 2],
            0,
            0
          );
        }
        h64.xor(u.multiply(PRIME64_1)).rotl(23).multiply(PRIME64_2).add(PRIME64_3);
        p += 4;
      }
      while (p < bEnd) {
        u.fromBits(isString ? input.charCodeAt(p++) : input[p++], 0, 0, 0);
        h64.xor(u.multiply(PRIME64_5)).rotl(11).multiply(PRIME64_1);
      }
      h = h64.clone().shiftRight(33);
      h64.xor(h).multiply(PRIME64_2);
      h = h64.clone().shiftRight(29);
      h64.xor(h).multiply(PRIME64_3);
      h = h64.clone().shiftRight(32);
      h64.xor(h);
      this.init(this.seed);
      return h64;
    };
    module2.exports = XXH64;
  }
});

// node_modules/xxhashjs/lib/index.js
var require_lib = __commonJS({
  "node_modules/xxhashjs/lib/index.js"(exports, module2) {
    module2.exports = {
      h32: require_xxhash(),
      h64: require_xxhash64()
    };
  }
});

// node_modules/simple-peer/simplepeer.min.js
var require_simplepeer_min = __commonJS({
  "node_modules/simple-peer/simplepeer.min.js"(exports, module2) {
    (function(e) {
      if ("object" == typeof exports && "undefined" != typeof module2)
        module2.exports = e();
      else if ("function" == typeof define && define.amd)
        define([], e);
      else {
        var t;
        t = "undefined" == typeof window ? "undefined" == typeof global ? "undefined" == typeof self ? this : self : global : window, t.SimplePeer = e();
      }
    })(function() {
      var t = Math.floor, n = Math.abs, r = Math.pow;
      return function() {
        function d(s, e, n2) {
          function t2(o, i) {
            if (!e[o]) {
              if (!s[o]) {
                var l = "function" == typeof require && require;
                if (!i && l)
                  return l(o, true);
                if (r2)
                  return r2(o, true);
                var c = new Error("Cannot find module '" + o + "'");
                throw c.code = "MODULE_NOT_FOUND", c;
              }
              var a2 = e[o] = { exports: {} };
              s[o][0].call(a2.exports, function(e2) {
                var r3 = s[o][1][e2];
                return t2(r3 || e2);
              }, a2, a2.exports, d, s, e, n2);
            }
            return e[o].exports;
          }
          for (var r2 = "function" == typeof require && require, a = 0; a < n2.length; a++)
            t2(n2[a]);
          return t2;
        }
        return d;
      }()({ 1: [function(e, t2, n2) {
        "use strict";
        function r2(e2) {
          var t3 = e2.length;
          if (0 < t3 % 4)
            throw new Error("Invalid string. Length must be a multiple of 4");
          var n3 = e2.indexOf("=");
          -1 === n3 && (n3 = t3);
          var r3 = n3 === t3 ? 0 : 4 - n3 % 4;
          return [n3, r3];
        }
        function a(e2, t3, n3) {
          return 3 * (t3 + n3) / 4 - n3;
        }
        function o(e2) {
          var t3, n3, o2 = r2(e2), d2 = o2[0], s2 = o2[1], l2 = new p(a(e2, d2, s2)), c2 = 0, f2 = 0 < s2 ? d2 - 4 : d2;
          for (n3 = 0; n3 < f2; n3 += 4)
            t3 = u[e2.charCodeAt(n3)] << 18 | u[e2.charCodeAt(n3 + 1)] << 12 | u[e2.charCodeAt(n3 + 2)] << 6 | u[e2.charCodeAt(n3 + 3)], l2[c2++] = 255 & t3 >> 16, l2[c2++] = 255 & t3 >> 8, l2[c2++] = 255 & t3;
          return 2 === s2 && (t3 = u[e2.charCodeAt(n3)] << 2 | u[e2.charCodeAt(n3 + 1)] >> 4, l2[c2++] = 255 & t3), 1 === s2 && (t3 = u[e2.charCodeAt(n3)] << 10 | u[e2.charCodeAt(n3 + 1)] << 4 | u[e2.charCodeAt(n3 + 2)] >> 2, l2[c2++] = 255 & t3 >> 8, l2[c2++] = 255 & t3), l2;
        }
        function d(e2) {
          return c[63 & e2 >> 18] + c[63 & e2 >> 12] + c[63 & e2 >> 6] + c[63 & e2];
        }
        function s(e2, t3, n3) {
          for (var r3, a2 = [], o2 = t3; o2 < n3; o2 += 3)
            r3 = (16711680 & e2[o2] << 16) + (65280 & e2[o2 + 1] << 8) + (255 & e2[o2 + 2]), a2.push(d(r3));
          return a2.join("");
        }
        function l(e2) {
          for (var t3, n3 = e2.length, r3 = n3 % 3, a2 = [], o2 = 16383, d2 = 0, l2 = n3 - r3; d2 < l2; d2 += o2)
            a2.push(s(e2, d2, d2 + o2 > l2 ? l2 : d2 + o2));
          return 1 === r3 ? (t3 = e2[n3 - 1], a2.push(c[t3 >> 2] + c[63 & t3 << 4] + "==")) : 2 === r3 && (t3 = (e2[n3 - 2] << 8) + e2[n3 - 1], a2.push(c[t3 >> 10] + c[63 & t3 >> 4] + c[63 & t3 << 2] + "=")), a2.join("");
        }
        n2.byteLength = function(e2) {
          var t3 = r2(e2), n3 = t3[0], a2 = t3[1];
          return 3 * (n3 + a2) / 4 - a2;
        }, n2.toByteArray = o, n2.fromByteArray = l;
        for (var c = [], u = [], p = "undefined" == typeof Uint8Array ? Array : Uint8Array, f = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", g = 0, _ = f.length; g < _; ++g)
          c[g] = f[g], u[f.charCodeAt(g)] = g;
        u[45] = 62, u[95] = 63;
      }, {}], 2: [function() {
      }, {}], 3: [function(e, t2, n2) {
        (function() {
          (function() {
            "use strict";
            var t3 = String.fromCharCode, o = Math.min;
            function d(e2) {
              if (2147483647 < e2)
                throw new RangeError('The value "' + e2 + '" is invalid for option "size"');
              var t4 = new Uint8Array(e2);
              return t4.__proto__ = s.prototype, t4;
            }
            function s(e2, t4, n3) {
              if ("number" == typeof e2) {
                if ("string" == typeof t4)
                  throw new TypeError('The "string" argument must be of type string. Received type number');
                return p(e2);
              }
              return l(e2, t4, n3);
            }
            function l(e2, t4, n3) {
              if ("string" == typeof e2)
                return f(e2, t4);
              if (ArrayBuffer.isView(e2))
                return g(e2);
              if (null == e2)
                throw TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e2);
              if (K(e2, ArrayBuffer) || e2 && K(e2.buffer, ArrayBuffer))
                return _(e2, t4, n3);
              if ("number" == typeof e2)
                throw new TypeError('The "value" argument must not be of type number. Received type number');
              var r2 = e2.valueOf && e2.valueOf();
              if (null != r2 && r2 !== e2)
                return s.from(r2, t4, n3);
              var a = h(e2);
              if (a)
                return a;
              if ("undefined" != typeof Symbol && null != Symbol.toPrimitive && "function" == typeof e2[Symbol.toPrimitive])
                return s.from(e2[Symbol.toPrimitive]("string"), t4, n3);
              throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e2);
            }
            function c(e2) {
              if ("number" != typeof e2)
                throw new TypeError('"size" argument must be of type number');
              else if (0 > e2)
                throw new RangeError('The value "' + e2 + '" is invalid for option "size"');
            }
            function u(e2, t4, n3) {
              return c(e2), 0 >= e2 ? d(e2) : void 0 === t4 ? d(e2) : "string" == typeof n3 ? d(e2).fill(t4, n3) : d(e2).fill(t4);
            }
            function p(e2) {
              return c(e2), d(0 > e2 ? 0 : 0 | m(e2));
            }
            function f(e2, t4) {
              if (("string" != typeof t4 || "" === t4) && (t4 = "utf8"), !s.isEncoding(t4))
                throw new TypeError("Unknown encoding: " + t4);
              var n3 = 0 | b(e2, t4), r2 = d(n3), a = r2.write(e2, t4);
              return a !== n3 && (r2 = r2.slice(0, a)), r2;
            }
            function g(e2) {
              for (var t4 = 0 > e2.length ? 0 : 0 | m(e2.length), n3 = d(t4), r2 = 0; r2 < t4; r2 += 1)
                n3[r2] = 255 & e2[r2];
              return n3;
            }
            function _(e2, t4, n3) {
              if (0 > t4 || e2.byteLength < t4)
                throw new RangeError('"offset" is outside of buffer bounds');
              if (e2.byteLength < t4 + (n3 || 0))
                throw new RangeError('"length" is outside of buffer bounds');
              var r2;
              return r2 = void 0 === t4 && void 0 === n3 ? new Uint8Array(e2) : void 0 === n3 ? new Uint8Array(e2, t4) : new Uint8Array(e2, t4, n3), r2.__proto__ = s.prototype, r2;
            }
            function h(e2) {
              if (s.isBuffer(e2)) {
                var t4 = 0 | m(e2.length), n3 = d(t4);
                return 0 === n3.length ? n3 : (e2.copy(n3, 0, 0, t4), n3);
              }
              return void 0 === e2.length ? "Buffer" === e2.type && Array.isArray(e2.data) ? g(e2.data) : void 0 : "number" != typeof e2.length || X(e2.length) ? d(0) : g(e2);
            }
            function m(e2) {
              if (e2 >= 2147483647)
                throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + 2147483647 .toString(16) + " bytes");
              return 0 | e2;
            }
            function b(e2, t4) {
              if (s.isBuffer(e2))
                return e2.length;
              if (ArrayBuffer.isView(e2) || K(e2, ArrayBuffer))
                return e2.byteLength;
              if ("string" != typeof e2)
                throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof e2);
              var n3 = e2.length, r2 = 2 < arguments.length && true === arguments[2];
              if (!r2 && 0 === n3)
                return 0;
              for (var a = false; ; )
                switch (t4) {
                  case "ascii":
                  case "latin1":
                  case "binary":
                    return n3;
                  case "utf8":
                  case "utf-8":
                    return H(e2).length;
                  case "ucs2":
                  case "ucs-2":
                  case "utf16le":
                  case "utf-16le":
                    return 2 * n3;
                  case "hex":
                    return n3 >>> 1;
                  case "base64":
                    return z(e2).length;
                  default:
                    if (a)
                      return r2 ? -1 : H(e2).length;
                    t4 = ("" + t4).toLowerCase(), a = true;
                }
            }
            function y(e2, t4, n3) {
              var r2 = false;
              if ((void 0 === t4 || 0 > t4) && (t4 = 0), t4 > this.length)
                return "";
              if ((void 0 === n3 || n3 > this.length) && (n3 = this.length), 0 >= n3)
                return "";
              if (n3 >>>= 0, t4 >>>= 0, n3 <= t4)
                return "";
              for (e2 || (e2 = "utf8"); ; )
                switch (e2) {
                  case "hex":
                    return P(this, t4, n3);
                  case "utf8":
                  case "utf-8":
                    return x(this, t4, n3);
                  case "ascii":
                    return D(this, t4, n3);
                  case "latin1":
                  case "binary":
                    return I(this, t4, n3);
                  case "base64":
                    return A(this, t4, n3);
                  case "ucs2":
                  case "ucs-2":
                  case "utf16le":
                  case "utf-16le":
                    return M(this, t4, n3);
                  default:
                    if (r2)
                      throw new TypeError("Unknown encoding: " + e2);
                    e2 = (e2 + "").toLowerCase(), r2 = true;
                }
            }
            function C(e2, t4, n3) {
              var r2 = e2[t4];
              e2[t4] = e2[n3], e2[n3] = r2;
            }
            function R(e2, t4, n3, r2, a) {
              if (0 === e2.length)
                return -1;
              if ("string" == typeof n3 ? (r2 = n3, n3 = 0) : 2147483647 < n3 ? n3 = 2147483647 : -2147483648 > n3 && (n3 = -2147483648), n3 = +n3, X(n3) && (n3 = a ? 0 : e2.length - 1), 0 > n3 && (n3 = e2.length + n3), n3 >= e2.length) {
                if (a)
                  return -1;
                n3 = e2.length - 1;
              } else if (0 > n3)
                if (a)
                  n3 = 0;
                else
                  return -1;
              if ("string" == typeof t4 && (t4 = s.from(t4, r2)), s.isBuffer(t4))
                return 0 === t4.length ? -1 : E(e2, t4, n3, r2, a);
              if ("number" == typeof t4)
                return t4 &= 255, "function" == typeof Uint8Array.prototype.indexOf ? a ? Uint8Array.prototype.indexOf.call(e2, t4, n3) : Uint8Array.prototype.lastIndexOf.call(e2, t4, n3) : E(e2, [t4], n3, r2, a);
              throw new TypeError("val must be string, number or Buffer");
            }
            function E(e2, t4, n3, r2, a) {
              function o2(e3, t5) {
                return 1 === d2 ? e3[t5] : e3.readUInt16BE(t5 * d2);
              }
              var d2 = 1, s2 = e2.length, l2 = t4.length;
              if (void 0 !== r2 && (r2 = (r2 + "").toLowerCase(), "ucs2" === r2 || "ucs-2" === r2 || "utf16le" === r2 || "utf-16le" === r2)) {
                if (2 > e2.length || 2 > t4.length)
                  return -1;
                d2 = 2, s2 /= 2, l2 /= 2, n3 /= 2;
              }
              var c2;
              if (a) {
                var u2 = -1;
                for (c2 = n3; c2 < s2; c2++)
                  if (o2(e2, c2) !== o2(t4, -1 === u2 ? 0 : c2 - u2))
                    -1 !== u2 && (c2 -= c2 - u2), u2 = -1;
                  else if (-1 === u2 && (u2 = c2), c2 - u2 + 1 === l2)
                    return u2 * d2;
              } else
                for (n3 + l2 > s2 && (n3 = s2 - l2), c2 = n3; 0 <= c2; c2--) {
                  for (var p2 = true, f2 = 0; f2 < l2; f2++)
                    if (o2(e2, c2 + f2) !== o2(t4, f2)) {
                      p2 = false;
                      break;
                    }
                  if (p2)
                    return c2;
                }
              return -1;
            }
            function w(e2, t4, n3, r2) {
              n3 = +n3 || 0;
              var a = e2.length - n3;
              r2 ? (r2 = +r2, r2 > a && (r2 = a)) : r2 = a;
              var o2 = t4.length;
              r2 > o2 / 2 && (r2 = o2 / 2);
              for (var d2, s2 = 0; s2 < r2; ++s2) {
                if (d2 = parseInt(t4.substr(2 * s2, 2), 16), X(d2))
                  return s2;
                e2[n3 + s2] = d2;
              }
              return s2;
            }
            function S(e2, t4, n3, r2) {
              return G(H(t4, e2.length - n3), e2, n3, r2);
            }
            function T(e2, t4, n3, r2) {
              return G(Y(t4), e2, n3, r2);
            }
            function v(e2, t4, n3, r2) {
              return T(e2, t4, n3, r2);
            }
            function k(e2, t4, n3, r2) {
              return G(z(t4), e2, n3, r2);
            }
            function L(e2, t4, n3, r2) {
              return G(V(t4, e2.length - n3), e2, n3, r2);
            }
            function A(e2, t4, n3) {
              return 0 === t4 && n3 === e2.length ? $.fromByteArray(e2) : $.fromByteArray(e2.slice(t4, n3));
            }
            function x(e2, t4, n3) {
              n3 = o(e2.length, n3);
              for (var r2 = [], a = t4; a < n3; ) {
                var d2 = e2[a], s2 = null, l2 = 239 < d2 ? 4 : 223 < d2 ? 3 : 191 < d2 ? 2 : 1;
                if (a + l2 <= n3) {
                  var c2, u2, p2, f2;
                  1 === l2 ? 128 > d2 && (s2 = d2) : 2 === l2 ? (c2 = e2[a + 1], 128 == (192 & c2) && (f2 = (31 & d2) << 6 | 63 & c2, 127 < f2 && (s2 = f2))) : 3 === l2 ? (c2 = e2[a + 1], u2 = e2[a + 2], 128 == (192 & c2) && 128 == (192 & u2) && (f2 = (15 & d2) << 12 | (63 & c2) << 6 | 63 & u2, 2047 < f2 && (55296 > f2 || 57343 < f2) && (s2 = f2))) : 4 === l2 ? (c2 = e2[a + 1], u2 = e2[a + 2], p2 = e2[a + 3], 128 == (192 & c2) && 128 == (192 & u2) && 128 == (192 & p2) && (f2 = (15 & d2) << 18 | (63 & c2) << 12 | (63 & u2) << 6 | 63 & p2, 65535 < f2 && 1114112 > f2 && (s2 = f2))) : void 0;
                }
                null === s2 ? (s2 = 65533, l2 = 1) : 65535 < s2 && (s2 -= 65536, r2.push(55296 | 1023 & s2 >>> 10), s2 = 56320 | 1023 & s2), r2.push(s2), a += l2;
              }
              return N(r2);
            }
            function N(e2) {
              var n3 = e2.length;
              if (n3 <= 4096)
                return t3.apply(String, e2);
              for (var r2 = "", a = 0; a < n3; )
                r2 += t3.apply(String, e2.slice(a, a += 4096));
              return r2;
            }
            function D(e2, n3, r2) {
              var a = "";
              r2 = o(e2.length, r2);
              for (var d2 = n3; d2 < r2; ++d2)
                a += t3(127 & e2[d2]);
              return a;
            }
            function I(e2, n3, r2) {
              var a = "";
              r2 = o(e2.length, r2);
              for (var d2 = n3; d2 < r2; ++d2)
                a += t3(e2[d2]);
              return a;
            }
            function P(e2, t4, n3) {
              var r2 = e2.length;
              (!t4 || 0 > t4) && (t4 = 0), (!n3 || 0 > n3 || n3 > r2) && (n3 = r2);
              for (var a = "", o2 = t4; o2 < n3; ++o2)
                a += W(e2[o2]);
              return a;
            }
            function M(e2, n3, r2) {
              for (var a = e2.slice(n3, r2), o2 = "", d2 = 0; d2 < a.length; d2 += 2)
                o2 += t3(a[d2] + 256 * a[d2 + 1]);
              return o2;
            }
            function O(e2, t4, n3) {
              if (0 != e2 % 1 || 0 > e2)
                throw new RangeError("offset is not uint");
              if (e2 + t4 > n3)
                throw new RangeError("Trying to access beyond buffer length");
            }
            function F(e2, t4, n3, r2, a, o2) {
              if (!s.isBuffer(e2))
                throw new TypeError('"buffer" argument must be a Buffer instance');
              if (t4 > a || t4 < o2)
                throw new RangeError('"value" argument is out of bounds');
              if (n3 + r2 > e2.length)
                throw new RangeError("Index out of range");
            }
            function B(e2, t4, n3, r2) {
              if (n3 + r2 > e2.length)
                throw new RangeError("Index out of range");
              if (0 > n3)
                throw new RangeError("Index out of range");
            }
            function U(e2, t4, n3, r2, a) {
              return t4 = +t4, n3 >>>= 0, a || B(e2, t4, n3, 4, 34028234663852886e22, -34028234663852886e22), J.write(e2, t4, n3, r2, 23, 4), n3 + 4;
            }
            function j(e2, t4, n3, r2, a) {
              return t4 = +t4, n3 >>>= 0, a || B(e2, t4, n3, 8, 17976931348623157e292, -17976931348623157e292), J.write(e2, t4, n3, r2, 52, 8), n3 + 8;
            }
            function q(e2) {
              if (e2 = e2.split("=")[0], e2 = e2.trim().replace(Q, ""), 2 > e2.length)
                return "";
              for (; 0 != e2.length % 4; )
                e2 += "=";
              return e2;
            }
            function W(e2) {
              return 16 > e2 ? "0" + e2.toString(16) : e2.toString(16);
            }
            function H(e2, t4) {
              t4 = t4 || 1 / 0;
              for (var n3, r2 = e2.length, a = null, o2 = [], d2 = 0; d2 < r2; ++d2) {
                if (n3 = e2.charCodeAt(d2), 55295 < n3 && 57344 > n3) {
                  if (!a) {
                    if (56319 < n3) {
                      -1 < (t4 -= 3) && o2.push(239, 191, 189);
                      continue;
                    } else if (d2 + 1 === r2) {
                      -1 < (t4 -= 3) && o2.push(239, 191, 189);
                      continue;
                    }
                    a = n3;
                    continue;
                  }
                  if (56320 > n3) {
                    -1 < (t4 -= 3) && o2.push(239, 191, 189), a = n3;
                    continue;
                  }
                  n3 = (a - 55296 << 10 | n3 - 56320) + 65536;
                } else
                  a && -1 < (t4 -= 3) && o2.push(239, 191, 189);
                if (a = null, 128 > n3) {
                  if (0 > (t4 -= 1))
                    break;
                  o2.push(n3);
                } else if (2048 > n3) {
                  if (0 > (t4 -= 2))
                    break;
                  o2.push(192 | n3 >> 6, 128 | 63 & n3);
                } else if (65536 > n3) {
                  if (0 > (t4 -= 3))
                    break;
                  o2.push(224 | n3 >> 12, 128 | 63 & n3 >> 6, 128 | 63 & n3);
                } else if (1114112 > n3) {
                  if (0 > (t4 -= 4))
                    break;
                  o2.push(240 | n3 >> 18, 128 | 63 & n3 >> 12, 128 | 63 & n3 >> 6, 128 | 63 & n3);
                } else
                  throw new Error("Invalid code point");
              }
              return o2;
            }
            function Y(e2) {
              for (var t4 = [], n3 = 0; n3 < e2.length; ++n3)
                t4.push(255 & e2.charCodeAt(n3));
              return t4;
            }
            function V(e2, t4) {
              for (var n3, r2, a, o2 = [], d2 = 0; d2 < e2.length && !(0 > (t4 -= 2)); ++d2)
                n3 = e2.charCodeAt(d2), r2 = n3 >> 8, a = n3 % 256, o2.push(a), o2.push(r2);
              return o2;
            }
            function z(e2) {
              return $.toByteArray(q(e2));
            }
            function G(e2, t4, n3, r2) {
              for (var a = 0; a < r2 && !(a + n3 >= t4.length || a >= e2.length); ++a)
                t4[a + n3] = e2[a];
              return a;
            }
            function K(e2, t4) {
              return e2 instanceof t4 || null != e2 && null != e2.constructor && null != e2.constructor.name && e2.constructor.name === t4.name;
            }
            function X(e2) {
              return e2 !== e2;
            }
            var $ = e("base64-js"), J = e("ieee754");
            n2.Buffer = s, n2.SlowBuffer = function(e2) {
              return +e2 != e2 && (e2 = 0), s.alloc(+e2);
            }, n2.INSPECT_MAX_BYTES = 50;
            n2.kMaxLength = 2147483647, s.TYPED_ARRAY_SUPPORT = function() {
              try {
                var e2 = new Uint8Array(1);
                return e2.__proto__ = { __proto__: Uint8Array.prototype, foo: function() {
                  return 42;
                } }, 42 === e2.foo();
              } catch (t4) {
                return false;
              }
            }(), s.TYPED_ARRAY_SUPPORT || "undefined" == typeof console || "function" != typeof console.error || console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."), Object.defineProperty(s.prototype, "parent", { enumerable: true, get: function() {
              return s.isBuffer(this) ? this.buffer : void 0;
            } }), Object.defineProperty(s.prototype, "offset", { enumerable: true, get: function() {
              return s.isBuffer(this) ? this.byteOffset : void 0;
            } }), "undefined" != typeof Symbol && null != Symbol.species && s[Symbol.species] === s && Object.defineProperty(s, Symbol.species, { value: null, configurable: true, enumerable: false, writable: false }), s.poolSize = 8192, s.from = function(e2, t4, n3) {
              return l(e2, t4, n3);
            }, s.prototype.__proto__ = Uint8Array.prototype, s.__proto__ = Uint8Array, s.alloc = function(e2, t4, n3) {
              return u(e2, t4, n3);
            }, s.allocUnsafe = function(e2) {
              return p(e2);
            }, s.allocUnsafeSlow = function(e2) {
              return p(e2);
            }, s.isBuffer = function(e2) {
              return null != e2 && true === e2._isBuffer && e2 !== s.prototype;
            }, s.compare = function(e2, t4) {
              if (K(e2, Uint8Array) && (e2 = s.from(e2, e2.offset, e2.byteLength)), K(t4, Uint8Array) && (t4 = s.from(t4, t4.offset, t4.byteLength)), !s.isBuffer(e2) || !s.isBuffer(t4))
                throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
              if (e2 === t4)
                return 0;
              for (var n3 = e2.length, r2 = t4.length, d2 = 0, l2 = o(n3, r2); d2 < l2; ++d2)
                if (e2[d2] !== t4[d2]) {
                  n3 = e2[d2], r2 = t4[d2];
                  break;
                }
              return n3 < r2 ? -1 : r2 < n3 ? 1 : 0;
            }, s.isEncoding = function(e2) {
              switch ((e2 + "").toLowerCase()) {
                case "hex":
                case "utf8":
                case "utf-8":
                case "ascii":
                case "latin1":
                case "binary":
                case "base64":
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return true;
                default:
                  return false;
              }
            }, s.concat = function(e2, t4) {
              if (!Array.isArray(e2))
                throw new TypeError('"list" argument must be an Array of Buffers');
              if (0 === e2.length)
                return s.alloc(0);
              var n3;
              if (t4 === void 0)
                for (t4 = 0, n3 = 0; n3 < e2.length; ++n3)
                  t4 += e2[n3].length;
              var r2 = s.allocUnsafe(t4), a = 0;
              for (n3 = 0; n3 < e2.length; ++n3) {
                var o2 = e2[n3];
                if (K(o2, Uint8Array) && (o2 = s.from(o2)), !s.isBuffer(o2))
                  throw new TypeError('"list" argument must be an Array of Buffers');
                o2.copy(r2, a), a += o2.length;
              }
              return r2;
            }, s.byteLength = b, s.prototype._isBuffer = true, s.prototype.swap16 = function() {
              var e2 = this.length;
              if (0 != e2 % 2)
                throw new RangeError("Buffer size must be a multiple of 16-bits");
              for (var t4 = 0; t4 < e2; t4 += 2)
                C(this, t4, t4 + 1);
              return this;
            }, s.prototype.swap32 = function() {
              var e2 = this.length;
              if (0 != e2 % 4)
                throw new RangeError("Buffer size must be a multiple of 32-bits");
              for (var t4 = 0; t4 < e2; t4 += 4)
                C(this, t4, t4 + 3), C(this, t4 + 1, t4 + 2);
              return this;
            }, s.prototype.swap64 = function() {
              var e2 = this.length;
              if (0 != e2 % 8)
                throw new RangeError("Buffer size must be a multiple of 64-bits");
              for (var t4 = 0; t4 < e2; t4 += 8)
                C(this, t4, t4 + 7), C(this, t4 + 1, t4 + 6), C(this, t4 + 2, t4 + 5), C(this, t4 + 3, t4 + 4);
              return this;
            }, s.prototype.toString = function() {
              var e2 = this.length;
              return 0 === e2 ? "" : 0 === arguments.length ? x(this, 0, e2) : y.apply(this, arguments);
            }, s.prototype.toLocaleString = s.prototype.toString, s.prototype.equals = function(e2) {
              if (!s.isBuffer(e2))
                throw new TypeError("Argument must be a Buffer");
              return this === e2 || 0 === s.compare(this, e2);
            }, s.prototype.inspect = function() {
              var e2 = "", t4 = n2.INSPECT_MAX_BYTES;
              return e2 = this.toString("hex", 0, t4).replace(/(.{2})/g, "$1 ").trim(), this.length > t4 && (e2 += " ... "), "<Buffer " + e2 + ">";
            }, s.prototype.compare = function(e2, t4, n3, r2, a) {
              if (K(e2, Uint8Array) && (e2 = s.from(e2, e2.offset, e2.byteLength)), !s.isBuffer(e2))
                throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof e2);
              if (void 0 === t4 && (t4 = 0), void 0 === n3 && (n3 = e2 ? e2.length : 0), void 0 === r2 && (r2 = 0), void 0 === a && (a = this.length), 0 > t4 || n3 > e2.length || 0 > r2 || a > this.length)
                throw new RangeError("out of range index");
              if (r2 >= a && t4 >= n3)
                return 0;
              if (r2 >= a)
                return -1;
              if (t4 >= n3)
                return 1;
              if (t4 >>>= 0, n3 >>>= 0, r2 >>>= 0, a >>>= 0, this === e2)
                return 0;
              for (var d2 = a - r2, l2 = n3 - t4, c2 = o(d2, l2), u2 = this.slice(r2, a), p2 = e2.slice(t4, n3), f2 = 0; f2 < c2; ++f2)
                if (u2[f2] !== p2[f2]) {
                  d2 = u2[f2], l2 = p2[f2];
                  break;
                }
              return d2 < l2 ? -1 : l2 < d2 ? 1 : 0;
            }, s.prototype.includes = function(e2, t4, n3) {
              return -1 !== this.indexOf(e2, t4, n3);
            }, s.prototype.indexOf = function(e2, t4, n3) {
              return R(this, e2, t4, n3, true);
            }, s.prototype.lastIndexOf = function(e2, t4, n3) {
              return R(this, e2, t4, n3, false);
            }, s.prototype.write = function(e2, t4, n3, r2) {
              if (void 0 === t4)
                r2 = "utf8", n3 = this.length, t4 = 0;
              else if (void 0 === n3 && "string" == typeof t4)
                r2 = t4, n3 = this.length, t4 = 0;
              else if (isFinite(t4))
                t4 >>>= 0, isFinite(n3) ? (n3 >>>= 0, void 0 === r2 && (r2 = "utf8")) : (r2 = n3, n3 = void 0);
              else
                throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
              var a = this.length - t4;
              if ((void 0 === n3 || n3 > a) && (n3 = a), 0 < e2.length && (0 > n3 || 0 > t4) || t4 > this.length)
                throw new RangeError("Attempt to write outside buffer bounds");
              r2 || (r2 = "utf8");
              for (var o2 = false; ; )
                switch (r2) {
                  case "hex":
                    return w(this, e2, t4, n3);
                  case "utf8":
                  case "utf-8":
                    return S(this, e2, t4, n3);
                  case "ascii":
                    return T(this, e2, t4, n3);
                  case "latin1":
                  case "binary":
                    return v(this, e2, t4, n3);
                  case "base64":
                    return k(this, e2, t4, n3);
                  case "ucs2":
                  case "ucs-2":
                  case "utf16le":
                  case "utf-16le":
                    return L(this, e2, t4, n3);
                  default:
                    if (o2)
                      throw new TypeError("Unknown encoding: " + r2);
                    r2 = ("" + r2).toLowerCase(), o2 = true;
                }
            }, s.prototype.toJSON = function() {
              return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
            };
            s.prototype.slice = function(e2, t4) {
              var n3 = this.length;
              e2 = ~~e2, t4 = t4 === void 0 ? n3 : ~~t4, 0 > e2 ? (e2 += n3, 0 > e2 && (e2 = 0)) : e2 > n3 && (e2 = n3), 0 > t4 ? (t4 += n3, 0 > t4 && (t4 = 0)) : t4 > n3 && (t4 = n3), t4 < e2 && (t4 = e2);
              var r2 = this.subarray(e2, t4);
              return r2.__proto__ = s.prototype, r2;
            }, s.prototype.readUIntLE = function(e2, t4, n3) {
              e2 >>>= 0, t4 >>>= 0, n3 || O(e2, t4, this.length);
              for (var r2 = this[e2], a = 1, o2 = 0; ++o2 < t4 && (a *= 256); )
                r2 += this[e2 + o2] * a;
              return r2;
            }, s.prototype.readUIntBE = function(e2, t4, n3) {
              e2 >>>= 0, t4 >>>= 0, n3 || O(e2, t4, this.length);
              for (var r2 = this[e2 + --t4], a = 1; 0 < t4 && (a *= 256); )
                r2 += this[e2 + --t4] * a;
              return r2;
            }, s.prototype.readUInt8 = function(e2, t4) {
              return e2 >>>= 0, t4 || O(e2, 1, this.length), this[e2];
            }, s.prototype.readUInt16LE = function(e2, t4) {
              return e2 >>>= 0, t4 || O(e2, 2, this.length), this[e2] | this[e2 + 1] << 8;
            }, s.prototype.readUInt16BE = function(e2, t4) {
              return e2 >>>= 0, t4 || O(e2, 2, this.length), this[e2] << 8 | this[e2 + 1];
            }, s.prototype.readUInt32LE = function(e2, t4) {
              return e2 >>>= 0, t4 || O(e2, 4, this.length), (this[e2] | this[e2 + 1] << 8 | this[e2 + 2] << 16) + 16777216 * this[e2 + 3];
            }, s.prototype.readUInt32BE = function(e2, t4) {
              return e2 >>>= 0, t4 || O(e2, 4, this.length), 16777216 * this[e2] + (this[e2 + 1] << 16 | this[e2 + 2] << 8 | this[e2 + 3]);
            }, s.prototype.readIntLE = function(e2, t4, n3) {
              e2 >>>= 0, t4 >>>= 0, n3 || O(e2, t4, this.length);
              for (var a = this[e2], o2 = 1, d2 = 0; ++d2 < t4 && (o2 *= 256); )
                a += this[e2 + d2] * o2;
              return o2 *= 128, a >= o2 && (a -= r(2, 8 * t4)), a;
            }, s.prototype.readIntBE = function(e2, t4, n3) {
              e2 >>>= 0, t4 >>>= 0, n3 || O(e2, t4, this.length);
              for (var a = t4, o2 = 1, d2 = this[e2 + --a]; 0 < a && (o2 *= 256); )
                d2 += this[e2 + --a] * o2;
              return o2 *= 128, d2 >= o2 && (d2 -= r(2, 8 * t4)), d2;
            }, s.prototype.readInt8 = function(e2, t4) {
              return e2 >>>= 0, t4 || O(e2, 1, this.length), 128 & this[e2] ? -1 * (255 - this[e2] + 1) : this[e2];
            }, s.prototype.readInt16LE = function(e2, t4) {
              e2 >>>= 0, t4 || O(e2, 2, this.length);
              var n3 = this[e2] | this[e2 + 1] << 8;
              return 32768 & n3 ? 4294901760 | n3 : n3;
            }, s.prototype.readInt16BE = function(e2, t4) {
              e2 >>>= 0, t4 || O(e2, 2, this.length);
              var n3 = this[e2 + 1] | this[e2] << 8;
              return 32768 & n3 ? 4294901760 | n3 : n3;
            }, s.prototype.readInt32LE = function(e2, t4) {
              return e2 >>>= 0, t4 || O(e2, 4, this.length), this[e2] | this[e2 + 1] << 8 | this[e2 + 2] << 16 | this[e2 + 3] << 24;
            }, s.prototype.readInt32BE = function(e2, t4) {
              return e2 >>>= 0, t4 || O(e2, 4, this.length), this[e2] << 24 | this[e2 + 1] << 16 | this[e2 + 2] << 8 | this[e2 + 3];
            }, s.prototype.readFloatLE = function(e2, t4) {
              return e2 >>>= 0, t4 || O(e2, 4, this.length), J.read(this, e2, true, 23, 4);
            }, s.prototype.readFloatBE = function(e2, t4) {
              return e2 >>>= 0, t4 || O(e2, 4, this.length), J.read(this, e2, false, 23, 4);
            }, s.prototype.readDoubleLE = function(e2, t4) {
              return e2 >>>= 0, t4 || O(e2, 8, this.length), J.read(this, e2, true, 52, 8);
            }, s.prototype.readDoubleBE = function(e2, t4) {
              return e2 >>>= 0, t4 || O(e2, 8, this.length), J.read(this, e2, false, 52, 8);
            }, s.prototype.writeUIntLE = function(e2, t4, n3, a) {
              if (e2 = +e2, t4 >>>= 0, n3 >>>= 0, !a) {
                var o2 = r(2, 8 * n3) - 1;
                F(this, e2, t4, n3, o2, 0);
              }
              var d2 = 1, s2 = 0;
              for (this[t4] = 255 & e2; ++s2 < n3 && (d2 *= 256); )
                this[t4 + s2] = 255 & e2 / d2;
              return t4 + n3;
            }, s.prototype.writeUIntBE = function(e2, t4, n3, a) {
              if (e2 = +e2, t4 >>>= 0, n3 >>>= 0, !a) {
                var o2 = r(2, 8 * n3) - 1;
                F(this, e2, t4, n3, o2, 0);
              }
              var d2 = n3 - 1, s2 = 1;
              for (this[t4 + d2] = 255 & e2; 0 <= --d2 && (s2 *= 256); )
                this[t4 + d2] = 255 & e2 / s2;
              return t4 + n3;
            }, s.prototype.writeUInt8 = function(e2, t4, n3) {
              return e2 = +e2, t4 >>>= 0, n3 || F(this, e2, t4, 1, 255, 0), this[t4] = 255 & e2, t4 + 1;
            }, s.prototype.writeUInt16LE = function(e2, t4, n3) {
              return e2 = +e2, t4 >>>= 0, n3 || F(this, e2, t4, 2, 65535, 0), this[t4] = 255 & e2, this[t4 + 1] = e2 >>> 8, t4 + 2;
            }, s.prototype.writeUInt16BE = function(e2, t4, n3) {
              return e2 = +e2, t4 >>>= 0, n3 || F(this, e2, t4, 2, 65535, 0), this[t4] = e2 >>> 8, this[t4 + 1] = 255 & e2, t4 + 2;
            }, s.prototype.writeUInt32LE = function(e2, t4, n3) {
              return e2 = +e2, t4 >>>= 0, n3 || F(this, e2, t4, 4, 4294967295, 0), this[t4 + 3] = e2 >>> 24, this[t4 + 2] = e2 >>> 16, this[t4 + 1] = e2 >>> 8, this[t4] = 255 & e2, t4 + 4;
            }, s.prototype.writeUInt32BE = function(e2, t4, n3) {
              return e2 = +e2, t4 >>>= 0, n3 || F(this, e2, t4, 4, 4294967295, 0), this[t4] = e2 >>> 24, this[t4 + 1] = e2 >>> 16, this[t4 + 2] = e2 >>> 8, this[t4 + 3] = 255 & e2, t4 + 4;
            }, s.prototype.writeIntLE = function(e2, t4, n3, a) {
              if (e2 = +e2, t4 >>>= 0, !a) {
                var o2 = r(2, 8 * n3 - 1);
                F(this, e2, t4, n3, o2 - 1, -o2);
              }
              var d2 = 0, s2 = 1, l2 = 0;
              for (this[t4] = 255 & e2; ++d2 < n3 && (s2 *= 256); )
                0 > e2 && 0 === l2 && 0 !== this[t4 + d2 - 1] && (l2 = 1), this[t4 + d2] = 255 & (e2 / s2 >> 0) - l2;
              return t4 + n3;
            }, s.prototype.writeIntBE = function(e2, t4, n3, a) {
              if (e2 = +e2, t4 >>>= 0, !a) {
                var o2 = r(2, 8 * n3 - 1);
                F(this, e2, t4, n3, o2 - 1, -o2);
              }
              var d2 = n3 - 1, s2 = 1, l2 = 0;
              for (this[t4 + d2] = 255 & e2; 0 <= --d2 && (s2 *= 256); )
                0 > e2 && 0 === l2 && 0 !== this[t4 + d2 + 1] && (l2 = 1), this[t4 + d2] = 255 & (e2 / s2 >> 0) - l2;
              return t4 + n3;
            }, s.prototype.writeInt8 = function(e2, t4, n3) {
              return e2 = +e2, t4 >>>= 0, n3 || F(this, e2, t4, 1, 127, -128), 0 > e2 && (e2 = 255 + e2 + 1), this[t4] = 255 & e2, t4 + 1;
            }, s.prototype.writeInt16LE = function(e2, t4, n3) {
              return e2 = +e2, t4 >>>= 0, n3 || F(this, e2, t4, 2, 32767, -32768), this[t4] = 255 & e2, this[t4 + 1] = e2 >>> 8, t4 + 2;
            }, s.prototype.writeInt16BE = function(e2, t4, n3) {
              return e2 = +e2, t4 >>>= 0, n3 || F(this, e2, t4, 2, 32767, -32768), this[t4] = e2 >>> 8, this[t4 + 1] = 255 & e2, t4 + 2;
            }, s.prototype.writeInt32LE = function(e2, t4, n3) {
              return e2 = +e2, t4 >>>= 0, n3 || F(this, e2, t4, 4, 2147483647, -2147483648), this[t4] = 255 & e2, this[t4 + 1] = e2 >>> 8, this[t4 + 2] = e2 >>> 16, this[t4 + 3] = e2 >>> 24, t4 + 4;
            }, s.prototype.writeInt32BE = function(e2, t4, n3) {
              return e2 = +e2, t4 >>>= 0, n3 || F(this, e2, t4, 4, 2147483647, -2147483648), 0 > e2 && (e2 = 4294967295 + e2 + 1), this[t4] = e2 >>> 24, this[t4 + 1] = e2 >>> 16, this[t4 + 2] = e2 >>> 8, this[t4 + 3] = 255 & e2, t4 + 4;
            }, s.prototype.writeFloatLE = function(e2, t4, n3) {
              return U(this, e2, t4, true, n3);
            }, s.prototype.writeFloatBE = function(e2, t4, n3) {
              return U(this, e2, t4, false, n3);
            }, s.prototype.writeDoubleLE = function(e2, t4, n3) {
              return j(this, e2, t4, true, n3);
            }, s.prototype.writeDoubleBE = function(e2, t4, n3) {
              return j(this, e2, t4, false, n3);
            }, s.prototype.copy = function(e2, t4, n3, r2) {
              if (!s.isBuffer(e2))
                throw new TypeError("argument should be a Buffer");
              if (n3 || (n3 = 0), r2 || 0 === r2 || (r2 = this.length), t4 >= e2.length && (t4 = e2.length), t4 || (t4 = 0), 0 < r2 && r2 < n3 && (r2 = n3), r2 === n3)
                return 0;
              if (0 === e2.length || 0 === this.length)
                return 0;
              if (0 > t4)
                throw new RangeError("targetStart out of bounds");
              if (0 > n3 || n3 >= this.length)
                throw new RangeError("Index out of range");
              if (0 > r2)
                throw new RangeError("sourceEnd out of bounds");
              r2 > this.length && (r2 = this.length), e2.length - t4 < r2 - n3 && (r2 = e2.length - t4 + n3);
              var a = r2 - n3;
              if (this === e2 && "function" == typeof Uint8Array.prototype.copyWithin)
                this.copyWithin(t4, n3, r2);
              else if (this === e2 && n3 < t4 && t4 < r2)
                for (var o2 = a - 1; 0 <= o2; --o2)
                  e2[o2 + t4] = this[o2 + n3];
              else
                Uint8Array.prototype.set.call(e2, this.subarray(n3, r2), t4);
              return a;
            }, s.prototype.fill = function(e2, t4, n3, r2) {
              if ("string" == typeof e2) {
                if ("string" == typeof t4 ? (r2 = t4, t4 = 0, n3 = this.length) : "string" == typeof n3 && (r2 = n3, n3 = this.length), void 0 !== r2 && "string" != typeof r2)
                  throw new TypeError("encoding must be a string");
                if ("string" == typeof r2 && !s.isEncoding(r2))
                  throw new TypeError("Unknown encoding: " + r2);
                if (1 === e2.length) {
                  var a = e2.charCodeAt(0);
                  ("utf8" === r2 && 128 > a || "latin1" === r2) && (e2 = a);
                }
              } else
                "number" == typeof e2 && (e2 &= 255);
              if (0 > t4 || this.length < t4 || this.length < n3)
                throw new RangeError("Out of range index");
              if (n3 <= t4)
                return this;
              t4 >>>= 0, n3 = n3 === void 0 ? this.length : n3 >>> 0, e2 || (e2 = 0);
              var o2;
              if ("number" == typeof e2)
                for (o2 = t4; o2 < n3; ++o2)
                  this[o2] = e2;
              else {
                var d2 = s.isBuffer(e2) ? e2 : s.from(e2, r2), l2 = d2.length;
                if (0 === l2)
                  throw new TypeError('The value "' + e2 + '" is invalid for argument "value"');
                for (o2 = 0; o2 < n3 - t4; ++o2)
                  this[o2 + t4] = d2[o2 % l2];
              }
              return this;
            };
            var Q = /[^+/0-9A-Za-z-_]/g;
          }).call(this);
        }).call(this, e("buffer").Buffer);
      }, { "base64-js": 1, buffer: 3, ieee754: 9 }], 4: [function(e, t2, n2) {
        (function(a) {
          (function() {
            function r2() {
              let e2;
              try {
                e2 = n2.storage.getItem("debug");
              } catch (e3) {
              }
              return !e2 && "undefined" != typeof a && "env" in a && (e2 = a.env.DEBUG), e2;
            }
            n2.formatArgs = function(e2) {
              if (e2[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + e2[0] + (this.useColors ? "%c " : " ") + "+" + t2.exports.humanize(this.diff), !this.useColors)
                return;
              const n3 = "color: " + this.color;
              e2.splice(1, 0, n3, "color: inherit");
              let r3 = 0, a2 = 0;
              e2[0].replace(/%[a-zA-Z%]/g, (e3) => {
                "%%" === e3 || (r3++, "%c" === e3 && (a2 = r3));
              }), e2.splice(a2, 0, n3);
            }, n2.save = function(e2) {
              try {
                e2 ? n2.storage.setItem("debug", e2) : n2.storage.removeItem("debug");
              } catch (e3) {
              }
            }, n2.load = r2, n2.useColors = function() {
              return !!("undefined" != typeof window && window.process && ("renderer" === window.process.type || window.process.__nwjs)) || !("undefined" != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) && ("undefined" != typeof document && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || "undefined" != typeof window && window.console && (window.console.firebug || window.console.exception && window.console.table) || "undefined" != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && 31 <= parseInt(RegExp.$1, 10) || "undefined" != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
            }, n2.storage = function() {
              try {
                return localStorage;
              } catch (e2) {
              }
            }(), n2.destroy = (() => {
              let e2 = false;
              return () => {
                e2 || (e2 = true, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
              };
            })(), n2.colors = ["#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33"], n2.log = console.debug || console.log || (() => {
            }), t2.exports = e("./common")(n2);
            const { formatters: o } = t2.exports;
            o.j = function(e2) {
              try {
                return JSON.stringify(e2);
              } catch (e3) {
                return "[UnexpectedJSONParseError]: " + e3.message;
              }
            };
          }).call(this);
        }).call(this, e("_process"));
      }, { "./common": 5, _process: 12 }], 5: [function(e, t2) {
        t2.exports = function(t3) {
          function r2(e2) {
            function t4(...e3) {
              if (!t4.enabled)
                return;
              const a2 = t4, o3 = +new Date(), i = o3 - (n2 || o3);
              a2.diff = i, a2.prev = n2, a2.curr = o3, n2 = o3, e3[0] = r2.coerce(e3[0]), "string" != typeof e3[0] && e3.unshift("%O");
              let d = 0;
              e3[0] = e3[0].replace(/%([a-zA-Z%])/g, (t5, n3) => {
                if ("%%" === t5)
                  return "%";
                d++;
                const o4 = r2.formatters[n3];
                if ("function" == typeof o4) {
                  const n4 = e3[d];
                  t5 = o4.call(a2, n4), e3.splice(d, 1), d--;
                }
                return t5;
              }), r2.formatArgs.call(a2, e3);
              const s = a2.log || r2.log;
              s.apply(a2, e3);
            }
            let n2, o2 = null;
            return t4.namespace = e2, t4.useColors = r2.useColors(), t4.color = r2.selectColor(e2), t4.extend = a, t4.destroy = r2.destroy, Object.defineProperty(t4, "enabled", { enumerable: true, configurable: false, get: () => null === o2 ? r2.enabled(e2) : o2, set: (e3) => {
              o2 = e3;
            } }), "function" == typeof r2.init && r2.init(t4), t4;
          }
          function a(e2, t4) {
            const n2 = r2(this.namespace + ("undefined" == typeof t4 ? ":" : t4) + e2);
            return n2.log = this.log, n2;
          }
          function o(e2) {
            return e2.toString().substring(2, e2.toString().length - 2).replace(/\.\*\?$/, "*");
          }
          return r2.debug = r2, r2.default = r2, r2.coerce = function(e2) {
            return e2 instanceof Error ? e2.stack || e2.message : e2;
          }, r2.disable = function() {
            const e2 = [...r2.names.map(o), ...r2.skips.map(o).map((e3) => "-" + e3)].join(",");
            return r2.enable(""), e2;
          }, r2.enable = function(e2) {
            r2.save(e2), r2.names = [], r2.skips = [];
            let t4;
            const n2 = ("string" == typeof e2 ? e2 : "").split(/[\s,]+/), a2 = n2.length;
            for (t4 = 0; t4 < a2; t4++)
              n2[t4] && (e2 = n2[t4].replace(/\*/g, ".*?"), "-" === e2[0] ? r2.skips.push(new RegExp("^" + e2.substr(1) + "$")) : r2.names.push(new RegExp("^" + e2 + "$")));
          }, r2.enabled = function(e2) {
            if ("*" === e2[e2.length - 1])
              return true;
            let t4, n2;
            for (t4 = 0, n2 = r2.skips.length; t4 < n2; t4++)
              if (r2.skips[t4].test(e2))
                return false;
            for (t4 = 0, n2 = r2.names.length; t4 < n2; t4++)
              if (r2.names[t4].test(e2))
                return true;
            return false;
          }, r2.humanize = e("ms"), r2.destroy = function() {
            console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
          }, Object.keys(t3).forEach((e2) => {
            r2[e2] = t3[e2];
          }), r2.names = [], r2.skips = [], r2.formatters = {}, r2.selectColor = function(e2) {
            let t4 = 0;
            for (let n2 = 0; n2 < e2.length; n2++)
              t4 = (t4 << 5) - t4 + e2.charCodeAt(n2), t4 |= 0;
            return r2.colors[n(t4) % r2.colors.length];
          }, r2.enable(r2.load()), r2;
        };
      }, { ms: 11 }], 6: [function(e, t2) {
        "use strict";
        function n2(e2, t3) {
          for (const n3 in t3)
            Object.defineProperty(e2, n3, { value: t3[n3], enumerable: true, configurable: true });
          return e2;
        }
        t2.exports = function(e2, t3, r2) {
          if (!e2 || "string" == typeof e2)
            throw new TypeError("Please pass an Error to err-code");
          r2 || (r2 = {}), "object" == typeof t3 && (r2 = t3, t3 = ""), t3 && (r2.code = t3);
          try {
            return n2(e2, r2);
          } catch (t4) {
            r2.message = e2.message, r2.stack = e2.stack;
            const a = function() {
            };
            a.prototype = Object.create(Object.getPrototypeOf(e2));
            const o = n2(new a(), r2);
            return o;
          }
        };
      }, {}], 7: [function(e, t2) {
        "use strict";
        function n2(e2) {
          console && console.warn && console.warn(e2);
        }
        function r2() {
          r2.init.call(this);
        }
        function a(e2) {
          if ("function" != typeof e2)
            throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof e2);
        }
        function o(e2) {
          return void 0 === e2._maxListeners ? r2.defaultMaxListeners : e2._maxListeners;
        }
        function i(e2, t3, r3, i2) {
          var d2, s2, l2;
          if (a(r3), s2 = e2._events, void 0 === s2 ? (s2 = e2._events = /* @__PURE__ */ Object.create(null), e2._eventsCount = 0) : (void 0 !== s2.newListener && (e2.emit("newListener", t3, r3.listener ? r3.listener : r3), s2 = e2._events), l2 = s2[t3]), void 0 === l2)
            l2 = s2[t3] = r3, ++e2._eventsCount;
          else if ("function" == typeof l2 ? l2 = s2[t3] = i2 ? [r3, l2] : [l2, r3] : i2 ? l2.unshift(r3) : l2.push(r3), d2 = o(e2), 0 < d2 && l2.length > d2 && !l2.warned) {
            l2.warned = true;
            var c2 = new Error("Possible EventEmitter memory leak detected. " + l2.length + " " + (t3 + " listeners added. Use emitter.setMaxListeners() to increase limit"));
            c2.name = "MaxListenersExceededWarning", c2.emitter = e2, c2.type = t3, c2.count = l2.length, n2(c2);
          }
          return e2;
        }
        function d() {
          if (!this.fired)
            return this.target.removeListener(this.type, this.wrapFn), this.fired = true, 0 === arguments.length ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
        }
        function s(e2, t3, n3) {
          var r3 = { fired: false, wrapFn: void 0, target: e2, type: t3, listener: n3 }, a2 = d.bind(r3);
          return a2.listener = n3, r3.wrapFn = a2, a2;
        }
        function l(e2, t3, n3) {
          var r3 = e2._events;
          if (r3 === void 0)
            return [];
          var a2 = r3[t3];
          return void 0 === a2 ? [] : "function" == typeof a2 ? n3 ? [a2.listener || a2] : [a2] : n3 ? f(a2) : u(a2, a2.length);
        }
        function c(e2) {
          var t3 = this._events;
          if (t3 !== void 0) {
            var n3 = t3[e2];
            if ("function" == typeof n3)
              return 1;
            if (void 0 !== n3)
              return n3.length;
          }
          return 0;
        }
        function u(e2, t3) {
          for (var n3 = Array(t3), r3 = 0; r3 < t3; ++r3)
            n3[r3] = e2[r3];
          return n3;
        }
        function p(e2, t3) {
          for (; t3 + 1 < e2.length; t3++)
            e2[t3] = e2[t3 + 1];
          e2.pop();
        }
        function f(e2) {
          for (var t3 = Array(e2.length), n3 = 0; n3 < t3.length; ++n3)
            t3[n3] = e2[n3].listener || e2[n3];
          return t3;
        }
        function g(e2, t3, n3) {
          "function" == typeof e2.on && _(e2, "error", t3, n3);
        }
        function _(e2, t3, n3, r3) {
          if ("function" == typeof e2.on)
            r3.once ? e2.once(t3, n3) : e2.on(t3, n3);
          else if ("function" == typeof e2.addEventListener)
            e2.addEventListener(t3, function a2(o2) {
              r3.once && e2.removeEventListener(t3, a2), n3(o2);
            });
          else
            throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof e2);
        }
        var h, m = "object" == typeof Reflect ? Reflect : null, b = m && "function" == typeof m.apply ? m.apply : function(e2, t3, n3) {
          return Function.prototype.apply.call(e2, t3, n3);
        };
        h = m && "function" == typeof m.ownKeys ? m.ownKeys : Object.getOwnPropertySymbols ? function(e2) {
          return Object.getOwnPropertyNames(e2).concat(Object.getOwnPropertySymbols(e2));
        } : function(e2) {
          return Object.getOwnPropertyNames(e2);
        };
        var y = Number.isNaN || function(e2) {
          return e2 !== e2;
        };
        t2.exports = r2, t2.exports.once = function(e2, t3) {
          return new Promise(function(n3, r3) {
            function a2(n4) {
              e2.removeListener(t3, o2), r3(n4);
            }
            function o2() {
              "function" == typeof e2.removeListener && e2.removeListener("error", a2), n3([].slice.call(arguments));
            }
            _(e2, t3, o2, { once: true }), "error" !== t3 && g(e2, a2, { once: true });
          });
        }, r2.EventEmitter = r2, r2.prototype._events = void 0, r2.prototype._eventsCount = 0, r2.prototype._maxListeners = void 0;
        var C = 10;
        Object.defineProperty(r2, "defaultMaxListeners", { enumerable: true, get: function() {
          return C;
        }, set: function(e2) {
          if ("number" != typeof e2 || 0 > e2 || y(e2))
            throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + e2 + ".");
          C = e2;
        } }), r2.init = function() {
          (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
        }, r2.prototype.setMaxListeners = function(e2) {
          if ("number" != typeof e2 || 0 > e2 || y(e2))
            throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e2 + ".");
          return this._maxListeners = e2, this;
        }, r2.prototype.getMaxListeners = function() {
          return o(this);
        }, r2.prototype.emit = function(e2) {
          for (var t3 = [], n3 = 1; n3 < arguments.length; n3++)
            t3.push(arguments[n3]);
          var r3 = "error" === e2, a2 = this._events;
          if (a2 !== void 0)
            r3 = r3 && a2.error === void 0;
          else if (!r3)
            return false;
          if (r3) {
            var o2;
            if (0 < t3.length && (o2 = t3[0]), o2 instanceof Error)
              throw o2;
            var d2 = new Error("Unhandled error." + (o2 ? " (" + o2.message + ")" : ""));
            throw d2.context = o2, d2;
          }
          var s2 = a2[e2];
          if (s2 === void 0)
            return false;
          if ("function" == typeof s2)
            b(s2, this, t3);
          else
            for (var l2 = s2.length, c2 = u(s2, l2), n3 = 0; n3 < l2; ++n3)
              b(c2[n3], this, t3);
          return true;
        }, r2.prototype.addListener = function(e2, t3) {
          return i(this, e2, t3, false);
        }, r2.prototype.on = r2.prototype.addListener, r2.prototype.prependListener = function(e2, t3) {
          return i(this, e2, t3, true);
        }, r2.prototype.once = function(e2, t3) {
          return a(t3), this.on(e2, s(this, e2, t3)), this;
        }, r2.prototype.prependOnceListener = function(e2, t3) {
          return a(t3), this.prependListener(e2, s(this, e2, t3)), this;
        }, r2.prototype.removeListener = function(e2, t3) {
          var n3, r3, o2, d2, s2;
          if (a(t3), r3 = this._events, void 0 === r3)
            return this;
          if (n3 = r3[e2], void 0 === n3)
            return this;
          if (n3 === t3 || n3.listener === t3)
            0 == --this._eventsCount ? this._events = /* @__PURE__ */ Object.create(null) : (delete r3[e2], r3.removeListener && this.emit("removeListener", e2, n3.listener || t3));
          else if ("function" != typeof n3) {
            for (o2 = -1, d2 = n3.length - 1; 0 <= d2; d2--)
              if (n3[d2] === t3 || n3[d2].listener === t3) {
                s2 = n3[d2].listener, o2 = d2;
                break;
              }
            if (0 > o2)
              return this;
            0 === o2 ? n3.shift() : p(n3, o2), 1 === n3.length && (r3[e2] = n3[0]), void 0 !== r3.removeListener && this.emit("removeListener", e2, s2 || t3);
          }
          return this;
        }, r2.prototype.off = r2.prototype.removeListener, r2.prototype.removeAllListeners = function(e2) {
          var t3, n3, r3;
          if (n3 = this._events, void 0 === n3)
            return this;
          if (void 0 === n3.removeListener)
            return 0 === arguments.length ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : void 0 !== n3[e2] && (0 == --this._eventsCount ? this._events = /* @__PURE__ */ Object.create(null) : delete n3[e2]), this;
          if (0 === arguments.length) {
            var a2, o2 = Object.keys(n3);
            for (r3 = 0; r3 < o2.length; ++r3)
              a2 = o2[r3], "removeListener" !== a2 && this.removeAllListeners(a2);
            return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
          }
          if (t3 = n3[e2], "function" == typeof t3)
            this.removeListener(e2, t3);
          else if (void 0 !== t3)
            for (r3 = t3.length - 1; 0 <= r3; r3--)
              this.removeListener(e2, t3[r3]);
          return this;
        }, r2.prototype.listeners = function(e2) {
          return l(this, e2, true);
        }, r2.prototype.rawListeners = function(e2) {
          return l(this, e2, false);
        }, r2.listenerCount = function(e2, t3) {
          return "function" == typeof e2.listenerCount ? e2.listenerCount(t3) : c.call(e2, t3);
        }, r2.prototype.listenerCount = c, r2.prototype.eventNames = function() {
          return 0 < this._eventsCount ? h(this._events) : [];
        };
      }, {}], 8: [function(e, t2) {
        t2.exports = function() {
          if ("undefined" == typeof globalThis)
            return null;
          var e2 = { RTCPeerConnection: globalThis.RTCPeerConnection || globalThis.mozRTCPeerConnection || globalThis.webkitRTCPeerConnection, RTCSessionDescription: globalThis.RTCSessionDescription || globalThis.mozRTCSessionDescription || globalThis.webkitRTCSessionDescription, RTCIceCandidate: globalThis.RTCIceCandidate || globalThis.mozRTCIceCandidate || globalThis.webkitRTCIceCandidate };
          return e2.RTCPeerConnection ? e2 : null;
        };
      }, {}], 9: [function(e, a, o) {
        o.read = function(t2, n2, a2, o2, l) {
          var c, u, p = 8 * l - o2 - 1, f = (1 << p) - 1, g = f >> 1, _ = -7, h = a2 ? l - 1 : 0, b = a2 ? -1 : 1, d = t2[n2 + h];
          for (h += b, c = d & (1 << -_) - 1, d >>= -_, _ += p; 0 < _; c = 256 * c + t2[n2 + h], h += b, _ -= 8)
            ;
          for (u = c & (1 << -_) - 1, c >>= -_, _ += o2; 0 < _; u = 256 * u + t2[n2 + h], h += b, _ -= 8)
            ;
          if (0 === c)
            c = 1 - g;
          else {
            if (c === f)
              return u ? NaN : (d ? -1 : 1) * (1 / 0);
            u += r(2, o2), c -= g;
          }
          return (d ? -1 : 1) * u * r(2, c - o2);
        }, o.write = function(a2, o2, l, u, p, f) {
          var h, b, y, g = Math.LN2, _ = Math.log, C = 8 * f - p - 1, R = (1 << C) - 1, E = R >> 1, w = 23 === p ? r(2, -24) - r(2, -77) : 0, S = u ? 0 : f - 1, T = u ? 1 : -1, d = 0 > o2 || 0 === o2 && 0 > 1 / o2 ? 1 : 0;
          for (o2 = n(o2), isNaN(o2) || o2 === 1 / 0 ? (b = isNaN(o2) ? 1 : 0, h = R) : (h = t(_(o2) / g), 1 > o2 * (y = r(2, -h)) && (h--, y *= 2), o2 += 1 <= h + E ? w / y : w * r(2, 1 - E), 2 <= o2 * y && (h++, y /= 2), h + E >= R ? (b = 0, h = R) : 1 <= h + E ? (b = (o2 * y - 1) * r(2, p), h += E) : (b = o2 * r(2, E - 1) * r(2, p), h = 0)); 8 <= p; a2[l + S] = 255 & b, S += T, b /= 256, p -= 8)
            ;
          for (h = h << p | b, C += p; 0 < C; a2[l + S] = 255 & h, S += T, h /= 256, C -= 8)
            ;
          a2[l + S - T] |= 128 * d;
        };
      }, {}], 10: [function(e, t2) {
        t2.exports = "function" == typeof Object.create ? function(e2, t3) {
          t3 && (e2.super_ = t3, e2.prototype = Object.create(t3.prototype, { constructor: { value: e2, enumerable: false, writable: true, configurable: true } }));
        } : function(e2, t3) {
          if (t3) {
            e2.super_ = t3;
            var n2 = function() {
            };
            n2.prototype = t3.prototype, e2.prototype = new n2(), e2.prototype.constructor = e2;
          }
        };
      }, {}], 11: [function(e, t2) {
        var r2 = Math.round;
        function a(e2) {
          if (e2 += "", !(100 < e2.length)) {
            var t3 = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(e2);
            if (t3) {
              var r3 = parseFloat(t3[1]), n2 = (t3[2] || "ms").toLowerCase();
              return "years" === n2 || "year" === n2 || "yrs" === n2 || "yr" === n2 || "y" === n2 ? 315576e5 * r3 : "weeks" === n2 || "week" === n2 || "w" === n2 ? 6048e5 * r3 : "days" === n2 || "day" === n2 || "d" === n2 ? 864e5 * r3 : "hours" === n2 || "hour" === n2 || "hrs" === n2 || "hr" === n2 || "h" === n2 ? 36e5 * r3 : "minutes" === n2 || "minute" === n2 || "mins" === n2 || "min" === n2 || "m" === n2 ? 6e4 * r3 : "seconds" === n2 || "second" === n2 || "secs" === n2 || "sec" === n2 || "s" === n2 ? 1e3 * r3 : "milliseconds" === n2 || "millisecond" === n2 || "msecs" === n2 || "msec" === n2 || "ms" === n2 ? r3 : void 0;
            }
          }
        }
        function o(e2) {
          var t3 = n(e2);
          return 864e5 <= t3 ? r2(e2 / 864e5) + "d" : 36e5 <= t3 ? r2(e2 / 36e5) + "h" : 6e4 <= t3 ? r2(e2 / 6e4) + "m" : 1e3 <= t3 ? r2(e2 / 1e3) + "s" : e2 + "ms";
        }
        function i(e2) {
          var t3 = n(e2);
          return 864e5 <= t3 ? s(e2, t3, 864e5, "day") : 36e5 <= t3 ? s(e2, t3, 36e5, "hour") : 6e4 <= t3 ? s(e2, t3, 6e4, "minute") : 1e3 <= t3 ? s(e2, t3, 1e3, "second") : e2 + " ms";
        }
        function s(e2, t3, a2, n2) {
          return r2(e2 / a2) + " " + n2 + (t3 >= 1.5 * a2 ? "s" : "");
        }
        var l = 24 * (60 * 6e4);
        t2.exports = function(e2, t3) {
          t3 = t3 || {};
          var n2 = typeof e2;
          if ("string" == n2 && 0 < e2.length)
            return a(e2);
          if ("number" === n2 && isFinite(e2))
            return t3.long ? i(e2) : o(e2);
          throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(e2));
        };
      }, {}], 12: [function(e, t2) {
        function n2() {
          throw new Error("setTimeout has not been defined");
        }
        function r2() {
          throw new Error("clearTimeout has not been defined");
        }
        function a(t3) {
          if (c === setTimeout)
            return setTimeout(t3, 0);
          if ((c === n2 || !c) && setTimeout)
            return c = setTimeout, setTimeout(t3, 0);
          try {
            return c(t3, 0);
          } catch (n3) {
            try {
              return c.call(null, t3, 0);
            } catch (n4) {
              return c.call(this, t3, 0);
            }
          }
        }
        function o(t3) {
          if (u === clearTimeout)
            return clearTimeout(t3);
          if ((u === r2 || !u) && clearTimeout)
            return u = clearTimeout, clearTimeout(t3);
          try {
            return u(t3);
          } catch (n3) {
            try {
              return u.call(null, t3);
            } catch (n4) {
              return u.call(this, t3);
            }
          }
        }
        function i() {
          _ && f && (_ = false, f.length ? g = f.concat(g) : h = -1, g.length && d());
        }
        function d() {
          if (!_) {
            var e2 = a(i);
            _ = true;
            for (var t3 = g.length; t3; ) {
              for (f = g, g = []; ++h < t3; )
                f && f[h].run();
              h = -1, t3 = g.length;
            }
            f = null, _ = false, o(e2);
          }
        }
        function s(e2, t3) {
          this.fun = e2, this.array = t3;
        }
        function l() {
        }
        var c, u, p = t2.exports = {};
        (function() {
          try {
            c = "function" == typeof setTimeout ? setTimeout : n2;
          } catch (t3) {
            c = n2;
          }
          try {
            u = "function" == typeof clearTimeout ? clearTimeout : r2;
          } catch (t3) {
            u = r2;
          }
        })();
        var f, g = [], _ = false, h = -1;
        p.nextTick = function(e2) {
          var t3 = Array(arguments.length - 1);
          if (1 < arguments.length)
            for (var n3 = 1; n3 < arguments.length; n3++)
              t3[n3 - 1] = arguments[n3];
          g.push(new s(e2, t3)), 1 !== g.length || _ || a(d);
        }, s.prototype.run = function() {
          this.fun.apply(null, this.array);
        }, p.title = "browser", p.browser = true, p.env = {}, p.argv = [], p.version = "", p.versions = {}, p.on = l, p.addListener = l, p.once = l, p.off = l, p.removeListener = l, p.removeAllListeners = l, p.emit = l, p.prependListener = l, p.prependOnceListener = l, p.listeners = function() {
          return [];
        }, p.binding = function() {
          throw new Error("process.binding is not supported");
        }, p.cwd = function() {
          return "/";
        }, p.chdir = function() {
          throw new Error("process.chdir is not supported");
        }, p.umask = function() {
          return 0;
        };
      }, {}], 13: [function(e, t2) {
        (function(e2) {
          (function() {
            let n2;
            t2.exports = "function" == typeof queueMicrotask ? queueMicrotask.bind("undefined" == typeof window ? e2 : window) : (e3) => (n2 || (n2 = Promise.resolve())).then(e3).catch((e4) => setTimeout(() => {
              throw e4;
            }, 0));
          }).call(this);
        }).call(this, "undefined" == typeof global ? "undefined" == typeof self ? "undefined" == typeof window ? {} : window : self : global);
      }, {}], 14: [function(e, t2) {
        (function(n2, r2) {
          (function() {
            "use strict";
            var a = e("safe-buffer").Buffer, o = r2.crypto || r2.msCrypto;
            t2.exports = o && o.getRandomValues ? function(e2, t3) {
              if (e2 > 4294967295)
                throw new RangeError("requested too many random bytes");
              var r3 = a.allocUnsafe(e2);
              if (0 < e2)
                if (65536 < e2)
                  for (var i = 0; i < e2; i += 65536)
                    o.getRandomValues(r3.slice(i, i + 65536));
                else
                  o.getRandomValues(r3);
              return "function" == typeof t3 ? n2.nextTick(function() {
                t3(null, r3);
              }) : r3;
            } : function() {
              throw new Error("Secure random number generation is not supported by this browser.\nUse Chrome, Firefox or Internet Explorer 11");
            };
          }).call(this);
        }).call(this, e("_process"), "undefined" == typeof global ? "undefined" == typeof self ? "undefined" == typeof window ? {} : window : self : global);
      }, { _process: 12, "safe-buffer": 30 }], 15: [function(e, t2) {
        "use strict";
        function n2(e2, t3) {
          e2.prototype = Object.create(t3.prototype), e2.prototype.constructor = e2, e2.__proto__ = t3;
        }
        function r2(e2, t3, r3) {
          function a2(e3, n3, r4) {
            return "string" == typeof t3 ? t3 : t3(e3, n3, r4);
          }
          r3 || (r3 = Error);
          var o2 = function(e3) {
            function t4(t5, n3, r4) {
              return e3.call(this, a2(t5, n3, r4)) || this;
            }
            return n2(t4, e3), t4;
          }(r3);
          o2.prototype.name = r3.name, o2.prototype.code = e2, s[e2] = o2;
        }
        function a(e2, t3) {
          if (Array.isArray(e2)) {
            var n3 = e2.length;
            return e2 = e2.map(function(e3) {
              return e3 + "";
            }), 2 < n3 ? "one of ".concat(t3, " ").concat(e2.slice(0, n3 - 1).join(", "), ", or ") + e2[n3 - 1] : 2 === n3 ? "one of ".concat(t3, " ").concat(e2[0], " or ").concat(e2[1]) : "of ".concat(t3, " ").concat(e2[0]);
          }
          return "of ".concat(t3, " ").concat(e2 + "");
        }
        function o(e2, t3, n3) {
          return e2.substr(!n3 || 0 > n3 ? 0 : +n3, t3.length) === t3;
        }
        function i(e2, t3, n3) {
          return (void 0 === n3 || n3 > e2.length) && (n3 = e2.length), e2.substring(n3 - t3.length, n3) === t3;
        }
        function d(e2, t3, n3) {
          return "number" != typeof n3 && (n3 = 0), !(n3 + t3.length > e2.length) && -1 !== e2.indexOf(t3, n3);
        }
        var s = {};
        r2("ERR_INVALID_OPT_VALUE", function(e2, t3) {
          return 'The value "' + t3 + '" is invalid for option "' + e2 + '"';
        }, TypeError), r2("ERR_INVALID_ARG_TYPE", function(e2, t3, n3) {
          var r3;
          "string" == typeof t3 && o(t3, "not ") ? (r3 = "must not be", t3 = t3.replace(/^not /, "")) : r3 = "must be";
          var s2;
          if (i(e2, " argument"))
            s2 = "The ".concat(e2, " ").concat(r3, " ").concat(a(t3, "type"));
          else {
            var l = d(e2, ".") ? "property" : "argument";
            s2 = 'The "'.concat(e2, '" ').concat(l, " ").concat(r3, " ").concat(a(t3, "type"));
          }
          return s2 += ". Received type ".concat(typeof n3), s2;
        }, TypeError), r2("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF"), r2("ERR_METHOD_NOT_IMPLEMENTED", function(e2) {
          return "The " + e2 + " method is not implemented";
        }), r2("ERR_STREAM_PREMATURE_CLOSE", "Premature close"), r2("ERR_STREAM_DESTROYED", function(e2) {
          return "Cannot call " + e2 + " after a stream was destroyed";
        }), r2("ERR_MULTIPLE_CALLBACK", "Callback called multiple times"), r2("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable"), r2("ERR_STREAM_WRITE_AFTER_END", "write after end"), r2("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError), r2("ERR_UNKNOWN_ENCODING", function(e2) {
          return "Unknown encoding: " + e2;
        }, TypeError), r2("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event"), t2.exports.codes = s;
      }, {}], 16: [function(e, t2) {
        (function(n2) {
          (function() {
            "use strict";
            function r2(e2) {
              return this instanceof r2 ? void (d.call(this, e2), s.call(this, e2), this.allowHalfOpen = true, e2 && (false === e2.readable && (this.readable = false), false === e2.writable && (this.writable = false), false === e2.allowHalfOpen && (this.allowHalfOpen = false, this.once("end", a)))) : new r2(e2);
            }
            function a() {
              this._writableState.ended || n2.nextTick(o, this);
            }
            function o(e2) {
              e2.end();
            }
            var i = Object.keys || function(e2) {
              var t3 = [];
              for (var n3 in e2)
                t3.push(n3);
              return t3;
            };
            t2.exports = r2;
            var d = e("./_stream_readable"), s = e("./_stream_writable");
            e("inherits")(r2, d);
            for (var l, c = i(s.prototype), u = 0; u < c.length; u++)
              l = c[u], r2.prototype[l] || (r2.prototype[l] = s.prototype[l]);
            Object.defineProperty(r2.prototype, "writableHighWaterMark", { enumerable: false, get: function() {
              return this._writableState.highWaterMark;
            } }), Object.defineProperty(r2.prototype, "writableBuffer", { enumerable: false, get: function() {
              return this._writableState && this._writableState.getBuffer();
            } }), Object.defineProperty(r2.prototype, "writableLength", { enumerable: false, get: function() {
              return this._writableState.length;
            } }), Object.defineProperty(r2.prototype, "destroyed", { enumerable: false, get: function() {
              return void 0 !== this._readableState && void 0 !== this._writableState && this._readableState.destroyed && this._writableState.destroyed;
            }, set: function(e2) {
              void 0 === this._readableState || void 0 === this._writableState || (this._readableState.destroyed = e2, this._writableState.destroyed = e2);
            } });
          }).call(this);
        }).call(this, e("_process"));
      }, { "./_stream_readable": 18, "./_stream_writable": 20, _process: 12, inherits: 10 }], 17: [function(e, t2) {
        "use strict";
        function n2(e2) {
          return this instanceof n2 ? void r2.call(this, e2) : new n2(e2);
        }
        t2.exports = n2;
        var r2 = e("./_stream_transform");
        e("inherits")(n2, r2), n2.prototype._transform = function(e2, t3, n3) {
          n3(null, e2);
        };
      }, { "./_stream_transform": 19, inherits: 10 }], 18: [function(e, t2) {
        (function(n2, r2) {
          (function() {
            "use strict";
            function a(e2) {
              return P.from(e2);
            }
            function o(e2) {
              return P.isBuffer(e2) || e2 instanceof M;
            }
            function i(e2, t3, n3) {
              return "function" == typeof e2.prependListener ? e2.prependListener(t3, n3) : void (e2._events && e2._events[t3] ? Array.isArray(e2._events[t3]) ? e2._events[t3].unshift(n3) : e2._events[t3] = [n3, e2._events[t3]] : e2.on(t3, n3));
            }
            function d(t3, n3, r3) {
              A = A || e("./_stream_duplex"), t3 = t3 || {}, "boolean" != typeof r3 && (r3 = n3 instanceof A), this.objectMode = !!t3.objectMode, r3 && (this.objectMode = this.objectMode || !!t3.readableObjectMode), this.highWaterMark = H(this, t3, "readableHighWaterMark", r3), this.buffer = new j(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = false, this.endEmitted = false, this.reading = false, this.sync = true, this.needReadable = false, this.emittedReadable = false, this.readableListening = false, this.resumeScheduled = false, this.paused = true, this.emitClose = false !== t3.emitClose, this.autoDestroy = !!t3.autoDestroy, this.destroyed = false, this.defaultEncoding = t3.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = false, this.decoder = null, this.encoding = null, t3.encoding && (!F && (F = e("string_decoder/").StringDecoder), this.decoder = new F(t3.encoding), this.encoding = t3.encoding);
            }
            function s(t3) {
              if (A = A || e("./_stream_duplex"), !(this instanceof s))
                return new s(t3);
              var n3 = this instanceof A;
              this._readableState = new d(t3, this, n3), this.readable = true, t3 && ("function" == typeof t3.read && (this._read = t3.read), "function" == typeof t3.destroy && (this._destroy = t3.destroy)), I.call(this);
            }
            function l(e2, t3, n3, r3, o2) {
              x("readableAddChunk", t3);
              var i2 = e2._readableState;
              if (null === t3)
                i2.reading = false, g(e2, i2);
              else {
                var d2;
                if (o2 || (d2 = u(i2, t3)), d2)
                  X(e2, d2);
                else if (!(i2.objectMode || t3 && 0 < t3.length))
                  r3 || (i2.reading = false, m(e2, i2));
                else if ("string" == typeof t3 || i2.objectMode || Object.getPrototypeOf(t3) === P.prototype || (t3 = a(t3)), r3)
                  i2.endEmitted ? X(e2, new K()) : c(e2, i2, t3, true);
                else if (i2.ended)
                  X(e2, new z());
                else {
                  if (i2.destroyed)
                    return false;
                  i2.reading = false, i2.decoder && !n3 ? (t3 = i2.decoder.write(t3), i2.objectMode || 0 !== t3.length ? c(e2, i2, t3, false) : m(e2, i2)) : c(e2, i2, t3, false);
                }
              }
              return !i2.ended && (i2.length < i2.highWaterMark || 0 === i2.length);
            }
            function c(e2, t3, n3, r3) {
              t3.flowing && 0 === t3.length && !t3.sync ? (t3.awaitDrain = 0, e2.emit("data", n3)) : (t3.length += t3.objectMode ? 1 : n3.length, r3 ? t3.buffer.unshift(n3) : t3.buffer.push(n3), t3.needReadable && _(e2)), m(e2, t3);
            }
            function u(e2, t3) {
              var n3;
              return o(t3) || "string" == typeof t3 || void 0 === t3 || e2.objectMode || (n3 = new V("chunk", ["string", "Buffer", "Uint8Array"], t3)), n3;
            }
            function p(e2) {
              return 1073741824 <= e2 ? e2 = 1073741824 : (e2--, e2 |= e2 >>> 1, e2 |= e2 >>> 2, e2 |= e2 >>> 4, e2 |= e2 >>> 8, e2 |= e2 >>> 16, e2++), e2;
            }
            function f(e2, t3) {
              return 0 >= e2 || 0 === t3.length && t3.ended ? 0 : t3.objectMode ? 1 : e2 === e2 ? (e2 > t3.highWaterMark && (t3.highWaterMark = p(e2)), e2 <= t3.length ? e2 : t3.ended ? t3.length : (t3.needReadable = true, 0)) : t3.flowing && t3.length ? t3.buffer.head.data.length : t3.length;
            }
            function g(e2, t3) {
              if (x("onEofChunk"), !t3.ended) {
                if (t3.decoder) {
                  var n3 = t3.decoder.end();
                  n3 && n3.length && (t3.buffer.push(n3), t3.length += t3.objectMode ? 1 : n3.length);
                }
                t3.ended = true, t3.sync ? _(e2) : (t3.needReadable = false, !t3.emittedReadable && (t3.emittedReadable = true, h(e2)));
              }
            }
            function _(e2) {
              var t3 = e2._readableState;
              x("emitReadable", t3.needReadable, t3.emittedReadable), t3.needReadable = false, t3.emittedReadable || (x("emitReadable", t3.flowing), t3.emittedReadable = true, n2.nextTick(h, e2));
            }
            function h(e2) {
              var t3 = e2._readableState;
              x("emitReadable_", t3.destroyed, t3.length, t3.ended), !t3.destroyed && (t3.length || t3.ended) && (e2.emit("readable"), t3.emittedReadable = false), t3.needReadable = !t3.flowing && !t3.ended && t3.length <= t3.highWaterMark, S(e2);
            }
            function m(e2, t3) {
              t3.readingMore || (t3.readingMore = true, n2.nextTick(b, e2, t3));
            }
            function b(e2, t3) {
              for (; !t3.reading && !t3.ended && (t3.length < t3.highWaterMark || t3.flowing && 0 === t3.length); ) {
                var n3 = t3.length;
                if (x("maybeReadMore read 0"), e2.read(0), n3 === t3.length)
                  break;
              }
              t3.readingMore = false;
            }
            function y(e2) {
              return function() {
                var t3 = e2._readableState;
                x("pipeOnDrain", t3.awaitDrain), t3.awaitDrain && t3.awaitDrain--, 0 === t3.awaitDrain && D(e2, "data") && (t3.flowing = true, S(e2));
              };
            }
            function C(e2) {
              var t3 = e2._readableState;
              t3.readableListening = 0 < e2.listenerCount("readable"), t3.resumeScheduled && !t3.paused ? t3.flowing = true : 0 < e2.listenerCount("data") && e2.resume();
            }
            function R(e2) {
              x("readable nexttick read 0"), e2.read(0);
            }
            function E(e2, t3) {
              t3.resumeScheduled || (t3.resumeScheduled = true, n2.nextTick(w, e2, t3));
            }
            function w(e2, t3) {
              x("resume", t3.reading), t3.reading || e2.read(0), t3.resumeScheduled = false, e2.emit("resume"), S(e2), t3.flowing && !t3.reading && e2.read(0);
            }
            function S(e2) {
              var t3 = e2._readableState;
              for (x("flow", t3.flowing); t3.flowing && null !== e2.read(); )
                ;
            }
            function T(e2, t3) {
              if (0 === t3.length)
                return null;
              var n3;
              return t3.objectMode ? n3 = t3.buffer.shift() : !e2 || e2 >= t3.length ? (n3 = t3.decoder ? t3.buffer.join("") : 1 === t3.buffer.length ? t3.buffer.first() : t3.buffer.concat(t3.length), t3.buffer.clear()) : n3 = t3.buffer.consume(e2, t3.decoder), n3;
            }
            function v(e2) {
              var t3 = e2._readableState;
              x("endReadable", t3.endEmitted), t3.endEmitted || (t3.ended = true, n2.nextTick(k, t3, e2));
            }
            function k(e2, t3) {
              if (x("endReadableNT", e2.endEmitted, e2.length), !e2.endEmitted && 0 === e2.length && (e2.endEmitted = true, t3.readable = false, t3.emit("end"), e2.autoDestroy)) {
                var n3 = t3._writableState;
                (!n3 || n3.autoDestroy && n3.finished) && t3.destroy();
              }
            }
            function L(e2, t3) {
              for (var n3 = 0, r3 = e2.length; n3 < r3; n3++)
                if (e2[n3] === t3)
                  return n3;
              return -1;
            }
            t2.exports = s;
            var A;
            s.ReadableState = d;
            var x, N = e("events").EventEmitter, D = function(e2, t3) {
              return e2.listeners(t3).length;
            }, I = e("./internal/streams/stream"), P = e("buffer").Buffer, M = r2.Uint8Array || function() {
            }, O = e("util");
            x = O && O.debuglog ? O.debuglog("stream") : function() {
            };
            var F, B, U, j = e("./internal/streams/buffer_list"), q = e("./internal/streams/destroy"), W = e("./internal/streams/state"), H = W.getHighWaterMark, Y = e("../errors").codes, V = Y.ERR_INVALID_ARG_TYPE, z = Y.ERR_STREAM_PUSH_AFTER_EOF, G = Y.ERR_METHOD_NOT_IMPLEMENTED, K = Y.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
            e("inherits")(s, I);
            var X = q.errorOrDestroy, $ = ["error", "close", "destroy", "pause", "resume"];
            Object.defineProperty(s.prototype, "destroyed", { enumerable: false, get: function() {
              return void 0 !== this._readableState && this._readableState.destroyed;
            }, set: function(e2) {
              this._readableState && (this._readableState.destroyed = e2);
            } }), s.prototype.destroy = q.destroy, s.prototype._undestroy = q.undestroy, s.prototype._destroy = function(e2, t3) {
              t3(e2);
            }, s.prototype.push = function(e2, t3) {
              var n3, r3 = this._readableState;
              return r3.objectMode ? n3 = true : "string" == typeof e2 && (t3 = t3 || r3.defaultEncoding, t3 !== r3.encoding && (e2 = P.from(e2, t3), t3 = ""), n3 = true), l(this, e2, t3, false, n3);
            }, s.prototype.unshift = function(e2) {
              return l(this, e2, null, true, false);
            }, s.prototype.isPaused = function() {
              return false === this._readableState.flowing;
            }, s.prototype.setEncoding = function(t3) {
              F || (F = e("string_decoder/").StringDecoder);
              var n3 = new F(t3);
              this._readableState.decoder = n3, this._readableState.encoding = this._readableState.decoder.encoding;
              for (var r3 = this._readableState.buffer.head, a2 = ""; null !== r3; )
                a2 += n3.write(r3.data), r3 = r3.next;
              return this._readableState.buffer.clear(), "" !== a2 && this._readableState.buffer.push(a2), this._readableState.length = a2.length, this;
            };
            s.prototype.read = function(e2) {
              x("read", e2), e2 = parseInt(e2, 10);
              var t3 = this._readableState, r3 = e2;
              if (0 !== e2 && (t3.emittedReadable = false), 0 === e2 && t3.needReadable && ((0 === t3.highWaterMark ? 0 < t3.length : t3.length >= t3.highWaterMark) || t3.ended))
                return x("read: emitReadable", t3.length, t3.ended), 0 === t3.length && t3.ended ? v(this) : _(this), null;
              if (e2 = f(e2, t3), 0 === e2 && t3.ended)
                return 0 === t3.length && v(this), null;
              var a2 = t3.needReadable;
              x("need readable", a2), (0 === t3.length || t3.length - e2 < t3.highWaterMark) && (a2 = true, x("length less than watermark", a2)), t3.ended || t3.reading ? (a2 = false, x("reading or ended", a2)) : a2 && (x("do read"), t3.reading = true, t3.sync = true, 0 === t3.length && (t3.needReadable = true), this._read(t3.highWaterMark), t3.sync = false, !t3.reading && (e2 = f(r3, t3)));
              var o2;
              return o2 = 0 < e2 ? T(e2, t3) : null, null === o2 ? (t3.needReadable = t3.length <= t3.highWaterMark, e2 = 0) : (t3.length -= e2, t3.awaitDrain = 0), 0 === t3.length && (!t3.ended && (t3.needReadable = true), r3 !== e2 && t3.ended && v(this)), null !== o2 && this.emit("data", o2), o2;
            }, s.prototype._read = function() {
              X(this, new G("_read()"));
            }, s.prototype.pipe = function(e2, t3) {
              function r3(e3, t4) {
                x("onunpipe"), e3 === p2 && t4 && false === t4.hasUnpiped && (t4.hasUnpiped = true, o2());
              }
              function a2() {
                x("onend"), e2.end();
              }
              function o2() {
                x("cleanup"), e2.removeListener("close", l2), e2.removeListener("finish", c2), e2.removeListener("drain", h2), e2.removeListener("error", s2), e2.removeListener("unpipe", r3), p2.removeListener("end", a2), p2.removeListener("end", u2), p2.removeListener("data", d2), m2 = true, f2.awaitDrain && (!e2._writableState || e2._writableState.needDrain) && h2();
              }
              function d2(t4) {
                x("ondata");
                var n3 = e2.write(t4);
                x("dest.write", n3), false === n3 && ((1 === f2.pipesCount && f2.pipes === e2 || 1 < f2.pipesCount && -1 !== L(f2.pipes, e2)) && !m2 && (x("false write response, pause", f2.awaitDrain), f2.awaitDrain++), p2.pause());
              }
              function s2(t4) {
                x("onerror", t4), u2(), e2.removeListener("error", s2), 0 === D(e2, "error") && X(e2, t4);
              }
              function l2() {
                e2.removeListener("finish", c2), u2();
              }
              function c2() {
                x("onfinish"), e2.removeListener("close", l2), u2();
              }
              function u2() {
                x("unpipe"), p2.unpipe(e2);
              }
              var p2 = this, f2 = this._readableState;
              switch (f2.pipesCount) {
                case 0:
                  f2.pipes = e2;
                  break;
                case 1:
                  f2.pipes = [f2.pipes, e2];
                  break;
                default:
                  f2.pipes.push(e2);
              }
              f2.pipesCount += 1, x("pipe count=%d opts=%j", f2.pipesCount, t3);
              var g2 = (!t3 || false !== t3.end) && e2 !== n2.stdout && e2 !== n2.stderr, _2 = g2 ? a2 : u2;
              f2.endEmitted ? n2.nextTick(_2) : p2.once("end", _2), e2.on("unpipe", r3);
              var h2 = y(p2);
              e2.on("drain", h2);
              var m2 = false;
              return p2.on("data", d2), i(e2, "error", s2), e2.once("close", l2), e2.once("finish", c2), e2.emit("pipe", p2), f2.flowing || (x("pipe resume"), p2.resume()), e2;
            }, s.prototype.unpipe = function(e2) {
              var t3 = this._readableState, n3 = { hasUnpiped: false };
              if (0 === t3.pipesCount)
                return this;
              if (1 === t3.pipesCount)
                return e2 && e2 !== t3.pipes ? this : (e2 || (e2 = t3.pipes), t3.pipes = null, t3.pipesCount = 0, t3.flowing = false, e2 && e2.emit("unpipe", this, n3), this);
              if (!e2) {
                var r3 = t3.pipes, a2 = t3.pipesCount;
                t3.pipes = null, t3.pipesCount = 0, t3.flowing = false;
                for (var o2 = 0; o2 < a2; o2++)
                  r3[o2].emit("unpipe", this, { hasUnpiped: false });
                return this;
              }
              var d2 = L(t3.pipes, e2);
              return -1 === d2 ? this : (t3.pipes.splice(d2, 1), t3.pipesCount -= 1, 1 === t3.pipesCount && (t3.pipes = t3.pipes[0]), e2.emit("unpipe", this, n3), this);
            }, s.prototype.on = function(e2, t3) {
              var r3 = I.prototype.on.call(this, e2, t3), a2 = this._readableState;
              return "data" === e2 ? (a2.readableListening = 0 < this.listenerCount("readable"), false !== a2.flowing && this.resume()) : "readable" == e2 && !a2.endEmitted && !a2.readableListening && (a2.readableListening = a2.needReadable = true, a2.flowing = false, a2.emittedReadable = false, x("on readable", a2.length, a2.reading), a2.length ? _(this) : !a2.reading && n2.nextTick(R, this)), r3;
            }, s.prototype.addListener = s.prototype.on, s.prototype.removeListener = function(e2, t3) {
              var r3 = I.prototype.removeListener.call(this, e2, t3);
              return "readable" === e2 && n2.nextTick(C, this), r3;
            }, s.prototype.removeAllListeners = function(e2) {
              var t3 = I.prototype.removeAllListeners.apply(this, arguments);
              return ("readable" === e2 || void 0 === e2) && n2.nextTick(C, this), t3;
            }, s.prototype.resume = function() {
              var e2 = this._readableState;
              return e2.flowing || (x("resume"), e2.flowing = !e2.readableListening, E(this, e2)), e2.paused = false, this;
            }, s.prototype.pause = function() {
              return x("call pause flowing=%j", this._readableState.flowing), false !== this._readableState.flowing && (x("pause"), this._readableState.flowing = false, this.emit("pause")), this._readableState.paused = true, this;
            }, s.prototype.wrap = function(e2) {
              var t3 = this, r3 = this._readableState, a2 = false;
              for (var o2 in e2.on("end", function() {
                if (x("wrapped end"), r3.decoder && !r3.ended) {
                  var e3 = r3.decoder.end();
                  e3 && e3.length && t3.push(e3);
                }
                t3.push(null);
              }), e2.on("data", function(n3) {
                if ((x("wrapped data"), r3.decoder && (n3 = r3.decoder.write(n3)), !(r3.objectMode && (null === n3 || void 0 === n3))) && (r3.objectMode || n3 && n3.length)) {
                  var o3 = t3.push(n3);
                  o3 || (a2 = true, e2.pause());
                }
              }), e2)
                void 0 === this[o2] && "function" == typeof e2[o2] && (this[o2] = function(t4) {
                  return function() {
                    return e2[t4].apply(e2, arguments);
                  };
                }(o2));
              for (var i2 = 0; i2 < $.length; i2++)
                e2.on($[i2], this.emit.bind(this, $[i2]));
              return this._read = function(t4) {
                x("wrapped _read", t4), a2 && (a2 = false, e2.resume());
              }, this;
            }, "function" == typeof Symbol && (s.prototype[Symbol.asyncIterator] = function() {
              return void 0 === B && (B = e("./internal/streams/async_iterator")), B(this);
            }), Object.defineProperty(s.prototype, "readableHighWaterMark", { enumerable: false, get: function() {
              return this._readableState.highWaterMark;
            } }), Object.defineProperty(s.prototype, "readableBuffer", { enumerable: false, get: function() {
              return this._readableState && this._readableState.buffer;
            } }), Object.defineProperty(s.prototype, "readableFlowing", { enumerable: false, get: function() {
              return this._readableState.flowing;
            }, set: function(e2) {
              this._readableState && (this._readableState.flowing = e2);
            } }), s._fromList = T, Object.defineProperty(s.prototype, "readableLength", { enumerable: false, get: function() {
              return this._readableState.length;
            } }), "function" == typeof Symbol && (s.from = function(t3, n3) {
              return void 0 === U && (U = e("./internal/streams/from")), U(s, t3, n3);
            });
          }).call(this);
        }).call(this, e("_process"), "undefined" == typeof global ? "undefined" == typeof self ? "undefined" == typeof window ? {} : window : self : global);
      }, { "../errors": 15, "./_stream_duplex": 16, "./internal/streams/async_iterator": 21, "./internal/streams/buffer_list": 22, "./internal/streams/destroy": 23, "./internal/streams/from": 25, "./internal/streams/state": 27, "./internal/streams/stream": 28, _process: 12, buffer: 3, events: 7, inherits: 10, "string_decoder/": 31, util: 2 }], 19: [function(e, t2) {
        "use strict";
        function n2(e2, t3) {
          var n3 = this._transformState;
          n3.transforming = false;
          var r3 = n3.writecb;
          if (null === r3)
            return this.emit("error", new s());
          n3.writechunk = null, n3.writecb = null, null != t3 && this.push(t3), r3(e2);
          var a2 = this._readableState;
          a2.reading = false, (a2.needReadable || a2.length < a2.highWaterMark) && this._read(a2.highWaterMark);
        }
        function r2(e2) {
          return this instanceof r2 ? void (u.call(this, e2), this._transformState = { afterTransform: n2.bind(this), needTransform: false, transforming: false, writecb: null, writechunk: null, writeencoding: null }, this._readableState.needReadable = true, this._readableState.sync = false, e2 && ("function" == typeof e2.transform && (this._transform = e2.transform), "function" == typeof e2.flush && (this._flush = e2.flush)), this.on("prefinish", a)) : new r2(e2);
        }
        function a() {
          var e2 = this;
          "function" != typeof this._flush || this._readableState.destroyed ? o(this, null, null) : this._flush(function(t3, n3) {
            o(e2, t3, n3);
          });
        }
        function o(e2, t3, n3) {
          if (t3)
            return e2.emit("error", t3);
          if (null != n3 && e2.push(n3), e2._writableState.length)
            throw new c();
          if (e2._transformState.transforming)
            throw new l();
          return e2.push(null);
        }
        t2.exports = r2;
        var i = e("../errors").codes, d = i.ERR_METHOD_NOT_IMPLEMENTED, s = i.ERR_MULTIPLE_CALLBACK, l = i.ERR_TRANSFORM_ALREADY_TRANSFORMING, c = i.ERR_TRANSFORM_WITH_LENGTH_0, u = e("./_stream_duplex");
        e("inherits")(r2, u), r2.prototype.push = function(e2, t3) {
          return this._transformState.needTransform = false, u.prototype.push.call(this, e2, t3);
        }, r2.prototype._transform = function(e2, t3, n3) {
          n3(new d("_transform()"));
        }, r2.prototype._write = function(e2, t3, n3) {
          var r3 = this._transformState;
          if (r3.writecb = n3, r3.writechunk = e2, r3.writeencoding = t3, !r3.transforming) {
            var a2 = this._readableState;
            (r3.needTransform || a2.needReadable || a2.length < a2.highWaterMark) && this._read(a2.highWaterMark);
          }
        }, r2.prototype._read = function() {
          var e2 = this._transformState;
          null === e2.writechunk || e2.transforming ? e2.needTransform = true : (e2.transforming = true, this._transform(e2.writechunk, e2.writeencoding, e2.afterTransform));
        }, r2.prototype._destroy = function(e2, t3) {
          u.prototype._destroy.call(this, e2, function(e3) {
            t3(e3);
          });
        };
      }, { "../errors": 15, "./_stream_duplex": 16, inherits: 10 }], 20: [function(e, t2) {
        (function(n2, r2) {
          (function() {
            "use strict";
            function a(e2) {
              var t3 = this;
              this.next = null, this.entry = null, this.finish = function() {
                v(t3, e2);
              };
            }
            function o(e2) {
              return x.from(e2);
            }
            function i(e2) {
              return x.isBuffer(e2) || e2 instanceof N;
            }
            function d() {
            }
            function s(t3, n3, r3) {
              k = k || e("./_stream_duplex"), t3 = t3 || {}, "boolean" != typeof r3 && (r3 = n3 instanceof k), this.objectMode = !!t3.objectMode, r3 && (this.objectMode = this.objectMode || !!t3.writableObjectMode), this.highWaterMark = P(this, t3, "writableHighWaterMark", r3), this.finalCalled = false, this.needDrain = false, this.ending = false, this.ended = false, this.finished = false, this.destroyed = false;
              var o2 = false === t3.decodeStrings;
              this.decodeStrings = !o2, this.defaultEncoding = t3.defaultEncoding || "utf8", this.length = 0, this.writing = false, this.corked = 0, this.sync = true, this.bufferProcessing = false, this.onwrite = function(e2) {
                m(n3, e2);
              }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = false, this.errorEmitted = false, this.emitClose = false !== t3.emitClose, this.autoDestroy = !!t3.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new a(this);
            }
            function l(t3) {
              k = k || e("./_stream_duplex");
              var n3 = this instanceof k;
              return n3 || V.call(l, this) ? void (this._writableState = new s(t3, this, n3), this.writable = true, t3 && ("function" == typeof t3.write && (this._write = t3.write), "function" == typeof t3.writev && (this._writev = t3.writev), "function" == typeof t3.destroy && (this._destroy = t3.destroy), "function" == typeof t3.final && (this._final = t3.final)), A.call(this)) : new l(t3);
            }
            function c(e2, t3) {
              var r3 = new W();
              Y(e2, r3), n2.nextTick(t3, r3);
            }
            function u(e2, t3, r3, a2) {
              var o2;
              return null === r3 ? o2 = new q() : "string" != typeof r3 && !t3.objectMode && (o2 = new O("chunk", ["string", "Buffer"], r3)), !o2 || (Y(e2, o2), n2.nextTick(a2, o2), false);
            }
            function p(e2, t3, n3) {
              return e2.objectMode || false === e2.decodeStrings || "string" != typeof t3 || (t3 = x.from(t3, n3)), t3;
            }
            function f(e2, t3, n3, r3, a2, o2) {
              if (!n3) {
                var i2 = p(t3, r3, a2);
                r3 !== i2 && (n3 = true, a2 = "buffer", r3 = i2);
              }
              var d2 = t3.objectMode ? 1 : r3.length;
              t3.length += d2;
              var s2 = t3.length < t3.highWaterMark;
              if (s2 || (t3.needDrain = true), t3.writing || t3.corked) {
                var l2 = t3.lastBufferedRequest;
                t3.lastBufferedRequest = { chunk: r3, encoding: a2, isBuf: n3, callback: o2, next: null }, l2 ? l2.next = t3.lastBufferedRequest : t3.bufferedRequest = t3.lastBufferedRequest, t3.bufferedRequestCount += 1;
              } else
                g(e2, t3, false, d2, r3, a2, o2);
              return s2;
            }
            function g(e2, t3, n3, r3, a2, o2, i2) {
              t3.writelen = r3, t3.writecb = i2, t3.writing = true, t3.sync = true, t3.destroyed ? t3.onwrite(new j("write")) : n3 ? e2._writev(a2, t3.onwrite) : e2._write(a2, o2, t3.onwrite), t3.sync = false;
            }
            function _(e2, t3, r3, a2, o2) {
              --t3.pendingcb, r3 ? (n2.nextTick(o2, a2), n2.nextTick(S, e2, t3), e2._writableState.errorEmitted = true, Y(e2, a2)) : (o2(a2), e2._writableState.errorEmitted = true, Y(e2, a2), S(e2, t3));
            }
            function h(e2) {
              e2.writing = false, e2.writecb = null, e2.length -= e2.writelen, e2.writelen = 0;
            }
            function m(e2, t3) {
              var r3 = e2._writableState, a2 = r3.sync, o2 = r3.writecb;
              if ("function" != typeof o2)
                throw new B();
              if (h(r3), t3)
                _(e2, r3, a2, t3, o2);
              else {
                var i2 = R(r3) || e2.destroyed;
                i2 || r3.corked || r3.bufferProcessing || !r3.bufferedRequest || C(e2, r3), a2 ? n2.nextTick(b, e2, r3, i2, o2) : b(e2, r3, i2, o2);
              }
            }
            function b(e2, t3, n3, r3) {
              n3 || y(e2, t3), t3.pendingcb--, r3(), S(e2, t3);
            }
            function y(e2, t3) {
              0 === t3.length && t3.needDrain && (t3.needDrain = false, e2.emit("drain"));
            }
            function C(e2, t3) {
              t3.bufferProcessing = true;
              var n3 = t3.bufferedRequest;
              if (e2._writev && n3 && n3.next) {
                var r3 = t3.bufferedRequestCount, o2 = Array(r3), i2 = t3.corkedRequestsFree;
                i2.entry = n3;
                for (var d2 = 0, s2 = true; n3; )
                  o2[d2] = n3, n3.isBuf || (s2 = false), n3 = n3.next, d2 += 1;
                o2.allBuffers = s2, g(e2, t3, true, t3.length, o2, "", i2.finish), t3.pendingcb++, t3.lastBufferedRequest = null, i2.next ? (t3.corkedRequestsFree = i2.next, i2.next = null) : t3.corkedRequestsFree = new a(t3), t3.bufferedRequestCount = 0;
              } else {
                for (; n3; ) {
                  var l2 = n3.chunk, c2 = n3.encoding, u2 = n3.callback, p2 = t3.objectMode ? 1 : l2.length;
                  if (g(e2, t3, false, p2, l2, c2, u2), n3 = n3.next, t3.bufferedRequestCount--, t3.writing)
                    break;
                }
                null === n3 && (t3.lastBufferedRequest = null);
              }
              t3.bufferedRequest = n3, t3.bufferProcessing = false;
            }
            function R(e2) {
              return e2.ending && 0 === e2.length && null === e2.bufferedRequest && !e2.finished && !e2.writing;
            }
            function E(e2, t3) {
              e2._final(function(n3) {
                t3.pendingcb--, n3 && Y(e2, n3), t3.prefinished = true, e2.emit("prefinish"), S(e2, t3);
              });
            }
            function w(e2, t3) {
              t3.prefinished || t3.finalCalled || ("function" != typeof e2._final || t3.destroyed ? (t3.prefinished = true, e2.emit("prefinish")) : (t3.pendingcb++, t3.finalCalled = true, n2.nextTick(E, e2, t3)));
            }
            function S(e2, t3) {
              var n3 = R(t3);
              if (n3 && (w(e2, t3), 0 === t3.pendingcb && (t3.finished = true, e2.emit("finish"), t3.autoDestroy))) {
                var r3 = e2._readableState;
                (!r3 || r3.autoDestroy && r3.endEmitted) && e2.destroy();
              }
              return n3;
            }
            function T(e2, t3, r3) {
              t3.ending = true, S(e2, t3), r3 && (t3.finished ? n2.nextTick(r3) : e2.once("finish", r3)), t3.ended = true, e2.writable = false;
            }
            function v(e2, t3, n3) {
              var r3 = e2.entry;
              for (e2.entry = null; r3; ) {
                var a2 = r3.callback;
                t3.pendingcb--, a2(n3), r3 = r3.next;
              }
              t3.corkedRequestsFree.next = e2;
            }
            t2.exports = l;
            var k;
            l.WritableState = s;
            var L = { deprecate: e("util-deprecate") }, A = e("./internal/streams/stream"), x = e("buffer").Buffer, N = r2.Uint8Array || function() {
            }, D = e("./internal/streams/destroy"), I = e("./internal/streams/state"), P = I.getHighWaterMark, M = e("../errors").codes, O = M.ERR_INVALID_ARG_TYPE, F = M.ERR_METHOD_NOT_IMPLEMENTED, B = M.ERR_MULTIPLE_CALLBACK, U = M.ERR_STREAM_CANNOT_PIPE, j = M.ERR_STREAM_DESTROYED, q = M.ERR_STREAM_NULL_VALUES, W = M.ERR_STREAM_WRITE_AFTER_END, H = M.ERR_UNKNOWN_ENCODING, Y = D.errorOrDestroy;
            e("inherits")(l, A), s.prototype.getBuffer = function() {
              for (var e2 = this.bufferedRequest, t3 = []; e2; )
                t3.push(e2), e2 = e2.next;
              return t3;
            }, function() {
              try {
                Object.defineProperty(s.prototype, "buffer", { get: L.deprecate(function() {
                  return this.getBuffer();
                }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003") });
              } catch (e2) {
              }
            }();
            var V;
            "function" == typeof Symbol && Symbol.hasInstance && "function" == typeof Function.prototype[Symbol.hasInstance] ? (V = Function.prototype[Symbol.hasInstance], Object.defineProperty(l, Symbol.hasInstance, { value: function(e2) {
              return !!V.call(this, e2) || !(this !== l) && e2 && e2._writableState instanceof s;
            } })) : V = function(e2) {
              return e2 instanceof this;
            }, l.prototype.pipe = function() {
              Y(this, new U());
            }, l.prototype.write = function(e2, t3, n3) {
              var r3 = this._writableState, a2 = false, s2 = !r3.objectMode && i(e2);
              return s2 && !x.isBuffer(e2) && (e2 = o(e2)), "function" == typeof t3 && (n3 = t3, t3 = null), s2 ? t3 = "buffer" : !t3 && (t3 = r3.defaultEncoding), "function" != typeof n3 && (n3 = d), r3.ending ? c(this, n3) : (s2 || u(this, r3, e2, n3)) && (r3.pendingcb++, a2 = f(this, r3, s2, e2, t3, n3)), a2;
            }, l.prototype.cork = function() {
              this._writableState.corked++;
            }, l.prototype.uncork = function() {
              var e2 = this._writableState;
              e2.corked && (e2.corked--, !e2.writing && !e2.corked && !e2.bufferProcessing && e2.bufferedRequest && C(this, e2));
            }, l.prototype.setDefaultEncoding = function(e2) {
              if ("string" == typeof e2 && (e2 = e2.toLowerCase()), !(-1 < ["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((e2 + "").toLowerCase())))
                throw new H(e2);
              return this._writableState.defaultEncoding = e2, this;
            }, Object.defineProperty(l.prototype, "writableBuffer", { enumerable: false, get: function() {
              return this._writableState && this._writableState.getBuffer();
            } }), Object.defineProperty(l.prototype, "writableHighWaterMark", { enumerable: false, get: function() {
              return this._writableState.highWaterMark;
            } }), l.prototype._write = function(e2, t3, n3) {
              n3(new F("_write()"));
            }, l.prototype._writev = null, l.prototype.end = function(e2, t3, n3) {
              var r3 = this._writableState;
              return "function" == typeof e2 ? (n3 = e2, e2 = null, t3 = null) : "function" == typeof t3 && (n3 = t3, t3 = null), null !== e2 && void 0 !== e2 && this.write(e2, t3), r3.corked && (r3.corked = 1, this.uncork()), r3.ending || T(this, r3, n3), this;
            }, Object.defineProperty(l.prototype, "writableLength", { enumerable: false, get: function() {
              return this._writableState.length;
            } }), Object.defineProperty(l.prototype, "destroyed", { enumerable: false, get: function() {
              return void 0 !== this._writableState && this._writableState.destroyed;
            }, set: function(e2) {
              this._writableState && (this._writableState.destroyed = e2);
            } }), l.prototype.destroy = D.destroy, l.prototype._undestroy = D.undestroy, l.prototype._destroy = function(e2, t3) {
              t3(e2);
            };
          }).call(this);
        }).call(this, e("_process"), "undefined" == typeof global ? "undefined" == typeof self ? "undefined" == typeof window ? {} : window : self : global);
      }, { "../errors": 15, "./_stream_duplex": 16, "./internal/streams/destroy": 23, "./internal/streams/state": 27, "./internal/streams/stream": 28, _process: 12, buffer: 3, inherits: 10, "util-deprecate": 32 }], 21: [function(e, t2) {
        (function(n2) {
          (function() {
            "use strict";
            function r2(e2, t3, n3) {
              return t3 in e2 ? Object.defineProperty(e2, t3, { value: n3, enumerable: true, configurable: true, writable: true }) : e2[t3] = n3, e2;
            }
            function a(e2, t3) {
              return { value: e2, done: t3 };
            }
            function o(e2) {
              var t3 = e2[c];
              if (null !== t3) {
                var n3 = e2[h].read();
                null !== n3 && (e2[g] = null, e2[c] = null, e2[u] = null, t3(a(n3, false)));
              }
            }
            function i(e2) {
              n2.nextTick(o, e2);
            }
            function d(e2, t3) {
              return function(n3, r3) {
                e2.then(function() {
                  return t3[f] ? void n3(a(void 0, true)) : void t3[_](n3, r3);
                }, r3);
              };
            }
            var s, l = e("./end-of-stream"), c = Symbol("lastResolve"), u = Symbol("lastReject"), p = Symbol("error"), f = Symbol("ended"), g = Symbol("lastPromise"), _ = Symbol("handlePromise"), h = Symbol("stream"), m = Object.getPrototypeOf(function() {
            }), b = Object.setPrototypeOf((s = { get stream() {
              return this[h];
            }, next: function() {
              var e2 = this, t3 = this[p];
              if (null !== t3)
                return Promise.reject(t3);
              if (this[f])
                return Promise.resolve(a(void 0, true));
              if (this[h].destroyed)
                return new Promise(function(t4, r4) {
                  n2.nextTick(function() {
                    e2[p] ? r4(e2[p]) : t4(a(void 0, true));
                  });
                });
              var r3, o2 = this[g];
              if (o2)
                r3 = new Promise(d(o2, this));
              else {
                var i2 = this[h].read();
                if (null !== i2)
                  return Promise.resolve(a(i2, false));
                r3 = new Promise(this[_]);
              }
              return this[g] = r3, r3;
            } }, r2(s, Symbol.asyncIterator, function() {
              return this;
            }), r2(s, "return", function() {
              var e2 = this;
              return new Promise(function(t3, n3) {
                e2[h].destroy(null, function(e3) {
                  return e3 ? void n3(e3) : void t3(a(void 0, true));
                });
              });
            }), s), m);
            t2.exports = function(e2) {
              var t3, n3 = Object.create(b, (t3 = {}, r2(t3, h, { value: e2, writable: true }), r2(t3, c, { value: null, writable: true }), r2(t3, u, { value: null, writable: true }), r2(t3, p, { value: null, writable: true }), r2(t3, f, { value: e2._readableState.endEmitted, writable: true }), r2(t3, _, { value: function(e3, t4) {
                var r3 = n3[h].read();
                r3 ? (n3[g] = null, n3[c] = null, n3[u] = null, e3(a(r3, false))) : (n3[c] = e3, n3[u] = t4);
              }, writable: true }), t3));
              return n3[g] = null, l(e2, function(e3) {
                if (e3 && "ERR_STREAM_PREMATURE_CLOSE" !== e3.code) {
                  var t4 = n3[u];
                  return null !== t4 && (n3[g] = null, n3[c] = null, n3[u] = null, t4(e3)), void (n3[p] = e3);
                }
                var r3 = n3[c];
                null !== r3 && (n3[g] = null, n3[c] = null, n3[u] = null, r3(a(void 0, true))), n3[f] = true;
              }), e2.on("readable", i.bind(null, n3)), n3;
            };
          }).call(this);
        }).call(this, e("_process"));
      }, { "./end-of-stream": 24, _process: 12 }], 22: [function(e, t2) {
        "use strict";
        function n2(e2, t3) {
          var n3 = Object.keys(e2);
          if (Object.getOwnPropertySymbols) {
            var r3 = Object.getOwnPropertySymbols(e2);
            t3 && (r3 = r3.filter(function(t4) {
              return Object.getOwnPropertyDescriptor(e2, t4).enumerable;
            })), n3.push.apply(n3, r3);
          }
          return n3;
        }
        function r2(e2) {
          for (var t3, r3 = 1; r3 < arguments.length; r3++)
            t3 = null == arguments[r3] ? {} : arguments[r3], r3 % 2 ? n2(Object(t3), true).forEach(function(n3) {
              a(e2, n3, t3[n3]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t3)) : n2(Object(t3)).forEach(function(n3) {
              Object.defineProperty(e2, n3, Object.getOwnPropertyDescriptor(t3, n3));
            });
          return e2;
        }
        function a(e2, t3, n3) {
          return t3 in e2 ? Object.defineProperty(e2, t3, { value: n3, enumerable: true, configurable: true, writable: true }) : e2[t3] = n3, e2;
        }
        function o(e2, t3) {
          if (!(e2 instanceof t3))
            throw new TypeError("Cannot call a class as a function");
        }
        function i(e2, t3) {
          for (var n3, r3 = 0; r3 < t3.length; r3++)
            n3 = t3[r3], n3.enumerable = n3.enumerable || false, n3.configurable = true, "value" in n3 && (n3.writable = true), Object.defineProperty(e2, n3.key, n3);
        }
        function d(e2, t3, n3) {
          return t3 && i(e2.prototype, t3), n3 && i(e2, n3), e2;
        }
        function s(e2, t3, n3) {
          u.prototype.copy.call(e2, t3, n3);
        }
        var l = e("buffer"), u = l.Buffer, p = e("util"), f = p.inspect, g = f && f.custom || "inspect";
        t2.exports = function() {
          function e2() {
            o(this, e2), this.head = null, this.tail = null, this.length = 0;
          }
          return d(e2, [{ key: "push", value: function(e3) {
            var t3 = { data: e3, next: null };
            0 < this.length ? this.tail.next = t3 : this.head = t3, this.tail = t3, ++this.length;
          } }, { key: "unshift", value: function(e3) {
            var t3 = { data: e3, next: this.head };
            0 === this.length && (this.tail = t3), this.head = t3, ++this.length;
          } }, { key: "shift", value: function() {
            if (0 !== this.length) {
              var e3 = this.head.data;
              return this.head = 1 === this.length ? this.tail = null : this.head.next, --this.length, e3;
            }
          } }, { key: "clear", value: function() {
            this.head = this.tail = null, this.length = 0;
          } }, { key: "join", value: function(e3) {
            if (0 === this.length)
              return "";
            for (var t3 = this.head, n3 = "" + t3.data; t3 = t3.next; )
              n3 += e3 + t3.data;
            return n3;
          } }, { key: "concat", value: function(e3) {
            if (0 === this.length)
              return u.alloc(0);
            for (var t3 = u.allocUnsafe(e3 >>> 0), n3 = this.head, r3 = 0; n3; )
              s(n3.data, t3, r3), r3 += n3.data.length, n3 = n3.next;
            return t3;
          } }, { key: "consume", value: function(e3, t3) {
            var n3;
            return e3 < this.head.data.length ? (n3 = this.head.data.slice(0, e3), this.head.data = this.head.data.slice(e3)) : e3 === this.head.data.length ? n3 = this.shift() : n3 = t3 ? this._getString(e3) : this._getBuffer(e3), n3;
          } }, { key: "first", value: function() {
            return this.head.data;
          } }, { key: "_getString", value: function(e3) {
            var t3 = this.head, r3 = 1, a2 = t3.data;
            for (e3 -= a2.length; t3 = t3.next; ) {
              var o2 = t3.data, i2 = e3 > o2.length ? o2.length : e3;
              if (a2 += i2 === o2.length ? o2 : o2.slice(0, e3), e3 -= i2, 0 === e3) {
                i2 === o2.length ? (++r3, this.head = t3.next ? t3.next : this.tail = null) : (this.head = t3, t3.data = o2.slice(i2));
                break;
              }
              ++r3;
            }
            return this.length -= r3, a2;
          } }, { key: "_getBuffer", value: function(e3) {
            var t3 = u.allocUnsafe(e3), r3 = this.head, a2 = 1;
            for (r3.data.copy(t3), e3 -= r3.data.length; r3 = r3.next; ) {
              var o2 = r3.data, i2 = e3 > o2.length ? o2.length : e3;
              if (o2.copy(t3, t3.length - e3, 0, i2), e3 -= i2, 0 === e3) {
                i2 === o2.length ? (++a2, this.head = r3.next ? r3.next : this.tail = null) : (this.head = r3, r3.data = o2.slice(i2));
                break;
              }
              ++a2;
            }
            return this.length -= a2, t3;
          } }, { key: g, value: function(e3, t3) {
            return f(this, r2({}, t3, { depth: 0, customInspect: false }));
          } }]), e2;
        }();
      }, { buffer: 3, util: 2 }], 23: [function(e, t2) {
        (function(e2) {
          (function() {
            "use strict";
            function n2(e3, t3) {
              a(e3, t3), r2(e3);
            }
            function r2(e3) {
              e3._writableState && !e3._writableState.emitClose || e3._readableState && !e3._readableState.emitClose || e3.emit("close");
            }
            function a(e3, t3) {
              e3.emit("error", t3);
            }
            t2.exports = { destroy: function(t3, o) {
              var i = this, d = this._readableState && this._readableState.destroyed, s = this._writableState && this._writableState.destroyed;
              return d || s ? (o ? o(t3) : t3 && (this._writableState ? !this._writableState.errorEmitted && (this._writableState.errorEmitted = true, e2.nextTick(a, this, t3)) : e2.nextTick(a, this, t3)), this) : (this._readableState && (this._readableState.destroyed = true), this._writableState && (this._writableState.destroyed = true), this._destroy(t3 || null, function(t4) {
                !o && t4 ? i._writableState ? i._writableState.errorEmitted ? e2.nextTick(r2, i) : (i._writableState.errorEmitted = true, e2.nextTick(n2, i, t4)) : e2.nextTick(n2, i, t4) : o ? (e2.nextTick(r2, i), o(t4)) : e2.nextTick(r2, i);
              }), this);
            }, undestroy: function() {
              this._readableState && (this._readableState.destroyed = false, this._readableState.reading = false, this._readableState.ended = false, this._readableState.endEmitted = false), this._writableState && (this._writableState.destroyed = false, this._writableState.ended = false, this._writableState.ending = false, this._writableState.finalCalled = false, this._writableState.prefinished = false, this._writableState.finished = false, this._writableState.errorEmitted = false);
            }, errorOrDestroy: function(e3, t3) {
              var n3 = e3._readableState, r3 = e3._writableState;
              n3 && n3.autoDestroy || r3 && r3.autoDestroy ? e3.destroy(t3) : e3.emit("error", t3);
            } };
          }).call(this);
        }).call(this, e("_process"));
      }, { _process: 12 }], 24: [function(e, t2) {
        "use strict";
        function n2(e2) {
          var t3 = false;
          return function() {
            if (!t3) {
              t3 = true;
              for (var n3 = arguments.length, r3 = Array(n3), a2 = 0; a2 < n3; a2++)
                r3[a2] = arguments[a2];
              e2.apply(this, r3);
            }
          };
        }
        function r2() {
        }
        function a(e2) {
          return e2.setHeader && "function" == typeof e2.abort;
        }
        function o(e2, t3, d) {
          if ("function" == typeof t3)
            return o(e2, null, t3);
          t3 || (t3 = {}), d = n2(d || r2);
          var s = t3.readable || false !== t3.readable && e2.readable, l = t3.writable || false !== t3.writable && e2.writable, c = function() {
            e2.writable || p();
          }, u = e2._writableState && e2._writableState.finished, p = function() {
            l = false, u = true, s || d.call(e2);
          }, f = e2._readableState && e2._readableState.endEmitted, g = function() {
            s = false, f = true, l || d.call(e2);
          }, _ = function(t4) {
            d.call(e2, t4);
          }, h = function() {
            var t4;
            return s && !f ? (e2._readableState && e2._readableState.ended || (t4 = new i()), d.call(e2, t4)) : l && !u ? (e2._writableState && e2._writableState.ended || (t4 = new i()), d.call(e2, t4)) : void 0;
          }, m = function() {
            e2.req.on("finish", p);
          };
          return a(e2) ? (e2.on("complete", p), e2.on("abort", h), e2.req ? m() : e2.on("request", m)) : l && !e2._writableState && (e2.on("end", c), e2.on("close", c)), e2.on("end", g), e2.on("finish", p), false !== t3.error && e2.on("error", _), e2.on("close", h), function() {
            e2.removeListener("complete", p), e2.removeListener("abort", h), e2.removeListener("request", m), e2.req && e2.req.removeListener("finish", p), e2.removeListener("end", c), e2.removeListener("close", c), e2.removeListener("finish", p), e2.removeListener("end", g), e2.removeListener("error", _), e2.removeListener("close", h);
          };
        }
        var i = e("../../../errors").codes.ERR_STREAM_PREMATURE_CLOSE;
        t2.exports = o;
      }, { "../../../errors": 15 }], 25: [function(e, t2) {
        t2.exports = function() {
          throw new Error("Readable.from is not available in the browser");
        };
      }, {}], 26: [function(e, t2) {
        "use strict";
        function n2(e2) {
          var t3 = false;
          return function() {
            t3 || (t3 = true, e2.apply(void 0, arguments));
          };
        }
        function r2(e2) {
          if (e2)
            throw e2;
        }
        function a(e2) {
          return e2.setHeader && "function" == typeof e2.abort;
        }
        function o(t3, r3, o2, i2) {
          i2 = n2(i2);
          var d2 = false;
          t3.on("close", function() {
            d2 = true;
          }), l === void 0 && (l = e("./end-of-stream")), l(t3, { readable: r3, writable: o2 }, function(e2) {
            return e2 ? i2(e2) : void (d2 = true, i2());
          });
          var s2 = false;
          return function(e2) {
            if (!d2)
              return s2 ? void 0 : (s2 = true, a(t3) ? t3.abort() : "function" == typeof t3.destroy ? t3.destroy() : void i2(e2 || new p("pipe")));
          };
        }
        function i(e2) {
          e2();
        }
        function d(e2, t3) {
          return e2.pipe(t3);
        }
        function s(e2) {
          return e2.length ? "function" == typeof e2[e2.length - 1] ? e2.pop() : r2 : r2;
        }
        var l, c = e("../../../errors").codes, u = c.ERR_MISSING_ARGS, p = c.ERR_STREAM_DESTROYED;
        t2.exports = function() {
          for (var e2 = arguments.length, t3 = Array(e2), n3 = 0; n3 < e2; n3++)
            t3[n3] = arguments[n3];
          var r3 = s(t3);
          if (Array.isArray(t3[0]) && (t3 = t3[0]), 2 > t3.length)
            throw new u("streams");
          var a2, l2 = t3.map(function(e3, n4) {
            var d2 = n4 < t3.length - 1;
            return o(e3, d2, 0 < n4, function(e4) {
              a2 || (a2 = e4), e4 && l2.forEach(i), d2 || (l2.forEach(i), r3(a2));
            });
          });
          return t3.reduce(d);
        };
      }, { "../../../errors": 15, "./end-of-stream": 24 }], 27: [function(e, n2) {
        "use strict";
        function r2(e2, t2, n3) {
          return null == e2.highWaterMark ? t2 ? e2[n3] : null : e2.highWaterMark;
        }
        var a = e("../../../errors").codes.ERR_INVALID_OPT_VALUE;
        n2.exports = { getHighWaterMark: function(e2, n3, o, i) {
          var d = r2(n3, i, o);
          if (null != d) {
            if (!(isFinite(d) && t(d) === d) || 0 > d) {
              var s = i ? o : "highWaterMark";
              throw new a(s, d);
            }
            return t(d);
          }
          return e2.objectMode ? 16 : 16384;
        } };
      }, { "../../../errors": 15 }], 28: [function(e, t2) {
        t2.exports = e("events").EventEmitter;
      }, { events: 7 }], 29: [function(e, t2, n2) {
        n2 = t2.exports = e("./lib/_stream_readable.js"), n2.Stream = n2, n2.Readable = n2, n2.Writable = e("./lib/_stream_writable.js"), n2.Duplex = e("./lib/_stream_duplex.js"), n2.Transform = e("./lib/_stream_transform.js"), n2.PassThrough = e("./lib/_stream_passthrough.js"), n2.finished = e("./lib/internal/streams/end-of-stream.js"), n2.pipeline = e("./lib/internal/streams/pipeline.js");
      }, { "./lib/_stream_duplex.js": 16, "./lib/_stream_passthrough.js": 17, "./lib/_stream_readable.js": 18, "./lib/_stream_transform.js": 19, "./lib/_stream_writable.js": 20, "./lib/internal/streams/end-of-stream.js": 24, "./lib/internal/streams/pipeline.js": 26 }], 30: [function(e, t2, n2) {
        function r2(e2, t3) {
          for (var n3 in e2)
            t3[n3] = e2[n3];
        }
        function a(e2, t3, n3) {
          return i(e2, t3, n3);
        }
        var o = e("buffer"), i = o.Buffer;
        i.from && i.alloc && i.allocUnsafe && i.allocUnsafeSlow ? t2.exports = o : (r2(o, n2), n2.Buffer = a), a.prototype = Object.create(i.prototype), r2(i, a), a.from = function(e2, t3, n3) {
          if ("number" == typeof e2)
            throw new TypeError("Argument must not be a number");
          return i(e2, t3, n3);
        }, a.alloc = function(e2, t3, n3) {
          if ("number" != typeof e2)
            throw new TypeError("Argument must be a number");
          var r3 = i(e2);
          return void 0 === t3 ? r3.fill(0) : "string" == typeof n3 ? r3.fill(t3, n3) : r3.fill(t3), r3;
        }, a.allocUnsafe = function(e2) {
          if ("number" != typeof e2)
            throw new TypeError("Argument must be a number");
          return i(e2);
        }, a.allocUnsafeSlow = function(e2) {
          if ("number" != typeof e2)
            throw new TypeError("Argument must be a number");
          return o.SlowBuffer(e2);
        };
      }, { buffer: 3 }], 31: [function(e, t2, n2) {
        "use strict";
        function r2(e2) {
          if (!e2)
            return "utf8";
          for (var t3; ; )
            switch (e2) {
              case "utf8":
              case "utf-8":
                return "utf8";
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return "utf16le";
              case "latin1":
              case "binary":
                return "latin1";
              case "base64":
              case "ascii":
              case "hex":
                return e2;
              default:
                if (t3)
                  return;
                e2 = ("" + e2).toLowerCase(), t3 = true;
            }
        }
        function a(e2) {
          var t3 = r2(e2);
          if ("string" != typeof t3 && (m.isEncoding === b || !b(e2)))
            throw new Error("Unknown encoding: " + e2);
          return t3 || e2;
        }
        function o(e2) {
          this.encoding = a(e2);
          var t3;
          switch (this.encoding) {
            case "utf16le":
              this.text = u, this.end = p, t3 = 4;
              break;
            case "utf8":
              this.fillLast = c, t3 = 4;
              break;
            case "base64":
              this.text = f, this.end = g, t3 = 3;
              break;
            default:
              return this.write = _, void (this.end = h);
          }
          this.lastNeed = 0, this.lastTotal = 0, this.lastChar = m.allocUnsafe(t3);
        }
        function d(e2) {
          if (127 >= e2)
            return 0;
          return 6 == e2 >> 5 ? 2 : 14 == e2 >> 4 ? 3 : 30 == e2 >> 3 ? 4 : 2 == e2 >> 6 ? -1 : -2;
        }
        function s(e2, t3, n3) {
          var r3 = t3.length - 1;
          if (r3 < n3)
            return 0;
          var a2 = d(t3[r3]);
          return 0 <= a2 ? (0 < a2 && (e2.lastNeed = a2 - 1), a2) : --r3 < n3 || -2 === a2 ? 0 : (a2 = d(t3[r3]), 0 <= a2) ? (0 < a2 && (e2.lastNeed = a2 - 2), a2) : --r3 < n3 || -2 === a2 ? 0 : (a2 = d(t3[r3]), 0 <= a2 ? (0 < a2 && (2 === a2 ? a2 = 0 : e2.lastNeed = a2 - 3), a2) : 0);
        }
        function l(e2, t3) {
          if (128 != (192 & t3[0]))
            return e2.lastNeed = 0, "\uFFFD";
          if (1 < e2.lastNeed && 1 < t3.length) {
            if (128 != (192 & t3[1]))
              return e2.lastNeed = 1, "\uFFFD";
            if (2 < e2.lastNeed && 2 < t3.length && 128 != (192 & t3[2]))
              return e2.lastNeed = 2, "\uFFFD";
          }
        }
        function c(e2) {
          var t3 = this.lastTotal - this.lastNeed, n3 = l(this, e2, t3);
          return void 0 === n3 ? this.lastNeed <= e2.length ? (e2.copy(this.lastChar, t3, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal)) : void (e2.copy(this.lastChar, t3, 0, e2.length), this.lastNeed -= e2.length) : n3;
        }
        function u(e2, t3) {
          if (0 == (e2.length - t3) % 2) {
            var n3 = e2.toString("utf16le", t3);
            if (n3) {
              var r3 = n3.charCodeAt(n3.length - 1);
              if (55296 <= r3 && 56319 >= r3)
                return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = e2[e2.length - 2], this.lastChar[1] = e2[e2.length - 1], n3.slice(0, -1);
            }
            return n3;
          }
          return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = e2[e2.length - 1], e2.toString("utf16le", t3, e2.length - 1);
        }
        function p(e2) {
          var t3 = e2 && e2.length ? this.write(e2) : "";
          if (this.lastNeed) {
            var n3 = this.lastTotal - this.lastNeed;
            return t3 + this.lastChar.toString("utf16le", 0, n3);
          }
          return t3;
        }
        function f(e2, t3) {
          var r3 = (e2.length - t3) % 3;
          return 0 == r3 ? e2.toString("base64", t3) : (this.lastNeed = 3 - r3, this.lastTotal = 3, 1 == r3 ? this.lastChar[0] = e2[e2.length - 1] : (this.lastChar[0] = e2[e2.length - 2], this.lastChar[1] = e2[e2.length - 1]), e2.toString("base64", t3, e2.length - r3));
        }
        function g(e2) {
          var t3 = e2 && e2.length ? this.write(e2) : "";
          return this.lastNeed ? t3 + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : t3;
        }
        function _(e2) {
          return e2.toString(this.encoding);
        }
        function h(e2) {
          return e2 && e2.length ? this.write(e2) : "";
        }
        var m = e("safe-buffer").Buffer, b = m.isEncoding || function(e2) {
          switch (e2 = "" + e2, e2 && e2.toLowerCase()) {
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "binary":
            case "base64":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
            case "raw":
              return true;
            default:
              return false;
          }
        };
        n2.StringDecoder = o, o.prototype.write = function(e2) {
          if (0 === e2.length)
            return "";
          var t3, n3;
          if (this.lastNeed) {
            if (t3 = this.fillLast(e2), void 0 === t3)
              return "";
            n3 = this.lastNeed, this.lastNeed = 0;
          } else
            n3 = 0;
          return n3 < e2.length ? t3 ? t3 + this.text(e2, n3) : this.text(e2, n3) : t3 || "";
        }, o.prototype.end = function(e2) {
          var t3 = e2 && e2.length ? this.write(e2) : "";
          return this.lastNeed ? t3 + "\uFFFD" : t3;
        }, o.prototype.text = function(e2, t3) {
          var n3 = s(this, e2, t3);
          if (!this.lastNeed)
            return e2.toString("utf8", t3);
          this.lastTotal = n3;
          var r3 = e2.length - (n3 - this.lastNeed);
          return e2.copy(this.lastChar, 0, r3), e2.toString("utf8", t3, r3);
        }, o.prototype.fillLast = function(e2) {
          return this.lastNeed <= e2.length ? (e2.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal)) : void (e2.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, e2.length), this.lastNeed -= e2.length);
        };
      }, { "safe-buffer": 30 }], 32: [function(e, t2) {
        (function(e2) {
          (function() {
            function n2(t3) {
              try {
                if (!e2.localStorage)
                  return false;
              } catch (e3) {
                return false;
              }
              var n3 = e2.localStorage[t3];
              return null != n3 && "true" === (n3 + "").toLowerCase();
            }
            t2.exports = function(e3, t3) {
              function r2() {
                if (!a) {
                  if (n2("throwDeprecation"))
                    throw new Error(t3);
                  else
                    n2("traceDeprecation") ? console.trace(t3) : console.warn(t3);
                  a = true;
                }
                return e3.apply(this, arguments);
              }
              if (n2("noDeprecation"))
                return e3;
              var a = false;
              return r2;
            };
          }).call(this);
        }).call(this, "undefined" == typeof global ? "undefined" == typeof self ? "undefined" == typeof window ? {} : window : self : global);
      }, {}], "/": [function(e, t2) {
        function n2(e2) {
          return e2.replace(/a=ice-options:trickle\s\n/g, "");
        }
        function r2(e2) {
          console.warn(e2);
        }
        const a = e("debug")("simple-peer"), o = e("get-browser-rtc"), i = e("randombytes"), d = e("readable-stream"), s = e("queue-microtask"), l = e("err-code"), { Buffer: c } = e("buffer"), u = 65536;
        class p extends d.Duplex {
          constructor(e2) {
            if (e2 = Object.assign({ allowHalfOpen: false }, e2), super(e2), this._id = i(4).toString("hex").slice(0, 7), this._debug("new peer %o", e2), this.channelName = e2.initiator ? e2.channelName || i(20).toString("hex") : null, this.initiator = e2.initiator || false, this.channelConfig = e2.channelConfig || p.channelConfig, this.channelNegotiated = this.channelConfig.negotiated, this.config = Object.assign({}, p.config, e2.config), this.offerOptions = e2.offerOptions || {}, this.answerOptions = e2.answerOptions || {}, this.sdpTransform = e2.sdpTransform || ((e3) => e3), this.streams = e2.streams || (e2.stream ? [e2.stream] : []), this.trickle = void 0 === e2.trickle || e2.trickle, this.allowHalfTrickle = void 0 !== e2.allowHalfTrickle && e2.allowHalfTrickle, this.iceCompleteTimeout = e2.iceCompleteTimeout || 5e3, this.destroyed = false, this.destroying = false, this._connected = false, this.remoteAddress = void 0, this.remoteFamily = void 0, this.remotePort = void 0, this.localAddress = void 0, this.localFamily = void 0, this.localPort = void 0, this._wrtc = e2.wrtc && "object" == typeof e2.wrtc ? e2.wrtc : o(), !this._wrtc)
              if ("undefined" == typeof window)
                throw l(new Error("No WebRTC support: Specify `opts.wrtc` option in this environment"), "ERR_WEBRTC_SUPPORT");
              else
                throw l(new Error("No WebRTC support: Not a supported browser"), "ERR_WEBRTC_SUPPORT");
            this._pcReady = false, this._channelReady = false, this._iceComplete = false, this._iceCompleteTimer = null, this._channel = null, this._pendingCandidates = [], this._isNegotiating = false, this._firstNegotiation = true, this._batchedNegotiation = false, this._queuedNegotiation = false, this._sendersAwaitingStable = [], this._senderMap = /* @__PURE__ */ new Map(), this._closingInterval = null, this._remoteTracks = [], this._remoteStreams = [], this._chunk = null, this._cb = null, this._interval = null;
            try {
              this._pc = new this._wrtc.RTCPeerConnection(this.config);
            } catch (e3) {
              return void this.destroy(l(e3, "ERR_PC_CONSTRUCTOR"));
            }
            this._isReactNativeWebrtc = "number" == typeof this._pc._peerConnectionId, this._pc.oniceconnectionstatechange = () => {
              this._onIceStateChange();
            }, this._pc.onicegatheringstatechange = () => {
              this._onIceStateChange();
            }, this._pc.onconnectionstatechange = () => {
              this._onConnectionStateChange();
            }, this._pc.onsignalingstatechange = () => {
              this._onSignalingStateChange();
            }, this._pc.onicecandidate = (e3) => {
              this._onIceCandidate(e3);
            }, "object" == typeof this._pc.peerIdentity && this._pc.peerIdentity.catch((e3) => {
              this.destroy(l(e3, "ERR_PC_PEER_IDENTITY"));
            }), this.initiator || this.channelNegotiated ? this._setupData({ channel: this._pc.createDataChannel(this.channelName, this.channelConfig) }) : this._pc.ondatachannel = (e3) => {
              this._setupData(e3);
            }, this.streams && this.streams.forEach((e3) => {
              this.addStream(e3);
            }), this._pc.ontrack = (e3) => {
              this._onTrack(e3);
            }, this._debug("initial negotiation"), this._needsNegotiation(), this._onFinishBound = () => {
              this._onFinish();
            }, this.once("finish", this._onFinishBound);
          }
          get bufferSize() {
            return this._channel && this._channel.bufferedAmount || 0;
          }
          get connected() {
            return this._connected && "open" === this._channel.readyState;
          }
          address() {
            return { port: this.localPort, family: this.localFamily, address: this.localAddress };
          }
          signal(e2) {
            if (!this.destroying) {
              if (this.destroyed)
                throw l(new Error("cannot signal after peer is destroyed"), "ERR_DESTROYED");
              if ("string" == typeof e2)
                try {
                  e2 = JSON.parse(e2);
                } catch (t3) {
                  e2 = {};
                }
              this._debug("signal()"), e2.renegotiate && this.initiator && (this._debug("got request to renegotiate"), this._needsNegotiation()), e2.transceiverRequest && this.initiator && (this._debug("got request for transceiver"), this.addTransceiver(e2.transceiverRequest.kind, e2.transceiverRequest.init)), e2.candidate && (this._pc.remoteDescription && this._pc.remoteDescription.type ? this._addIceCandidate(e2.candidate) : this._pendingCandidates.push(e2.candidate)), e2.sdp && this._pc.setRemoteDescription(new this._wrtc.RTCSessionDescription(e2)).then(() => {
                this.destroyed || (this._pendingCandidates.forEach((e3) => {
                  this._addIceCandidate(e3);
                }), this._pendingCandidates = [], "offer" === this._pc.remoteDescription.type && this._createAnswer());
              }).catch((e3) => {
                this.destroy(l(e3, "ERR_SET_REMOTE_DESCRIPTION"));
              }), e2.sdp || e2.candidate || e2.renegotiate || e2.transceiverRequest || this.destroy(l(new Error("signal() called with invalid signal data"), "ERR_SIGNALING"));
            }
          }
          _addIceCandidate(e2) {
            const t3 = new this._wrtc.RTCIceCandidate(e2);
            this._pc.addIceCandidate(t3).catch((e3) => {
              !t3.address || t3.address.endsWith(".local") ? r2("Ignoring unsupported ICE candidate.") : this.destroy(l(e3, "ERR_ADD_ICE_CANDIDATE"));
            });
          }
          send(e2) {
            if (!this.destroying) {
              if (this.destroyed)
                throw l(new Error("cannot send after peer is destroyed"), "ERR_DESTROYED");
              this._channel.send(e2);
            }
          }
          addTransceiver(e2, t3) {
            if (!this.destroying) {
              if (this.destroyed)
                throw l(new Error("cannot addTransceiver after peer is destroyed"), "ERR_DESTROYED");
              if (this._debug("addTransceiver()"), this.initiator)
                try {
                  this._pc.addTransceiver(e2, t3), this._needsNegotiation();
                } catch (e3) {
                  this.destroy(l(e3, "ERR_ADD_TRANSCEIVER"));
                }
              else
                this.emit("signal", { type: "transceiverRequest", transceiverRequest: { kind: e2, init: t3 } });
            }
          }
          addStream(e2) {
            if (!this.destroying) {
              if (this.destroyed)
                throw l(new Error("cannot addStream after peer is destroyed"), "ERR_DESTROYED");
              this._debug("addStream()"), e2.getTracks().forEach((t3) => {
                this.addTrack(t3, e2);
              });
            }
          }
          addTrack(e2, t3) {
            if (this.destroying)
              return;
            if (this.destroyed)
              throw l(new Error("cannot addTrack after peer is destroyed"), "ERR_DESTROYED");
            this._debug("addTrack()");
            const n3 = this._senderMap.get(e2) || /* @__PURE__ */ new Map();
            let r3 = n3.get(t3);
            if (!r3)
              r3 = this._pc.addTrack(e2, t3), n3.set(t3, r3), this._senderMap.set(e2, n3), this._needsNegotiation();
            else if (r3.removed)
              throw l(new Error("Track has been removed. You should enable/disable tracks that you want to re-add."), "ERR_SENDER_REMOVED");
            else
              throw l(new Error("Track has already been added to that stream."), "ERR_SENDER_ALREADY_ADDED");
          }
          replaceTrack(e2, t3, n3) {
            if (this.destroying)
              return;
            if (this.destroyed)
              throw l(new Error("cannot replaceTrack after peer is destroyed"), "ERR_DESTROYED");
            this._debug("replaceTrack()");
            const r3 = this._senderMap.get(e2), a2 = r3 ? r3.get(n3) : null;
            if (!a2)
              throw l(new Error("Cannot replace track that was never added."), "ERR_TRACK_NOT_ADDED");
            t3 && this._senderMap.set(t3, r3), null == a2.replaceTrack ? this.destroy(l(new Error("replaceTrack is not supported in this browser"), "ERR_UNSUPPORTED_REPLACETRACK")) : a2.replaceTrack(t3);
          }
          removeTrack(e2, t3) {
            if (this.destroying)
              return;
            if (this.destroyed)
              throw l(new Error("cannot removeTrack after peer is destroyed"), "ERR_DESTROYED");
            this._debug("removeSender()");
            const n3 = this._senderMap.get(e2), r3 = n3 ? n3.get(t3) : null;
            if (!r3)
              throw l(new Error("Cannot remove track that was never added."), "ERR_TRACK_NOT_ADDED");
            try {
              r3.removed = true, this._pc.removeTrack(r3);
            } catch (e3) {
              "NS_ERROR_UNEXPECTED" === e3.name ? this._sendersAwaitingStable.push(r3) : this.destroy(l(e3, "ERR_REMOVE_TRACK"));
            }
            this._needsNegotiation();
          }
          removeStream(e2) {
            if (!this.destroying) {
              if (this.destroyed)
                throw l(new Error("cannot removeStream after peer is destroyed"), "ERR_DESTROYED");
              this._debug("removeSenders()"), e2.getTracks().forEach((t3) => {
                this.removeTrack(t3, e2);
              });
            }
          }
          _needsNegotiation() {
            this._debug("_needsNegotiation"), this._batchedNegotiation || (this._batchedNegotiation = true, s(() => {
              this._batchedNegotiation = false, this.initiator || !this._firstNegotiation ? (this._debug("starting batched negotiation"), this.negotiate()) : this._debug("non-initiator initial negotiation request discarded"), this._firstNegotiation = false;
            }));
          }
          negotiate() {
            if (!this.destroying) {
              if (this.destroyed)
                throw l(new Error("cannot negotiate after peer is destroyed"), "ERR_DESTROYED");
              this.initiator ? this._isNegotiating ? (this._queuedNegotiation = true, this._debug("already negotiating, queueing")) : (this._debug("start negotiation"), setTimeout(() => {
                this._createOffer();
              }, 0)) : this._isNegotiating ? (this._queuedNegotiation = true, this._debug("already negotiating, queueing")) : (this._debug("requesting negotiation from initiator"), this.emit("signal", { type: "renegotiate", renegotiate: true })), this._isNegotiating = true;
            }
          }
          destroy(e2) {
            this._destroy(e2, () => {
            });
          }
          _destroy(e2, t3) {
            this.destroyed || this.destroying || (this.destroying = true, this._debug("destroying (error: %s)", e2 && (e2.message || e2)), s(() => {
              if (this.destroyed = true, this.destroying = false, this._debug("destroy (error: %s)", e2 && (e2.message || e2)), this.readable = this.writable = false, this._readableState.ended || this.push(null), this._writableState.finished || this.end(), this._connected = false, this._pcReady = false, this._channelReady = false, this._remoteTracks = null, this._remoteStreams = null, this._senderMap = null, clearInterval(this._closingInterval), this._closingInterval = null, clearInterval(this._interval), this._interval = null, this._chunk = null, this._cb = null, this._onFinishBound && this.removeListener("finish", this._onFinishBound), this._onFinishBound = null, this._channel) {
                try {
                  this._channel.close();
                } catch (e3) {
                }
                this._channel.onmessage = null, this._channel.onopen = null, this._channel.onclose = null, this._channel.onerror = null;
              }
              if (this._pc) {
                try {
                  this._pc.close();
                } catch (e3) {
                }
                this._pc.oniceconnectionstatechange = null, this._pc.onicegatheringstatechange = null, this._pc.onsignalingstatechange = null, this._pc.onicecandidate = null, this._pc.ontrack = null, this._pc.ondatachannel = null;
              }
              this._pc = null, this._channel = null, e2 && this.emit("error", e2), this.emit("close"), t3();
            }));
          }
          _setupData(e2) {
            if (!e2.channel)
              return this.destroy(l(new Error("Data channel event is missing `channel` property"), "ERR_DATA_CHANNEL"));
            this._channel = e2.channel, this._channel.binaryType = "arraybuffer", "number" == typeof this._channel.bufferedAmountLowThreshold && (this._channel.bufferedAmountLowThreshold = u), this.channelName = this._channel.label, this._channel.onmessage = (e3) => {
              this._onChannelMessage(e3);
            }, this._channel.onbufferedamountlow = () => {
              this._onChannelBufferedAmountLow();
            }, this._channel.onopen = () => {
              this._onChannelOpen();
            }, this._channel.onclose = () => {
              this._onChannelClose();
            }, this._channel.onerror = (e3) => {
              const t4 = e3.error instanceof Error ? e3.error : new Error(`Datachannel error: ${e3.message} ${e3.filename}:${e3.lineno}:${e3.colno}`);
              this.destroy(l(t4, "ERR_DATA_CHANNEL"));
            };
            let t3 = false;
            this._closingInterval = setInterval(() => {
              this._channel && "closing" === this._channel.readyState ? (t3 && this._onChannelClose(), t3 = true) : t3 = false;
            }, 5e3);
          }
          _read() {
          }
          _write(e2, t3, n3) {
            if (this.destroyed)
              return n3(l(new Error("cannot write after peer is destroyed"), "ERR_DATA_CHANNEL"));
            if (this._connected) {
              try {
                this.send(e2);
              } catch (e3) {
                return this.destroy(l(e3, "ERR_DATA_CHANNEL"));
              }
              this._channel.bufferedAmount > u ? (this._debug("start backpressure: bufferedAmount %d", this._channel.bufferedAmount), this._cb = n3) : n3(null);
            } else
              this._debug("write before connect"), this._chunk = e2, this._cb = n3;
          }
          _onFinish() {
            if (!this.destroyed) {
              const e2 = () => {
                setTimeout(() => this.destroy(), 1e3);
              };
              this._connected ? e2() : this.once("connect", e2);
            }
          }
          _startIceCompleteTimeout() {
            this.destroyed || this._iceCompleteTimer || (this._debug("started iceComplete timeout"), this._iceCompleteTimer = setTimeout(() => {
              this._iceComplete || (this._iceComplete = true, this._debug("iceComplete timeout completed"), this.emit("iceTimeout"), this.emit("_iceComplete"));
            }, this.iceCompleteTimeout));
          }
          _createOffer() {
            this.destroyed || this._pc.createOffer(this.offerOptions).then((e2) => {
              if (this.destroyed)
                return;
              this.trickle || this.allowHalfTrickle || (e2.sdp = n2(e2.sdp)), e2.sdp = this.sdpTransform(e2.sdp);
              const t3 = () => {
                if (!this.destroyed) {
                  const t4 = this._pc.localDescription || e2;
                  this._debug("signal"), this.emit("signal", { type: t4.type, sdp: t4.sdp });
                }
              };
              this._pc.setLocalDescription(e2).then(() => {
                this._debug("createOffer success"), this.destroyed || (this.trickle || this._iceComplete ? t3() : this.once("_iceComplete", t3));
              }).catch((e3) => {
                this.destroy(l(e3, "ERR_SET_LOCAL_DESCRIPTION"));
              });
            }).catch((e2) => {
              this.destroy(l(e2, "ERR_CREATE_OFFER"));
            });
          }
          _requestMissingTransceivers() {
            this._pc.getTransceivers && this._pc.getTransceivers().forEach((e2) => {
              e2.mid || !e2.sender.track || e2.requested || (e2.requested = true, this.addTransceiver(e2.sender.track.kind));
            });
          }
          _createAnswer() {
            this.destroyed || this._pc.createAnswer(this.answerOptions).then((e2) => {
              if (this.destroyed)
                return;
              this.trickle || this.allowHalfTrickle || (e2.sdp = n2(e2.sdp)), e2.sdp = this.sdpTransform(e2.sdp);
              const t3 = () => {
                if (!this.destroyed) {
                  const t4 = this._pc.localDescription || e2;
                  this._debug("signal"), this.emit("signal", { type: t4.type, sdp: t4.sdp }), this.initiator || this._requestMissingTransceivers();
                }
              };
              this._pc.setLocalDescription(e2).then(() => {
                this.destroyed || (this.trickle || this._iceComplete ? t3() : this.once("_iceComplete", t3));
              }).catch((e3) => {
                this.destroy(l(e3, "ERR_SET_LOCAL_DESCRIPTION"));
              });
            }).catch((e2) => {
              this.destroy(l(e2, "ERR_CREATE_ANSWER"));
            });
          }
          _onConnectionStateChange() {
            this.destroyed || "failed" === this._pc.connectionState && this.destroy(l(new Error("Connection failed."), "ERR_CONNECTION_FAILURE"));
          }
          _onIceStateChange() {
            if (this.destroyed)
              return;
            const e2 = this._pc.iceConnectionState, t3 = this._pc.iceGatheringState;
            this._debug("iceStateChange (connection: %s) (gathering: %s)", e2, t3), this.emit("iceStateChange", e2, t3), ("connected" === e2 || "completed" === e2) && (this._pcReady = true, this._maybeReady()), "failed" === e2 && this.destroy(l(new Error("Ice connection failed."), "ERR_ICE_CONNECTION_FAILURE")), "closed" === e2 && this.destroy(l(new Error("Ice connection closed."), "ERR_ICE_CONNECTION_CLOSED"));
          }
          getStats(e2) {
            const t3 = (e3) => ("[object Array]" === Object.prototype.toString.call(e3.values) && e3.values.forEach((t4) => {
              Object.assign(e3, t4);
            }), e3);
            0 === this._pc.getStats.length || this._isReactNativeWebrtc ? this._pc.getStats().then((n3) => {
              const r3 = [];
              n3.forEach((e3) => {
                r3.push(t3(e3));
              }), e2(null, r3);
            }, (t4) => e2(t4)) : 0 < this._pc.getStats.length ? this._pc.getStats((n3) => {
              if (this.destroyed)
                return;
              const r3 = [];
              n3.result().forEach((e3) => {
                const n4 = {};
                e3.names().forEach((t4) => {
                  n4[t4] = e3.stat(t4);
                }), n4.id = e3.id, n4.type = e3.type, n4.timestamp = e3.timestamp, r3.push(t3(n4));
              }), e2(null, r3);
            }, (t4) => e2(t4)) : e2(null, []);
          }
          _maybeReady() {
            if (this._debug("maybeReady pc %s channel %s", this._pcReady, this._channelReady), this._connected || this._connecting || !this._pcReady || !this._channelReady)
              return;
            this._connecting = true;
            const e2 = () => {
              this.destroyed || this.getStats((t3, n3) => {
                if (this.destroyed)
                  return;
                t3 && (n3 = []);
                const r3 = {}, a2 = {}, o2 = {};
                let i2 = false;
                n3.forEach((e3) => {
                  ("remotecandidate" === e3.type || "remote-candidate" === e3.type) && (r3[e3.id] = e3), ("localcandidate" === e3.type || "local-candidate" === e3.type) && (a2[e3.id] = e3), ("candidatepair" === e3.type || "candidate-pair" === e3.type) && (o2[e3.id] = e3);
                });
                const d2 = (e3) => {
                  i2 = true;
                  let t4 = a2[e3.localCandidateId];
                  t4 && (t4.ip || t4.address) ? (this.localAddress = t4.ip || t4.address, this.localPort = +t4.port) : t4 && t4.ipAddress ? (this.localAddress = t4.ipAddress, this.localPort = +t4.portNumber) : "string" == typeof e3.googLocalAddress && (t4 = e3.googLocalAddress.split(":"), this.localAddress = t4[0], this.localPort = +t4[1]), this.localAddress && (this.localFamily = this.localAddress.includes(":") ? "IPv6" : "IPv4");
                  let n4 = r3[e3.remoteCandidateId];
                  n4 && (n4.ip || n4.address) ? (this.remoteAddress = n4.ip || n4.address, this.remotePort = +n4.port) : n4 && n4.ipAddress ? (this.remoteAddress = n4.ipAddress, this.remotePort = +n4.portNumber) : "string" == typeof e3.googRemoteAddress && (n4 = e3.googRemoteAddress.split(":"), this.remoteAddress = n4[0], this.remotePort = +n4[1]), this.remoteAddress && (this.remoteFamily = this.remoteAddress.includes(":") ? "IPv6" : "IPv4"), this._debug("connect local: %s:%s remote: %s:%s", this.localAddress, this.localPort, this.remoteAddress, this.remotePort);
                };
                if (n3.forEach((e3) => {
                  "transport" === e3.type && e3.selectedCandidatePairId && d2(o2[e3.selectedCandidatePairId]), ("googCandidatePair" === e3.type && "true" === e3.googActiveConnection || ("candidatepair" === e3.type || "candidate-pair" === e3.type) && e3.selected) && d2(e3);
                }), !i2 && (!Object.keys(o2).length || Object.keys(a2).length))
                  return void setTimeout(e2, 100);
                if (this._connecting = false, this._connected = true, this._chunk) {
                  try {
                    this.send(this._chunk);
                  } catch (e4) {
                    return this.destroy(l(e4, "ERR_DATA_CHANNEL"));
                  }
                  this._chunk = null, this._debug('sent chunk from "write before connect"');
                  const e3 = this._cb;
                  this._cb = null, e3(null);
                }
                "number" != typeof this._channel.bufferedAmountLowThreshold && (this._interval = setInterval(() => this._onInterval(), 150), this._interval.unref && this._interval.unref()), this._debug("connect"), this.emit("connect");
              });
            };
            e2();
          }
          _onInterval() {
            this._cb && this._channel && !(this._channel.bufferedAmount > u) && this._onChannelBufferedAmountLow();
          }
          _onSignalingStateChange() {
            this.destroyed || ("stable" === this._pc.signalingState && (this._isNegotiating = false, this._debug("flushing sender queue", this._sendersAwaitingStable), this._sendersAwaitingStable.forEach((e2) => {
              this._pc.removeTrack(e2), this._queuedNegotiation = true;
            }), this._sendersAwaitingStable = [], this._queuedNegotiation ? (this._debug("flushing negotiation queue"), this._queuedNegotiation = false, this._needsNegotiation()) : (this._debug("negotiated"), this.emit("negotiated"))), this._debug("signalingStateChange %s", this._pc.signalingState), this.emit("signalingStateChange", this._pc.signalingState));
          }
          _onIceCandidate(e2) {
            this.destroyed || (e2.candidate && this.trickle ? this.emit("signal", { type: "candidate", candidate: { candidate: e2.candidate.candidate, sdpMLineIndex: e2.candidate.sdpMLineIndex, sdpMid: e2.candidate.sdpMid } }) : !e2.candidate && !this._iceComplete && (this._iceComplete = true, this.emit("_iceComplete")), e2.candidate && this._startIceCompleteTimeout());
          }
          _onChannelMessage(e2) {
            if (this.destroyed)
              return;
            let t3 = e2.data;
            t3 instanceof ArrayBuffer && (t3 = c.from(t3)), this.push(t3);
          }
          _onChannelBufferedAmountLow() {
            if (!this.destroyed && this._cb) {
              this._debug("ending backpressure: bufferedAmount %d", this._channel.bufferedAmount);
              const e2 = this._cb;
              this._cb = null, e2(null);
            }
          }
          _onChannelOpen() {
            this._connected || this.destroyed || (this._debug("on channel open"), this._channelReady = true, this._maybeReady());
          }
          _onChannelClose() {
            this.destroyed || (this._debug("on channel close"), this.destroy());
          }
          _onTrack(e2) {
            this.destroyed || e2.streams.forEach((t3) => {
              this._debug("on track"), this.emit("track", e2.track, t3), this._remoteTracks.push({ track: e2.track, stream: t3 }), this._remoteStreams.some((e3) => e3.id === t3.id) || (this._remoteStreams.push(t3), s(() => {
                this._debug("on stream"), this.emit("stream", t3);
              }));
            });
          }
          _debug() {
            const e2 = [].slice.call(arguments);
            e2[0] = "[" + this._id + "] " + e2[0], a.apply(null, e2);
          }
        }
        p.WEBRTC_SUPPORT = !!o(), p.config = { iceServers: [{ urls: ["stun:stun.l.google.com:19302", "stun:global.stun.twilio.com:3478"] }], sdpSemantics: "unified-plan" }, p.channelConfig = {}, t2.exports = p;
      }, { buffer: 3, debug: 4, "err-code": 6, "get-browser-rtc": 8, "queue-microtask": 13, randombytes: 14, "readable-stream": 29 }] }, {}, [])("/");
    });
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => main_default
});
module.exports = __toCommonJS(main_exports);

// src/peerdraftPlugin.ts
var import_obsidian14 = require("obsidian");

// node_modules/lib0/math.js
var floor = Math.floor;
var abs = Math.abs;
var log10 = Math.log10;
var min = (a, b) => a < b ? a : b;
var max = (a, b) => a > b ? a : b;
var isNaN2 = Number.isNaN;
var pow = Math.pow;
var isNegativeZero = (n) => n !== 0 ? n < 0 : 1 / n < 0;

// node_modules/lib0/time.js
var getUnixTime = Date.now;

// node_modules/lib0/map.js
var create = () => /* @__PURE__ */ new Map();
var copy = (m) => {
  const r = create();
  m.forEach((v, k) => {
    r.set(k, v);
  });
  return r;
};
var setIfUndefined = (map2, key, createT) => {
  let set = map2.get(key);
  if (set === void 0) {
    map2.set(key, set = createT());
  }
  return set;
};
var map = (m, f) => {
  const res = [];
  for (const [key, value] of m) {
    res.push(f(value, key));
  }
  return res;
};
var any = (m, f) => {
  for (const [key, value] of m) {
    if (f(value, key)) {
      return true;
    }
  }
  return false;
};

// node_modules/lib0/set.js
var create2 = () => /* @__PURE__ */ new Set();

// node_modules/lib0/array.js
var last = (arr) => arr[arr.length - 1];
var appendTo = (dest, src) => {
  for (let i = 0; i < src.length; i++) {
    dest.push(src[i]);
  }
};
var from = Array.from;
var some = (arr, f) => {
  for (let i = 0; i < arr.length; i++) {
    if (f(arr[i], i, arr)) {
      return true;
    }
  }
  return false;
};
var isArray = Array.isArray;

// node_modules/lib0/observable.js
var ObservableV2 = class {
  constructor() {
    this._observers = create();
  }
  /**
   * @template {keyof EVENTS & string} NAME
   * @param {NAME} name
   * @param {EVENTS[NAME]} f
   */
  on(name, f) {
    setIfUndefined(
      this._observers,
      /** @type {string} */
      name,
      create2
    ).add(f);
    return f;
  }
  /**
   * @template {keyof EVENTS & string} NAME
   * @param {NAME} name
   * @param {EVENTS[NAME]} f
   */
  once(name, f) {
    const _f = (...args2) => {
      this.off(
        name,
        /** @type {any} */
        _f
      );
      f(...args2);
    };
    this.on(
      name,
      /** @type {any} */
      _f
    );
  }
  /**
   * @template {keyof EVENTS & string} NAME
   * @param {NAME} name
   * @param {EVENTS[NAME]} f
   */
  off(name, f) {
    const observers = this._observers.get(name);
    if (observers !== void 0) {
      observers.delete(f);
      if (observers.size === 0) {
        this._observers.delete(name);
      }
    }
  }
  /**
   * Emit a named event. All registered event listeners that listen to the
   * specified name will receive the event.
   *
   * @todo This should catch exceptions
   *
   * @template {keyof EVENTS & string} NAME
   * @param {NAME} name The event name.
   * @param {Parameters<EVENTS[NAME]>} args The arguments that are applied to the event listener.
   */
  emit(name, args2) {
    return from((this._observers.get(name) || create()).values()).forEach((f) => f(...args2));
  }
  destroy() {
    this._observers = create();
  }
};
var Observable = class {
  constructor() {
    this._observers = create();
  }
  /**
   * @param {N} name
   * @param {function} f
   */
  on(name, f) {
    setIfUndefined(this._observers, name, create2).add(f);
  }
  /**
   * @param {N} name
   * @param {function} f
   */
  once(name, f) {
    const _f = (...args2) => {
      this.off(name, _f);
      f(...args2);
    };
    this.on(name, _f);
  }
  /**
   * @param {N} name
   * @param {function} f
   */
  off(name, f) {
    const observers = this._observers.get(name);
    if (observers !== void 0) {
      observers.delete(f);
      if (observers.size === 0) {
        this._observers.delete(name);
      }
    }
  }
  /**
   * Emit a named event. All registered event listeners that listen to the
   * specified name will receive the event.
   *
   * @todo This should catch exceptions
   *
   * @param {N} name The event name.
   * @param {Array<any>} args The arguments that are applied to the event listener.
   */
  emit(name, args2) {
    return from((this._observers.get(name) || create()).values()).forEach((f) => f(...args2));
  }
  destroy() {
    this._observers = create();
  }
};

// src/sharedEntities/sharedDocument.ts
var import_obsidian9 = require("obsidian");

// node_modules/lib0/binary.js
var BIT1 = 1;
var BIT2 = 2;
var BIT3 = 4;
var BIT4 = 8;
var BIT6 = 32;
var BIT7 = 64;
var BIT8 = 128;
var BIT18 = 1 << 17;
var BIT19 = 1 << 18;
var BIT20 = 1 << 19;
var BIT21 = 1 << 20;
var BIT22 = 1 << 21;
var BIT23 = 1 << 22;
var BIT24 = 1 << 23;
var BIT25 = 1 << 24;
var BIT26 = 1 << 25;
var BIT27 = 1 << 26;
var BIT28 = 1 << 27;
var BIT29 = 1 << 28;
var BIT30 = 1 << 29;
var BIT31 = 1 << 30;
var BIT32 = 1 << 31;
var BITS5 = 31;
var BITS6 = 63;
var BITS7 = 127;
var BITS17 = BIT18 - 1;
var BITS18 = BIT19 - 1;
var BITS19 = BIT20 - 1;
var BITS20 = BIT21 - 1;
var BITS21 = BIT22 - 1;
var BITS22 = BIT23 - 1;
var BITS23 = BIT24 - 1;
var BITS24 = BIT25 - 1;
var BITS25 = BIT26 - 1;
var BITS26 = BIT27 - 1;
var BITS27 = BIT28 - 1;
var BITS28 = BIT29 - 1;
var BITS29 = BIT30 - 1;
var BITS30 = BIT31 - 1;
var BITS31 = 2147483647;

// node_modules/lib0/number.js
var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER;
var MIN_SAFE_INTEGER = Number.MIN_SAFE_INTEGER;
var LOWEST_INT32 = 1 << 31;
var isInteger = Number.isInteger || ((num) => typeof num === "number" && isFinite(num) && floor(num) === num);
var isNaN3 = Number.isNaN;
var parseInt2 = Number.parseInt;

// node_modules/lib0/string.js
var fromCharCode = String.fromCharCode;
var fromCodePoint = String.fromCodePoint;
var MAX_UTF16_CHARACTER = fromCharCode(65535);
var toLowerCase = (s) => s.toLowerCase();
var trimLeftRegex = /^\s*/g;
var trimLeft = (s) => s.replace(trimLeftRegex, "");
var fromCamelCaseRegex = /([A-Z])/g;
var fromCamelCase = (s, separator) => trimLeft(s.replace(fromCamelCaseRegex, (match) => `${separator}${toLowerCase(match)}`));
var _encodeUtf8Polyfill = (str) => {
  const encodedString = unescape(encodeURIComponent(str));
  const len = encodedString.length;
  const buf = new Uint8Array(len);
  for (let i = 0; i < len; i++) {
    buf[i] = /** @type {number} */
    encodedString.codePointAt(i);
  }
  return buf;
};
var utf8TextEncoder = (
  /** @type {TextEncoder} */
  typeof TextEncoder !== "undefined" ? new TextEncoder() : null
);
var _encodeUtf8Native = (str) => utf8TextEncoder.encode(str);
var encodeUtf8 = utf8TextEncoder ? _encodeUtf8Native : _encodeUtf8Polyfill;
var utf8TextDecoder = typeof TextDecoder === "undefined" ? null : new TextDecoder("utf-8", { fatal: true, ignoreBOM: true });
if (utf8TextDecoder && utf8TextDecoder.decode(new Uint8Array()).length === 1) {
  utf8TextDecoder = null;
}

// node_modules/lib0/encoding.js
var Encoder = class {
  constructor() {
    this.cpos = 0;
    this.cbuf = new Uint8Array(100);
    this.bufs = [];
  }
};
var createEncoder = () => new Encoder();
var length = (encoder) => {
  let len = encoder.cpos;
  for (let i = 0; i < encoder.bufs.length; i++) {
    len += encoder.bufs[i].length;
  }
  return len;
};
var toUint8Array = (encoder) => {
  const uint8arr = new Uint8Array(length(encoder));
  let curPos = 0;
  for (let i = 0; i < encoder.bufs.length; i++) {
    const d = encoder.bufs[i];
    uint8arr.set(d, curPos);
    curPos += d.length;
  }
  uint8arr.set(new Uint8Array(encoder.cbuf.buffer, 0, encoder.cpos), curPos);
  return uint8arr;
};
var verifyLen = (encoder, len) => {
  const bufferLen = encoder.cbuf.length;
  if (bufferLen - encoder.cpos < len) {
    encoder.bufs.push(new Uint8Array(encoder.cbuf.buffer, 0, encoder.cpos));
    encoder.cbuf = new Uint8Array(max(bufferLen, len) * 2);
    encoder.cpos = 0;
  }
};
var write = (encoder, num) => {
  const bufferLen = encoder.cbuf.length;
  if (encoder.cpos === bufferLen) {
    encoder.bufs.push(encoder.cbuf);
    encoder.cbuf = new Uint8Array(bufferLen * 2);
    encoder.cpos = 0;
  }
  encoder.cbuf[encoder.cpos++] = num;
};
var writeUint8 = write;
var writeVarUint = (encoder, num) => {
  while (num > BITS7) {
    write(encoder, BIT8 | BITS7 & num);
    num = floor(num / 128);
  }
  write(encoder, BITS7 & num);
};
var writeVarInt = (encoder, num) => {
  const isNegative = isNegativeZero(num);
  if (isNegative) {
    num = -num;
  }
  write(encoder, (num > BITS6 ? BIT8 : 0) | (isNegative ? BIT7 : 0) | BITS6 & num);
  num = floor(num / 64);
  while (num > 0) {
    write(encoder, (num > BITS7 ? BIT8 : 0) | BITS7 & num);
    num = floor(num / 128);
  }
};
var _strBuffer = new Uint8Array(3e4);
var _maxStrBSize = _strBuffer.length / 3;
var _writeVarStringNative = (encoder, str) => {
  if (str.length < _maxStrBSize) {
    const written = utf8TextEncoder.encodeInto(str, _strBuffer).written || 0;
    writeVarUint(encoder, written);
    for (let i = 0; i < written; i++) {
      write(encoder, _strBuffer[i]);
    }
  } else {
    writeVarUint8Array(encoder, encodeUtf8(str));
  }
};
var _writeVarStringPolyfill = (encoder, str) => {
  const encodedString = unescape(encodeURIComponent(str));
  const len = encodedString.length;
  writeVarUint(encoder, len);
  for (let i = 0; i < len; i++) {
    write(
      encoder,
      /** @type {number} */
      encodedString.codePointAt(i)
    );
  }
};
var writeVarString = utf8TextEncoder && /** @type {any} */
utf8TextEncoder.encodeInto ? _writeVarStringNative : _writeVarStringPolyfill;
var writeUint8Array = (encoder, uint8Array) => {
  const bufferLen = encoder.cbuf.length;
  const cpos = encoder.cpos;
  const leftCopyLen = min(bufferLen - cpos, uint8Array.length);
  const rightCopyLen = uint8Array.length - leftCopyLen;
  encoder.cbuf.set(uint8Array.subarray(0, leftCopyLen), cpos);
  encoder.cpos += leftCopyLen;
  if (rightCopyLen > 0) {
    encoder.bufs.push(encoder.cbuf);
    encoder.cbuf = new Uint8Array(max(bufferLen * 2, rightCopyLen));
    encoder.cbuf.set(uint8Array.subarray(leftCopyLen));
    encoder.cpos = rightCopyLen;
  }
};
var writeVarUint8Array = (encoder, uint8Array) => {
  writeVarUint(encoder, uint8Array.byteLength);
  writeUint8Array(encoder, uint8Array);
};
var writeOnDataView = (encoder, len) => {
  verifyLen(encoder, len);
  const dview = new DataView(encoder.cbuf.buffer, encoder.cpos, len);
  encoder.cpos += len;
  return dview;
};
var writeFloat32 = (encoder, num) => writeOnDataView(encoder, 4).setFloat32(0, num, false);
var writeFloat64 = (encoder, num) => writeOnDataView(encoder, 8).setFloat64(0, num, false);
var writeBigInt64 = (encoder, num) => (
  /** @type {any} */
  writeOnDataView(encoder, 8).setBigInt64(0, num, false)
);
var floatTestBed = new DataView(new ArrayBuffer(4));
var isFloat32 = (num) => {
  floatTestBed.setFloat32(0, num);
  return floatTestBed.getFloat32(0) === num;
};
var writeAny = (encoder, data) => {
  switch (typeof data) {
    case "string":
      write(encoder, 119);
      writeVarString(encoder, data);
      break;
    case "number":
      if (isInteger(data) && abs(data) <= BITS31) {
        write(encoder, 125);
        writeVarInt(encoder, data);
      } else if (isFloat32(data)) {
        write(encoder, 124);
        writeFloat32(encoder, data);
      } else {
        write(encoder, 123);
        writeFloat64(encoder, data);
      }
      break;
    case "bigint":
      write(encoder, 122);
      writeBigInt64(encoder, data);
      break;
    case "object":
      if (data === null) {
        write(encoder, 126);
      } else if (isArray(data)) {
        write(encoder, 117);
        writeVarUint(encoder, data.length);
        for (let i = 0; i < data.length; i++) {
          writeAny(encoder, data[i]);
        }
      } else if (data instanceof Uint8Array) {
        write(encoder, 116);
        writeVarUint8Array(encoder, data);
      } else {
        write(encoder, 118);
        const keys3 = Object.keys(data);
        writeVarUint(encoder, keys3.length);
        for (let i = 0; i < keys3.length; i++) {
          const key = keys3[i];
          writeVarString(encoder, key);
          writeAny(encoder, data[key]);
        }
      }
      break;
    case "boolean":
      write(encoder, data ? 120 : 121);
      break;
    default:
      write(encoder, 127);
  }
};
var RleEncoder = class extends Encoder {
  /**
   * @param {function(Encoder, T):void} writer
   */
  constructor(writer) {
    super();
    this.w = writer;
    this.s = null;
    this.count = 0;
  }
  /**
   * @param {T} v
   */
  write(v) {
    if (this.s === v) {
      this.count++;
    } else {
      if (this.count > 0) {
        writeVarUint(this, this.count - 1);
      }
      this.count = 1;
      this.w(this, v);
      this.s = v;
    }
  }
};
var flushUintOptRleEncoder = (encoder) => {
  if (encoder.count > 0) {
    writeVarInt(encoder.encoder, encoder.count === 1 ? encoder.s : -encoder.s);
    if (encoder.count > 1) {
      writeVarUint(encoder.encoder, encoder.count - 2);
    }
  }
};
var UintOptRleEncoder = class {
  constructor() {
    this.encoder = new Encoder();
    this.s = 0;
    this.count = 0;
  }
  /**
   * @param {number} v
   */
  write(v) {
    if (this.s === v) {
      this.count++;
    } else {
      flushUintOptRleEncoder(this);
      this.count = 1;
      this.s = v;
    }
  }
  toUint8Array() {
    flushUintOptRleEncoder(this);
    return toUint8Array(this.encoder);
  }
};
var flushIntDiffOptRleEncoder = (encoder) => {
  if (encoder.count > 0) {
    const encodedDiff = encoder.diff * 2 + (encoder.count === 1 ? 0 : 1);
    writeVarInt(encoder.encoder, encodedDiff);
    if (encoder.count > 1) {
      writeVarUint(encoder.encoder, encoder.count - 2);
    }
  }
};
var IntDiffOptRleEncoder = class {
  constructor() {
    this.encoder = new Encoder();
    this.s = 0;
    this.count = 0;
    this.diff = 0;
  }
  /**
   * @param {number} v
   */
  write(v) {
    if (this.diff === v - this.s) {
      this.s = v;
      this.count++;
    } else {
      flushIntDiffOptRleEncoder(this);
      this.count = 1;
      this.diff = v - this.s;
      this.s = v;
    }
  }
  toUint8Array() {
    flushIntDiffOptRleEncoder(this);
    return toUint8Array(this.encoder);
  }
};
var StringEncoder = class {
  constructor() {
    this.sarr = [];
    this.s = "";
    this.lensE = new UintOptRleEncoder();
  }
  /**
   * @param {string} string
   */
  write(string) {
    this.s += string;
    if (this.s.length > 19) {
      this.sarr.push(this.s);
      this.s = "";
    }
    this.lensE.write(string.length);
  }
  toUint8Array() {
    const encoder = new Encoder();
    this.sarr.push(this.s);
    this.s = "";
    writeVarString(encoder, this.sarr.join(""));
    writeUint8Array(encoder, this.lensE.toUint8Array());
    return toUint8Array(encoder);
  }
};

// node_modules/lib0/error.js
var create3 = (s) => new Error(s);
var methodUnimplemented = () => {
  throw create3("Method unimplemented");
};
var unexpectedCase = () => {
  throw create3("Unexpected case");
};

// node_modules/lib0/decoding.js
var errorUnexpectedEndOfArray = create3("Unexpected end of array");
var errorIntegerOutOfRange = create3("Integer out of Range");
var Decoder = class {
  /**
   * @param {Uint8Array} uint8Array Binary data to decode
   */
  constructor(uint8Array) {
    this.arr = uint8Array;
    this.pos = 0;
  }
};
var createDecoder = (uint8Array) => new Decoder(uint8Array);
var hasContent = (decoder) => decoder.pos !== decoder.arr.length;
var readUint8Array = (decoder, len) => {
  const view = new Uint8Array(decoder.arr.buffer, decoder.pos + decoder.arr.byteOffset, len);
  decoder.pos += len;
  return view;
};
var readVarUint8Array = (decoder) => readUint8Array(decoder, readVarUint(decoder));
var readUint8 = (decoder) => decoder.arr[decoder.pos++];
var readVarUint = (decoder) => {
  let num = 0;
  let mult = 1;
  const len = decoder.arr.length;
  while (decoder.pos < len) {
    const r = decoder.arr[decoder.pos++];
    num = num + (r & BITS7) * mult;
    mult *= 128;
    if (r < BIT8) {
      return num;
    }
    if (num > MAX_SAFE_INTEGER) {
      throw errorIntegerOutOfRange;
    }
  }
  throw errorUnexpectedEndOfArray;
};
var readVarInt = (decoder) => {
  let r = decoder.arr[decoder.pos++];
  let num = r & BITS6;
  let mult = 64;
  const sign = (r & BIT7) > 0 ? -1 : 1;
  if ((r & BIT8) === 0) {
    return sign * num;
  }
  const len = decoder.arr.length;
  while (decoder.pos < len) {
    r = decoder.arr[decoder.pos++];
    num = num + (r & BITS7) * mult;
    mult *= 128;
    if (r < BIT8) {
      return sign * num;
    }
    if (num > MAX_SAFE_INTEGER) {
      throw errorIntegerOutOfRange;
    }
  }
  throw errorUnexpectedEndOfArray;
};
var _readVarStringPolyfill = (decoder) => {
  let remainingLen = readVarUint(decoder);
  if (remainingLen === 0) {
    return "";
  } else {
    let encodedString = String.fromCodePoint(readUint8(decoder));
    if (--remainingLen < 100) {
      while (remainingLen--) {
        encodedString += String.fromCodePoint(readUint8(decoder));
      }
    } else {
      while (remainingLen > 0) {
        const nextLen = remainingLen < 1e4 ? remainingLen : 1e4;
        const bytes = decoder.arr.subarray(decoder.pos, decoder.pos + nextLen);
        decoder.pos += nextLen;
        encodedString += String.fromCodePoint.apply(
          null,
          /** @type {any} */
          bytes
        );
        remainingLen -= nextLen;
      }
    }
    return decodeURIComponent(escape(encodedString));
  }
};
var _readVarStringNative = (decoder) => (
  /** @type any */
  utf8TextDecoder.decode(readVarUint8Array(decoder))
);
var readVarString = utf8TextDecoder ? _readVarStringNative : _readVarStringPolyfill;
var readFromDataView = (decoder, len) => {
  const dv = new DataView(decoder.arr.buffer, decoder.arr.byteOffset + decoder.pos, len);
  decoder.pos += len;
  return dv;
};
var readFloat32 = (decoder) => readFromDataView(decoder, 4).getFloat32(0, false);
var readFloat64 = (decoder) => readFromDataView(decoder, 8).getFloat64(0, false);
var readBigInt64 = (decoder) => (
  /** @type {any} */
  readFromDataView(decoder, 8).getBigInt64(0, false)
);
var readAnyLookupTable = [
  (decoder) => void 0,
  // CASE 127: undefined
  (decoder) => null,
  // CASE 126: null
  readVarInt,
  // CASE 125: integer
  readFloat32,
  // CASE 124: float32
  readFloat64,
  // CASE 123: float64
  readBigInt64,
  // CASE 122: bigint
  (decoder) => false,
  // CASE 121: boolean (false)
  (decoder) => true,
  // CASE 120: boolean (true)
  readVarString,
  // CASE 119: string
  (decoder) => {
    const len = readVarUint(decoder);
    const obj = {};
    for (let i = 0; i < len; i++) {
      const key = readVarString(decoder);
      obj[key] = readAny(decoder);
    }
    return obj;
  },
  (decoder) => {
    const len = readVarUint(decoder);
    const arr = [];
    for (let i = 0; i < len; i++) {
      arr.push(readAny(decoder));
    }
    return arr;
  },
  readVarUint8Array
  // CASE 116: Uint8Array
];
var readAny = (decoder) => readAnyLookupTable[127 - readUint8(decoder)](decoder);
var RleDecoder = class extends Decoder {
  /**
   * @param {Uint8Array} uint8Array
   * @param {function(Decoder):T} reader
   */
  constructor(uint8Array, reader) {
    super(uint8Array);
    this.reader = reader;
    this.s = null;
    this.count = 0;
  }
  read() {
    if (this.count === 0) {
      this.s = this.reader(this);
      if (hasContent(this)) {
        this.count = readVarUint(this) + 1;
      } else {
        this.count = -1;
      }
    }
    this.count--;
    return (
      /** @type {T} */
      this.s
    );
  }
};
var UintOptRleDecoder = class extends Decoder {
  /**
   * @param {Uint8Array} uint8Array
   */
  constructor(uint8Array) {
    super(uint8Array);
    this.s = 0;
    this.count = 0;
  }
  read() {
    if (this.count === 0) {
      this.s = readVarInt(this);
      const isNegative = isNegativeZero(this.s);
      this.count = 1;
      if (isNegative) {
        this.s = -this.s;
        this.count = readVarUint(this) + 2;
      }
    }
    this.count--;
    return (
      /** @type {number} */
      this.s
    );
  }
};
var IntDiffOptRleDecoder = class extends Decoder {
  /**
   * @param {Uint8Array} uint8Array
   */
  constructor(uint8Array) {
    super(uint8Array);
    this.s = 0;
    this.count = 0;
    this.diff = 0;
  }
  /**
   * @return {number}
   */
  read() {
    if (this.count === 0) {
      const diff = readVarInt(this);
      const hasCount = diff & 1;
      this.diff = floor(diff / 2);
      this.count = 1;
      if (hasCount) {
        this.count = readVarUint(this) + 2;
      }
    }
    this.s += this.diff;
    this.count--;
    return this.s;
  }
};
var StringDecoder = class {
  /**
   * @param {Uint8Array} uint8Array
   */
  constructor(uint8Array) {
    this.decoder = new UintOptRleDecoder(uint8Array);
    this.str = readVarString(this.decoder);
    this.spos = 0;
  }
  /**
   * @return {string}
   */
  read() {
    const end = this.spos + this.decoder.read();
    const res = this.str.slice(this.spos, end);
    this.spos = end;
    return res;
  }
};

// node_modules/lib0/webcrypto.js
var subtle = crypto.subtle;
var getRandomValues = crypto.getRandomValues.bind(crypto);

// node_modules/lib0/random.js
var rand = Math.random;
var uint32 = () => getRandomValues(new Uint32Array(1))[0];
var uuidv4Template = [1e7] + -1e3 + -4e3 + -8e3 + -1e11;
var uuidv4 = () => uuidv4Template.replace(
  /[018]/g,
  /** @param {number} c */
  (c) => (c ^ uint32() & 15 >> c / 4).toString(16)
);

// node_modules/lib0/promise.js
var create4 = (f) => (
  /** @type {Promise<T>} */
  new Promise(f)
);
var all = Promise.all.bind(Promise);
var reject = (reason) => Promise.reject(reason);
var resolve = (res) => Promise.resolve(res);

// node_modules/lib0/conditions.js
var undefinedToNull = (v) => v === void 0 ? null : v;

// node_modules/lib0/storage.js
var VarStoragePolyfill = class {
  constructor() {
    this.map = /* @__PURE__ */ new Map();
  }
  /**
   * @param {string} key
   * @param {any} newValue
   */
  setItem(key, newValue) {
    this.map.set(key, newValue);
  }
  /**
   * @param {string} key
   */
  getItem(key) {
    return this.map.get(key);
  }
};
var _localStorage = new VarStoragePolyfill();
var usePolyfill = true;
try {
  if (typeof localStorage !== "undefined" && localStorage) {
    _localStorage = localStorage;
    usePolyfill = false;
  }
} catch (e) {
}
var varStorage = _localStorage;
var onChange = (eventHandler) => usePolyfill || addEventListener(
  "storage",
  /** @type {any} */
  eventHandler
);
var offChange = (eventHandler) => usePolyfill || removeEventListener(
  "storage",
  /** @type {any} */
  eventHandler
);

// node_modules/lib0/object.js
var assign = Object.assign;
var keys = Object.keys;
var forEach = (obj, f) => {
  for (const key in obj) {
    f(obj[key], key);
  }
};
var length2 = (obj) => keys(obj).length;
var isEmpty = (obj) => {
  for (const _k in obj) {
    return false;
  }
  return true;
};
var every = (obj, f) => {
  for (const key in obj) {
    if (!f(obj[key], key)) {
      return false;
    }
  }
  return true;
};
var hasProperty = (obj, key) => Object.prototype.hasOwnProperty.call(obj, key);
var equalFlat = (a, b) => a === b || length2(a) === length2(b) && every(a, (val, key) => (val !== void 0 || hasProperty(b, key)) && b[key] === val);

// node_modules/lib0/function.js
var callAll = (fs, args2, i = 0) => {
  try {
    for (; i < fs.length; i++) {
      fs[i](...args2);
    }
  } finally {
    if (i < fs.length) {
      callAll(fs, args2, i + 1);
    }
  }
};
var nop = () => {
};
var id = (a) => a;
var equalityStrict = (a, b) => a === b;
var equalityDeep = (a, b) => {
  if (a == null || b == null) {
    return equalityStrict(a, b);
  }
  if (a.constructor !== b.constructor) {
    return false;
  }
  if (a === b) {
    return true;
  }
  switch (a.constructor) {
    case ArrayBuffer:
      a = new Uint8Array(a);
      b = new Uint8Array(b);
    case Uint8Array: {
      if (a.byteLength !== b.byteLength) {
        return false;
      }
      for (let i = 0; i < a.length; i++) {
        if (a[i] !== b[i]) {
          return false;
        }
      }
      break;
    }
    case Set: {
      if (a.size !== b.size) {
        return false;
      }
      for (const value of a) {
        if (!b.has(value)) {
          return false;
        }
      }
      break;
    }
    case Map: {
      if (a.size !== b.size) {
        return false;
      }
      for (const key of a.keys()) {
        if (!b.has(key) || !equalityDeep(a.get(key), b.get(key))) {
          return false;
        }
      }
      break;
    }
    case Object:
      if (length2(a) !== length2(b)) {
        return false;
      }
      for (const key in a) {
        if (!hasProperty(a, key) || !equalityDeep(a[key], b[key])) {
          return false;
        }
      }
      break;
    case Array:
      if (a.length !== b.length) {
        return false;
      }
      for (let i = 0; i < a.length; i++) {
        if (!equalityDeep(a[i], b[i])) {
          return false;
        }
      }
      break;
    default:
      return false;
  }
  return true;
};
var isOneOf = (value, options) => options.includes(value);

// node_modules/lib0/environment.js
var isNode = typeof process !== "undefined" && process.release && /node|io\.js/.test(process.release.name) && Object.prototype.toString.call(typeof process !== "undefined" ? process : 0) === "[object process]";
var isBrowser = typeof window !== "undefined" && typeof document !== "undefined" && !isNode;
var isMac = typeof navigator !== "undefined" ? /Mac/.test(navigator.platform) : false;
var params;
var args = [];
var computeParams = () => {
  if (params === void 0) {
    if (isNode) {
      params = create();
      const pargs = process.argv;
      let currParamName = null;
      for (let i = 0; i < pargs.length; i++) {
        const parg = pargs[i];
        if (parg[0] === "-") {
          if (currParamName !== null) {
            params.set(currParamName, "");
          }
          currParamName = parg;
        } else {
          if (currParamName !== null) {
            params.set(currParamName, parg);
            currParamName = null;
          } else {
            args.push(parg);
          }
        }
      }
      if (currParamName !== null) {
        params.set(currParamName, "");
      }
    } else if (typeof location === "object") {
      params = create();
      (location.search || "?").slice(1).split("&").forEach((kv) => {
        if (kv.length !== 0) {
          const [key, value] = kv.split("=");
          params.set(`--${fromCamelCase(key, "-")}`, value);
          params.set(`-${fromCamelCase(key, "-")}`, value);
        }
      });
    } else {
      params = create();
    }
  }
  return params;
};
var hasParam = (name) => computeParams().has(name);
var getVariable = (name) => isNode ? undefinedToNull(process.env[name.toUpperCase()]) : undefinedToNull(varStorage.getItem(name));
var hasConf = (name) => hasParam("--" + name) || getVariable(name) !== null;
var production = hasConf("production");
var forceColor = isNode && isOneOf(process.env.FORCE_COLOR, ["true", "1", "2"]);
var supportsColor = !hasParam("no-colors") && (!isNode || process.stdout.isTTY || forceColor) && (!isNode || hasParam("color") || forceColor || getVariable("COLORTERM") !== null || (getVariable("TERM") || "").includes("color"));

// node_modules/lib0/buffer.js
var createUint8ArrayFromLen = (len) => new Uint8Array(len);
var createUint8ArrayViewFromArrayBuffer = (buffer, byteOffset, length3) => new Uint8Array(buffer, byteOffset, length3);
var createUint8ArrayFromArrayBuffer = (buffer) => new Uint8Array(buffer);
var toBase64Browser = (bytes) => {
  let s = "";
  for (let i = 0; i < bytes.byteLength; i++) {
    s += fromCharCode(bytes[i]);
  }
  return btoa(s);
};
var toBase64Node = (bytes) => Buffer.from(bytes.buffer, bytes.byteOffset, bytes.byteLength).toString("base64");
var fromBase64Browser = (s) => {
  const a = atob(s);
  const bytes = createUint8ArrayFromLen(a.length);
  for (let i = 0; i < a.length; i++) {
    bytes[i] = a.charCodeAt(i);
  }
  return bytes;
};
var fromBase64Node = (s) => {
  const buf = Buffer.from(s, "base64");
  return createUint8ArrayViewFromArrayBuffer(buf.buffer, buf.byteOffset, buf.byteLength);
};
var toBase64 = isBrowser ? toBase64Browser : toBase64Node;
var fromBase64 = isBrowser ? fromBase64Browser : fromBase64Node;
var copyUint8Array = (uint8Array) => {
  const newBuf = createUint8ArrayFromLen(uint8Array.byteLength);
  newBuf.set(uint8Array);
  return newBuf;
};

// node_modules/lib0/pair.js
var Pair = class {
  /**
   * @param {L} left
   * @param {R} right
   */
  constructor(left, right) {
    this.left = left;
    this.right = right;
  }
};
var create5 = (left, right) => new Pair(left, right);
var forEach2 = (arr, f) => arr.forEach((p) => f(p.left, p.right));

// node_modules/lib0/dom.js
var doc = (
  /** @type {Document} */
  typeof document !== "undefined" ? document : {}
);
var createElement = (name) => doc.createElement(name);
var createDocumentFragment = () => doc.createDocumentFragment();
var createTextNode = (text2) => doc.createTextNode(text2);
var domParser = (
  /** @type {DOMParser} */
  typeof DOMParser !== "undefined" ? new DOMParser() : null
);
var setAttributes = (el, attrs) => {
  forEach2(attrs, (key, value) => {
    if (value === false) {
      el.removeAttribute(key);
    } else if (value === true) {
      el.setAttribute(key, "");
    } else {
      el.setAttribute(key, value);
    }
  });
  return el;
};
var fragment = (children) => {
  const fragment2 = createDocumentFragment();
  for (let i = 0; i < children.length; i++) {
    appendChild(fragment2, children[i]);
  }
  return fragment2;
};
var append = (parent, nodes) => {
  appendChild(parent, fragment(nodes));
  return parent;
};
var element = (name, attrs = [], children = []) => append(setAttributes(createElement(name), attrs), children);
var text = createTextNode;
var mapToStyleString = (m) => map(m, (value, key) => `${key}:${value};`).join("");
var appendChild = (parent, child) => parent.appendChild(child);
var ELEMENT_NODE = doc.ELEMENT_NODE;
var TEXT_NODE = doc.TEXT_NODE;
var CDATA_SECTION_NODE = doc.CDATA_SECTION_NODE;
var COMMENT_NODE = doc.COMMENT_NODE;
var DOCUMENT_NODE = doc.DOCUMENT_NODE;
var DOCUMENT_TYPE_NODE = doc.DOCUMENT_TYPE_NODE;
var DOCUMENT_FRAGMENT_NODE = doc.DOCUMENT_FRAGMENT_NODE;

// node_modules/lib0/symbol.js
var create6 = Symbol;

// node_modules/lib0/logging.common.js
var BOLD = create6();
var UNBOLD = create6();
var BLUE = create6();
var GREY = create6();
var GREEN = create6();
var RED = create6();
var PURPLE = create6();
var ORANGE = create6();
var UNCOLOR = create6();
var computeNoColorLoggingArgs = (args2) => {
  const strBuilder = [];
  const logArgs = [];
  let i = 0;
  for (; i < args2.length; i++) {
    const arg = args2[i];
    if (arg.constructor === String || arg.constructor === Number) {
      strBuilder.push(arg);
    } else if (arg.constructor === Object) {
      logArgs.push(JSON.stringify(arg));
    }
  }
  return logArgs;
};
var loggingColors = [GREEN, PURPLE, ORANGE, BLUE];
var nextColor = 0;
var lastLoggingTime = getUnixTime();
var createModuleLogger = (_print, moduleName) => {
  const color = loggingColors[nextColor];
  const debugRegexVar = getVariable("log");
  const doLogging = debugRegexVar !== null && (debugRegexVar === "*" || debugRegexVar === "true" || new RegExp(debugRegexVar, "gi").test(moduleName));
  nextColor = (nextColor + 1) % loggingColors.length;
  moduleName += ": ";
  return !doLogging ? nop : (...args2) => {
    const timeNow = getUnixTime();
    const timeDiff = timeNow - lastLoggingTime;
    lastLoggingTime = timeNow;
    _print(
      color,
      moduleName,
      UNCOLOR,
      ...args2.map(
        (arg) => typeof arg === "string" || typeof arg === "symbol" ? arg : JSON.stringify(arg)
      ),
      color,
      " +" + timeDiff + "ms"
    );
  };
};

// node_modules/lib0/logging.js
var _browserStyleMap = {
  [BOLD]: create5("font-weight", "bold"),
  [UNBOLD]: create5("font-weight", "normal"),
  [BLUE]: create5("color", "blue"),
  [GREEN]: create5("color", "green"),
  [GREY]: create5("color", "grey"),
  [RED]: create5("color", "red"),
  [PURPLE]: create5("color", "purple"),
  [ORANGE]: create5("color", "orange"),
  // not well supported in chrome when debugging node with inspector - TODO: deprecate
  [UNCOLOR]: create5("color", "black")
};
var computeBrowserLoggingArgs = (args2) => {
  const strBuilder = [];
  const styles = [];
  const currentStyle = create();
  let logArgs = [];
  let i = 0;
  for (; i < args2.length; i++) {
    const arg = args2[i];
    const style = _browserStyleMap[arg];
    if (style !== void 0) {
      currentStyle.set(style.left, style.right);
    } else {
      if (arg.constructor === String || arg.constructor === Number) {
        const style2 = mapToStyleString(currentStyle);
        if (i > 0 || style2.length > 0) {
          strBuilder.push("%c" + arg);
          styles.push(style2);
        } else {
          strBuilder.push(arg);
        }
      } else {
        break;
      }
    }
  }
  if (i > 0) {
    logArgs = styles;
    logArgs.unshift(strBuilder.join(""));
  }
  for (; i < args2.length; i++) {
    const arg = args2[i];
    if (!(arg instanceof Symbol)) {
      logArgs.push(arg);
    }
  }
  return logArgs;
};
var computeLoggingArgs = supportsColor ? computeBrowserLoggingArgs : computeNoColorLoggingArgs;
var print = (...args2) => {
  console.log(...computeLoggingArgs(args2));
  vconsoles.forEach((vc) => vc.print(args2));
};
var warn = (...args2) => {
  console.warn(...computeLoggingArgs(args2));
  args2.unshift(ORANGE);
  vconsoles.forEach((vc) => vc.print(args2));
};
var vconsoles = create2();
var createModuleLogger2 = (moduleName) => createModuleLogger(print, moduleName);

// node_modules/lib0/iterator.js
var createIterator = (next) => ({
  /**
   * @return {IterableIterator<T>}
   */
  [Symbol.iterator]() {
    return this;
  },
  // @ts-ignore
  next
});
var iteratorFilter = (iterator, filter) => createIterator(() => {
  let res;
  do {
    res = iterator.next();
  } while (!res.done && !filter(res.value));
  return res;
});
var iteratorMap = (iterator, fmap) => createIterator(() => {
  const { done, value } = iterator.next();
  return { done, value: done ? void 0 : fmap(value) };
});

// node_modules/yjs/dist/yjs.mjs
var DeleteItem = class {
  /**
   * @param {number} clock
   * @param {number} len
   */
  constructor(clock, len) {
    this.clock = clock;
    this.len = len;
  }
};
var DeleteSet = class {
  constructor() {
    this.clients = /* @__PURE__ */ new Map();
  }
};
var iterateDeletedStructs = (transaction, ds, f) => ds.clients.forEach((deletes, clientid) => {
  const structs = (
    /** @type {Array<GC|Item>} */
    transaction.doc.store.clients.get(clientid)
  );
  for (let i = 0; i < deletes.length; i++) {
    const del2 = deletes[i];
    iterateStructs(transaction, structs, del2.clock, del2.len, f);
  }
});
var findIndexDS = (dis, clock) => {
  let left = 0;
  let right = dis.length - 1;
  while (left <= right) {
    const midindex = floor((left + right) / 2);
    const mid = dis[midindex];
    const midclock = mid.clock;
    if (midclock <= clock) {
      if (clock < midclock + mid.len) {
        return midindex;
      }
      left = midindex + 1;
    } else {
      right = midindex - 1;
    }
  }
  return null;
};
var isDeleted = (ds, id2) => {
  const dis = ds.clients.get(id2.client);
  return dis !== void 0 && findIndexDS(dis, id2.clock) !== null;
};
var sortAndMergeDeleteSet = (ds) => {
  ds.clients.forEach((dels) => {
    dels.sort((a, b) => a.clock - b.clock);
    let i, j;
    for (i = 1, j = 1; i < dels.length; i++) {
      const left = dels[j - 1];
      const right = dels[i];
      if (left.clock + left.len >= right.clock) {
        left.len = max(left.len, right.clock + right.len - left.clock);
      } else {
        if (j < i) {
          dels[j] = right;
        }
        j++;
      }
    }
    dels.length = j;
  });
};
var mergeDeleteSets = (dss) => {
  const merged = new DeleteSet();
  for (let dssI = 0; dssI < dss.length; dssI++) {
    dss[dssI].clients.forEach((delsLeft, client) => {
      if (!merged.clients.has(client)) {
        const dels = delsLeft.slice();
        for (let i = dssI + 1; i < dss.length; i++) {
          appendTo(dels, dss[i].clients.get(client) || []);
        }
        merged.clients.set(client, dels);
      }
    });
  }
  sortAndMergeDeleteSet(merged);
  return merged;
};
var addToDeleteSet = (ds, client, clock, length3) => {
  setIfUndefined(ds.clients, client, () => (
    /** @type {Array<DeleteItem>} */
    []
  )).push(new DeleteItem(clock, length3));
};
var createDeleteSet = () => new DeleteSet();
var createDeleteSetFromStructStore = (ss) => {
  const ds = createDeleteSet();
  ss.clients.forEach((structs, client) => {
    const dsitems = [];
    for (let i = 0; i < structs.length; i++) {
      const struct = structs[i];
      if (struct.deleted) {
        const clock = struct.id.clock;
        let len = struct.length;
        if (i + 1 < structs.length) {
          for (let next = structs[i + 1]; i + 1 < structs.length && next.deleted; next = structs[++i + 1]) {
            len += next.length;
          }
        }
        dsitems.push(new DeleteItem(clock, len));
      }
    }
    if (dsitems.length > 0) {
      ds.clients.set(client, dsitems);
    }
  });
  return ds;
};
var writeDeleteSet = (encoder, ds) => {
  writeVarUint(encoder.restEncoder, ds.clients.size);
  from(ds.clients.entries()).sort((a, b) => b[0] - a[0]).forEach(([client, dsitems]) => {
    encoder.resetDsCurVal();
    writeVarUint(encoder.restEncoder, client);
    const len = dsitems.length;
    writeVarUint(encoder.restEncoder, len);
    for (let i = 0; i < len; i++) {
      const item = dsitems[i];
      encoder.writeDsClock(item.clock);
      encoder.writeDsLen(item.len);
    }
  });
};
var readDeleteSet = (decoder) => {
  const ds = new DeleteSet();
  const numClients = readVarUint(decoder.restDecoder);
  for (let i = 0; i < numClients; i++) {
    decoder.resetDsCurVal();
    const client = readVarUint(decoder.restDecoder);
    const numberOfDeletes = readVarUint(decoder.restDecoder);
    if (numberOfDeletes > 0) {
      const dsField = setIfUndefined(ds.clients, client, () => (
        /** @type {Array<DeleteItem>} */
        []
      ));
      for (let i2 = 0; i2 < numberOfDeletes; i2++) {
        dsField.push(new DeleteItem(decoder.readDsClock(), decoder.readDsLen()));
      }
    }
  }
  return ds;
};
var readAndApplyDeleteSet = (decoder, transaction, store) => {
  const unappliedDS = new DeleteSet();
  const numClients = readVarUint(decoder.restDecoder);
  for (let i = 0; i < numClients; i++) {
    decoder.resetDsCurVal();
    const client = readVarUint(decoder.restDecoder);
    const numberOfDeletes = readVarUint(decoder.restDecoder);
    const structs = store.clients.get(client) || [];
    const state = getState(store, client);
    for (let i2 = 0; i2 < numberOfDeletes; i2++) {
      const clock = decoder.readDsClock();
      const clockEnd = clock + decoder.readDsLen();
      if (clock < state) {
        if (state < clockEnd) {
          addToDeleteSet(unappliedDS, client, state, clockEnd - state);
        }
        let index = findIndexSS(structs, clock);
        let struct = structs[index];
        if (!struct.deleted && struct.id.clock < clock) {
          structs.splice(index + 1, 0, splitItem(transaction, struct, clock - struct.id.clock));
          index++;
        }
        while (index < structs.length) {
          struct = structs[index++];
          if (struct.id.clock < clockEnd) {
            if (!struct.deleted) {
              if (clockEnd < struct.id.clock + struct.length) {
                structs.splice(index, 0, splitItem(transaction, struct, clockEnd - struct.id.clock));
              }
              struct.delete(transaction);
            }
          } else {
            break;
          }
        }
      } else {
        addToDeleteSet(unappliedDS, client, clock, clockEnd - clock);
      }
    }
  }
  if (unappliedDS.clients.size > 0) {
    const ds = new UpdateEncoderV2();
    writeVarUint(ds.restEncoder, 0);
    writeDeleteSet(ds, unappliedDS);
    return ds.toUint8Array();
  }
  return null;
};
var generateNewClientId = uint32;
var Doc = class extends Observable {
  /**
   * @param {DocOpts} opts configuration
   */
  constructor({ guid = uuidv4(), collectionid = null, gc = true, gcFilter = () => true, meta = null, autoLoad = false, shouldLoad = true } = {}) {
    super();
    this.gc = gc;
    this.gcFilter = gcFilter;
    this.clientID = generateNewClientId();
    this.guid = guid;
    this.collectionid = collectionid;
    this.share = /* @__PURE__ */ new Map();
    this.store = new StructStore();
    this._transaction = null;
    this._transactionCleanups = [];
    this.subdocs = /* @__PURE__ */ new Set();
    this._item = null;
    this.shouldLoad = shouldLoad;
    this.autoLoad = autoLoad;
    this.meta = meta;
    this.isLoaded = false;
    this.isSynced = false;
    this.whenLoaded = create4((resolve2) => {
      this.on("load", () => {
        this.isLoaded = true;
        resolve2(this);
      });
    });
    const provideSyncedPromise = () => create4((resolve2) => {
      const eventHandler = (isSynced) => {
        if (isSynced === void 0 || isSynced === true) {
          this.off("sync", eventHandler);
          resolve2();
        }
      };
      this.on("sync", eventHandler);
    });
    this.on("sync", (isSynced) => {
      if (isSynced === false && this.isSynced) {
        this.whenSynced = provideSyncedPromise();
      }
      this.isSynced = isSynced === void 0 || isSynced === true;
      if (!this.isLoaded) {
        this.emit("load", []);
      }
    });
    this.whenSynced = provideSyncedPromise();
  }
  /**
   * Notify the parent document that you request to load data into this subdocument (if it is a subdocument).
   *
   * `load()` might be used in the future to request any provider to load the most current data.
   *
   * It is safe to call `load()` multiple times.
   */
  load() {
    const item = this._item;
    if (item !== null && !this.shouldLoad) {
      transact(
        /** @type {any} */
        item.parent.doc,
        (transaction) => {
          transaction.subdocsLoaded.add(this);
        },
        null,
        true
      );
    }
    this.shouldLoad = true;
  }
  getSubdocs() {
    return this.subdocs;
  }
  getSubdocGuids() {
    return new Set(from(this.subdocs).map((doc2) => doc2.guid));
  }
  /**
   * Changes that happen inside of a transaction are bundled. This means that
   * the observer fires _after_ the transaction is finished and that all changes
   * that happened inside of the transaction are sent as one message to the
   * other peers.
   *
   * @template T
   * @param {function(Transaction):T} f The function that should be executed as a transaction
   * @param {any} [origin] Origin of who started the transaction. Will be stored on transaction.origin
   * @return T
   *
   * @public
   */
  transact(f, origin = null) {
    return transact(this, f, origin);
  }
  /**
   * Define a shared data type.
   *
   * Multiple calls of `y.get(name, TypeConstructor)` yield the same result
   * and do not overwrite each other. I.e.
   * `y.define(name, Y.Array) === y.define(name, Y.Array)`
   *
   * After this method is called, the type is also available on `y.share.get(name)`.
   *
   * *Best Practices:*
   * Define all types right after the Yjs instance is created and store them in a separate object.
   * Also use the typed methods `getText(name)`, `getArray(name)`, ..
   *
   * @example
   *   const y = new Y(..)
   *   const appState = {
   *     document: y.getText('document')
   *     comments: y.getArray('comments')
   *   }
   *
   * @param {string} name
   * @param {Function} TypeConstructor The constructor of the type definition. E.g. Y.Text, Y.Array, Y.Map, ...
   * @return {AbstractType<any>} The created type. Constructed with TypeConstructor
   *
   * @public
   */
  get(name, TypeConstructor = AbstractType) {
    const type2 = setIfUndefined(this.share, name, () => {
      const t = new TypeConstructor();
      t._integrate(this, null);
      return t;
    });
    const Constr = type2.constructor;
    if (TypeConstructor !== AbstractType && Constr !== TypeConstructor) {
      if (Constr === AbstractType) {
        const t = new TypeConstructor();
        t._map = type2._map;
        type2._map.forEach(
          /** @param {Item?} n */
          (n) => {
            for (; n !== null; n = n.left) {
              n.parent = t;
            }
          }
        );
        t._start = type2._start;
        for (let n = t._start; n !== null; n = n.right) {
          n.parent = t;
        }
        t._length = type2._length;
        this.share.set(name, t);
        t._integrate(this, null);
        return t;
      } else {
        throw new Error(`Type with the name ${name} has already been defined with a different constructor`);
      }
    }
    return type2;
  }
  /**
   * @template T
   * @param {string} [name]
   * @return {YArray<T>}
   *
   * @public
   */
  getArray(name = "") {
    return this.get(name, YArray);
  }
  /**
   * @param {string} [name]
   * @return {YText}
   *
   * @public
   */
  getText(name = "") {
    return this.get(name, YText);
  }
  /**
   * @template T
   * @param {string} [name]
   * @return {YMap<T>}
   *
   * @public
   */
  getMap(name = "") {
    return this.get(name, YMap);
  }
  /**
   * @param {string} [name]
   * @return {YXmlFragment}
   *
   * @public
   */
  getXmlFragment(name = "") {
    return this.get(name, YXmlFragment);
  }
  /**
   * Converts the entire document into a js object, recursively traversing each yjs type
   * Doesn't log types that have not been defined (using ydoc.getType(..)).
   *
   * @deprecated Do not use this method and rather call toJSON directly on the shared types.
   *
   * @return {Object<string, any>}
   */
  toJSON() {
    const doc2 = {};
    this.share.forEach((value, key) => {
      doc2[key] = value.toJSON();
    });
    return doc2;
  }
  /**
   * Emit `destroy` event and unregister all event handlers.
   */
  destroy() {
    from(this.subdocs).forEach((subdoc) => subdoc.destroy());
    const item = this._item;
    if (item !== null) {
      this._item = null;
      const content = (
        /** @type {ContentDoc} */
        item.content
      );
      content.doc = new Doc({ guid: this.guid, ...content.opts, shouldLoad: false });
      content.doc._item = item;
      transact(
        /** @type {any} */
        item.parent.doc,
        (transaction) => {
          const doc2 = content.doc;
          if (!item.deleted) {
            transaction.subdocsAdded.add(doc2);
          }
          transaction.subdocsRemoved.add(this);
        },
        null,
        true
      );
    }
    this.emit("destroyed", [true]);
    this.emit("destroy", [this]);
    super.destroy();
  }
  /**
   * @param {string} eventName
   * @param {function(...any):any} f
   */
  on(eventName, f) {
    super.on(eventName, f);
  }
  /**
   * @param {string} eventName
   * @param {function} f
   */
  off(eventName, f) {
    super.off(eventName, f);
  }
};
var DSDecoderV1 = class {
  /**
   * @param {decoding.Decoder} decoder
   */
  constructor(decoder) {
    this.restDecoder = decoder;
  }
  resetDsCurVal() {
  }
  /**
   * @return {number}
   */
  readDsClock() {
    return readVarUint(this.restDecoder);
  }
  /**
   * @return {number}
   */
  readDsLen() {
    return readVarUint(this.restDecoder);
  }
};
var UpdateDecoderV1 = class extends DSDecoderV1 {
  /**
   * @return {ID}
   */
  readLeftID() {
    return createID(readVarUint(this.restDecoder), readVarUint(this.restDecoder));
  }
  /**
   * @return {ID}
   */
  readRightID() {
    return createID(readVarUint(this.restDecoder), readVarUint(this.restDecoder));
  }
  /**
   * Read the next client id.
   * Use this in favor of readID whenever possible to reduce the number of objects created.
   */
  readClient() {
    return readVarUint(this.restDecoder);
  }
  /**
   * @return {number} info An unsigned 8-bit integer
   */
  readInfo() {
    return readUint8(this.restDecoder);
  }
  /**
   * @return {string}
   */
  readString() {
    return readVarString(this.restDecoder);
  }
  /**
   * @return {boolean} isKey
   */
  readParentInfo() {
    return readVarUint(this.restDecoder) === 1;
  }
  /**
   * @return {number} info An unsigned 8-bit integer
   */
  readTypeRef() {
    return readVarUint(this.restDecoder);
  }
  /**
   * Write len of a struct - well suited for Opt RLE encoder.
   *
   * @return {number} len
   */
  readLen() {
    return readVarUint(this.restDecoder);
  }
  /**
   * @return {any}
   */
  readAny() {
    return readAny(this.restDecoder);
  }
  /**
   * @return {Uint8Array}
   */
  readBuf() {
    return copyUint8Array(readVarUint8Array(this.restDecoder));
  }
  /**
   * Legacy implementation uses JSON parse. We use any-decoding in v2.
   *
   * @return {any}
   */
  readJSON() {
    return JSON.parse(readVarString(this.restDecoder));
  }
  /**
   * @return {string}
   */
  readKey() {
    return readVarString(this.restDecoder);
  }
};
var DSDecoderV2 = class {
  /**
   * @param {decoding.Decoder} decoder
   */
  constructor(decoder) {
    this.dsCurrVal = 0;
    this.restDecoder = decoder;
  }
  resetDsCurVal() {
    this.dsCurrVal = 0;
  }
  /**
   * @return {number}
   */
  readDsClock() {
    this.dsCurrVal += readVarUint(this.restDecoder);
    return this.dsCurrVal;
  }
  /**
   * @return {number}
   */
  readDsLen() {
    const diff = readVarUint(this.restDecoder) + 1;
    this.dsCurrVal += diff;
    return diff;
  }
};
var UpdateDecoderV2 = class extends DSDecoderV2 {
  /**
   * @param {decoding.Decoder} decoder
   */
  constructor(decoder) {
    super(decoder);
    this.keys = [];
    readVarUint(decoder);
    this.keyClockDecoder = new IntDiffOptRleDecoder(readVarUint8Array(decoder));
    this.clientDecoder = new UintOptRleDecoder(readVarUint8Array(decoder));
    this.leftClockDecoder = new IntDiffOptRleDecoder(readVarUint8Array(decoder));
    this.rightClockDecoder = new IntDiffOptRleDecoder(readVarUint8Array(decoder));
    this.infoDecoder = new RleDecoder(readVarUint8Array(decoder), readUint8);
    this.stringDecoder = new StringDecoder(readVarUint8Array(decoder));
    this.parentInfoDecoder = new RleDecoder(readVarUint8Array(decoder), readUint8);
    this.typeRefDecoder = new UintOptRleDecoder(readVarUint8Array(decoder));
    this.lenDecoder = new UintOptRleDecoder(readVarUint8Array(decoder));
  }
  /**
   * @return {ID}
   */
  readLeftID() {
    return new ID(this.clientDecoder.read(), this.leftClockDecoder.read());
  }
  /**
   * @return {ID}
   */
  readRightID() {
    return new ID(this.clientDecoder.read(), this.rightClockDecoder.read());
  }
  /**
   * Read the next client id.
   * Use this in favor of readID whenever possible to reduce the number of objects created.
   */
  readClient() {
    return this.clientDecoder.read();
  }
  /**
   * @return {number} info An unsigned 8-bit integer
   */
  readInfo() {
    return (
      /** @type {number} */
      this.infoDecoder.read()
    );
  }
  /**
   * @return {string}
   */
  readString() {
    return this.stringDecoder.read();
  }
  /**
   * @return {boolean}
   */
  readParentInfo() {
    return this.parentInfoDecoder.read() === 1;
  }
  /**
   * @return {number} An unsigned 8-bit integer
   */
  readTypeRef() {
    return this.typeRefDecoder.read();
  }
  /**
   * Write len of a struct - well suited for Opt RLE encoder.
   *
   * @return {number}
   */
  readLen() {
    return this.lenDecoder.read();
  }
  /**
   * @return {any}
   */
  readAny() {
    return readAny(this.restDecoder);
  }
  /**
   * @return {Uint8Array}
   */
  readBuf() {
    return readVarUint8Array(this.restDecoder);
  }
  /**
   * This is mainly here for legacy purposes.
   *
   * Initial we incoded objects using JSON. Now we use the much faster lib0/any-encoder. This method mainly exists for legacy purposes for the v1 encoder.
   *
   * @return {any}
   */
  readJSON() {
    return readAny(this.restDecoder);
  }
  /**
   * @return {string}
   */
  readKey() {
    const keyClock = this.keyClockDecoder.read();
    if (keyClock < this.keys.length) {
      return this.keys[keyClock];
    } else {
      const key = this.stringDecoder.read();
      this.keys.push(key);
      return key;
    }
  }
};
var DSEncoderV1 = class {
  constructor() {
    this.restEncoder = createEncoder();
  }
  toUint8Array() {
    return toUint8Array(this.restEncoder);
  }
  resetDsCurVal() {
  }
  /**
   * @param {number} clock
   */
  writeDsClock(clock) {
    writeVarUint(this.restEncoder, clock);
  }
  /**
   * @param {number} len
   */
  writeDsLen(len) {
    writeVarUint(this.restEncoder, len);
  }
};
var UpdateEncoderV1 = class extends DSEncoderV1 {
  /**
   * @param {ID} id
   */
  writeLeftID(id2) {
    writeVarUint(this.restEncoder, id2.client);
    writeVarUint(this.restEncoder, id2.clock);
  }
  /**
   * @param {ID} id
   */
  writeRightID(id2) {
    writeVarUint(this.restEncoder, id2.client);
    writeVarUint(this.restEncoder, id2.clock);
  }
  /**
   * Use writeClient and writeClock instead of writeID if possible.
   * @param {number} client
   */
  writeClient(client) {
    writeVarUint(this.restEncoder, client);
  }
  /**
   * @param {number} info An unsigned 8-bit integer
   */
  writeInfo(info) {
    writeUint8(this.restEncoder, info);
  }
  /**
   * @param {string} s
   */
  writeString(s) {
    writeVarString(this.restEncoder, s);
  }
  /**
   * @param {boolean} isYKey
   */
  writeParentInfo(isYKey) {
    writeVarUint(this.restEncoder, isYKey ? 1 : 0);
  }
  /**
   * @param {number} info An unsigned 8-bit integer
   */
  writeTypeRef(info) {
    writeVarUint(this.restEncoder, info);
  }
  /**
   * Write len of a struct - well suited for Opt RLE encoder.
   *
   * @param {number} len
   */
  writeLen(len) {
    writeVarUint(this.restEncoder, len);
  }
  /**
   * @param {any} any
   */
  writeAny(any2) {
    writeAny(this.restEncoder, any2);
  }
  /**
   * @param {Uint8Array} buf
   */
  writeBuf(buf) {
    writeVarUint8Array(this.restEncoder, buf);
  }
  /**
   * @param {any} embed
   */
  writeJSON(embed) {
    writeVarString(this.restEncoder, JSON.stringify(embed));
  }
  /**
   * @param {string} key
   */
  writeKey(key) {
    writeVarString(this.restEncoder, key);
  }
};
var DSEncoderV2 = class {
  constructor() {
    this.restEncoder = createEncoder();
    this.dsCurrVal = 0;
  }
  toUint8Array() {
    return toUint8Array(this.restEncoder);
  }
  resetDsCurVal() {
    this.dsCurrVal = 0;
  }
  /**
   * @param {number} clock
   */
  writeDsClock(clock) {
    const diff = clock - this.dsCurrVal;
    this.dsCurrVal = clock;
    writeVarUint(this.restEncoder, diff);
  }
  /**
   * @param {number} len
   */
  writeDsLen(len) {
    if (len === 0) {
      unexpectedCase();
    }
    writeVarUint(this.restEncoder, len - 1);
    this.dsCurrVal += len;
  }
};
var UpdateEncoderV2 = class extends DSEncoderV2 {
  constructor() {
    super();
    this.keyMap = /* @__PURE__ */ new Map();
    this.keyClock = 0;
    this.keyClockEncoder = new IntDiffOptRleEncoder();
    this.clientEncoder = new UintOptRleEncoder();
    this.leftClockEncoder = new IntDiffOptRleEncoder();
    this.rightClockEncoder = new IntDiffOptRleEncoder();
    this.infoEncoder = new RleEncoder(writeUint8);
    this.stringEncoder = new StringEncoder();
    this.parentInfoEncoder = new RleEncoder(writeUint8);
    this.typeRefEncoder = new UintOptRleEncoder();
    this.lenEncoder = new UintOptRleEncoder();
  }
  toUint8Array() {
    const encoder = createEncoder();
    writeVarUint(encoder, 0);
    writeVarUint8Array(encoder, this.keyClockEncoder.toUint8Array());
    writeVarUint8Array(encoder, this.clientEncoder.toUint8Array());
    writeVarUint8Array(encoder, this.leftClockEncoder.toUint8Array());
    writeVarUint8Array(encoder, this.rightClockEncoder.toUint8Array());
    writeVarUint8Array(encoder, toUint8Array(this.infoEncoder));
    writeVarUint8Array(encoder, this.stringEncoder.toUint8Array());
    writeVarUint8Array(encoder, toUint8Array(this.parentInfoEncoder));
    writeVarUint8Array(encoder, this.typeRefEncoder.toUint8Array());
    writeVarUint8Array(encoder, this.lenEncoder.toUint8Array());
    writeUint8Array(encoder, toUint8Array(this.restEncoder));
    return toUint8Array(encoder);
  }
  /**
   * @param {ID} id
   */
  writeLeftID(id2) {
    this.clientEncoder.write(id2.client);
    this.leftClockEncoder.write(id2.clock);
  }
  /**
   * @param {ID} id
   */
  writeRightID(id2) {
    this.clientEncoder.write(id2.client);
    this.rightClockEncoder.write(id2.clock);
  }
  /**
   * @param {number} client
   */
  writeClient(client) {
    this.clientEncoder.write(client);
  }
  /**
   * @param {number} info An unsigned 8-bit integer
   */
  writeInfo(info) {
    this.infoEncoder.write(info);
  }
  /**
   * @param {string} s
   */
  writeString(s) {
    this.stringEncoder.write(s);
  }
  /**
   * @param {boolean} isYKey
   */
  writeParentInfo(isYKey) {
    this.parentInfoEncoder.write(isYKey ? 1 : 0);
  }
  /**
   * @param {number} info An unsigned 8-bit integer
   */
  writeTypeRef(info) {
    this.typeRefEncoder.write(info);
  }
  /**
   * Write len of a struct - well suited for Opt RLE encoder.
   *
   * @param {number} len
   */
  writeLen(len) {
    this.lenEncoder.write(len);
  }
  /**
   * @param {any} any
   */
  writeAny(any2) {
    writeAny(this.restEncoder, any2);
  }
  /**
   * @param {Uint8Array} buf
   */
  writeBuf(buf) {
    writeVarUint8Array(this.restEncoder, buf);
  }
  /**
   * This is mainly here for legacy purposes.
   *
   * Initial we incoded objects using JSON. Now we use the much faster lib0/any-encoder. This method mainly exists for legacy purposes for the v1 encoder.
   *
   * @param {any} embed
   */
  writeJSON(embed) {
    writeAny(this.restEncoder, embed);
  }
  /**
   * Property keys are often reused. For example, in y-prosemirror the key `bold` might
   * occur very often. For a 3d application, the key `position` might occur very often.
   *
   * We cache these keys in a Map and refer to them via a unique number.
   *
   * @param {string} key
   */
  writeKey(key) {
    const clock = this.keyMap.get(key);
    if (clock === void 0) {
      this.keyClockEncoder.write(this.keyClock++);
      this.stringEncoder.write(key);
    } else {
      this.keyClockEncoder.write(clock);
    }
  }
};
var writeStructs = (encoder, structs, client, clock) => {
  clock = max(clock, structs[0].id.clock);
  const startNewStructs = findIndexSS(structs, clock);
  writeVarUint(encoder.restEncoder, structs.length - startNewStructs);
  encoder.writeClient(client);
  writeVarUint(encoder.restEncoder, clock);
  const firstStruct = structs[startNewStructs];
  firstStruct.write(encoder, clock - firstStruct.id.clock);
  for (let i = startNewStructs + 1; i < structs.length; i++) {
    structs[i].write(encoder, 0);
  }
};
var writeClientsStructs = (encoder, store, _sm) => {
  const sm = /* @__PURE__ */ new Map();
  _sm.forEach((clock, client) => {
    if (getState(store, client) > clock) {
      sm.set(client, clock);
    }
  });
  getStateVector(store).forEach((_clock, client) => {
    if (!_sm.has(client)) {
      sm.set(client, 0);
    }
  });
  writeVarUint(encoder.restEncoder, sm.size);
  from(sm.entries()).sort((a, b) => b[0] - a[0]).forEach(([client, clock]) => {
    writeStructs(
      encoder,
      /** @type {Array<GC|Item>} */
      store.clients.get(client),
      client,
      clock
    );
  });
};
var readClientsStructRefs = (decoder, doc2) => {
  const clientRefs = create();
  const numOfStateUpdates = readVarUint(decoder.restDecoder);
  for (let i = 0; i < numOfStateUpdates; i++) {
    const numberOfStructs = readVarUint(decoder.restDecoder);
    const refs = new Array(numberOfStructs);
    const client = decoder.readClient();
    let clock = readVarUint(decoder.restDecoder);
    clientRefs.set(client, { i: 0, refs });
    for (let i2 = 0; i2 < numberOfStructs; i2++) {
      const info = decoder.readInfo();
      switch (BITS5 & info) {
        case 0: {
          const len = decoder.readLen();
          refs[i2] = new GC(createID(client, clock), len);
          clock += len;
          break;
        }
        case 10: {
          const len = readVarUint(decoder.restDecoder);
          refs[i2] = new Skip(createID(client, clock), len);
          clock += len;
          break;
        }
        default: {
          const cantCopyParentInfo = (info & (BIT7 | BIT8)) === 0;
          const struct = new Item(
            createID(client, clock),
            null,
            // leftd
            (info & BIT8) === BIT8 ? decoder.readLeftID() : null,
            // origin
            null,
            // right
            (info & BIT7) === BIT7 ? decoder.readRightID() : null,
            // right origin
            cantCopyParentInfo ? decoder.readParentInfo() ? doc2.get(decoder.readString()) : decoder.readLeftID() : null,
            // parent
            cantCopyParentInfo && (info & BIT6) === BIT6 ? decoder.readString() : null,
            // parentSub
            readItemContent(decoder, info)
            // item content
          );
          refs[i2] = struct;
          clock += struct.length;
        }
      }
    }
  }
  return clientRefs;
};
var integrateStructs = (transaction, store, clientsStructRefs) => {
  const stack = [];
  let clientsStructRefsIds = from(clientsStructRefs.keys()).sort((a, b) => a - b);
  if (clientsStructRefsIds.length === 0) {
    return null;
  }
  const getNextStructTarget = () => {
    if (clientsStructRefsIds.length === 0) {
      return null;
    }
    let nextStructsTarget = (
      /** @type {{i:number,refs:Array<GC|Item>}} */
      clientsStructRefs.get(clientsStructRefsIds[clientsStructRefsIds.length - 1])
    );
    while (nextStructsTarget.refs.length === nextStructsTarget.i) {
      clientsStructRefsIds.pop();
      if (clientsStructRefsIds.length > 0) {
        nextStructsTarget = /** @type {{i:number,refs:Array<GC|Item>}} */
        clientsStructRefs.get(clientsStructRefsIds[clientsStructRefsIds.length - 1]);
      } else {
        return null;
      }
    }
    return nextStructsTarget;
  };
  let curStructsTarget = getNextStructTarget();
  if (curStructsTarget === null && stack.length === 0) {
    return null;
  }
  const restStructs = new StructStore();
  const missingSV = /* @__PURE__ */ new Map();
  const updateMissingSv = (client, clock) => {
    const mclock = missingSV.get(client);
    if (mclock == null || mclock > clock) {
      missingSV.set(client, clock);
    }
  };
  let stackHead = (
    /** @type {any} */
    curStructsTarget.refs[
      /** @type {any} */
      curStructsTarget.i++
    ]
  );
  const state = /* @__PURE__ */ new Map();
  const addStackToRestSS = () => {
    for (const item of stack) {
      const client = item.id.client;
      const unapplicableItems = clientsStructRefs.get(client);
      if (unapplicableItems) {
        unapplicableItems.i--;
        restStructs.clients.set(client, unapplicableItems.refs.slice(unapplicableItems.i));
        clientsStructRefs.delete(client);
        unapplicableItems.i = 0;
        unapplicableItems.refs = [];
      } else {
        restStructs.clients.set(client, [item]);
      }
      clientsStructRefsIds = clientsStructRefsIds.filter((c) => c !== client);
    }
    stack.length = 0;
  };
  while (true) {
    if (stackHead.constructor !== Skip) {
      const localClock = setIfUndefined(state, stackHead.id.client, () => getState(store, stackHead.id.client));
      const offset = localClock - stackHead.id.clock;
      if (offset < 0) {
        stack.push(stackHead);
        updateMissingSv(stackHead.id.client, stackHead.id.clock - 1);
        addStackToRestSS();
      } else {
        const missing = stackHead.getMissing(transaction, store);
        if (missing !== null) {
          stack.push(stackHead);
          const structRefs = clientsStructRefs.get(
            /** @type {number} */
            missing
          ) || { refs: [], i: 0 };
          if (structRefs.refs.length === structRefs.i) {
            updateMissingSv(
              /** @type {number} */
              missing,
              getState(store, missing)
            );
            addStackToRestSS();
          } else {
            stackHead = structRefs.refs[structRefs.i++];
            continue;
          }
        } else if (offset === 0 || offset < stackHead.length) {
          stackHead.integrate(transaction, offset);
          state.set(stackHead.id.client, stackHead.id.clock + stackHead.length);
        }
      }
    }
    if (stack.length > 0) {
      stackHead = /** @type {GC|Item} */
      stack.pop();
    } else if (curStructsTarget !== null && curStructsTarget.i < curStructsTarget.refs.length) {
      stackHead = /** @type {GC|Item} */
      curStructsTarget.refs[curStructsTarget.i++];
    } else {
      curStructsTarget = getNextStructTarget();
      if (curStructsTarget === null) {
        break;
      } else {
        stackHead = /** @type {GC|Item} */
        curStructsTarget.refs[curStructsTarget.i++];
      }
    }
  }
  if (restStructs.clients.size > 0) {
    const encoder = new UpdateEncoderV2();
    writeClientsStructs(encoder, restStructs, /* @__PURE__ */ new Map());
    writeVarUint(encoder.restEncoder, 0);
    return { missing: missingSV, update: encoder.toUint8Array() };
  }
  return null;
};
var writeStructsFromTransaction = (encoder, transaction) => writeClientsStructs(encoder, transaction.doc.store, transaction.beforeState);
var readUpdateV2 = (decoder, ydoc, transactionOrigin, structDecoder = new UpdateDecoderV2(decoder)) => transact(ydoc, (transaction) => {
  transaction.local = false;
  let retry = false;
  const doc2 = transaction.doc;
  const store = doc2.store;
  const ss = readClientsStructRefs(structDecoder, doc2);
  const restStructs = integrateStructs(transaction, store, ss);
  const pending = store.pendingStructs;
  if (pending) {
    for (const [client, clock] of pending.missing) {
      if (clock < getState(store, client)) {
        retry = true;
        break;
      }
    }
    if (restStructs) {
      for (const [client, clock] of restStructs.missing) {
        const mclock = pending.missing.get(client);
        if (mclock == null || mclock > clock) {
          pending.missing.set(client, clock);
        }
      }
      pending.update = mergeUpdatesV2([pending.update, restStructs.update]);
    }
  } else {
    store.pendingStructs = restStructs;
  }
  const dsRest = readAndApplyDeleteSet(structDecoder, transaction, store);
  if (store.pendingDs) {
    const pendingDSUpdate = new UpdateDecoderV2(createDecoder(store.pendingDs));
    readVarUint(pendingDSUpdate.restDecoder);
    const dsRest2 = readAndApplyDeleteSet(pendingDSUpdate, transaction, store);
    if (dsRest && dsRest2) {
      store.pendingDs = mergeUpdatesV2([dsRest, dsRest2]);
    } else {
      store.pendingDs = dsRest || dsRest2;
    }
  } else {
    store.pendingDs = dsRest;
  }
  if (retry) {
    const update = (
      /** @type {{update: Uint8Array}} */
      store.pendingStructs.update
    );
    store.pendingStructs = null;
    applyUpdateV2(transaction.doc, update);
  }
}, transactionOrigin, false);
var applyUpdateV2 = (ydoc, update, transactionOrigin, YDecoder = UpdateDecoderV2) => {
  const decoder = createDecoder(update);
  readUpdateV2(decoder, ydoc, transactionOrigin, new YDecoder(decoder));
};
var applyUpdate = (ydoc, update, transactionOrigin) => applyUpdateV2(ydoc, update, transactionOrigin, UpdateDecoderV1);
var writeStateAsUpdate = (encoder, doc2, targetStateVector = /* @__PURE__ */ new Map()) => {
  writeClientsStructs(encoder, doc2.store, targetStateVector);
  writeDeleteSet(encoder, createDeleteSetFromStructStore(doc2.store));
};
var encodeStateAsUpdateV2 = (doc2, encodedTargetStateVector = new Uint8Array([0]), encoder = new UpdateEncoderV2()) => {
  const targetStateVector = decodeStateVector(encodedTargetStateVector);
  writeStateAsUpdate(encoder, doc2, targetStateVector);
  const updates = [encoder.toUint8Array()];
  if (doc2.store.pendingDs) {
    updates.push(doc2.store.pendingDs);
  }
  if (doc2.store.pendingStructs) {
    updates.push(diffUpdateV2(doc2.store.pendingStructs.update, encodedTargetStateVector));
  }
  if (updates.length > 1) {
    if (encoder.constructor === UpdateEncoderV1) {
      return mergeUpdates(updates.map((update, i) => i === 0 ? update : convertUpdateFormatV2ToV1(update)));
    } else if (encoder.constructor === UpdateEncoderV2) {
      return mergeUpdatesV2(updates);
    }
  }
  return updates[0];
};
var encodeStateAsUpdate = (doc2, encodedTargetStateVector) => encodeStateAsUpdateV2(doc2, encodedTargetStateVector, new UpdateEncoderV1());
var readStateVector = (decoder) => {
  const ss = /* @__PURE__ */ new Map();
  const ssLength = readVarUint(decoder.restDecoder);
  for (let i = 0; i < ssLength; i++) {
    const client = readVarUint(decoder.restDecoder);
    const clock = readVarUint(decoder.restDecoder);
    ss.set(client, clock);
  }
  return ss;
};
var decodeStateVector = (decodedState) => readStateVector(new DSDecoderV1(createDecoder(decodedState)));
var writeStateVector = (encoder, sv) => {
  writeVarUint(encoder.restEncoder, sv.size);
  from(sv.entries()).sort((a, b) => b[0] - a[0]).forEach(([client, clock]) => {
    writeVarUint(encoder.restEncoder, client);
    writeVarUint(encoder.restEncoder, clock);
  });
  return encoder;
};
var writeDocumentStateVector = (encoder, doc2) => writeStateVector(encoder, getStateVector(doc2.store));
var encodeStateVectorV2 = (doc2, encoder = new DSEncoderV2()) => {
  if (doc2 instanceof Map) {
    writeStateVector(encoder, doc2);
  } else {
    writeDocumentStateVector(encoder, doc2);
  }
  return encoder.toUint8Array();
};
var encodeStateVector = (doc2) => encodeStateVectorV2(doc2, new DSEncoderV1());
var EventHandler = class {
  constructor() {
    this.l = [];
  }
};
var createEventHandler = () => new EventHandler();
var addEventHandlerListener = (eventHandler, f) => eventHandler.l.push(f);
var removeEventHandlerListener = (eventHandler, f) => {
  const l = eventHandler.l;
  const len = l.length;
  eventHandler.l = l.filter((g) => f !== g);
  if (len === eventHandler.l.length) {
    console.error("[yjs] Tried to remove event handler that doesn't exist.");
  }
};
var callEventHandlerListeners = (eventHandler, arg0, arg1) => callAll(eventHandler.l, [arg0, arg1]);
var ID = class {
  /**
   * @param {number} client client id
   * @param {number} clock unique per client id, continuous number
   */
  constructor(client, clock) {
    this.client = client;
    this.clock = clock;
  }
};
var compareIDs = (a, b) => a === b || a !== null && b !== null && a.client === b.client && a.clock === b.clock;
var createID = (client, clock) => new ID(client, clock);
var findRootTypeKey = (type2) => {
  for (const [key, value] of type2.doc.share.entries()) {
    if (value === type2) {
      return key;
    }
  }
  throw unexpectedCase();
};
var isParentOf = (parent, child) => {
  while (child !== null) {
    if (child.parent === parent) {
      return true;
    }
    child = /** @type {AbstractType<any>} */
    child.parent._item;
  }
  return false;
};
var RelativePosition = class {
  /**
   * @param {ID|null} type
   * @param {string|null} tname
   * @param {ID|null} item
   * @param {number} assoc
   */
  constructor(type2, tname, item, assoc = 0) {
    this.type = type2;
    this.tname = tname;
    this.item = item;
    this.assoc = assoc;
  }
};
var relativePositionToJSON = (rpos) => {
  const json = {};
  if (rpos.type) {
    json.type = rpos.type;
  }
  if (rpos.tname) {
    json.tname = rpos.tname;
  }
  if (rpos.item) {
    json.item = rpos.item;
  }
  if (rpos.assoc != null) {
    json.assoc = rpos.assoc;
  }
  return json;
};
var createRelativePositionFromJSON = (json) => new RelativePosition(json.type == null ? null : createID(json.type.client, json.type.clock), json.tname || null, json.item == null ? null : createID(json.item.client, json.item.clock), json.assoc == null ? 0 : json.assoc);
var AbsolutePosition = class {
  /**
   * @param {AbstractType<any>} type
   * @param {number} index
   * @param {number} [assoc]
   */
  constructor(type2, index, assoc = 0) {
    this.type = type2;
    this.index = index;
    this.assoc = assoc;
  }
};
var createAbsolutePosition = (type2, index, assoc = 0) => new AbsolutePosition(type2, index, assoc);
var createRelativePosition = (type2, item, assoc) => {
  let typeid = null;
  let tname = null;
  if (type2._item === null) {
    tname = findRootTypeKey(type2);
  } else {
    typeid = createID(type2._item.id.client, type2._item.id.clock);
  }
  return new RelativePosition(typeid, tname, item, assoc);
};
var createRelativePositionFromTypeIndex = (type2, index, assoc = 0) => {
  let t = type2._start;
  if (assoc < 0) {
    if (index === 0) {
      return createRelativePosition(type2, null, assoc);
    }
    index--;
  }
  while (t !== null) {
    if (!t.deleted && t.countable) {
      if (t.length > index) {
        return createRelativePosition(type2, createID(t.id.client, t.id.clock + index), assoc);
      }
      index -= t.length;
    }
    if (t.right === null && assoc < 0) {
      return createRelativePosition(type2, t.lastId, assoc);
    }
    t = t.right;
  }
  return createRelativePosition(type2, null, assoc);
};
var createAbsolutePositionFromRelativePosition = (rpos, doc2) => {
  const store = doc2.store;
  const rightID = rpos.item;
  const typeID = rpos.type;
  const tname = rpos.tname;
  const assoc = rpos.assoc;
  let type2 = null;
  let index = 0;
  if (rightID !== null) {
    if (getState(store, rightID.client) <= rightID.clock) {
      return null;
    }
    const res = followRedone(store, rightID);
    const right = res.item;
    if (!(right instanceof Item)) {
      return null;
    }
    type2 = /** @type {AbstractType<any>} */
    right.parent;
    if (type2._item === null || !type2._item.deleted) {
      index = right.deleted || !right.countable ? 0 : res.diff + (assoc >= 0 ? 0 : 1);
      let n = right.left;
      while (n !== null) {
        if (!n.deleted && n.countable) {
          index += n.length;
        }
        n = n.left;
      }
    }
  } else {
    if (tname !== null) {
      type2 = doc2.get(tname);
    } else if (typeID !== null) {
      if (getState(store, typeID.client) <= typeID.clock) {
        return null;
      }
      const { item } = followRedone(store, typeID);
      if (item instanceof Item && item.content instanceof ContentType) {
        type2 = item.content.type;
      } else {
        return null;
      }
    } else {
      throw unexpectedCase();
    }
    if (assoc >= 0) {
      index = type2._length;
    } else {
      index = 0;
    }
  }
  return createAbsolutePosition(type2, index, rpos.assoc);
};
var compareRelativePositions = (a, b) => a === b || a !== null && b !== null && a.tname === b.tname && compareIDs(a.item, b.item) && compareIDs(a.type, b.type) && a.assoc === b.assoc;
var Snapshot = class {
  /**
   * @param {DeleteSet} ds
   * @param {Map<number,number>} sv state map
   */
  constructor(ds, sv) {
    this.ds = ds;
    this.sv = sv;
  }
};
var createSnapshot = (ds, sm) => new Snapshot(ds, sm);
var emptySnapshot = createSnapshot(createDeleteSet(), /* @__PURE__ */ new Map());
var isVisible = (item, snapshot) => snapshot === void 0 ? !item.deleted : snapshot.sv.has(item.id.client) && (snapshot.sv.get(item.id.client) || 0) > item.id.clock && !isDeleted(snapshot.ds, item.id);
var splitSnapshotAffectedStructs = (transaction, snapshot) => {
  const meta = setIfUndefined(transaction.meta, splitSnapshotAffectedStructs, create2);
  const store = transaction.doc.store;
  if (!meta.has(snapshot)) {
    snapshot.sv.forEach((clock, client) => {
      if (clock < getState(store, client)) {
        getItemCleanStart(transaction, createID(client, clock));
      }
    });
    iterateDeletedStructs(transaction, snapshot.ds, (_item) => {
    });
    meta.add(snapshot);
  }
};
var StructStore = class {
  constructor() {
    this.clients = /* @__PURE__ */ new Map();
    this.pendingStructs = null;
    this.pendingDs = null;
  }
};
var getStateVector = (store) => {
  const sm = /* @__PURE__ */ new Map();
  store.clients.forEach((structs, client) => {
    const struct = structs[structs.length - 1];
    sm.set(client, struct.id.clock + struct.length);
  });
  return sm;
};
var getState = (store, client) => {
  const structs = store.clients.get(client);
  if (structs === void 0) {
    return 0;
  }
  const lastStruct = structs[structs.length - 1];
  return lastStruct.id.clock + lastStruct.length;
};
var addStruct = (store, struct) => {
  let structs = store.clients.get(struct.id.client);
  if (structs === void 0) {
    structs = [];
    store.clients.set(struct.id.client, structs);
  } else {
    const lastStruct = structs[structs.length - 1];
    if (lastStruct.id.clock + lastStruct.length !== struct.id.clock) {
      throw unexpectedCase();
    }
  }
  structs.push(struct);
};
var findIndexSS = (structs, clock) => {
  let left = 0;
  let right = structs.length - 1;
  let mid = structs[right];
  let midclock = mid.id.clock;
  if (midclock === clock) {
    return right;
  }
  let midindex = floor(clock / (midclock + mid.length - 1) * right);
  while (left <= right) {
    mid = structs[midindex];
    midclock = mid.id.clock;
    if (midclock <= clock) {
      if (clock < midclock + mid.length) {
        return midindex;
      }
      left = midindex + 1;
    } else {
      right = midindex - 1;
    }
    midindex = floor((left + right) / 2);
  }
  throw unexpectedCase();
};
var find = (store, id2) => {
  const structs = store.clients.get(id2.client);
  return structs[findIndexSS(structs, id2.clock)];
};
var getItem = (
  /** @type {function(StructStore,ID):Item} */
  find
);
var findIndexCleanStart = (transaction, structs, clock) => {
  const index = findIndexSS(structs, clock);
  const struct = structs[index];
  if (struct.id.clock < clock && struct instanceof Item) {
    structs.splice(index + 1, 0, splitItem(transaction, struct, clock - struct.id.clock));
    return index + 1;
  }
  return index;
};
var getItemCleanStart = (transaction, id2) => {
  const structs = (
    /** @type {Array<Item>} */
    transaction.doc.store.clients.get(id2.client)
  );
  return structs[findIndexCleanStart(transaction, structs, id2.clock)];
};
var getItemCleanEnd = (transaction, store, id2) => {
  const structs = store.clients.get(id2.client);
  const index = findIndexSS(structs, id2.clock);
  const struct = structs[index];
  if (id2.clock !== struct.id.clock + struct.length - 1 && struct.constructor !== GC) {
    structs.splice(index + 1, 0, splitItem(transaction, struct, id2.clock - struct.id.clock + 1));
  }
  return struct;
};
var replaceStruct = (store, struct, newStruct) => {
  const structs = (
    /** @type {Array<GC|Item>} */
    store.clients.get(struct.id.client)
  );
  structs[findIndexSS(structs, struct.id.clock)] = newStruct;
};
var iterateStructs = (transaction, structs, clockStart, len, f) => {
  if (len === 0) {
    return;
  }
  const clockEnd = clockStart + len;
  let index = findIndexCleanStart(transaction, structs, clockStart);
  let struct;
  do {
    struct = structs[index++];
    if (clockEnd < struct.id.clock + struct.length) {
      findIndexCleanStart(transaction, structs, clockEnd);
    }
    f(struct);
  } while (index < structs.length && structs[index].id.clock < clockEnd);
};
var Transaction = class {
  /**
   * @param {Doc} doc
   * @param {any} origin
   * @param {boolean} local
   */
  constructor(doc2, origin, local) {
    this.doc = doc2;
    this.deleteSet = new DeleteSet();
    this.beforeState = getStateVector(doc2.store);
    this.afterState = /* @__PURE__ */ new Map();
    this.changed = /* @__PURE__ */ new Map();
    this.changedParentTypes = /* @__PURE__ */ new Map();
    this._mergeStructs = [];
    this.origin = origin;
    this.meta = /* @__PURE__ */ new Map();
    this.local = local;
    this.subdocsAdded = /* @__PURE__ */ new Set();
    this.subdocsRemoved = /* @__PURE__ */ new Set();
    this.subdocsLoaded = /* @__PURE__ */ new Set();
    this._needFormattingCleanup = false;
  }
};
var writeUpdateMessageFromTransaction = (encoder, transaction) => {
  if (transaction.deleteSet.clients.size === 0 && !any(transaction.afterState, (clock, client) => transaction.beforeState.get(client) !== clock)) {
    return false;
  }
  sortAndMergeDeleteSet(transaction.deleteSet);
  writeStructsFromTransaction(encoder, transaction);
  writeDeleteSet(encoder, transaction.deleteSet);
  return true;
};
var addChangedTypeToTransaction = (transaction, type2, parentSub) => {
  const item = type2._item;
  if (item === null || item.id.clock < (transaction.beforeState.get(item.id.client) || 0) && !item.deleted) {
    setIfUndefined(transaction.changed, type2, create2).add(parentSub);
  }
};
var tryToMergeWithLefts = (structs, pos) => {
  let right = structs[pos];
  let left = structs[pos - 1];
  let i = pos;
  for (; i > 0; right = left, left = structs[--i - 1]) {
    if (left.deleted === right.deleted && left.constructor === right.constructor) {
      if (left.mergeWith(right)) {
        if (right instanceof Item && right.parentSub !== null && /** @type {AbstractType<any>} */
        right.parent._map.get(right.parentSub) === right) {
          right.parent._map.set(
            right.parentSub,
            /** @type {Item} */
            left
          );
        }
        continue;
      }
    }
    break;
  }
  const merged = pos - i;
  if (merged) {
    structs.splice(pos + 1 - merged, merged);
  }
  return merged;
};
var tryGcDeleteSet = (ds, store, gcFilter) => {
  for (const [client, deleteItems] of ds.clients.entries()) {
    const structs = (
      /** @type {Array<GC|Item>} */
      store.clients.get(client)
    );
    for (let di = deleteItems.length - 1; di >= 0; di--) {
      const deleteItem = deleteItems[di];
      const endDeleteItemClock = deleteItem.clock + deleteItem.len;
      for (let si = findIndexSS(structs, deleteItem.clock), struct = structs[si]; si < structs.length && struct.id.clock < endDeleteItemClock; struct = structs[++si]) {
        const struct2 = structs[si];
        if (deleteItem.clock + deleteItem.len <= struct2.id.clock) {
          break;
        }
        if (struct2 instanceof Item && struct2.deleted && !struct2.keep && gcFilter(struct2)) {
          struct2.gc(store, false);
        }
      }
    }
  }
};
var tryMergeDeleteSet = (ds, store) => {
  ds.clients.forEach((deleteItems, client) => {
    const structs = (
      /** @type {Array<GC|Item>} */
      store.clients.get(client)
    );
    for (let di = deleteItems.length - 1; di >= 0; di--) {
      const deleteItem = deleteItems[di];
      const mostRightIndexToCheck = min(structs.length - 1, 1 + findIndexSS(structs, deleteItem.clock + deleteItem.len - 1));
      for (let si = mostRightIndexToCheck, struct = structs[si]; si > 0 && struct.id.clock >= deleteItem.clock; struct = structs[si]) {
        si -= 1 + tryToMergeWithLefts(structs, si);
      }
    }
  });
};
var cleanupTransactions = (transactionCleanups, i) => {
  if (i < transactionCleanups.length) {
    const transaction = transactionCleanups[i];
    const doc2 = transaction.doc;
    const store = doc2.store;
    const ds = transaction.deleteSet;
    const mergeStructs = transaction._mergeStructs;
    try {
      sortAndMergeDeleteSet(ds);
      transaction.afterState = getStateVector(transaction.doc.store);
      doc2.emit("beforeObserverCalls", [transaction, doc2]);
      const fs = [];
      transaction.changed.forEach(
        (subs, itemtype) => fs.push(() => {
          if (itemtype._item === null || !itemtype._item.deleted) {
            itemtype._callObserver(transaction, subs);
          }
        })
      );
      fs.push(() => {
        transaction.changedParentTypes.forEach((events, type2) => {
          if (type2._dEH.l.length > 0 && (type2._item === null || !type2._item.deleted)) {
            events = events.filter(
              (event) => event.target._item === null || !event.target._item.deleted
            );
            events.forEach((event) => {
              event.currentTarget = type2;
              event._path = null;
            });
            events.sort((event1, event2) => event1.path.length - event2.path.length);
            callEventHandlerListeners(type2._dEH, events, transaction);
          }
        });
      });
      fs.push(() => doc2.emit("afterTransaction", [transaction, doc2]));
      callAll(fs, []);
      if (transaction._needFormattingCleanup) {
        cleanupYTextAfterTransaction(transaction);
      }
    } finally {
      if (doc2.gc) {
        tryGcDeleteSet(ds, store, doc2.gcFilter);
      }
      tryMergeDeleteSet(ds, store);
      transaction.afterState.forEach((clock, client) => {
        const beforeClock = transaction.beforeState.get(client) || 0;
        if (beforeClock !== clock) {
          const structs = (
            /** @type {Array<GC|Item>} */
            store.clients.get(client)
          );
          const firstChangePos = max(findIndexSS(structs, beforeClock), 1);
          for (let i2 = structs.length - 1; i2 >= firstChangePos; ) {
            i2 -= 1 + tryToMergeWithLefts(structs, i2);
          }
        }
      });
      for (let i2 = mergeStructs.length - 1; i2 >= 0; i2--) {
        const { client, clock } = mergeStructs[i2].id;
        const structs = (
          /** @type {Array<GC|Item>} */
          store.clients.get(client)
        );
        const replacedStructPos = findIndexSS(structs, clock);
        if (replacedStructPos + 1 < structs.length) {
          if (tryToMergeWithLefts(structs, replacedStructPos + 1) > 1) {
            continue;
          }
        }
        if (replacedStructPos > 0) {
          tryToMergeWithLefts(structs, replacedStructPos);
        }
      }
      if (!transaction.local && transaction.afterState.get(doc2.clientID) !== transaction.beforeState.get(doc2.clientID)) {
        print(ORANGE, BOLD, "[yjs] ", UNBOLD, RED, "Changed the client-id because another client seems to be using it.");
        doc2.clientID = generateNewClientId();
      }
      doc2.emit("afterTransactionCleanup", [transaction, doc2]);
      if (doc2._observers.has("update")) {
        const encoder = new UpdateEncoderV1();
        const hasContent2 = writeUpdateMessageFromTransaction(encoder, transaction);
        if (hasContent2) {
          doc2.emit("update", [encoder.toUint8Array(), transaction.origin, doc2, transaction]);
        }
      }
      if (doc2._observers.has("updateV2")) {
        const encoder = new UpdateEncoderV2();
        const hasContent2 = writeUpdateMessageFromTransaction(encoder, transaction);
        if (hasContent2) {
          doc2.emit("updateV2", [encoder.toUint8Array(), transaction.origin, doc2, transaction]);
        }
      }
      const { subdocsAdded, subdocsLoaded, subdocsRemoved } = transaction;
      if (subdocsAdded.size > 0 || subdocsRemoved.size > 0 || subdocsLoaded.size > 0) {
        subdocsAdded.forEach((subdoc) => {
          subdoc.clientID = doc2.clientID;
          if (subdoc.collectionid == null) {
            subdoc.collectionid = doc2.collectionid;
          }
          doc2.subdocs.add(subdoc);
        });
        subdocsRemoved.forEach((subdoc) => doc2.subdocs.delete(subdoc));
        doc2.emit("subdocs", [{ loaded: subdocsLoaded, added: subdocsAdded, removed: subdocsRemoved }, doc2, transaction]);
        subdocsRemoved.forEach((subdoc) => subdoc.destroy());
      }
      if (transactionCleanups.length <= i + 1) {
        doc2._transactionCleanups = [];
        doc2.emit("afterAllTransactions", [doc2, transactionCleanups]);
      } else {
        cleanupTransactions(transactionCleanups, i + 1);
      }
    }
  }
};
var transact = (doc2, f, origin = null, local = true) => {
  const transactionCleanups = doc2._transactionCleanups;
  let initialCall = false;
  let result = null;
  if (doc2._transaction === null) {
    initialCall = true;
    doc2._transaction = new Transaction(doc2, origin, local);
    transactionCleanups.push(doc2._transaction);
    if (transactionCleanups.length === 1) {
      doc2.emit("beforeAllTransactions", [doc2]);
    }
    doc2.emit("beforeTransaction", [doc2._transaction, doc2]);
  }
  try {
    result = f(doc2._transaction);
  } finally {
    if (initialCall) {
      const finishCleanup = doc2._transaction === transactionCleanups[0];
      doc2._transaction = null;
      if (finishCleanup) {
        cleanupTransactions(transactionCleanups, 0);
      }
    }
  }
  return result;
};
var StackItem = class {
  /**
   * @param {DeleteSet} deletions
   * @param {DeleteSet} insertions
   */
  constructor(deletions, insertions) {
    this.insertions = insertions;
    this.deletions = deletions;
    this.meta = /* @__PURE__ */ new Map();
  }
};
var clearUndoManagerStackItem = (tr, um, stackItem) => {
  iterateDeletedStructs(tr, stackItem.deletions, (item) => {
    if (item instanceof Item && um.scope.some((type2) => isParentOf(type2, item))) {
      keepItem(item, false);
    }
  });
};
var popStackItem = (undoManager, stack, eventType) => {
  let result = null;
  let _tr = null;
  const doc2 = undoManager.doc;
  const scope = undoManager.scope;
  transact(doc2, (transaction) => {
    while (stack.length > 0 && result === null) {
      const store = doc2.store;
      const stackItem = (
        /** @type {StackItem} */
        stack.pop()
      );
      const itemsToRedo = /* @__PURE__ */ new Set();
      const itemsToDelete = [];
      let performedChange = false;
      iterateDeletedStructs(transaction, stackItem.insertions, (struct) => {
        if (struct instanceof Item) {
          if (struct.redone !== null) {
            let { item, diff } = followRedone(store, struct.id);
            if (diff > 0) {
              item = getItemCleanStart(transaction, createID(item.id.client, item.id.clock + diff));
            }
            struct = item;
          }
          if (!struct.deleted && scope.some((type2) => isParentOf(
            type2,
            /** @type {Item} */
            struct
          ))) {
            itemsToDelete.push(struct);
          }
        }
      });
      iterateDeletedStructs(transaction, stackItem.deletions, (struct) => {
        if (struct instanceof Item && scope.some((type2) => isParentOf(type2, struct)) && // Never redo structs in stackItem.insertions because they were created and deleted in the same capture interval.
        !isDeleted(stackItem.insertions, struct.id)) {
          itemsToRedo.add(struct);
        }
      });
      itemsToRedo.forEach((struct) => {
        performedChange = redoItem(transaction, struct, itemsToRedo, stackItem.insertions, undoManager.ignoreRemoteMapChanges, undoManager) !== null || performedChange;
      });
      for (let i = itemsToDelete.length - 1; i >= 0; i--) {
        const item = itemsToDelete[i];
        if (undoManager.deleteFilter(item)) {
          item.delete(transaction);
          performedChange = true;
        }
      }
      result = performedChange ? stackItem : null;
    }
    transaction.changed.forEach((subProps, type2) => {
      if (subProps.has(null) && type2._searchMarker) {
        type2._searchMarker.length = 0;
      }
    });
    _tr = transaction;
  }, undoManager);
  if (result != null) {
    const changedParentTypes = _tr.changedParentTypes;
    undoManager.emit("stack-item-popped", [{ stackItem: result, type: eventType, changedParentTypes }, undoManager]);
  }
  return result;
};
var UndoManager = class extends Observable {
  /**
   * @param {AbstractType<any>|Array<AbstractType<any>>} typeScope Accepts either a single type, or an array of types
   * @param {UndoManagerOptions} options
   */
  constructor(typeScope, {
    captureTimeout = 500,
    captureTransaction = (_tr) => true,
    deleteFilter = () => true,
    trackedOrigins = /* @__PURE__ */ new Set([null]),
    ignoreRemoteMapChanges = false,
    doc: doc2 = (
      /** @type {Doc} */
      isArray(typeScope) ? typeScope[0].doc : typeScope.doc
    )
  } = {}) {
    super();
    this.scope = [];
    this.doc = doc2;
    this.addToScope(typeScope);
    this.deleteFilter = deleteFilter;
    trackedOrigins.add(this);
    this.trackedOrigins = trackedOrigins;
    this.captureTransaction = captureTransaction;
    this.undoStack = [];
    this.redoStack = [];
    this.undoing = false;
    this.redoing = false;
    this.lastChange = 0;
    this.ignoreRemoteMapChanges = ignoreRemoteMapChanges;
    this.captureTimeout = captureTimeout;
    this.afterTransactionHandler = (transaction) => {
      if (!this.captureTransaction(transaction) || !this.scope.some((type2) => transaction.changedParentTypes.has(type2)) || !this.trackedOrigins.has(transaction.origin) && (!transaction.origin || !this.trackedOrigins.has(transaction.origin.constructor))) {
        return;
      }
      const undoing = this.undoing;
      const redoing = this.redoing;
      const stack = undoing ? this.redoStack : this.undoStack;
      if (undoing) {
        this.stopCapturing();
      } else if (!redoing) {
        this.clear(false, true);
      }
      const insertions = new DeleteSet();
      transaction.afterState.forEach((endClock, client) => {
        const startClock = transaction.beforeState.get(client) || 0;
        const len = endClock - startClock;
        if (len > 0) {
          addToDeleteSet(insertions, client, startClock, len);
        }
      });
      const now = getUnixTime();
      let didAdd = false;
      if (this.lastChange > 0 && now - this.lastChange < this.captureTimeout && stack.length > 0 && !undoing && !redoing) {
        const lastOp = stack[stack.length - 1];
        lastOp.deletions = mergeDeleteSets([lastOp.deletions, transaction.deleteSet]);
        lastOp.insertions = mergeDeleteSets([lastOp.insertions, insertions]);
      } else {
        stack.push(new StackItem(transaction.deleteSet, insertions));
        didAdd = true;
      }
      if (!undoing && !redoing) {
        this.lastChange = now;
      }
      iterateDeletedStructs(
        transaction,
        transaction.deleteSet,
        /** @param {Item|GC} item */
        (item) => {
          if (item instanceof Item && this.scope.some((type2) => isParentOf(type2, item))) {
            keepItem(item, true);
          }
        }
      );
      const changeEvent = [{ stackItem: stack[stack.length - 1], origin: transaction.origin, type: undoing ? "redo" : "undo", changedParentTypes: transaction.changedParentTypes }, this];
      if (didAdd) {
        this.emit("stack-item-added", changeEvent);
      } else {
        this.emit("stack-item-updated", changeEvent);
      }
    };
    this.doc.on("afterTransaction", this.afterTransactionHandler);
    this.doc.on("destroy", () => {
      this.destroy();
    });
  }
  /**
   * @param {Array<AbstractType<any>> | AbstractType<any>} ytypes
   */
  addToScope(ytypes) {
    ytypes = isArray(ytypes) ? ytypes : [ytypes];
    ytypes.forEach((ytype) => {
      if (this.scope.every((yt) => yt !== ytype)) {
        if (ytype.doc !== this.doc)
          warn("[yjs#509] Not same Y.Doc");
        this.scope.push(ytype);
      }
    });
  }
  /**
   * @param {any} origin
   */
  addTrackedOrigin(origin) {
    this.trackedOrigins.add(origin);
  }
  /**
   * @param {any} origin
   */
  removeTrackedOrigin(origin) {
    this.trackedOrigins.delete(origin);
  }
  clear(clearUndoStack = true, clearRedoStack = true) {
    if (clearUndoStack && this.canUndo() || clearRedoStack && this.canRedo()) {
      this.doc.transact((tr) => {
        if (clearUndoStack) {
          this.undoStack.forEach((item) => clearUndoManagerStackItem(tr, this, item));
          this.undoStack = [];
        }
        if (clearRedoStack) {
          this.redoStack.forEach((item) => clearUndoManagerStackItem(tr, this, item));
          this.redoStack = [];
        }
        this.emit("stack-cleared", [{ undoStackCleared: clearUndoStack, redoStackCleared: clearRedoStack }]);
      });
    }
  }
  /**
   * UndoManager merges Undo-StackItem if they are created within time-gap
   * smaller than `options.captureTimeout`. Call `um.stopCapturing()` so that the next
   * StackItem won't be merged.
   *
   *
   * @example
   *     // without stopCapturing
   *     ytext.insert(0, 'a')
   *     ytext.insert(1, 'b')
   *     um.undo()
   *     ytext.toString() // => '' (note that 'ab' was removed)
   *     // with stopCapturing
   *     ytext.insert(0, 'a')
   *     um.stopCapturing()
   *     ytext.insert(0, 'b')
   *     um.undo()
   *     ytext.toString() // => 'a' (note that only 'b' was removed)
   *
   */
  stopCapturing() {
    this.lastChange = 0;
  }
  /**
   * Undo last changes on type.
   *
   * @return {StackItem?} Returns StackItem if a change was applied
   */
  undo() {
    this.undoing = true;
    let res;
    try {
      res = popStackItem(this, this.undoStack, "undo");
    } finally {
      this.undoing = false;
    }
    return res;
  }
  /**
   * Redo last undo operation.
   *
   * @return {StackItem?} Returns StackItem if a change was applied
   */
  redo() {
    this.redoing = true;
    let res;
    try {
      res = popStackItem(this, this.redoStack, "redo");
    } finally {
      this.redoing = false;
    }
    return res;
  }
  /**
   * Are undo steps available?
   *
   * @return {boolean} `true` if undo is possible
   */
  canUndo() {
    return this.undoStack.length > 0;
  }
  /**
   * Are redo steps available?
   *
   * @return {boolean} `true` if redo is possible
   */
  canRedo() {
    return this.redoStack.length > 0;
  }
  destroy() {
    this.trackedOrigins.delete(this);
    this.doc.off("afterTransaction", this.afterTransactionHandler);
    super.destroy();
  }
};
function* lazyStructReaderGenerator(decoder) {
  const numOfStateUpdates = readVarUint(decoder.restDecoder);
  for (let i = 0; i < numOfStateUpdates; i++) {
    const numberOfStructs = readVarUint(decoder.restDecoder);
    const client = decoder.readClient();
    let clock = readVarUint(decoder.restDecoder);
    for (let i2 = 0; i2 < numberOfStructs; i2++) {
      const info = decoder.readInfo();
      if (info === 10) {
        const len = readVarUint(decoder.restDecoder);
        yield new Skip(createID(client, clock), len);
        clock += len;
      } else if ((BITS5 & info) !== 0) {
        const cantCopyParentInfo = (info & (BIT7 | BIT8)) === 0;
        const struct = new Item(
          createID(client, clock),
          null,
          // left
          (info & BIT8) === BIT8 ? decoder.readLeftID() : null,
          // origin
          null,
          // right
          (info & BIT7) === BIT7 ? decoder.readRightID() : null,
          // right origin
          // @ts-ignore Force writing a string here.
          cantCopyParentInfo ? decoder.readParentInfo() ? decoder.readString() : decoder.readLeftID() : null,
          // parent
          cantCopyParentInfo && (info & BIT6) === BIT6 ? decoder.readString() : null,
          // parentSub
          readItemContent(decoder, info)
          // item content
        );
        yield struct;
        clock += struct.length;
      } else {
        const len = decoder.readLen();
        yield new GC(createID(client, clock), len);
        clock += len;
      }
    }
  }
}
var LazyStructReader = class {
  /**
   * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder
   * @param {boolean} filterSkips
   */
  constructor(decoder, filterSkips) {
    this.gen = lazyStructReaderGenerator(decoder);
    this.curr = null;
    this.done = false;
    this.filterSkips = filterSkips;
    this.next();
  }
  /**
   * @return {Item | GC | Skip |null}
   */
  next() {
    do {
      this.curr = this.gen.next().value || null;
    } while (this.filterSkips && this.curr !== null && this.curr.constructor === Skip);
    return this.curr;
  }
};
var LazyStructWriter = class {
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */
  constructor(encoder) {
    this.currClient = 0;
    this.startClock = 0;
    this.written = 0;
    this.encoder = encoder;
    this.clientStructs = [];
  }
};
var mergeUpdates = (updates) => mergeUpdatesV2(updates, UpdateDecoderV1, UpdateEncoderV1);
var sliceStruct = (left, diff) => {
  if (left.constructor === GC) {
    const { client, clock } = left.id;
    return new GC(createID(client, clock + diff), left.length - diff);
  } else if (left.constructor === Skip) {
    const { client, clock } = left.id;
    return new Skip(createID(client, clock + diff), left.length - diff);
  } else {
    const leftItem = (
      /** @type {Item} */
      left
    );
    const { client, clock } = leftItem.id;
    return new Item(
      createID(client, clock + diff),
      null,
      createID(client, clock + diff - 1),
      null,
      leftItem.rightOrigin,
      leftItem.parent,
      leftItem.parentSub,
      leftItem.content.splice(diff)
    );
  }
};
var mergeUpdatesV2 = (updates, YDecoder = UpdateDecoderV2, YEncoder = UpdateEncoderV2) => {
  if (updates.length === 1) {
    return updates[0];
  }
  const updateDecoders = updates.map((update) => new YDecoder(createDecoder(update)));
  let lazyStructDecoders = updateDecoders.map((decoder) => new LazyStructReader(decoder, true));
  let currWrite = null;
  const updateEncoder = new YEncoder();
  const lazyStructEncoder = new LazyStructWriter(updateEncoder);
  while (true) {
    lazyStructDecoders = lazyStructDecoders.filter((dec) => dec.curr !== null);
    lazyStructDecoders.sort(
      /** @type {function(any,any):number} */
      (dec1, dec2) => {
        if (dec1.curr.id.client === dec2.curr.id.client) {
          const clockDiff = dec1.curr.id.clock - dec2.curr.id.clock;
          if (clockDiff === 0) {
            return dec1.curr.constructor === dec2.curr.constructor ? 0 : dec1.curr.constructor === Skip ? 1 : -1;
          } else {
            return clockDiff;
          }
        } else {
          return dec2.curr.id.client - dec1.curr.id.client;
        }
      }
    );
    if (lazyStructDecoders.length === 0) {
      break;
    }
    const currDecoder = lazyStructDecoders[0];
    const firstClient = (
      /** @type {Item | GC} */
      currDecoder.curr.id.client
    );
    if (currWrite !== null) {
      let curr = (
        /** @type {Item | GC | null} */
        currDecoder.curr
      );
      let iterated = false;
      while (curr !== null && curr.id.clock + curr.length <= currWrite.struct.id.clock + currWrite.struct.length && curr.id.client >= currWrite.struct.id.client) {
        curr = currDecoder.next();
        iterated = true;
      }
      if (curr === null || // current decoder is empty
      curr.id.client !== firstClient || // check whether there is another decoder that has has updates from `firstClient`
      iterated && curr.id.clock > currWrite.struct.id.clock + currWrite.struct.length) {
        continue;
      }
      if (firstClient !== currWrite.struct.id.client) {
        writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);
        currWrite = { struct: curr, offset: 0 };
        currDecoder.next();
      } else {
        if (currWrite.struct.id.clock + currWrite.struct.length < curr.id.clock) {
          if (currWrite.struct.constructor === Skip) {
            currWrite.struct.length = curr.id.clock + curr.length - currWrite.struct.id.clock;
          } else {
            writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);
            const diff = curr.id.clock - currWrite.struct.id.clock - currWrite.struct.length;
            const struct = new Skip(createID(firstClient, currWrite.struct.id.clock + currWrite.struct.length), diff);
            currWrite = { struct, offset: 0 };
          }
        } else {
          const diff = currWrite.struct.id.clock + currWrite.struct.length - curr.id.clock;
          if (diff > 0) {
            if (currWrite.struct.constructor === Skip) {
              currWrite.struct.length -= diff;
            } else {
              curr = sliceStruct(curr, diff);
            }
          }
          if (!currWrite.struct.mergeWith(
            /** @type {any} */
            curr
          )) {
            writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);
            currWrite = { struct: curr, offset: 0 };
            currDecoder.next();
          }
        }
      }
    } else {
      currWrite = { struct: (
        /** @type {Item | GC} */
        currDecoder.curr
      ), offset: 0 };
      currDecoder.next();
    }
    for (let next = currDecoder.curr; next !== null && next.id.client === firstClient && next.id.clock === currWrite.struct.id.clock + currWrite.struct.length && next.constructor !== Skip; next = currDecoder.next()) {
      writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);
      currWrite = { struct: next, offset: 0 };
    }
  }
  if (currWrite !== null) {
    writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);
    currWrite = null;
  }
  finishLazyStructWriting(lazyStructEncoder);
  const dss = updateDecoders.map((decoder) => readDeleteSet(decoder));
  const ds = mergeDeleteSets(dss);
  writeDeleteSet(updateEncoder, ds);
  return updateEncoder.toUint8Array();
};
var diffUpdateV2 = (update, sv, YDecoder = UpdateDecoderV2, YEncoder = UpdateEncoderV2) => {
  const state = decodeStateVector(sv);
  const encoder = new YEncoder();
  const lazyStructWriter = new LazyStructWriter(encoder);
  const decoder = new YDecoder(createDecoder(update));
  const reader = new LazyStructReader(decoder, false);
  while (reader.curr) {
    const curr = reader.curr;
    const currClient = curr.id.client;
    const svClock = state.get(currClient) || 0;
    if (reader.curr.constructor === Skip) {
      reader.next();
      continue;
    }
    if (curr.id.clock + curr.length > svClock) {
      writeStructToLazyStructWriter(lazyStructWriter, curr, max(svClock - curr.id.clock, 0));
      reader.next();
      while (reader.curr && reader.curr.id.client === currClient) {
        writeStructToLazyStructWriter(lazyStructWriter, reader.curr, 0);
        reader.next();
      }
    } else {
      while (reader.curr && reader.curr.id.client === currClient && reader.curr.id.clock + reader.curr.length <= svClock) {
        reader.next();
      }
    }
  }
  finishLazyStructWriting(lazyStructWriter);
  const ds = readDeleteSet(decoder);
  writeDeleteSet(encoder, ds);
  return encoder.toUint8Array();
};
var flushLazyStructWriter = (lazyWriter) => {
  if (lazyWriter.written > 0) {
    lazyWriter.clientStructs.push({ written: lazyWriter.written, restEncoder: toUint8Array(lazyWriter.encoder.restEncoder) });
    lazyWriter.encoder.restEncoder = createEncoder();
    lazyWriter.written = 0;
  }
};
var writeStructToLazyStructWriter = (lazyWriter, struct, offset) => {
  if (lazyWriter.written > 0 && lazyWriter.currClient !== struct.id.client) {
    flushLazyStructWriter(lazyWriter);
  }
  if (lazyWriter.written === 0) {
    lazyWriter.currClient = struct.id.client;
    lazyWriter.encoder.writeClient(struct.id.client);
    writeVarUint(lazyWriter.encoder.restEncoder, struct.id.clock + offset);
  }
  struct.write(lazyWriter.encoder, offset);
  lazyWriter.written++;
};
var finishLazyStructWriting = (lazyWriter) => {
  flushLazyStructWriter(lazyWriter);
  const restEncoder = lazyWriter.encoder.restEncoder;
  writeVarUint(restEncoder, lazyWriter.clientStructs.length);
  for (let i = 0; i < lazyWriter.clientStructs.length; i++) {
    const partStructs = lazyWriter.clientStructs[i];
    writeVarUint(restEncoder, partStructs.written);
    writeUint8Array(restEncoder, partStructs.restEncoder);
  }
};
var convertUpdateFormat = (update, blockTransformer, YDecoder, YEncoder) => {
  const updateDecoder = new YDecoder(createDecoder(update));
  const lazyDecoder = new LazyStructReader(updateDecoder, false);
  const updateEncoder = new YEncoder();
  const lazyWriter = new LazyStructWriter(updateEncoder);
  for (let curr = lazyDecoder.curr; curr !== null; curr = lazyDecoder.next()) {
    writeStructToLazyStructWriter(lazyWriter, blockTransformer(curr), 0);
  }
  finishLazyStructWriting(lazyWriter);
  const ds = readDeleteSet(updateDecoder);
  writeDeleteSet(updateEncoder, ds);
  return updateEncoder.toUint8Array();
};
var convertUpdateFormatV2ToV1 = (update) => convertUpdateFormat(update, id, UpdateDecoderV2, UpdateEncoderV1);
var errorComputeChanges = "You must not compute changes after the event-handler fired.";
var YEvent = class {
  /**
   * @param {T} target The changed type.
   * @param {Transaction} transaction
   */
  constructor(target, transaction) {
    this.target = target;
    this.currentTarget = target;
    this.transaction = transaction;
    this._changes = null;
    this._keys = null;
    this._delta = null;
    this._path = null;
  }
  /**
   * Computes the path from `y` to the changed type.
   *
   * @todo v14 should standardize on path: Array<{parent, index}> because that is easier to work with.
   *
   * The following property holds:
   * @example
   *   let type = y
   *   event.path.forEach(dir => {
   *     type = type.get(dir)
   *   })
   *   type === event.target // => true
   */
  get path() {
    return this._path || (this._path = getPathTo(this.currentTarget, this.target));
  }
  /**
   * Check if a struct is deleted by this event.
   *
   * In contrast to change.deleted, this method also returns true if the struct was added and then deleted.
   *
   * @param {AbstractStruct} struct
   * @return {boolean}
   */
  deletes(struct) {
    return isDeleted(this.transaction.deleteSet, struct.id);
  }
  /**
   * @type {Map<string, { action: 'add' | 'update' | 'delete', oldValue: any, newValue: any }>}
   */
  get keys() {
    if (this._keys === null) {
      if (this.transaction.doc._transactionCleanups.length === 0) {
        throw create3(errorComputeChanges);
      }
      const keys3 = /* @__PURE__ */ new Map();
      const target = this.target;
      const changed = (
        /** @type Set<string|null> */
        this.transaction.changed.get(target)
      );
      changed.forEach((key) => {
        if (key !== null) {
          const item = (
            /** @type {Item} */
            target._map.get(key)
          );
          let action;
          let oldValue;
          if (this.adds(item)) {
            let prev = item.left;
            while (prev !== null && this.adds(prev)) {
              prev = prev.left;
            }
            if (this.deletes(item)) {
              if (prev !== null && this.deletes(prev)) {
                action = "delete";
                oldValue = last(prev.content.getContent());
              } else {
                return;
              }
            } else {
              if (prev !== null && this.deletes(prev)) {
                action = "update";
                oldValue = last(prev.content.getContent());
              } else {
                action = "add";
                oldValue = void 0;
              }
            }
          } else {
            if (this.deletes(item)) {
              action = "delete";
              oldValue = last(
                /** @type {Item} */
                item.content.getContent()
              );
            } else {
              return;
            }
          }
          keys3.set(key, { action, oldValue });
        }
      });
      this._keys = keys3;
    }
    return this._keys;
  }
  /**
   * This is a computed property. Note that this can only be safely computed during the
   * event call. Computing this property after other changes happened might result in
   * unexpected behavior (incorrect computation of deltas). A safe way to collect changes
   * is to store the `changes` or the `delta` object. Avoid storing the `transaction` object.
   *
   * @type {Array<{insert?: string | Array<any> | object | AbstractType<any>, retain?: number, delete?: number, attributes?: Object<string, any>}>}
   */
  get delta() {
    return this.changes.delta;
  }
  /**
   * Check if a struct is added by this event.
   *
   * In contrast to change.deleted, this method also returns true if the struct was added and then deleted.
   *
   * @param {AbstractStruct} struct
   * @return {boolean}
   */
  adds(struct) {
    return struct.id.clock >= (this.transaction.beforeState.get(struct.id.client) || 0);
  }
  /**
   * This is a computed property. Note that this can only be safely computed during the
   * event call. Computing this property after other changes happened might result in
   * unexpected behavior (incorrect computation of deltas). A safe way to collect changes
   * is to store the `changes` or the `delta` object. Avoid storing the `transaction` object.
   *
   * @type {{added:Set<Item>,deleted:Set<Item>,keys:Map<string,{action:'add'|'update'|'delete',oldValue:any}>,delta:Array<{insert?:Array<any>|string, delete?:number, retain?:number}>}}
   */
  get changes() {
    let changes = this._changes;
    if (changes === null) {
      if (this.transaction.doc._transactionCleanups.length === 0) {
        throw create3(errorComputeChanges);
      }
      const target = this.target;
      const added = create2();
      const deleted = create2();
      const delta = [];
      changes = {
        added,
        deleted,
        delta,
        keys: this.keys
      };
      const changed = (
        /** @type Set<string|null> */
        this.transaction.changed.get(target)
      );
      if (changed.has(null)) {
        let lastOp = null;
        const packOp = () => {
          if (lastOp) {
            delta.push(lastOp);
          }
        };
        for (let item = target._start; item !== null; item = item.right) {
          if (item.deleted) {
            if (this.deletes(item) && !this.adds(item)) {
              if (lastOp === null || lastOp.delete === void 0) {
                packOp();
                lastOp = { delete: 0 };
              }
              lastOp.delete += item.length;
              deleted.add(item);
            }
          } else {
            if (this.adds(item)) {
              if (lastOp === null || lastOp.insert === void 0) {
                packOp();
                lastOp = { insert: [] };
              }
              lastOp.insert = lastOp.insert.concat(item.content.getContent());
              added.add(item);
            } else {
              if (lastOp === null || lastOp.retain === void 0) {
                packOp();
                lastOp = { retain: 0 };
              }
              lastOp.retain += item.length;
            }
          }
        }
        if (lastOp !== null && lastOp.retain === void 0) {
          packOp();
        }
      }
      this._changes = changes;
    }
    return (
      /** @type {any} */
      changes
    );
  }
};
var getPathTo = (parent, child) => {
  const path4 = [];
  while (child._item !== null && child !== parent) {
    if (child._item.parentSub !== null) {
      path4.unshift(child._item.parentSub);
    } else {
      let i = 0;
      let c = (
        /** @type {AbstractType<any>} */
        child._item.parent._start
      );
      while (c !== child._item && c !== null) {
        if (!c.deleted) {
          i++;
        }
        c = c.right;
      }
      path4.unshift(i);
    }
    child = /** @type {AbstractType<any>} */
    child._item.parent;
  }
  return path4;
};
var maxSearchMarker = 80;
var globalSearchMarkerTimestamp = 0;
var ArraySearchMarker = class {
  /**
   * @param {Item} p
   * @param {number} index
   */
  constructor(p, index) {
    p.marker = true;
    this.p = p;
    this.index = index;
    this.timestamp = globalSearchMarkerTimestamp++;
  }
};
var refreshMarkerTimestamp = (marker) => {
  marker.timestamp = globalSearchMarkerTimestamp++;
};
var overwriteMarker = (marker, p, index) => {
  marker.p.marker = false;
  marker.p = p;
  p.marker = true;
  marker.index = index;
  marker.timestamp = globalSearchMarkerTimestamp++;
};
var markPosition = (searchMarker, p, index) => {
  if (searchMarker.length >= maxSearchMarker) {
    const marker = searchMarker.reduce((a, b) => a.timestamp < b.timestamp ? a : b);
    overwriteMarker(marker, p, index);
    return marker;
  } else {
    const pm = new ArraySearchMarker(p, index);
    searchMarker.push(pm);
    return pm;
  }
};
var findMarker = (yarray, index) => {
  if (yarray._start === null || index === 0 || yarray._searchMarker === null) {
    return null;
  }
  const marker = yarray._searchMarker.length === 0 ? null : yarray._searchMarker.reduce((a, b) => abs(index - a.index) < abs(index - b.index) ? a : b);
  let p = yarray._start;
  let pindex = 0;
  if (marker !== null) {
    p = marker.p;
    pindex = marker.index;
    refreshMarkerTimestamp(marker);
  }
  while (p.right !== null && pindex < index) {
    if (!p.deleted && p.countable) {
      if (index < pindex + p.length) {
        break;
      }
      pindex += p.length;
    }
    p = p.right;
  }
  while (p.left !== null && pindex > index) {
    p = p.left;
    if (!p.deleted && p.countable) {
      pindex -= p.length;
    }
  }
  while (p.left !== null && p.left.id.client === p.id.client && p.left.id.clock + p.left.length === p.id.clock) {
    p = p.left;
    if (!p.deleted && p.countable) {
      pindex -= p.length;
    }
  }
  if (marker !== null && abs(marker.index - pindex) < /** @type {YText|YArray<any>} */
  p.parent.length / maxSearchMarker) {
    overwriteMarker(marker, p, pindex);
    return marker;
  } else {
    return markPosition(yarray._searchMarker, p, pindex);
  }
};
var updateMarkerChanges = (searchMarker, index, len) => {
  for (let i = searchMarker.length - 1; i >= 0; i--) {
    const m = searchMarker[i];
    if (len > 0) {
      let p = m.p;
      p.marker = false;
      while (p && (p.deleted || !p.countable)) {
        p = p.left;
        if (p && !p.deleted && p.countable) {
          m.index -= p.length;
        }
      }
      if (p === null || p.marker === true) {
        searchMarker.splice(i, 1);
        continue;
      }
      m.p = p;
      p.marker = true;
    }
    if (index < m.index || len > 0 && index === m.index) {
      m.index = max(index, m.index + len);
    }
  }
};
var callTypeObservers = (type2, transaction, event) => {
  const changedType = type2;
  const changedParentTypes = transaction.changedParentTypes;
  while (true) {
    setIfUndefined(changedParentTypes, type2, () => []).push(event);
    if (type2._item === null) {
      break;
    }
    type2 = /** @type {AbstractType<any>} */
    type2._item.parent;
  }
  callEventHandlerListeners(changedType._eH, event, transaction);
};
var AbstractType = class {
  constructor() {
    this._item = null;
    this._map = /* @__PURE__ */ new Map();
    this._start = null;
    this.doc = null;
    this._length = 0;
    this._eH = createEventHandler();
    this._dEH = createEventHandler();
    this._searchMarker = null;
  }
  /**
   * @return {AbstractType<any>|null}
   */
  get parent() {
    return this._item ? (
      /** @type {AbstractType<any>} */
      this._item.parent
    ) : null;
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item|null} item
   */
  _integrate(y, item) {
    this.doc = y;
    this._item = item;
  }
  /**
   * @return {AbstractType<EventType>}
   */
  _copy() {
    throw methodUnimplemented();
  }
  /**
   * @return {AbstractType<EventType>}
   */
  clone() {
    throw methodUnimplemented();
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} _encoder
   */
  _write(_encoder) {
  }
  /**
   * The first non-deleted item
   */
  get _first() {
    let n = this._start;
    while (n !== null && n.deleted) {
      n = n.right;
    }
    return n;
  }
  /**
   * Creates YEvent and calls all type observers.
   * Must be implemented by each type.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} _parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(transaction, _parentSubs) {
    if (!transaction.local && this._searchMarker) {
      this._searchMarker.length = 0;
    }
  }
  /**
   * Observe all events that are created on this type.
   *
   * @param {function(EventType, Transaction):void} f Observer function
   */
  observe(f) {
    addEventHandlerListener(this._eH, f);
  }
  /**
   * Observe all events that are created by this type and its children.
   *
   * @param {function(Array<YEvent<any>>,Transaction):void} f Observer function
   */
  observeDeep(f) {
    addEventHandlerListener(this._dEH, f);
  }
  /**
   * Unregister an observer function.
   *
   * @param {function(EventType,Transaction):void} f Observer function
   */
  unobserve(f) {
    removeEventHandlerListener(this._eH, f);
  }
  /**
   * Unregister an observer function.
   *
   * @param {function(Array<YEvent<any>>,Transaction):void} f Observer function
   */
  unobserveDeep(f) {
    removeEventHandlerListener(this._dEH, f);
  }
  /**
   * @abstract
   * @return {any}
   */
  toJSON() {
  }
};
var typeListSlice = (type2, start, end) => {
  if (start < 0) {
    start = type2._length + start;
  }
  if (end < 0) {
    end = type2._length + end;
  }
  let len = end - start;
  const cs = [];
  let n = type2._start;
  while (n !== null && len > 0) {
    if (n.countable && !n.deleted) {
      const c = n.content.getContent();
      if (c.length <= start) {
        start -= c.length;
      } else {
        for (let i = start; i < c.length && len > 0; i++) {
          cs.push(c[i]);
          len--;
        }
        start = 0;
      }
    }
    n = n.right;
  }
  return cs;
};
var typeListToArray = (type2) => {
  const cs = [];
  let n = type2._start;
  while (n !== null) {
    if (n.countable && !n.deleted) {
      const c = n.content.getContent();
      for (let i = 0; i < c.length; i++) {
        cs.push(c[i]);
      }
    }
    n = n.right;
  }
  return cs;
};
var typeListForEach = (type2, f) => {
  let index = 0;
  let n = type2._start;
  while (n !== null) {
    if (n.countable && !n.deleted) {
      const c = n.content.getContent();
      for (let i = 0; i < c.length; i++) {
        f(c[i], index++, type2);
      }
    }
    n = n.right;
  }
};
var typeListMap = (type2, f) => {
  const result = [];
  typeListForEach(type2, (c, i) => {
    result.push(f(c, i, type2));
  });
  return result;
};
var typeListCreateIterator = (type2) => {
  let n = type2._start;
  let currentContent = null;
  let currentContentIndex = 0;
  return {
    [Symbol.iterator]() {
      return this;
    },
    next: () => {
      if (currentContent === null) {
        while (n !== null && n.deleted) {
          n = n.right;
        }
        if (n === null) {
          return {
            done: true,
            value: void 0
          };
        }
        currentContent = n.content.getContent();
        currentContentIndex = 0;
        n = n.right;
      }
      const value = currentContent[currentContentIndex++];
      if (currentContent.length <= currentContentIndex) {
        currentContent = null;
      }
      return {
        done: false,
        value
      };
    }
  };
};
var typeListGet = (type2, index) => {
  const marker = findMarker(type2, index);
  let n = type2._start;
  if (marker !== null) {
    n = marker.p;
    index -= marker.index;
  }
  for (; n !== null; n = n.right) {
    if (!n.deleted && n.countable) {
      if (index < n.length) {
        return n.content.getContent()[index];
      }
      index -= n.length;
    }
  }
};
var typeListInsertGenericsAfter = (transaction, parent, referenceItem, content) => {
  let left = referenceItem;
  const doc2 = transaction.doc;
  const ownClientId = doc2.clientID;
  const store = doc2.store;
  const right = referenceItem === null ? parent._start : referenceItem.right;
  let jsonContent = [];
  const packJsonContent = () => {
    if (jsonContent.length > 0) {
      left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentAny(jsonContent));
      left.integrate(transaction, 0);
      jsonContent = [];
    }
  };
  content.forEach((c) => {
    if (c === null) {
      jsonContent.push(c);
    } else {
      switch (c.constructor) {
        case Number:
        case Object:
        case Boolean:
        case Array:
        case String:
          jsonContent.push(c);
          break;
        default:
          packJsonContent();
          switch (c.constructor) {
            case Uint8Array:
            case ArrayBuffer:
              left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentBinary(new Uint8Array(
                /** @type {Uint8Array} */
                c
              )));
              left.integrate(transaction, 0);
              break;
            case Doc:
              left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentDoc(
                /** @type {Doc} */
                c
              ));
              left.integrate(transaction, 0);
              break;
            default:
              if (c instanceof AbstractType) {
                left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentType(c));
                left.integrate(transaction, 0);
              } else {
                throw new Error("Unexpected content type in insert operation");
              }
          }
      }
    }
  });
  packJsonContent();
};
var lengthExceeded = () => create3("Length exceeded!");
var typeListInsertGenerics = (transaction, parent, index, content) => {
  if (index > parent._length) {
    throw lengthExceeded();
  }
  if (index === 0) {
    if (parent._searchMarker) {
      updateMarkerChanges(parent._searchMarker, index, content.length);
    }
    return typeListInsertGenericsAfter(transaction, parent, null, content);
  }
  const startIndex = index;
  const marker = findMarker(parent, index);
  let n = parent._start;
  if (marker !== null) {
    n = marker.p;
    index -= marker.index;
    if (index === 0) {
      n = n.prev;
      index += n && n.countable && !n.deleted ? n.length : 0;
    }
  }
  for (; n !== null; n = n.right) {
    if (!n.deleted && n.countable) {
      if (index <= n.length) {
        if (index < n.length) {
          getItemCleanStart(transaction, createID(n.id.client, n.id.clock + index));
        }
        break;
      }
      index -= n.length;
    }
  }
  if (parent._searchMarker) {
    updateMarkerChanges(parent._searchMarker, startIndex, content.length);
  }
  return typeListInsertGenericsAfter(transaction, parent, n, content);
};
var typeListPushGenerics = (transaction, parent, content) => {
  const marker = (parent._searchMarker || []).reduce((maxMarker, currMarker) => currMarker.index > maxMarker.index ? currMarker : maxMarker, { index: 0, p: parent._start });
  let n = marker.p;
  if (n) {
    while (n.right) {
      n = n.right;
    }
  }
  return typeListInsertGenericsAfter(transaction, parent, n, content);
};
var typeListDelete = (transaction, parent, index, length3) => {
  if (length3 === 0) {
    return;
  }
  const startIndex = index;
  const startLength = length3;
  const marker = findMarker(parent, index);
  let n = parent._start;
  if (marker !== null) {
    n = marker.p;
    index -= marker.index;
  }
  for (; n !== null && index > 0; n = n.right) {
    if (!n.deleted && n.countable) {
      if (index < n.length) {
        getItemCleanStart(transaction, createID(n.id.client, n.id.clock + index));
      }
      index -= n.length;
    }
  }
  while (length3 > 0 && n !== null) {
    if (!n.deleted) {
      if (length3 < n.length) {
        getItemCleanStart(transaction, createID(n.id.client, n.id.clock + length3));
      }
      n.delete(transaction);
      length3 -= n.length;
    }
    n = n.right;
  }
  if (length3 > 0) {
    throw lengthExceeded();
  }
  if (parent._searchMarker) {
    updateMarkerChanges(
      parent._searchMarker,
      startIndex,
      -startLength + length3
      /* in case we remove the above exception */
    );
  }
};
var typeMapDelete = (transaction, parent, key) => {
  const c = parent._map.get(key);
  if (c !== void 0) {
    c.delete(transaction);
  }
};
var typeMapSet = (transaction, parent, key, value) => {
  const left = parent._map.get(key) || null;
  const doc2 = transaction.doc;
  const ownClientId = doc2.clientID;
  let content;
  if (value == null) {
    content = new ContentAny([value]);
  } else {
    switch (value.constructor) {
      case Number:
      case Object:
      case Boolean:
      case Array:
      case String:
        content = new ContentAny([value]);
        break;
      case Uint8Array:
        content = new ContentBinary(
          /** @type {Uint8Array} */
          value
        );
        break;
      case Doc:
        content = new ContentDoc(
          /** @type {Doc} */
          value
        );
        break;
      default:
        if (value instanceof AbstractType) {
          content = new ContentType(value);
        } else {
          throw new Error("Unexpected content type");
        }
    }
  }
  new Item(createID(ownClientId, getState(doc2.store, ownClientId)), left, left && left.lastId, null, null, parent, key, content).integrate(transaction, 0);
};
var typeMapGet = (parent, key) => {
  const val = parent._map.get(key);
  return val !== void 0 && !val.deleted ? val.content.getContent()[val.length - 1] : void 0;
};
var typeMapGetAll = (parent) => {
  const res = {};
  parent._map.forEach((value, key) => {
    if (!value.deleted) {
      res[key] = value.content.getContent()[value.length - 1];
    }
  });
  return res;
};
var typeMapHas = (parent, key) => {
  const val = parent._map.get(key);
  return val !== void 0 && !val.deleted;
};
var createMapIterator = (map2) => iteratorFilter(
  map2.entries(),
  /** @param {any} entry */
  (entry) => !entry[1].deleted
);
var YArrayEvent = class extends YEvent {
  /**
   * @param {YArray<T>} yarray The changed type
   * @param {Transaction} transaction The transaction object
   */
  constructor(yarray, transaction) {
    super(yarray, transaction);
    this._transaction = transaction;
  }
};
var YArray = class extends AbstractType {
  constructor() {
    super();
    this._prelimContent = [];
    this._searchMarker = [];
  }
  /**
   * Construct a new YArray containing the specified items.
   * @template {Object<string,any>|Array<any>|number|null|string|Uint8Array} T
   * @param {Array<T>} items
   * @return {YArray<T>}
   */
  static from(items) {
    const a = new YArray();
    a.push(items);
    return a;
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item} item
   */
  _integrate(y, item) {
    super._integrate(y, item);
    this.insert(
      0,
      /** @type {Array<any>} */
      this._prelimContent
    );
    this._prelimContent = null;
  }
  /**
   * @return {YArray<T>}
   */
  _copy() {
    return new YArray();
  }
  /**
   * @return {YArray<T>}
   */
  clone() {
    const arr = new YArray();
    arr.insert(0, this.toArray().map(
      (el) => el instanceof AbstractType ? (
        /** @type {typeof el} */
        el.clone()
      ) : el
    ));
    return arr;
  }
  get length() {
    return this._prelimContent === null ? this._length : this._prelimContent.length;
  }
  /**
   * Creates YArrayEvent and calls observers.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(transaction, parentSubs) {
    super._callObserver(transaction, parentSubs);
    callTypeObservers(this, transaction, new YArrayEvent(this, transaction));
  }
  /**
   * Inserts new content at an index.
   *
   * Important: This function expects an array of content. Not just a content
   * object. The reason for this "weirdness" is that inserting several elements
   * is very efficient when it is done as a single operation.
   *
   * @example
   *  // Insert character 'a' at position 0
   *  yarray.insert(0, ['a'])
   *  // Insert numbers 1, 2 at position 1
   *  yarray.insert(1, [1, 2])
   *
   * @param {number} index The index to insert content at.
   * @param {Array<T>} content The array of content
   */
  insert(index, content) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeListInsertGenerics(
          transaction,
          this,
          index,
          /** @type {any} */
          content
        );
      });
    } else {
      this._prelimContent.splice(index, 0, ...content);
    }
  }
  /**
   * Appends content to this YArray.
   *
   * @param {Array<T>} content Array of content to append.
   *
   * @todo Use the following implementation in all types.
   */
  push(content) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeListPushGenerics(
          transaction,
          this,
          /** @type {any} */
          content
        );
      });
    } else {
      this._prelimContent.push(...content);
    }
  }
  /**
   * Preppends content to this YArray.
   *
   * @param {Array<T>} content Array of content to preppend.
   */
  unshift(content) {
    this.insert(0, content);
  }
  /**
   * Deletes elements starting from an index.
   *
   * @param {number} index Index at which to start deleting elements
   * @param {number} length The number of elements to remove. Defaults to 1.
   */
  delete(index, length3 = 1) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeListDelete(transaction, this, index, length3);
      });
    } else {
      this._prelimContent.splice(index, length3);
    }
  }
  /**
   * Returns the i-th element from a YArray.
   *
   * @param {number} index The index of the element to return from the YArray
   * @return {T}
   */
  get(index) {
    return typeListGet(this, index);
  }
  /**
   * Transforms this YArray to a JavaScript Array.
   *
   * @return {Array<T>}
   */
  toArray() {
    return typeListToArray(this);
  }
  /**
   * Transforms this YArray to a JavaScript Array.
   *
   * @param {number} [start]
   * @param {number} [end]
   * @return {Array<T>}
   */
  slice(start = 0, end = this.length) {
    return typeListSlice(this, start, end);
  }
  /**
   * Transforms this Shared Type to a JSON object.
   *
   * @return {Array<any>}
   */
  toJSON() {
    return this.map((c) => c instanceof AbstractType ? c.toJSON() : c);
  }
  /**
   * Returns an Array with the result of calling a provided function on every
   * element of this YArray.
   *
   * @template M
   * @param {function(T,number,YArray<T>):M} f Function that produces an element of the new Array
   * @return {Array<M>} A new array with each element being the result of the
   *                 callback function
   */
  map(f) {
    return typeListMap(
      this,
      /** @type {any} */
      f
    );
  }
  /**
   * Executes a provided function once on overy element of this YArray.
   *
   * @param {function(T,number,YArray<T>):void} f A function to execute on every element of this YArray.
   */
  forEach(f) {
    typeListForEach(this, f);
  }
  /**
   * @return {IterableIterator<T>}
   */
  [Symbol.iterator]() {
    return typeListCreateIterator(this);
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */
  _write(encoder) {
    encoder.writeTypeRef(YArrayRefID);
  }
};
var readYArray = (_decoder) => new YArray();
var YMapEvent = class extends YEvent {
  /**
   * @param {YMap<T>} ymap The YArray that changed.
   * @param {Transaction} transaction
   * @param {Set<any>} subs The keys that changed.
   */
  constructor(ymap, transaction, subs) {
    super(ymap, transaction);
    this.keysChanged = subs;
  }
};
var YMap = class extends AbstractType {
  /**
   *
   * @param {Iterable<readonly [string, any]>=} entries - an optional iterable to initialize the YMap
   */
  constructor(entries) {
    super();
    this._prelimContent = null;
    if (entries === void 0) {
      this._prelimContent = /* @__PURE__ */ new Map();
    } else {
      this._prelimContent = new Map(entries);
    }
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item} item
   */
  _integrate(y, item) {
    super._integrate(y, item);
    this._prelimContent.forEach((value, key) => {
      this.set(key, value);
    });
    this._prelimContent = null;
  }
  /**
   * @return {YMap<MapType>}
   */
  _copy() {
    return new YMap();
  }
  /**
   * @return {YMap<MapType>}
   */
  clone() {
    const map2 = new YMap();
    this.forEach((value, key) => {
      map2.set(key, value instanceof AbstractType ? (
        /** @type {typeof value} */
        value.clone()
      ) : value);
    });
    return map2;
  }
  /**
   * Creates YMapEvent and calls observers.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(transaction, parentSubs) {
    callTypeObservers(this, transaction, new YMapEvent(this, transaction, parentSubs));
  }
  /**
   * Transforms this Shared Type to a JSON object.
   *
   * @return {Object<string,any>}
   */
  toJSON() {
    const map2 = {};
    this._map.forEach((item, key) => {
      if (!item.deleted) {
        const v = item.content.getContent()[item.length - 1];
        map2[key] = v instanceof AbstractType ? v.toJSON() : v;
      }
    });
    return map2;
  }
  /**
   * Returns the size of the YMap (count of key/value pairs)
   *
   * @return {number}
   */
  get size() {
    return [...createMapIterator(this._map)].length;
  }
  /**
   * Returns the keys for each element in the YMap Type.
   *
   * @return {IterableIterator<string>}
   */
  keys() {
    return iteratorMap(
      createMapIterator(this._map),
      /** @param {any} v */
      (v) => v[0]
    );
  }
  /**
   * Returns the values for each element in the YMap Type.
   *
   * @return {IterableIterator<any>}
   */
  values() {
    return iteratorMap(
      createMapIterator(this._map),
      /** @param {any} v */
      (v) => v[1].content.getContent()[v[1].length - 1]
    );
  }
  /**
   * Returns an Iterator of [key, value] pairs
   *
   * @return {IterableIterator<any>}
   */
  entries() {
    return iteratorMap(
      createMapIterator(this._map),
      /** @param {any} v */
      (v) => [v[0], v[1].content.getContent()[v[1].length - 1]]
    );
  }
  /**
   * Executes a provided function on once on every key-value pair.
   *
   * @param {function(MapType,string,YMap<MapType>):void} f A function to execute on every element of this YArray.
   */
  forEach(f) {
    this._map.forEach((item, key) => {
      if (!item.deleted) {
        f(item.content.getContent()[item.length - 1], key, this);
      }
    });
  }
  /**
   * Returns an Iterator of [key, value] pairs
   *
   * @return {IterableIterator<any>}
   */
  [Symbol.iterator]() {
    return this.entries();
  }
  /**
   * Remove a specified element from this YMap.
   *
   * @param {string} key The key of the element to remove.
   */
  delete(key) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeMapDelete(transaction, this, key);
      });
    } else {
      this._prelimContent.delete(key);
    }
  }
  /**
   * Adds or updates an element with a specified key and value.
   * @template {MapType} VAL
   *
   * @param {string} key The key of the element to add to this YMap
   * @param {VAL} value The value of the element to add
   * @return {VAL}
   */
  set(key, value) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeMapSet(
          transaction,
          this,
          key,
          /** @type {any} */
          value
        );
      });
    } else {
      this._prelimContent.set(key, value);
    }
    return value;
  }
  /**
   * Returns a specified element from this YMap.
   *
   * @param {string} key
   * @return {MapType|undefined}
   */
  get(key) {
    return (
      /** @type {any} */
      typeMapGet(this, key)
    );
  }
  /**
   * Returns a boolean indicating whether the specified key exists or not.
   *
   * @param {string} key The key to test.
   * @return {boolean}
   */
  has(key) {
    return typeMapHas(this, key);
  }
  /**
   * Removes all elements from this YMap.
   */
  clear() {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        this.forEach(function(_value, key, map2) {
          typeMapDelete(transaction, map2, key);
        });
      });
    } else {
      this._prelimContent.clear();
    }
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */
  _write(encoder) {
    encoder.writeTypeRef(YMapRefID);
  }
};
var readYMap = (_decoder) => new YMap();
var equalAttrs = (a, b) => a === b || typeof a === "object" && typeof b === "object" && a && b && equalFlat(a, b);
var ItemTextListPosition = class {
  /**
   * @param {Item|null} left
   * @param {Item|null} right
   * @param {number} index
   * @param {Map<string,any>} currentAttributes
   */
  constructor(left, right, index, currentAttributes) {
    this.left = left;
    this.right = right;
    this.index = index;
    this.currentAttributes = currentAttributes;
  }
  /**
   * Only call this if you know that this.right is defined
   */
  forward() {
    if (this.right === null) {
      unexpectedCase();
    }
    switch (this.right.content.constructor) {
      case ContentFormat:
        if (!this.right.deleted) {
          updateCurrentAttributes(
            this.currentAttributes,
            /** @type {ContentFormat} */
            this.right.content
          );
        }
        break;
      default:
        if (!this.right.deleted) {
          this.index += this.right.length;
        }
        break;
    }
    this.left = this.right;
    this.right = this.right.right;
  }
};
var findNextPosition = (transaction, pos, count2) => {
  while (pos.right !== null && count2 > 0) {
    switch (pos.right.content.constructor) {
      case ContentFormat:
        if (!pos.right.deleted) {
          updateCurrentAttributes(
            pos.currentAttributes,
            /** @type {ContentFormat} */
            pos.right.content
          );
        }
        break;
      default:
        if (!pos.right.deleted) {
          if (count2 < pos.right.length) {
            getItemCleanStart(transaction, createID(pos.right.id.client, pos.right.id.clock + count2));
          }
          pos.index += pos.right.length;
          count2 -= pos.right.length;
        }
        break;
    }
    pos.left = pos.right;
    pos.right = pos.right.right;
  }
  return pos;
};
var findPosition = (transaction, parent, index) => {
  const currentAttributes = /* @__PURE__ */ new Map();
  const marker = findMarker(parent, index);
  if (marker) {
    const pos = new ItemTextListPosition(marker.p.left, marker.p, marker.index, currentAttributes);
    return findNextPosition(transaction, pos, index - marker.index);
  } else {
    const pos = new ItemTextListPosition(null, parent._start, 0, currentAttributes);
    return findNextPosition(transaction, pos, index);
  }
};
var insertNegatedAttributes = (transaction, parent, currPos, negatedAttributes) => {
  while (currPos.right !== null && (currPos.right.deleted === true || currPos.right.content.constructor === ContentFormat && equalAttrs(
    negatedAttributes.get(
      /** @type {ContentFormat} */
      currPos.right.content.key
    ),
    /** @type {ContentFormat} */
    currPos.right.content.value
  ))) {
    if (!currPos.right.deleted) {
      negatedAttributes.delete(
        /** @type {ContentFormat} */
        currPos.right.content.key
      );
    }
    currPos.forward();
  }
  const doc2 = transaction.doc;
  const ownClientId = doc2.clientID;
  negatedAttributes.forEach((val, key) => {
    const left = currPos.left;
    const right = currPos.right;
    const nextFormat = new Item(createID(ownClientId, getState(doc2.store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentFormat(key, val));
    nextFormat.integrate(transaction, 0);
    currPos.right = nextFormat;
    currPos.forward();
  });
};
var updateCurrentAttributes = (currentAttributes, format) => {
  const { key, value } = format;
  if (value === null) {
    currentAttributes.delete(key);
  } else {
    currentAttributes.set(key, value);
  }
};
var minimizeAttributeChanges = (currPos, attributes) => {
  while (true) {
    if (currPos.right === null) {
      break;
    } else if (currPos.right.deleted || currPos.right.content.constructor === ContentFormat && equalAttrs(
      attributes[
        /** @type {ContentFormat} */
        currPos.right.content.key
      ] || null,
      /** @type {ContentFormat} */
      currPos.right.content.value
    ))
      ;
    else {
      break;
    }
    currPos.forward();
  }
};
var insertAttributes = (transaction, parent, currPos, attributes) => {
  const doc2 = transaction.doc;
  const ownClientId = doc2.clientID;
  const negatedAttributes = /* @__PURE__ */ new Map();
  for (const key in attributes) {
    const val = attributes[key];
    const currentVal = currPos.currentAttributes.get(key) || null;
    if (!equalAttrs(currentVal, val)) {
      negatedAttributes.set(key, currentVal);
      const { left, right } = currPos;
      currPos.right = new Item(createID(ownClientId, getState(doc2.store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentFormat(key, val));
      currPos.right.integrate(transaction, 0);
      currPos.forward();
    }
  }
  return negatedAttributes;
};
var insertText = (transaction, parent, currPos, text2, attributes) => {
  currPos.currentAttributes.forEach((_val, key) => {
    if (attributes[key] === void 0) {
      attributes[key] = null;
    }
  });
  const doc2 = transaction.doc;
  const ownClientId = doc2.clientID;
  minimizeAttributeChanges(currPos, attributes);
  const negatedAttributes = insertAttributes(transaction, parent, currPos, attributes);
  const content = text2.constructor === String ? new ContentString(
    /** @type {string} */
    text2
  ) : text2 instanceof AbstractType ? new ContentType(text2) : new ContentEmbed(text2);
  let { left, right, index } = currPos;
  if (parent._searchMarker) {
    updateMarkerChanges(parent._searchMarker, currPos.index, content.getLength());
  }
  right = new Item(createID(ownClientId, getState(doc2.store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, content);
  right.integrate(transaction, 0);
  currPos.right = right;
  currPos.index = index;
  currPos.forward();
  insertNegatedAttributes(transaction, parent, currPos, negatedAttributes);
};
var formatText = (transaction, parent, currPos, length3, attributes) => {
  const doc2 = transaction.doc;
  const ownClientId = doc2.clientID;
  minimizeAttributeChanges(currPos, attributes);
  const negatedAttributes = insertAttributes(transaction, parent, currPos, attributes);
  iterationLoop:
    while (currPos.right !== null && (length3 > 0 || negatedAttributes.size > 0 && (currPos.right.deleted || currPos.right.content.constructor === ContentFormat))) {
      if (!currPos.right.deleted) {
        switch (currPos.right.content.constructor) {
          case ContentFormat: {
            const { key, value } = (
              /** @type {ContentFormat} */
              currPos.right.content
            );
            const attr = attributes[key];
            if (attr !== void 0) {
              if (equalAttrs(attr, value)) {
                negatedAttributes.delete(key);
              } else {
                if (length3 === 0) {
                  break iterationLoop;
                }
                negatedAttributes.set(key, value);
              }
              currPos.right.delete(transaction);
            } else {
              currPos.currentAttributes.set(key, value);
            }
            break;
          }
          default:
            if (length3 < currPos.right.length) {
              getItemCleanStart(transaction, createID(currPos.right.id.client, currPos.right.id.clock + length3));
            }
            length3 -= currPos.right.length;
            break;
        }
      }
      currPos.forward();
    }
  if (length3 > 0) {
    let newlines = "";
    for (; length3 > 0; length3--) {
      newlines += "\n";
    }
    currPos.right = new Item(createID(ownClientId, getState(doc2.store, ownClientId)), currPos.left, currPos.left && currPos.left.lastId, currPos.right, currPos.right && currPos.right.id, parent, null, new ContentString(newlines));
    currPos.right.integrate(transaction, 0);
    currPos.forward();
  }
  insertNegatedAttributes(transaction, parent, currPos, negatedAttributes);
};
var cleanupFormattingGap = (transaction, start, curr, startAttributes, currAttributes) => {
  let end = start;
  const endFormats = create();
  while (end && (!end.countable || end.deleted)) {
    if (!end.deleted && end.content.constructor === ContentFormat) {
      const cf = (
        /** @type {ContentFormat} */
        end.content
      );
      endFormats.set(cf.key, cf);
    }
    end = end.right;
  }
  let cleanups = 0;
  let reachedCurr = false;
  while (start !== end) {
    if (curr === start) {
      reachedCurr = true;
    }
    if (!start.deleted) {
      const content = start.content;
      switch (content.constructor) {
        case ContentFormat: {
          const { key, value } = (
            /** @type {ContentFormat} */
            content
          );
          const startAttrValue = startAttributes.get(key) || null;
          if (endFormats.get(key) !== content || startAttrValue === value) {
            start.delete(transaction);
            cleanups++;
            if (!reachedCurr && (currAttributes.get(key) || null) === value && startAttrValue !== value) {
              if (startAttrValue === null) {
                currAttributes.delete(key);
              } else {
                currAttributes.set(key, startAttrValue);
              }
            }
          }
          if (!reachedCurr && !start.deleted) {
            updateCurrentAttributes(
              currAttributes,
              /** @type {ContentFormat} */
              content
            );
          }
          break;
        }
      }
    }
    start = /** @type {Item} */
    start.right;
  }
  return cleanups;
};
var cleanupContextlessFormattingGap = (transaction, item) => {
  while (item && item.right && (item.right.deleted || !item.right.countable)) {
    item = item.right;
  }
  const attrs = /* @__PURE__ */ new Set();
  while (item && (item.deleted || !item.countable)) {
    if (!item.deleted && item.content.constructor === ContentFormat) {
      const key = (
        /** @type {ContentFormat} */
        item.content.key
      );
      if (attrs.has(key)) {
        item.delete(transaction);
      } else {
        attrs.add(key);
      }
    }
    item = item.left;
  }
};
var cleanupYTextFormatting = (type2) => {
  let res = 0;
  transact(
    /** @type {Doc} */
    type2.doc,
    (transaction) => {
      let start = (
        /** @type {Item} */
        type2._start
      );
      let end = type2._start;
      let startAttributes = create();
      const currentAttributes = copy(startAttributes);
      while (end) {
        if (end.deleted === false) {
          switch (end.content.constructor) {
            case ContentFormat:
              updateCurrentAttributes(
                currentAttributes,
                /** @type {ContentFormat} */
                end.content
              );
              break;
            default:
              res += cleanupFormattingGap(transaction, start, end, startAttributes, currentAttributes);
              startAttributes = copy(currentAttributes);
              start = end;
              break;
          }
        }
        end = end.right;
      }
    }
  );
  return res;
};
var cleanupYTextAfterTransaction = (transaction) => {
  const needFullCleanup = /* @__PURE__ */ new Set();
  const doc2 = transaction.doc;
  for (const [client, afterClock] of transaction.afterState.entries()) {
    const clock = transaction.beforeState.get(client) || 0;
    if (afterClock === clock) {
      continue;
    }
    iterateStructs(
      transaction,
      /** @type {Array<Item|GC>} */
      doc2.store.clients.get(client),
      clock,
      afterClock,
      (item) => {
        if (!item.deleted && /** @type {Item} */
        item.content.constructor === ContentFormat && item.constructor !== GC) {
          needFullCleanup.add(
            /** @type {any} */
            item.parent
          );
        }
      }
    );
  }
  transact(doc2, (t) => {
    iterateDeletedStructs(transaction, transaction.deleteSet, (item) => {
      if (item instanceof GC || !/** @type {YText} */
      item.parent._hasFormatting || needFullCleanup.has(
        /** @type {YText} */
        item.parent
      )) {
        return;
      }
      const parent = (
        /** @type {YText} */
        item.parent
      );
      if (item.content.constructor === ContentFormat) {
        needFullCleanup.add(parent);
      } else {
        cleanupContextlessFormattingGap(t, item);
      }
    });
    for (const yText of needFullCleanup) {
      cleanupYTextFormatting(yText);
    }
  });
};
var deleteText = (transaction, currPos, length3) => {
  const startLength = length3;
  const startAttrs = copy(currPos.currentAttributes);
  const start = currPos.right;
  while (length3 > 0 && currPos.right !== null) {
    if (currPos.right.deleted === false) {
      switch (currPos.right.content.constructor) {
        case ContentType:
        case ContentEmbed:
        case ContentString:
          if (length3 < currPos.right.length) {
            getItemCleanStart(transaction, createID(currPos.right.id.client, currPos.right.id.clock + length3));
          }
          length3 -= currPos.right.length;
          currPos.right.delete(transaction);
          break;
      }
    }
    currPos.forward();
  }
  if (start) {
    cleanupFormattingGap(transaction, start, currPos.right, startAttrs, currPos.currentAttributes);
  }
  const parent = (
    /** @type {AbstractType<any>} */
    /** @type {Item} */
    (currPos.left || currPos.right).parent
  );
  if (parent._searchMarker) {
    updateMarkerChanges(parent._searchMarker, currPos.index, -startLength + length3);
  }
  return currPos;
};
var YTextEvent = class extends YEvent {
  /**
   * @param {YText} ytext
   * @param {Transaction} transaction
   * @param {Set<any>} subs The keys that changed
   */
  constructor(ytext, transaction, subs) {
    super(ytext, transaction);
    this.childListChanged = false;
    this.keysChanged = /* @__PURE__ */ new Set();
    subs.forEach((sub) => {
      if (sub === null) {
        this.childListChanged = true;
      } else {
        this.keysChanged.add(sub);
      }
    });
  }
  /**
   * @type {{added:Set<Item>,deleted:Set<Item>,keys:Map<string,{action:'add'|'update'|'delete',oldValue:any}>,delta:Array<{insert?:Array<any>|string, delete?:number, retain?:number}>}}
   */
  get changes() {
    if (this._changes === null) {
      const changes = {
        keys: this.keys,
        delta: this.delta,
        added: /* @__PURE__ */ new Set(),
        deleted: /* @__PURE__ */ new Set()
      };
      this._changes = changes;
    }
    return (
      /** @type {any} */
      this._changes
    );
  }
  /**
   * Compute the changes in the delta format.
   * A {@link https://quilljs.com/docs/delta/|Quill Delta}) that represents the changes on the document.
   *
   * @type {Array<{insert?:string|object|AbstractType<any>, delete?:number, retain?:number, attributes?: Object<string,any>}>}
   *
   * @public
   */
  get delta() {
    if (this._delta === null) {
      const y = (
        /** @type {Doc} */
        this.target.doc
      );
      const delta = [];
      transact(y, (transaction) => {
        const currentAttributes = /* @__PURE__ */ new Map();
        const oldAttributes = /* @__PURE__ */ new Map();
        let item = this.target._start;
        let action = null;
        const attributes = {};
        let insert = "";
        let retain = 0;
        let deleteLen = 0;
        const addOp = () => {
          if (action !== null) {
            let op = null;
            switch (action) {
              case "delete":
                if (deleteLen > 0) {
                  op = { delete: deleteLen };
                }
                deleteLen = 0;
                break;
              case "insert":
                if (typeof insert === "object" || insert.length > 0) {
                  op = { insert };
                  if (currentAttributes.size > 0) {
                    op.attributes = {};
                    currentAttributes.forEach((value, key) => {
                      if (value !== null) {
                        op.attributes[key] = value;
                      }
                    });
                  }
                }
                insert = "";
                break;
              case "retain":
                if (retain > 0) {
                  op = { retain };
                  if (!isEmpty(attributes)) {
                    op.attributes = assign({}, attributes);
                  }
                }
                retain = 0;
                break;
            }
            if (op)
              delta.push(op);
            action = null;
          }
        };
        while (item !== null) {
          switch (item.content.constructor) {
            case ContentType:
            case ContentEmbed:
              if (this.adds(item)) {
                if (!this.deletes(item)) {
                  addOp();
                  action = "insert";
                  insert = item.content.getContent()[0];
                  addOp();
                }
              } else if (this.deletes(item)) {
                if (action !== "delete") {
                  addOp();
                  action = "delete";
                }
                deleteLen += 1;
              } else if (!item.deleted) {
                if (action !== "retain") {
                  addOp();
                  action = "retain";
                }
                retain += 1;
              }
              break;
            case ContentString:
              if (this.adds(item)) {
                if (!this.deletes(item)) {
                  if (action !== "insert") {
                    addOp();
                    action = "insert";
                  }
                  insert += /** @type {ContentString} */
                  item.content.str;
                }
              } else if (this.deletes(item)) {
                if (action !== "delete") {
                  addOp();
                  action = "delete";
                }
                deleteLen += item.length;
              } else if (!item.deleted) {
                if (action !== "retain") {
                  addOp();
                  action = "retain";
                }
                retain += item.length;
              }
              break;
            case ContentFormat: {
              const { key, value } = (
                /** @type {ContentFormat} */
                item.content
              );
              if (this.adds(item)) {
                if (!this.deletes(item)) {
                  const curVal = currentAttributes.get(key) || null;
                  if (!equalAttrs(curVal, value)) {
                    if (action === "retain") {
                      addOp();
                    }
                    if (equalAttrs(value, oldAttributes.get(key) || null)) {
                      delete attributes[key];
                    } else {
                      attributes[key] = value;
                    }
                  } else if (value !== null) {
                    item.delete(transaction);
                  }
                }
              } else if (this.deletes(item)) {
                oldAttributes.set(key, value);
                const curVal = currentAttributes.get(key) || null;
                if (!equalAttrs(curVal, value)) {
                  if (action === "retain") {
                    addOp();
                  }
                  attributes[key] = curVal;
                }
              } else if (!item.deleted) {
                oldAttributes.set(key, value);
                const attr = attributes[key];
                if (attr !== void 0) {
                  if (!equalAttrs(attr, value)) {
                    if (action === "retain") {
                      addOp();
                    }
                    if (value === null) {
                      delete attributes[key];
                    } else {
                      attributes[key] = value;
                    }
                  } else if (attr !== null) {
                    item.delete(transaction);
                  }
                }
              }
              if (!item.deleted) {
                if (action === "insert") {
                  addOp();
                }
                updateCurrentAttributes(
                  currentAttributes,
                  /** @type {ContentFormat} */
                  item.content
                );
              }
              break;
            }
          }
          item = item.right;
        }
        addOp();
        while (delta.length > 0) {
          const lastOp = delta[delta.length - 1];
          if (lastOp.retain !== void 0 && lastOp.attributes === void 0) {
            delta.pop();
          } else {
            break;
          }
        }
      });
      this._delta = delta;
    }
    return (
      /** @type {any} */
      this._delta
    );
  }
};
var YText = class extends AbstractType {
  /**
   * @param {String} [string] The initial value of the YText.
   */
  constructor(string) {
    super();
    this._pending = string !== void 0 ? [() => this.insert(0, string)] : [];
    this._searchMarker = [];
    this._hasFormatting = false;
  }
  /**
   * Number of characters of this text type.
   *
   * @type {number}
   */
  get length() {
    return this._length;
  }
  /**
   * @param {Doc} y
   * @param {Item} item
   */
  _integrate(y, item) {
    super._integrate(y, item);
    try {
      this._pending.forEach((f) => f());
    } catch (e) {
      console.error(e);
    }
    this._pending = null;
  }
  _copy() {
    return new YText();
  }
  /**
   * @return {YText}
   */
  clone() {
    const text2 = new YText();
    text2.applyDelta(this.toDelta());
    return text2;
  }
  /**
   * Creates YTextEvent and calls observers.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(transaction, parentSubs) {
    super._callObserver(transaction, parentSubs);
    const event = new YTextEvent(this, transaction, parentSubs);
    callTypeObservers(this, transaction, event);
    if (!transaction.local && this._hasFormatting) {
      transaction._needFormattingCleanup = true;
    }
  }
  /**
   * Returns the unformatted string representation of this YText type.
   *
   * @public
   */
  toString() {
    let str = "";
    let n = this._start;
    while (n !== null) {
      if (!n.deleted && n.countable && n.content.constructor === ContentString) {
        str += /** @type {ContentString} */
        n.content.str;
      }
      n = n.right;
    }
    return str;
  }
  /**
   * Returns the unformatted string representation of this YText type.
   *
   * @return {string}
   * @public
   */
  toJSON() {
    return this.toString();
  }
  /**
   * Apply a {@link Delta} on this shared YText type.
   *
   * @param {any} delta The changes to apply on this element.
   * @param {object}  opts
   * @param {boolean} [opts.sanitize] Sanitize input delta. Removes ending newlines if set to true.
   *
   *
   * @public
   */
  applyDelta(delta, { sanitize = true } = {}) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        const currPos = new ItemTextListPosition(null, this._start, 0, /* @__PURE__ */ new Map());
        for (let i = 0; i < delta.length; i++) {
          const op = delta[i];
          if (op.insert !== void 0) {
            const ins = !sanitize && typeof op.insert === "string" && i === delta.length - 1 && currPos.right === null && op.insert.slice(-1) === "\n" ? op.insert.slice(0, -1) : op.insert;
            if (typeof ins !== "string" || ins.length > 0) {
              insertText(transaction, this, currPos, ins, op.attributes || {});
            }
          } else if (op.retain !== void 0) {
            formatText(transaction, this, currPos, op.retain, op.attributes || {});
          } else if (op.delete !== void 0) {
            deleteText(transaction, currPos, op.delete);
          }
        }
      });
    } else {
      this._pending.push(() => this.applyDelta(delta));
    }
  }
  /**
   * Returns the Delta representation of this YText type.
   *
   * @param {Snapshot} [snapshot]
   * @param {Snapshot} [prevSnapshot]
   * @param {function('removed' | 'added', ID):any} [computeYChange]
   * @return {any} The Delta representation of this type.
   *
   * @public
   */
  toDelta(snapshot, prevSnapshot, computeYChange) {
    const ops = [];
    const currentAttributes = /* @__PURE__ */ new Map();
    const doc2 = (
      /** @type {Doc} */
      this.doc
    );
    let str = "";
    let n = this._start;
    function packStr() {
      if (str.length > 0) {
        const attributes = {};
        let addAttributes = false;
        currentAttributes.forEach((value, key) => {
          addAttributes = true;
          attributes[key] = value;
        });
        const op = { insert: str };
        if (addAttributes) {
          op.attributes = attributes;
        }
        ops.push(op);
        str = "";
      }
    }
    const computeDelta = () => {
      while (n !== null) {
        if (isVisible(n, snapshot) || prevSnapshot !== void 0 && isVisible(n, prevSnapshot)) {
          switch (n.content.constructor) {
            case ContentString: {
              const cur = currentAttributes.get("ychange");
              if (snapshot !== void 0 && !isVisible(n, snapshot)) {
                if (cur === void 0 || cur.user !== n.id.client || cur.type !== "removed") {
                  packStr();
                  currentAttributes.set("ychange", computeYChange ? computeYChange("removed", n.id) : { type: "removed" });
                }
              } else if (prevSnapshot !== void 0 && !isVisible(n, prevSnapshot)) {
                if (cur === void 0 || cur.user !== n.id.client || cur.type !== "added") {
                  packStr();
                  currentAttributes.set("ychange", computeYChange ? computeYChange("added", n.id) : { type: "added" });
                }
              } else if (cur !== void 0) {
                packStr();
                currentAttributes.delete("ychange");
              }
              str += /** @type {ContentString} */
              n.content.str;
              break;
            }
            case ContentType:
            case ContentEmbed: {
              packStr();
              const op = {
                insert: n.content.getContent()[0]
              };
              if (currentAttributes.size > 0) {
                const attrs = (
                  /** @type {Object<string,any>} */
                  {}
                );
                op.attributes = attrs;
                currentAttributes.forEach((value, key) => {
                  attrs[key] = value;
                });
              }
              ops.push(op);
              break;
            }
            case ContentFormat:
              if (isVisible(n, snapshot)) {
                packStr();
                updateCurrentAttributes(
                  currentAttributes,
                  /** @type {ContentFormat} */
                  n.content
                );
              }
              break;
          }
        }
        n = n.right;
      }
      packStr();
    };
    if (snapshot || prevSnapshot) {
      transact(doc2, (transaction) => {
        if (snapshot) {
          splitSnapshotAffectedStructs(transaction, snapshot);
        }
        if (prevSnapshot) {
          splitSnapshotAffectedStructs(transaction, prevSnapshot);
        }
        computeDelta();
      }, "cleanup");
    } else {
      computeDelta();
    }
    return ops;
  }
  /**
   * Insert text at a given index.
   *
   * @param {number} index The index at which to start inserting.
   * @param {String} text The text to insert at the specified position.
   * @param {TextAttributes} [attributes] Optionally define some formatting
   *                                    information to apply on the inserted
   *                                    Text.
   * @public
   */
  insert(index, text2, attributes) {
    if (text2.length <= 0) {
      return;
    }
    const y = this.doc;
    if (y !== null) {
      transact(y, (transaction) => {
        const pos = findPosition(transaction, this, index);
        if (!attributes) {
          attributes = {};
          pos.currentAttributes.forEach((v, k) => {
            attributes[k] = v;
          });
        }
        insertText(transaction, this, pos, text2, attributes);
      });
    } else {
      this._pending.push(() => this.insert(index, text2, attributes));
    }
  }
  /**
   * Inserts an embed at a index.
   *
   * @param {number} index The index to insert the embed at.
   * @param {Object | AbstractType<any>} embed The Object that represents the embed.
   * @param {TextAttributes} attributes Attribute information to apply on the
   *                                    embed
   *
   * @public
   */
  insertEmbed(index, embed, attributes = {}) {
    const y = this.doc;
    if (y !== null) {
      transact(y, (transaction) => {
        const pos = findPosition(transaction, this, index);
        insertText(transaction, this, pos, embed, attributes);
      });
    } else {
      this._pending.push(() => this.insertEmbed(index, embed, attributes));
    }
  }
  /**
   * Deletes text starting from an index.
   *
   * @param {number} index Index at which to start deleting.
   * @param {number} length The number of characters to remove. Defaults to 1.
   *
   * @public
   */
  delete(index, length3) {
    if (length3 === 0) {
      return;
    }
    const y = this.doc;
    if (y !== null) {
      transact(y, (transaction) => {
        deleteText(transaction, findPosition(transaction, this, index), length3);
      });
    } else {
      this._pending.push(() => this.delete(index, length3));
    }
  }
  /**
   * Assigns properties to a range of text.
   *
   * @param {number} index The position where to start formatting.
   * @param {number} length The amount of characters to assign properties to.
   * @param {TextAttributes} attributes Attribute information to apply on the
   *                                    text.
   *
   * @public
   */
  format(index, length3, attributes) {
    if (length3 === 0) {
      return;
    }
    const y = this.doc;
    if (y !== null) {
      transact(y, (transaction) => {
        const pos = findPosition(transaction, this, index);
        if (pos.right === null) {
          return;
        }
        formatText(transaction, this, pos, length3, attributes);
      });
    } else {
      this._pending.push(() => this.format(index, length3, attributes));
    }
  }
  /**
   * Removes an attribute.
   *
   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
   *
   * @param {String} attributeName The attribute name that is to be removed.
   *
   * @public
   */
  removeAttribute(attributeName) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeMapDelete(transaction, this, attributeName);
      });
    } else {
      this._pending.push(() => this.removeAttribute(attributeName));
    }
  }
  /**
   * Sets or updates an attribute.
   *
   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
   *
   * @param {String} attributeName The attribute name that is to be set.
   * @param {any} attributeValue The attribute value that is to be set.
   *
   * @public
   */
  setAttribute(attributeName, attributeValue) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeMapSet(transaction, this, attributeName, attributeValue);
      });
    } else {
      this._pending.push(() => this.setAttribute(attributeName, attributeValue));
    }
  }
  /**
   * Returns an attribute value that belongs to the attribute name.
   *
   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
   *
   * @param {String} attributeName The attribute name that identifies the
   *                               queried value.
   * @return {any} The queried attribute value.
   *
   * @public
   */
  getAttribute(attributeName) {
    return (
      /** @type {any} */
      typeMapGet(this, attributeName)
    );
  }
  /**
   * Returns all attribute name/value pairs in a JSON Object.
   *
   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
   *
   * @return {Object<string, any>} A JSON Object that describes the attributes.
   *
   * @public
   */
  getAttributes() {
    return typeMapGetAll(this);
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */
  _write(encoder) {
    encoder.writeTypeRef(YTextRefID);
  }
};
var readYText = (_decoder) => new YText();
var YXmlTreeWalker = class {
  /**
   * @param {YXmlFragment | YXmlElement} root
   * @param {function(AbstractType<any>):boolean} [f]
   */
  constructor(root, f = () => true) {
    this._filter = f;
    this._root = root;
    this._currentNode = /** @type {Item} */
    root._start;
    this._firstCall = true;
  }
  [Symbol.iterator]() {
    return this;
  }
  /**
   * Get the next node.
   *
   * @return {IteratorResult<YXmlElement|YXmlText|YXmlHook>} The next node.
   *
   * @public
   */
  next() {
    let n = this._currentNode;
    let type2 = n && n.content && /** @type {any} */
    n.content.type;
    if (n !== null && (!this._firstCall || n.deleted || !this._filter(type2))) {
      do {
        type2 = /** @type {any} */
        n.content.type;
        if (!n.deleted && (type2.constructor === YXmlElement || type2.constructor === YXmlFragment) && type2._start !== null) {
          n = type2._start;
        } else {
          while (n !== null) {
            if (n.right !== null) {
              n = n.right;
              break;
            } else if (n.parent === this._root) {
              n = null;
            } else {
              n = /** @type {AbstractType<any>} */
              n.parent._item;
            }
          }
        }
      } while (n !== null && (n.deleted || !this._filter(
        /** @type {ContentType} */
        n.content.type
      )));
    }
    this._firstCall = false;
    if (n === null) {
      return { value: void 0, done: true };
    }
    this._currentNode = n;
    return { value: (
      /** @type {any} */
      n.content.type
    ), done: false };
  }
};
var YXmlFragment = class extends AbstractType {
  constructor() {
    super();
    this._prelimContent = [];
  }
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get firstChild() {
    const first = this._first;
    return first ? first.content.getContent()[0] : null;
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item} item
   */
  _integrate(y, item) {
    super._integrate(y, item);
    this.insert(
      0,
      /** @type {Array<any>} */
      this._prelimContent
    );
    this._prelimContent = null;
  }
  _copy() {
    return new YXmlFragment();
  }
  /**
   * @return {YXmlFragment}
   */
  clone() {
    const el = new YXmlFragment();
    el.insert(0, this.toArray().map((item) => item instanceof AbstractType ? item.clone() : item));
    return el;
  }
  get length() {
    return this._prelimContent === null ? this._length : this._prelimContent.length;
  }
  /**
   * Create a subtree of childNodes.
   *
   * @example
   * const walker = elem.createTreeWalker(dom => dom.nodeName === 'div')
   * for (let node in walker) {
   *   // `node` is a div node
   *   nop(node)
   * }
   *
   * @param {function(AbstractType<any>):boolean} filter Function that is called on each child element and
   *                          returns a Boolean indicating whether the child
   *                          is to be included in the subtree.
   * @return {YXmlTreeWalker} A subtree and a position within it.
   *
   * @public
   */
  createTreeWalker(filter) {
    return new YXmlTreeWalker(this, filter);
  }
  /**
   * Returns the first YXmlElement that matches the query.
   * Similar to DOM's {@link querySelector}.
   *
   * Query support:
   *   - tagname
   * TODO:
   *   - id
   *   - attribute
   *
   * @param {CSS_Selector} query The query on the children.
   * @return {YXmlElement|YXmlText|YXmlHook|null} The first element that matches the query or null.
   *
   * @public
   */
  querySelector(query) {
    query = query.toUpperCase();
    const iterator = new YXmlTreeWalker(this, (element2) => element2.nodeName && element2.nodeName.toUpperCase() === query);
    const next = iterator.next();
    if (next.done) {
      return null;
    } else {
      return next.value;
    }
  }
  /**
   * Returns all YXmlElements that match the query.
   * Similar to Dom's {@link querySelectorAll}.
   *
   * @todo Does not yet support all queries. Currently only query by tagName.
   *
   * @param {CSS_Selector} query The query on the children
   * @return {Array<YXmlElement|YXmlText|YXmlHook|null>} The elements that match this query.
   *
   * @public
   */
  querySelectorAll(query) {
    query = query.toUpperCase();
    return from(new YXmlTreeWalker(this, (element2) => element2.nodeName && element2.nodeName.toUpperCase() === query));
  }
  /**
   * Creates YXmlEvent and calls observers.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(transaction, parentSubs) {
    callTypeObservers(this, transaction, new YXmlEvent(this, parentSubs, transaction));
  }
  /**
   * Get the string representation of all the children of this YXmlFragment.
   *
   * @return {string} The string representation of all children.
   */
  toString() {
    return typeListMap(this, (xml) => xml.toString()).join("");
  }
  /**
   * @return {string}
   */
  toJSON() {
    return this.toString();
  }
  /**
   * Creates a Dom Element that mirrors this YXmlElement.
   *
   * @param {Document} [_document=document] The document object (you must define
   *                                        this when calling this method in
   *                                        nodejs)
   * @param {Object<string, any>} [hooks={}] Optional property to customize how hooks
   *                                             are presented in the DOM
   * @param {any} [binding] You should not set this property. This is
   *                               used if DomBinding wants to create a
   *                               association to the created DOM type.
   * @return {Node} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
   *
   * @public
   */
  toDOM(_document = document, hooks = {}, binding) {
    const fragment2 = _document.createDocumentFragment();
    if (binding !== void 0) {
      binding._createAssociation(fragment2, this);
    }
    typeListForEach(this, (xmlType) => {
      fragment2.insertBefore(xmlType.toDOM(_document, hooks, binding), null);
    });
    return fragment2;
  }
  /**
   * Inserts new content at an index.
   *
   * @example
   *  // Insert character 'a' at position 0
   *  xml.insert(0, [new Y.XmlText('text')])
   *
   * @param {number} index The index to insert content at
   * @param {Array<YXmlElement|YXmlText>} content The array of content
   */
  insert(index, content) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeListInsertGenerics(transaction, this, index, content);
      });
    } else {
      this._prelimContent.splice(index, 0, ...content);
    }
  }
  /**
   * Inserts new content at an index.
   *
   * @example
   *  // Insert character 'a' at position 0
   *  xml.insert(0, [new Y.XmlText('text')])
   *
   * @param {null|Item|YXmlElement|YXmlText} ref The index to insert content at
   * @param {Array<YXmlElement|YXmlText>} content The array of content
   */
  insertAfter(ref, content) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        const refItem = ref && ref instanceof AbstractType ? ref._item : ref;
        typeListInsertGenericsAfter(transaction, this, refItem, content);
      });
    } else {
      const pc = (
        /** @type {Array<any>} */
        this._prelimContent
      );
      const index = ref === null ? 0 : pc.findIndex((el) => el === ref) + 1;
      if (index === 0 && ref !== null) {
        throw create3("Reference item not found");
      }
      pc.splice(index, 0, ...content);
    }
  }
  /**
   * Deletes elements starting from an index.
   *
   * @param {number} index Index at which to start deleting elements
   * @param {number} [length=1] The number of elements to remove. Defaults to 1.
   */
  delete(index, length3 = 1) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeListDelete(transaction, this, index, length3);
      });
    } else {
      this._prelimContent.splice(index, length3);
    }
  }
  /**
   * Transforms this YArray to a JavaScript Array.
   *
   * @return {Array<YXmlElement|YXmlText|YXmlHook>}
   */
  toArray() {
    return typeListToArray(this);
  }
  /**
   * Appends content to this YArray.
   *
   * @param {Array<YXmlElement|YXmlText>} content Array of content to append.
   */
  push(content) {
    this.insert(this.length, content);
  }
  /**
   * Preppends content to this YArray.
   *
   * @param {Array<YXmlElement|YXmlText>} content Array of content to preppend.
   */
  unshift(content) {
    this.insert(0, content);
  }
  /**
   * Returns the i-th element from a YArray.
   *
   * @param {number} index The index of the element to return from the YArray
   * @return {YXmlElement|YXmlText}
   */
  get(index) {
    return typeListGet(this, index);
  }
  /**
   * Transforms this YArray to a JavaScript Array.
   *
   * @param {number} [start]
   * @param {number} [end]
   * @return {Array<YXmlElement|YXmlText>}
   */
  slice(start = 0, end = this.length) {
    return typeListSlice(this, start, end);
  }
  /**
   * Executes a provided function on once on overy child element.
   *
   * @param {function(YXmlElement|YXmlText,number, typeof self):void} f A function to execute on every element of this YArray.
   */
  forEach(f) {
    typeListForEach(this, f);
  }
  /**
   * Transform the properties of this type to binary and write it to an
   * BinaryEncoder.
   *
   * This is called when this Item is sent to a remote peer.
   *
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   */
  _write(encoder) {
    encoder.writeTypeRef(YXmlFragmentRefID);
  }
};
var readYXmlFragment = (_decoder) => new YXmlFragment();
var YXmlElement = class extends YXmlFragment {
  constructor(nodeName = "UNDEFINED") {
    super();
    this.nodeName = nodeName;
    this._prelimAttrs = /* @__PURE__ */ new Map();
  }
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get nextSibling() {
    const n = this._item ? this._item.next : null;
    return n ? (
      /** @type {YXmlElement|YXmlText} */
      /** @type {ContentType} */
      n.content.type
    ) : null;
  }
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get prevSibling() {
    const n = this._item ? this._item.prev : null;
    return n ? (
      /** @type {YXmlElement|YXmlText} */
      /** @type {ContentType} */
      n.content.type
    ) : null;
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item} item
   */
  _integrate(y, item) {
    super._integrate(y, item);
    /** @type {Map<string, any>} */
    this._prelimAttrs.forEach((value, key) => {
      this.setAttribute(key, value);
    });
    this._prelimAttrs = null;
  }
  /**
   * Creates an Item with the same effect as this Item (without position effect)
   *
   * @return {YXmlElement}
   */
  _copy() {
    return new YXmlElement(this.nodeName);
  }
  /**
   * @return {YXmlElement<KV>}
   */
  clone() {
    const el = new YXmlElement(this.nodeName);
    const attrs = this.getAttributes();
    forEach(attrs, (value, key) => {
      if (typeof value === "string") {
        el.setAttribute(key, value);
      }
    });
    el.insert(0, this.toArray().map((item) => item instanceof AbstractType ? item.clone() : item));
    return el;
  }
  /**
   * Returns the XML serialization of this YXmlElement.
   * The attributes are ordered by attribute-name, so you can easily use this
   * method to compare YXmlElements
   *
   * @return {string} The string representation of this type.
   *
   * @public
   */
  toString() {
    const attrs = this.getAttributes();
    const stringBuilder = [];
    const keys3 = [];
    for (const key in attrs) {
      keys3.push(key);
    }
    keys3.sort();
    const keysLen = keys3.length;
    for (let i = 0; i < keysLen; i++) {
      const key = keys3[i];
      stringBuilder.push(key + '="' + attrs[key] + '"');
    }
    const nodeName = this.nodeName.toLocaleLowerCase();
    const attrsString = stringBuilder.length > 0 ? " " + stringBuilder.join(" ") : "";
    return `<${nodeName}${attrsString}>${super.toString()}</${nodeName}>`;
  }
  /**
   * Removes an attribute from this YXmlElement.
   *
   * @param {string} attributeName The attribute name that is to be removed.
   *
   * @public
   */
  removeAttribute(attributeName) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeMapDelete(transaction, this, attributeName);
      });
    } else {
      this._prelimAttrs.delete(attributeName);
    }
  }
  /**
   * Sets or updates an attribute.
   *
   * @template {keyof KV & string} KEY
   *
   * @param {KEY} attributeName The attribute name that is to be set.
   * @param {KV[KEY]} attributeValue The attribute value that is to be set.
   *
   * @public
   */
  setAttribute(attributeName, attributeValue) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeMapSet(transaction, this, attributeName, attributeValue);
      });
    } else {
      this._prelimAttrs.set(attributeName, attributeValue);
    }
  }
  /**
   * Returns an attribute value that belongs to the attribute name.
   *
   * @template {keyof KV & string} KEY
   *
   * @param {KEY} attributeName The attribute name that identifies the
   *                               queried value.
   * @return {KV[KEY]|undefined} The queried attribute value.
   *
   * @public
   */
  getAttribute(attributeName) {
    return (
      /** @type {any} */
      typeMapGet(this, attributeName)
    );
  }
  /**
   * Returns whether an attribute exists
   *
   * @param {string} attributeName The attribute name to check for existence.
   * @return {boolean} whether the attribute exists.
   *
   * @public
   */
  hasAttribute(attributeName) {
    return (
      /** @type {any} */
      typeMapHas(this, attributeName)
    );
  }
  /**
   * Returns all attribute name/value pairs in a JSON Object.
   *
   * @return {{ [Key in Extract<keyof KV,string>]?: KV[Key]}} A JSON Object that describes the attributes.
   *
   * @public
   */
  getAttributes() {
    return (
      /** @type {any} */
      typeMapGetAll(this)
    );
  }
  /**
   * Creates a Dom Element that mirrors this YXmlElement.
   *
   * @param {Document} [_document=document] The document object (you must define
   *                                        this when calling this method in
   *                                        nodejs)
   * @param {Object<string, any>} [hooks={}] Optional property to customize how hooks
   *                                             are presented in the DOM
   * @param {any} [binding] You should not set this property. This is
   *                               used if DomBinding wants to create a
   *                               association to the created DOM type.
   * @return {Node} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
   *
   * @public
   */
  toDOM(_document = document, hooks = {}, binding) {
    const dom = _document.createElement(this.nodeName);
    const attrs = this.getAttributes();
    for (const key in attrs) {
      const value = attrs[key];
      if (typeof value === "string") {
        dom.setAttribute(key, value);
      }
    }
    typeListForEach(this, (yxml) => {
      dom.appendChild(yxml.toDOM(_document, hooks, binding));
    });
    if (binding !== void 0) {
      binding._createAssociation(dom, this);
    }
    return dom;
  }
  /**
   * Transform the properties of this type to binary and write it to an
   * BinaryEncoder.
   *
   * This is called when this Item is sent to a remote peer.
   *
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   */
  _write(encoder) {
    encoder.writeTypeRef(YXmlElementRefID);
    encoder.writeKey(this.nodeName);
  }
};
var readYXmlElement = (decoder) => new YXmlElement(decoder.readKey());
var YXmlEvent = class extends YEvent {
  /**
   * @param {YXmlElement|YXmlText|YXmlFragment} target The target on which the event is created.
   * @param {Set<string|null>} subs The set of changed attributes. `null` is included if the
   *                   child list changed.
   * @param {Transaction} transaction The transaction instance with wich the
   *                                  change was created.
   */
  constructor(target, subs, transaction) {
    super(target, transaction);
    this.childListChanged = false;
    this.attributesChanged = /* @__PURE__ */ new Set();
    subs.forEach((sub) => {
      if (sub === null) {
        this.childListChanged = true;
      } else {
        this.attributesChanged.add(sub);
      }
    });
  }
};
var YXmlHook = class extends YMap {
  /**
   * @param {string} hookName nodeName of the Dom Node.
   */
  constructor(hookName) {
    super();
    this.hookName = hookName;
  }
  /**
   * Creates an Item with the same effect as this Item (without position effect)
   */
  _copy() {
    return new YXmlHook(this.hookName);
  }
  /**
   * @return {YXmlHook}
   */
  clone() {
    const el = new YXmlHook(this.hookName);
    this.forEach((value, key) => {
      el.set(key, value);
    });
    return el;
  }
  /**
   * Creates a Dom Element that mirrors this YXmlElement.
   *
   * @param {Document} [_document=document] The document object (you must define
   *                                        this when calling this method in
   *                                        nodejs)
   * @param {Object.<string, any>} [hooks] Optional property to customize how hooks
   *                                             are presented in the DOM
   * @param {any} [binding] You should not set this property. This is
   *                               used if DomBinding wants to create a
   *                               association to the created DOM type
   * @return {Element} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
   *
   * @public
   */
  toDOM(_document = document, hooks = {}, binding) {
    const hook = hooks[this.hookName];
    let dom;
    if (hook !== void 0) {
      dom = hook.createDom(this);
    } else {
      dom = document.createElement(this.hookName);
    }
    dom.setAttribute("data-yjs-hook", this.hookName);
    if (binding !== void 0) {
      binding._createAssociation(dom, this);
    }
    return dom;
  }
  /**
   * Transform the properties of this type to binary and write it to an
   * BinaryEncoder.
   *
   * This is called when this Item is sent to a remote peer.
   *
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   */
  _write(encoder) {
    encoder.writeTypeRef(YXmlHookRefID);
    encoder.writeKey(this.hookName);
  }
};
var readYXmlHook = (decoder) => new YXmlHook(decoder.readKey());
var YXmlText = class extends YText {
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get nextSibling() {
    const n = this._item ? this._item.next : null;
    return n ? (
      /** @type {YXmlElement|YXmlText} */
      /** @type {ContentType} */
      n.content.type
    ) : null;
  }
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get prevSibling() {
    const n = this._item ? this._item.prev : null;
    return n ? (
      /** @type {YXmlElement|YXmlText} */
      /** @type {ContentType} */
      n.content.type
    ) : null;
  }
  _copy() {
    return new YXmlText();
  }
  /**
   * @return {YXmlText}
   */
  clone() {
    const text2 = new YXmlText();
    text2.applyDelta(this.toDelta());
    return text2;
  }
  /**
   * Creates a Dom Element that mirrors this YXmlText.
   *
   * @param {Document} [_document=document] The document object (you must define
   *                                        this when calling this method in
   *                                        nodejs)
   * @param {Object<string, any>} [hooks] Optional property to customize how hooks
   *                                             are presented in the DOM
   * @param {any} [binding] You should not set this property. This is
   *                               used if DomBinding wants to create a
   *                               association to the created DOM type.
   * @return {Text} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
   *
   * @public
   */
  toDOM(_document = document, hooks, binding) {
    const dom = _document.createTextNode(this.toString());
    if (binding !== void 0) {
      binding._createAssociation(dom, this);
    }
    return dom;
  }
  toString() {
    return this.toDelta().map((delta) => {
      const nestedNodes = [];
      for (const nodeName in delta.attributes) {
        const attrs = [];
        for (const key in delta.attributes[nodeName]) {
          attrs.push({ key, value: delta.attributes[nodeName][key] });
        }
        attrs.sort((a, b) => a.key < b.key ? -1 : 1);
        nestedNodes.push({ nodeName, attrs });
      }
      nestedNodes.sort((a, b) => a.nodeName < b.nodeName ? -1 : 1);
      let str = "";
      for (let i = 0; i < nestedNodes.length; i++) {
        const node = nestedNodes[i];
        str += `<${node.nodeName}`;
        for (let j = 0; j < node.attrs.length; j++) {
          const attr = node.attrs[j];
          str += ` ${attr.key}="${attr.value}"`;
        }
        str += ">";
      }
      str += delta.insert;
      for (let i = nestedNodes.length - 1; i >= 0; i--) {
        str += `</${nestedNodes[i].nodeName}>`;
      }
      return str;
    }).join("");
  }
  /**
   * @return {string}
   */
  toJSON() {
    return this.toString();
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */
  _write(encoder) {
    encoder.writeTypeRef(YXmlTextRefID);
  }
};
var readYXmlText = (decoder) => new YXmlText();
var AbstractStruct = class {
  /**
   * @param {ID} id
   * @param {number} length
   */
  constructor(id2, length3) {
    this.id = id2;
    this.length = length3;
  }
  /**
   * @type {boolean}
   */
  get deleted() {
    throw methodUnimplemented();
  }
  /**
   * Merge this struct with the item to the right.
   * This method is already assuming that `this.id.clock + this.length === this.id.clock`.
   * Also this method does *not* remove right from StructStore!
   * @param {AbstractStruct} right
   * @return {boolean} wether this merged with right
   */
  mergeWith(right) {
    return false;
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   * @param {number} offset
   * @param {number} encodingRef
   */
  write(encoder, offset, encodingRef) {
    throw methodUnimplemented();
  }
  /**
   * @param {Transaction} transaction
   * @param {number} offset
   */
  integrate(transaction, offset) {
    throw methodUnimplemented();
  }
};
var structGCRefNumber = 0;
var GC = class extends AbstractStruct {
  get deleted() {
    return true;
  }
  delete() {
  }
  /**
   * @param {GC} right
   * @return {boolean}
   */
  mergeWith(right) {
    if (this.constructor !== right.constructor) {
      return false;
    }
    this.length += right.length;
    return true;
  }
  /**
   * @param {Transaction} transaction
   * @param {number} offset
   */
  integrate(transaction, offset) {
    if (offset > 0) {
      this.id.clock += offset;
      this.length -= offset;
    }
    addStruct(transaction.doc.store, this);
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset) {
    encoder.writeInfo(structGCRefNumber);
    encoder.writeLen(this.length - offset);
  }
  /**
   * @param {Transaction} transaction
   * @param {StructStore} store
   * @return {null | number}
   */
  getMissing(transaction, store) {
    return null;
  }
};
var ContentBinary = class {
  /**
   * @param {Uint8Array} content
   */
  constructor(content) {
    this.content = content;
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [this.content];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return true;
  }
  /**
   * @return {ContentBinary}
   */
  copy() {
    return new ContentBinary(this.content);
  }
  /**
   * @param {number} offset
   * @return {ContentBinary}
   */
  splice(offset) {
    throw methodUnimplemented();
  }
  /**
   * @param {ContentBinary} right
   * @return {boolean}
   */
  mergeWith(right) {
    return false;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(transaction, item) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
  }
  /**
   * @param {StructStore} store
   */
  gc(store) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset) {
    encoder.writeBuf(this.content);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 3;
  }
};
var readContentBinary = (decoder) => new ContentBinary(decoder.readBuf());
var ContentDeleted = class {
  /**
   * @param {number} len
   */
  constructor(len) {
    this.len = len;
  }
  /**
   * @return {number}
   */
  getLength() {
    return this.len;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return false;
  }
  /**
   * @return {ContentDeleted}
   */
  copy() {
    return new ContentDeleted(this.len);
  }
  /**
   * @param {number} offset
   * @return {ContentDeleted}
   */
  splice(offset) {
    const right = new ContentDeleted(this.len - offset);
    this.len = offset;
    return right;
  }
  /**
   * @param {ContentDeleted} right
   * @return {boolean}
   */
  mergeWith(right) {
    this.len += right.len;
    return true;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(transaction, item) {
    addToDeleteSet(transaction.deleteSet, item.id.client, item.id.clock, this.len);
    item.markDeleted();
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
  }
  /**
   * @param {StructStore} store
   */
  gc(store) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset) {
    encoder.writeLen(this.len - offset);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 1;
  }
};
var readContentDeleted = (decoder) => new ContentDeleted(decoder.readLen());
var createDocFromOpts = (guid, opts) => new Doc({ guid, ...opts, shouldLoad: opts.shouldLoad || opts.autoLoad || false });
var ContentDoc = class {
  /**
   * @param {Doc} doc
   */
  constructor(doc2) {
    if (doc2._item) {
      console.error("This document was already integrated as a sub-document. You should create a second instance instead with the same guid.");
    }
    this.doc = doc2;
    const opts = {};
    this.opts = opts;
    if (!doc2.gc) {
      opts.gc = false;
    }
    if (doc2.autoLoad) {
      opts.autoLoad = true;
    }
    if (doc2.meta !== null) {
      opts.meta = doc2.meta;
    }
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [this.doc];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return true;
  }
  /**
   * @return {ContentDoc}
   */
  copy() {
    return new ContentDoc(createDocFromOpts(this.doc.guid, this.opts));
  }
  /**
   * @param {number} offset
   * @return {ContentDoc}
   */
  splice(offset) {
    throw methodUnimplemented();
  }
  /**
   * @param {ContentDoc} right
   * @return {boolean}
   */
  mergeWith(right) {
    return false;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(transaction, item) {
    this.doc._item = item;
    transaction.subdocsAdded.add(this.doc);
    if (this.doc.shouldLoad) {
      transaction.subdocsLoaded.add(this.doc);
    }
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
    if (transaction.subdocsAdded.has(this.doc)) {
      transaction.subdocsAdded.delete(this.doc);
    } else {
      transaction.subdocsRemoved.add(this.doc);
    }
  }
  /**
   * @param {StructStore} store
   */
  gc(store) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset) {
    encoder.writeString(this.doc.guid);
    encoder.writeAny(this.opts);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 9;
  }
};
var readContentDoc = (decoder) => new ContentDoc(createDocFromOpts(decoder.readString(), decoder.readAny()));
var ContentEmbed = class {
  /**
   * @param {Object} embed
   */
  constructor(embed) {
    this.embed = embed;
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [this.embed];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return true;
  }
  /**
   * @return {ContentEmbed}
   */
  copy() {
    return new ContentEmbed(this.embed);
  }
  /**
   * @param {number} offset
   * @return {ContentEmbed}
   */
  splice(offset) {
    throw methodUnimplemented();
  }
  /**
   * @param {ContentEmbed} right
   * @return {boolean}
   */
  mergeWith(right) {
    return false;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(transaction, item) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
  }
  /**
   * @param {StructStore} store
   */
  gc(store) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset) {
    encoder.writeJSON(this.embed);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 5;
  }
};
var readContentEmbed = (decoder) => new ContentEmbed(decoder.readJSON());
var ContentFormat = class {
  /**
   * @param {string} key
   * @param {Object} value
   */
  constructor(key, value) {
    this.key = key;
    this.value = value;
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return false;
  }
  /**
   * @return {ContentFormat}
   */
  copy() {
    return new ContentFormat(this.key, this.value);
  }
  /**
   * @param {number} _offset
   * @return {ContentFormat}
   */
  splice(_offset) {
    throw methodUnimplemented();
  }
  /**
   * @param {ContentFormat} _right
   * @return {boolean}
   */
  mergeWith(_right) {
    return false;
  }
  /**
   * @param {Transaction} _transaction
   * @param {Item} item
   */
  integrate(_transaction, item) {
    const p = (
      /** @type {YText} */
      item.parent
    );
    p._searchMarker = null;
    p._hasFormatting = true;
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
  }
  /**
   * @param {StructStore} store
   */
  gc(store) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset) {
    encoder.writeKey(this.key);
    encoder.writeJSON(this.value);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 6;
  }
};
var readContentFormat = (decoder) => new ContentFormat(decoder.readKey(), decoder.readJSON());
var ContentJSON = class {
  /**
   * @param {Array<any>} arr
   */
  constructor(arr) {
    this.arr = arr;
  }
  /**
   * @return {number}
   */
  getLength() {
    return this.arr.length;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return this.arr;
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return true;
  }
  /**
   * @return {ContentJSON}
   */
  copy() {
    return new ContentJSON(this.arr);
  }
  /**
   * @param {number} offset
   * @return {ContentJSON}
   */
  splice(offset) {
    const right = new ContentJSON(this.arr.slice(offset));
    this.arr = this.arr.slice(0, offset);
    return right;
  }
  /**
   * @param {ContentJSON} right
   * @return {boolean}
   */
  mergeWith(right) {
    this.arr = this.arr.concat(right.arr);
    return true;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(transaction, item) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
  }
  /**
   * @param {StructStore} store
   */
  gc(store) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset) {
    const len = this.arr.length;
    encoder.writeLen(len - offset);
    for (let i = offset; i < len; i++) {
      const c = this.arr[i];
      encoder.writeString(c === void 0 ? "undefined" : JSON.stringify(c));
    }
  }
  /**
   * @return {number}
   */
  getRef() {
    return 2;
  }
};
var readContentJSON = (decoder) => {
  const len = decoder.readLen();
  const cs = [];
  for (let i = 0; i < len; i++) {
    const c = decoder.readString();
    if (c === "undefined") {
      cs.push(void 0);
    } else {
      cs.push(JSON.parse(c));
    }
  }
  return new ContentJSON(cs);
};
var ContentAny = class {
  /**
   * @param {Array<any>} arr
   */
  constructor(arr) {
    this.arr = arr;
  }
  /**
   * @return {number}
   */
  getLength() {
    return this.arr.length;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return this.arr;
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return true;
  }
  /**
   * @return {ContentAny}
   */
  copy() {
    return new ContentAny(this.arr);
  }
  /**
   * @param {number} offset
   * @return {ContentAny}
   */
  splice(offset) {
    const right = new ContentAny(this.arr.slice(offset));
    this.arr = this.arr.slice(0, offset);
    return right;
  }
  /**
   * @param {ContentAny} right
   * @return {boolean}
   */
  mergeWith(right) {
    this.arr = this.arr.concat(right.arr);
    return true;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(transaction, item) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
  }
  /**
   * @param {StructStore} store
   */
  gc(store) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset) {
    const len = this.arr.length;
    encoder.writeLen(len - offset);
    for (let i = offset; i < len; i++) {
      const c = this.arr[i];
      encoder.writeAny(c);
    }
  }
  /**
   * @return {number}
   */
  getRef() {
    return 8;
  }
};
var readContentAny = (decoder) => {
  const len = decoder.readLen();
  const cs = [];
  for (let i = 0; i < len; i++) {
    cs.push(decoder.readAny());
  }
  return new ContentAny(cs);
};
var ContentString = class {
  /**
   * @param {string} str
   */
  constructor(str) {
    this.str = str;
  }
  /**
   * @return {number}
   */
  getLength() {
    return this.str.length;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return this.str.split("");
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return true;
  }
  /**
   * @return {ContentString}
   */
  copy() {
    return new ContentString(this.str);
  }
  /**
   * @param {number} offset
   * @return {ContentString}
   */
  splice(offset) {
    const right = new ContentString(this.str.slice(offset));
    this.str = this.str.slice(0, offset);
    const firstCharCode = this.str.charCodeAt(offset - 1);
    if (firstCharCode >= 55296 && firstCharCode <= 56319) {
      this.str = this.str.slice(0, offset - 1) + "\uFFFD";
      right.str = "\uFFFD" + right.str.slice(1);
    }
    return right;
  }
  /**
   * @param {ContentString} right
   * @return {boolean}
   */
  mergeWith(right) {
    this.str += right.str;
    return true;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(transaction, item) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
  }
  /**
   * @param {StructStore} store
   */
  gc(store) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset) {
    encoder.writeString(offset === 0 ? this.str : this.str.slice(offset));
  }
  /**
   * @return {number}
   */
  getRef() {
    return 4;
  }
};
var readContentString = (decoder) => new ContentString(decoder.readString());
var typeRefs = [
  readYArray,
  readYMap,
  readYText,
  readYXmlElement,
  readYXmlFragment,
  readYXmlHook,
  readYXmlText
];
var YArrayRefID = 0;
var YMapRefID = 1;
var YTextRefID = 2;
var YXmlElementRefID = 3;
var YXmlFragmentRefID = 4;
var YXmlHookRefID = 5;
var YXmlTextRefID = 6;
var ContentType = class {
  /**
   * @param {AbstractType<any>} type
   */
  constructor(type2) {
    this.type = type2;
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [this.type];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return true;
  }
  /**
   * @return {ContentType}
   */
  copy() {
    return new ContentType(this.type._copy());
  }
  /**
   * @param {number} offset
   * @return {ContentType}
   */
  splice(offset) {
    throw methodUnimplemented();
  }
  /**
   * @param {ContentType} right
   * @return {boolean}
   */
  mergeWith(right) {
    return false;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(transaction, item) {
    this.type._integrate(transaction.doc, item);
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
    let item = this.type._start;
    while (item !== null) {
      if (!item.deleted) {
        item.delete(transaction);
      } else if (item.id.clock < (transaction.beforeState.get(item.id.client) || 0)) {
        transaction._mergeStructs.push(item);
      }
      item = item.right;
    }
    this.type._map.forEach((item2) => {
      if (!item2.deleted) {
        item2.delete(transaction);
      } else if (item2.id.clock < (transaction.beforeState.get(item2.id.client) || 0)) {
        transaction._mergeStructs.push(item2);
      }
    });
    transaction.changed.delete(this.type);
  }
  /**
   * @param {StructStore} store
   */
  gc(store) {
    let item = this.type._start;
    while (item !== null) {
      item.gc(store, true);
      item = item.right;
    }
    this.type._start = null;
    this.type._map.forEach(
      /** @param {Item | null} item */
      (item2) => {
        while (item2 !== null) {
          item2.gc(store, true);
          item2 = item2.left;
        }
      }
    );
    this.type._map = /* @__PURE__ */ new Map();
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset) {
    this.type._write(encoder);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 7;
  }
};
var readContentType = (decoder) => new ContentType(typeRefs[decoder.readTypeRef()](decoder));
var followRedone = (store, id2) => {
  let nextID = id2;
  let diff = 0;
  let item;
  do {
    if (diff > 0) {
      nextID = createID(nextID.client, nextID.clock + diff);
    }
    item = getItem(store, nextID);
    diff = nextID.clock - item.id.clock;
    nextID = item.redone;
  } while (nextID !== null && item instanceof Item);
  return {
    item,
    diff
  };
};
var keepItem = (item, keep) => {
  while (item !== null && item.keep !== keep) {
    item.keep = keep;
    item = /** @type {AbstractType<any>} */
    item.parent._item;
  }
};
var splitItem = (transaction, leftItem, diff) => {
  const { client, clock } = leftItem.id;
  const rightItem = new Item(
    createID(client, clock + diff),
    leftItem,
    createID(client, clock + diff - 1),
    leftItem.right,
    leftItem.rightOrigin,
    leftItem.parent,
    leftItem.parentSub,
    leftItem.content.splice(diff)
  );
  if (leftItem.deleted) {
    rightItem.markDeleted();
  }
  if (leftItem.keep) {
    rightItem.keep = true;
  }
  if (leftItem.redone !== null) {
    rightItem.redone = createID(leftItem.redone.client, leftItem.redone.clock + diff);
  }
  leftItem.right = rightItem;
  if (rightItem.right !== null) {
    rightItem.right.left = rightItem;
  }
  transaction._mergeStructs.push(rightItem);
  if (rightItem.parentSub !== null && rightItem.right === null) {
    rightItem.parent._map.set(rightItem.parentSub, rightItem);
  }
  leftItem.length = diff;
  return rightItem;
};
var isDeletedByUndoStack = (stack, id2) => some(
  stack,
  /** @param {StackItem} s */
  (s) => isDeleted(s.deletions, id2)
);
var redoItem = (transaction, item, redoitems, itemsToDelete, ignoreRemoteMapChanges, um) => {
  const doc2 = transaction.doc;
  const store = doc2.store;
  const ownClientID = doc2.clientID;
  const redone = item.redone;
  if (redone !== null) {
    return getItemCleanStart(transaction, redone);
  }
  let parentItem = (
    /** @type {AbstractType<any>} */
    item.parent._item
  );
  let left = null;
  let right;
  if (parentItem !== null && parentItem.deleted === true) {
    if (parentItem.redone === null && (!redoitems.has(parentItem) || redoItem(transaction, parentItem, redoitems, itemsToDelete, ignoreRemoteMapChanges, um) === null)) {
      return null;
    }
    while (parentItem.redone !== null) {
      parentItem = getItemCleanStart(transaction, parentItem.redone);
    }
  }
  const parentType = parentItem === null ? (
    /** @type {AbstractType<any>} */
    item.parent
  ) : (
    /** @type {ContentType} */
    parentItem.content.type
  );
  if (item.parentSub === null) {
    left = item.left;
    right = item;
    while (left !== null) {
      let leftTrace = left;
      while (leftTrace !== null && /** @type {AbstractType<any>} */
      leftTrace.parent._item !== parentItem) {
        leftTrace = leftTrace.redone === null ? null : getItemCleanStart(transaction, leftTrace.redone);
      }
      if (leftTrace !== null && /** @type {AbstractType<any>} */
      leftTrace.parent._item === parentItem) {
        left = leftTrace;
        break;
      }
      left = left.left;
    }
    while (right !== null) {
      let rightTrace = right;
      while (rightTrace !== null && /** @type {AbstractType<any>} */
      rightTrace.parent._item !== parentItem) {
        rightTrace = rightTrace.redone === null ? null : getItemCleanStart(transaction, rightTrace.redone);
      }
      if (rightTrace !== null && /** @type {AbstractType<any>} */
      rightTrace.parent._item === parentItem) {
        right = rightTrace;
        break;
      }
      right = right.right;
    }
  } else {
    right = null;
    if (item.right && !ignoreRemoteMapChanges) {
      left = item;
      while (left !== null && left.right !== null && (left.right.redone || isDeleted(itemsToDelete, left.right.id) || isDeletedByUndoStack(um.undoStack, left.right.id) || isDeletedByUndoStack(um.redoStack, left.right.id))) {
        left = left.right;
        while (left.redone)
          left = getItemCleanStart(transaction, left.redone);
      }
      if (left && left.right !== null) {
        return null;
      }
    } else {
      left = parentType._map.get(item.parentSub) || null;
    }
  }
  const nextClock = getState(store, ownClientID);
  const nextId = createID(ownClientID, nextClock);
  const redoneItem = new Item(
    nextId,
    left,
    left && left.lastId,
    right,
    right && right.id,
    parentType,
    item.parentSub,
    item.content.copy()
  );
  item.redone = nextId;
  keepItem(redoneItem, true);
  redoneItem.integrate(transaction, 0);
  return redoneItem;
};
var Item = class extends AbstractStruct {
  /**
   * @param {ID} id
   * @param {Item | null} left
   * @param {ID | null} origin
   * @param {Item | null} right
   * @param {ID | null} rightOrigin
   * @param {AbstractType<any>|ID|null} parent Is a type if integrated, is null if it is possible to copy parent from left or right, is ID before integration to search for it.
   * @param {string | null} parentSub
   * @param {AbstractContent} content
   */
  constructor(id2, left, origin, right, rightOrigin, parent, parentSub, content) {
    super(id2, content.getLength());
    this.origin = origin;
    this.left = left;
    this.right = right;
    this.rightOrigin = rightOrigin;
    this.parent = parent;
    this.parentSub = parentSub;
    this.redone = null;
    this.content = content;
    this.info = this.content.isCountable() ? BIT2 : 0;
  }
  /**
   * This is used to mark the item as an indexed fast-search marker
   *
   * @type {boolean}
   */
  set marker(isMarked) {
    if ((this.info & BIT4) > 0 !== isMarked) {
      this.info ^= BIT4;
    }
  }
  get marker() {
    return (this.info & BIT4) > 0;
  }
  /**
   * If true, do not garbage collect this Item.
   */
  get keep() {
    return (this.info & BIT1) > 0;
  }
  set keep(doKeep) {
    if (this.keep !== doKeep) {
      this.info ^= BIT1;
    }
  }
  get countable() {
    return (this.info & BIT2) > 0;
  }
  /**
   * Whether this item was deleted or not.
   * @type {Boolean}
   */
  get deleted() {
    return (this.info & BIT3) > 0;
  }
  set deleted(doDelete) {
    if (this.deleted !== doDelete) {
      this.info ^= BIT3;
    }
  }
  markDeleted() {
    this.info |= BIT3;
  }
  /**
   * Return the creator clientID of the missing op or define missing items and return null.
   *
   * @param {Transaction} transaction
   * @param {StructStore} store
   * @return {null | number}
   */
  getMissing(transaction, store) {
    if (this.origin && this.origin.client !== this.id.client && this.origin.clock >= getState(store, this.origin.client)) {
      return this.origin.client;
    }
    if (this.rightOrigin && this.rightOrigin.client !== this.id.client && this.rightOrigin.clock >= getState(store, this.rightOrigin.client)) {
      return this.rightOrigin.client;
    }
    if (this.parent && this.parent.constructor === ID && this.id.client !== this.parent.client && this.parent.clock >= getState(store, this.parent.client)) {
      return this.parent.client;
    }
    if (this.origin) {
      this.left = getItemCleanEnd(transaction, store, this.origin);
      this.origin = this.left.lastId;
    }
    if (this.rightOrigin) {
      this.right = getItemCleanStart(transaction, this.rightOrigin);
      this.rightOrigin = this.right.id;
    }
    if (this.left && this.left.constructor === GC || this.right && this.right.constructor === GC) {
      this.parent = null;
    } else if (!this.parent) {
      if (this.left && this.left.constructor === Item) {
        this.parent = this.left.parent;
        this.parentSub = this.left.parentSub;
      }
      if (this.right && this.right.constructor === Item) {
        this.parent = this.right.parent;
        this.parentSub = this.right.parentSub;
      }
    } else if (this.parent.constructor === ID) {
      const parentItem = getItem(store, this.parent);
      if (parentItem.constructor === GC) {
        this.parent = null;
      } else {
        this.parent = /** @type {ContentType} */
        parentItem.content.type;
      }
    }
    return null;
  }
  /**
   * @param {Transaction} transaction
   * @param {number} offset
   */
  integrate(transaction, offset) {
    if (offset > 0) {
      this.id.clock += offset;
      this.left = getItemCleanEnd(transaction, transaction.doc.store, createID(this.id.client, this.id.clock - 1));
      this.origin = this.left.lastId;
      this.content = this.content.splice(offset);
      this.length -= offset;
    }
    if (this.parent) {
      if (!this.left && (!this.right || this.right.left !== null) || this.left && this.left.right !== this.right) {
        let left = this.left;
        let o;
        if (left !== null) {
          o = left.right;
        } else if (this.parentSub !== null) {
          o = /** @type {AbstractType<any>} */
          this.parent._map.get(this.parentSub) || null;
          while (o !== null && o.left !== null) {
            o = o.left;
          }
        } else {
          o = /** @type {AbstractType<any>} */
          this.parent._start;
        }
        const conflictingItems = /* @__PURE__ */ new Set();
        const itemsBeforeOrigin = /* @__PURE__ */ new Set();
        while (o !== null && o !== this.right) {
          itemsBeforeOrigin.add(o);
          conflictingItems.add(o);
          if (compareIDs(this.origin, o.origin)) {
            if (o.id.client < this.id.client) {
              left = o;
              conflictingItems.clear();
            } else if (compareIDs(this.rightOrigin, o.rightOrigin)) {
              break;
            }
          } else if (o.origin !== null && itemsBeforeOrigin.has(getItem(transaction.doc.store, o.origin))) {
            if (!conflictingItems.has(getItem(transaction.doc.store, o.origin))) {
              left = o;
              conflictingItems.clear();
            }
          } else {
            break;
          }
          o = o.right;
        }
        this.left = left;
      }
      if (this.left !== null) {
        const right = this.left.right;
        this.right = right;
        this.left.right = this;
      } else {
        let r;
        if (this.parentSub !== null) {
          r = /** @type {AbstractType<any>} */
          this.parent._map.get(this.parentSub) || null;
          while (r !== null && r.left !== null) {
            r = r.left;
          }
        } else {
          r = /** @type {AbstractType<any>} */
          this.parent._start;
          this.parent._start = this;
        }
        this.right = r;
      }
      if (this.right !== null) {
        this.right.left = this;
      } else if (this.parentSub !== null) {
        this.parent._map.set(this.parentSub, this);
        if (this.left !== null) {
          this.left.delete(transaction);
        }
      }
      if (this.parentSub === null && this.countable && !this.deleted) {
        this.parent._length += this.length;
      }
      addStruct(transaction.doc.store, this);
      this.content.integrate(transaction, this);
      addChangedTypeToTransaction(
        transaction,
        /** @type {AbstractType<any>} */
        this.parent,
        this.parentSub
      );
      if (
        /** @type {AbstractType<any>} */
        this.parent._item !== null && /** @type {AbstractType<any>} */
        this.parent._item.deleted || this.parentSub !== null && this.right !== null
      ) {
        this.delete(transaction);
      }
    } else {
      new GC(this.id, this.length).integrate(transaction, 0);
    }
  }
  /**
   * Returns the next non-deleted item
   */
  get next() {
    let n = this.right;
    while (n !== null && n.deleted) {
      n = n.right;
    }
    return n;
  }
  /**
   * Returns the previous non-deleted item
   */
  get prev() {
    let n = this.left;
    while (n !== null && n.deleted) {
      n = n.left;
    }
    return n;
  }
  /**
   * Computes the last content address of this Item.
   */
  get lastId() {
    return this.length === 1 ? this.id : createID(this.id.client, this.id.clock + this.length - 1);
  }
  /**
   * Try to merge two items
   *
   * @param {Item} right
   * @return {boolean}
   */
  mergeWith(right) {
    if (this.constructor === right.constructor && compareIDs(right.origin, this.lastId) && this.right === right && compareIDs(this.rightOrigin, right.rightOrigin) && this.id.client === right.id.client && this.id.clock + this.length === right.id.clock && this.deleted === right.deleted && this.redone === null && right.redone === null && this.content.constructor === right.content.constructor && this.content.mergeWith(right.content)) {
      const searchMarker = (
        /** @type {AbstractType<any>} */
        this.parent._searchMarker
      );
      if (searchMarker) {
        searchMarker.forEach((marker) => {
          if (marker.p === right) {
            marker.p = this;
            if (!this.deleted && this.countable) {
              marker.index -= this.length;
            }
          }
        });
      }
      if (right.keep) {
        this.keep = true;
      }
      this.right = right.right;
      if (this.right !== null) {
        this.right.left = this;
      }
      this.length += right.length;
      return true;
    }
    return false;
  }
  /**
   * Mark this Item as deleted.
   *
   * @param {Transaction} transaction
   */
  delete(transaction) {
    if (!this.deleted) {
      const parent = (
        /** @type {AbstractType<any>} */
        this.parent
      );
      if (this.countable && this.parentSub === null) {
        parent._length -= this.length;
      }
      this.markDeleted();
      addToDeleteSet(transaction.deleteSet, this.id.client, this.id.clock, this.length);
      addChangedTypeToTransaction(transaction, parent, this.parentSub);
      this.content.delete(transaction);
    }
  }
  /**
   * @param {StructStore} store
   * @param {boolean} parentGCd
   */
  gc(store, parentGCd) {
    if (!this.deleted) {
      throw unexpectedCase();
    }
    this.content.gc(store);
    if (parentGCd) {
      replaceStruct(store, this, new GC(this.id, this.length));
    } else {
      this.content = new ContentDeleted(this.length);
    }
  }
  /**
   * Transform the properties of this type to binary and write it to an
   * BinaryEncoder.
   *
   * This is called when this Item is sent to a remote peer.
   *
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   * @param {number} offset
   */
  write(encoder, offset) {
    const origin = offset > 0 ? createID(this.id.client, this.id.clock + offset - 1) : this.origin;
    const rightOrigin = this.rightOrigin;
    const parentSub = this.parentSub;
    const info = this.content.getRef() & BITS5 | (origin === null ? 0 : BIT8) | // origin is defined
    (rightOrigin === null ? 0 : BIT7) | // right origin is defined
    (parentSub === null ? 0 : BIT6);
    encoder.writeInfo(info);
    if (origin !== null) {
      encoder.writeLeftID(origin);
    }
    if (rightOrigin !== null) {
      encoder.writeRightID(rightOrigin);
    }
    if (origin === null && rightOrigin === null) {
      const parent = (
        /** @type {AbstractType<any>} */
        this.parent
      );
      if (parent._item !== void 0) {
        const parentItem = parent._item;
        if (parentItem === null) {
          const ykey = findRootTypeKey(parent);
          encoder.writeParentInfo(true);
          encoder.writeString(ykey);
        } else {
          encoder.writeParentInfo(false);
          encoder.writeLeftID(parentItem.id);
        }
      } else if (parent.constructor === String) {
        encoder.writeParentInfo(true);
        encoder.writeString(parent);
      } else if (parent.constructor === ID) {
        encoder.writeParentInfo(false);
        encoder.writeLeftID(parent);
      } else {
        unexpectedCase();
      }
      if (parentSub !== null) {
        encoder.writeString(parentSub);
      }
    }
    this.content.write(encoder, offset);
  }
};
var readItemContent = (decoder, info) => contentRefs[info & BITS5](decoder);
var contentRefs = [
  () => {
    unexpectedCase();
  },
  // GC is not ItemContent
  readContentDeleted,
  // 1
  readContentJSON,
  // 2
  readContentBinary,
  // 3
  readContentString,
  // 4
  readContentEmbed,
  // 5
  readContentFormat,
  // 6
  readContentType,
  // 7
  readContentAny,
  // 8
  readContentDoc,
  // 9
  () => {
    unexpectedCase();
  }
  // 10 - Skip is not ItemContent
];
var structSkipRefNumber = 10;
var Skip = class extends AbstractStruct {
  get deleted() {
    return true;
  }
  delete() {
  }
  /**
   * @param {Skip} right
   * @return {boolean}
   */
  mergeWith(right) {
    if (this.constructor !== right.constructor) {
      return false;
    }
    this.length += right.length;
    return true;
  }
  /**
   * @param {Transaction} transaction
   * @param {number} offset
   */
  integrate(transaction, offset) {
    unexpectedCase();
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset) {
    encoder.writeInfo(structSkipRefNumber);
    writeVarUint(encoder.restEncoder, this.length - offset);
  }
  /**
   * @param {Transaction} transaction
   * @param {StructStore} store
   * @return {null | number}
   */
  getMissing(transaction, store) {
    return null;
  }
};
var glo = (
  /** @type {any} */
  typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {}
);
var importIdentifier = "__ $YJS$ __";
if (glo[importIdentifier] === true) {
  console.error("Yjs was already imported. This breaks constructor checks and will lead to issues! - https://github.com/yjs/yjs/issues/438");
}
glo[importIdentifier] = true;

// src/tools.ts
var XXH = __toESM(require_lib());
var createRandomId = () => {
  return window.crypto.randomUUID();
};
var randomUint32 = () => {
  return window.crypto.getRandomValues(new Uint32Array(1))[0];
};
var generateRandomString = function() {
  return Math.random().toString(20).substring(2, 8);
};
var calculateHash = (text2) => {
  return XXH.h32(text2, 43981).toString(16);
};
var serialize = (obj) => {
  if (Array.isArray(obj)) {
    return `[${obj.map((el) => serialize(el)).join(",")}]`;
  } else if (typeof obj === "object" && obj !== null) {
    let acc = "";
    const keys3 = Object.keys(obj).sort();
    acc += `{${JSON.stringify(keys3)}`;
    for (let i = 0; i < keys3.length; i++) {
      acc += `${serialize(obj[keys3[i]])},`;
    }
    return `${acc}}`;
  }
  return `${JSON.stringify(obj)}`;
};

// src/sharedEntities/sharedDocument.ts
var import_state = require("@codemirror/state");

// src/ui.ts
var import_obsidian = require("obsidian");
var ShowTextModal = class extends import_obsidian.Modal {
  constructor(app, title, message) {
    super(app);
    this.message = message;
    this.title = title;
  }
  onOpen() {
    this.titleEl.setText(this.title);
    this.contentEl.setText(this.message);
  }
  onClose() {
    this.containerEl.empty();
  }
};
var showTextModal = (app, title, text2) => {
  new ShowTextModal(app, title, text2).open();
};
var showNotice = (text2, duration) => {
  new import_obsidian.Notice(text2, duration);
};
var openFileInNewTab = async (file, workspace) => {
  const leaf = workspace.getLeaf("tab");
  await leaf.openFile(file);
  return leaf;
};
var pinLeaf = (leaf) => {
  leaf.setPinned(true);
  showNotice(`auto-pinned "${leaf.getDisplayText()}"`);
};
var usercolors = [
  { dark: "#30bced", light: "#30bced33" },
  { dark: "#6eeb83", light: "#6eeb8333" },
  { dark: "#ffbc42", light: "#ffbc4233" },
  { dark: "#ecd444", light: "#ecd44433" },
  { dark: "#ee6352", light: "#ee635233" },
  { dark: "#9ac2c9", light: "#9ac2c933" },
  { dark: "#8acb88", light: "#8acb8833" },
  { dark: "#1be7ff", light: "#1be7ff33" }
];

// node_modules/y-codemirror.next/src/index.js
var cmView4 = __toESM(require("@codemirror/view"), 1);
var cmState4 = __toESM(require("@codemirror/state"), 1);

// node_modules/y-codemirror.next/src/y-sync.js
var cmState = __toESM(require("@codemirror/state"), 1);
var cmView = __toESM(require("@codemirror/view"), 1);

// node_modules/y-codemirror.next/src/y-range.js
var YRange = class {
  /**
   * @param {Y.RelativePosition} yanchor
   * @param {Y.RelativePosition} yhead
   */
  constructor(yanchor, yhead) {
    this.yanchor = yanchor;
    this.yhead = yhead;
  }
  /**
   * @returns {any}
   */
  toJSON() {
    return {
      yanchor: relativePositionToJSON(this.yanchor),
      yhead: relativePositionToJSON(this.yhead)
    };
  }
  /**
   * @param {any} json
   * @return {YRange}
   */
  static fromJSON(json) {
    return new YRange(createRelativePositionFromJSON(json.yanchor), createRelativePositionFromJSON(json.yhead));
  }
};

// node_modules/y-codemirror.next/src/y-sync.js
var YSyncConfig = class {
  constructor(ytext, awareness) {
    this.ytext = ytext;
    this.awareness = awareness;
    this.undoManager = new UndoManager(ytext);
  }
  /**
   * Helper function to transform an absolute index position to a Yjs-based relative position
   * (https://docs.yjs.dev/api/relative-positions).
   *
   * A relative position can be transformed back to an absolute position even after the document has changed. The position is
   * automatically adapted. This does not require any position transformations. Relative positions are computed based on
   * the internal Yjs document model. Peers that share content through Yjs are guaranteed that their positions will always
   * synced up when using relatve positions.
   *
   * ```js
   * import { ySyncFacet } from 'y-codemirror'
   *
   * ..
   * const ysync = view.state.facet(ySyncFacet)
   * // transform an absolute index position to a ypos
   * const ypos = ysync.getYPos(3)
   * // transform the ypos back to an absolute position
   * ysync.fromYPos(ypos) // => 3
   * ```
   *
   * It cannot be guaranteed that absolute index positions can be synced up between peers.
   * This might lead to undesired behavior when implementing features that require that all peers see the
   * same marked range (e.g. a comment plugin).
   *
   * @param {number} pos
   * @param {number} [assoc]
   */
  toYPos(pos, assoc = 0) {
    return createRelativePositionFromTypeIndex(this.ytext, pos, assoc);
  }
  /**
   * @param {Y.RelativePosition | Object} rpos
   */
  fromYPos(rpos) {
    const pos = createAbsolutePositionFromRelativePosition(createRelativePositionFromJSON(rpos), this.ytext.doc);
    if (pos == null || pos.type !== this.ytext) {
      throw new Error("[y-codemirror] The position you want to retrieve was created by a different document");
    }
    return {
      pos: pos.index,
      assoc: pos.assoc
    };
  }
  /**
   * @param {cmState.SelectionRange} range
   * @return {YRange}
   */
  toYRange(range) {
    const assoc = range.assoc;
    const yanchor = this.toYPos(range.anchor, assoc);
    const yhead = this.toYPos(range.head, assoc);
    return new YRange(yanchor, yhead);
  }
  /**
   * @param {YRange} yrange
   */
  fromYRange(yrange) {
    const anchor = this.fromYPos(yrange.yanchor);
    const head = this.fromYPos(yrange.yhead);
    if (anchor.pos === head.pos) {
      return cmState.EditorSelection.cursor(head.pos, head.assoc);
    }
    return cmState.EditorSelection.range(anchor.pos, head.pos);
  }
};
var ySyncFacet = cmState.Facet.define({
  combine(inputs) {
    return inputs[inputs.length - 1];
  }
});
var ySyncAnnotation = cmState.Annotation.define();
var YSyncPluginValue = class {
  /**
   * @param {cmView.EditorView} view
   */
  constructor(view) {
    this.view = view;
    this.conf = view.state.facet(ySyncFacet);
    this._observer = (event, tr) => {
      if (tr.origin !== this.conf) {
        const delta = event.delta;
        const changes = [];
        let pos = 0;
        for (let i = 0; i < delta.length; i++) {
          const d = delta[i];
          if (d.insert != null) {
            changes.push({ from: pos, to: pos, insert: d.insert });
          } else if (d.delete != null) {
            changes.push({ from: pos, to: pos + d.delete, insert: "" });
            pos += d.delete;
          } else {
            pos += d.retain;
          }
        }
        view.dispatch({ changes, annotations: [ySyncAnnotation.of(this.conf)] });
      }
    };
    this._ytext = this.conf.ytext;
    this._ytext.observe(this._observer);
  }
  /**
   * @param {cmView.ViewUpdate} update
   */
  update(update) {
    if (!update.docChanged || update.transactions.length > 0 && update.transactions[0].annotation(ySyncAnnotation) === this.conf) {
      return;
    }
    const ytext = this.conf.ytext;
    ytext.doc.transact(() => {
      let adj = 0;
      update.changes.iterChanges((fromA, toA, fromB, toB, insert) => {
        const insertText2 = insert.sliceString(0, insert.length, "\n");
        if (fromA !== toA) {
          ytext.delete(fromA + adj, toA - fromA);
        }
        if (insertText2.length > 0) {
          ytext.insert(fromA + adj, insertText2);
        }
        adj += insertText2.length - (toA - fromA);
      });
    }, this.conf);
  }
  destroy() {
    this._ytext.unobserve(this._observer);
  }
};
var ySync = cmView.ViewPlugin.fromClass(YSyncPluginValue);

// node_modules/y-codemirror.next/src/y-remote-selections.js
var cmView2 = __toESM(require("@codemirror/view"), 1);
var cmState2 = __toESM(require("@codemirror/state"), 1);
var yRemoteSelectionsTheme = cmView2.EditorView.baseTheme({
  ".cm-ySelection": {},
  ".cm-yLineSelection": {
    padding: 0,
    margin: "0px 2px 0px 4px"
  },
  ".cm-ySelectionCaret": {
    position: "relative",
    borderLeft: "1px solid black",
    borderRight: "1px solid black",
    marginLeft: "-1px",
    marginRight: "-1px",
    boxSizing: "border-box",
    display: "inline"
  },
  ".cm-ySelectionCaretDot": {
    borderRadius: "50%",
    position: "absolute",
    width: ".4em",
    height: ".4em",
    top: "-.2em",
    left: "-.2em",
    backgroundColor: "inherit",
    transition: "transform .3s ease-in-out",
    boxSizing: "border-box"
  },
  ".cm-ySelectionCaret:hover > .cm-ySelectionCaretDot": {
    transformOrigin: "bottom center",
    transform: "scale(0)"
  },
  ".cm-ySelectionInfo": {
    position: "absolute",
    top: "-1.05em",
    left: "-1px",
    fontSize: ".75em",
    fontFamily: "serif",
    fontStyle: "normal",
    fontWeight: "normal",
    lineHeight: "normal",
    userSelect: "none",
    color: "white",
    paddingLeft: "2px",
    paddingRight: "2px",
    zIndex: 101,
    transition: "opacity .3s ease-in-out",
    backgroundColor: "inherit",
    // these should be separate
    opacity: 0,
    transitionDelay: "0s",
    whiteSpace: "nowrap"
  },
  ".cm-ySelectionCaret:hover > .cm-ySelectionInfo": {
    opacity: 1,
    transitionDelay: "0s"
  }
});
var yRemoteSelectionsAnnotation = cmState2.Annotation.define();
var YRemoteCaretWidget = class extends cmView2.WidgetType {
  /**
   * @param {string} color
   * @param {string} name
   */
  constructor(color, name) {
    super();
    this.color = color;
    this.name = name;
  }
  toDOM() {
    return (
      /** @type {HTMLElement} */
      element("span", [create5("class", "cm-ySelectionCaret"), create5("style", `background-color: ${this.color}; border-color: ${this.color}`)], [
        text("\u2060"),
        element("div", [
          create5("class", "cm-ySelectionCaretDot")
        ]),
        text("\u2060"),
        element("div", [
          create5("class", "cm-ySelectionInfo")
        ], [
          text(this.name)
        ]),
        text("\u2060")
      ])
    );
  }
  eq(widget) {
    return widget.color === this.color;
  }
  compare(widget) {
    return widget.color === this.color;
  }
  updateDOM() {
    return false;
  }
  get estimatedHeight() {
    return -1;
  }
  ignoreEvent() {
    return true;
  }
};
var YRemoteSelectionsPluginValue = class {
  /**
   * @param {cmView.EditorView} view
   */
  constructor(view) {
    this.conf = view.state.facet(ySyncFacet);
    this._listener = ({ added, updated, removed }, s, t) => {
      const clients = added.concat(updated).concat(removed);
      if (clients.findIndex((id2) => id2 !== this.conf.awareness.doc.clientID) >= 0) {
        view.dispatch({ annotations: [yRemoteSelectionsAnnotation.of([])] });
      }
    };
    this._awareness = this.conf.awareness;
    this._awareness.on("change", this._listener);
    this.decorations = cmState2.RangeSet.of([]);
  }
  destroy() {
    this._awareness.off("change", this._listener);
  }
  /**
   * @param {cmView.ViewUpdate} update
   */
  update(update) {
    const ytext = this.conf.ytext;
    const ydoc = (
      /** @type {Y.Doc} */
      ytext.doc
    );
    const awareness = this.conf.awareness;
    const decorations = [];
    const localAwarenessState = this.conf.awareness.getLocalState();
    if (localAwarenessState != null) {
      const hasFocus = update.view.hasFocus && update.view.dom.ownerDocument.hasFocus();
      const sel = hasFocus ? update.state.selection.main : null;
      const currentAnchor = localAwarenessState.cursor == null ? null : createRelativePositionFromJSON(localAwarenessState.cursor.anchor);
      const currentHead = localAwarenessState.cursor == null ? null : createRelativePositionFromJSON(localAwarenessState.cursor.head);
      if (sel != null) {
        const anchor = createRelativePositionFromTypeIndex(ytext, sel.anchor);
        const head = createRelativePositionFromTypeIndex(ytext, sel.head);
        if (localAwarenessState.cursor == null || !compareRelativePositions(currentAnchor, anchor) || !compareRelativePositions(currentHead, head)) {
          awareness.setLocalStateField("cursor", {
            anchor,
            head
          });
        }
      } else if (localAwarenessState.cursor != null && hasFocus) {
        awareness.setLocalStateField("cursor", null);
      }
    }
    awareness.getStates().forEach((state, clientid) => {
      if (clientid === awareness.doc.clientID) {
        return;
      }
      const cursor = state.cursor;
      if (cursor == null || cursor.anchor == null || cursor.head == null) {
        return;
      }
      const anchor = createAbsolutePositionFromRelativePosition(cursor.anchor, ydoc);
      const head = createAbsolutePositionFromRelativePosition(cursor.head, ydoc);
      if (anchor == null || head == null || anchor.type !== ytext || head.type !== ytext) {
        return;
      }
      const { color = "#30bced", name = "Anonymous" } = state.user || {};
      const colorLight = state.user && state.user.colorLight || color + "33";
      const start = min(anchor.index, head.index);
      const end = max(anchor.index, head.index);
      const startLine = update.view.state.doc.lineAt(start);
      const endLine = update.view.state.doc.lineAt(end);
      if (startLine.number === endLine.number) {
        decorations.push({
          from: start,
          to: end,
          value: cmView2.Decoration.mark({
            attributes: { style: `background-color: ${colorLight}` },
            class: "cm-ySelection"
          })
        });
      } else {
        decorations.push({
          from: start,
          to: startLine.from + startLine.length,
          value: cmView2.Decoration.mark({
            attributes: { style: `background-color: ${colorLight}` },
            class: "cm-ySelection"
          })
        });
        decorations.push({
          from: endLine.from,
          to: end,
          value: cmView2.Decoration.mark({
            attributes: { style: `background-color: ${colorLight}` },
            class: "cm-ySelection"
          })
        });
        for (let i = startLine.number + 1; i < endLine.number; i++) {
          const linePos = update.view.state.doc.line(i).from;
          decorations.push({
            from: linePos,
            to: linePos,
            value: cmView2.Decoration.line({
              attributes: { style: `background-color: ${colorLight}`, class: "cm-yLineSelection" }
            })
          });
        }
      }
      decorations.push({
        from: head.index,
        to: head.index,
        value: cmView2.Decoration.widget({
          side: head.index - anchor.index > 0 ? -1 : 1,
          // the local cursor should be rendered outside the remote selection
          block: false,
          widget: new YRemoteCaretWidget(color, name)
        })
      });
    });
    this.decorations = cmView2.Decoration.set(decorations, true);
  }
};
var yRemoteSelections = cmView2.ViewPlugin.fromClass(YRemoteSelectionsPluginValue, {
  decorations: (v) => v.decorations
});

// node_modules/y-codemirror.next/src/y-undomanager.js
var cmState3 = __toESM(require("@codemirror/state"), 1);
var cmView3 = __toESM(require("@codemirror/view"), 1);

// node_modules/lib0/mutex.js
var createMutex = () => {
  let token = true;
  return (f, g) => {
    if (token) {
      token = false;
      try {
        f();
      } finally {
        token = true;
      }
    } else if (g !== void 0) {
      g();
    }
  };
};

// node_modules/y-codemirror.next/src/y-undomanager.js
var YUndoManagerConfig = class {
  /**
   * @param {Y.UndoManager} undoManager
   */
  constructor(undoManager) {
    this.undoManager = undoManager;
  }
  /**
   * @param {any} origin
   */
  addTrackedOrigin(origin) {
    this.undoManager.addTrackedOrigin(origin);
  }
  /**
   * @param {any} origin
   */
  removeTrackedOrigin(origin) {
    this.undoManager.removeTrackedOrigin(origin);
  }
  /**
   * @return {boolean} Whether a change was undone.
   */
  undo() {
    return this.undoManager.undo() != null;
  }
  /**
   * @return {boolean} Whether a change was redone.
   */
  redo() {
    return this.undoManager.redo() != null;
  }
};
var yUndoManagerFacet = cmState3.Facet.define({
  combine(inputs) {
    return inputs[inputs.length - 1];
  }
});
var yUndoManagerAnnotation = cmState3.Annotation.define();
var YUndoManagerPluginValue = class {
  /**
   * @param {cmView.EditorView} view
   */
  constructor(view) {
    this.view = view;
    this.conf = view.state.facet(yUndoManagerFacet);
    this._undoManager = this.conf.undoManager;
    this.syncConf = view.state.facet(ySyncFacet);
    this._beforeChangeSelection = null;
    this._mux = createMutex();
    this._onStackItemAdded = ({ stackItem, changedParentTypes }) => {
      if (changedParentTypes.has(this.syncConf.ytext) && this._beforeChangeSelection && !stackItem.meta.has(this)) {
        stackItem.meta.set(this, this._beforeChangeSelection);
      }
    };
    this._onStackItemPopped = ({ stackItem }) => {
      const sel = stackItem.meta.get(this);
      if (sel) {
        const selection = this.syncConf.fromYRange(sel);
        view.dispatch(view.state.update({ selection }));
        this._storeSelection();
      }
    };
    this._storeSelection = () => {
      this._beforeChangeSelection = this.syncConf.toYRange(this.view.state.selection.main);
    };
    this._undoManager.on("stack-item-added", this._onStackItemAdded);
    this._undoManager.on("stack-item-popped", this._onStackItemPopped);
    this._undoManager.addTrackedOrigin(this.syncConf);
  }
  /**
   * @param {cmView.ViewUpdate} update
   */
  update(update) {
    if (update.selectionSet && (update.transactions.length === 0 || update.transactions[0].annotation(ySyncAnnotation) !== this.syncConf)) {
      this._storeSelection();
    }
  }
  destroy() {
    this._undoManager.off("stack-item-added", this._onStackItemAdded);
    this._undoManager.off("stack-item-popped", this._onStackItemPopped);
    this._undoManager.removeTrackedOrigin(this.syncConf);
  }
};
var yUndoManager = cmView3.ViewPlugin.fromClass(YUndoManagerPluginValue);
var undo = ({ state, dispatch }) => state.facet(yUndoManagerFacet).undo() || true;
var redo = ({ state, dispatch }) => state.facet(yUndoManagerFacet).redo() || true;

// node_modules/y-codemirror.next/src/index.js
var yCollab = (ytext, awareness, { undoManager = new UndoManager(ytext) } = {}) => {
  const ySyncConfig = new YSyncConfig(ytext, awareness);
  const plugins = [
    ySyncFacet.of(ySyncConfig),
    ySync
  ];
  if (awareness) {
    plugins.push(
      yRemoteSelectionsTheme,
      yRemoteSelections
    );
  }
  if (undoManager !== false) {
    plugins.push(
      yUndoManagerFacet.of(new YUndoManagerConfig(undoManager)),
      yUndoManager,
      cmView4.EditorView.domEventHandlers({
        beforeinput(e, view) {
          if (e.inputType === "historyUndo")
            return undo(view);
          if (e.inputType === "historyRedo")
            return redo(view);
          return false;
        }
      })
    );
  }
  return plugins;
};

// src/sharedEntities/sharedDocument.ts
var import_state2 = require("@codemirror/state");

// src/utils/peerdraftRecord.ts
var PeerdraftRecord = class extends ObservableV2 {
  constructor() {
    super(...arguments);
    this.record = {};
  }
  set(key, value) {
    const oldValue = this.record[key];
    this.record[key] = value;
    if (oldValue === void 0) {
      this.emit("add", [key, value]);
    } else if (oldValue != value) {
      this.emit("update", [key, oldValue, value]);
    }
  }
  get(key) {
    return this.record[key];
  }
  delete(key) {
    const oldValue = this.record[key];
    delete this.record[key];
    this.emit("delete", [key, oldValue]);
  }
  get size() {
    return Object.keys(this.record).length;
  }
  get keys() {
    return Object.keys(this.record);
  }
};

// src/workspace/peerdraftLeaf.ts
var PeerdraftLeaf = class extends ObservableV2 {
  constructor(path4, isPreview) {
    super();
    this._isPreview = isPreview, this._path = path4;
  }
  get isPreview() {
    return this._isPreview;
  }
  set isPreview(value) {
    const old = this._isPreview;
    this._isPreview = value;
    if (value != old) {
      this.emit("changeIsPreview", [old, value]);
    }
  }
  get path() {
    return this._path;
  }
  set path(value) {
    const old = this._path;
    this._path = value;
    if (value != old) {
      this.emit("changePath", [old, value]);
    }
  }
};

// src/workspace/peerdraftWorkspace.ts
var import_obsidian2 = require("obsidian");
var updatePeerdraftWorkspace = (ws, pws) => {
  var _a, _b;
  const leafs = ws.getLeavesOfType("markdown");
  const oldLeafIds = pws.keys;
  const existingLeafIds = leafs.map((leaf) => {
    return leaf.id;
  });
  for (const leaf of leafs) {
    const leafId = leaf.id;
    const isPreview = leaf.view.containerEl.getAttribute("data-mode") === "preview";
    const path4 = (_b = (_a = leaf.view.file) == null ? void 0 : _a.path) != null ? _b : "";
    let pleaf = pws.get(leafId);
    if (pleaf) {
      pleaf.isPreview = isPreview;
      pleaf.path = path4;
    } else {
      pleaf = new PeerdraftLeaf(path4, isPreview);
      pws.set(leafId, pleaf);
    }
  }
  for (const oldLeafId of oldLeafIds) {
    if (!existingLeafIds.contains(oldLeafId)) {
      pws.delete(oldLeafId);
    }
  }
};
var getLeafsByPath = (path4, pws) => {
  return pws.keys.map((key) => {
    return pws.get(key);
  }).filter((leaf) => {
    return leaf.path === path4;
  });
};
var getLeafIdsByPath = (path4, pws) => {
  const normalizedPath = (0, import_obsidian2.normalizePath)(path4);
  return pws.keys.filter((key) => {
    return (0, import_obsidian2.normalizePath)(pws.get(key).path) === normalizedPath;
  });
};

// node_modules/lib0/websocket.js
var reconnectTimeoutBase = 1200;
var maxReconnectTimeout = 2500;
var messageReconnectTimeout = 3e4;
var setupWS = (wsclient) => {
  if (wsclient.shouldConnect && wsclient.ws === null) {
    const websocket = new WebSocket(wsclient.url);
    const binaryType = wsclient.binaryType;
    let pingTimeout = null;
    if (binaryType) {
      websocket.binaryType = binaryType;
    }
    wsclient.ws = websocket;
    wsclient.connecting = true;
    wsclient.connected = false;
    websocket.onmessage = (event) => {
      wsclient.lastMessageReceived = getUnixTime();
      const data = event.data;
      const message = typeof data === "string" ? JSON.parse(data) : data;
      if (message && message.type === "pong") {
        clearTimeout(pingTimeout);
        pingTimeout = setTimeout(sendPing, messageReconnectTimeout / 2);
      }
      wsclient.emit("message", [message, wsclient]);
    };
    const onclose = (error) => {
      if (wsclient.ws !== null) {
        wsclient.ws = null;
        wsclient.connecting = false;
        if (wsclient.connected) {
          wsclient.connected = false;
          wsclient.emit("disconnect", [{ type: "disconnect", error }, wsclient]);
        } else {
          wsclient.unsuccessfulReconnects++;
        }
        setTimeout(setupWS, min(log10(wsclient.unsuccessfulReconnects + 1) * reconnectTimeoutBase, maxReconnectTimeout), wsclient);
      }
      clearTimeout(pingTimeout);
    };
    const sendPing = () => {
      if (wsclient.ws === websocket) {
        wsclient.send({
          type: "ping"
        });
      }
    };
    websocket.onclose = () => onclose(null);
    websocket.onerror = (error) => onclose(error);
    websocket.onopen = () => {
      wsclient.lastMessageReceived = getUnixTime();
      wsclient.connecting = false;
      wsclient.connected = true;
      wsclient.unsuccessfulReconnects = 0;
      wsclient.emit("connect", [{ type: "connect" }, wsclient]);
      pingTimeout = setTimeout(sendPing, messageReconnectTimeout / 2);
    };
  }
};
var WebsocketClient = class extends Observable {
  /**
   * @param {string} url
   * @param {object} opts
   * @param {'arraybuffer' | 'blob' | null} [opts.binaryType] Set `ws.binaryType`
   */
  constructor(url, { binaryType } = {}) {
    super();
    this.url = url;
    this.ws = null;
    this.binaryType = binaryType || null;
    this.connected = false;
    this.connecting = false;
    this.unsuccessfulReconnects = 0;
    this.lastMessageReceived = 0;
    this.shouldConnect = true;
    this._checkInterval = setInterval(() => {
      if (this.connected && messageReconnectTimeout < getUnixTime() - this.lastMessageReceived) {
        this.ws.close();
      }
    }, messageReconnectTimeout / 2);
    setupWS(this);
  }
  /**
   * @param {any} message
   */
  send(message) {
    if (this.ws) {
      this.ws.send(JSON.stringify(message));
    }
  }
  destroy() {
    clearInterval(this._checkInterval);
    this.disconnect();
    super.destroy();
  }
  disconnect() {
    this.shouldConnect = false;
    if (this.ws !== null) {
      this.ws.close();
    }
  }
  connect() {
    this.shouldConnect = true;
    if (!this.connected && this.ws === null) {
      setupWS(this);
    }
  }
};

// node_modules/lib0/broadcastchannel.js
var channels = /* @__PURE__ */ new Map();
var LocalStoragePolyfill = class {
  /**
   * @param {string} room
   */
  constructor(room) {
    this.room = room;
    this.onmessage = null;
    this._onChange = (e) => e.key === room && this.onmessage !== null && this.onmessage({ data: fromBase64(e.newValue || "") });
    onChange(this._onChange);
  }
  /**
   * @param {ArrayBuffer} buf
   */
  postMessage(buf) {
    varStorage.setItem(this.room, toBase64(createUint8ArrayFromArrayBuffer(buf)));
  }
  close() {
    offChange(this._onChange);
  }
};
var BC = typeof BroadcastChannel === "undefined" ? LocalStoragePolyfill : BroadcastChannel;
var getChannel = (room) => setIfUndefined(channels, room, () => {
  const subs = create2();
  const bc = new BC(room);
  bc.onmessage = (e) => subs.forEach((sub) => sub(e.data, "broadcastchannel"));
  return {
    bc,
    subs
  };
});
var subscribe = (room, f) => {
  getChannel(room).subs.add(f);
  return f;
};
var unsubscribe = (room, f) => {
  const channel = getChannel(room);
  const unsubscribed = channel.subs.delete(f);
  if (unsubscribed && channel.subs.size === 0) {
    channel.bc.close();
    channels.delete(room);
  }
  return unsubscribed;
};
var publish = (room, data, origin = null) => {
  const c = getChannel(room);
  c.bc.postMessage(data);
  c.subs.forEach((sub) => sub(data, origin));
};

// node_modules/y-webrtc/src/y-webrtc.js
var import_simplepeer_min = __toESM(require_simplepeer_min(), 1);

// node_modules/y-protocols/sync.js
var messageYjsSyncStep1 = 0;
var messageYjsSyncStep2 = 1;
var messageYjsUpdate = 2;
var writeSyncStep1 = (encoder, doc2) => {
  writeVarUint(encoder, messageYjsSyncStep1);
  const sv = encodeStateVector(doc2);
  writeVarUint8Array(encoder, sv);
};
var writeSyncStep2 = (encoder, doc2, encodedStateVector) => {
  writeVarUint(encoder, messageYjsSyncStep2);
  writeVarUint8Array(encoder, encodeStateAsUpdate(doc2, encodedStateVector));
};
var readSyncStep1 = (decoder, encoder, doc2) => writeSyncStep2(encoder, doc2, readVarUint8Array(decoder));
var readSyncStep2 = (decoder, doc2, transactionOrigin) => {
  try {
    applyUpdate(doc2, readVarUint8Array(decoder), transactionOrigin);
  } catch (error) {
    console.error("Caught error while handling a Yjs update", error);
  }
};
var writeUpdate = (encoder, update) => {
  writeVarUint(encoder, messageYjsUpdate);
  writeVarUint8Array(encoder, update);
};
var readUpdate = readSyncStep2;
var readSyncMessage = (decoder, encoder, doc2, transactionOrigin) => {
  const messageType = readVarUint(decoder);
  switch (messageType) {
    case messageYjsSyncStep1:
      readSyncStep1(decoder, encoder, doc2);
      break;
    case messageYjsSyncStep2:
      readSyncStep2(decoder, doc2, transactionOrigin);
      break;
    case messageYjsUpdate:
      readUpdate(decoder, doc2, transactionOrigin);
      break;
    default:
      throw new Error("Unknown message type");
  }
  return messageType;
};

// node_modules/y-protocols/awareness.js
var outdatedTimeout = 3e4;
var Awareness = class extends Observable {
  /**
   * @param {Y.Doc} doc
   */
  constructor(doc2) {
    super();
    this.doc = doc2;
    this.clientID = doc2.clientID;
    this.states = /* @__PURE__ */ new Map();
    this.meta = /* @__PURE__ */ new Map();
    this._checkInterval = /** @type {any} */
    setInterval(() => {
      const now = getUnixTime();
      if (this.getLocalState() !== null && outdatedTimeout / 2 <= now - /** @type {{lastUpdated:number}} */
      this.meta.get(this.clientID).lastUpdated) {
        this.setLocalState(this.getLocalState());
      }
      const remove = [];
      this.meta.forEach((meta, clientid) => {
        if (clientid !== this.clientID && outdatedTimeout <= now - meta.lastUpdated && this.states.has(clientid)) {
          remove.push(clientid);
        }
      });
      if (remove.length > 0) {
        removeAwarenessStates(this, remove, "timeout");
      }
    }, floor(outdatedTimeout / 10));
    doc2.on("destroy", () => {
      this.destroy();
    });
    this.setLocalState({});
  }
  destroy() {
    this.emit("destroy", [this]);
    this.setLocalState(null);
    super.destroy();
    clearInterval(this._checkInterval);
  }
  /**
   * @return {Object<string,any>|null}
   */
  getLocalState() {
    return this.states.get(this.clientID) || null;
  }
  /**
   * @param {Object<string,any>|null} state
   */
  setLocalState(state) {
    const clientID = this.clientID;
    const currLocalMeta = this.meta.get(clientID);
    const clock = currLocalMeta === void 0 ? 0 : currLocalMeta.clock + 1;
    const prevState = this.states.get(clientID);
    if (state === null) {
      this.states.delete(clientID);
    } else {
      this.states.set(clientID, state);
    }
    this.meta.set(clientID, {
      clock,
      lastUpdated: getUnixTime()
    });
    const added = [];
    const updated = [];
    const filteredUpdated = [];
    const removed = [];
    if (state === null) {
      removed.push(clientID);
    } else if (prevState == null) {
      if (state != null) {
        added.push(clientID);
      }
    } else {
      updated.push(clientID);
      if (!equalityDeep(prevState, state)) {
        filteredUpdated.push(clientID);
      }
    }
    if (added.length > 0 || filteredUpdated.length > 0 || removed.length > 0) {
      this.emit("change", [{ added, updated: filteredUpdated, removed }, "local"]);
    }
    this.emit("update", [{ added, updated, removed }, "local"]);
  }
  /**
   * @param {string} field
   * @param {any} value
   */
  setLocalStateField(field, value) {
    const state = this.getLocalState();
    if (state !== null) {
      this.setLocalState({
        ...state,
        [field]: value
      });
    }
  }
  /**
   * @return {Map<number,Object<string,any>>}
   */
  getStates() {
    return this.states;
  }
};
var removeAwarenessStates = (awareness, clients, origin) => {
  const removed = [];
  for (let i = 0; i < clients.length; i++) {
    const clientID = clients[i];
    if (awareness.states.has(clientID)) {
      awareness.states.delete(clientID);
      if (clientID === awareness.clientID) {
        const curMeta = (
          /** @type {MetaClientState} */
          awareness.meta.get(clientID)
        );
        awareness.meta.set(clientID, {
          clock: curMeta.clock + 1,
          lastUpdated: getUnixTime()
        });
      }
      removed.push(clientID);
    }
  }
  if (removed.length > 0) {
    awareness.emit("change", [{ added: [], updated: [], removed }, origin]);
    awareness.emit("update", [{ added: [], updated: [], removed }, origin]);
  }
};
var encodeAwarenessUpdate = (awareness, clients, states = awareness.states) => {
  const len = clients.length;
  const encoder = createEncoder();
  writeVarUint(encoder, len);
  for (let i = 0; i < len; i++) {
    const clientID = clients[i];
    const state = states.get(clientID) || null;
    const clock = (
      /** @type {MetaClientState} */
      awareness.meta.get(clientID).clock
    );
    writeVarUint(encoder, clientID);
    writeVarUint(encoder, clock);
    writeVarString(encoder, JSON.stringify(state));
  }
  return toUint8Array(encoder);
};
var applyAwarenessUpdate = (awareness, update, origin) => {
  const decoder = createDecoder(update);
  const timestamp = getUnixTime();
  const added = [];
  const updated = [];
  const filteredUpdated = [];
  const removed = [];
  const len = readVarUint(decoder);
  for (let i = 0; i < len; i++) {
    const clientID = readVarUint(decoder);
    let clock = readVarUint(decoder);
    const state = JSON.parse(readVarString(decoder));
    const clientMeta = awareness.meta.get(clientID);
    const prevState = awareness.states.get(clientID);
    const currClock = clientMeta === void 0 ? 0 : clientMeta.clock;
    if (currClock < clock || currClock === clock && state === null && awareness.states.has(clientID)) {
      if (state === null) {
        if (clientID === awareness.clientID && awareness.getLocalState() != null) {
          clock++;
        } else {
          awareness.states.delete(clientID);
        }
      } else {
        awareness.states.set(clientID, state);
      }
      awareness.meta.set(clientID, {
        clock,
        lastUpdated: timestamp
      });
      if (clientMeta === void 0 && state !== null) {
        added.push(clientID);
      } else if (clientMeta !== void 0 && state === null) {
        removed.push(clientID);
      } else if (state !== null) {
        if (!equalityDeep(state, prevState)) {
          filteredUpdated.push(clientID);
        }
        updated.push(clientID);
      }
    }
  }
  if (added.length > 0 || filteredUpdated.length > 0 || removed.length > 0) {
    awareness.emit("change", [{
      added,
      updated: filteredUpdated,
      removed
    }, origin]);
  }
  if (added.length > 0 || updated.length > 0 || removed.length > 0) {
    awareness.emit("update", [{
      added,
      updated,
      removed
    }, origin]);
  }
};

// node_modules/y-webrtc/src/crypto.js
var deriveKey = (secret, roomName) => {
  const secretBuffer = encodeUtf8(secret).buffer;
  const salt = encodeUtf8(roomName).buffer;
  return crypto.subtle.importKey(
    "raw",
    secretBuffer,
    "PBKDF2",
    false,
    ["deriveKey"]
  ).then(
    (keyMaterial) => crypto.subtle.deriveKey(
      {
        name: "PBKDF2",
        salt,
        iterations: 1e5,
        hash: "SHA-256"
      },
      keyMaterial,
      {
        name: "AES-GCM",
        length: 256
      },
      true,
      ["encrypt", "decrypt"]
    )
  );
};
var encrypt = (data, key) => {
  if (!key) {
    return (
      /** @type {PromiseLike<Uint8Array>} */
      resolve(data)
    );
  }
  const iv = crypto.getRandomValues(new Uint8Array(12));
  return crypto.subtle.encrypt(
    {
      name: "AES-GCM",
      iv
    },
    key,
    data
  ).then((cipher) => {
    const encryptedDataEncoder = createEncoder();
    writeVarString(encryptedDataEncoder, "AES-GCM");
    writeVarUint8Array(encryptedDataEncoder, iv);
    writeVarUint8Array(encryptedDataEncoder, new Uint8Array(cipher));
    return toUint8Array(encryptedDataEncoder);
  });
};
var encryptJson = (data, key) => {
  const dataEncoder = createEncoder();
  writeAny(dataEncoder, data);
  return encrypt(toUint8Array(dataEncoder), key);
};
var decrypt = (data, key) => {
  if (!key) {
    return (
      /** @type {PromiseLike<Uint8Array>} */
      resolve(data)
    );
  }
  const dataDecoder = createDecoder(data);
  const algorithm = readVarString(dataDecoder);
  if (algorithm !== "AES-GCM") {
    reject(create3("Unknown encryption algorithm"));
  }
  const iv = readVarUint8Array(dataDecoder);
  const cipher = readVarUint8Array(dataDecoder);
  return crypto.subtle.decrypt(
    {
      name: "AES-GCM",
      iv
    },
    key,
    cipher
  ).then((data2) => new Uint8Array(data2));
};
var decryptJson = (data, key) => decrypt(data, key).then(
  (decryptedValue) => readAny(createDecoder(new Uint8Array(decryptedValue)))
);

// node_modules/y-webrtc/src/y-webrtc.js
var log = createModuleLogger2("y-webrtc");
var messageSync = 0;
var messageQueryAwareness = 3;
var messageAwareness = 1;
var messageBcPeerId = 4;
var signalingConns = /* @__PURE__ */ new Map();
var rooms = /* @__PURE__ */ new Map();
var checkIsSynced = (room) => {
  let synced = true;
  room.webrtcConns.forEach((peer) => {
    if (!peer.synced) {
      synced = false;
    }
  });
  if (!synced && room.synced || synced && !room.synced) {
    room.synced = synced;
    room.provider.emit("synced", [{ synced }]);
    log("synced ", BOLD, room.name, UNBOLD, " with all peers");
  }
};
var readMessage = (room, buf, syncedCallback) => {
  const decoder = createDecoder(buf);
  const encoder = createEncoder();
  const messageType = readVarUint(decoder);
  if (room === void 0) {
    return null;
  }
  const awareness = room.awareness;
  const doc2 = room.doc;
  let sendReply = false;
  switch (messageType) {
    case messageSync: {
      writeVarUint(encoder, messageSync);
      const syncMessageType = readSyncMessage(decoder, encoder, doc2, room);
      if (syncMessageType === messageYjsSyncStep2 && !room.synced) {
        syncedCallback();
      }
      if (syncMessageType === messageYjsSyncStep1) {
        sendReply = true;
      }
      break;
    }
    case messageQueryAwareness:
      writeVarUint(encoder, messageAwareness);
      writeVarUint8Array(encoder, encodeAwarenessUpdate(awareness, Array.from(awareness.getStates().keys())));
      sendReply = true;
      break;
    case messageAwareness:
      applyAwarenessUpdate(awareness, readVarUint8Array(decoder), room);
      break;
    case messageBcPeerId: {
      const add2 = readUint8(decoder) === 1;
      const peerName = readVarString(decoder);
      if (peerName !== room.peerId && (room.bcConns.has(peerName) && !add2 || !room.bcConns.has(peerName) && add2)) {
        const removed = [];
        const added = [];
        if (add2) {
          room.bcConns.add(peerName);
          added.push(peerName);
        } else {
          room.bcConns.delete(peerName);
          removed.push(peerName);
        }
        room.provider.emit("peers", [{
          added,
          removed,
          webrtcPeers: Array.from(room.webrtcConns.keys()),
          bcPeers: Array.from(room.bcConns)
        }]);
        broadcastBcPeerId(room);
      }
      break;
    }
    default:
      console.error("Unable to compute message");
      return encoder;
  }
  if (!sendReply) {
    return null;
  }
  return encoder;
};
var readPeerMessage = (peerConn, buf) => {
  const room = peerConn.room;
  log("received message from ", BOLD, peerConn.remotePeerId, GREY, " (", room.name, ")", UNBOLD, UNCOLOR);
  return readMessage(room, buf, () => {
    peerConn.synced = true;
    log("synced ", BOLD, room.name, UNBOLD, " with ", BOLD, peerConn.remotePeerId);
    checkIsSynced(room);
  });
};
var sendWebrtcConn = (webrtcConn, encoder) => {
  log("send message to ", BOLD, webrtcConn.remotePeerId, UNBOLD, GREY, " (", webrtcConn.room.name, ")", UNCOLOR);
  try {
    webrtcConn.peer.send(toUint8Array(encoder));
  } catch (e) {
  }
};
var broadcastWebrtcConn = (room, m) => {
  log("broadcast message in ", BOLD, room.name, UNBOLD);
  room.webrtcConns.forEach((conn) => {
    try {
      conn.peer.send(m);
    } catch (e) {
    }
  });
};
var WebrtcConn = class {
  /**
   * @param {SignalingConn} signalingConn
   * @param {boolean} initiator
   * @param {string} remotePeerId
   * @param {Room} room
   */
  constructor(signalingConn, initiator, remotePeerId, room) {
    log("establishing connection to ", BOLD, remotePeerId);
    this.room = room;
    this.remotePeerId = remotePeerId;
    this.glareToken = void 0;
    this.closed = false;
    this.connected = false;
    this.synced = false;
    this.peer = new import_simplepeer_min.default({ initiator, ...room.provider.peerOpts });
    this.peer.on("signal", (signal) => {
      if (this.glareToken === void 0) {
        this.glareToken = Date.now() + Math.random();
      }
      publishSignalingMessage(signalingConn, room, { to: remotePeerId, from: room.peerId, type: "signal", token: this.glareToken, signal });
    });
    this.peer.on("connect", () => {
      log("connected to ", BOLD, remotePeerId);
      this.connected = true;
      const provider = room.provider;
      const doc2 = provider.doc;
      const awareness = room.awareness;
      const encoder = createEncoder();
      writeVarUint(encoder, messageSync);
      writeSyncStep1(encoder, doc2);
      sendWebrtcConn(this, encoder);
      const awarenessStates = awareness.getStates();
      if (awarenessStates.size > 0) {
        const encoder2 = createEncoder();
        writeVarUint(encoder2, messageAwareness);
        writeVarUint8Array(encoder2, encodeAwarenessUpdate(awareness, Array.from(awarenessStates.keys())));
        sendWebrtcConn(this, encoder2);
      }
    });
    this.peer.on("close", () => {
      this.connected = false;
      this.closed = true;
      if (room.webrtcConns.has(this.remotePeerId)) {
        room.webrtcConns.delete(this.remotePeerId);
        room.provider.emit("peers", [{
          removed: [this.remotePeerId],
          added: [],
          webrtcPeers: Array.from(room.webrtcConns.keys()),
          bcPeers: Array.from(room.bcConns)
        }]);
      }
      checkIsSynced(room);
      this.peer.destroy();
      log("closed connection to ", BOLD, remotePeerId);
      announceSignalingInfo(room);
    });
    this.peer.on("error", (err) => {
      log("Error in connection to ", BOLD, remotePeerId, ": ", err);
      announceSignalingInfo(room);
    });
    this.peer.on("data", (data) => {
      const answer = readPeerMessage(this, data);
      if (answer !== null) {
        sendWebrtcConn(this, answer);
      }
    });
  }
  destroy() {
    this.peer.destroy();
  }
};
var broadcastBcMessage = (room, m) => encrypt(m, room.key).then(
  (data) => room.mux(
    () => publish(room.name, data)
  )
);
var broadcastRoomMessage = (room, m) => {
  if (room.bcconnected) {
    broadcastBcMessage(room, m);
  }
  broadcastWebrtcConn(room, m);
};
var announceSignalingInfo = (room) => {
  signalingConns.forEach((conn) => {
    if (conn.connected) {
      conn.send({ type: "subscribe", topics: [room.name] });
      if (room.webrtcConns.size < room.provider.maxConns) {
        publishSignalingMessage(conn, room, { type: "announce", from: room.peerId });
      }
    }
  });
};
var broadcastBcPeerId = (room) => {
  if (room.provider.filterBcConns) {
    const encoderPeerIdBc = createEncoder();
    writeVarUint(encoderPeerIdBc, messageBcPeerId);
    writeUint8(encoderPeerIdBc, 1);
    writeVarString(encoderPeerIdBc, room.peerId);
    broadcastBcMessage(room, toUint8Array(encoderPeerIdBc));
  }
};
var Room = class {
  /**
   * @param {Y.Doc} doc
   * @param {WebrtcProvider} provider
   * @param {string} name
   * @param {CryptoKey|null} key
   */
  constructor(doc2, provider, name, key) {
    this.peerId = uuidv4();
    this.doc = doc2;
    this.awareness = provider.awareness;
    this.provider = provider;
    this.synced = false;
    this.name = name;
    this.key = key;
    this.webrtcConns = /* @__PURE__ */ new Map();
    this.bcConns = /* @__PURE__ */ new Set();
    this.mux = createMutex();
    this.bcconnected = false;
    this._bcSubscriber = (data) => decrypt(new Uint8Array(data), key).then(
      (m) => this.mux(() => {
        const reply = readMessage(this, m, () => {
        });
        if (reply) {
          broadcastBcMessage(this, toUint8Array(reply));
        }
      })
    );
    this._docUpdateHandler = (update, origin) => {
      const encoder = createEncoder();
      writeVarUint(encoder, messageSync);
      writeUpdate(encoder, update);
      broadcastRoomMessage(this, toUint8Array(encoder));
    };
    this._awarenessUpdateHandler = ({ added, updated, removed }, origin) => {
      const changedClients = added.concat(updated).concat(removed);
      const encoderAwareness = createEncoder();
      writeVarUint(encoderAwareness, messageAwareness);
      writeVarUint8Array(encoderAwareness, encodeAwarenessUpdate(this.awareness, changedClients));
      broadcastRoomMessage(this, toUint8Array(encoderAwareness));
    };
    this._beforeUnloadHandler = () => {
      removeAwarenessStates(this.awareness, [doc2.clientID], "window unload");
      rooms.forEach((room) => {
        room.disconnect();
      });
    };
    if (typeof window !== "undefined") {
      window.addEventListener("beforeunload", this._beforeUnloadHandler);
    } else if (typeof process !== "undefined") {
      process.on("exit", this._beforeUnloadHandler);
    }
  }
  connect() {
    this.doc.on("update", this._docUpdateHandler);
    this.awareness.on("update", this._awarenessUpdateHandler);
    announceSignalingInfo(this);
    const roomName = this.name;
    subscribe(roomName, this._bcSubscriber);
    this.bcconnected = true;
    broadcastBcPeerId(this);
    const encoderSync = createEncoder();
    writeVarUint(encoderSync, messageSync);
    writeSyncStep1(encoderSync, this.doc);
    broadcastBcMessage(this, toUint8Array(encoderSync));
    const encoderState = createEncoder();
    writeVarUint(encoderState, messageSync);
    writeSyncStep2(encoderState, this.doc);
    broadcastBcMessage(this, toUint8Array(encoderState));
    const encoderAwarenessQuery = createEncoder();
    writeVarUint(encoderAwarenessQuery, messageQueryAwareness);
    broadcastBcMessage(this, toUint8Array(encoderAwarenessQuery));
    const encoderAwarenessState = createEncoder();
    writeVarUint(encoderAwarenessState, messageAwareness);
    writeVarUint8Array(encoderAwarenessState, encodeAwarenessUpdate(this.awareness, [this.doc.clientID]));
    broadcastBcMessage(this, toUint8Array(encoderAwarenessState));
  }
  disconnect() {
    signalingConns.forEach((conn) => {
      if (conn.connected) {
        conn.send({ type: "unsubscribe", topics: [this.name] });
      }
    });
    removeAwarenessStates(this.awareness, [this.doc.clientID], "disconnect");
    const encoderPeerIdBc = createEncoder();
    writeVarUint(encoderPeerIdBc, messageBcPeerId);
    writeUint8(encoderPeerIdBc, 0);
    writeVarString(encoderPeerIdBc, this.peerId);
    broadcastBcMessage(this, toUint8Array(encoderPeerIdBc));
    unsubscribe(this.name, this._bcSubscriber);
    this.bcconnected = false;
    this.doc.off("update", this._docUpdateHandler);
    this.awareness.off("update", this._awarenessUpdateHandler);
    this.webrtcConns.forEach((conn) => conn.destroy());
  }
  destroy() {
    this.disconnect();
    if (typeof window !== "undefined") {
      window.removeEventListener("beforeunload", this._beforeUnloadHandler);
    } else if (typeof process !== "undefined") {
      process.off("exit", this._beforeUnloadHandler);
    }
  }
};
var openRoom = (doc2, provider, name, key) => {
  if (rooms.has(name)) {
    throw create3(`A Yjs Doc connected to room "${name}" already exists!`);
  }
  const room = new Room(doc2, provider, name, key);
  rooms.set(
    name,
    /** @type {Room} */
    room
  );
  return room;
};
var publishSignalingMessage = (conn, room, data) => {
  if (room.key) {
    encryptJson(data, room.key).then((data2) => {
      conn.send({ type: "publish", topic: room.name, data: toBase64(data2) });
    });
  } else {
    conn.send({ type: "publish", topic: room.name, data });
  }
};
var SignalingConn = class extends WebsocketClient {
  constructor(url) {
    super(url);
    this.providers = /* @__PURE__ */ new Set();
    this.on("connect", () => {
      log(`connected (${url})`);
      const topics = Array.from(rooms.keys());
      this.send({ type: "subscribe", topics });
      rooms.forEach(
        (room) => publishSignalingMessage(this, room, { type: "announce", from: room.peerId })
      );
    });
    this.on("message", (m) => {
      switch (m.type) {
        case "publish": {
          const roomName = m.topic;
          const room = rooms.get(roomName);
          if (room == null || typeof roomName !== "string") {
            return;
          }
          const execMessage = (data) => {
            const webrtcConns = room.webrtcConns;
            const peerId = room.peerId;
            if (data == null || data.from === peerId || data.to !== void 0 && data.to !== peerId || room.bcConns.has(data.from)) {
              return;
            }
            const emitPeerChange = webrtcConns.has(data.from) ? () => {
            } : () => room.provider.emit("peers", [{
              removed: [],
              added: [data.from],
              webrtcPeers: Array.from(room.webrtcConns.keys()),
              bcPeers: Array.from(room.bcConns)
            }]);
            switch (data.type) {
              case "announce":
                if (webrtcConns.size < room.provider.maxConns) {
                  setIfUndefined(webrtcConns, data.from, () => new WebrtcConn(this, true, data.from, room));
                  emitPeerChange();
                }
                break;
              case "signal":
                if (data.signal.type === "offer") {
                  const existingConn = webrtcConns.get(data.from);
                  if (existingConn) {
                    const remoteToken = data.token;
                    const localToken = existingConn.glareToken;
                    if (localToken && localToken > remoteToken) {
                      log("offer rejected: ", data.from);
                      return;
                    }
                    existingConn.glareToken = void 0;
                  }
                }
                if (data.signal.type === "answer") {
                  log("offer answered by: ", data.from);
                  const existingConn = webrtcConns.get(data.from);
                  existingConn.glareToken = void 0;
                }
                if (data.to === peerId) {
                  setIfUndefined(webrtcConns, data.from, () => new WebrtcConn(this, false, data.from, room)).peer.signal(data.signal);
                  emitPeerChange();
                }
                break;
            }
          };
          if (room.key) {
            if (typeof m.data === "string") {
              decryptJson(fromBase64(m.data), room.key).then(execMessage);
            }
          } else {
            execMessage(m.data);
          }
        }
      }
    });
    this.on("disconnect", () => log(`disconnect (${url})`));
  }
};
var WebrtcProvider = class extends Observable {
  /**
   * @param {string} roomName
   * @param {Y.Doc} doc
   * @param {ProviderOptions?} opts
   */
  constructor(roomName, doc2, {
    signaling = ["wss://y-webrtc-eu.fly.dev"],
    password = null,
    awareness = new Awareness(doc2),
    maxConns = 20 + floor(rand() * 15),
    // the random factor reduces the chance that n clients form a cluster
    filterBcConns = true,
    peerOpts = {}
    // simple-peer options. See https://github.com/feross/simple-peer#peer--new-peeropts
  } = {}) {
    super();
    this.roomName = roomName;
    this.doc = doc2;
    this.filterBcConns = filterBcConns;
    this.awareness = awareness;
    this.shouldConnect = false;
    this.signalingUrls = signaling;
    this.signalingConns = [];
    this.maxConns = maxConns;
    this.peerOpts = peerOpts;
    this.key = password ? deriveKey(password, roomName) : (
      /** @type {PromiseLike<null>} */
      resolve(null)
    );
    this.room = null;
    this.key.then((key) => {
      this.room = openRoom(doc2, this, roomName, key);
      if (this.shouldConnect) {
        this.room.connect();
      } else {
        this.room.disconnect();
      }
    });
    this.connect();
    this.destroy = this.destroy.bind(this);
    doc2.on("destroy", this.destroy);
  }
  /**
   * @type {boolean}
   */
  get connected() {
    return this.room !== null && this.shouldConnect;
  }
  connect() {
    this.shouldConnect = true;
    this.signalingUrls.forEach((url) => {
      const signalingConn = setIfUndefined(signalingConns, url, () => new SignalingConn(url));
      this.signalingConns.push(signalingConn);
      signalingConn.providers.add(this);
    });
    if (this.room) {
      this.room.connect();
    }
  }
  disconnect() {
    this.shouldConnect = false;
    this.signalingConns.forEach((conn) => {
      conn.providers.delete(this);
      if (conn.providers.size === 0) {
        conn.destroy();
        signalingConns.delete(conn.url);
      }
    });
    if (this.room) {
      this.room.disconnect();
    }
  }
  destroy() {
    this.doc.off("destroy", this.destroy);
    this.key.then(() => {
      this.room.destroy();
      rooms.delete(this.roomName);
    });
    super.destroy();
  }
};

// src/sharedEntities/sharedEntity.ts
var import_obsidian3 = require("obsidian");
var SharedEntity = class {
  constructor(plugin) {
    this.plugin = plugin;
    this._webRTCTimeout = null;
  }
  get shareId() {
    return this._shareId;
  }
  get path() {
    return this._path;
  }
  get indexedDBProvider() {
    return this._indexedDBProvider;
  }
  get webRTCProvider() {
    return this._webRTCProvider;
  }
  static findByPath(path4) {
    const normalizedPath = (0, import_obsidian3.normalizePath)(path4);
    const docs = this._sharedEntites.filter((doc2) => {
      return doc2.path === normalizedPath;
    });
    if (docs.length >= 1) {
      return docs[0];
    } else {
      return;
    }
  }
  static findById(id2) {
    const docs = this._sharedEntites.filter((doc2) => {
      return doc2.shareId === id2;
    });
    if (docs.length >= 1) {
      return docs[0];
    } else {
      return;
    }
  }
  static getAll() {
    return Object.assign([], this._sharedEntites);
  }
  initServerYDoc() {
    return new Promise((resolve2) => {
      const tempId = createRandomId();
      const handler = (serverTempId, id2, checksum) => {
        if (serverTempId === tempId) {
          this.plugin.serverSync.off("new-doc-confirmed", handler);
          this._shareId = id2;
          resolve2(checksum);
        }
      };
      this.plugin.serverSync.on("new-doc-confirmed", handler);
      this.plugin.serverSync.sendNewDocument(this, tempId);
    });
  }
  syncWithServer() {
    return new Promise((resolve2) => {
      const handler = async (id2, hash) => {
        if (id2 === this.shareId) {
          this.plugin.serverSync.off("synced", handler);
          this.plugin.log("synced " + this.path);
          resolve2(hash);
        }
      };
      this.plugin.serverSync.on("synced", handler);
      this.plugin.serverSync.sendSyncStep1(this);
      this.plugin.log("syncing " + this.path);
    });
  }
  startWebRTCSync(init) {
    this.plugin.log(`WebRTC for ${this.path}: start`);
    if (!this.shareId)
      return;
    if (this._webRTCProvider) {
      this._webRTCProvider.connect();
      return this._webRTCProvider;
    }
    const webRTCProvider = new WebrtcProvider(this._shareId, this.yDoc, { signaling: [this.plugin.settings.signaling], peerOpts: { iceServers: [{ urls: "stun:freeturn.net:5349" }, { urls: "turns:freeturn.net:5349", username: "free", credential: "free" }, { urls: "stun:stun.l.google.com:19302" }, { urls: "stun:global.stun.twilio.com:3478?transport=udp" }] } });
    this._webRTCProvider = webRTCProvider;
    if (init) {
      init(webRTCProvider);
    }
    return webRTCProvider;
  }
  stopWebRTCSync() {
    var _a, _b, _c;
    if (!this._webRTCProvider)
      return;
    this.plugin.log(`WebRTC for ${this.path}: stop`);
    (_a = this._webRTCProvider) == null ? void 0 : _a.awareness.destroy();
    (_b = this._webRTCProvider) == null ? void 0 : _b.disconnect();
    (_c = this._webRTCProvider) == null ? void 0 : _c.destroy();
    this._webRTCProvider = void 0;
  }
  async stopIndexedDBSync() {
    if (!this._indexedDBProvider)
      return;
    await this._indexedDBProvider.destroy();
  }
  destroy() {
    this.stopWebRTCSync();
  }
};
SharedEntity.DB_PERSISTENCE_PREFIX = "peerdraft_persistence_";

// src/sharedEntities/sharedDocument.ts
var path2 = __toESM(require("path"));

// node_modules/lib0/indexeddb.js
var rtop = (request) => create4((resolve2, reject2) => {
  request.onerror = (event) => reject2(new Error(event.target.error));
  request.onsuccess = (event) => resolve2(event.target.result);
});
var openDB = (name, initDB) => create4((resolve2, reject2) => {
  const request = indexedDB.open(name);
  request.onupgradeneeded = (event) => initDB(event.target.result);
  request.onerror = (event) => reject2(create3(event.target.error));
  request.onsuccess = (event) => {
    const db = event.target.result;
    db.onversionchange = () => {
      db.close();
    };
    resolve2(db);
  };
});
var deleteDB = (name) => rtop(indexedDB.deleteDatabase(name));
var createStores = (db, definitions) => definitions.forEach(
  (d) => (
    // @ts-ignore
    db.createObjectStore.apply(db, d)
  )
);
var transact2 = (db, stores, access = "readwrite") => {
  const transaction = db.transaction(stores, access);
  return stores.map((store) => getStore(transaction, store));
};
var count = (store, range) => rtop(store.count(range));
var get = (store, key) => rtop(store.get(key));
var del = (store, key) => rtop(store.delete(key));
var put = (store, item, key) => rtop(store.put(item, key));
var addAutoKey = (store, item) => rtop(store.add(item));
var getAll = (store, range, limit) => rtop(store.getAll(range, limit));
var queryFirst = (store, query, direction) => {
  let first = null;
  return iterateKeys(store, query, (key) => {
    first = key;
    return false;
  }, direction).then(() => first);
};
var getLastKey = (store, range = null) => queryFirst(store, range, "prev");
var iterateOnRequest = (request, f) => create4((resolve2, reject2) => {
  request.onerror = reject2;
  request.onsuccess = async (event) => {
    const cursor = event.target.result;
    if (cursor === null || await f(cursor) === false) {
      return resolve2();
    }
    cursor.continue();
  };
});
var iterateKeys = (store, keyrange, f, direction = "next") => iterateOnRequest(store.openKeyCursor(keyrange, direction), (cursor) => f(cursor.key));
var getStore = (t, store) => t.objectStore(store);
var createIDBKeyRangeUpperBound = (upper, upperOpen) => IDBKeyRange.upperBound(upper, upperOpen);
var createIDBKeyRangeLowerBound = (lower, lowerOpen) => IDBKeyRange.lowerBound(lower, lowerOpen);

// node_modules/y-indexeddb/src/y-indexeddb.js
var customStoreName = "custom";
var updatesStoreName = "updates";
var PREFERRED_TRIM_SIZE = 500;
var fetchUpdates = (idbPersistence, beforeApplyUpdatesCallback = () => {
}, afterApplyUpdatesCallback = () => {
}) => {
  const [updatesStore] = transact2(
    /** @type {IDBDatabase} */
    idbPersistence.db,
    [updatesStoreName]
  );
  return getAll(updatesStore, createIDBKeyRangeLowerBound(idbPersistence._dbref, false)).then((updates) => {
    if (!idbPersistence._destroyed) {
      beforeApplyUpdatesCallback(updatesStore);
      transact(idbPersistence.doc, () => {
        updates.forEach((val) => applyUpdate(idbPersistence.doc, val));
      }, idbPersistence, false);
      afterApplyUpdatesCallback(updatesStore);
    }
  }).then(() => getLastKey(updatesStore).then((lastKey) => {
    idbPersistence._dbref = lastKey + 1;
  })).then(() => count(updatesStore).then((cnt) => {
    idbPersistence._dbsize = cnt;
  })).then(() => updatesStore);
};
var storeState = (idbPersistence, forceStore = true) => fetchUpdates(idbPersistence).then((updatesStore) => {
  if (forceStore || idbPersistence._dbsize >= PREFERRED_TRIM_SIZE) {
    addAutoKey(updatesStore, encodeStateAsUpdate(idbPersistence.doc)).then(() => del(updatesStore, createIDBKeyRangeUpperBound(idbPersistence._dbref, true))).then(() => count(updatesStore).then((cnt) => {
      idbPersistence._dbsize = cnt;
    }));
  }
});
var IndexeddbPersistence = class extends Observable {
  /**
   * @param {string} name
   * @param {Y.Doc} doc
   */
  constructor(name, doc2) {
    super();
    this.doc = doc2;
    this.name = name;
    this._dbref = 0;
    this._dbsize = 0;
    this._destroyed = false;
    this.db = null;
    this.synced = false;
    this._db = openDB(
      name,
      (db) => createStores(db, [
        ["updates", { autoIncrement: true }],
        ["custom"]
      ])
    );
    this.whenSynced = create4((resolve2) => this.on("synced", () => resolve2(this)));
    this._db.then((db) => {
      this.db = db;
      const beforeApplyUpdatesCallback = (updatesStore) => addAutoKey(updatesStore, encodeStateAsUpdate(doc2));
      const afterApplyUpdatesCallback = () => {
        if (this._destroyed)
          return this;
        this.synced = true;
        this.emit("synced", [this]);
      };
      fetchUpdates(this, beforeApplyUpdatesCallback, afterApplyUpdatesCallback);
    });
    this._storeTimeout = 1e3;
    this._storeTimeoutId = null;
    this._storeUpdate = (update, origin) => {
      if (this.db && origin !== this) {
        const [updatesStore] = transact2(
          /** @type {IDBDatabase} */
          this.db,
          [updatesStoreName]
        );
        addAutoKey(updatesStore, update);
        if (++this._dbsize >= PREFERRED_TRIM_SIZE) {
          if (this._storeTimeoutId !== null) {
            clearTimeout(this._storeTimeoutId);
          }
          this._storeTimeoutId = setTimeout(() => {
            storeState(this, false);
            this._storeTimeoutId = null;
          }, this._storeTimeout);
        }
      }
    };
    doc2.on("update", this._storeUpdate);
    this.destroy = this.destroy.bind(this);
    doc2.on("destroy", this.destroy);
  }
  destroy() {
    if (this._storeTimeoutId) {
      clearTimeout(this._storeTimeoutId);
    }
    this.doc.off("update", this._storeUpdate);
    this.doc.off("destroy", this.destroy);
    this._destroyed = true;
    return this._db.then((db) => {
      db.close();
    });
  }
  /**
   * Destroys this instance and removes all data from indexeddb.
   *
   * @return {Promise<void>}
   */
  clearData() {
    return this.destroy().then(() => {
      deleteDB(this.name);
    });
  }
  /**
   * @param {String | number | ArrayBuffer | Date} key
   * @return {Promise<String | number | ArrayBuffer | Date | any>}
   */
  get(key) {
    return this._db.then((db) => {
      const [custom] = transact2(db, [customStoreName], "readonly");
      return get(custom, key);
    });
  }
  /**
   * @param {String | number | ArrayBuffer | Date} key
   * @param {String | number | ArrayBuffer | Date} value
   * @return {Promise<String | number | ArrayBuffer | Date>}
   */
  set(key, value) {
    return this._db.then((db) => {
      const [custom] = transact2(db, [customStoreName]);
      return put(custom, value, key);
    });
  }
  /**
   * @param {String | number | ArrayBuffer | Date} key
   * @return {Promise<undefined>}
   */
  del(key) {
    return this._db.then((db) => {
      const [custom] = transact2(db, [customStoreName]);
      return del(custom, key);
    });
  }
};

// src/workspace/explorerView.ts
var addIsSharedClass = (path4, plugin) => {
  const fileExplorers = plugin.app.workspace.getLeavesOfType("file-explorer");
  fileExplorers.forEach((fileExplorer) => {
    const fileItem = fileExplorer.view.fileItems[path4];
    if (!fileItem)
      return;
    const el = fileItem.innerEl;
    el.addClass("pd-explorer-shared");
  });
};
var removeIsSharedClass = (path4, plugin) => {
  const fileExplorers = plugin.app.workspace.getLeavesOfType("file-explorer");
  fileExplorers.forEach((fileExplorer) => {
    const fileItem = fileExplorer.view.fileItems[path4];
    if (!fileItem)
      return;
    const el = fileItem.innerEl;
    el.removeClass("pd-explorer-shared");
  });
};

// src/sharedEntities/sharedFolder.ts
var import_obsidian8 = require("obsidian");
var path = __toESM(require("path"));

// src/settings.ts
var import_obsidian6 = require("obsidian");

// src/subscription.ts
var import_obsidian4 = require("obsidian");
var refreshSubscriptionData = async (plugin) => {
  const settings = await getSettings(plugin);
  const url = new URL(settings.subscriptionAPI);
  url.searchParams.set("oid", settings.oid);
  const data = await (0, import_obsidian4.requestUrl)(url.toString()).json;
  if (data) {
    if (data.plan) {
      settings.plan = data.plan;
    }
    if (data.usage) {
      settings.duration = data.usage;
    }
    await saveSettings(settings, plugin);
  }
};

// src/ui/selectFolder.ts
var import_obsidian5 = require("obsidian");
var SelectFolderModal = class extends import_obsidian5.SuggestModal {
  constructor(app, cb) {
    super(app);
    this.cb = cb;
    this.folders = [];
    import_obsidian5.Vault.recurseChildren(app.vault.getRoot(), (file) => {
      if (file instanceof import_obsidian5.TFolder)
        this.folders.push(file);
    });
    this.folders.shift();
    this.folders.sort((a, b) => {
      return a.path.toLocaleLowerCase().localeCompare(b.path.toLocaleLowerCase());
    });
  }
  onOpen() {
    super.onOpen();
    this.inputEl.placeholder = "Choose a location";
  }
  getSuggestions(query) {
    return this.folders.filter((folder) => {
      return folder.path.toLocaleLowerCase().includes(query.toLocaleLowerCase());
    });
  }
  renderSuggestion(value, el) {
    el.setText(value.path);
  }
  selectSuggestion(value, evt) {
    this.selectedFolder = value;
    super.selectSuggestion(value, evt);
  }
  onChooseSuggestion(item, evt) {
  }
  onClose() {
    this.cb(this.selectedFolder);
  }
};
var promptForFolderSelection = async (app) => {
  return new Promise((resolve2) => {
    new SelectFolderModal(app, (folder) => {
      resolve2(folder);
    }).open();
  });
};

// node_modules/dexie/dist/modern/dexie.mjs
var _global = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
var keys2 = Object.keys;
var isArray2 = Array.isArray;
if (typeof Promise !== "undefined" && !_global.Promise) {
  _global.Promise = Promise;
}
function extend(obj, extension) {
  if (typeof extension !== "object")
    return obj;
  keys2(extension).forEach(function(key) {
    obj[key] = extension[key];
  });
  return obj;
}
var getProto = Object.getPrototypeOf;
var _hasOwn = {}.hasOwnProperty;
function hasOwn(obj, prop) {
  return _hasOwn.call(obj, prop);
}
function props(proto, extension) {
  if (typeof extension === "function")
    extension = extension(getProto(proto));
  (typeof Reflect === "undefined" ? keys2 : Reflect.ownKeys)(extension).forEach((key) => {
    setProp(proto, key, extension[key]);
  });
}
var defineProperty = Object.defineProperty;
function setProp(obj, prop, functionOrGetSet, options) {
  defineProperty(obj, prop, extend(functionOrGetSet && hasOwn(functionOrGetSet, "get") && typeof functionOrGetSet.get === "function" ? { get: functionOrGetSet.get, set: functionOrGetSet.set, configurable: true } : { value: functionOrGetSet, configurable: true, writable: true }, options));
}
function derive(Child) {
  return {
    from: function(Parent) {
      Child.prototype = Object.create(Parent.prototype);
      setProp(Child.prototype, "constructor", Child);
      return {
        extend: props.bind(null, Child.prototype)
      };
    }
  };
}
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
function getPropertyDescriptor(obj, prop) {
  const pd = getOwnPropertyDescriptor(obj, prop);
  let proto;
  return pd || (proto = getProto(obj)) && getPropertyDescriptor(proto, prop);
}
var _slice = [].slice;
function slice(args2, start, end) {
  return _slice.call(args2, start, end);
}
function override(origFunc, overridedFactory) {
  return overridedFactory(origFunc);
}
function assert(b) {
  if (!b)
    throw new Error("Assertion Failed");
}
function asap$1(fn) {
  if (_global.setImmediate)
    setImmediate(fn);
  else
    setTimeout(fn, 0);
}
function arrayToObject(array, extractor) {
  return array.reduce((result, item, i) => {
    var nameAndValue = extractor(item, i);
    if (nameAndValue)
      result[nameAndValue[0]] = nameAndValue[1];
    return result;
  }, {});
}
function tryCatch(fn, onerror, args2) {
  try {
    fn.apply(null, args2);
  } catch (ex) {
    onerror && onerror(ex);
  }
}
function getByKeyPath(obj, keyPath) {
  if (typeof keyPath === "string" && hasOwn(obj, keyPath))
    return obj[keyPath];
  if (!keyPath)
    return obj;
  if (typeof keyPath !== "string") {
    var rv = [];
    for (var i = 0, l = keyPath.length; i < l; ++i) {
      var val = getByKeyPath(obj, keyPath[i]);
      rv.push(val);
    }
    return rv;
  }
  var period = keyPath.indexOf(".");
  if (period !== -1) {
    var innerObj = obj[keyPath.substr(0, period)];
    return innerObj == null ? void 0 : getByKeyPath(innerObj, keyPath.substr(period + 1));
  }
  return void 0;
}
function setByKeyPath(obj, keyPath, value) {
  if (!obj || keyPath === void 0)
    return;
  if ("isFrozen" in Object && Object.isFrozen(obj))
    return;
  if (typeof keyPath !== "string" && "length" in keyPath) {
    assert(typeof value !== "string" && "length" in value);
    for (var i = 0, l = keyPath.length; i < l; ++i) {
      setByKeyPath(obj, keyPath[i], value[i]);
    }
  } else {
    var period = keyPath.indexOf(".");
    if (period !== -1) {
      var currentKeyPath = keyPath.substr(0, period);
      var remainingKeyPath = keyPath.substr(period + 1);
      if (remainingKeyPath === "")
        if (value === void 0) {
          if (isArray2(obj) && !isNaN(parseInt(currentKeyPath)))
            obj.splice(currentKeyPath, 1);
          else
            delete obj[currentKeyPath];
        } else
          obj[currentKeyPath] = value;
      else {
        var innerObj = obj[currentKeyPath];
        if (!innerObj || !hasOwn(obj, currentKeyPath))
          innerObj = obj[currentKeyPath] = {};
        setByKeyPath(innerObj, remainingKeyPath, value);
      }
    } else {
      if (value === void 0) {
        if (isArray2(obj) && !isNaN(parseInt(keyPath)))
          obj.splice(keyPath, 1);
        else
          delete obj[keyPath];
      } else
        obj[keyPath] = value;
    }
  }
}
function delByKeyPath(obj, keyPath) {
  if (typeof keyPath === "string")
    setByKeyPath(obj, keyPath, void 0);
  else if ("length" in keyPath)
    [].map.call(keyPath, function(kp) {
      setByKeyPath(obj, kp, void 0);
    });
}
function shallowClone(obj) {
  var rv = {};
  for (var m in obj) {
    if (hasOwn(obj, m))
      rv[m] = obj[m];
  }
  return rv;
}
var concat = [].concat;
function flatten(a) {
  return concat.apply([], a);
}
var intrinsicTypeNames = "BigUint64Array,BigInt64Array,Array,Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,FileSystemDirectoryHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey".split(",").concat(flatten([8, 16, 32, 64].map((num) => ["Int", "Uint", "Float"].map((t) => t + num + "Array")))).filter((t) => _global[t]);
var intrinsicTypes = intrinsicTypeNames.map((t) => _global[t]);
arrayToObject(intrinsicTypeNames, (x) => [x, true]);
var circularRefs = null;
function deepClone(any2) {
  circularRefs = typeof WeakMap !== "undefined" && /* @__PURE__ */ new WeakMap();
  const rv = innerDeepClone(any2);
  circularRefs = null;
  return rv;
}
function innerDeepClone(any2) {
  if (!any2 || typeof any2 !== "object")
    return any2;
  let rv = circularRefs && circularRefs.get(any2);
  if (rv)
    return rv;
  if (isArray2(any2)) {
    rv = [];
    circularRefs && circularRefs.set(any2, rv);
    for (var i = 0, l = any2.length; i < l; ++i) {
      rv.push(innerDeepClone(any2[i]));
    }
  } else if (intrinsicTypes.indexOf(any2.constructor) >= 0) {
    rv = any2;
  } else {
    const proto = getProto(any2);
    rv = proto === Object.prototype ? {} : Object.create(proto);
    circularRefs && circularRefs.set(any2, rv);
    for (var prop in any2) {
      if (hasOwn(any2, prop)) {
        rv[prop] = innerDeepClone(any2[prop]);
      }
    }
  }
  return rv;
}
var { toString } = {};
function toStringTag(o) {
  return toString.call(o).slice(8, -1);
}
var iteratorSymbol = typeof Symbol !== "undefined" ? Symbol.iterator : "@@iterator";
var getIteratorOf = typeof iteratorSymbol === "symbol" ? function(x) {
  var i;
  return x != null && (i = x[iteratorSymbol]) && i.apply(x);
} : function() {
  return null;
};
var NO_CHAR_ARRAY = {};
function getArrayOf(arrayLike) {
  var i, a, x, it;
  if (arguments.length === 1) {
    if (isArray2(arrayLike))
      return arrayLike.slice();
    if (this === NO_CHAR_ARRAY && typeof arrayLike === "string")
      return [arrayLike];
    if (it = getIteratorOf(arrayLike)) {
      a = [];
      while (x = it.next(), !x.done)
        a.push(x.value);
      return a;
    }
    if (arrayLike == null)
      return [arrayLike];
    i = arrayLike.length;
    if (typeof i === "number") {
      a = new Array(i);
      while (i--)
        a[i] = arrayLike[i];
      return a;
    }
    return [arrayLike];
  }
  i = arguments.length;
  a = new Array(i);
  while (i--)
    a[i] = arguments[i];
  return a;
}
var isAsyncFunction = typeof Symbol !== "undefined" ? (fn) => fn[Symbol.toStringTag] === "AsyncFunction" : () => false;
var debug = typeof location !== "undefined" && /^(http|https):\/\/(localhost|127\.0\.0\.1)/.test(location.href);
function setDebug(value, filter) {
  debug = value;
  libraryFilter = filter;
}
var libraryFilter = () => true;
var NEEDS_THROW_FOR_STACK = !new Error("").stack;
function getErrorWithStack() {
  if (NEEDS_THROW_FOR_STACK)
    try {
      getErrorWithStack.arguments;
      throw new Error();
    } catch (e) {
      return e;
    }
  return new Error();
}
function prettyStack(exception, numIgnoredFrames) {
  var stack = exception.stack;
  if (!stack)
    return "";
  numIgnoredFrames = numIgnoredFrames || 0;
  if (stack.indexOf(exception.name) === 0)
    numIgnoredFrames += (exception.name + exception.message).split("\n").length;
  return stack.split("\n").slice(numIgnoredFrames).filter(libraryFilter).map((frame) => "\n" + frame).join("");
}
var dexieErrorNames = [
  "Modify",
  "Bulk",
  "OpenFailed",
  "VersionChange",
  "Schema",
  "Upgrade",
  "InvalidTable",
  "MissingAPI",
  "NoSuchDatabase",
  "InvalidArgument",
  "SubTransaction",
  "Unsupported",
  "Internal",
  "DatabaseClosed",
  "PrematureCommit",
  "ForeignAwait"
];
var idbDomErrorNames = [
  "Unknown",
  "Constraint",
  "Data",
  "TransactionInactive",
  "ReadOnly",
  "Version",
  "NotFound",
  "InvalidState",
  "InvalidAccess",
  "Abort",
  "Timeout",
  "QuotaExceeded",
  "Syntax",
  "DataClone"
];
var errorList = dexieErrorNames.concat(idbDomErrorNames);
var defaultTexts = {
  VersionChanged: "Database version changed by other database connection",
  DatabaseClosed: "Database has been closed",
  Abort: "Transaction aborted",
  TransactionInactive: "Transaction has already completed or failed",
  MissingAPI: "IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb"
};
function DexieError(name, msg) {
  this._e = getErrorWithStack();
  this.name = name;
  this.message = msg;
}
derive(DexieError).from(Error).extend({
  stack: {
    get: function() {
      return this._stack || (this._stack = this.name + ": " + this.message + prettyStack(this._e, 2));
    }
  },
  toString: function() {
    return this.name + ": " + this.message;
  }
});
function getMultiErrorMessage(msg, failures) {
  return msg + ". Errors: " + Object.keys(failures).map((key) => failures[key].toString()).filter((v, i, s) => s.indexOf(v) === i).join("\n");
}
function ModifyError(msg, failures, successCount, failedKeys) {
  this._e = getErrorWithStack();
  this.failures = failures;
  this.failedKeys = failedKeys;
  this.successCount = successCount;
  this.message = getMultiErrorMessage(msg, failures);
}
derive(ModifyError).from(DexieError);
function BulkError(msg, failures) {
  this._e = getErrorWithStack();
  this.name = "BulkError";
  this.failures = Object.keys(failures).map((pos) => failures[pos]);
  this.failuresByPos = failures;
  this.message = getMultiErrorMessage(msg, failures);
}
derive(BulkError).from(DexieError);
var errnames = errorList.reduce((obj, name) => (obj[name] = name + "Error", obj), {});
var BaseException = DexieError;
var exceptions = errorList.reduce((obj, name) => {
  var fullName = name + "Error";
  function DexieError2(msgOrInner, inner) {
    this._e = getErrorWithStack();
    this.name = fullName;
    if (!msgOrInner) {
      this.message = defaultTexts[name] || fullName;
      this.inner = null;
    } else if (typeof msgOrInner === "string") {
      this.message = `${msgOrInner}${!inner ? "" : "\n " + inner}`;
      this.inner = inner || null;
    } else if (typeof msgOrInner === "object") {
      this.message = `${msgOrInner.name} ${msgOrInner.message}`;
      this.inner = msgOrInner;
    }
  }
  derive(DexieError2).from(BaseException);
  obj[name] = DexieError2;
  return obj;
}, {});
exceptions.Syntax = SyntaxError;
exceptions.Type = TypeError;
exceptions.Range = RangeError;
var exceptionMap = idbDomErrorNames.reduce((obj, name) => {
  obj[name + "Error"] = exceptions[name];
  return obj;
}, {});
function mapError(domError, message) {
  if (!domError || domError instanceof DexieError || domError instanceof TypeError || domError instanceof SyntaxError || !domError.name || !exceptionMap[domError.name])
    return domError;
  var rv = new exceptionMap[domError.name](message || domError.message, domError);
  if ("stack" in domError) {
    setProp(rv, "stack", { get: function() {
      return this.inner.stack;
    } });
  }
  return rv;
}
var fullNameExceptions = errorList.reduce((obj, name) => {
  if (["Syntax", "Type", "Range"].indexOf(name) === -1)
    obj[name + "Error"] = exceptions[name];
  return obj;
}, {});
fullNameExceptions.ModifyError = ModifyError;
fullNameExceptions.DexieError = DexieError;
fullNameExceptions.BulkError = BulkError;
function nop2() {
}
function mirror(val) {
  return val;
}
function pureFunctionChain(f1, f2) {
  if (f1 == null || f1 === mirror)
    return f2;
  return function(val) {
    return f2(f1(val));
  };
}
function callBoth(on1, on2) {
  return function() {
    on1.apply(this, arguments);
    on2.apply(this, arguments);
  };
}
function hookCreatingChain(f1, f2) {
  if (f1 === nop2)
    return f2;
  return function() {
    var res = f1.apply(this, arguments);
    if (res !== void 0)
      arguments[0] = res;
    var onsuccess = this.onsuccess, onerror = this.onerror;
    this.onsuccess = null;
    this.onerror = null;
    var res2 = f2.apply(this, arguments);
    if (onsuccess)
      this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;
    if (onerror)
      this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;
    return res2 !== void 0 ? res2 : res;
  };
}
function hookDeletingChain(f1, f2) {
  if (f1 === nop2)
    return f2;
  return function() {
    f1.apply(this, arguments);
    var onsuccess = this.onsuccess, onerror = this.onerror;
    this.onsuccess = this.onerror = null;
    f2.apply(this, arguments);
    if (onsuccess)
      this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;
    if (onerror)
      this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;
  };
}
function hookUpdatingChain(f1, f2) {
  if (f1 === nop2)
    return f2;
  return function(modifications) {
    var res = f1.apply(this, arguments);
    extend(modifications, res);
    var onsuccess = this.onsuccess, onerror = this.onerror;
    this.onsuccess = null;
    this.onerror = null;
    var res2 = f2.apply(this, arguments);
    if (onsuccess)
      this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;
    if (onerror)
      this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;
    return res === void 0 ? res2 === void 0 ? void 0 : res2 : extend(res, res2);
  };
}
function reverseStoppableEventChain(f1, f2) {
  if (f1 === nop2)
    return f2;
  return function() {
    if (f2.apply(this, arguments) === false)
      return false;
    return f1.apply(this, arguments);
  };
}
function promisableChain(f1, f2) {
  if (f1 === nop2)
    return f2;
  return function() {
    var res = f1.apply(this, arguments);
    if (res && typeof res.then === "function") {
      var thiz = this, i = arguments.length, args2 = new Array(i);
      while (i--)
        args2[i] = arguments[i];
      return res.then(function() {
        return f2.apply(thiz, args2);
      });
    }
    return f2.apply(this, arguments);
  };
}
var INTERNAL = {};
var LONG_STACKS_CLIP_LIMIT = 100;
var MAX_LONG_STACKS = 20;
var ZONE_ECHO_LIMIT = 100;
var [resolvedNativePromise, nativePromiseProto, resolvedGlobalPromise] = typeof Promise === "undefined" ? [] : (() => {
  let globalP = Promise.resolve();
  if (typeof crypto === "undefined" || !crypto.subtle)
    return [globalP, getProto(globalP), globalP];
  const nativeP = crypto.subtle.digest("SHA-512", new Uint8Array([0]));
  return [
    nativeP,
    getProto(nativeP),
    globalP
  ];
})();
var nativePromiseThen = nativePromiseProto && nativePromiseProto.then;
var NativePromise = resolvedNativePromise && resolvedNativePromise.constructor;
var patchGlobalPromise = !!resolvedGlobalPromise;
var stack_being_generated = false;
var schedulePhysicalTick = resolvedGlobalPromise ? () => {
  resolvedGlobalPromise.then(physicalTick);
} : _global.setImmediate ? setImmediate.bind(null, physicalTick) : _global.MutationObserver ? () => {
  var hiddenDiv = document.createElement("div");
  new MutationObserver(() => {
    physicalTick();
    hiddenDiv = null;
  }).observe(hiddenDiv, { attributes: true });
  hiddenDiv.setAttribute("i", "1");
} : () => {
  setTimeout(physicalTick, 0);
};
var asap = function(callback, args2) {
  microtickQueue.push([callback, args2]);
  if (needsNewPhysicalTick) {
    schedulePhysicalTick();
    needsNewPhysicalTick = false;
  }
};
var isOutsideMicroTick = true;
var needsNewPhysicalTick = true;
var unhandledErrors = [];
var rejectingErrors = [];
var currentFulfiller = null;
var rejectionMapper = mirror;
var globalPSD = {
  id: "global",
  global: true,
  ref: 0,
  unhandleds: [],
  onunhandled: globalError,
  pgp: false,
  env: {},
  finalize: function() {
    this.unhandleds.forEach((uh) => {
      try {
        globalError(uh[0], uh[1]);
      } catch (e) {
      }
    });
  }
};
var PSD = globalPSD;
var microtickQueue = [];
var numScheduledCalls = 0;
var tickFinalizers = [];
function DexiePromise(fn) {
  if (typeof this !== "object")
    throw new TypeError("Promises must be constructed via new");
  this._listeners = [];
  this.onuncatched = nop2;
  this._lib = false;
  var psd = this._PSD = PSD;
  if (debug) {
    this._stackHolder = getErrorWithStack();
    this._prev = null;
    this._numPrev = 0;
  }
  if (typeof fn !== "function") {
    if (fn !== INTERNAL)
      throw new TypeError("Not a function");
    this._state = arguments[1];
    this._value = arguments[2];
    if (this._state === false)
      handleRejection(this, this._value);
    return;
  }
  this._state = null;
  this._value = null;
  ++psd.ref;
  executePromiseTask(this, fn);
}
var thenProp = {
  get: function() {
    var psd = PSD, microTaskId = totalEchoes;
    function then(onFulfilled, onRejected) {
      var possibleAwait = !psd.global && (psd !== PSD || microTaskId !== totalEchoes);
      const cleanup = possibleAwait && !decrementExpectedAwaits();
      var rv = new DexiePromise((resolve2, reject2) => {
        propagateToListener(this, new Listener(nativeAwaitCompatibleWrap(onFulfilled, psd, possibleAwait, cleanup), nativeAwaitCompatibleWrap(onRejected, psd, possibleAwait, cleanup), resolve2, reject2, psd));
      });
      debug && linkToPreviousPromise(rv, this);
      return rv;
    }
    then.prototype = INTERNAL;
    return then;
  },
  set: function(value) {
    setProp(this, "then", value && value.prototype === INTERNAL ? thenProp : {
      get: function() {
        return value;
      },
      set: thenProp.set
    });
  }
};
props(DexiePromise.prototype, {
  then: thenProp,
  _then: function(onFulfilled, onRejected) {
    propagateToListener(this, new Listener(null, null, onFulfilled, onRejected, PSD));
  },
  catch: function(onRejected) {
    if (arguments.length === 1)
      return this.then(null, onRejected);
    var type2 = arguments[0], handler = arguments[1];
    return typeof type2 === "function" ? this.then(null, (err) => err instanceof type2 ? handler(err) : PromiseReject(err)) : this.then(null, (err) => err && err.name === type2 ? handler(err) : PromiseReject(err));
  },
  finally: function(onFinally) {
    return this.then((value) => {
      onFinally();
      return value;
    }, (err) => {
      onFinally();
      return PromiseReject(err);
    });
  },
  stack: {
    get: function() {
      if (this._stack)
        return this._stack;
      try {
        stack_being_generated = true;
        var stacks = getStack(this, [], MAX_LONG_STACKS);
        var stack = stacks.join("\nFrom previous: ");
        if (this._state !== null)
          this._stack = stack;
        return stack;
      } finally {
        stack_being_generated = false;
      }
    }
  },
  timeout: function(ms, msg) {
    return ms < Infinity ? new DexiePromise((resolve2, reject2) => {
      var handle = setTimeout(() => reject2(new exceptions.Timeout(msg)), ms);
      this.then(resolve2, reject2).finally(clearTimeout.bind(null, handle));
    }) : this;
  }
});
if (typeof Symbol !== "undefined" && Symbol.toStringTag)
  setProp(DexiePromise.prototype, Symbol.toStringTag, "Dexie.Promise");
globalPSD.env = snapShot();
function Listener(onFulfilled, onRejected, resolve2, reject2, zone) {
  this.onFulfilled = typeof onFulfilled === "function" ? onFulfilled : null;
  this.onRejected = typeof onRejected === "function" ? onRejected : null;
  this.resolve = resolve2;
  this.reject = reject2;
  this.psd = zone;
}
props(DexiePromise, {
  all: function() {
    var values = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);
    return new DexiePromise(function(resolve2, reject2) {
      if (values.length === 0)
        resolve2([]);
      var remaining = values.length;
      values.forEach((a, i) => DexiePromise.resolve(a).then((x) => {
        values[i] = x;
        if (!--remaining)
          resolve2(values);
      }, reject2));
    });
  },
  resolve: (value) => {
    if (value instanceof DexiePromise)
      return value;
    if (value && typeof value.then === "function")
      return new DexiePromise((resolve2, reject2) => {
        value.then(resolve2, reject2);
      });
    var rv = new DexiePromise(INTERNAL, true, value);
    linkToPreviousPromise(rv, currentFulfiller);
    return rv;
  },
  reject: PromiseReject,
  race: function() {
    var values = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);
    return new DexiePromise((resolve2, reject2) => {
      values.map((value) => DexiePromise.resolve(value).then(resolve2, reject2));
    });
  },
  PSD: {
    get: () => PSD,
    set: (value) => PSD = value
  },
  totalEchoes: { get: () => totalEchoes },
  newPSD: newScope,
  usePSD,
  scheduler: {
    get: () => asap,
    set: (value) => {
      asap = value;
    }
  },
  rejectionMapper: {
    get: () => rejectionMapper,
    set: (value) => {
      rejectionMapper = value;
    }
  },
  follow: (fn, zoneProps) => {
    return new DexiePromise((resolve2, reject2) => {
      return newScope((resolve3, reject3) => {
        var psd = PSD;
        psd.unhandleds = [];
        psd.onunhandled = reject3;
        psd.finalize = callBoth(function() {
          run_at_end_of_this_or_next_physical_tick(() => {
            this.unhandleds.length === 0 ? resolve3() : reject3(this.unhandleds[0]);
          });
        }, psd.finalize);
        fn();
      }, zoneProps, resolve2, reject2);
    });
  }
});
if (NativePromise) {
  if (NativePromise.allSettled)
    setProp(DexiePromise, "allSettled", function() {
      const possiblePromises = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);
      return new DexiePromise((resolve2) => {
        if (possiblePromises.length === 0)
          resolve2([]);
        let remaining = possiblePromises.length;
        const results = new Array(remaining);
        possiblePromises.forEach((p, i) => DexiePromise.resolve(p).then((value) => results[i] = { status: "fulfilled", value }, (reason) => results[i] = { status: "rejected", reason }).then(() => --remaining || resolve2(results)));
      });
    });
  if (NativePromise.any && typeof AggregateError !== "undefined")
    setProp(DexiePromise, "any", function() {
      const possiblePromises = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);
      return new DexiePromise((resolve2, reject2) => {
        if (possiblePromises.length === 0)
          reject2(new AggregateError([]));
        let remaining = possiblePromises.length;
        const failures = new Array(remaining);
        possiblePromises.forEach((p, i) => DexiePromise.resolve(p).then((value) => resolve2(value), (failure) => {
          failures[i] = failure;
          if (!--remaining)
            reject2(new AggregateError(failures));
        }));
      });
    });
}
function executePromiseTask(promise, fn) {
  try {
    fn((value) => {
      if (promise._state !== null)
        return;
      if (value === promise)
        throw new TypeError("A promise cannot be resolved with itself.");
      var shouldExecuteTick = promise._lib && beginMicroTickScope();
      if (value && typeof value.then === "function") {
        executePromiseTask(promise, (resolve2, reject2) => {
          value instanceof DexiePromise ? value._then(resolve2, reject2) : value.then(resolve2, reject2);
        });
      } else {
        promise._state = true;
        promise._value = value;
        propagateAllListeners(promise);
      }
      if (shouldExecuteTick)
        endMicroTickScope();
    }, handleRejection.bind(null, promise));
  } catch (ex) {
    handleRejection(promise, ex);
  }
}
function handleRejection(promise, reason) {
  rejectingErrors.push(reason);
  if (promise._state !== null)
    return;
  var shouldExecuteTick = promise._lib && beginMicroTickScope();
  reason = rejectionMapper(reason);
  promise._state = false;
  promise._value = reason;
  debug && reason !== null && typeof reason === "object" && !reason._promise && tryCatch(() => {
    var origProp = getPropertyDescriptor(reason, "stack");
    reason._promise = promise;
    setProp(reason, "stack", {
      get: () => stack_being_generated ? origProp && (origProp.get ? origProp.get.apply(reason) : origProp.value) : promise.stack
    });
  });
  addPossiblyUnhandledError(promise);
  propagateAllListeners(promise);
  if (shouldExecuteTick)
    endMicroTickScope();
}
function propagateAllListeners(promise) {
  var listeners = promise._listeners;
  promise._listeners = [];
  for (var i = 0, len = listeners.length; i < len; ++i) {
    propagateToListener(promise, listeners[i]);
  }
  var psd = promise._PSD;
  --psd.ref || psd.finalize();
  if (numScheduledCalls === 0) {
    ++numScheduledCalls;
    asap(() => {
      if (--numScheduledCalls === 0)
        finalizePhysicalTick();
    }, []);
  }
}
function propagateToListener(promise, listener) {
  if (promise._state === null) {
    promise._listeners.push(listener);
    return;
  }
  var cb = promise._state ? listener.onFulfilled : listener.onRejected;
  if (cb === null) {
    return (promise._state ? listener.resolve : listener.reject)(promise._value);
  }
  ++listener.psd.ref;
  ++numScheduledCalls;
  asap(callListener, [cb, promise, listener]);
}
function callListener(cb, promise, listener) {
  try {
    currentFulfiller = promise;
    var ret, value = promise._value;
    if (promise._state) {
      ret = cb(value);
    } else {
      if (rejectingErrors.length)
        rejectingErrors = [];
      ret = cb(value);
      if (rejectingErrors.indexOf(value) === -1)
        markErrorAsHandled(promise);
    }
    listener.resolve(ret);
  } catch (e) {
    listener.reject(e);
  } finally {
    currentFulfiller = null;
    if (--numScheduledCalls === 0)
      finalizePhysicalTick();
    --listener.psd.ref || listener.psd.finalize();
  }
}
function getStack(promise, stacks, limit) {
  if (stacks.length === limit)
    return stacks;
  var stack = "";
  if (promise._state === false) {
    var failure = promise._value, errorName, message;
    if (failure != null) {
      errorName = failure.name || "Error";
      message = failure.message || failure;
      stack = prettyStack(failure, 0);
    } else {
      errorName = failure;
      message = "";
    }
    stacks.push(errorName + (message ? ": " + message : "") + stack);
  }
  if (debug) {
    stack = prettyStack(promise._stackHolder, 2);
    if (stack && stacks.indexOf(stack) === -1)
      stacks.push(stack);
    if (promise._prev)
      getStack(promise._prev, stacks, limit);
  }
  return stacks;
}
function linkToPreviousPromise(promise, prev) {
  var numPrev = prev ? prev._numPrev + 1 : 0;
  if (numPrev < LONG_STACKS_CLIP_LIMIT) {
    promise._prev = prev;
    promise._numPrev = numPrev;
  }
}
function physicalTick() {
  beginMicroTickScope() && endMicroTickScope();
}
function beginMicroTickScope() {
  var wasRootExec = isOutsideMicroTick;
  isOutsideMicroTick = false;
  needsNewPhysicalTick = false;
  return wasRootExec;
}
function endMicroTickScope() {
  var callbacks, i, l;
  do {
    while (microtickQueue.length > 0) {
      callbacks = microtickQueue;
      microtickQueue = [];
      l = callbacks.length;
      for (i = 0; i < l; ++i) {
        var item = callbacks[i];
        item[0].apply(null, item[1]);
      }
    }
  } while (microtickQueue.length > 0);
  isOutsideMicroTick = true;
  needsNewPhysicalTick = true;
}
function finalizePhysicalTick() {
  var unhandledErrs = unhandledErrors;
  unhandledErrors = [];
  unhandledErrs.forEach((p) => {
    p._PSD.onunhandled.call(null, p._value, p);
  });
  var finalizers = tickFinalizers.slice(0);
  var i = finalizers.length;
  while (i)
    finalizers[--i]();
}
function run_at_end_of_this_or_next_physical_tick(fn) {
  function finalizer() {
    fn();
    tickFinalizers.splice(tickFinalizers.indexOf(finalizer), 1);
  }
  tickFinalizers.push(finalizer);
  ++numScheduledCalls;
  asap(() => {
    if (--numScheduledCalls === 0)
      finalizePhysicalTick();
  }, []);
}
function addPossiblyUnhandledError(promise) {
  if (!unhandledErrors.some((p) => p._value === promise._value))
    unhandledErrors.push(promise);
}
function markErrorAsHandled(promise) {
  var i = unhandledErrors.length;
  while (i)
    if (unhandledErrors[--i]._value === promise._value) {
      unhandledErrors.splice(i, 1);
      return;
    }
}
function PromiseReject(reason) {
  return new DexiePromise(INTERNAL, false, reason);
}
function wrap(fn, errorCatcher) {
  var psd = PSD;
  return function() {
    var wasRootExec = beginMicroTickScope(), outerScope = PSD;
    try {
      switchToZone(psd, true);
      return fn.apply(this, arguments);
    } catch (e) {
      errorCatcher && errorCatcher(e);
    } finally {
      switchToZone(outerScope, false);
      if (wasRootExec)
        endMicroTickScope();
    }
  };
}
var task = { awaits: 0, echoes: 0, id: 0 };
var taskCounter = 0;
var zoneStack = [];
var zoneEchoes = 0;
var totalEchoes = 0;
var zone_id_counter = 0;
function newScope(fn, props2, a1, a2) {
  var parent = PSD, psd = Object.create(parent);
  psd.parent = parent;
  psd.ref = 0;
  psd.global = false;
  psd.id = ++zone_id_counter;
  var globalEnv = globalPSD.env;
  psd.env = patchGlobalPromise ? {
    Promise: DexiePromise,
    PromiseProp: { value: DexiePromise, configurable: true, writable: true },
    all: DexiePromise.all,
    race: DexiePromise.race,
    allSettled: DexiePromise.allSettled,
    any: DexiePromise.any,
    resolve: DexiePromise.resolve,
    reject: DexiePromise.reject,
    nthen: getPatchedPromiseThen(globalEnv.nthen, psd),
    gthen: getPatchedPromiseThen(globalEnv.gthen, psd)
  } : {};
  if (props2)
    extend(psd, props2);
  ++parent.ref;
  psd.finalize = function() {
    --this.parent.ref || this.parent.finalize();
  };
  var rv = usePSD(psd, fn, a1, a2);
  if (psd.ref === 0)
    psd.finalize();
  return rv;
}
function incrementExpectedAwaits() {
  if (!task.id)
    task.id = ++taskCounter;
  ++task.awaits;
  task.echoes += ZONE_ECHO_LIMIT;
  return task.id;
}
function decrementExpectedAwaits() {
  if (!task.awaits)
    return false;
  if (--task.awaits === 0)
    task.id = 0;
  task.echoes = task.awaits * ZONE_ECHO_LIMIT;
  return true;
}
if (("" + nativePromiseThen).indexOf("[native code]") === -1) {
  incrementExpectedAwaits = decrementExpectedAwaits = nop2;
}
function onPossibleParallellAsync(possiblePromise) {
  if (task.echoes && possiblePromise && possiblePromise.constructor === NativePromise) {
    incrementExpectedAwaits();
    return possiblePromise.then((x) => {
      decrementExpectedAwaits();
      return x;
    }, (e) => {
      decrementExpectedAwaits();
      return rejection(e);
    });
  }
  return possiblePromise;
}
function zoneEnterEcho(targetZone) {
  ++totalEchoes;
  if (!task.echoes || --task.echoes === 0) {
    task.echoes = task.id = 0;
  }
  zoneStack.push(PSD);
  switchToZone(targetZone, true);
}
function zoneLeaveEcho() {
  var zone = zoneStack[zoneStack.length - 1];
  zoneStack.pop();
  switchToZone(zone, false);
}
function switchToZone(targetZone, bEnteringZone) {
  var currentZone = PSD;
  if (bEnteringZone ? task.echoes && (!zoneEchoes++ || targetZone !== PSD) : zoneEchoes && (!--zoneEchoes || targetZone !== PSD)) {
    enqueueNativeMicroTask(bEnteringZone ? zoneEnterEcho.bind(null, targetZone) : zoneLeaveEcho);
  }
  if (targetZone === PSD)
    return;
  PSD = targetZone;
  if (currentZone === globalPSD)
    globalPSD.env = snapShot();
  if (patchGlobalPromise) {
    var GlobalPromise = globalPSD.env.Promise;
    var targetEnv = targetZone.env;
    nativePromiseProto.then = targetEnv.nthen;
    GlobalPromise.prototype.then = targetEnv.gthen;
    if (currentZone.global || targetZone.global) {
      Object.defineProperty(_global, "Promise", targetEnv.PromiseProp);
      GlobalPromise.all = targetEnv.all;
      GlobalPromise.race = targetEnv.race;
      GlobalPromise.resolve = targetEnv.resolve;
      GlobalPromise.reject = targetEnv.reject;
      if (targetEnv.allSettled)
        GlobalPromise.allSettled = targetEnv.allSettled;
      if (targetEnv.any)
        GlobalPromise.any = targetEnv.any;
    }
  }
}
function snapShot() {
  var GlobalPromise = _global.Promise;
  return patchGlobalPromise ? {
    Promise: GlobalPromise,
    PromiseProp: Object.getOwnPropertyDescriptor(_global, "Promise"),
    all: GlobalPromise.all,
    race: GlobalPromise.race,
    allSettled: GlobalPromise.allSettled,
    any: GlobalPromise.any,
    resolve: GlobalPromise.resolve,
    reject: GlobalPromise.reject,
    nthen: nativePromiseProto.then,
    gthen: GlobalPromise.prototype.then
  } : {};
}
function usePSD(psd, fn, a1, a2, a3) {
  var outerScope = PSD;
  try {
    switchToZone(psd, true);
    return fn(a1, a2, a3);
  } finally {
    switchToZone(outerScope, false);
  }
}
function enqueueNativeMicroTask(job) {
  nativePromiseThen.call(resolvedNativePromise, job);
}
function nativeAwaitCompatibleWrap(fn, zone, possibleAwait, cleanup) {
  return typeof fn !== "function" ? fn : function() {
    var outerZone = PSD;
    if (possibleAwait)
      incrementExpectedAwaits();
    switchToZone(zone, true);
    try {
      return fn.apply(this, arguments);
    } finally {
      switchToZone(outerZone, false);
      if (cleanup)
        enqueueNativeMicroTask(decrementExpectedAwaits);
    }
  };
}
function getPatchedPromiseThen(origThen, zone) {
  return function(onResolved, onRejected) {
    return origThen.call(this, nativeAwaitCompatibleWrap(onResolved, zone), nativeAwaitCompatibleWrap(onRejected, zone));
  };
}
var UNHANDLEDREJECTION = "unhandledrejection";
function globalError(err, promise) {
  var rv;
  try {
    rv = promise.onuncatched(err);
  } catch (e) {
  }
  if (rv !== false)
    try {
      var event, eventData = { promise, reason: err };
      if (_global.document && document.createEvent) {
        event = document.createEvent("Event");
        event.initEvent(UNHANDLEDREJECTION, true, true);
        extend(event, eventData);
      } else if (_global.CustomEvent) {
        event = new CustomEvent(UNHANDLEDREJECTION, { detail: eventData });
        extend(event, eventData);
      }
      if (event && _global.dispatchEvent) {
        dispatchEvent(event);
        if (!_global.PromiseRejectionEvent && _global.onunhandledrejection)
          try {
            _global.onunhandledrejection(event);
          } catch (_) {
          }
      }
      if (debug && event && !event.defaultPrevented) {
        console.warn(`Unhandled rejection: ${err.stack || err}`);
      }
    } catch (e) {
    }
}
var rejection = DexiePromise.reject;
function tempTransaction(db, mode, storeNames, fn) {
  if (!db.idbdb || !db._state.openComplete && (!PSD.letThrough && !db._vip)) {
    if (db._state.openComplete) {
      return rejection(new exceptions.DatabaseClosed(db._state.dbOpenError));
    }
    if (!db._state.isBeingOpened) {
      if (!db._options.autoOpen)
        return rejection(new exceptions.DatabaseClosed());
      db.open().catch(nop2);
    }
    return db._state.dbReadyPromise.then(() => tempTransaction(db, mode, storeNames, fn));
  } else {
    var trans = db._createTransaction(mode, storeNames, db._dbSchema);
    try {
      trans.create();
      db._state.PR1398_maxLoop = 3;
    } catch (ex) {
      if (ex.name === errnames.InvalidState && db.isOpen() && --db._state.PR1398_maxLoop > 0) {
        console.warn("Dexie: Need to reopen db");
        db._close();
        return db.open().then(() => tempTransaction(db, mode, storeNames, fn));
      }
      return rejection(ex);
    }
    return trans._promise(mode, (resolve2, reject2) => {
      return newScope(() => {
        PSD.trans = trans;
        return fn(resolve2, reject2, trans);
      });
    }).then((result) => {
      return trans._completion.then(() => result);
    });
  }
}
var DEXIE_VERSION = "3.2.6";
var maxString = String.fromCharCode(65535);
var minKey = -Infinity;
var INVALID_KEY_ARGUMENT = "Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.";
var STRING_EXPECTED = "String expected.";
var connections = [];
var isIEOrEdge = typeof navigator !== "undefined" && /(MSIE|Trident|Edge)/.test(navigator.userAgent);
var hasIEDeleteObjectStoreBug = isIEOrEdge;
var hangsOnDeleteLargeKeyRange = isIEOrEdge;
var dexieStackFrameFilter = (frame) => !/(dexie\.js|dexie\.min\.js)/.test(frame);
var DBNAMES_DB = "__dbnames";
var READONLY = "readonly";
var READWRITE = "readwrite";
function combine(filter1, filter2) {
  return filter1 ? filter2 ? function() {
    return filter1.apply(this, arguments) && filter2.apply(this, arguments);
  } : filter1 : filter2;
}
var AnyRange = {
  type: 3,
  lower: -Infinity,
  lowerOpen: false,
  upper: [[]],
  upperOpen: false
};
function workaroundForUndefinedPrimKey(keyPath) {
  return typeof keyPath === "string" && !/\./.test(keyPath) ? (obj) => {
    if (obj[keyPath] === void 0 && keyPath in obj) {
      obj = deepClone(obj);
      delete obj[keyPath];
    }
    return obj;
  } : (obj) => obj;
}
var Table = class {
  _trans(mode, fn, writeLocked) {
    const trans = this._tx || PSD.trans;
    const tableName = this.name;
    function checkTableInTransaction(resolve2, reject2, trans2) {
      if (!trans2.schema[tableName])
        throw new exceptions.NotFound("Table " + tableName + " not part of transaction");
      return fn(trans2.idbtrans, trans2);
    }
    const wasRootExec = beginMicroTickScope();
    try {
      return trans && trans.db === this.db ? trans === PSD.trans ? trans._promise(mode, checkTableInTransaction, writeLocked) : newScope(() => trans._promise(mode, checkTableInTransaction, writeLocked), { trans, transless: PSD.transless || PSD }) : tempTransaction(this.db, mode, [this.name], checkTableInTransaction);
    } finally {
      if (wasRootExec)
        endMicroTickScope();
    }
  }
  get(keyOrCrit, cb) {
    if (keyOrCrit && keyOrCrit.constructor === Object)
      return this.where(keyOrCrit).first(cb);
    return this._trans("readonly", (trans) => {
      return this.core.get({ trans, key: keyOrCrit }).then((res) => this.hook.reading.fire(res));
    }).then(cb);
  }
  where(indexOrCrit) {
    if (typeof indexOrCrit === "string")
      return new this.db.WhereClause(this, indexOrCrit);
    if (isArray2(indexOrCrit))
      return new this.db.WhereClause(this, `[${indexOrCrit.join("+")}]`);
    const keyPaths = keys2(indexOrCrit);
    if (keyPaths.length === 1)
      return this.where(keyPaths[0]).equals(indexOrCrit[keyPaths[0]]);
    const compoundIndex = this.schema.indexes.concat(this.schema.primKey).filter((ix) => {
      if (ix.compound && keyPaths.every((keyPath) => ix.keyPath.indexOf(keyPath) >= 0)) {
        for (let i = 0; i < keyPaths.length; ++i) {
          if (keyPaths.indexOf(ix.keyPath[i]) === -1)
            return false;
        }
        return true;
      }
      return false;
    }).sort((a, b) => a.keyPath.length - b.keyPath.length)[0];
    if (compoundIndex && this.db._maxKey !== maxString) {
      const keyPathsInValidOrder = compoundIndex.keyPath.slice(0, keyPaths.length);
      return this.where(keyPathsInValidOrder).equals(keyPathsInValidOrder.map((kp) => indexOrCrit[kp]));
    }
    if (!compoundIndex && debug)
      console.warn(`The query ${JSON.stringify(indexOrCrit)} on ${this.name} would benefit of a compound index [${keyPaths.join("+")}]`);
    const { idxByName } = this.schema;
    const idb = this.db._deps.indexedDB;
    function equals(a, b) {
      try {
        return idb.cmp(a, b) === 0;
      } catch (e) {
        return false;
      }
    }
    const [idx, filterFunction] = keyPaths.reduce(([prevIndex, prevFilterFn], keyPath) => {
      const index = idxByName[keyPath];
      const value = indexOrCrit[keyPath];
      return [
        prevIndex || index,
        prevIndex || !index ? combine(prevFilterFn, index && index.multi ? (x) => {
          const prop = getByKeyPath(x, keyPath);
          return isArray2(prop) && prop.some((item) => equals(value, item));
        } : (x) => equals(value, getByKeyPath(x, keyPath))) : prevFilterFn
      ];
    }, [null, null]);
    return idx ? this.where(idx.name).equals(indexOrCrit[idx.keyPath]).filter(filterFunction) : compoundIndex ? this.filter(filterFunction) : this.where(keyPaths).equals("");
  }
  filter(filterFunction) {
    return this.toCollection().and(filterFunction);
  }
  count(thenShortcut) {
    return this.toCollection().count(thenShortcut);
  }
  offset(offset) {
    return this.toCollection().offset(offset);
  }
  limit(numRows) {
    return this.toCollection().limit(numRows);
  }
  each(callback) {
    return this.toCollection().each(callback);
  }
  toArray(thenShortcut) {
    return this.toCollection().toArray(thenShortcut);
  }
  toCollection() {
    return new this.db.Collection(new this.db.WhereClause(this));
  }
  orderBy(index) {
    return new this.db.Collection(new this.db.WhereClause(this, isArray2(index) ? `[${index.join("+")}]` : index));
  }
  reverse() {
    return this.toCollection().reverse();
  }
  mapToClass(constructor) {
    this.schema.mappedClass = constructor;
    const readHook = (obj) => {
      if (!obj)
        return obj;
      const res = Object.create(constructor.prototype);
      for (var m in obj)
        if (hasOwn(obj, m))
          try {
            res[m] = obj[m];
          } catch (_) {
          }
      return res;
    };
    if (this.schema.readHook) {
      this.hook.reading.unsubscribe(this.schema.readHook);
    }
    this.schema.readHook = readHook;
    this.hook("reading", readHook);
    return constructor;
  }
  defineClass() {
    function Class(content) {
      extend(this, content);
    }
    return this.mapToClass(Class);
  }
  add(obj, key) {
    const { auto, keyPath } = this.schema.primKey;
    let objToAdd = obj;
    if (keyPath && auto) {
      objToAdd = workaroundForUndefinedPrimKey(keyPath)(obj);
    }
    return this._trans("readwrite", (trans) => {
      return this.core.mutate({ trans, type: "add", keys: key != null ? [key] : null, values: [objToAdd] });
    }).then((res) => res.numFailures ? DexiePromise.reject(res.failures[0]) : res.lastResult).then((lastResult) => {
      if (keyPath) {
        try {
          setByKeyPath(obj, keyPath, lastResult);
        } catch (_) {
        }
      }
      return lastResult;
    });
  }
  update(keyOrObject, modifications) {
    if (typeof keyOrObject === "object" && !isArray2(keyOrObject)) {
      const key = getByKeyPath(keyOrObject, this.schema.primKey.keyPath);
      if (key === void 0)
        return rejection(new exceptions.InvalidArgument("Given object does not contain its primary key"));
      try {
        if (typeof modifications !== "function") {
          keys2(modifications).forEach((keyPath) => {
            setByKeyPath(keyOrObject, keyPath, modifications[keyPath]);
          });
        } else {
          modifications(keyOrObject, { value: keyOrObject, primKey: key });
        }
      } catch (_a) {
      }
      return this.where(":id").equals(key).modify(modifications);
    } else {
      return this.where(":id").equals(keyOrObject).modify(modifications);
    }
  }
  put(obj, key) {
    const { auto, keyPath } = this.schema.primKey;
    let objToAdd = obj;
    if (keyPath && auto) {
      objToAdd = workaroundForUndefinedPrimKey(keyPath)(obj);
    }
    return this._trans("readwrite", (trans) => this.core.mutate({ trans, type: "put", values: [objToAdd], keys: key != null ? [key] : null })).then((res) => res.numFailures ? DexiePromise.reject(res.failures[0]) : res.lastResult).then((lastResult) => {
      if (keyPath) {
        try {
          setByKeyPath(obj, keyPath, lastResult);
        } catch (_) {
        }
      }
      return lastResult;
    });
  }
  delete(key) {
    return this._trans("readwrite", (trans) => this.core.mutate({ trans, type: "delete", keys: [key] })).then((res) => res.numFailures ? DexiePromise.reject(res.failures[0]) : void 0);
  }
  clear() {
    return this._trans("readwrite", (trans) => this.core.mutate({ trans, type: "deleteRange", range: AnyRange })).then((res) => res.numFailures ? DexiePromise.reject(res.failures[0]) : void 0);
  }
  bulkGet(keys3) {
    return this._trans("readonly", (trans) => {
      return this.core.getMany({
        keys: keys3,
        trans
      }).then((result) => result.map((res) => this.hook.reading.fire(res)));
    });
  }
  bulkAdd(objects, keysOrOptions, options) {
    const keys3 = Array.isArray(keysOrOptions) ? keysOrOptions : void 0;
    options = options || (keys3 ? void 0 : keysOrOptions);
    const wantResults = options ? options.allKeys : void 0;
    return this._trans("readwrite", (trans) => {
      const { auto, keyPath } = this.schema.primKey;
      if (keyPath && keys3)
        throw new exceptions.InvalidArgument("bulkAdd(): keys argument invalid on tables with inbound keys");
      if (keys3 && keys3.length !== objects.length)
        throw new exceptions.InvalidArgument("Arguments objects and keys must have the same length");
      const numObjects = objects.length;
      let objectsToAdd = keyPath && auto ? objects.map(workaroundForUndefinedPrimKey(keyPath)) : objects;
      return this.core.mutate({ trans, type: "add", keys: keys3, values: objectsToAdd, wantResults }).then(({ numFailures, results, lastResult, failures }) => {
        const result = wantResults ? results : lastResult;
        if (numFailures === 0)
          return result;
        throw new BulkError(`${this.name}.bulkAdd(): ${numFailures} of ${numObjects} operations failed`, failures);
      });
    });
  }
  bulkPut(objects, keysOrOptions, options) {
    const keys3 = Array.isArray(keysOrOptions) ? keysOrOptions : void 0;
    options = options || (keys3 ? void 0 : keysOrOptions);
    const wantResults = options ? options.allKeys : void 0;
    return this._trans("readwrite", (trans) => {
      const { auto, keyPath } = this.schema.primKey;
      if (keyPath && keys3)
        throw new exceptions.InvalidArgument("bulkPut(): keys argument invalid on tables with inbound keys");
      if (keys3 && keys3.length !== objects.length)
        throw new exceptions.InvalidArgument("Arguments objects and keys must have the same length");
      const numObjects = objects.length;
      let objectsToPut = keyPath && auto ? objects.map(workaroundForUndefinedPrimKey(keyPath)) : objects;
      return this.core.mutate({ trans, type: "put", keys: keys3, values: objectsToPut, wantResults }).then(({ numFailures, results, lastResult, failures }) => {
        const result = wantResults ? results : lastResult;
        if (numFailures === 0)
          return result;
        throw new BulkError(`${this.name}.bulkPut(): ${numFailures} of ${numObjects} operations failed`, failures);
      });
    });
  }
  bulkDelete(keys3) {
    const numKeys = keys3.length;
    return this._trans("readwrite", (trans) => {
      return this.core.mutate({ trans, type: "delete", keys: keys3 });
    }).then(({ numFailures, lastResult, failures }) => {
      if (numFailures === 0)
        return lastResult;
      throw new BulkError(`${this.name}.bulkDelete(): ${numFailures} of ${numKeys} operations failed`, failures);
    });
  }
};
function Events(ctx) {
  var evs = {};
  var rv = function(eventName, subscriber) {
    if (subscriber) {
      var i2 = arguments.length, args2 = new Array(i2 - 1);
      while (--i2)
        args2[i2 - 1] = arguments[i2];
      evs[eventName].subscribe.apply(null, args2);
      return ctx;
    } else if (typeof eventName === "string") {
      return evs[eventName];
    }
  };
  rv.addEventType = add2;
  for (var i = 1, l = arguments.length; i < l; ++i) {
    add2(arguments[i]);
  }
  return rv;
  function add2(eventName, chainFunction, defaultFunction) {
    if (typeof eventName === "object")
      return addConfiguredEvents(eventName);
    if (!chainFunction)
      chainFunction = reverseStoppableEventChain;
    if (!defaultFunction)
      defaultFunction = nop2;
    var context = {
      subscribers: [],
      fire: defaultFunction,
      subscribe: function(cb) {
        if (context.subscribers.indexOf(cb) === -1) {
          context.subscribers.push(cb);
          context.fire = chainFunction(context.fire, cb);
        }
      },
      unsubscribe: function(cb) {
        context.subscribers = context.subscribers.filter(function(fn) {
          return fn !== cb;
        });
        context.fire = context.subscribers.reduce(chainFunction, defaultFunction);
      }
    };
    evs[eventName] = rv[eventName] = context;
    return context;
  }
  function addConfiguredEvents(cfg) {
    keys2(cfg).forEach(function(eventName) {
      var args2 = cfg[eventName];
      if (isArray2(args2)) {
        add2(eventName, cfg[eventName][0], cfg[eventName][1]);
      } else if (args2 === "asap") {
        var context = add2(eventName, mirror, function fire() {
          var i2 = arguments.length, args3 = new Array(i2);
          while (i2--)
            args3[i2] = arguments[i2];
          context.subscribers.forEach(function(fn) {
            asap$1(function fireEvent() {
              fn.apply(null, args3);
            });
          });
        });
      } else
        throw new exceptions.InvalidArgument("Invalid event config");
    });
  }
}
function makeClassConstructor(prototype, constructor) {
  derive(constructor).from({ prototype });
  return constructor;
}
function createTableConstructor(db) {
  return makeClassConstructor(Table.prototype, function Table3(name, tableSchema, trans) {
    this.db = db;
    this._tx = trans;
    this.name = name;
    this.schema = tableSchema;
    this.hook = db._allTables[name] ? db._allTables[name].hook : Events(null, {
      "creating": [hookCreatingChain, nop2],
      "reading": [pureFunctionChain, mirror],
      "updating": [hookUpdatingChain, nop2],
      "deleting": [hookDeletingChain, nop2]
    });
  });
}
function isPlainKeyRange(ctx, ignoreLimitFilter) {
  return !(ctx.filter || ctx.algorithm || ctx.or) && (ignoreLimitFilter ? ctx.justLimit : !ctx.replayFilter);
}
function addFilter(ctx, fn) {
  ctx.filter = combine(ctx.filter, fn);
}
function addReplayFilter(ctx, factory, isLimitFilter) {
  var curr = ctx.replayFilter;
  ctx.replayFilter = curr ? () => combine(curr(), factory()) : factory;
  ctx.justLimit = isLimitFilter && !curr;
}
function addMatchFilter(ctx, fn) {
  ctx.isMatch = combine(ctx.isMatch, fn);
}
function getIndexOrStore(ctx, coreSchema) {
  if (ctx.isPrimKey)
    return coreSchema.primaryKey;
  const index = coreSchema.getIndexByKeyPath(ctx.index);
  if (!index)
    throw new exceptions.Schema("KeyPath " + ctx.index + " on object store " + coreSchema.name + " is not indexed");
  return index;
}
function openCursor(ctx, coreTable, trans) {
  const index = getIndexOrStore(ctx, coreTable.schema);
  return coreTable.openCursor({
    trans,
    values: !ctx.keysOnly,
    reverse: ctx.dir === "prev",
    unique: !!ctx.unique,
    query: {
      index,
      range: ctx.range
    }
  });
}
function iter(ctx, fn, coreTrans, coreTable) {
  const filter = ctx.replayFilter ? combine(ctx.filter, ctx.replayFilter()) : ctx.filter;
  if (!ctx.or) {
    return iterate(openCursor(ctx, coreTable, coreTrans), combine(ctx.algorithm, filter), fn, !ctx.keysOnly && ctx.valueMapper);
  } else {
    const set = {};
    const union = (item, cursor, advance) => {
      if (!filter || filter(cursor, advance, (result) => cursor.stop(result), (err) => cursor.fail(err))) {
        var primaryKey = cursor.primaryKey;
        var key = "" + primaryKey;
        if (key === "[object ArrayBuffer]")
          key = "" + new Uint8Array(primaryKey);
        if (!hasOwn(set, key)) {
          set[key] = true;
          fn(item, cursor, advance);
        }
      }
    };
    return Promise.all([
      ctx.or._iterate(union, coreTrans),
      iterate(openCursor(ctx, coreTable, coreTrans), ctx.algorithm, union, !ctx.keysOnly && ctx.valueMapper)
    ]);
  }
}
function iterate(cursorPromise, filter, fn, valueMapper) {
  var mappedFn = valueMapper ? (x, c, a) => fn(valueMapper(x), c, a) : fn;
  var wrappedFn = wrap(mappedFn);
  return cursorPromise.then((cursor) => {
    if (cursor) {
      return cursor.start(() => {
        var c = () => cursor.continue();
        if (!filter || filter(cursor, (advancer) => c = advancer, (val) => {
          cursor.stop(val);
          c = nop2;
        }, (e) => {
          cursor.fail(e);
          c = nop2;
        }))
          wrappedFn(cursor.value, cursor, (advancer) => c = advancer);
        c();
      });
    }
  });
}
function cmp(a, b) {
  try {
    const ta = type(a);
    const tb = type(b);
    if (ta !== tb) {
      if (ta === "Array")
        return 1;
      if (tb === "Array")
        return -1;
      if (ta === "binary")
        return 1;
      if (tb === "binary")
        return -1;
      if (ta === "string")
        return 1;
      if (tb === "string")
        return -1;
      if (ta === "Date")
        return 1;
      if (tb !== "Date")
        return NaN;
      return -1;
    }
    switch (ta) {
      case "number":
      case "Date":
      case "string":
        return a > b ? 1 : a < b ? -1 : 0;
      case "binary": {
        return compareUint8Arrays(getUint8Array(a), getUint8Array(b));
      }
      case "Array":
        return compareArrays(a, b);
    }
  } catch (_a) {
  }
  return NaN;
}
function compareArrays(a, b) {
  const al = a.length;
  const bl = b.length;
  const l = al < bl ? al : bl;
  for (let i = 0; i < l; ++i) {
    const res = cmp(a[i], b[i]);
    if (res !== 0)
      return res;
  }
  return al === bl ? 0 : al < bl ? -1 : 1;
}
function compareUint8Arrays(a, b) {
  const al = a.length;
  const bl = b.length;
  const l = al < bl ? al : bl;
  for (let i = 0; i < l; ++i) {
    if (a[i] !== b[i])
      return a[i] < b[i] ? -1 : 1;
  }
  return al === bl ? 0 : al < bl ? -1 : 1;
}
function type(x) {
  const t = typeof x;
  if (t !== "object")
    return t;
  if (ArrayBuffer.isView(x))
    return "binary";
  const tsTag = toStringTag(x);
  return tsTag === "ArrayBuffer" ? "binary" : tsTag;
}
function getUint8Array(a) {
  if (a instanceof Uint8Array)
    return a;
  if (ArrayBuffer.isView(a))
    return new Uint8Array(a.buffer, a.byteOffset, a.byteLength);
  return new Uint8Array(a);
}
var Collection = class {
  _read(fn, cb) {
    var ctx = this._ctx;
    return ctx.error ? ctx.table._trans(null, rejection.bind(null, ctx.error)) : ctx.table._trans("readonly", fn).then(cb);
  }
  _write(fn) {
    var ctx = this._ctx;
    return ctx.error ? ctx.table._trans(null, rejection.bind(null, ctx.error)) : ctx.table._trans("readwrite", fn, "locked");
  }
  _addAlgorithm(fn) {
    var ctx = this._ctx;
    ctx.algorithm = combine(ctx.algorithm, fn);
  }
  _iterate(fn, coreTrans) {
    return iter(this._ctx, fn, coreTrans, this._ctx.table.core);
  }
  clone(props2) {
    var rv = Object.create(this.constructor.prototype), ctx = Object.create(this._ctx);
    if (props2)
      extend(ctx, props2);
    rv._ctx = ctx;
    return rv;
  }
  raw() {
    this._ctx.valueMapper = null;
    return this;
  }
  each(fn) {
    var ctx = this._ctx;
    return this._read((trans) => iter(ctx, fn, trans, ctx.table.core));
  }
  count(cb) {
    return this._read((trans) => {
      const ctx = this._ctx;
      const coreTable = ctx.table.core;
      if (isPlainKeyRange(ctx, true)) {
        return coreTable.count({
          trans,
          query: {
            index: getIndexOrStore(ctx, coreTable.schema),
            range: ctx.range
          }
        }).then((count3) => Math.min(count3, ctx.limit));
      } else {
        var count2 = 0;
        return iter(ctx, () => {
          ++count2;
          return false;
        }, trans, coreTable).then(() => count2);
      }
    }).then(cb);
  }
  sortBy(keyPath, cb) {
    const parts = keyPath.split(".").reverse(), lastPart = parts[0], lastIndex = parts.length - 1;
    function getval(obj, i) {
      if (i)
        return getval(obj[parts[i]], i - 1);
      return obj[lastPart];
    }
    var order = this._ctx.dir === "next" ? 1 : -1;
    function sorter(a, b) {
      var aVal = getval(a, lastIndex), bVal = getval(b, lastIndex);
      return aVal < bVal ? -order : aVal > bVal ? order : 0;
    }
    return this.toArray(function(a) {
      return a.sort(sorter);
    }).then(cb);
  }
  toArray(cb) {
    return this._read((trans) => {
      var ctx = this._ctx;
      if (ctx.dir === "next" && isPlainKeyRange(ctx, true) && ctx.limit > 0) {
        const { valueMapper } = ctx;
        const index = getIndexOrStore(ctx, ctx.table.core.schema);
        return ctx.table.core.query({
          trans,
          limit: ctx.limit,
          values: true,
          query: {
            index,
            range: ctx.range
          }
        }).then(({ result }) => valueMapper ? result.map(valueMapper) : result);
      } else {
        const a = [];
        return iter(ctx, (item) => a.push(item), trans, ctx.table.core).then(() => a);
      }
    }, cb);
  }
  offset(offset) {
    var ctx = this._ctx;
    if (offset <= 0)
      return this;
    ctx.offset += offset;
    if (isPlainKeyRange(ctx)) {
      addReplayFilter(ctx, () => {
        var offsetLeft = offset;
        return (cursor, advance) => {
          if (offsetLeft === 0)
            return true;
          if (offsetLeft === 1) {
            --offsetLeft;
            return false;
          }
          advance(() => {
            cursor.advance(offsetLeft);
            offsetLeft = 0;
          });
          return false;
        };
      });
    } else {
      addReplayFilter(ctx, () => {
        var offsetLeft = offset;
        return () => --offsetLeft < 0;
      });
    }
    return this;
  }
  limit(numRows) {
    this._ctx.limit = Math.min(this._ctx.limit, numRows);
    addReplayFilter(this._ctx, () => {
      var rowsLeft = numRows;
      return function(cursor, advance, resolve2) {
        if (--rowsLeft <= 0)
          advance(resolve2);
        return rowsLeft >= 0;
      };
    }, true);
    return this;
  }
  until(filterFunction, bIncludeStopEntry) {
    addFilter(this._ctx, function(cursor, advance, resolve2) {
      if (filterFunction(cursor.value)) {
        advance(resolve2);
        return bIncludeStopEntry;
      } else {
        return true;
      }
    });
    return this;
  }
  first(cb) {
    return this.limit(1).toArray(function(a) {
      return a[0];
    }).then(cb);
  }
  last(cb) {
    return this.reverse().first(cb);
  }
  filter(filterFunction) {
    addFilter(this._ctx, function(cursor) {
      return filterFunction(cursor.value);
    });
    addMatchFilter(this._ctx, filterFunction);
    return this;
  }
  and(filter) {
    return this.filter(filter);
  }
  or(indexName) {
    return new this.db.WhereClause(this._ctx.table, indexName, this);
  }
  reverse() {
    this._ctx.dir = this._ctx.dir === "prev" ? "next" : "prev";
    if (this._ondirectionchange)
      this._ondirectionchange(this._ctx.dir);
    return this;
  }
  desc() {
    return this.reverse();
  }
  eachKey(cb) {
    var ctx = this._ctx;
    ctx.keysOnly = !ctx.isMatch;
    return this.each(function(val, cursor) {
      cb(cursor.key, cursor);
    });
  }
  eachUniqueKey(cb) {
    this._ctx.unique = "unique";
    return this.eachKey(cb);
  }
  eachPrimaryKey(cb) {
    var ctx = this._ctx;
    ctx.keysOnly = !ctx.isMatch;
    return this.each(function(val, cursor) {
      cb(cursor.primaryKey, cursor);
    });
  }
  keys(cb) {
    var ctx = this._ctx;
    ctx.keysOnly = !ctx.isMatch;
    var a = [];
    return this.each(function(item, cursor) {
      a.push(cursor.key);
    }).then(function() {
      return a;
    }).then(cb);
  }
  primaryKeys(cb) {
    var ctx = this._ctx;
    if (ctx.dir === "next" && isPlainKeyRange(ctx, true) && ctx.limit > 0) {
      return this._read((trans) => {
        var index = getIndexOrStore(ctx, ctx.table.core.schema);
        return ctx.table.core.query({
          trans,
          values: false,
          limit: ctx.limit,
          query: {
            index,
            range: ctx.range
          }
        });
      }).then(({ result }) => result).then(cb);
    }
    ctx.keysOnly = !ctx.isMatch;
    var a = [];
    return this.each(function(item, cursor) {
      a.push(cursor.primaryKey);
    }).then(function() {
      return a;
    }).then(cb);
  }
  uniqueKeys(cb) {
    this._ctx.unique = "unique";
    return this.keys(cb);
  }
  firstKey(cb) {
    return this.limit(1).keys(function(a) {
      return a[0];
    }).then(cb);
  }
  lastKey(cb) {
    return this.reverse().firstKey(cb);
  }
  distinct() {
    var ctx = this._ctx, idx = ctx.index && ctx.table.schema.idxByName[ctx.index];
    if (!idx || !idx.multi)
      return this;
    var set = {};
    addFilter(this._ctx, function(cursor) {
      var strKey = cursor.primaryKey.toString();
      var found = hasOwn(set, strKey);
      set[strKey] = true;
      return !found;
    });
    return this;
  }
  modify(changes) {
    var ctx = this._ctx;
    return this._write((trans) => {
      var modifyer;
      if (typeof changes === "function") {
        modifyer = changes;
      } else {
        var keyPaths = keys2(changes);
        var numKeys = keyPaths.length;
        modifyer = function(item) {
          var anythingModified = false;
          for (var i = 0; i < numKeys; ++i) {
            var keyPath = keyPaths[i], val = changes[keyPath];
            if (getByKeyPath(item, keyPath) !== val) {
              setByKeyPath(item, keyPath, val);
              anythingModified = true;
            }
          }
          return anythingModified;
        };
      }
      const coreTable = ctx.table.core;
      const { outbound, extractKey } = coreTable.schema.primaryKey;
      const limit = this.db._options.modifyChunkSize || 200;
      const totalFailures = [];
      let successCount = 0;
      const failedKeys = [];
      const applyMutateResult = (expectedCount, res) => {
        const { failures, numFailures } = res;
        successCount += expectedCount - numFailures;
        for (let pos of keys2(failures)) {
          totalFailures.push(failures[pos]);
        }
      };
      return this.clone().primaryKeys().then((keys3) => {
        const nextChunk = (offset) => {
          const count2 = Math.min(limit, keys3.length - offset);
          return coreTable.getMany({
            trans,
            keys: keys3.slice(offset, offset + count2),
            cache: "immutable"
          }).then((values) => {
            const addValues = [];
            const putValues = [];
            const putKeys = outbound ? [] : null;
            const deleteKeys = [];
            for (let i = 0; i < count2; ++i) {
              const origValue = values[i];
              const ctx2 = {
                value: deepClone(origValue),
                primKey: keys3[offset + i]
              };
              if (modifyer.call(ctx2, ctx2.value, ctx2) !== false) {
                if (ctx2.value == null) {
                  deleteKeys.push(keys3[offset + i]);
                } else if (!outbound && cmp(extractKey(origValue), extractKey(ctx2.value)) !== 0) {
                  deleteKeys.push(keys3[offset + i]);
                  addValues.push(ctx2.value);
                } else {
                  putValues.push(ctx2.value);
                  if (outbound)
                    putKeys.push(keys3[offset + i]);
                }
              }
            }
            const criteria = isPlainKeyRange(ctx) && ctx.limit === Infinity && (typeof changes !== "function" || changes === deleteCallback) && {
              index: ctx.index,
              range: ctx.range
            };
            return Promise.resolve(addValues.length > 0 && coreTable.mutate({ trans, type: "add", values: addValues }).then((res) => {
              for (let pos in res.failures) {
                deleteKeys.splice(parseInt(pos), 1);
              }
              applyMutateResult(addValues.length, res);
            })).then(() => (putValues.length > 0 || criteria && typeof changes === "object") && coreTable.mutate({
              trans,
              type: "put",
              keys: putKeys,
              values: putValues,
              criteria,
              changeSpec: typeof changes !== "function" && changes
            }).then((res) => applyMutateResult(putValues.length, res))).then(() => (deleteKeys.length > 0 || criteria && changes === deleteCallback) && coreTable.mutate({
              trans,
              type: "delete",
              keys: deleteKeys,
              criteria
            }).then((res) => applyMutateResult(deleteKeys.length, res))).then(() => {
              return keys3.length > offset + count2 && nextChunk(offset + limit);
            });
          });
        };
        return nextChunk(0).then(() => {
          if (totalFailures.length > 0)
            throw new ModifyError("Error modifying one or more objects", totalFailures, successCount, failedKeys);
          return keys3.length;
        });
      });
    });
  }
  delete() {
    var ctx = this._ctx, range = ctx.range;
    if (isPlainKeyRange(ctx) && (ctx.isPrimKey && !hangsOnDeleteLargeKeyRange || range.type === 3)) {
      return this._write((trans) => {
        const { primaryKey } = ctx.table.core.schema;
        const coreRange = range;
        return ctx.table.core.count({ trans, query: { index: primaryKey, range: coreRange } }).then((count2) => {
          return ctx.table.core.mutate({ trans, type: "deleteRange", range: coreRange }).then(({ failures, lastResult, results, numFailures }) => {
            if (numFailures)
              throw new ModifyError("Could not delete some values", Object.keys(failures).map((pos) => failures[pos]), count2 - numFailures);
            return count2 - numFailures;
          });
        });
      });
    }
    return this.modify(deleteCallback);
  }
};
var deleteCallback = (value, ctx) => ctx.value = null;
function createCollectionConstructor(db) {
  return makeClassConstructor(Collection.prototype, function Collection2(whereClause, keyRangeGenerator) {
    this.db = db;
    let keyRange = AnyRange, error = null;
    if (keyRangeGenerator)
      try {
        keyRange = keyRangeGenerator();
      } catch (ex) {
        error = ex;
      }
    const whereCtx = whereClause._ctx;
    const table = whereCtx.table;
    const readingHook = table.hook.reading.fire;
    this._ctx = {
      table,
      index: whereCtx.index,
      isPrimKey: !whereCtx.index || table.schema.primKey.keyPath && whereCtx.index === table.schema.primKey.name,
      range: keyRange,
      keysOnly: false,
      dir: "next",
      unique: "",
      algorithm: null,
      filter: null,
      replayFilter: null,
      justLimit: true,
      isMatch: null,
      offset: 0,
      limit: Infinity,
      error,
      or: whereCtx.or,
      valueMapper: readingHook !== mirror ? readingHook : null
    };
  });
}
function simpleCompare(a, b) {
  return a < b ? -1 : a === b ? 0 : 1;
}
function simpleCompareReverse(a, b) {
  return a > b ? -1 : a === b ? 0 : 1;
}
function fail(collectionOrWhereClause, err, T) {
  var collection = collectionOrWhereClause instanceof WhereClause ? new collectionOrWhereClause.Collection(collectionOrWhereClause) : collectionOrWhereClause;
  collection._ctx.error = T ? new T(err) : new TypeError(err);
  return collection;
}
function emptyCollection(whereClause) {
  return new whereClause.Collection(whereClause, () => rangeEqual("")).limit(0);
}
function upperFactory(dir) {
  return dir === "next" ? (s) => s.toUpperCase() : (s) => s.toLowerCase();
}
function lowerFactory(dir) {
  return dir === "next" ? (s) => s.toLowerCase() : (s) => s.toUpperCase();
}
function nextCasing(key, lowerKey, upperNeedle, lowerNeedle, cmp2, dir) {
  var length3 = Math.min(key.length, lowerNeedle.length);
  var llp = -1;
  for (var i = 0; i < length3; ++i) {
    var lwrKeyChar = lowerKey[i];
    if (lwrKeyChar !== lowerNeedle[i]) {
      if (cmp2(key[i], upperNeedle[i]) < 0)
        return key.substr(0, i) + upperNeedle[i] + upperNeedle.substr(i + 1);
      if (cmp2(key[i], lowerNeedle[i]) < 0)
        return key.substr(0, i) + lowerNeedle[i] + upperNeedle.substr(i + 1);
      if (llp >= 0)
        return key.substr(0, llp) + lowerKey[llp] + upperNeedle.substr(llp + 1);
      return null;
    }
    if (cmp2(key[i], lwrKeyChar) < 0)
      llp = i;
  }
  if (length3 < lowerNeedle.length && dir === "next")
    return key + upperNeedle.substr(key.length);
  if (length3 < key.length && dir === "prev")
    return key.substr(0, upperNeedle.length);
  return llp < 0 ? null : key.substr(0, llp) + lowerNeedle[llp] + upperNeedle.substr(llp + 1);
}
function addIgnoreCaseAlgorithm(whereClause, match, needles, suffix) {
  var upper, lower, compare, upperNeedles, lowerNeedles, direction, nextKeySuffix, needlesLen = needles.length;
  if (!needles.every((s) => typeof s === "string")) {
    return fail(whereClause, STRING_EXPECTED);
  }
  function initDirection(dir) {
    upper = upperFactory(dir);
    lower = lowerFactory(dir);
    compare = dir === "next" ? simpleCompare : simpleCompareReverse;
    var needleBounds = needles.map(function(needle) {
      return { lower: lower(needle), upper: upper(needle) };
    }).sort(function(a, b) {
      return compare(a.lower, b.lower);
    });
    upperNeedles = needleBounds.map(function(nb) {
      return nb.upper;
    });
    lowerNeedles = needleBounds.map(function(nb) {
      return nb.lower;
    });
    direction = dir;
    nextKeySuffix = dir === "next" ? "" : suffix;
  }
  initDirection("next");
  var c = new whereClause.Collection(whereClause, () => createRange(upperNeedles[0], lowerNeedles[needlesLen - 1] + suffix));
  c._ondirectionchange = function(direction2) {
    initDirection(direction2);
  };
  var firstPossibleNeedle = 0;
  c._addAlgorithm(function(cursor, advance, resolve2) {
    var key = cursor.key;
    if (typeof key !== "string")
      return false;
    var lowerKey = lower(key);
    if (match(lowerKey, lowerNeedles, firstPossibleNeedle)) {
      return true;
    } else {
      var lowestPossibleCasing = null;
      for (var i = firstPossibleNeedle; i < needlesLen; ++i) {
        var casing = nextCasing(key, lowerKey, upperNeedles[i], lowerNeedles[i], compare, direction);
        if (casing === null && lowestPossibleCasing === null)
          firstPossibleNeedle = i + 1;
        else if (lowestPossibleCasing === null || compare(lowestPossibleCasing, casing) > 0) {
          lowestPossibleCasing = casing;
        }
      }
      if (lowestPossibleCasing !== null) {
        advance(function() {
          cursor.continue(lowestPossibleCasing + nextKeySuffix);
        });
      } else {
        advance(resolve2);
      }
      return false;
    }
  });
  return c;
}
function createRange(lower, upper, lowerOpen, upperOpen) {
  return {
    type: 2,
    lower,
    upper,
    lowerOpen,
    upperOpen
  };
}
function rangeEqual(value) {
  return {
    type: 1,
    lower: value,
    upper: value
  };
}
var WhereClause = class {
  get Collection() {
    return this._ctx.table.db.Collection;
  }
  between(lower, upper, includeLower, includeUpper) {
    includeLower = includeLower !== false;
    includeUpper = includeUpper === true;
    try {
      if (this._cmp(lower, upper) > 0 || this._cmp(lower, upper) === 0 && (includeLower || includeUpper) && !(includeLower && includeUpper))
        return emptyCollection(this);
      return new this.Collection(this, () => createRange(lower, upper, !includeLower, !includeUpper));
    } catch (e) {
      return fail(this, INVALID_KEY_ARGUMENT);
    }
  }
  equals(value) {
    if (value == null)
      return fail(this, INVALID_KEY_ARGUMENT);
    return new this.Collection(this, () => rangeEqual(value));
  }
  above(value) {
    if (value == null)
      return fail(this, INVALID_KEY_ARGUMENT);
    return new this.Collection(this, () => createRange(value, void 0, true));
  }
  aboveOrEqual(value) {
    if (value == null)
      return fail(this, INVALID_KEY_ARGUMENT);
    return new this.Collection(this, () => createRange(value, void 0, false));
  }
  below(value) {
    if (value == null)
      return fail(this, INVALID_KEY_ARGUMENT);
    return new this.Collection(this, () => createRange(void 0, value, false, true));
  }
  belowOrEqual(value) {
    if (value == null)
      return fail(this, INVALID_KEY_ARGUMENT);
    return new this.Collection(this, () => createRange(void 0, value));
  }
  startsWith(str) {
    if (typeof str !== "string")
      return fail(this, STRING_EXPECTED);
    return this.between(str, str + maxString, true, true);
  }
  startsWithIgnoreCase(str) {
    if (str === "")
      return this.startsWith(str);
    return addIgnoreCaseAlgorithm(this, (x, a) => x.indexOf(a[0]) === 0, [str], maxString);
  }
  equalsIgnoreCase(str) {
    return addIgnoreCaseAlgorithm(this, (x, a) => x === a[0], [str], "");
  }
  anyOfIgnoreCase() {
    var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
    if (set.length === 0)
      return emptyCollection(this);
    return addIgnoreCaseAlgorithm(this, (x, a) => a.indexOf(x) !== -1, set, "");
  }
  startsWithAnyOfIgnoreCase() {
    var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
    if (set.length === 0)
      return emptyCollection(this);
    return addIgnoreCaseAlgorithm(this, (x, a) => a.some((n) => x.indexOf(n) === 0), set, maxString);
  }
  anyOf() {
    const set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
    let compare = this._cmp;
    try {
      set.sort(compare);
    } catch (e) {
      return fail(this, INVALID_KEY_ARGUMENT);
    }
    if (set.length === 0)
      return emptyCollection(this);
    const c = new this.Collection(this, () => createRange(set[0], set[set.length - 1]));
    c._ondirectionchange = (direction) => {
      compare = direction === "next" ? this._ascending : this._descending;
      set.sort(compare);
    };
    let i = 0;
    c._addAlgorithm((cursor, advance, resolve2) => {
      const key = cursor.key;
      while (compare(key, set[i]) > 0) {
        ++i;
        if (i === set.length) {
          advance(resolve2);
          return false;
        }
      }
      if (compare(key, set[i]) === 0) {
        return true;
      } else {
        advance(() => {
          cursor.continue(set[i]);
        });
        return false;
      }
    });
    return c;
  }
  notEqual(value) {
    return this.inAnyRange([[minKey, value], [value, this.db._maxKey]], { includeLowers: false, includeUppers: false });
  }
  noneOf() {
    const set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
    if (set.length === 0)
      return new this.Collection(this);
    try {
      set.sort(this._ascending);
    } catch (e) {
      return fail(this, INVALID_KEY_ARGUMENT);
    }
    const ranges = set.reduce((res, val) => res ? res.concat([[res[res.length - 1][1], val]]) : [[minKey, val]], null);
    ranges.push([set[set.length - 1], this.db._maxKey]);
    return this.inAnyRange(ranges, { includeLowers: false, includeUppers: false });
  }
  inAnyRange(ranges, options) {
    const cmp2 = this._cmp, ascending = this._ascending, descending = this._descending, min2 = this._min, max2 = this._max;
    if (ranges.length === 0)
      return emptyCollection(this);
    if (!ranges.every((range) => range[0] !== void 0 && range[1] !== void 0 && ascending(range[0], range[1]) <= 0)) {
      return fail(this, "First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower", exceptions.InvalidArgument);
    }
    const includeLowers = !options || options.includeLowers !== false;
    const includeUppers = options && options.includeUppers === true;
    function addRange2(ranges2, newRange) {
      let i = 0, l = ranges2.length;
      for (; i < l; ++i) {
        const range = ranges2[i];
        if (cmp2(newRange[0], range[1]) < 0 && cmp2(newRange[1], range[0]) > 0) {
          range[0] = min2(range[0], newRange[0]);
          range[1] = max2(range[1], newRange[1]);
          break;
        }
      }
      if (i === l)
        ranges2.push(newRange);
      return ranges2;
    }
    let sortDirection = ascending;
    function rangeSorter(a, b) {
      return sortDirection(a[0], b[0]);
    }
    let set;
    try {
      set = ranges.reduce(addRange2, []);
      set.sort(rangeSorter);
    } catch (ex) {
      return fail(this, INVALID_KEY_ARGUMENT);
    }
    let rangePos = 0;
    const keyIsBeyondCurrentEntry = includeUppers ? (key) => ascending(key, set[rangePos][1]) > 0 : (key) => ascending(key, set[rangePos][1]) >= 0;
    const keyIsBeforeCurrentEntry = includeLowers ? (key) => descending(key, set[rangePos][0]) > 0 : (key) => descending(key, set[rangePos][0]) >= 0;
    function keyWithinCurrentRange(key) {
      return !keyIsBeyondCurrentEntry(key) && !keyIsBeforeCurrentEntry(key);
    }
    let checkKey = keyIsBeyondCurrentEntry;
    const c = new this.Collection(this, () => createRange(set[0][0], set[set.length - 1][1], !includeLowers, !includeUppers));
    c._ondirectionchange = (direction) => {
      if (direction === "next") {
        checkKey = keyIsBeyondCurrentEntry;
        sortDirection = ascending;
      } else {
        checkKey = keyIsBeforeCurrentEntry;
        sortDirection = descending;
      }
      set.sort(rangeSorter);
    };
    c._addAlgorithm((cursor, advance, resolve2) => {
      var key = cursor.key;
      while (checkKey(key)) {
        ++rangePos;
        if (rangePos === set.length) {
          advance(resolve2);
          return false;
        }
      }
      if (keyWithinCurrentRange(key)) {
        return true;
      } else if (this._cmp(key, set[rangePos][1]) === 0 || this._cmp(key, set[rangePos][0]) === 0) {
        return false;
      } else {
        advance(() => {
          if (sortDirection === ascending)
            cursor.continue(set[rangePos][0]);
          else
            cursor.continue(set[rangePos][1]);
        });
        return false;
      }
    });
    return c;
  }
  startsWithAnyOf() {
    const set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
    if (!set.every((s) => typeof s === "string")) {
      return fail(this, "startsWithAnyOf() only works with strings");
    }
    if (set.length === 0)
      return emptyCollection(this);
    return this.inAnyRange(set.map((str) => [str, str + maxString]));
  }
};
function createWhereClauseConstructor(db) {
  return makeClassConstructor(WhereClause.prototype, function WhereClause2(table, index, orCollection) {
    this.db = db;
    this._ctx = {
      table,
      index: index === ":id" ? null : index,
      or: orCollection
    };
    const indexedDB2 = db._deps.indexedDB;
    if (!indexedDB2)
      throw new exceptions.MissingAPI();
    this._cmp = this._ascending = indexedDB2.cmp.bind(indexedDB2);
    this._descending = (a, b) => indexedDB2.cmp(b, a);
    this._max = (a, b) => indexedDB2.cmp(a, b) > 0 ? a : b;
    this._min = (a, b) => indexedDB2.cmp(a, b) < 0 ? a : b;
    this._IDBKeyRange = db._deps.IDBKeyRange;
  });
}
function eventRejectHandler(reject2) {
  return wrap(function(event) {
    preventDefault(event);
    reject2(event.target.error);
    return false;
  });
}
function preventDefault(event) {
  if (event.stopPropagation)
    event.stopPropagation();
  if (event.preventDefault)
    event.preventDefault();
}
var DEXIE_STORAGE_MUTATED_EVENT_NAME = "storagemutated";
var STORAGE_MUTATED_DOM_EVENT_NAME = "x-storagemutated-1";
var globalEvents = Events(null, DEXIE_STORAGE_MUTATED_EVENT_NAME);
var Transaction2 = class {
  _lock() {
    assert(!PSD.global);
    ++this._reculock;
    if (this._reculock === 1 && !PSD.global)
      PSD.lockOwnerFor = this;
    return this;
  }
  _unlock() {
    assert(!PSD.global);
    if (--this._reculock === 0) {
      if (!PSD.global)
        PSD.lockOwnerFor = null;
      while (this._blockedFuncs.length > 0 && !this._locked()) {
        var fnAndPSD = this._blockedFuncs.shift();
        try {
          usePSD(fnAndPSD[1], fnAndPSD[0]);
        } catch (e) {
        }
      }
    }
    return this;
  }
  _locked() {
    return this._reculock && PSD.lockOwnerFor !== this;
  }
  create(idbtrans) {
    if (!this.mode)
      return this;
    const idbdb = this.db.idbdb;
    const dbOpenError = this.db._state.dbOpenError;
    assert(!this.idbtrans);
    if (!idbtrans && !idbdb) {
      switch (dbOpenError && dbOpenError.name) {
        case "DatabaseClosedError":
          throw new exceptions.DatabaseClosed(dbOpenError);
        case "MissingAPIError":
          throw new exceptions.MissingAPI(dbOpenError.message, dbOpenError);
        default:
          throw new exceptions.OpenFailed(dbOpenError);
      }
    }
    if (!this.active)
      throw new exceptions.TransactionInactive();
    assert(this._completion._state === null);
    idbtrans = this.idbtrans = idbtrans || (this.db.core ? this.db.core.transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability }) : idbdb.transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability }));
    idbtrans.onerror = wrap((ev) => {
      preventDefault(ev);
      this._reject(idbtrans.error);
    });
    idbtrans.onabort = wrap((ev) => {
      preventDefault(ev);
      this.active && this._reject(new exceptions.Abort(idbtrans.error));
      this.active = false;
      this.on("abort").fire(ev);
    });
    idbtrans.oncomplete = wrap(() => {
      this.active = false;
      this._resolve();
      if ("mutatedParts" in idbtrans) {
        globalEvents.storagemutated.fire(idbtrans["mutatedParts"]);
      }
    });
    return this;
  }
  _promise(mode, fn, bWriteLock) {
    if (mode === "readwrite" && this.mode !== "readwrite")
      return rejection(new exceptions.ReadOnly("Transaction is readonly"));
    if (!this.active)
      return rejection(new exceptions.TransactionInactive());
    if (this._locked()) {
      return new DexiePromise((resolve2, reject2) => {
        this._blockedFuncs.push([() => {
          this._promise(mode, fn, bWriteLock).then(resolve2, reject2);
        }, PSD]);
      });
    } else if (bWriteLock) {
      return newScope(() => {
        var p2 = new DexiePromise((resolve2, reject2) => {
          this._lock();
          const rv = fn(resolve2, reject2, this);
          if (rv && rv.then)
            rv.then(resolve2, reject2);
        });
        p2.finally(() => this._unlock());
        p2._lib = true;
        return p2;
      });
    } else {
      var p = new DexiePromise((resolve2, reject2) => {
        var rv = fn(resolve2, reject2, this);
        if (rv && rv.then)
          rv.then(resolve2, reject2);
      });
      p._lib = true;
      return p;
    }
  }
  _root() {
    return this.parent ? this.parent._root() : this;
  }
  waitFor(promiseLike) {
    var root = this._root();
    const promise = DexiePromise.resolve(promiseLike);
    if (root._waitingFor) {
      root._waitingFor = root._waitingFor.then(() => promise);
    } else {
      root._waitingFor = promise;
      root._waitingQueue = [];
      var store = root.idbtrans.objectStore(root.storeNames[0]);
      (function spin() {
        ++root._spinCount;
        while (root._waitingQueue.length)
          root._waitingQueue.shift()();
        if (root._waitingFor)
          store.get(-Infinity).onsuccess = spin;
      })();
    }
    var currentWaitPromise = root._waitingFor;
    return new DexiePromise((resolve2, reject2) => {
      promise.then((res) => root._waitingQueue.push(wrap(resolve2.bind(null, res))), (err) => root._waitingQueue.push(wrap(reject2.bind(null, err)))).finally(() => {
        if (root._waitingFor === currentWaitPromise) {
          root._waitingFor = null;
        }
      });
    });
  }
  abort() {
    if (this.active) {
      this.active = false;
      if (this.idbtrans)
        this.idbtrans.abort();
      this._reject(new exceptions.Abort());
    }
  }
  table(tableName) {
    const memoizedTables = this._memoizedTables || (this._memoizedTables = {});
    if (hasOwn(memoizedTables, tableName))
      return memoizedTables[tableName];
    const tableSchema = this.schema[tableName];
    if (!tableSchema) {
      throw new exceptions.NotFound("Table " + tableName + " not part of transaction");
    }
    const transactionBoundTable = new this.db.Table(tableName, tableSchema, this);
    transactionBoundTable.core = this.db.core.table(tableName);
    memoizedTables[tableName] = transactionBoundTable;
    return transactionBoundTable;
  }
};
function createTransactionConstructor(db) {
  return makeClassConstructor(Transaction2.prototype, function Transaction3(mode, storeNames, dbschema, chromeTransactionDurability, parent) {
    this.db = db;
    this.mode = mode;
    this.storeNames = storeNames;
    this.schema = dbschema;
    this.chromeTransactionDurability = chromeTransactionDurability;
    this.idbtrans = null;
    this.on = Events(this, "complete", "error", "abort");
    this.parent = parent || null;
    this.active = true;
    this._reculock = 0;
    this._blockedFuncs = [];
    this._resolve = null;
    this._reject = null;
    this._waitingFor = null;
    this._waitingQueue = null;
    this._spinCount = 0;
    this._completion = new DexiePromise((resolve2, reject2) => {
      this._resolve = resolve2;
      this._reject = reject2;
    });
    this._completion.then(() => {
      this.active = false;
      this.on.complete.fire();
    }, (e) => {
      var wasActive = this.active;
      this.active = false;
      this.on.error.fire(e);
      this.parent ? this.parent._reject(e) : wasActive && this.idbtrans && this.idbtrans.abort();
      return rejection(e);
    });
  });
}
function createIndexSpec(name, keyPath, unique, multi, auto, compound, isPrimKey) {
  return {
    name,
    keyPath,
    unique,
    multi,
    auto,
    compound,
    src: (unique && !isPrimKey ? "&" : "") + (multi ? "*" : "") + (auto ? "++" : "") + nameFromKeyPath(keyPath)
  };
}
function nameFromKeyPath(keyPath) {
  return typeof keyPath === "string" ? keyPath : keyPath ? "[" + [].join.call(keyPath, "+") + "]" : "";
}
function createTableSchema(name, primKey, indexes) {
  return {
    name,
    primKey,
    indexes,
    mappedClass: null,
    idxByName: arrayToObject(indexes, (index) => [index.name, index])
  };
}
function safariMultiStoreFix(storeNames) {
  return storeNames.length === 1 ? storeNames[0] : storeNames;
}
var getMaxKey = (IdbKeyRange) => {
  try {
    IdbKeyRange.only([[]]);
    getMaxKey = () => [[]];
    return [[]];
  } catch (e) {
    getMaxKey = () => maxString;
    return maxString;
  }
};
function getKeyExtractor(keyPath) {
  if (keyPath == null) {
    return () => void 0;
  } else if (typeof keyPath === "string") {
    return getSinglePathKeyExtractor(keyPath);
  } else {
    return (obj) => getByKeyPath(obj, keyPath);
  }
}
function getSinglePathKeyExtractor(keyPath) {
  const split = keyPath.split(".");
  if (split.length === 1) {
    return (obj) => obj[keyPath];
  } else {
    return (obj) => getByKeyPath(obj, keyPath);
  }
}
function arrayify(arrayLike) {
  return [].slice.call(arrayLike);
}
var _id_counter = 0;
function getKeyPathAlias(keyPath) {
  return keyPath == null ? ":id" : typeof keyPath === "string" ? keyPath : `[${keyPath.join("+")}]`;
}
function createDBCore(db, IdbKeyRange, tmpTrans) {
  function extractSchema(db2, trans) {
    const tables2 = arrayify(db2.objectStoreNames);
    return {
      schema: {
        name: db2.name,
        tables: tables2.map((table) => trans.objectStore(table)).map((store) => {
          const { keyPath, autoIncrement } = store;
          const compound = isArray2(keyPath);
          const outbound = keyPath == null;
          const indexByKeyPath = {};
          const result = {
            name: store.name,
            primaryKey: {
              name: null,
              isPrimaryKey: true,
              outbound,
              compound,
              keyPath,
              autoIncrement,
              unique: true,
              extractKey: getKeyExtractor(keyPath)
            },
            indexes: arrayify(store.indexNames).map((indexName) => store.index(indexName)).map((index) => {
              const { name, unique, multiEntry, keyPath: keyPath2 } = index;
              const compound2 = isArray2(keyPath2);
              const result2 = {
                name,
                compound: compound2,
                keyPath: keyPath2,
                unique,
                multiEntry,
                extractKey: getKeyExtractor(keyPath2)
              };
              indexByKeyPath[getKeyPathAlias(keyPath2)] = result2;
              return result2;
            }),
            getIndexByKeyPath: (keyPath2) => indexByKeyPath[getKeyPathAlias(keyPath2)]
          };
          indexByKeyPath[":id"] = result.primaryKey;
          if (keyPath != null) {
            indexByKeyPath[getKeyPathAlias(keyPath)] = result.primaryKey;
          }
          return result;
        })
      },
      hasGetAll: tables2.length > 0 && "getAll" in trans.objectStore(tables2[0]) && !(typeof navigator !== "undefined" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604)
    };
  }
  function makeIDBKeyRange(range) {
    if (range.type === 3)
      return null;
    if (range.type === 4)
      throw new Error("Cannot convert never type to IDBKeyRange");
    const { lower, upper, lowerOpen, upperOpen } = range;
    const idbRange = lower === void 0 ? upper === void 0 ? null : IdbKeyRange.upperBound(upper, !!upperOpen) : upper === void 0 ? IdbKeyRange.lowerBound(lower, !!lowerOpen) : IdbKeyRange.bound(lower, upper, !!lowerOpen, !!upperOpen);
    return idbRange;
  }
  function createDbCoreTable(tableSchema) {
    const tableName = tableSchema.name;
    function mutate({ trans, type: type2, keys: keys3, values, range }) {
      return new Promise((resolve2, reject2) => {
        resolve2 = wrap(resolve2);
        const store = trans.objectStore(tableName);
        const outbound = store.keyPath == null;
        const isAddOrPut = type2 === "put" || type2 === "add";
        if (!isAddOrPut && type2 !== "delete" && type2 !== "deleteRange")
          throw new Error("Invalid operation type: " + type2);
        const { length: length3 } = keys3 || values || { length: 1 };
        if (keys3 && values && keys3.length !== values.length) {
          throw new Error("Given keys array must have same length as given values array.");
        }
        if (length3 === 0)
          return resolve2({ numFailures: 0, failures: {}, results: [], lastResult: void 0 });
        let req;
        const reqs = [];
        const failures = [];
        let numFailures = 0;
        const errorHandler = (event) => {
          ++numFailures;
          preventDefault(event);
        };
        if (type2 === "deleteRange") {
          if (range.type === 4)
            return resolve2({ numFailures, failures, results: [], lastResult: void 0 });
          if (range.type === 3)
            reqs.push(req = store.clear());
          else
            reqs.push(req = store.delete(makeIDBKeyRange(range)));
        } else {
          const [args1, args2] = isAddOrPut ? outbound ? [values, keys3] : [values, null] : [keys3, null];
          if (isAddOrPut) {
            for (let i = 0; i < length3; ++i) {
              reqs.push(req = args2 && args2[i] !== void 0 ? store[type2](args1[i], args2[i]) : store[type2](args1[i]));
              req.onerror = errorHandler;
            }
          } else {
            for (let i = 0; i < length3; ++i) {
              reqs.push(req = store[type2](args1[i]));
              req.onerror = errorHandler;
            }
          }
        }
        const done = (event) => {
          const lastResult = event.target.result;
          reqs.forEach((req2, i) => req2.error != null && (failures[i] = req2.error));
          resolve2({
            numFailures,
            failures,
            results: type2 === "delete" ? keys3 : reqs.map((req2) => req2.result),
            lastResult
          });
        };
        req.onerror = (event) => {
          errorHandler(event);
          done(event);
        };
        req.onsuccess = done;
      });
    }
    function openCursor2({ trans, values, query: query2, reverse, unique }) {
      return new Promise((resolve2, reject2) => {
        resolve2 = wrap(resolve2);
        const { index, range } = query2;
        const store = trans.objectStore(tableName);
        const source = index.isPrimaryKey ? store : store.index(index.name);
        const direction = reverse ? unique ? "prevunique" : "prev" : unique ? "nextunique" : "next";
        const req = values || !("openKeyCursor" in source) ? source.openCursor(makeIDBKeyRange(range), direction) : source.openKeyCursor(makeIDBKeyRange(range), direction);
        req.onerror = eventRejectHandler(reject2);
        req.onsuccess = wrap((ev) => {
          const cursor = req.result;
          if (!cursor) {
            resolve2(null);
            return;
          }
          cursor.___id = ++_id_counter;
          cursor.done = false;
          const _cursorContinue = cursor.continue.bind(cursor);
          let _cursorContinuePrimaryKey = cursor.continuePrimaryKey;
          if (_cursorContinuePrimaryKey)
            _cursorContinuePrimaryKey = _cursorContinuePrimaryKey.bind(cursor);
          const _cursorAdvance = cursor.advance.bind(cursor);
          const doThrowCursorIsNotStarted = () => {
            throw new Error("Cursor not started");
          };
          const doThrowCursorIsStopped = () => {
            throw new Error("Cursor not stopped");
          };
          cursor.trans = trans;
          cursor.stop = cursor.continue = cursor.continuePrimaryKey = cursor.advance = doThrowCursorIsNotStarted;
          cursor.fail = wrap(reject2);
          cursor.next = function() {
            let gotOne = 1;
            return this.start(() => gotOne-- ? this.continue() : this.stop()).then(() => this);
          };
          cursor.start = (callback) => {
            const iterationPromise = new Promise((resolveIteration, rejectIteration) => {
              resolveIteration = wrap(resolveIteration);
              req.onerror = eventRejectHandler(rejectIteration);
              cursor.fail = rejectIteration;
              cursor.stop = (value) => {
                cursor.stop = cursor.continue = cursor.continuePrimaryKey = cursor.advance = doThrowCursorIsStopped;
                resolveIteration(value);
              };
            });
            const guardedCallback = () => {
              if (req.result) {
                try {
                  callback();
                } catch (err) {
                  cursor.fail(err);
                }
              } else {
                cursor.done = true;
                cursor.start = () => {
                  throw new Error("Cursor behind last entry");
                };
                cursor.stop();
              }
            };
            req.onsuccess = wrap((ev2) => {
              req.onsuccess = guardedCallback;
              guardedCallback();
            });
            cursor.continue = _cursorContinue;
            cursor.continuePrimaryKey = _cursorContinuePrimaryKey;
            cursor.advance = _cursorAdvance;
            guardedCallback();
            return iterationPromise;
          };
          resolve2(cursor);
        }, reject2);
      });
    }
    function query(hasGetAll2) {
      return (request) => {
        return new Promise((resolve2, reject2) => {
          resolve2 = wrap(resolve2);
          const { trans, values, limit, query: query2 } = request;
          const nonInfinitLimit = limit === Infinity ? void 0 : limit;
          const { index, range } = query2;
          const store = trans.objectStore(tableName);
          const source = index.isPrimaryKey ? store : store.index(index.name);
          const idbKeyRange = makeIDBKeyRange(range);
          if (limit === 0)
            return resolve2({ result: [] });
          if (hasGetAll2) {
            const req = values ? source.getAll(idbKeyRange, nonInfinitLimit) : source.getAllKeys(idbKeyRange, nonInfinitLimit);
            req.onsuccess = (event) => resolve2({ result: event.target.result });
            req.onerror = eventRejectHandler(reject2);
          } else {
            let count2 = 0;
            const req = values || !("openKeyCursor" in source) ? source.openCursor(idbKeyRange) : source.openKeyCursor(idbKeyRange);
            const result = [];
            req.onsuccess = (event) => {
              const cursor = req.result;
              if (!cursor)
                return resolve2({ result });
              result.push(values ? cursor.value : cursor.primaryKey);
              if (++count2 === limit)
                return resolve2({ result });
              cursor.continue();
            };
            req.onerror = eventRejectHandler(reject2);
          }
        });
      };
    }
    return {
      name: tableName,
      schema: tableSchema,
      mutate,
      getMany({ trans, keys: keys3 }) {
        return new Promise((resolve2, reject2) => {
          resolve2 = wrap(resolve2);
          const store = trans.objectStore(tableName);
          const length3 = keys3.length;
          const result = new Array(length3);
          let keyCount = 0;
          let callbackCount = 0;
          let req;
          const successHandler = (event) => {
            const req2 = event.target;
            if ((result[req2._pos] = req2.result) != null)
              ;
            if (++callbackCount === keyCount)
              resolve2(result);
          };
          const errorHandler = eventRejectHandler(reject2);
          for (let i = 0; i < length3; ++i) {
            const key = keys3[i];
            if (key != null) {
              req = store.get(keys3[i]);
              req._pos = i;
              req.onsuccess = successHandler;
              req.onerror = errorHandler;
              ++keyCount;
            }
          }
          if (keyCount === 0)
            resolve2(result);
        });
      },
      get({ trans, key }) {
        return new Promise((resolve2, reject2) => {
          resolve2 = wrap(resolve2);
          const store = trans.objectStore(tableName);
          const req = store.get(key);
          req.onsuccess = (event) => resolve2(event.target.result);
          req.onerror = eventRejectHandler(reject2);
        });
      },
      query: query(hasGetAll),
      openCursor: openCursor2,
      count({ query: query2, trans }) {
        const { index, range } = query2;
        return new Promise((resolve2, reject2) => {
          const store = trans.objectStore(tableName);
          const source = index.isPrimaryKey ? store : store.index(index.name);
          const idbKeyRange = makeIDBKeyRange(range);
          const req = idbKeyRange ? source.count(idbKeyRange) : source.count();
          req.onsuccess = wrap((ev) => resolve2(ev.target.result));
          req.onerror = eventRejectHandler(reject2);
        });
      }
    };
  }
  const { schema, hasGetAll } = extractSchema(db, tmpTrans);
  const tables = schema.tables.map((tableSchema) => createDbCoreTable(tableSchema));
  const tableMap = {};
  tables.forEach((table) => tableMap[table.name] = table);
  return {
    stack: "dbcore",
    transaction: db.transaction.bind(db),
    table(name) {
      const result = tableMap[name];
      if (!result)
        throw new Error(`Table '${name}' not found`);
      return tableMap[name];
    },
    MIN_KEY: -Infinity,
    MAX_KEY: getMaxKey(IdbKeyRange),
    schema
  };
}
function createMiddlewareStack(stackImpl, middlewares) {
  return middlewares.reduce((down, { create: create7 }) => ({ ...down, ...create7(down) }), stackImpl);
}
function createMiddlewareStacks(middlewares, idbdb, { IDBKeyRange: IDBKeyRange2, indexedDB: indexedDB2 }, tmpTrans) {
  const dbcore = createMiddlewareStack(createDBCore(idbdb, IDBKeyRange2, tmpTrans), middlewares.dbcore);
  return {
    dbcore
  };
}
function generateMiddlewareStacks({ _novip: db }, tmpTrans) {
  const idbdb = tmpTrans.db;
  const stacks = createMiddlewareStacks(db._middlewares, idbdb, db._deps, tmpTrans);
  db.core = stacks.dbcore;
  db.tables.forEach((table) => {
    const tableName = table.name;
    if (db.core.schema.tables.some((tbl) => tbl.name === tableName)) {
      table.core = db.core.table(tableName);
      if (db[tableName] instanceof db.Table) {
        db[tableName].core = table.core;
      }
    }
  });
}
function setApiOnPlace({ _novip: db }, objs, tableNames, dbschema) {
  tableNames.forEach((tableName) => {
    const schema = dbschema[tableName];
    objs.forEach((obj) => {
      const propDesc = getPropertyDescriptor(obj, tableName);
      if (!propDesc || "value" in propDesc && propDesc.value === void 0) {
        if (obj === db.Transaction.prototype || obj instanceof db.Transaction) {
          setProp(obj, tableName, {
            get() {
              return this.table(tableName);
            },
            set(value) {
              defineProperty(this, tableName, { value, writable: true, configurable: true, enumerable: true });
            }
          });
        } else {
          obj[tableName] = new db.Table(tableName, schema);
        }
      }
    });
  });
}
function removeTablesApi({ _novip: db }, objs) {
  objs.forEach((obj) => {
    for (let key in obj) {
      if (obj[key] instanceof db.Table)
        delete obj[key];
    }
  });
}
function lowerVersionFirst(a, b) {
  return a._cfg.version - b._cfg.version;
}
function runUpgraders(db, oldVersion, idbUpgradeTrans, reject2) {
  const globalSchema = db._dbSchema;
  const trans = db._createTransaction("readwrite", db._storeNames, globalSchema);
  trans.create(idbUpgradeTrans);
  trans._completion.catch(reject2);
  const rejectTransaction = trans._reject.bind(trans);
  const transless = PSD.transless || PSD;
  newScope(() => {
    PSD.trans = trans;
    PSD.transless = transless;
    if (oldVersion === 0) {
      keys2(globalSchema).forEach((tableName) => {
        createTable(idbUpgradeTrans, tableName, globalSchema[tableName].primKey, globalSchema[tableName].indexes);
      });
      generateMiddlewareStacks(db, idbUpgradeTrans);
      DexiePromise.follow(() => db.on.populate.fire(trans)).catch(rejectTransaction);
    } else
      updateTablesAndIndexes(db, oldVersion, trans, idbUpgradeTrans).catch(rejectTransaction);
  });
}
function updateTablesAndIndexes({ _novip: db }, oldVersion, trans, idbUpgradeTrans) {
  const queue = [];
  const versions = db._versions;
  let globalSchema = db._dbSchema = buildGlobalSchema(db, db.idbdb, idbUpgradeTrans);
  let anyContentUpgraderHasRun = false;
  const versToRun = versions.filter((v) => v._cfg.version >= oldVersion);
  versToRun.forEach((version) => {
    queue.push(() => {
      const oldSchema = globalSchema;
      const newSchema = version._cfg.dbschema;
      adjustToExistingIndexNames(db, oldSchema, idbUpgradeTrans);
      adjustToExistingIndexNames(db, newSchema, idbUpgradeTrans);
      globalSchema = db._dbSchema = newSchema;
      const diff = getSchemaDiff(oldSchema, newSchema);
      diff.add.forEach((tuple) => {
        createTable(idbUpgradeTrans, tuple[0], tuple[1].primKey, tuple[1].indexes);
      });
      diff.change.forEach((change) => {
        if (change.recreate) {
          throw new exceptions.Upgrade("Not yet support for changing primary key");
        } else {
          const store = idbUpgradeTrans.objectStore(change.name);
          change.add.forEach((idx) => addIndex(store, idx));
          change.change.forEach((idx) => {
            store.deleteIndex(idx.name);
            addIndex(store, idx);
          });
          change.del.forEach((idxName) => store.deleteIndex(idxName));
        }
      });
      const contentUpgrade = version._cfg.contentUpgrade;
      if (contentUpgrade && version._cfg.version > oldVersion) {
        generateMiddlewareStacks(db, idbUpgradeTrans);
        trans._memoizedTables = {};
        anyContentUpgraderHasRun = true;
        let upgradeSchema = shallowClone(newSchema);
        diff.del.forEach((table) => {
          upgradeSchema[table] = oldSchema[table];
        });
        removeTablesApi(db, [db.Transaction.prototype]);
        setApiOnPlace(db, [db.Transaction.prototype], keys2(upgradeSchema), upgradeSchema);
        trans.schema = upgradeSchema;
        const contentUpgradeIsAsync = isAsyncFunction(contentUpgrade);
        if (contentUpgradeIsAsync) {
          incrementExpectedAwaits();
        }
        let returnValue;
        const promiseFollowed = DexiePromise.follow(() => {
          returnValue = contentUpgrade(trans);
          if (returnValue) {
            if (contentUpgradeIsAsync) {
              var decrementor = decrementExpectedAwaits.bind(null, null);
              returnValue.then(decrementor, decrementor);
            }
          }
        });
        return returnValue && typeof returnValue.then === "function" ? DexiePromise.resolve(returnValue) : promiseFollowed.then(() => returnValue);
      }
    });
    queue.push((idbtrans) => {
      if (!anyContentUpgraderHasRun || !hasIEDeleteObjectStoreBug) {
        const newSchema = version._cfg.dbschema;
        deleteRemovedTables(newSchema, idbtrans);
      }
      removeTablesApi(db, [db.Transaction.prototype]);
      setApiOnPlace(db, [db.Transaction.prototype], db._storeNames, db._dbSchema);
      trans.schema = db._dbSchema;
    });
  });
  function runQueue() {
    return queue.length ? DexiePromise.resolve(queue.shift()(trans.idbtrans)).then(runQueue) : DexiePromise.resolve();
  }
  return runQueue().then(() => {
    createMissingTables(globalSchema, idbUpgradeTrans);
  });
}
function getSchemaDiff(oldSchema, newSchema) {
  const diff = {
    del: [],
    add: [],
    change: []
  };
  let table;
  for (table in oldSchema) {
    if (!newSchema[table])
      diff.del.push(table);
  }
  for (table in newSchema) {
    const oldDef = oldSchema[table], newDef = newSchema[table];
    if (!oldDef) {
      diff.add.push([table, newDef]);
    } else {
      const change = {
        name: table,
        def: newDef,
        recreate: false,
        del: [],
        add: [],
        change: []
      };
      if ("" + (oldDef.primKey.keyPath || "") !== "" + (newDef.primKey.keyPath || "") || oldDef.primKey.auto !== newDef.primKey.auto && !isIEOrEdge) {
        change.recreate = true;
        diff.change.push(change);
      } else {
        const oldIndexes = oldDef.idxByName;
        const newIndexes = newDef.idxByName;
        let idxName;
        for (idxName in oldIndexes) {
          if (!newIndexes[idxName])
            change.del.push(idxName);
        }
        for (idxName in newIndexes) {
          const oldIdx = oldIndexes[idxName], newIdx = newIndexes[idxName];
          if (!oldIdx)
            change.add.push(newIdx);
          else if (oldIdx.src !== newIdx.src)
            change.change.push(newIdx);
        }
        if (change.del.length > 0 || change.add.length > 0 || change.change.length > 0) {
          diff.change.push(change);
        }
      }
    }
  }
  return diff;
}
function createTable(idbtrans, tableName, primKey, indexes) {
  const store = idbtrans.db.createObjectStore(tableName, primKey.keyPath ? { keyPath: primKey.keyPath, autoIncrement: primKey.auto } : { autoIncrement: primKey.auto });
  indexes.forEach((idx) => addIndex(store, idx));
  return store;
}
function createMissingTables(newSchema, idbtrans) {
  keys2(newSchema).forEach((tableName) => {
    if (!idbtrans.db.objectStoreNames.contains(tableName)) {
      createTable(idbtrans, tableName, newSchema[tableName].primKey, newSchema[tableName].indexes);
    }
  });
}
function deleteRemovedTables(newSchema, idbtrans) {
  [].slice.call(idbtrans.db.objectStoreNames).forEach((storeName) => newSchema[storeName] == null && idbtrans.db.deleteObjectStore(storeName));
}
function addIndex(store, idx) {
  store.createIndex(idx.name, idx.keyPath, { unique: idx.unique, multiEntry: idx.multi });
}
function buildGlobalSchema(db, idbdb, tmpTrans) {
  const globalSchema = {};
  const dbStoreNames = slice(idbdb.objectStoreNames, 0);
  dbStoreNames.forEach((storeName) => {
    const store = tmpTrans.objectStore(storeName);
    let keyPath = store.keyPath;
    const primKey = createIndexSpec(nameFromKeyPath(keyPath), keyPath || "", false, false, !!store.autoIncrement, keyPath && typeof keyPath !== "string", true);
    const indexes = [];
    for (let j = 0; j < store.indexNames.length; ++j) {
      const idbindex = store.index(store.indexNames[j]);
      keyPath = idbindex.keyPath;
      var index = createIndexSpec(idbindex.name, keyPath, !!idbindex.unique, !!idbindex.multiEntry, false, keyPath && typeof keyPath !== "string", false);
      indexes.push(index);
    }
    globalSchema[storeName] = createTableSchema(storeName, primKey, indexes);
  });
  return globalSchema;
}
function readGlobalSchema({ _novip: db }, idbdb, tmpTrans) {
  db.verno = idbdb.version / 10;
  const globalSchema = db._dbSchema = buildGlobalSchema(db, idbdb, tmpTrans);
  db._storeNames = slice(idbdb.objectStoreNames, 0);
  setApiOnPlace(db, [db._allTables], keys2(globalSchema), globalSchema);
}
function verifyInstalledSchema(db, tmpTrans) {
  const installedSchema = buildGlobalSchema(db, db.idbdb, tmpTrans);
  const diff = getSchemaDiff(installedSchema, db._dbSchema);
  return !(diff.add.length || diff.change.some((ch) => ch.add.length || ch.change.length));
}
function adjustToExistingIndexNames({ _novip: db }, schema, idbtrans) {
  const storeNames = idbtrans.db.objectStoreNames;
  for (let i = 0; i < storeNames.length; ++i) {
    const storeName = storeNames[i];
    const store = idbtrans.objectStore(storeName);
    db._hasGetAll = "getAll" in store;
    for (let j = 0; j < store.indexNames.length; ++j) {
      const indexName = store.indexNames[j];
      const keyPath = store.index(indexName).keyPath;
      const dexieName = typeof keyPath === "string" ? keyPath : "[" + slice(keyPath).join("+") + "]";
      if (schema[storeName]) {
        const indexSpec = schema[storeName].idxByName[dexieName];
        if (indexSpec) {
          indexSpec.name = indexName;
          delete schema[storeName].idxByName[dexieName];
          schema[storeName].idxByName[indexName] = indexSpec;
        }
      }
    }
  }
  if (typeof navigator !== "undefined" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && _global.WorkerGlobalScope && _global instanceof _global.WorkerGlobalScope && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604) {
    db._hasGetAll = false;
  }
}
function parseIndexSyntax(primKeyAndIndexes) {
  return primKeyAndIndexes.split(",").map((index, indexNum) => {
    index = index.trim();
    const name = index.replace(/([&*]|\+\+)/g, "");
    const keyPath = /^\[/.test(name) ? name.match(/^\[(.*)\]$/)[1].split("+") : name;
    return createIndexSpec(name, keyPath || null, /\&/.test(index), /\*/.test(index), /\+\+/.test(index), isArray2(keyPath), indexNum === 0);
  });
}
var Version = class {
  _parseStoresSpec(stores, outSchema) {
    keys2(stores).forEach((tableName) => {
      if (stores[tableName] !== null) {
        var indexes = parseIndexSyntax(stores[tableName]);
        var primKey = indexes.shift();
        if (primKey.multi)
          throw new exceptions.Schema("Primary key cannot be multi-valued");
        indexes.forEach((idx) => {
          if (idx.auto)
            throw new exceptions.Schema("Only primary key can be marked as autoIncrement (++)");
          if (!idx.keyPath)
            throw new exceptions.Schema("Index must have a name and cannot be an empty string");
        });
        outSchema[tableName] = createTableSchema(tableName, primKey, indexes);
      }
    });
  }
  stores(stores) {
    const db = this.db;
    this._cfg.storesSource = this._cfg.storesSource ? extend(this._cfg.storesSource, stores) : stores;
    const versions = db._versions;
    const storesSpec = {};
    let dbschema = {};
    versions.forEach((version) => {
      extend(storesSpec, version._cfg.storesSource);
      dbschema = version._cfg.dbschema = {};
      version._parseStoresSpec(storesSpec, dbschema);
    });
    db._dbSchema = dbschema;
    removeTablesApi(db, [db._allTables, db, db.Transaction.prototype]);
    setApiOnPlace(db, [db._allTables, db, db.Transaction.prototype, this._cfg.tables], keys2(dbschema), dbschema);
    db._storeNames = keys2(dbschema);
    return this;
  }
  upgrade(upgradeFunction) {
    this._cfg.contentUpgrade = promisableChain(this._cfg.contentUpgrade || nop2, upgradeFunction);
    return this;
  }
};
function createVersionConstructor(db) {
  return makeClassConstructor(Version.prototype, function Version2(versionNumber) {
    this.db = db;
    this._cfg = {
      version: versionNumber,
      storesSource: null,
      dbschema: {},
      tables: {},
      contentUpgrade: null
    };
  });
}
function getDbNamesTable(indexedDB2, IDBKeyRange2) {
  let dbNamesDB = indexedDB2["_dbNamesDB"];
  if (!dbNamesDB) {
    dbNamesDB = indexedDB2["_dbNamesDB"] = new Dexie$1(DBNAMES_DB, {
      addons: [],
      indexedDB: indexedDB2,
      IDBKeyRange: IDBKeyRange2
    });
    dbNamesDB.version(1).stores({ dbnames: "name" });
  }
  return dbNamesDB.table("dbnames");
}
function hasDatabasesNative(indexedDB2) {
  return indexedDB2 && typeof indexedDB2.databases === "function";
}
function getDatabaseNames({ indexedDB: indexedDB2, IDBKeyRange: IDBKeyRange2 }) {
  return hasDatabasesNative(indexedDB2) ? Promise.resolve(indexedDB2.databases()).then((infos) => infos.map((info) => info.name).filter((name) => name !== DBNAMES_DB)) : getDbNamesTable(indexedDB2, IDBKeyRange2).toCollection().primaryKeys();
}
function _onDatabaseCreated({ indexedDB: indexedDB2, IDBKeyRange: IDBKeyRange2 }, name) {
  !hasDatabasesNative(indexedDB2) && name !== DBNAMES_DB && getDbNamesTable(indexedDB2, IDBKeyRange2).put({ name }).catch(nop2);
}
function _onDatabaseDeleted({ indexedDB: indexedDB2, IDBKeyRange: IDBKeyRange2 }, name) {
  !hasDatabasesNative(indexedDB2) && name !== DBNAMES_DB && getDbNamesTable(indexedDB2, IDBKeyRange2).delete(name).catch(nop2);
}
function vip(fn) {
  return newScope(function() {
    PSD.letThrough = true;
    return fn();
  });
}
function idbReady() {
  var isSafari = !navigator.userAgentData && /Safari\//.test(navigator.userAgent) && !/Chrom(e|ium)\//.test(navigator.userAgent);
  if (!isSafari || !indexedDB.databases)
    return Promise.resolve();
  var intervalId;
  return new Promise(function(resolve2) {
    var tryIdb = function() {
      return indexedDB.databases().finally(resolve2);
    };
    intervalId = setInterval(tryIdb, 100);
    tryIdb();
  }).finally(function() {
    return clearInterval(intervalId);
  });
}
function dexieOpen(db) {
  const state = db._state;
  const { indexedDB: indexedDB2 } = db._deps;
  if (state.isBeingOpened || db.idbdb)
    return state.dbReadyPromise.then(() => state.dbOpenError ? rejection(state.dbOpenError) : db);
  debug && (state.openCanceller._stackHolder = getErrorWithStack());
  state.isBeingOpened = true;
  state.dbOpenError = null;
  state.openComplete = false;
  const openCanceller = state.openCanceller;
  function throwIfCancelled() {
    if (state.openCanceller !== openCanceller)
      throw new exceptions.DatabaseClosed("db.open() was cancelled");
  }
  let resolveDbReady = state.dbReadyResolve, upgradeTransaction = null, wasCreated = false;
  const tryOpenDB = () => new DexiePromise((resolve2, reject2) => {
    throwIfCancelled();
    if (!indexedDB2)
      throw new exceptions.MissingAPI();
    const dbName = db.name;
    const req = state.autoSchema ? indexedDB2.open(dbName) : indexedDB2.open(dbName, Math.round(db.verno * 10));
    if (!req)
      throw new exceptions.MissingAPI();
    req.onerror = eventRejectHandler(reject2);
    req.onblocked = wrap(db._fireOnBlocked);
    req.onupgradeneeded = wrap((e) => {
      upgradeTransaction = req.transaction;
      if (state.autoSchema && !db._options.allowEmptyDB) {
        req.onerror = preventDefault;
        upgradeTransaction.abort();
        req.result.close();
        const delreq = indexedDB2.deleteDatabase(dbName);
        delreq.onsuccess = delreq.onerror = wrap(() => {
          reject2(new exceptions.NoSuchDatabase(`Database ${dbName} doesnt exist`));
        });
      } else {
        upgradeTransaction.onerror = eventRejectHandler(reject2);
        var oldVer = e.oldVersion > Math.pow(2, 62) ? 0 : e.oldVersion;
        wasCreated = oldVer < 1;
        db._novip.idbdb = req.result;
        runUpgraders(db, oldVer / 10, upgradeTransaction, reject2);
      }
    }, reject2);
    req.onsuccess = wrap(() => {
      upgradeTransaction = null;
      const idbdb = db._novip.idbdb = req.result;
      const objectStoreNames = slice(idbdb.objectStoreNames);
      if (objectStoreNames.length > 0)
        try {
          const tmpTrans = idbdb.transaction(safariMultiStoreFix(objectStoreNames), "readonly");
          if (state.autoSchema)
            readGlobalSchema(db, idbdb, tmpTrans);
          else {
            adjustToExistingIndexNames(db, db._dbSchema, tmpTrans);
            if (!verifyInstalledSchema(db, tmpTrans)) {
              console.warn(`Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Some queries may fail.`);
            }
          }
          generateMiddlewareStacks(db, tmpTrans);
        } catch (e) {
        }
      connections.push(db);
      idbdb.onversionchange = wrap((ev) => {
        state.vcFired = true;
        db.on("versionchange").fire(ev);
      });
      idbdb.onclose = wrap((ev) => {
        db.on("close").fire(ev);
      });
      if (wasCreated)
        _onDatabaseCreated(db._deps, dbName);
      resolve2();
    }, reject2);
  }).catch((err) => {
    if (err && err.name === "UnknownError" && state.PR1398_maxLoop > 0) {
      state.PR1398_maxLoop--;
      console.warn("Dexie: Workaround for Chrome UnknownError on open()");
      return tryOpenDB();
    } else {
      return DexiePromise.reject(err);
    }
  });
  return DexiePromise.race([
    openCanceller,
    (typeof navigator === "undefined" ? DexiePromise.resolve() : idbReady()).then(tryOpenDB)
  ]).then(() => {
    throwIfCancelled();
    state.onReadyBeingFired = [];
    return DexiePromise.resolve(vip(() => db.on.ready.fire(db.vip))).then(function fireRemainders() {
      if (state.onReadyBeingFired.length > 0) {
        let remainders = state.onReadyBeingFired.reduce(promisableChain, nop2);
        state.onReadyBeingFired = [];
        return DexiePromise.resolve(vip(() => remainders(db.vip))).then(fireRemainders);
      }
    });
  }).finally(() => {
    state.onReadyBeingFired = null;
    state.isBeingOpened = false;
  }).then(() => {
    return db;
  }).catch((err) => {
    state.dbOpenError = err;
    try {
      upgradeTransaction && upgradeTransaction.abort();
    } catch (_a) {
    }
    if (openCanceller === state.openCanceller) {
      db._close();
    }
    return rejection(err);
  }).finally(() => {
    state.openComplete = true;
    resolveDbReady();
  });
}
function awaitIterator(iterator) {
  var callNext = (result) => iterator.next(result), doThrow = (error) => iterator.throw(error), onSuccess = step(callNext), onError = step(doThrow);
  function step(getNext) {
    return (val) => {
      var next = getNext(val), value = next.value;
      return next.done ? value : !value || typeof value.then !== "function" ? isArray2(value) ? Promise.all(value).then(onSuccess, onError) : onSuccess(value) : value.then(onSuccess, onError);
    };
  }
  return step(callNext)();
}
function extractTransactionArgs(mode, _tableArgs_, scopeFunc) {
  var i = arguments.length;
  if (i < 2)
    throw new exceptions.InvalidArgument("Too few arguments");
  var args2 = new Array(i - 1);
  while (--i)
    args2[i - 1] = arguments[i];
  scopeFunc = args2.pop();
  var tables = flatten(args2);
  return [mode, tables, scopeFunc];
}
function enterTransactionScope(db, mode, storeNames, parentTransaction, scopeFunc) {
  return DexiePromise.resolve().then(() => {
    const transless = PSD.transless || PSD;
    const trans = db._createTransaction(mode, storeNames, db._dbSchema, parentTransaction);
    const zoneProps = {
      trans,
      transless
    };
    if (parentTransaction) {
      trans.idbtrans = parentTransaction.idbtrans;
    } else {
      try {
        trans.create();
        db._state.PR1398_maxLoop = 3;
      } catch (ex) {
        if (ex.name === errnames.InvalidState && db.isOpen() && --db._state.PR1398_maxLoop > 0) {
          console.warn("Dexie: Need to reopen db");
          db._close();
          return db.open().then(() => enterTransactionScope(db, mode, storeNames, null, scopeFunc));
        }
        return rejection(ex);
      }
    }
    const scopeFuncIsAsync = isAsyncFunction(scopeFunc);
    if (scopeFuncIsAsync) {
      incrementExpectedAwaits();
    }
    let returnValue;
    const promiseFollowed = DexiePromise.follow(() => {
      returnValue = scopeFunc.call(trans, trans);
      if (returnValue) {
        if (scopeFuncIsAsync) {
          var decrementor = decrementExpectedAwaits.bind(null, null);
          returnValue.then(decrementor, decrementor);
        } else if (typeof returnValue.next === "function" && typeof returnValue.throw === "function") {
          returnValue = awaitIterator(returnValue);
        }
      }
    }, zoneProps);
    return (returnValue && typeof returnValue.then === "function" ? DexiePromise.resolve(returnValue).then((x) => trans.active ? x : rejection(new exceptions.PrematureCommit("Transaction committed too early. See http://bit.ly/2kdckMn"))) : promiseFollowed.then(() => returnValue)).then((x) => {
      if (parentTransaction)
        trans._resolve();
      return trans._completion.then(() => x);
    }).catch((e) => {
      trans._reject(e);
      return rejection(e);
    });
  });
}
function pad(a, value, count2) {
  const result = isArray2(a) ? a.slice() : [a];
  for (let i = 0; i < count2; ++i)
    result.push(value);
  return result;
}
function createVirtualIndexMiddleware(down) {
  return {
    ...down,
    table(tableName) {
      const table = down.table(tableName);
      const { schema } = table;
      const indexLookup = {};
      const allVirtualIndexes = [];
      function addVirtualIndexes(keyPath, keyTail, lowLevelIndex) {
        const keyPathAlias = getKeyPathAlias(keyPath);
        const indexList = indexLookup[keyPathAlias] = indexLookup[keyPathAlias] || [];
        const keyLength = keyPath == null ? 0 : typeof keyPath === "string" ? 1 : keyPath.length;
        const isVirtual = keyTail > 0;
        const virtualIndex = {
          ...lowLevelIndex,
          isVirtual,
          keyTail,
          keyLength,
          extractKey: getKeyExtractor(keyPath),
          unique: !isVirtual && lowLevelIndex.unique
        };
        indexList.push(virtualIndex);
        if (!virtualIndex.isPrimaryKey) {
          allVirtualIndexes.push(virtualIndex);
        }
        if (keyLength > 1) {
          const virtualKeyPath = keyLength === 2 ? keyPath[0] : keyPath.slice(0, keyLength - 1);
          addVirtualIndexes(virtualKeyPath, keyTail + 1, lowLevelIndex);
        }
        indexList.sort((a, b) => a.keyTail - b.keyTail);
        return virtualIndex;
      }
      const primaryKey = addVirtualIndexes(schema.primaryKey.keyPath, 0, schema.primaryKey);
      indexLookup[":id"] = [primaryKey];
      for (const index of schema.indexes) {
        addVirtualIndexes(index.keyPath, 0, index);
      }
      function findBestIndex(keyPath) {
        const result2 = indexLookup[getKeyPathAlias(keyPath)];
        return result2 && result2[0];
      }
      function translateRange(range, keyTail) {
        return {
          type: range.type === 1 ? 2 : range.type,
          lower: pad(range.lower, range.lowerOpen ? down.MAX_KEY : down.MIN_KEY, keyTail),
          lowerOpen: true,
          upper: pad(range.upper, range.upperOpen ? down.MIN_KEY : down.MAX_KEY, keyTail),
          upperOpen: true
        };
      }
      function translateRequest(req) {
        const index = req.query.index;
        return index.isVirtual ? {
          ...req,
          query: {
            index,
            range: translateRange(req.query.range, index.keyTail)
          }
        } : req;
      }
      const result = {
        ...table,
        schema: {
          ...schema,
          primaryKey,
          indexes: allVirtualIndexes,
          getIndexByKeyPath: findBestIndex
        },
        count(req) {
          return table.count(translateRequest(req));
        },
        query(req) {
          return table.query(translateRequest(req));
        },
        openCursor(req) {
          const { keyTail, isVirtual, keyLength } = req.query.index;
          if (!isVirtual)
            return table.openCursor(req);
          function createVirtualCursor(cursor) {
            function _continue(key) {
              key != null ? cursor.continue(pad(key, req.reverse ? down.MAX_KEY : down.MIN_KEY, keyTail)) : req.unique ? cursor.continue(cursor.key.slice(0, keyLength).concat(req.reverse ? down.MIN_KEY : down.MAX_KEY, keyTail)) : cursor.continue();
            }
            const virtualCursor = Object.create(cursor, {
              continue: { value: _continue },
              continuePrimaryKey: {
                value(key, primaryKey2) {
                  cursor.continuePrimaryKey(pad(key, down.MAX_KEY, keyTail), primaryKey2);
                }
              },
              primaryKey: {
                get() {
                  return cursor.primaryKey;
                }
              },
              key: {
                get() {
                  const key = cursor.key;
                  return keyLength === 1 ? key[0] : key.slice(0, keyLength);
                }
              },
              value: {
                get() {
                  return cursor.value;
                }
              }
            });
            return virtualCursor;
          }
          return table.openCursor(translateRequest(req)).then((cursor) => cursor && createVirtualCursor(cursor));
        }
      };
      return result;
    }
  };
}
var virtualIndexMiddleware = {
  stack: "dbcore",
  name: "VirtualIndexMiddleware",
  level: 1,
  create: createVirtualIndexMiddleware
};
function getObjectDiff(a, b, rv, prfx) {
  rv = rv || {};
  prfx = prfx || "";
  keys2(a).forEach((prop) => {
    if (!hasOwn(b, prop)) {
      rv[prfx + prop] = void 0;
    } else {
      var ap = a[prop], bp = b[prop];
      if (typeof ap === "object" && typeof bp === "object" && ap && bp) {
        const apTypeName = toStringTag(ap);
        const bpTypeName = toStringTag(bp);
        if (apTypeName !== bpTypeName) {
          rv[prfx + prop] = b[prop];
        } else if (apTypeName === "Object") {
          getObjectDiff(ap, bp, rv, prfx + prop + ".");
        } else if (ap !== bp) {
          rv[prfx + prop] = b[prop];
        }
      } else if (ap !== bp)
        rv[prfx + prop] = b[prop];
    }
  });
  keys2(b).forEach((prop) => {
    if (!hasOwn(a, prop)) {
      rv[prfx + prop] = b[prop];
    }
  });
  return rv;
}
function getEffectiveKeys(primaryKey, req) {
  if (req.type === "delete")
    return req.keys;
  return req.keys || req.values.map(primaryKey.extractKey);
}
var hooksMiddleware = {
  stack: "dbcore",
  name: "HooksMiddleware",
  level: 2,
  create: (downCore) => ({
    ...downCore,
    table(tableName) {
      const downTable = downCore.table(tableName);
      const { primaryKey } = downTable.schema;
      const tableMiddleware = {
        ...downTable,
        mutate(req) {
          const dxTrans = PSD.trans;
          const { deleting, creating, updating } = dxTrans.table(tableName).hook;
          switch (req.type) {
            case "add":
              if (creating.fire === nop2)
                break;
              return dxTrans._promise("readwrite", () => addPutOrDelete(req), true);
            case "put":
              if (creating.fire === nop2 && updating.fire === nop2)
                break;
              return dxTrans._promise("readwrite", () => addPutOrDelete(req), true);
            case "delete":
              if (deleting.fire === nop2)
                break;
              return dxTrans._promise("readwrite", () => addPutOrDelete(req), true);
            case "deleteRange":
              if (deleting.fire === nop2)
                break;
              return dxTrans._promise("readwrite", () => deleteRange(req), true);
          }
          return downTable.mutate(req);
          function addPutOrDelete(req2) {
            const dxTrans2 = PSD.trans;
            const keys3 = req2.keys || getEffectiveKeys(primaryKey, req2);
            if (!keys3)
              throw new Error("Keys missing");
            req2 = req2.type === "add" || req2.type === "put" ? { ...req2, keys: keys3 } : { ...req2 };
            if (req2.type !== "delete")
              req2.values = [...req2.values];
            if (req2.keys)
              req2.keys = [...req2.keys];
            return getExistingValues(downTable, req2, keys3).then((existingValues) => {
              const contexts = keys3.map((key, i) => {
                const existingValue = existingValues[i];
                const ctx = { onerror: null, onsuccess: null };
                if (req2.type === "delete") {
                  deleting.fire.call(ctx, key, existingValue, dxTrans2);
                } else if (req2.type === "add" || existingValue === void 0) {
                  const generatedPrimaryKey = creating.fire.call(ctx, key, req2.values[i], dxTrans2);
                  if (key == null && generatedPrimaryKey != null) {
                    key = generatedPrimaryKey;
                    req2.keys[i] = key;
                    if (!primaryKey.outbound) {
                      setByKeyPath(req2.values[i], primaryKey.keyPath, key);
                    }
                  }
                } else {
                  const objectDiff = getObjectDiff(existingValue, req2.values[i]);
                  const additionalChanges = updating.fire.call(ctx, objectDiff, key, existingValue, dxTrans2);
                  if (additionalChanges) {
                    const requestedValue = req2.values[i];
                    Object.keys(additionalChanges).forEach((keyPath) => {
                      if (hasOwn(requestedValue, keyPath)) {
                        requestedValue[keyPath] = additionalChanges[keyPath];
                      } else {
                        setByKeyPath(requestedValue, keyPath, additionalChanges[keyPath]);
                      }
                    });
                  }
                }
                return ctx;
              });
              return downTable.mutate(req2).then(({ failures, results, numFailures, lastResult }) => {
                for (let i = 0; i < keys3.length; ++i) {
                  const primKey = results ? results[i] : keys3[i];
                  const ctx = contexts[i];
                  if (primKey == null) {
                    ctx.onerror && ctx.onerror(failures[i]);
                  } else {
                    ctx.onsuccess && ctx.onsuccess(
                      req2.type === "put" && existingValues[i] ? req2.values[i] : primKey
                    );
                  }
                }
                return { failures, results, numFailures, lastResult };
              }).catch((error) => {
                contexts.forEach((ctx) => ctx.onerror && ctx.onerror(error));
                return Promise.reject(error);
              });
            });
          }
          function deleteRange(req2) {
            return deleteNextChunk(req2.trans, req2.range, 1e4);
          }
          function deleteNextChunk(trans, range, limit) {
            return downTable.query({ trans, values: false, query: { index: primaryKey, range }, limit }).then(({ result }) => {
              return addPutOrDelete({ type: "delete", keys: result, trans }).then((res) => {
                if (res.numFailures > 0)
                  return Promise.reject(res.failures[0]);
                if (result.length < limit) {
                  return { failures: [], numFailures: 0, lastResult: void 0 };
                } else {
                  return deleteNextChunk(trans, { ...range, lower: result[result.length - 1], lowerOpen: true }, limit);
                }
              });
            });
          }
        }
      };
      return tableMiddleware;
    }
  })
};
function getExistingValues(table, req, effectiveKeys) {
  return req.type === "add" ? Promise.resolve([]) : table.getMany({ trans: req.trans, keys: effectiveKeys, cache: "immutable" });
}
function getFromTransactionCache(keys3, cache, clone) {
  try {
    if (!cache)
      return null;
    if (cache.keys.length < keys3.length)
      return null;
    const result = [];
    for (let i = 0, j = 0; i < cache.keys.length && j < keys3.length; ++i) {
      if (cmp(cache.keys[i], keys3[j]) !== 0)
        continue;
      result.push(clone ? deepClone(cache.values[i]) : cache.values[i]);
      ++j;
    }
    return result.length === keys3.length ? result : null;
  } catch (_a) {
    return null;
  }
}
var cacheExistingValuesMiddleware = {
  stack: "dbcore",
  level: -1,
  create: (core) => {
    return {
      table: (tableName) => {
        const table = core.table(tableName);
        return {
          ...table,
          getMany: (req) => {
            if (!req.cache) {
              return table.getMany(req);
            }
            const cachedResult = getFromTransactionCache(req.keys, req.trans["_cache"], req.cache === "clone");
            if (cachedResult) {
              return DexiePromise.resolve(cachedResult);
            }
            return table.getMany(req).then((res) => {
              req.trans["_cache"] = {
                keys: req.keys,
                values: req.cache === "clone" ? deepClone(res) : res
              };
              return res;
            });
          },
          mutate: (req) => {
            if (req.type !== "add")
              req.trans["_cache"] = null;
            return table.mutate(req);
          }
        };
      }
    };
  }
};
function isEmptyRange(node) {
  return !("from" in node);
}
var RangeSet2 = function(fromOrTree, to) {
  if (this) {
    extend(this, arguments.length ? { d: 1, from: fromOrTree, to: arguments.length > 1 ? to : fromOrTree } : { d: 0 });
  } else {
    const rv = new RangeSet2();
    if (fromOrTree && "d" in fromOrTree) {
      extend(rv, fromOrTree);
    }
    return rv;
  }
};
props(RangeSet2.prototype, {
  add(rangeSet) {
    mergeRanges(this, rangeSet);
    return this;
  },
  addKey(key) {
    addRange(this, key, key);
    return this;
  },
  addKeys(keys3) {
    keys3.forEach((key) => addRange(this, key, key));
    return this;
  },
  [iteratorSymbol]() {
    return getRangeSetIterator(this);
  }
});
function addRange(target, from2, to) {
  const diff = cmp(from2, to);
  if (isNaN(diff))
    return;
  if (diff > 0)
    throw RangeError();
  if (isEmptyRange(target))
    return extend(target, { from: from2, to, d: 1 });
  const left = target.l;
  const right = target.r;
  if (cmp(to, target.from) < 0) {
    left ? addRange(left, from2, to) : target.l = { from: from2, to, d: 1, l: null, r: null };
    return rebalance(target);
  }
  if (cmp(from2, target.to) > 0) {
    right ? addRange(right, from2, to) : target.r = { from: from2, to, d: 1, l: null, r: null };
    return rebalance(target);
  }
  if (cmp(from2, target.from) < 0) {
    target.from = from2;
    target.l = null;
    target.d = right ? right.d + 1 : 1;
  }
  if (cmp(to, target.to) > 0) {
    target.to = to;
    target.r = null;
    target.d = target.l ? target.l.d + 1 : 1;
  }
  const rightWasCutOff = !target.r;
  if (left && !target.l) {
    mergeRanges(target, left);
  }
  if (right && rightWasCutOff) {
    mergeRanges(target, right);
  }
}
function mergeRanges(target, newSet) {
  function _addRangeSet(target2, { from: from2, to, l, r }) {
    addRange(target2, from2, to);
    if (l)
      _addRangeSet(target2, l);
    if (r)
      _addRangeSet(target2, r);
  }
  if (!isEmptyRange(newSet))
    _addRangeSet(target, newSet);
}
function rangesOverlap(rangeSet1, rangeSet2) {
  const i1 = getRangeSetIterator(rangeSet2);
  let nextResult1 = i1.next();
  if (nextResult1.done)
    return false;
  let a = nextResult1.value;
  const i2 = getRangeSetIterator(rangeSet1);
  let nextResult2 = i2.next(a.from);
  let b = nextResult2.value;
  while (!nextResult1.done && !nextResult2.done) {
    if (cmp(b.from, a.to) <= 0 && cmp(b.to, a.from) >= 0)
      return true;
    cmp(a.from, b.from) < 0 ? a = (nextResult1 = i1.next(b.from)).value : b = (nextResult2 = i2.next(a.from)).value;
  }
  return false;
}
function getRangeSetIterator(node) {
  let state = isEmptyRange(node) ? null : { s: 0, n: node };
  return {
    next(key) {
      const keyProvided = arguments.length > 0;
      while (state) {
        switch (state.s) {
          case 0:
            state.s = 1;
            if (keyProvided) {
              while (state.n.l && cmp(key, state.n.from) < 0)
                state = { up: state, n: state.n.l, s: 1 };
            } else {
              while (state.n.l)
                state = { up: state, n: state.n.l, s: 1 };
            }
          case 1:
            state.s = 2;
            if (!keyProvided || cmp(key, state.n.to) <= 0)
              return { value: state.n, done: false };
          case 2:
            if (state.n.r) {
              state.s = 3;
              state = { up: state, n: state.n.r, s: 0 };
              continue;
            }
          case 3:
            state = state.up;
        }
      }
      return { done: true };
    }
  };
}
function rebalance(target) {
  var _a, _b;
  const diff = (((_a = target.r) === null || _a === void 0 ? void 0 : _a.d) || 0) - (((_b = target.l) === null || _b === void 0 ? void 0 : _b.d) || 0);
  const r = diff > 1 ? "r" : diff < -1 ? "l" : "";
  if (r) {
    const l = r === "r" ? "l" : "r";
    const rootClone = { ...target };
    const oldRootRight = target[r];
    target.from = oldRootRight.from;
    target.to = oldRootRight.to;
    target[r] = oldRootRight[r];
    rootClone[r] = oldRootRight[l];
    target[l] = rootClone;
    rootClone.d = computeDepth(rootClone);
  }
  target.d = computeDepth(target);
}
function computeDepth({ r, l }) {
  return (r ? l ? Math.max(r.d, l.d) : r.d : l ? l.d : 0) + 1;
}
var observabilityMiddleware = {
  stack: "dbcore",
  level: 0,
  create: (core) => {
    const dbName = core.schema.name;
    const FULL_RANGE = new RangeSet2(core.MIN_KEY, core.MAX_KEY);
    return {
      ...core,
      table: (tableName) => {
        const table = core.table(tableName);
        const { schema } = table;
        const { primaryKey } = schema;
        const { extractKey, outbound } = primaryKey;
        const tableClone = {
          ...table,
          mutate: (req) => {
            const trans = req.trans;
            const mutatedParts = trans.mutatedParts || (trans.mutatedParts = {});
            const getRangeSet = (indexName) => {
              const part = `idb://${dbName}/${tableName}/${indexName}`;
              return mutatedParts[part] || (mutatedParts[part] = new RangeSet2());
            };
            const pkRangeSet = getRangeSet("");
            const delsRangeSet = getRangeSet(":dels");
            const { type: type2 } = req;
            let [keys3, newObjs] = req.type === "deleteRange" ? [req.range] : req.type === "delete" ? [req.keys] : req.values.length < 50 ? [[], req.values] : [];
            const oldCache = req.trans["_cache"];
            return table.mutate(req).then((res) => {
              if (isArray2(keys3)) {
                if (type2 !== "delete")
                  keys3 = res.results;
                pkRangeSet.addKeys(keys3);
                const oldObjs = getFromTransactionCache(keys3, oldCache);
                if (!oldObjs && type2 !== "add") {
                  delsRangeSet.addKeys(keys3);
                }
                if (oldObjs || newObjs) {
                  trackAffectedIndexes(getRangeSet, schema, oldObjs, newObjs);
                }
              } else if (keys3) {
                const range = { from: keys3.lower, to: keys3.upper };
                delsRangeSet.add(range);
                pkRangeSet.add(range);
              } else {
                pkRangeSet.add(FULL_RANGE);
                delsRangeSet.add(FULL_RANGE);
                schema.indexes.forEach((idx) => getRangeSet(idx.name).add(FULL_RANGE));
              }
              return res;
            });
          }
        };
        const getRange = ({ query: { index, range } }) => {
          var _a, _b;
          return [
            index,
            new RangeSet2((_a = range.lower) !== null && _a !== void 0 ? _a : core.MIN_KEY, (_b = range.upper) !== null && _b !== void 0 ? _b : core.MAX_KEY)
          ];
        };
        const readSubscribers = {
          get: (req) => [primaryKey, new RangeSet2(req.key)],
          getMany: (req) => [primaryKey, new RangeSet2().addKeys(req.keys)],
          count: getRange,
          query: getRange,
          openCursor: getRange
        };
        keys2(readSubscribers).forEach((method) => {
          tableClone[method] = function(req) {
            const { subscr } = PSD;
            if (subscr) {
              const getRangeSet = (indexName) => {
                const part = `idb://${dbName}/${tableName}/${indexName}`;
                return subscr[part] || (subscr[part] = new RangeSet2());
              };
              const pkRangeSet = getRangeSet("");
              const delsRangeSet = getRangeSet(":dels");
              const [queriedIndex, queriedRanges] = readSubscribers[method](req);
              getRangeSet(queriedIndex.name || "").add(queriedRanges);
              if (!queriedIndex.isPrimaryKey) {
                if (method === "count") {
                  delsRangeSet.add(FULL_RANGE);
                } else {
                  const keysPromise = method === "query" && outbound && req.values && table.query({
                    ...req,
                    values: false
                  });
                  return table[method].apply(this, arguments).then((res) => {
                    if (method === "query") {
                      if (outbound && req.values) {
                        return keysPromise.then(({ result: resultingKeys }) => {
                          pkRangeSet.addKeys(resultingKeys);
                          return res;
                        });
                      }
                      const pKeys = req.values ? res.result.map(extractKey) : res.result;
                      if (req.values) {
                        pkRangeSet.addKeys(pKeys);
                      } else {
                        delsRangeSet.addKeys(pKeys);
                      }
                    } else if (method === "openCursor") {
                      const cursor = res;
                      const wantValues = req.values;
                      return cursor && Object.create(cursor, {
                        key: {
                          get() {
                            delsRangeSet.addKey(cursor.primaryKey);
                            return cursor.key;
                          }
                        },
                        primaryKey: {
                          get() {
                            const pkey = cursor.primaryKey;
                            delsRangeSet.addKey(pkey);
                            return pkey;
                          }
                        },
                        value: {
                          get() {
                            wantValues && pkRangeSet.addKey(cursor.primaryKey);
                            return cursor.value;
                          }
                        }
                      });
                    }
                    return res;
                  });
                }
              }
            }
            return table[method].apply(this, arguments);
          };
        });
        return tableClone;
      }
    };
  }
};
function trackAffectedIndexes(getRangeSet, schema, oldObjs, newObjs) {
  function addAffectedIndex(ix) {
    const rangeSet = getRangeSet(ix.name || "");
    function extractKey(obj) {
      return obj != null ? ix.extractKey(obj) : null;
    }
    const addKeyOrKeys = (key) => ix.multiEntry && isArray2(key) ? key.forEach((key2) => rangeSet.addKey(key2)) : rangeSet.addKey(key);
    (oldObjs || newObjs).forEach((_, i) => {
      const oldKey = oldObjs && extractKey(oldObjs[i]);
      const newKey = newObjs && extractKey(newObjs[i]);
      if (cmp(oldKey, newKey) !== 0) {
        if (oldKey != null)
          addKeyOrKeys(oldKey);
        if (newKey != null)
          addKeyOrKeys(newKey);
      }
    });
  }
  schema.indexes.forEach(addAffectedIndex);
}
var Dexie$1 = class {
  constructor(name, options) {
    this._middlewares = {};
    this.verno = 0;
    const deps = Dexie$1.dependencies;
    this._options = options = {
      addons: Dexie$1.addons,
      autoOpen: true,
      indexedDB: deps.indexedDB,
      IDBKeyRange: deps.IDBKeyRange,
      ...options
    };
    this._deps = {
      indexedDB: options.indexedDB,
      IDBKeyRange: options.IDBKeyRange
    };
    const { addons } = options;
    this._dbSchema = {};
    this._versions = [];
    this._storeNames = [];
    this._allTables = {};
    this.idbdb = null;
    this._novip = this;
    const state = {
      dbOpenError: null,
      isBeingOpened: false,
      onReadyBeingFired: null,
      openComplete: false,
      dbReadyResolve: nop2,
      dbReadyPromise: null,
      cancelOpen: nop2,
      openCanceller: null,
      autoSchema: true,
      PR1398_maxLoop: 3
    };
    state.dbReadyPromise = new DexiePromise((resolve2) => {
      state.dbReadyResolve = resolve2;
    });
    state.openCanceller = new DexiePromise((_, reject2) => {
      state.cancelOpen = reject2;
    });
    this._state = state;
    this.name = name;
    this.on = Events(this, "populate", "blocked", "versionchange", "close", { ready: [promisableChain, nop2] });
    this.on.ready.subscribe = override(this.on.ready.subscribe, (subscribe2) => {
      return (subscriber, bSticky) => {
        Dexie$1.vip(() => {
          const state2 = this._state;
          if (state2.openComplete) {
            if (!state2.dbOpenError)
              DexiePromise.resolve().then(subscriber);
            if (bSticky)
              subscribe2(subscriber);
          } else if (state2.onReadyBeingFired) {
            state2.onReadyBeingFired.push(subscriber);
            if (bSticky)
              subscribe2(subscriber);
          } else {
            subscribe2(subscriber);
            const db = this;
            if (!bSticky)
              subscribe2(function unsubscribe2() {
                db.on.ready.unsubscribe(subscriber);
                db.on.ready.unsubscribe(unsubscribe2);
              });
          }
        });
      };
    });
    this.Collection = createCollectionConstructor(this);
    this.Table = createTableConstructor(this);
    this.Transaction = createTransactionConstructor(this);
    this.Version = createVersionConstructor(this);
    this.WhereClause = createWhereClauseConstructor(this);
    this.on("versionchange", (ev) => {
      if (ev.newVersion > 0)
        console.warn(`Another connection wants to upgrade database '${this.name}'. Closing db now to resume the upgrade.`);
      else
        console.warn(`Another connection wants to delete database '${this.name}'. Closing db now to resume the delete request.`);
      this.close();
    });
    this.on("blocked", (ev) => {
      if (!ev.newVersion || ev.newVersion < ev.oldVersion)
        console.warn(`Dexie.delete('${this.name}') was blocked`);
      else
        console.warn(`Upgrade '${this.name}' blocked by other connection holding version ${ev.oldVersion / 10}`);
    });
    this._maxKey = getMaxKey(options.IDBKeyRange);
    this._createTransaction = (mode, storeNames, dbschema, parentTransaction) => new this.Transaction(mode, storeNames, dbschema, this._options.chromeTransactionDurability, parentTransaction);
    this._fireOnBlocked = (ev) => {
      this.on("blocked").fire(ev);
      connections.filter((c) => c.name === this.name && c !== this && !c._state.vcFired).map((c) => c.on("versionchange").fire(ev));
    };
    this.use(virtualIndexMiddleware);
    this.use(hooksMiddleware);
    this.use(observabilityMiddleware);
    this.use(cacheExistingValuesMiddleware);
    this.vip = Object.create(this, { _vip: { value: true } });
    addons.forEach((addon) => addon(this));
  }
  version(versionNumber) {
    if (isNaN(versionNumber) || versionNumber < 0.1)
      throw new exceptions.Type(`Given version is not a positive number`);
    versionNumber = Math.round(versionNumber * 10) / 10;
    if (this.idbdb || this._state.isBeingOpened)
      throw new exceptions.Schema("Cannot add version when database is open");
    this.verno = Math.max(this.verno, versionNumber);
    const versions = this._versions;
    var versionInstance = versions.filter((v) => v._cfg.version === versionNumber)[0];
    if (versionInstance)
      return versionInstance;
    versionInstance = new this.Version(versionNumber);
    versions.push(versionInstance);
    versions.sort(lowerVersionFirst);
    versionInstance.stores({});
    this._state.autoSchema = false;
    return versionInstance;
  }
  _whenReady(fn) {
    return this.idbdb && (this._state.openComplete || PSD.letThrough || this._vip) ? fn() : new DexiePromise((resolve2, reject2) => {
      if (this._state.openComplete) {
        return reject2(new exceptions.DatabaseClosed(this._state.dbOpenError));
      }
      if (!this._state.isBeingOpened) {
        if (!this._options.autoOpen) {
          reject2(new exceptions.DatabaseClosed());
          return;
        }
        this.open().catch(nop2);
      }
      this._state.dbReadyPromise.then(resolve2, reject2);
    }).then(fn);
  }
  use({ stack, create: create7, level, name }) {
    if (name)
      this.unuse({ stack, name });
    const middlewares = this._middlewares[stack] || (this._middlewares[stack] = []);
    middlewares.push({ stack, create: create7, level: level == null ? 10 : level, name });
    middlewares.sort((a, b) => a.level - b.level);
    return this;
  }
  unuse({ stack, name, create: create7 }) {
    if (stack && this._middlewares[stack]) {
      this._middlewares[stack] = this._middlewares[stack].filter((mw) => create7 ? mw.create !== create7 : name ? mw.name !== name : false);
    }
    return this;
  }
  open() {
    return dexieOpen(this);
  }
  _close() {
    const state = this._state;
    const idx = connections.indexOf(this);
    if (idx >= 0)
      connections.splice(idx, 1);
    if (this.idbdb) {
      try {
        this.idbdb.close();
      } catch (e) {
      }
      this._novip.idbdb = null;
    }
    state.dbReadyPromise = new DexiePromise((resolve2) => {
      state.dbReadyResolve = resolve2;
    });
    state.openCanceller = new DexiePromise((_, reject2) => {
      state.cancelOpen = reject2;
    });
  }
  close() {
    this._close();
    const state = this._state;
    this._options.autoOpen = false;
    state.dbOpenError = new exceptions.DatabaseClosed();
    if (state.isBeingOpened)
      state.cancelOpen(state.dbOpenError);
  }
  delete() {
    const hasArguments = arguments.length > 0;
    const state = this._state;
    return new DexiePromise((resolve2, reject2) => {
      const doDelete = () => {
        this.close();
        var req = this._deps.indexedDB.deleteDatabase(this.name);
        req.onsuccess = wrap(() => {
          _onDatabaseDeleted(this._deps, this.name);
          resolve2();
        });
        req.onerror = eventRejectHandler(reject2);
        req.onblocked = this._fireOnBlocked;
      };
      if (hasArguments)
        throw new exceptions.InvalidArgument("Arguments not allowed in db.delete()");
      if (state.isBeingOpened) {
        state.dbReadyPromise.then(doDelete);
      } else {
        doDelete();
      }
    });
  }
  backendDB() {
    return this.idbdb;
  }
  isOpen() {
    return this.idbdb !== null;
  }
  hasBeenClosed() {
    const dbOpenError = this._state.dbOpenError;
    return dbOpenError && dbOpenError.name === "DatabaseClosed";
  }
  hasFailed() {
    return this._state.dbOpenError !== null;
  }
  dynamicallyOpened() {
    return this._state.autoSchema;
  }
  get tables() {
    return keys2(this._allTables).map((name) => this._allTables[name]);
  }
  transaction() {
    const args2 = extractTransactionArgs.apply(this, arguments);
    return this._transaction.apply(this, args2);
  }
  _transaction(mode, tables, scopeFunc) {
    let parentTransaction = PSD.trans;
    if (!parentTransaction || parentTransaction.db !== this || mode.indexOf("!") !== -1)
      parentTransaction = null;
    const onlyIfCompatible = mode.indexOf("?") !== -1;
    mode = mode.replace("!", "").replace("?", "");
    let idbMode, storeNames;
    try {
      storeNames = tables.map((table) => {
        var storeName = table instanceof this.Table ? table.name : table;
        if (typeof storeName !== "string")
          throw new TypeError("Invalid table argument to Dexie.transaction(). Only Table or String are allowed");
        return storeName;
      });
      if (mode == "r" || mode === READONLY)
        idbMode = READONLY;
      else if (mode == "rw" || mode == READWRITE)
        idbMode = READWRITE;
      else
        throw new exceptions.InvalidArgument("Invalid transaction mode: " + mode);
      if (parentTransaction) {
        if (parentTransaction.mode === READONLY && idbMode === READWRITE) {
          if (onlyIfCompatible) {
            parentTransaction = null;
          } else
            throw new exceptions.SubTransaction("Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY");
        }
        if (parentTransaction) {
          storeNames.forEach((storeName) => {
            if (parentTransaction && parentTransaction.storeNames.indexOf(storeName) === -1) {
              if (onlyIfCompatible) {
                parentTransaction = null;
              } else
                throw new exceptions.SubTransaction("Table " + storeName + " not included in parent transaction.");
            }
          });
        }
        if (onlyIfCompatible && parentTransaction && !parentTransaction.active) {
          parentTransaction = null;
        }
      }
    } catch (e) {
      return parentTransaction ? parentTransaction._promise(null, (_, reject2) => {
        reject2(e);
      }) : rejection(e);
    }
    const enterTransaction = enterTransactionScope.bind(null, this, idbMode, storeNames, parentTransaction, scopeFunc);
    return parentTransaction ? parentTransaction._promise(idbMode, enterTransaction, "lock") : PSD.trans ? usePSD(PSD.transless, () => this._whenReady(enterTransaction)) : this._whenReady(enterTransaction);
  }
  table(tableName) {
    if (!hasOwn(this._allTables, tableName)) {
      throw new exceptions.InvalidTable(`Table ${tableName} does not exist`);
    }
    return this._allTables[tableName];
  }
};
var symbolObservable = typeof Symbol !== "undefined" && "observable" in Symbol ? Symbol.observable : "@@observable";
var Observable2 = class {
  constructor(subscribe2) {
    this._subscribe = subscribe2;
  }
  subscribe(x, error, complete) {
    return this._subscribe(!x || typeof x === "function" ? { next: x, error, complete } : x);
  }
  [symbolObservable]() {
    return this;
  }
};
function extendObservabilitySet(target, newSet) {
  keys2(newSet).forEach((part) => {
    const rangeSet = target[part] || (target[part] = new RangeSet2());
    mergeRanges(rangeSet, newSet[part]);
  });
  return target;
}
function liveQuery(querier) {
  let hasValue = false;
  let currentValue = void 0;
  const observable = new Observable2((observer) => {
    const scopeFuncIsAsync = isAsyncFunction(querier);
    function execute(subscr) {
      if (scopeFuncIsAsync) {
        incrementExpectedAwaits();
      }
      const exec = () => newScope(querier, { subscr, trans: null });
      const rv = PSD.trans ? usePSD(PSD.transless, exec) : exec();
      if (scopeFuncIsAsync) {
        rv.then(decrementExpectedAwaits, decrementExpectedAwaits);
      }
      return rv;
    }
    let closed = false;
    let accumMuts = {};
    let currentObs = {};
    const subscription = {
      get closed() {
        return closed;
      },
      unsubscribe: () => {
        closed = true;
        globalEvents.storagemutated.unsubscribe(mutationListener);
      }
    };
    observer.start && observer.start(subscription);
    let querying = false, startedListening = false;
    function shouldNotify() {
      return keys2(currentObs).some((key) => accumMuts[key] && rangesOverlap(accumMuts[key], currentObs[key]));
    }
    const mutationListener = (parts) => {
      extendObservabilitySet(accumMuts, parts);
      if (shouldNotify()) {
        doQuery();
      }
    };
    const doQuery = () => {
      if (querying || closed)
        return;
      accumMuts = {};
      const subscr = {};
      const ret = execute(subscr);
      if (!startedListening) {
        globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, mutationListener);
        startedListening = true;
      }
      querying = true;
      Promise.resolve(ret).then((result) => {
        hasValue = true;
        currentValue = result;
        querying = false;
        if (closed)
          return;
        if (shouldNotify()) {
          doQuery();
        } else {
          accumMuts = {};
          currentObs = subscr;
          observer.next && observer.next(result);
        }
      }, (err) => {
        querying = false;
        hasValue = false;
        observer.error && observer.error(err);
        subscription.unsubscribe();
      });
    };
    doQuery();
    return subscription;
  });
  observable.hasValue = () => hasValue;
  observable.getValue = () => currentValue;
  return observable;
}
var domDeps;
try {
  domDeps = {
    indexedDB: _global.indexedDB || _global.mozIndexedDB || _global.webkitIndexedDB || _global.msIndexedDB,
    IDBKeyRange: _global.IDBKeyRange || _global.webkitIDBKeyRange
  };
} catch (e) {
  domDeps = { indexedDB: null, IDBKeyRange: null };
}
var Dexie = Dexie$1;
props(Dexie, {
  ...fullNameExceptions,
  delete(databaseName) {
    const db = new Dexie(databaseName, { addons: [] });
    return db.delete();
  },
  exists(name) {
    return new Dexie(name, { addons: [] }).open().then((db) => {
      db.close();
      return true;
    }).catch("NoSuchDatabaseError", () => false);
  },
  getDatabaseNames(cb) {
    try {
      return getDatabaseNames(Dexie.dependencies).then(cb);
    } catch (_a) {
      return rejection(new exceptions.MissingAPI());
    }
  },
  defineClass() {
    function Class(content) {
      extend(this, content);
    }
    return Class;
  },
  ignoreTransaction(scopeFunc) {
    return PSD.trans ? usePSD(PSD.transless, scopeFunc) : scopeFunc();
  },
  vip,
  async: function(generatorFn) {
    return function() {
      try {
        var rv = awaitIterator(generatorFn.apply(this, arguments));
        if (!rv || typeof rv.then !== "function")
          return DexiePromise.resolve(rv);
        return rv;
      } catch (e) {
        return rejection(e);
      }
    };
  },
  spawn: function(generatorFn, args2, thiz) {
    try {
      var rv = awaitIterator(generatorFn.apply(thiz, args2 || []));
      if (!rv || typeof rv.then !== "function")
        return DexiePromise.resolve(rv);
      return rv;
    } catch (e) {
      return rejection(e);
    }
  },
  currentTransaction: {
    get: () => PSD.trans || null
  },
  waitFor: function(promiseOrFunction, optionalTimeout) {
    const promise = DexiePromise.resolve(typeof promiseOrFunction === "function" ? Dexie.ignoreTransaction(promiseOrFunction) : promiseOrFunction).timeout(optionalTimeout || 6e4);
    return PSD.trans ? PSD.trans.waitFor(promise) : promise;
  },
  Promise: DexiePromise,
  debug: {
    get: () => debug,
    set: (value) => {
      setDebug(value, value === "dexie" ? () => true : dexieStackFrameFilter);
    }
  },
  derive,
  extend,
  props,
  override,
  Events,
  on: globalEvents,
  liveQuery,
  extendObservabilitySet,
  getByKeyPath,
  setByKeyPath,
  delByKeyPath,
  shallowClone,
  deepClone,
  getObjectDiff,
  cmp,
  asap: asap$1,
  minKey,
  addons: [],
  connections,
  errnames,
  dependencies: domDeps,
  semVer: DEXIE_VERSION,
  version: DEXIE_VERSION.split(".").map((n) => parseInt(n)).reduce((p, c, i) => p + c / Math.pow(10, i * 2))
});
Dexie.maxKey = getMaxKey(Dexie.dependencies.IDBKeyRange);
if (typeof dispatchEvent !== "undefined" && typeof addEventListener !== "undefined") {
  globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, (updatedParts) => {
    if (!propagatingLocally) {
      let event;
      if (isIEOrEdge) {
        event = document.createEvent("CustomEvent");
        event.initCustomEvent(STORAGE_MUTATED_DOM_EVENT_NAME, true, true, updatedParts);
      } else {
        event = new CustomEvent(STORAGE_MUTATED_DOM_EVENT_NAME, {
          detail: updatedParts
        });
      }
      propagatingLocally = true;
      dispatchEvent(event);
      propagatingLocally = false;
    }
  });
  addEventListener(STORAGE_MUTATED_DOM_EVENT_NAME, ({ detail }) => {
    if (!propagatingLocally) {
      propagateLocally(detail);
    }
  });
}
function propagateLocally(updateParts) {
  let wasMe = propagatingLocally;
  try {
    propagatingLocally = true;
    globalEvents.storagemutated.fire(updateParts);
  } finally {
    propagatingLocally = wasMe;
  }
}
var propagatingLocally = false;
if (typeof BroadcastChannel !== "undefined") {
  const bc = new BroadcastChannel(STORAGE_MUTATED_DOM_EVENT_NAME);
  if (typeof bc.unref === "function") {
    bc.unref();
  }
  globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, (changedParts) => {
    if (!propagatingLocally) {
      bc.postMessage(changedParts);
    }
  });
  bc.onmessage = (ev) => {
    if (ev.data)
      propagateLocally(ev.data);
  };
} else if (typeof self !== "undefined" && typeof navigator !== "undefined") {
  globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, (changedParts) => {
    try {
      if (!propagatingLocally) {
        if (typeof localStorage !== "undefined") {
          localStorage.setItem(STORAGE_MUTATED_DOM_EVENT_NAME, JSON.stringify({
            trig: Math.random(),
            changedParts
          }));
        }
        if (typeof self["clients"] === "object") {
          [...self["clients"].matchAll({ includeUncontrolled: true })].forEach((client) => client.postMessage({
            type: STORAGE_MUTATED_DOM_EVENT_NAME,
            changedParts
          }));
        }
      }
    } catch (_a) {
    }
  });
  if (typeof addEventListener !== "undefined") {
    addEventListener("storage", (ev) => {
      if (ev.key === STORAGE_MUTATED_DOM_EVENT_NAME) {
        const data = JSON.parse(ev.newValue);
        if (data)
          propagateLocally(data.changedParts);
      }
    });
  }
  const swContainer = self.document && navigator.serviceWorker;
  if (swContainer) {
    swContainer.addEventListener("message", propagateMessageLocally);
  }
}
function propagateMessageLocally({ data }) {
  if (data && data.type === STORAGE_MUTATED_DOM_EVENT_NAME) {
    propagateLocally(data.changedParts);
  }
}
DexiePromise.rejectionMapper = mapError;
setDebug(debug, dexieStackFrameFilter);

// src/permanentShareStore.ts
var PermanentShareStoreIndexedDB = class {
  constructor(oid) {
    this.keepOpen = true;
    this.oid = oid;
    this.db = new Dexie$1("peerdraft_" + this.oid);
    this.db.version(2).stores({
      sharedDocs: "path,persistenceId,shareId",
      sharedFolders: "path,persistenceId,shareId"
    });
    this.db.on("close", () => {
      if (this.keepOpen) {
        this.db.open();
      }
    });
    this.documentTable = this.db._allTables["sharedDocs"];
    this.folderTable = this.db._allTables["sharedFolders"];
  }
  close() {
    this.keepOpen = false;
    this.db.close();
  }
  add(doc2) {
    if (doc2 instanceof SharedDocument) {
      return this.documentTable.add({
        path: doc2.path,
        shareId: doc2.shareId,
        persistenceId: createRandomId()
      });
    }
    if (doc2 instanceof SharedFolder) {
      return this.folderTable.add({
        path: doc2.path,
        shareId: doc2.shareId,
        persistenceId: createRandomId()
      });
    }
  }
  removeDoc(path4) {
    return this.documentTable.delete(path4);
  }
  async getDocByPath(path4) {
    return this.documentTable.get(path4);
  }
  getAllDocs() {
    return this.documentTable.toArray();
  }
  removeFolder(path4) {
    return this.folderTable.delete(path4);
  }
  getAllFolders() {
    return this.folderTable.toArray();
  }
  async getFolderByPath(path4) {
    return this.folderTable.get(path4);
  }
  async deleteDB() {
    window.indexedDB.deleteDatabase(this.folderTable.name);
    window.indexedDB.deleteDatabase(this.documentTable.name);
  }
};

// src/settings.ts
var DEFAULT_SETTINGS = {
  basePath: "https://www.peerdraft.app",
  subscriptionAPI: "https://www.peerdraft.app/subscription",
  connectAPI: "https://www.peerdraft.app/subscription/connect",
  sessionAPI: "https://www.peerdraft.app/session",
  sync: "wss://www.peerdraft.app/sync",
  signaling: "wss://www.peerdraft.app/signal",
  actives: "wss://www.peerdraft.app/actives",
  name: "",
  root: "",
  plan: {
    type: "hobby",
    email: ""
  },
  duration: 0,
  debug: false,
  version: "",
  serverShares: {
    files: /* @__PURE__ */ new Map(),
    folders: /* @__PURE__ */ new Map()
  }
};
var FORCE_SETTINGS = {
  /*
  basePath: "http://localhost:5173",
  subscriptionAPI: "http://localhost:5173/subscription",
  connectAPI: "http://localhost:5173/subscription/connect",
  sessionAPI: "http://localhost:5173/session",
  sync: "ws://localhost:5173/sync",
  signaling: "ws://localhost:5173/signal",
  actives: "ws://localhost:5173/actives"
  */
  basePath: "https://www.peerdraft.app",
  subscriptionAPI: "https://www.peerdraft.app/subscription",
  connectAPI: "https://www.peerdraft.app/subscription/connect",
  sessionAPI: "https://www.peerdraft.app/session",
  sync: "wss://www.peerdraft.app/sync",
  signaling: "wss://www.peerdraft.app/signal",
  actives: "wss://www.peerdraft.app/actives"
};
var migrateSettings = async (plugin) => {
  var _a;
  const oldSettings = await getSettings(plugin);
  const newSettings = Object.assign({}, DEFAULT_SETTINGS, oldSettings, FORCE_SETTINGS, {
    version: plugin.manifest.version
  });
  newSettings.oid = (_a = oldSettings == null ? void 0 : oldSettings.oid) != null ? _a : plugin.app.appId;
  const files = newSettings.serverShares.files;
  for (const key of files.keys()) {
    if (key.contains("\\")) {
      files.set((0, import_obsidian6.normalizePath)(key), files.get(key));
      files.delete(key);
    }
  }
  const folders = newSettings.serverShares.folders;
  for (const key of folders.keys()) {
    if (key.contains("\\")) {
      folders.set((0, import_obsidian6.normalizePath)(key), folders.get(key));
      folders.delete(key);
    }
  }
  if ((oldSettings == null ? void 0 : oldSettings.oid) && newSettings.serverShares.files.size === 0 && newSettings.serverShares.folders.size === 0) {
    const db = new PermanentShareStoreIndexedDB(oldSettings.oid);
    const docs = await db.getAllDocs();
    docs.forEach((doc2) => {
      newSettings.serverShares.files.set((0, import_obsidian6.normalizePath)(doc2.path), { persistenceId: doc2.persistenceId, shareId: doc2.shareId });
    });
    const folders2 = await db.getAllFolders();
    folders2.forEach((doc2) => {
      newSettings.serverShares.folders.set((0, import_obsidian6.normalizePath)(doc2.path), { persistenceId: doc2.persistenceId, shareId: doc2.shareId });
    });
    saveSettings(newSettings, plugin);
    await db.deleteDB();
  }
  saveSettings(newSettings, plugin);
  if (oldSettings && oldSettings.version != newSettings.version) {
    showTextModal(plugin.app, "Peerdraft updated", "A new version of Peerdraft was installed. Please restart Obsidian before you use Peerdraft again.");
  }
  return newSettings;
};
var getSettings = async (plugin) => {
  var _a, _b;
  const settings = await plugin.loadData();
  if (settings) {
    settings.serverShares = {
      files: new Map((_a = settings.serverShares) == null ? void 0 : _a.files),
      folders: new Map((_b = settings.serverShares) == null ? void 0 : _b.folders)
    };
  }
  return settings;
};
var saveSettings = (0, import_obsidian6.debounce)(async (settings, plugin) => {
  const serialized = JSON.parse(JSON.stringify(settings));
  serialized.serverShares = {
    files: Array.from(settings.serverShares.files.entries()),
    folders: Array.from(settings.serverShares.folders.entries())
  };
  plugin.saveData(serialized);
}, 1e3, true);
var renderSettings = async (el, plugin) => {
  el.empty();
  const settings = await getSettings(plugin);
  el.createEl("h1", { text: "General" });
  new import_obsidian6.Setting(el).setName("Display Name").setDesc("This name will be shown to your collaborators").addText((text2) => {
    text2.setValue(settings.name);
    text2.onChange(async (value) => {
      settings.name = value;
      saveSettings(settings, plugin);
    });
  });
  const pathSetting = new import_obsidian6.Setting(el);
  pathSetting.setName("Root Folder");
  pathSetting.setDesc("When you import a share from someone else it will be created in this folder.");
  pathSetting.addText((text2) => {
    text2.setValue(settings.root);
    text2.onChange(async (value) => {
      settings.root = value;
      saveSettings(settings, plugin);
    });
    pathSetting.addExtraButton((button) => {
      button.setIcon("search");
      button.onClick(async () => {
        const folder = await promptForFolderSelection(plugin.app);
        if (folder) {
          text2.setValue(folder.path);
          settings.root = folder.path;
          saveSettings(settings, plugin);
        }
      });
    });
  });
  el.createEl("h1", { text: "Your subscription" });
  if (settings.plan.type === "hobby") {
    el.createEl("div", { text: "You are on the free Hobby plan. You can collaborate with your peers for up to 2.5 hours a month. For unlimited collaboration time, sign-up for the Professional plan at 30 USD/year." });
    el.createEl("p");
    el.createEl("div", { text: `You have used Peerdraft for ${settings.duration} minutes so far.` });
    el.createEl("p");
    new import_obsidian6.Setting(el).setName("Subscribe").addButton((button) => {
      button.setButtonText("Buy professional plan");
      button.setCta();
      button.onClick((e) => {
        window.open(`https://peerdraft.app/checkout?oid=${settings.oid}`);
      });
    });
    let connectEmail = "";
    new import_obsidian6.Setting(el).setName("Use existing subscription").setDesc("If you already bought a subscription, enter the e-mail address associated with it and click on `Connect`.").addText((text2) => {
      text2.setPlaceholder("me@test.com");
      text2.onChange((value) => {
        connectEmail = value;
      });
    }).addButton((button) => {
      button.setButtonText("Connect");
      button.onClick(async (e) => {
        const data = await (0, import_obsidian6.requestUrl)({
          url: settings.connectAPI,
          method: "POST",
          contentType: "application/json",
          body: JSON.stringify({
            email: connectEmail,
            oid: settings.oid
          })
        }).json;
        if (data && data.plan) {
          settings.plan = data.plan;
          saveSettings(settings, plugin), await renderSettings(el, plugin);
        }
      });
    });
  } else if (settings.plan.type === "professional") {
    el.createEl("div", { text: "You are on the professional plan for unlimited collaboration. Happy peerdrafting." });
    el.createEl("p");
    el.createEl("div", { text: `You have used Peerdraft for ${settings.duration} minutes so far.` });
    el.createEl("p");
  }
  new import_obsidian6.Setting(el).setName("Refresh subscription data").setDesc("If you just subscribed or connected your license, click here to refresh your subscription information.").addButton((button) => {
    button.setButtonText("Refresh");
    button.onClick(async (e) => {
      refreshSubscriptionData(plugin);
      renderSettings(el, plugin);
    });
  });
  el.createEl("h1", { text: "Help" });
  const div = el.createDiv();
  div.createSpan({ text: "If you need any help, " });
  div.createEl("a", {
    text: "get in touch",
    attr: {
      href: "mailto:dominik@peerdraft.app"
    }
  });
  div.createSpan({ text: "." });
};
var createSettingsTab = (plugin) => {
  return new class extends import_obsidian6.PluginSettingTab {
    async display() {
      await renderSettings(this.containerEl, plugin);
    }
  }(plugin.app, plugin);
};

// src/permanentShareStoreFS.ts
var import_obsidian7 = require("obsidian");
var add = async (doc2, plugin) => {
  if (doc2 instanceof SharedDocument) {
    plugin.settings.serverShares.files.set(doc2.path, {
      shareId: doc2.shareId,
      persistenceId: createRandomId()
    });
  }
  if (doc2 instanceof SharedFolder) {
    plugin.settings.serverShares.folders.set(doc2.path, {
      shareId: doc2.shareId,
      persistenceId: createRandomId()
    });
  }
  saveSettings(plugin.settings, plugin);
};
var removeDoc = async (path4, plugin) => {
  plugin.settings.serverShares.files.delete((0, import_obsidian7.normalizePath)(path4));
  saveSettings(plugin.settings, plugin);
};
var getDocByPath = (path4, plugin) => {
  return plugin.settings.serverShares.files.get(path4);
};
var moveDoc = async (oldPath, newPath, plugin) => {
  const files = plugin.settings.serverShares.files;
  const entry = files.get(oldPath);
  if (entry) {
    files.delete(oldPath);
    files.set(newPath, entry);
    saveSettings(plugin.settings, plugin);
  }
};
var removeFolder = async (path4, plugin) => {
  plugin.settings.serverShares.folders.delete(path4);
  saveSettings(plugin.settings, plugin);
};
var getFolderByPath = (path4, plugin) => {
  return plugin.settings.serverShares.folders.get(path4);
};
var moveFolder = async (oldPath, newPath, plugin) => {
  const oldPathNormalized = (0, import_obsidian7.normalizePath)(oldPath);
  const newPathNormalized = (0, import_obsidian7.normalizePath)(newPath);
  const files = plugin.settings.serverShares.folders;
  const entry = files.get(oldPathNormalized);
  if (entry) {
    files.delete(oldPathNormalized);
    files.set(newPathNormalized, entry);
    saveSettings(plugin.settings, plugin);
  }
};

// src/sharedEntities/sharedFolder.ts
var handleUpdate = (ev, tx, folder, plugin) => {
  var _a;
  if (![plugin.serverSync, (_a = folder.webRTCProvider) == null ? void 0 : _a.room].contains(tx.origin))
    return;
  const changedKeys = ev.changes.keys;
  changedKeys.forEach(async (data, key) => {
    plugin.log("Action: " + data.action + "for " + key + " --> " + tx.doc.getMap("documents").get(key));
    if (data.action === "add") {
      const relativePath = tx.doc.getMap("documents").get(key);
      const absolutePath = path.join(folder.path, relativePath);
      const file = plugin.app.vault.getAbstractFileByPath(absolutePath);
      if (file) {
        showNotice("File " + file.path + " already exists. Renaming.");
        const alteredPath = path.join(path.dirname(relativePath), path.basename(relativePath, path.extname(relativePath)) + "_" + generateRandomString() + path.extname(relativePath));
        const alteredAbsolutePath = path.join(folder.root.path, alteredPath);
        folder.getDocsFragment().set(key, alteredPath);
        SharedDocument.fromIdAndPath(key, alteredAbsolutePath, plugin);
      } else {
        showNotice("Creating new shared document: " + absolutePath);
        await SharedFolder.getOrCreatePath(path.parse(absolutePath).dir, plugin);
        await SharedDocument.fromIdAndPath(key, absolutePath, plugin);
      }
    } else if (data.action === "update") {
      const newPath = tx.doc.getMap("documents").get(key);
      const document2 = SharedDocument.findById(key);
      if (!document2)
        return;
      plugin.log("Update " + document2.path + "   " + key);
      const folder2 = SharedFolder.getSharedFolderForSubPath(document2.path);
      if (!folder2)
        return;
      let newAbsolutePath = path.join(folder2.root.path, newPath);
      await SharedFolder.getOrCreatePath(path.parse(newAbsolutePath).dir, plugin);
      const alreadyExists = SharedDocument.findByPath(newAbsolutePath);
      if (alreadyExists) {
        showNotice("File " + newPath + " already exists. Renaming.");
        const alteredPath = path.join(path.dirname(newPath), path.basename(newPath, path.extname(newPath)) + "_" + generateRandomString() + path.extname(newPath));
        const alteredAbsolutePath = path.join(folder2.root.path, alteredPath);
        folder2.getDocsFragment().set(key, alteredPath);
        SharedDocument.fromIdAndPath(key, alteredAbsolutePath, plugin);
      } else {
        await plugin.app.fileManager.renameFile(document2.file, newAbsolutePath);
      }
    } else if (data.action === "delete") {
      const document2 = SharedDocument.findById(key);
      if (!document2)
        return;
      plugin.log("Delete " + document2.path + "   " + key);
      const file = plugin.app.vault.getAbstractFileByPath(document2.path);
      if (!file)
        return;
      plugin.app.vault.delete(file);
    }
  });
};
var _SharedFolder = class extends SharedEntity {
  constructor(root, plugin, ydoc) {
    super(plugin);
    this.root = root;
    this._path = root.path;
    this.yDoc = ydoc != null ? ydoc : new Doc();
    this.getDocsFragment().observe((ev, tx) => {
      handleUpdate(ev, tx, this, plugin);
    });
    this.yDoc.on("update", (update, origin, yDoc, tr) => {
      if (tr.local && this.shareId) {
        plugin.serverSync.sendUpdate(this, update);
      }
    });
    _SharedFolder._sharedEntites.push(this);
    addIsSharedClass(this.path, plugin);
  }
  static async fromTFolder(root, plugin) {
    showNotice(`Inititializing share for ${root.path}.`);
    const files = this.getAllFilesInFolder(root);
    for (const file of files) {
      if (SharedDocument.findByPath(file.path)) {
        showNotice("You can not share a directory that already has shared files in it (right now).");
        return;
      }
    }
    const docs = await Promise.all(files.map((file) => {
      return SharedDocument.fromTFile(file, {
        permanent: true
      }, plugin);
    }));
    const folder = new _SharedFolder(root, plugin);
    for (const doc2 of docs) {
      if (doc2) {
        folder.addDocument(doc2);
      }
    }
    folder.yDoc.getText("originalFoldername").insert(0, root.name);
    await folder.initServerYDoc();
    await add(folder, plugin);
    await folder.startIndexedDBSync();
    folder.startWebRTCSync();
    navigator.clipboard.writeText(plugin.settings.basePath + "/team/" + folder.shareId);
    showNotice(`Folder ${folder.path} with ${docs.length} documents shared. URL copied to your clipboard.`, 0);
    return folder;
  }
  static async recreate(folder, plugin) {
    const location2 = folder.root.path;
    await folder.unshare();
    await plugin.app.vault.delete(folder.root, true);
    return await this.fromShareURL(plugin.settings.basePath + "/team/" + folder.shareId, plugin, location2);
  }
  static async fromShareURL(url, plugin, location2) {
    const id2 = url.split("/").pop();
    if (!id2 || !id2.match("^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")) {
      showNotice("No valid peerdraft link");
      return;
    }
    let folderPath = location2;
    const preFetchedDoc = await plugin.serverSync.requestDocument(id2);
    if (!location2) {
      let initialRootName = `_peerdraft_team_folder_${generateRandomString()}`;
      const docFoldername = preFetchedDoc.getText("originalFoldername").toString();
      if (docFoldername != "") {
        const folderExists = plugin.app.vault.getAbstractFileByPath(path.join(plugin.settings.root, docFoldername));
        if (!folderExists) {
          initialRootName = docFoldername;
        } else {
          initialRootName = `_peerdraft_${generateRandomString()}_${docFoldername}`;
        }
      }
      folderPath = path.join(plugin.settings.root, initialRootName);
    }
    const folder = await _SharedFolder.getOrCreatePath(folderPath, plugin);
    if (!folder) {
      return showNotice("Could not create folder " + folderPath);
    }
    ;
    const paths = [];
    const documentMap = preFetchedDoc.getMap("documents");
    for (const entry of documentMap.entries()) {
      let docPath = entry[1];
      if (paths.contains((0, import_obsidian8.normalizePath)(docPath))) {
        docPath = (0, import_obsidian8.normalizePath)(path.join(path.dirname(docPath), path.basename(docPath, path.extname(docPath)) + "_" + generateRandomString() + path.extname(docPath)));
        documentMap.set(entry[0], docPath);
      }
      await SharedDocument.fromIdAndPath(entry[0], path.join(folderPath, docPath), plugin);
      paths.push((0, import_obsidian8.normalizePath)(docPath));
    }
    const sFolder = new _SharedFolder(folder, plugin, preFetchedDoc);
    sFolder._shareId = id2;
    await add(sFolder, plugin);
    await sFolder.startIndexedDBSync();
    if (sFolder.indexedDBProvider) {
      if (!sFolder.indexedDBProvider.synced)
        await sFolder.indexedDBProvider.whenSynced;
      sFolder.syncWithServer();
      sFolder.startWebRTCSync();
    }
    return sFolder;
  }
  static async fromPermanentShareFolder(psf, plugin) {
    if (this.findByPath(psf.path))
      return;
    let tFolder;
    tFolder = plugin.app.vault.getAbstractFileByPath(psf.path);
    if (tFolder instanceof import_obsidian8.TFile) {
      showNotice("Expected " + psf.path + " to be a folder, a but is a file?");
      return;
    }
    if (!(tFolder instanceof import_obsidian8.TFolder)) {
      showNotice("Shared folder " + psf.path + " not found. Creating it now.");
      tFolder = await this.getOrCreatePath(psf.path, plugin);
    }
    if (!(tFolder instanceof import_obsidian8.TFolder)) {
      showNotice("Could not create folder " + psf.path + ".");
      return;
    }
    const folder = new _SharedFolder(tFolder, plugin);
    folder._shareId = psf.shareId;
    const local = await folder.startIndexedDBSync();
    if (local) {
      if (local.synced || await local.whenSynced) {
        folder.syncWithServer();
        folder.startWebRTCSync();
      }
    }
    return folder;
  }
  static findByPath(path4) {
    return super.findByPath(path4);
  }
  static findById(id2) {
    return super.findById(id2);
  }
  static getAll() {
    return super.getAll();
  }
  static getSharedFolderForSubPath(dir) {
    const normalizedPath = (0, import_obsidian8.normalizePath)(dir);
    const folders = this.getAll();
    for (const folder of folders) {
      if (folder.root.path === normalizedPath)
        return;
      if (folder.isPathSubPath(normalizedPath))
        return folder;
    }
  }
  getDocsFragment() {
    return this.yDoc.getMap("documents");
  }
  getDocByRelativePath(dir) {
    const normalizedPath = (0, import_obsidian8.normalizePath)(dir);
    for (const entry of this.getDocsFragment().entries()) {
      if (entry[1] === normalizedPath)
        return entry[0];
    }
  }
  updatePath(oldPath, newPath) {
    const oldPathRelative = path.relative(this.root.path, oldPath);
    const newPathRelative = path.relative(this.root.path, newPath);
    const id2 = this.getDocByRelativePath(oldPathRelative);
    if (id2) {
      this.getDocsFragment().set(id2, (0, import_obsidian8.normalizePath)(newPathRelative));
    }
    return id2;
  }
  calculateHash() {
    const serialized = serialize(Array.from(this.getDocsFragment()));
    return calculateHash(serialized);
  }
  addDocument(doc2) {
    if (this.getDocsFragment().get(doc2.shareId))
      return;
    const relativePath = path.relative(this.root.path, doc2.path);
    if (relativePath.startsWith(".."))
      return;
    this.getDocsFragment().set(doc2.shareId, relativePath);
  }
  removeDocument(doc2) {
    this.getDocsFragment().delete(doc2.shareId);
  }
  isPathSubPath(folder) {
    const relativePath = path.relative(this.root.path, folder);
    return !relativePath.startsWith("..");
  }
  static getAllFilesInFolder(folder) {
    const files = folder.children.flatMap((child) => {
      if (child instanceof import_obsidian8.TFile) {
        if (child.extension === "md") {
          return child;
        }
      }
      if (child instanceof import_obsidian8.TFolder) {
        return this.getAllFilesInFolder(child);
      }
      return [];
    });
    return files;
  }
  async setNewFolderLocation(folder) {
    const oldPath = this._path;
    this.root = folder;
    this._path = (0, import_obsidian8.normalizePath)(folder.path);
    moveFolder(oldPath, folder.path, this.plugin);
  }
  async getOrCreateFile(relativePath) {
    const absolutePath = path.join(this.root.path, relativePath);
    let file = this.plugin.app.vault.getAbstractFileByPath(absolutePath);
    if (file && file instanceof import_obsidian8.TFile)
      return file;
    const folder = await _SharedFolder.getOrCreatePath(path.parse(absolutePath).dir, this.plugin);
    if (!folder) {
      showNotice("Error creating shares");
      return;
    }
    return await this.plugin.app.vault.create(absolutePath, "");
  }
  static async getOrCreatePath(absolutePath, plugin) {
    let folder = plugin.app.vault.getAbstractFileByPath((0, import_obsidian8.normalizePath)(absolutePath));
    if (folder && folder instanceof import_obsidian8.TFolder)
      return folder;
    const segments = absolutePath.split(path.sep);
    for (let index = 0; index < segments.length; index++) {
      const subPath = segments.slice(0, index + 1).join(path.sep);
      folder = plugin.app.vault.getAbstractFileByPath((0, import_obsidian8.normalizePath)(subPath));
      if (!folder) {
        folder = await plugin.app.vault.createFolder((0, import_obsidian8.normalizePath)(subPath));
      }
    }
    return folder;
  }
  isFileInSyncObject(file) {
    const normalizedPath = (0, import_obsidian8.normalizePath)(file.path);
    for (const value of this.getDocsFragment().values()) {
      if (normalizedPath === path.join(this.root.path, value))
        return true;
    }
    return false;
  }
  startWebRTCSync() {
    return super.startWebRTCSync((provider) => {
      const handleTimeout = () => {
      };
      this._webRTCTimeout = window.setTimeout(handleTimeout, 6e4);
      provider.doc.on("update", async (update, origin, doc2, tr) => {
        if (this._webRTCTimeout != null) {
          window.clearTimeout(this._webRTCTimeout);
        }
        this._webRTCTimeout = window.setTimeout(handleTimeout, 6e4);
      });
    });
  }
  async startIndexedDBSync() {
    var _a;
    if (this._indexedDBProvider)
      return this._indexedDBProvider;
    const id2 = (_a = getFolderByPath(this.path, this.plugin)) == null ? void 0 : _a.persistenceId;
    if (!id2)
      return;
    this._indexedDBProvider = new IndexeddbPersistence(SharedEntity.DB_PERSISTENCE_PREFIX + id2, this.yDoc);
    return this._indexedDBProvider;
  }
  async unshare() {
    const dbEntry = getFolderByPath(this.path, this.plugin);
    if (dbEntry) {
      removeFolder(this.path, this.plugin);
    }
    if (this._indexedDBProvider) {
      await this._indexedDBProvider.clearData();
      await this._indexedDBProvider.destroy();
    }
    this.getDocsFragment().forEach((path4, shareId) => {
      var _a;
      (_a = SharedDocument.findById(shareId)) == null ? void 0 : _a.unshare();
    });
    this.destroy();
    removeIsSharedClass(this.path, this.plugin);
  }
  destroy() {
    super.destroy();
    _SharedFolder._sharedEntites.splice(_SharedFolder._sharedEntites.indexOf(this), 1);
  }
};
var SharedFolder = _SharedFolder;
SharedFolder._sharedEntites = new Array();

// node_modules/async-mutex/index.mjs
var E_TIMEOUT = new Error("timeout while waiting for mutex to become available");
var E_ALREADY_LOCKED = new Error("mutex already locked");
var E_CANCELED = new Error("request for lock canceled");
var __awaiter$2 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P || (P = Promise))(function(resolve2, reject2) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject2(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject2(e);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Semaphore = class {
  constructor(_value, _cancelError = E_CANCELED) {
    this._value = _value;
    this._cancelError = _cancelError;
    this._queue = [];
    this._weightedWaiters = [];
  }
  acquire(weight = 1, priority = 0) {
    if (weight <= 0)
      throw new Error(`invalid weight ${weight}: must be positive`);
    return new Promise((resolve2, reject2) => {
      const task2 = { resolve: resolve2, reject: reject2, weight, priority };
      const i = findIndexFromEnd(this._queue, (other) => priority <= other.priority);
      if (i === -1 && weight <= this._value) {
        this._dispatchItem(task2);
      } else {
        this._queue.splice(i + 1, 0, task2);
      }
    });
  }
  runExclusive(callback_1) {
    return __awaiter$2(this, arguments, void 0, function* (callback, weight = 1, priority = 0) {
      const [value, release] = yield this.acquire(weight, priority);
      try {
        return yield callback(value);
      } finally {
        release();
      }
    });
  }
  waitForUnlock(weight = 1, priority = 0) {
    if (weight <= 0)
      throw new Error(`invalid weight ${weight}: must be positive`);
    if (this._couldLockImmediately(weight, priority)) {
      return Promise.resolve();
    } else {
      return new Promise((resolve2) => {
        if (!this._weightedWaiters[weight - 1])
          this._weightedWaiters[weight - 1] = [];
        insertSorted(this._weightedWaiters[weight - 1], { resolve: resolve2, priority });
      });
    }
  }
  isLocked() {
    return this._value <= 0;
  }
  getValue() {
    return this._value;
  }
  setValue(value) {
    this._value = value;
    this._dispatchQueue();
  }
  release(weight = 1) {
    if (weight <= 0)
      throw new Error(`invalid weight ${weight}: must be positive`);
    this._value += weight;
    this._dispatchQueue();
  }
  cancel() {
    this._queue.forEach((entry) => entry.reject(this._cancelError));
    this._queue = [];
  }
  _dispatchQueue() {
    this._drainUnlockWaiters();
    while (this._queue.length > 0 && this._queue[0].weight <= this._value) {
      this._dispatchItem(this._queue.shift());
      this._drainUnlockWaiters();
    }
  }
  _dispatchItem(item) {
    const previousValue = this._value;
    this._value -= item.weight;
    item.resolve([previousValue, this._newReleaser(item.weight)]);
  }
  _newReleaser(weight) {
    let called = false;
    return () => {
      if (called)
        return;
      called = true;
      this.release(weight);
    };
  }
  _drainUnlockWaiters() {
    if (this._queue.length === 0) {
      for (let weight = this._value; weight > 0; weight--) {
        const waiters = this._weightedWaiters[weight - 1];
        if (!waiters)
          continue;
        waiters.forEach((waiter) => waiter.resolve());
        this._weightedWaiters[weight - 1] = [];
      }
    } else {
      const queuedPriority = this._queue[0].priority;
      for (let weight = this._value; weight > 0; weight--) {
        const waiters = this._weightedWaiters[weight - 1];
        if (!waiters)
          continue;
        const i = waiters.findIndex((waiter) => waiter.priority <= queuedPriority);
        (i === -1 ? waiters : waiters.splice(0, i)).forEach((waiter) => waiter.resolve());
      }
    }
  }
  _couldLockImmediately(weight, priority) {
    return (this._queue.length === 0 || this._queue[0].priority < priority) && weight <= this._value;
  }
};
function insertSorted(a, v) {
  const i = findIndexFromEnd(a, (other) => v.priority <= other.priority);
  a.splice(i + 1, 0, v);
}
function findIndexFromEnd(a, predicate) {
  for (let i = a.length - 1; i >= 0; i--) {
    if (predicate(a[i])) {
      return i;
    }
  }
  return -1;
}
var __awaiter$1 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P || (P = Promise))(function(resolve2, reject2) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject2(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject2(e);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Mutex = class {
  constructor(cancelError) {
    this._semaphore = new Semaphore(1, cancelError);
  }
  acquire() {
    return __awaiter$1(this, arguments, void 0, function* (priority = 0) {
      const [, releaser] = yield this._semaphore.acquire(1, priority);
      return releaser;
    });
  }
  runExclusive(callback, priority = 0) {
    return this._semaphore.runExclusive(() => callback(), 1, priority);
  }
  isLocked() {
    return this._semaphore.isLocked();
  }
  waitForUnlock(priority = 0) {
    return this._semaphore.waitForUnlock(1, priority);
  }
  release() {
    if (this._semaphore.isLocked())
      this._semaphore.release();
  }
  cancel() {
    return this._semaphore.cancel();
  }
};

// node_modules/diff-match-patch-es/dist/index.mjs
var defaultOptions = /* @__PURE__ */ Object.freeze({
  diffTimeout: 1,
  diffEditCost: 4,
  matchThreshold: 0.5,
  matchDistance: 1e3,
  patchDeleteThreshold: 0.5,
  patchMargin: 4,
  matchMaxBits: 32
});
function resolveOptions(options) {
  if (options == null ? void 0 : options.__resolved)
    return options;
  const resolved = {
    ...defaultOptions,
    ...options
  };
  Object.defineProperty(resolved, "__resolved", { value: true, enumerable: false });
  return resolved;
}
var DIFF_DELETE = -1;
var DIFF_INSERT = 1;
var DIFF_EQUAL = 0;
function createDiff(op, text2) {
  return [op, text2];
}
function diffMain(text1, text2, options, opt_checklines = true, opt_deadline) {
  const resolved = resolveOptions(options);
  if (typeof opt_deadline == "undefined") {
    if (resolved.diffTimeout <= 0)
      opt_deadline = Number.MAX_VALUE;
    else
      opt_deadline = (/* @__PURE__ */ new Date()).getTime() + resolved.diffTimeout * 1e3;
  }
  const deadline = opt_deadline;
  if (text1 == null || text2 == null)
    throw new Error("Null input. (diff_main)");
  if (text1 === text2) {
    if (text1)
      return [createDiff(DIFF_EQUAL, text1)];
    return [];
  }
  const checklines = opt_checklines;
  let commonlength = diffCommonPrefix(text1, text2);
  const commonprefix = text1.substring(0, commonlength);
  text1 = text1.substring(commonlength);
  text2 = text2.substring(commonlength);
  commonlength = diffCommonSuffix(text1, text2);
  const commonsuffix = text1.substring(text1.length - commonlength);
  text1 = text1.substring(0, text1.length - commonlength);
  text2 = text2.substring(0, text2.length - commonlength);
  const diffs = diffCompute(text1, text2, resolved, checklines, deadline);
  if (commonprefix)
    diffs.unshift(createDiff(DIFF_EQUAL, commonprefix));
  if (commonsuffix)
    diffs.push(createDiff(DIFF_EQUAL, commonsuffix));
  diffCleanupMerge(diffs);
  return diffs;
}
function diffCompute(text1, text2, options, checklines, deadline) {
  let diffs;
  if (!text1) {
    return [createDiff(DIFF_INSERT, text2)];
  }
  if (!text2) {
    return [createDiff(DIFF_DELETE, text1)];
  }
  const longtext = text1.length > text2.length ? text1 : text2;
  const shorttext = text1.length > text2.length ? text2 : text1;
  const i = longtext.indexOf(shorttext);
  if (i !== -1) {
    diffs = [createDiff(DIFF_INSERT, longtext.substring(0, i)), createDiff(DIFF_EQUAL, shorttext), createDiff(DIFF_INSERT, longtext.substring(i + shorttext.length))];
    if (text1.length > text2.length)
      diffs[0][0] = diffs[2][0] = DIFF_DELETE;
    return diffs;
  }
  if (shorttext.length === 1) {
    return [createDiff(DIFF_DELETE, text1), createDiff(DIFF_INSERT, text2)];
  }
  const hm = diffHalfMatch(text1, text2, options);
  if (hm) {
    const text1_a = hm[0];
    const text1_b = hm[1];
    const text2_a = hm[2];
    const text2_b = hm[3];
    const mid_common = hm[4];
    const diffs_a = diffMain(text1_a, text2_a, options, checklines, deadline);
    const diffs_b = diffMain(text1_b, text2_b, options, checklines, deadline);
    return diffs_a.concat([createDiff(DIFF_EQUAL, mid_common)], diffs_b);
  }
  if (checklines && text1.length > 100 && text2.length > 100)
    return diffLineMode(text1, text2, options, deadline);
  return diffBisect(text1, text2, options, deadline);
}
function diffLineMode(text1, text2, options, deadline) {
  const a = diffLinesToChars(text1, text2);
  text1 = a.chars1;
  text2 = a.chars2;
  const linearray = a.lineArray;
  const diffs = diffMain(text1, text2, options, false, deadline);
  diffCharsToLines(diffs, linearray);
  diffCleanupSemantic(diffs);
  diffs.push(createDiff(DIFF_EQUAL, ""));
  let pointer = 0;
  let count_delete = 0;
  let count_insert = 0;
  let text_delete = "";
  let text_insert = "";
  while (pointer < diffs.length) {
    switch (diffs[pointer][0]) {
      case DIFF_INSERT:
        count_insert++;
        text_insert += diffs[pointer][1];
        break;
      case DIFF_DELETE:
        count_delete++;
        text_delete += diffs[pointer][1];
        break;
      case DIFF_EQUAL:
        if (count_delete >= 1 && count_insert >= 1) {
          diffs.splice(pointer - count_delete - count_insert, count_delete + count_insert);
          pointer = pointer - count_delete - count_insert;
          const subDiff = diffMain(text_delete, text_insert, options, false, deadline);
          for (let j = subDiff.length - 1; j >= 0; j--)
            diffs.splice(pointer, 0, subDiff[j]);
          pointer = pointer + subDiff.length;
        }
        count_insert = 0;
        count_delete = 0;
        text_delete = "";
        text_insert = "";
        break;
    }
    pointer++;
  }
  diffs.pop();
  return diffs;
}
function diffBisect(text1, text2, options, deadline) {
  const text1_length = text1.length;
  const text2_length = text2.length;
  const max_d = Math.ceil((text1_length + text2_length) / 2);
  const v_offset = max_d;
  const v_length = 2 * max_d;
  const v1 = new Array(v_length);
  const v2 = new Array(v_length);
  for (let x = 0; x < v_length; x++) {
    v1[x] = -1;
    v2[x] = -1;
  }
  v1[v_offset + 1] = 0;
  v2[v_offset + 1] = 0;
  const delta = text1_length - text2_length;
  const front = delta % 2 !== 0;
  let k1start = 0;
  let k1end = 0;
  let k2start = 0;
  let k2end = 0;
  for (let d = 0; d < max_d; d++) {
    if ((/* @__PURE__ */ new Date()).getTime() > deadline)
      break;
    for (let k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {
      const k1_offset = v_offset + k1;
      let x1;
      if (k1 === -d || k1 !== d && v1[k1_offset - 1] < v1[k1_offset + 1])
        x1 = v1[k1_offset + 1];
      else
        x1 = v1[k1_offset - 1] + 1;
      let y1 = x1 - k1;
      while (x1 < text1_length && y1 < text2_length && text1.charAt(x1) === text2.charAt(y1)) {
        x1++;
        y1++;
      }
      v1[k1_offset] = x1;
      if (x1 > text1_length) {
        k1end += 2;
      } else if (y1 > text2_length) {
        k1start += 2;
      } else if (front) {
        const k2_offset = v_offset + delta - k1;
        if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] !== -1) {
          const x2 = text1_length - v2[k2_offset];
          if (x1 >= x2) {
            return diffBisectSplit(text1, text2, options, x1, y1, deadline);
          }
        }
      }
    }
    for (let k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {
      const k2_offset = v_offset + k2;
      let x2;
      if (k2 === -d || k2 !== d && v2[k2_offset - 1] < v2[k2_offset + 1])
        x2 = v2[k2_offset + 1];
      else
        x2 = v2[k2_offset - 1] + 1;
      let y2 = x2 - k2;
      while (x2 < text1_length && y2 < text2_length && text1.charAt(text1_length - x2 - 1) === text2.charAt(text2_length - y2 - 1)) {
        x2++;
        y2++;
      }
      v2[k2_offset] = x2;
      if (x2 > text1_length) {
        k2end += 2;
      } else if (y2 > text2_length) {
        k2start += 2;
      } else if (!front) {
        const k1_offset = v_offset + delta - k2;
        if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] !== -1) {
          const x1 = v1[k1_offset];
          const y1 = v_offset + x1 - k1_offset;
          x2 = text1_length - x2;
          if (x1 >= x2) {
            return diffBisectSplit(text1, text2, options, x1, y1, deadline);
          }
        }
      }
    }
  }
  return [createDiff(DIFF_DELETE, text1), createDiff(DIFF_INSERT, text2)];
}
function diffBisectSplit(text1, text2, options, x, y, deadline) {
  const text1a = text1.substring(0, x);
  const text2a = text2.substring(0, y);
  const text1b = text1.substring(x);
  const text2b = text2.substring(y);
  const diffs = diffMain(text1a, text2a, options, false, deadline);
  const diffsb = diffMain(text1b, text2b, options, false, deadline);
  return diffs.concat(diffsb);
}
function diffLinesToChars(text1, text2) {
  const lineArray = [];
  const lineHash = {};
  let maxLines = 4e4;
  lineArray[0] = "";
  function diffLinesToCharsMunge(text3) {
    let chars = "";
    let lineStart = 0;
    let lineEnd = -1;
    let lineArrayLength = lineArray.length;
    while (lineEnd < text3.length - 1) {
      lineEnd = text3.indexOf("\n", lineStart);
      if (lineEnd === -1)
        lineEnd = text3.length - 1;
      let line = text3.substring(lineStart, lineEnd + 1);
      if (lineHash.hasOwnProperty ? Object.prototype.hasOwnProperty.call(lineHash, line) : lineHash[line] !== void 0) {
        chars += String.fromCharCode(lineHash[line]);
      } else {
        if (lineArrayLength === maxLines) {
          line = text3.substring(lineStart);
          lineEnd = text3.length;
        }
        chars += String.fromCharCode(lineArrayLength);
        lineHash[line] = lineArrayLength;
        lineArray[lineArrayLength++] = line;
      }
      lineStart = lineEnd + 1;
    }
    return chars;
  }
  const chars1 = diffLinesToCharsMunge(text1);
  maxLines = 65535;
  const chars2 = diffLinesToCharsMunge(text2);
  return { chars1, chars2, lineArray };
}
function diffCharsToLines(diffs, lineArray) {
  for (let i = 0; i < diffs.length; i++) {
    const chars = diffs[i][1];
    const text2 = [];
    for (let j = 0; j < chars.length; j++)
      text2[j] = lineArray[chars.charCodeAt(j)];
    diffs[i][1] = text2.join("");
  }
}
function diffCommonPrefix(text1, text2) {
  if (!text1 || !text2 || text1.charAt(0) !== text2.charAt(0))
    return 0;
  let pointermin = 0;
  let pointermax = Math.min(text1.length, text2.length);
  let pointermid = pointermax;
  let pointerstart = 0;
  while (pointermin < pointermid) {
    if (text1.substring(pointerstart, pointermid) === text2.substring(pointerstart, pointermid)) {
      pointermin = pointermid;
      pointerstart = pointermin;
    } else {
      pointermax = pointermid;
    }
    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
  }
  return pointermid;
}
function diffCommonSuffix(text1, text2) {
  if (!text1 || !text2 || text1.charAt(text1.length - 1) !== text2.charAt(text2.length - 1))
    return 0;
  let pointermin = 0;
  let pointermax = Math.min(text1.length, text2.length);
  let pointermid = pointermax;
  let pointerend = 0;
  while (pointermin < pointermid) {
    if (text1.substring(text1.length - pointermid, text1.length - pointerend) === text2.substring(text2.length - pointermid, text2.length - pointerend)) {
      pointermin = pointermid;
      pointerend = pointermin;
    } else {
      pointermax = pointermid;
    }
    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
  }
  return pointermid;
}
function diffCommonOverlap(text1, text2) {
  const text1_length = text1.length;
  const text2_length = text2.length;
  if (text1_length === 0 || text2_length === 0)
    return 0;
  if (text1_length > text2_length)
    text1 = text1.substring(text1_length - text2_length);
  else if (text1_length < text2_length)
    text2 = text2.substring(0, text1_length);
  const text_length = Math.min(text1_length, text2_length);
  if (text1 === text2)
    return text_length;
  let best = 0;
  let length3 = 1;
  while (true) {
    const pattern = text1.substring(text_length - length3);
    const found = text2.indexOf(pattern);
    if (found === -1)
      return best;
    length3 += found;
    if (found === 0 || text1.substring(text_length - length3) === text2.substring(0, length3)) {
      best = length3;
      length3++;
    }
  }
}
function diffHalfMatch(text1, text2, options) {
  if (options.diffTimeout <= 0) {
    return null;
  }
  const longtext = text1.length > text2.length ? text1 : text2;
  const shorttext = text1.length > text2.length ? text2 : text1;
  if (longtext.length < 4 || shorttext.length * 2 < longtext.length)
    return null;
  function diffHalfMatchI(longtext2, shorttext2, i) {
    const seed = longtext2.substring(i, i + Math.floor(longtext2.length / 4));
    let j = -1;
    let best_common = "";
    let best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;
    while ((j = shorttext2.indexOf(seed, j + 1)) !== -1) {
      const prefixLength = diffCommonPrefix(longtext2.substring(i), shorttext2.substring(j));
      const suffixLength = diffCommonSuffix(longtext2.substring(0, i), shorttext2.substring(0, j));
      if (best_common.length < suffixLength + prefixLength) {
        best_common = shorttext2.substring(j - suffixLength, j) + shorttext2.substring(j, j + prefixLength);
        best_longtext_a = longtext2.substring(0, i - suffixLength);
        best_longtext_b = longtext2.substring(i + prefixLength);
        best_shorttext_a = shorttext2.substring(0, j - suffixLength);
        best_shorttext_b = shorttext2.substring(j + prefixLength);
      }
    }
    if (best_common.length * 2 >= longtext2.length)
      return [best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b, best_common];
    else
      return null;
  }
  const hm1 = diffHalfMatchI(longtext, shorttext, Math.ceil(longtext.length / 4));
  const hm2 = diffHalfMatchI(longtext, shorttext, Math.ceil(longtext.length / 2));
  let hm;
  if (!hm1 && !hm2) {
    return null;
  } else if (!hm2) {
    hm = hm1;
  } else if (!hm1) {
    hm = hm2;
  } else {
    hm = hm1[4].length > hm2[4].length ? hm1 : hm2;
  }
  let text1_a, text1_b, text2_a, text2_b;
  if (text1.length > text2.length) {
    text1_a = hm[0];
    text1_b = hm[1];
    text2_a = hm[2];
    text2_b = hm[3];
  } else {
    text2_a = hm[0];
    text2_b = hm[1];
    text1_a = hm[2];
    text1_b = hm[3];
  }
  const mid_common = hm[4];
  return [text1_a, text1_b, text2_a, text2_b, mid_common];
}
function diffCleanupSemantic(diffs) {
  let changes = false;
  const equalities = [];
  let equalitiesLength = 0;
  let lastEquality = null;
  let pointer = 0;
  let length_insertions1 = 0;
  let length_deletions1 = 0;
  let length_insertions2 = 0;
  let length_deletions2 = 0;
  while (pointer < diffs.length) {
    if (diffs[pointer][0] === DIFF_EQUAL) {
      equalities[equalitiesLength++] = pointer;
      length_insertions1 = length_insertions2;
      length_deletions1 = length_deletions2;
      length_insertions2 = 0;
      length_deletions2 = 0;
      lastEquality = diffs[pointer][1];
    } else {
      if (diffs[pointer][0] === DIFF_INSERT)
        length_insertions2 += diffs[pointer][1].length;
      else
        length_deletions2 += diffs[pointer][1].length;
      if (lastEquality && lastEquality.length <= Math.max(length_insertions1, length_deletions1) && lastEquality.length <= Math.max(length_insertions2, length_deletions2)) {
        diffs.splice(equalities[equalitiesLength - 1], 0, createDiff(DIFF_DELETE, lastEquality));
        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;
        equalitiesLength--;
        equalitiesLength--;
        pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;
        length_insertions1 = 0;
        length_deletions1 = 0;
        length_insertions2 = 0;
        length_deletions2 = 0;
        lastEquality = null;
        changes = true;
      }
    }
    pointer++;
  }
  if (changes)
    diffCleanupMerge(diffs);
  diffCleanupSemanticLossless(diffs);
  pointer = 1;
  while (pointer < diffs.length) {
    if (diffs[pointer - 1][0] === DIFF_DELETE && diffs[pointer][0] === DIFF_INSERT) {
      const deletion = diffs[pointer - 1][1];
      const insertion = diffs[pointer][1];
      const overlap_length1 = diffCommonOverlap(deletion, insertion);
      const overlap_length2 = diffCommonOverlap(insertion, deletion);
      if (overlap_length1 >= overlap_length2) {
        if (overlap_length1 >= deletion.length / 2 || overlap_length1 >= insertion.length / 2) {
          diffs.splice(pointer, 0, createDiff(DIFF_EQUAL, insertion.substring(0, overlap_length1)));
          diffs[pointer - 1][1] = deletion.substring(0, deletion.length - overlap_length1);
          diffs[pointer + 1][1] = insertion.substring(overlap_length1);
          pointer++;
        }
      } else {
        if (overlap_length2 >= deletion.length / 2 || overlap_length2 >= insertion.length / 2) {
          diffs.splice(pointer, 0, createDiff(DIFF_EQUAL, deletion.substring(0, overlap_length2)));
          diffs[pointer - 1][0] = DIFF_INSERT;
          diffs[pointer - 1][1] = insertion.substring(0, insertion.length - overlap_length2);
          diffs[pointer + 1][0] = DIFF_DELETE;
          diffs[pointer + 1][1] = deletion.substring(overlap_length2);
          pointer++;
        }
      }
      pointer++;
    }
    pointer++;
  }
}
var nonAlphaNumericRegex_ = /[^a-zA-Z0-9]/;
var whitespaceRegex_ = /\s/;
var linebreakRegex_ = /[\r\n]/;
var blanklineEndRegex_ = /\n\r?\n$/;
var blanklineStartRegex_ = /^\r?\n\r?\n/;
function diffCleanupSemanticLossless(diffs) {
  function diffCleanupSemanticScore(one, two) {
    if (!one || !two) {
      return 6;
    }
    const char1 = one.charAt(one.length - 1);
    const char2 = two.charAt(0);
    const nonAlphaNumeric1 = char1.match(nonAlphaNumericRegex_);
    const nonAlphaNumeric2 = char2.match(nonAlphaNumericRegex_);
    const whitespace1 = nonAlphaNumeric1 && char1.match(whitespaceRegex_);
    const whitespace2 = nonAlphaNumeric2 && char2.match(whitespaceRegex_);
    const lineBreak1 = whitespace1 && char1.match(linebreakRegex_);
    const lineBreak2 = whitespace2 && char2.match(linebreakRegex_);
    const blankLine1 = lineBreak1 && one.match(blanklineEndRegex_);
    const blankLine2 = lineBreak2 && two.match(blanklineStartRegex_);
    if (blankLine1 || blankLine2) {
      return 5;
    } else if (lineBreak1 || lineBreak2) {
      return 4;
    } else if (nonAlphaNumeric1 && !whitespace1 && whitespace2) {
      return 3;
    } else if (whitespace1 || whitespace2) {
      return 2;
    } else if (nonAlphaNumeric1 || nonAlphaNumeric2) {
      return 1;
    }
    return 0;
  }
  let pointer = 1;
  while (pointer < diffs.length - 1) {
    if (diffs[pointer - 1][0] === DIFF_EQUAL && diffs[pointer + 1][0] === DIFF_EQUAL) {
      let equality1 = diffs[pointer - 1][1];
      let edit = diffs[pointer][1];
      let equality2 = diffs[pointer + 1][1];
      const commonOffset = diffCommonSuffix(equality1, edit);
      if (commonOffset) {
        const commonString = edit.substring(edit.length - commonOffset);
        equality1 = equality1.substring(0, equality1.length - commonOffset);
        edit = commonString + edit.substring(0, edit.length - commonOffset);
        equality2 = commonString + equality2;
      }
      let bestEquality1 = equality1;
      let bestEdit = edit;
      let bestEquality2 = equality2;
      let bestScore = diffCleanupSemanticScore(equality1, edit) + diffCleanupSemanticScore(edit, equality2);
      while (edit.charAt(0) === equality2.charAt(0)) {
        equality1 += edit.charAt(0);
        edit = edit.substring(1) + equality2.charAt(0);
        equality2 = equality2.substring(1);
        const score = diffCleanupSemanticScore(equality1, edit) + diffCleanupSemanticScore(edit, equality2);
        if (score >= bestScore) {
          bestScore = score;
          bestEquality1 = equality1;
          bestEdit = edit;
          bestEquality2 = equality2;
        }
      }
      if (diffs[pointer - 1][1] !== bestEquality1) {
        if (bestEquality1) {
          diffs[pointer - 1][1] = bestEquality1;
        } else {
          diffs.splice(pointer - 1, 1);
          pointer--;
        }
        diffs[pointer][1] = bestEdit;
        if (bestEquality2) {
          diffs[pointer + 1][1] = bestEquality2;
        } else {
          diffs.splice(pointer + 1, 1);
          pointer--;
        }
      }
    }
    pointer++;
  }
}
function diffCleanupEfficiency(diffs, options = {}) {
  const {
    diffEditCost = defaultOptions.diffEditCost
  } = options;
  let changes = false;
  const equalities = [];
  let equalitiesLength = 0;
  let lastEquality = null;
  let pointer = 0;
  let pre_ins = false;
  let pre_del = false;
  let post_ins = false;
  let post_del = false;
  while (pointer < diffs.length) {
    if (diffs[pointer][0] === DIFF_EQUAL) {
      if (diffs[pointer][1].length < diffEditCost && (post_ins || post_del)) {
        equalities[equalitiesLength++] = pointer;
        pre_ins = post_ins;
        pre_del = post_del;
        lastEquality = diffs[pointer][1];
      } else {
        equalitiesLength = 0;
        lastEquality = null;
      }
      post_ins = post_del = false;
    } else {
      let booleanCount = function(...args2) {
        return args2.filter(Boolean).length;
      };
      if (diffs[pointer][0] === DIFF_DELETE)
        post_del = true;
      else
        post_ins = true;
      if (lastEquality && (pre_ins && pre_del && post_ins && post_del || lastEquality.length < diffEditCost / 2 && booleanCount(pre_ins, pre_del, post_ins, post_del) === 3)) {
        diffs.splice(equalities[equalitiesLength - 1], 0, createDiff(DIFF_DELETE, lastEquality));
        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;
        equalitiesLength--;
        lastEquality = null;
        if (pre_ins && pre_del) {
          post_ins = post_del = true;
          equalitiesLength = 0;
        } else {
          equalitiesLength--;
          pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;
          post_ins = post_del = false;
        }
        changes = true;
      }
    }
    pointer++;
  }
  if (changes)
    diffCleanupMerge(diffs);
}
function diffCleanupMerge(diffs) {
  diffs.push(createDiff(DIFF_EQUAL, ""));
  let pointer = 0;
  let count_delete = 0;
  let count_insert = 0;
  let text_delete = "";
  let text_insert = "";
  let commonlength;
  while (pointer < diffs.length) {
    switch (diffs[pointer][0]) {
      case DIFF_INSERT:
        count_insert++;
        text_insert += diffs[pointer][1];
        pointer++;
        break;
      case DIFF_DELETE:
        count_delete++;
        text_delete += diffs[pointer][1];
        pointer++;
        break;
      case DIFF_EQUAL:
        if (count_delete + count_insert > 1) {
          if (count_delete !== 0 && count_insert !== 0) {
            commonlength = diffCommonPrefix(text_insert, text_delete);
            if (commonlength !== 0) {
              if (pointer - count_delete - count_insert > 0 && diffs[pointer - count_delete - count_insert - 1][0] === DIFF_EQUAL) {
                diffs[pointer - count_delete - count_insert - 1][1] += text_insert.substring(0, commonlength);
              } else {
                diffs.splice(0, 0, createDiff(DIFF_EQUAL, text_insert.substring(0, commonlength)));
                pointer++;
              }
              text_insert = text_insert.substring(commonlength);
              text_delete = text_delete.substring(commonlength);
            }
            commonlength = diffCommonSuffix(text_insert, text_delete);
            if (commonlength !== 0) {
              diffs[pointer][1] = text_insert.substring(text_insert.length - commonlength) + diffs[pointer][1];
              text_insert = text_insert.substring(0, text_insert.length - commonlength);
              text_delete = text_delete.substring(0, text_delete.length - commonlength);
            }
          }
          pointer -= count_delete + count_insert;
          diffs.splice(pointer, count_delete + count_insert);
          if (text_delete.length) {
            diffs.splice(pointer, 0, createDiff(DIFF_DELETE, text_delete));
            pointer++;
          }
          if (text_insert.length) {
            diffs.splice(pointer, 0, createDiff(DIFF_INSERT, text_insert));
            pointer++;
          }
          pointer++;
        } else if (pointer !== 0 && diffs[pointer - 1][0] === DIFF_EQUAL) {
          diffs[pointer - 1][1] += diffs[pointer][1];
          diffs.splice(pointer, 1);
        } else {
          pointer++;
        }
        count_insert = 0;
        count_delete = 0;
        text_delete = "";
        text_insert = "";
        break;
    }
  }
  if (diffs[diffs.length - 1][1] === "")
    diffs.pop();
  let changes = false;
  pointer = 1;
  while (pointer < diffs.length - 1) {
    if (diffs[pointer - 1][0] === DIFF_EQUAL && diffs[pointer + 1][0] === DIFF_EQUAL) {
      if (diffs[pointer][1].substring(diffs[pointer][1].length - diffs[pointer - 1][1].length) === diffs[pointer - 1][1]) {
        diffs[pointer][1] = diffs[pointer - 1][1] + diffs[pointer][1].substring(0, diffs[pointer][1].length - diffs[pointer - 1][1].length);
        diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];
        diffs.splice(pointer - 1, 1);
        changes = true;
      } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) === diffs[pointer + 1][1]) {
        diffs[pointer - 1][1] += diffs[pointer + 1][1];
        diffs[pointer][1] = diffs[pointer][1].substring(diffs[pointer + 1][1].length) + diffs[pointer + 1][1];
        diffs.splice(pointer + 1, 1);
        changes = true;
      }
    }
    pointer++;
  }
  if (changes)
    diffCleanupMerge(diffs);
}

// src/sharedEntities/sharedDocument.ts
var _SharedDocument = class extends SharedEntity {
  constructor(opts, plugin) {
    var _a;
    super(plugin);
    this.mutex = new Mutex();
    if (opts.path) {
      this._path = (0, import_obsidian9.normalizePath)(opts.path);
      const file = this.plugin.app.vault.getAbstractFileByPath((0, import_obsidian9.normalizePath)(opts.path));
      if (file instanceof import_obsidian9.TFile) {
        this._file = file;
      } else {
        showNotice("ERROR creating sharedDoc");
      }
    }
    if (opts.id) {
      this._shareId = opts.id;
    }
    this.yDoc = (_a = opts.yDoc) != null ? _a : new Doc();
    this.yDoc.on("update", (update, origin, yDoc, tr) => {
      if (tr.local && this.isPermanent) {
        plugin.serverSync.sendUpdate(this, update);
      }
    });
    _SharedDocument._sharedEntites.push(this);
    this._extensions = new PeerdraftRecord();
    this._extensions.on("delete", () => {
      if (this._extensions.size === 0 && this._webRTCProvider) {
        this._webRTCProvider.awareness.setLocalState({});
      }
    });
    this.getContentFragment().observe(async () => {
      if (this._file && this._extensions.size === 0) {
        (0, import_obsidian9.debounce)(() => {
          this.mutex.runExclusive(async () => {
            const yDocContent = this.getValue();
            const fileContent = await this.plugin.app.vault.read(this._file);
            if (yDocContent != fileContent) {
              this.lastUpdateTriggeredByDocChange = new Date().valueOf();
              await this.plugin.app.vault.modify(this._file, yDocContent, {
                mtime: this.lastUpdateTriggeredByDocChange
              });
            }
          });
        }, 1e3, true)();
      }
    });
    this.plugin.registerEvent(this.plugin.app.vault.on("modify", async (file) => {
      if (this.file === file && this._extensions.size === 0 && this.file.stat.mtime != this.lastUpdateTriggeredByDocChange) {
        this.mutex.runExclusive(async () => {
          const yDocContent = this.getValue();
          const fileContent = await this.plugin.app.vault.read(this._file);
          if (yDocContent != fileContent) {
            const diffs = diffMain(yDocContent, fileContent);
            diffCleanupEfficiency(diffs);
            const content = this.getContentFragment();
            let pos = 0;
            this.yDoc.transact(() => {
              for (const diff of diffs) {
                const text2 = diff[1];
                const length3 = text2.length;
                switch (diff[0]) {
                  case 0:
                    {
                      pos += length3;
                    }
                    break;
                  case -1:
                    {
                      content.delete(pos, length3);
                    }
                    break;
                  case 1:
                    {
                      content.insert(pos, text2);
                      pos += length3;
                    }
                    break;
                }
              }
            });
          }
        });
      }
    }));
    addIsSharedClass(this.path, this.plugin);
  }
  static async fromView(view, plugin, opts = { permanent: false }) {
    if (!view.file)
      return;
    if (this.findByPath(view.file.path))
      return;
    const doc2 = await this.fromTFile(view.file, opts, plugin);
    if (doc2) {
      doc2.startWebRTCSync();
      if (doc2.isPermanent && doc2._webRTCProvider) {
        doc2.getOwnerFragment().insert(0, doc2._webRTCProvider.awareness.clientID.toFixed(0));
      } else {
        doc2.addStatusBarEntry();
        pinLeaf(view.leaf);
      }
      navigator.clipboard.writeText(plugin.settings.basePath + "/cm/" + doc2.shareId);
      showNotice("Collaboration started for " + doc2.path + ". Link copied to Clipboard.");
    }
    return doc2;
  }
  static async fromPermanentShareDocument(pd, plugin) {
    if (this.findByPath(pd.path))
      return;
    const file = plugin.app.vault.getAbstractFileByPath((0, import_obsidian9.normalizePath)(pd.path));
    if (!file) {
      showNotice("File " + pd.path + " not found. Creating it now.");
      await SharedFolder.getOrCreatePath(path2.dirname(pd.path), plugin);
      const file2 = await plugin.app.vault.create(pd.path, "");
      if (!file2) {
        showNotice("Error creating file " + pd.path + ".");
        return;
      }
    }
    const doc2 = new _SharedDocument({
      path: pd.path
    }, plugin);
    doc2._isPermanent = true;
    doc2._shareId = pd.shareId;
    await doc2.startIndexedDBSync();
    doc2.syncWithServer();
    plugin.activeStreamClient.add([doc2.shareId]);
    return doc2;
  }
  static async fromShareURL(url, plugin) {
    const id2 = url.split("/").pop();
    if (!id2 || !id2.match("^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")) {
      showNotice("No valid peerdraft link");
      return;
    }
    const existingDoc = _SharedDocument.findById(id2);
    if (existingDoc) {
      showNotice("This share is already active: " + existingDoc.path);
      return;
    }
    const isPermanent = await plugin.serverAPI.isSessionPermanent(id2);
    const yDoc = new Doc();
    showNotice("Trying to initiate sync...");
    const doc2 = new _SharedDocument({
      id: id2,
      yDoc
    }, plugin);
    await new Promise((resolve2) => {
      doc2.startWebRTCSync();
      if (isPermanent) {
        doc2.syncWithServer();
      }
      yDoc.once("update", () => {
        resolve2();
      });
    });
    const docFilename = doc2.yDoc.getText("originalFilename").toString();
    let initialFileName = `_peerdraft_session_${id2}_${generateRandomString()}.md`;
    if (docFilename != "") {
      const fileExists = plugin.app.vault.getAbstractFileByPath((0, import_obsidian9.normalizePath)(docFilename));
      if (!fileExists) {
        initialFileName = docFilename;
      } else {
        initialFileName = `_peerdraft_${generateRandomString()}_${docFilename}`;
      }
    }
    const parent = plugin.settings.root || plugin.app.fileManager.getNewFileParent("", initialFileName).path;
    const filePath = path2.join(parent, initialFileName);
    const folder = await SharedFolder.getOrCreatePath(path2.dirname(filePath), plugin);
    const file = await plugin.app.vault.create(filePath, doc2.getValue());
    addIsSharedClass(file.path, plugin);
    doc2._file = file;
    doc2._path = file.path;
    if (isPermanent) {
      doc2._isPermanent = true;
      await add(doc2, plugin);
      await doc2.startIndexedDBSync();
      plugin.activeStreamClient.add([doc2.shareId]);
    }
    const leaf = await openFileInNewTab(file, plugin.app.workspace);
    doc2.addStatusBarEntry();
    doc2.addExtensionToLeaf(leaf.id);
    pinLeaf(leaf);
    showNotice("Joined Session in " + doc2.path + ".");
    return doc2;
  }
  static async fromIdAndPath(id2, location2, plugin) {
    const normalizedPath = (0, import_obsidian9.normalizePath)(location2);
    const existingDoc = _SharedDocument.findById(id2);
    if (existingDoc) {
      showNotice("This share is already active: " + existingDoc.path);
      return;
    }
    await SharedFolder.getOrCreatePath(path2.dirname(normalizedPath), plugin);
    showNotice("Creating new synced file " + normalizedPath);
    const ydoc = await plugin.serverSync.requestDocument(id2);
    const doc2 = new _SharedDocument({
      id: id2,
      yDoc: ydoc
    }, plugin);
    doc2._path = normalizedPath;
    const file = await plugin.app.vault.create(normalizedPath, ydoc.getText("content").toString());
    doc2._file = file;
    doc2.syncWithServer();
    await doc2.setPermanent();
    await doc2.startIndexedDBSync();
    addIsSharedClass(doc2.path, plugin);
  }
  static async fromTFile(file, opts, plugin) {
    if (!["md", "MD"].contains(file.extension))
      return;
    const existing = _SharedDocument.findByPath(file.path);
    if (existing)
      return existing;
    const doc2 = new _SharedDocument({ path: file.path }, plugin);
    const leafIds = getLeafIdsByPath(file.path, plugin.pws);
    if (leafIds.length > 0) {
      const content = plugin.app.workspace.getLeafById(leafIds[0]).view.editor.getValue();
      doc2.getContentFragment().insert(0, content);
    } else {
      const content = await plugin.app.vault.read(file);
      doc2.getContentFragment().insert(0, content);
    }
    doc2.yDoc.getText("originalFilename").insert(0, file.name);
    if (opts.permanent) {
      await doc2.initServerYDoc();
      await doc2.setPermanent();
      doc2.startIndexedDBSync();
    } else {
      doc2._shareId = createRandomId();
    }
    for (const id2 of leafIds) {
      doc2.addExtensionToLeaf(id2);
    }
    showNotice(`Inititialized share for ${file.path}`);
    return doc2;
  }
  static findByPath(path4) {
    return super.findByPath(path4);
  }
  static findById(id2) {
    return super.findById(id2);
  }
  static getAll() {
    return super.getAll();
  }
  get file() {
    return this._file;
  }
  calculateHash() {
    const text2 = this.getContentFragment().toString();
    return calculateHash(text2);
  }
  startWebRTCSync() {
    return super.startWebRTCSync((provider) => {
      provider.awareness.setLocalStateField("user", {
        name: this.plugin.settings.name,
        color: _SharedDocument._userColor.dark,
        colorLight: _SharedDocument._userColor.light
      });
      provider.awareness.on("update", async (msg) => {
        var _a, _b, _c, _d;
        const removed = (_a = msg.removed) != null ? _a : [];
        if (removed && removed.length > 0) {
          const removedStrings = removed.map((id2) => {
            return id2.toFixed(0);
          });
          const owner = this.getOwnerFragment().toString();
          if (owner != provider.awareness.clientID.toString()) {
            if (removedStrings.includes(owner) && !this.isPermanent) {
              showNotice("Shared session for " + this.path + " stopped by owner");
              await this.unshare();
            }
          }
        }
        const added = (_b = msg.added) != null ? _b : [];
        if (added && added.length > 0) {
          const states = provider.awareness.getStates();
          for (const key of added) {
            const peer = states.get(key);
            if (peer && this.path && key != ((_c = this._webRTCProvider) == null ? void 0 : _c.awareness.clientID)) {
              showNotice(`${(_d = peer.user) == null ? void 0 : _d.name} is working on ${this.path}`, 1e4);
            }
          }
        }
      });
    });
  }
  async setNewFileLocation(file) {
    const oldPath = this._path;
    this._file = file;
    this._path = (0, import_obsidian9.normalizePath)(file.path);
    if (this.statusBarEntry) {
      this.removeStatusStatusBarEntry();
      this.addStatusBarEntry();
    }
    await moveDoc(oldPath, file.path, this.plugin);
    removeIsSharedClass(oldPath, this.plugin);
    addIsSharedClass(this.path, this.plugin);
  }
  async setPermanent() {
    if (!this._isPermanent) {
      this._isPermanent = true;
      await add(this, this.plugin);
      this.plugin.activeStreamClient.add([this.shareId]);
    }
  }
  get isPermanent() {
    return this._isPermanent;
  }
  getValue() {
    return this.getContentFragment().toString();
  }
  getContentFragment() {
    return this.yDoc.getText("content");
  }
  getOwnerFragment() {
    return this.yDoc.getText("owner");
  }
  async startIndexedDBSync() {
    var _a;
    if (this._indexedDBProvider)
      return this._indexedDBProvider;
    const id2 = (_a = getDocByPath(this.path, this.plugin)) == null ? void 0 : _a.persistenceId;
    if (!id2)
      return;
    const provider = new IndexeddbPersistence(SharedEntity.DB_PERSISTENCE_PREFIX + id2, this.yDoc);
    this._indexedDBProvider = provider;
    if (!provider.synced)
      await provider.whenSynced;
    return this._indexedDBProvider;
  }
  addExtensionToLeaf(leafId) {
    const webRTCProvider = this.startWebRTCSync();
    if (!webRTCProvider)
      return;
    if (this._extensions.get(leafId))
      return;
    const pLeaf = this.plugin.pws.get(leafId);
    if (!pLeaf)
      return;
    if (pLeaf.path != this._path)
      return;
    if (pLeaf.isPreview) {
      pLeaf.once("changeIsPreview", () => {
        this.addExtensionToLeaf(leafId);
      });
      return;
    }
    const leaf = this.plugin.app.workspace.getLeafById(leafId);
    if (!leaf)
      return;
    const view = leaf.view;
    const editor = view.editor;
    editor.setValue(this.getValue());
    const undoManager = new UndoManager(this.getContentFragment());
    const extension = yCollab(this.getContentFragment(), webRTCProvider.awareness, { undoManager });
    const compartment = new import_state.Compartment();
    const editorView = editor.cm;
    editorView.dispatch({
      effects: import_state2.StateEffect.appendConfig.of(compartment.of(extension))
    });
    this._extensions.set(leafId, compartment);
    pLeaf.once("changeIsPreview", () => {
      this.removeExtensionFromLeaf(leafId);
      pLeaf.once("changeIsPreview", () => {
        this.addExtensionToLeaf(leafId);
      });
    });
    return import_state.Compartment;
  }
  removeExtensionFromLeaf(leafId) {
    const leaf = this.plugin.app.workspace.getLeafById(leafId);
    if (leaf) {
      try {
        const editor = leaf.view.editor;
        const editorView = editor.cm;
        const compartment = this._extensions.get(leafId);
        if (compartment) {
          editorView.dispatch({
            effects: compartment.reconfigure([])
          });
        }
      } catch (error) {
        this.plugin.log("editor already gone");
      }
    }
    this._extensions.delete(leafId);
  }
  addStatusBarEntry() {
    if (this.statusBarEntry)
      return;
    const menu = new import_obsidian9.Menu();
    menu.addItem((item) => {
      item.setTitle("Copy link");
      item.onClick(() => {
        navigator.clipboard.writeText(this.plugin.settings.basePath + "/cm/" + this.shareId);
        showNotice("Link copied to clipboard.");
      });
    });
    menu.addItem((item) => {
      item.setTitle("Stop shared session");
      item.onClick(async () => {
        await this.unshare();
      });
    });
    const status = this.plugin.addStatusBarItem();
    status.addClass("mod-clickable");
    status.createEl("span", { text: "Sharing '" + this.path + "'" });
    status.onClickEvent((event) => {
      menu.showAtMouseEvent(event);
    });
    this.statusBarEntry = status;
  }
  removeStatusStatusBarEntry() {
    if (!this.statusBarEntry)
      return;
    this.statusBarEntry.remove();
    this.statusBarEntry = void 0;
  }
  async unshare() {
    const dbEntry = getDocByPath(this.path, this.plugin);
    if (dbEntry) {
      removeDoc(this.path, this.plugin);
    }
    if (this._indexedDBProvider) {
      await this._indexedDBProvider.clearData();
    }
    this.destroy();
    removeIsSharedClass(this.path, this.plugin);
  }
  destroy() {
    if (!this.isPermanent) {
      showNotice("Stopping collaboration on " + this.path + ".");
    }
    for (const key of this._extensions.keys) {
      this.removeExtensionFromLeaf(key);
    }
    this._extensions.destroy();
    super.destroy();
    this.removeStatusStatusBarEntry();
    _SharedDocument._sharedEntites.splice(_SharedDocument._sharedEntites.indexOf(this), 1);
  }
};
var SharedDocument = _SharedDocument;
SharedDocument._userColor = usercolors[randomUint32() % usercolors.length];
SharedDocument._sharedEntites = new Array();

// src/activeStreamClient.ts
var handleMessage = (data) => {
  var _a, _b;
  const message = JSON.parse(data);
  for (const id2 of message.docs) {
    (_a = SharedDocument.findById(id2)) == null ? void 0 : _a.startWebRTCSync();
    (_b = SharedFolder.findById(id2)) == null ? void 0 : _b.startWebRTCSync();
  }
};
var setupWS2 = (client) => {
  if (client.shouldConnect && client.ws === null) {
    const websocket = new WebSocket(client.url);
    client.ws = websocket;
    client.wsconnecting = true;
    client.wsconnected = false;
    websocket.onmessage = (event) => {
      client.wsLastMessageReceived = getUnixTime();
      handleMessage(event.data);
    };
    websocket.onerror = (event) => {
      client.emit("connection-error", [event, client]);
    };
    websocket.onclose = (event) => {
      client.emit("connection-close", [event, client]);
      client.ws = null;
      client.wsconnecting = false;
      if (client.wsconnected) {
        client.wsconnected = false;
        client.emit("status", [{
          status: "disconnected"
        }]);
      } else {
        client.wsUnsuccessfulReconnects++;
      }
      setTimeout(
        setupWS2,
        min(
          pow(2, client.wsUnsuccessfulReconnects) * 100,
          client.maxBackoffTime
        ),
        client
      );
    };
    websocket.onopen = () => {
      client.wsLastMessageReceived = getUnixTime();
      client.wsconnecting = false;
      client.wsconnected = true;
      client.wsUnsuccessfulReconnects = 0;
      client.emit("status", [{
        status: "connected"
      }]);
      client.send(JSON.stringify({
        type: "full",
        docs: Array.from(client.docIds)
      }));
    };
    client.emit("status", [{
      status: "connecting"
    }]);
  }
};
var ActiveStreamClient = class extends ObservableV2 {
  constructor(url, opts = {
    connect: true,
    resyncInterval: -1,
    maxBackoffTime: 2500
  }) {
    super();
    this.maxBackoffTime = opts.maxBackoffTime;
    this.url = url;
    this.wsconnected = false;
    this.wsconnecting = false;
    this.wsUnsuccessfulReconnects = 0;
    this.ws = null;
    this.wsLastMessageReceived = 0;
    this.shouldConnect = opts.connect;
    this._resyncInterval = 0;
    this.docIds = /* @__PURE__ */ new Set();
    if (opts.resyncInterval > 0) {
      this._resyncInterval = window.setInterval(() => {
        if (this.ws && this.ws.readyState === WebSocket.OPEN) {
          this.send(JSON.stringify({
            type: "full",
            docs: Array.from(this.docIds)
          }));
        }
      }, opts.resyncInterval);
    }
    if (opts.connect) {
      this.connect();
    }
  }
  send(data) {
    var _a, _b;
    if (this.ws && this.ws.readyState !== this.ws.CONNECTING && this.ws.readyState !== this.ws.OPEN) {
      this.ws.close();
    }
    try {
      (_a = this.ws) == null ? void 0 : _a.send(data);
    } catch (e) {
      (_b = this.ws) == null ? void 0 : _b.close();
    }
  }
  destroy() {
    if (this._resyncInterval !== 0) {
      clearInterval(this._resyncInterval);
    }
    this.disconnect();
    super.destroy();
  }
  disconnect() {
    this.shouldConnect = false;
    if (this.ws !== null) {
      this.ws.close();
    }
  }
  connect() {
    this.shouldConnect = true;
    if (!this.wsconnected && this.ws === null) {
      setupWS2(this);
    }
  }
  add(ids) {
    for (const id2 of ids) {
      this.docIds.add(id2);
    }
    this.send(JSON.stringify({
      type: "add",
      docs: ids
    }));
  }
  remove(ids) {
    for (const id2 of ids) {
      this.docIds.delete(id2);
    }
    this.send(JSON.stringify({
      type: "remove",
      docs: ids
    }));
  }
};

// src/cookie.ts
var import_obsidian10 = require("obsidian");
var import_remote = require("@electron/remote");
var prepareCommunication = async (plugin) => {
  if (import_obsidian10.Platform.isDesktopApp) {
    await import_remote.session.defaultSession.cookies.set({ url: "https://www.peerdraft.app", "name": "oid", "value": plugin.settings.oid, "domain": "www.peerdraft.app", "path": "/", "secure": true, "httpOnly": true, "sameSite": "no_restriction" });
    await import_remote.session.defaultSession.cookies.set({ url: "http://localhost:5173", "name": "oid", "value": plugin.settings.oid, "domain": "localhost", "path": "/", "secure": true, "httpOnly": true, "sameSite": "no_restriction" });
  } else if (import_obsidian10.Platform.isMobileApp) {
    const signalingURL = new URL(plugin.settings.signaling);
    signalingURL.searchParams.append("oid", plugin.settings.oid);
    plugin.settings.signaling = signalingURL.toString();
  }
};

// src/serverAPI.ts
var import_obsidian11 = require("obsidian");
var ServerAPI = class {
  constructor(opts) {
    this.opts = opts;
  }
  async createPermanentSession() {
    const data = await (0, import_obsidian11.requestUrl)({
      url: this.opts.permanentSessionUrl,
      method: "POST",
      contentType: "application/json",
      body: JSON.stringify({
        oid: this.opts.oid
      })
    }).json;
    if (!data || !data.id) {
      showNotice("Error creating shared file");
      return;
    }
    return data;
  }
  async isSessionPermanent(id2) {
    const data = await (0, import_obsidian11.requestUrl)({
      url: this.opts.permanentSessionUrl + "/" + id2,
      method: "GET",
      contentType: "application/json"
    }).json;
    if (!data) {
      showNotice("Error creating shared file");
      return;
    }
    return !!data.permanent;
  }
};

// src/sharedEntities/sharedEntityFactory.ts
var fromShareURL = async (url, plugin) => {
  const splittedUrl = url.split("/");
  if (splittedUrl == null ? void 0 : splittedUrl.contains("cm")) {
    return SharedDocument.fromShareURL(url, plugin);
  }
  if (splittedUrl == null ? void 0 : splittedUrl.contains("team")) {
    return SharedFolder.fromShareURL(url, plugin);
  }
};

// src/ui/chooseSessionType.ts
var import_obsidian12 = require("obsidian");
var ChooseSessionTypeModal = class extends import_obsidian12.Modal {
  constructor(app, cb) {
    super(app);
    this.cb = cb;
  }
  async onOpen() {
    new import_obsidian12.Setting(this.contentEl).setName("Start working together").setHeading();
    new import_obsidian12.Setting(this.contentEl).addButton((button) => {
      button.setButtonText("Start fleeting session");
      button.setCta();
      button.onClick(() => {
        this.close();
        this.cb({
          permanent: false
        });
      });
    }).setDesc("A fleeting session automatically closes when you close the document or disconnect.");
    new import_obsidian12.Setting(this.contentEl).addButton((button) => {
      button.setButtonText("Share permanently");
      button.setCta();
      button.onClick(() => {
        this.close();
        this.cb({
          permanent: true
        });
      });
    }).setDesc("The document will be shared permanently until you explicitely stop sharing. This is persisted even if you disconnect or close Obsidian.");
  }
};
var promptForSessionType = (app) => {
  return new Promise((resolve2) => {
    new ChooseSessionTypeModal(app, (result) => {
      resolve2(result);
    }).open();
  });
};

// src/ui/enterText.ts
var import_obsidian13 = require("obsidian");
var EnterTextModal = class extends import_obsidian13.Modal {
  constructor(app, opts, cb) {
    super(app);
    this.cb = cb;
    this.result = opts.initial;
    this.opts = opts;
  }
  async onOpen() {
    new import_obsidian13.Setting(this.contentEl).setName(this.opts.header).setHeading();
    new import_obsidian13.Setting(this.contentEl).addText((text2) => {
      text2.setValue(this.result.text), text2.onChange((value) => {
        this.result.text = value;
      });
      text2.inputEl.onkeydown = (ev) => {
        if (ev.key === "Enter") {
          ev.preventDefault();
          this.close();
          this.cb(this.result);
        }
      };
    }).setDesc(this.opts.description);
    const buttons = new import_obsidian13.Setting(this.contentEl);
    buttons.addButton((button) => {
      button.setButtonText("Cancel");
      button.onClick(() => {
        this.close();
      });
    });
    buttons.addButton((button) => {
      button.setButtonText("OK");
      button.setCta();
      button.onClick(() => {
        this.close();
        this.cb(this.result);
      });
    });
  }
};
var promptForText = (app, opts) => {
  return new Promise((resolve2) => {
    new EnterTextModal(app, opts, (cb) => {
      resolve2(cb);
    }).open();
  });
};
var promptForURL = (app) => {
  return promptForText(app, {
    description: "Enter the URL you received to start working together.",
    header: "Enter your Peerdraft URL",
    initial: {
      text: ""
    }
  });
};
var promptForName = (app) => {
  return promptForText(app, {
    description: "This name will be shown to your collaborators",
    header: "What's your name?",
    initial: {
      text: ""
    }
  });
};

// src/peerdraftWebSocketProvider.ts
var MESSAGE_MULTIPLEX_SYNC = 4;
var SYNC_STEP_1 = 0;
var SYNC_STEP_2 = 1;
var UPDATE = 3;
var NEW_DOCUMENT = 4;
var NEW_DOCUMENT_CONFIRMED = 5;
var GET_DOCUMENT_AS_UPDATE = 6;
var SEND_DOCUMENT_AS_UPDATE = 7;
var messageReconnectTimeout2 = 3e4;
var setupWS3 = (provider) => {
  if (provider.shouldConnect && provider.ws === null) {
    const websocket = new WebSocket(provider.url);
    websocket.binaryType = "arraybuffer";
    provider.ws = websocket;
    provider.wsconnecting = true;
    provider.wsconnected = false;
    websocket.onmessage = (event) => {
      var _a, _b;
      provider.wsLastMessageReceived = getUnixTime();
      const data = new Uint8Array(event.data);
      if (data.length == 0)
        return;
      const decoder = createDecoder(data);
      const messageType = readVarUint(decoder);
      if (messageType === MESSAGE_MULTIPLEX_SYNC) {
        const syncMessageType = readVarUint(decoder);
        switch (syncMessageType) {
          case NEW_DOCUMENT_CONFIRMED:
            {
              const tempId = readVarString(decoder);
              const id2 = readVarString(decoder);
              const checksum = readVarString(decoder);
              provider.emit("new-doc-confirmed", [tempId, id2, checksum]);
            }
            break;
          case SYNC_STEP_1:
            {
              const id2 = readVarString(decoder);
              const vector = readVarUint8Array(decoder);
              const hash = readVarString(decoder);
              const doc2 = (_a = SharedDocument.findById(id2)) != null ? _a : SharedFolder.findById(id2);
              if (doc2 && hash != doc2.calculateHash()) {
                provider.sendSyncStep2(doc2, vector);
              }
            }
            break;
          case SYNC_STEP_2:
            {
              const id2 = readVarString(decoder);
              const update = readVarUint8Array(decoder);
              const hash = readVarString(decoder);
              const doc2 = (_b = SharedDocument.findById(id2)) != null ? _b : SharedFolder.findById(id2);
              if (doc2) {
                applyUpdate(doc2.yDoc, update, provider);
                provider.emit("synced", [id2, hash]);
              }
            }
            break;
          case SEND_DOCUMENT_AS_UPDATE:
            {
              const id2 = readVarString(decoder);
              const update = readVarUint8Array(decoder);
              const checksum = readVarString(decoder);
              provider.emit("document-received", [id2, update, checksum]);
            }
            break;
          default:
            console.log("unreachable");
            break;
        }
      }
    };
    websocket.onerror = (event) => {
      provider.emit("connection-error", [event, provider]);
    };
    websocket.onclose = (event) => {
      provider.emit("connection-close", [event, provider]);
      provider.ws = null;
      provider.wsconnecting = false;
      if (provider.wsconnected) {
        provider.wsconnected = false;
        provider.emit("status", [{
          status: "disconnected"
        }]);
      } else {
        provider.wsUnsuccessfulReconnects++;
      }
      setTimeout(
        setupWS3,
        min(
          pow(2, provider.wsUnsuccessfulReconnects) * 100,
          provider.maxBackoffTime
        ),
        provider
      );
    };
    websocket.onopen = async () => {
      provider.wsLastMessageReceived = getUnixTime();
      provider.wsconnecting = false;
      provider.wsconnected = true;
      provider.wsUnsuccessfulReconnects = 0;
      provider.emit("status", [{
        status: "connected"
      }]);
      for (const folder of SharedFolder.getAll()) {
        if (folder.indexedDBProvider) {
          if (!folder.indexedDBProvider.synced)
            await folder.indexedDBProvider.whenSynced;
          folder.syncWithServer();
        }
      }
      for (const doc2 of SharedDocument.getAll()) {
        if (doc2.isPermanent && doc2.indexedDBProvider) {
          if (!doc2.indexedDBProvider.synced)
            await doc2.indexedDBProvider.whenSynced;
          doc2.syncWithServer();
        }
      }
    };
    provider.emit("status", [{
      status: "connecting"
    }]);
  }
};
var PeerdraftWebsocketProvider = class extends ObservableV2 {
  constructor(serverUrl, {
    connect = true,
    resyncInterval = -1,
    maxBackoffTime = 2500
  } = {}) {
    super();
    this.url = serverUrl;
    this.maxBackoffTime = maxBackoffTime;
    this.wsconnected = false;
    this.wsconnecting = false;
    this._resyncInterval = resyncInterval;
    this.wsUnsuccessfulReconnects = 0;
    this._synced = false;
    this.ws = null;
    this.wsLastMessageReceived = 0;
    this.shouldConnect = connect;
    this._resyncInterval = 0;
    this._checkInterval = window.setInterval(() => {
      if (this.wsconnected && messageReconnectTimeout2 < getUnixTime() - this.wsLastMessageReceived) {
        this.ws.close();
      }
    }, messageReconnectTimeout2 / 10);
    if (connect) {
      this.connect();
    }
  }
  sendSyncStep1(doc2) {
    const encoder = createEncoder();
    writeVarUint(encoder, MESSAGE_MULTIPLEX_SYNC);
    writeVarUint(encoder, SYNC_STEP_1);
    writeVarString(encoder, doc2.shareId);
    writeVarUint8Array(encoder, encodeStateVector(doc2.yDoc));
    writeVarString(encoder, doc2.calculateHash());
    this.sendMessage(toUint8Array(encoder));
  }
  sendSyncStep2(doc2, vector) {
    const encoder = createEncoder();
    writeVarUint(encoder, MESSAGE_MULTIPLEX_SYNC);
    writeVarUint(encoder, SYNC_STEP_2);
    writeVarString(encoder, doc2.shareId);
    writeVarUint8Array(encoder, encodeStateAsUpdate(doc2.yDoc, vector));
    writeVarString(encoder, doc2.calculateHash());
    this.sendMessage(toUint8Array(encoder));
  }
  sendUpdate(doc2, update) {
    const encoder = createEncoder();
    writeVarUint(encoder, MESSAGE_MULTIPLEX_SYNC);
    writeVarUint(encoder, UPDATE);
    writeVarString(encoder, doc2.shareId);
    writeVarUint8Array(encoder, update);
    writeVarString(encoder, doc2.calculateHash());
    this.sendMessage(toUint8Array(encoder));
  }
  sendUpdateMessage(shareId, update, checksum) {
    const encoder = createEncoder();
    writeVarUint(encoder, MESSAGE_MULTIPLEX_SYNC);
    writeVarUint(encoder, UPDATE);
    writeVarString(encoder, shareId);
    writeVarUint8Array(encoder, update);
    writeVarString(encoder, checksum);
    this.sendMessage(toUint8Array(encoder));
  }
  sendNewDocument(doc2, tempId) {
    const encoder = createEncoder();
    writeVarUint(encoder, MESSAGE_MULTIPLEX_SYNC);
    writeVarUint(encoder, NEW_DOCUMENT);
    writeVarString(encoder, tempId);
    writeVarUint8Array(encoder, encodeStateAsUpdate(doc2.yDoc));
    writeVarString(encoder, doc2.calculateHash());
    this.sendMessage(toUint8Array(encoder));
  }
  sendGetDocumentAsUpdate(id2) {
    const encoder = createEncoder();
    writeVarUint(encoder, MESSAGE_MULTIPLEX_SYNC);
    writeVarUint(encoder, GET_DOCUMENT_AS_UPDATE), writeVarString(encoder, id2);
    this.sendMessage(toUint8Array(encoder));
  }
  sendMessage(buf) {
    if (this.wsconnected && this.ws && this.ws.readyState === WebSocket.OPEN) {
      this.ws.send(buf);
    }
  }
  requestDocument(docId) {
    return new Promise((resolve2) => {
      const handler = (serverId, update, checksum) => {
        if (docId == serverId) {
          this.off("document-received", handler);
          const doc2 = new Doc();
          applyUpdate(doc2, update);
          const docs = Array.from(doc2.getMap("documents"));
          if (docs.length > 0) {
            const serialized = serialize(Array.from(docs));
            const calculatedHash = calculateHash(serialized);
            if (calculatedHash != checksum) {
              this.sendUpdateMessage(docId, encodeStateAsUpdate(doc2), calculatedHash);
            }
          }
          resolve2(doc2);
        }
      };
      this.on("document-received", handler);
      this.sendGetDocumentAsUpdate(docId);
    });
  }
  destroy() {
    if (this._resyncInterval !== 0) {
      clearInterval(this._resyncInterval);
    }
    clearInterval(this._checkInterval);
    this.disconnect();
    super.destroy();
  }
  disconnect() {
    this.shouldConnect = false;
    if (this.ws !== null) {
      this.ws.close();
    }
  }
  connect() {
    this.shouldConnect = true;
    if (!this.wsconnected && this.ws === null) {
      setupWS3(this);
    }
  }
};

// src/peerdraftPlugin.ts
var path3 = __toESM(require("path"));
var PeerdraftPlugin = class extends import_obsidian14.Plugin {
  async onload() {
    const plugin = this;
    plugin.settings = await migrateSettings(plugin);
    await prepareCommunication(plugin);
    plugin.pws = new PeerdraftRecord();
    plugin.serverAPI = new ServerAPI({
      oid: plugin.settings.oid,
      permanentSessionUrl: plugin.settings.sessionAPI
    });
    plugin.activeStreamClient = new ActiveStreamClient(plugin.settings.actives, {
      maxBackoffTime: 3e5,
      connect: true,
      resyncInterval: -1
    });
    plugin.pws.on("add", (key, leaf) => {
      var _a;
      (_a = SharedDocument.findByPath(leaf.path)) == null ? void 0 : _a.addExtensionToLeaf(key);
      leaf.on("changePath", (oldPath) => {
        var _a2;
        const doc2 = SharedDocument.findByPath(oldPath);
        if (doc2) {
          doc2.removeExtensionFromLeaf(key);
          const leafs = getLeafsByPath(oldPath, plugin.pws);
          if (leafs.length === 0 && !doc2.isPermanent) {
            doc2.unshare();
          }
        }
        (_a2 = SharedDocument.findByPath(leaf.path)) == null ? void 0 : _a2.addExtensionToLeaf(key);
      });
    });
    plugin.pws.on("delete", async (key, leaf) => {
      const doc2 = SharedDocument.findByPath(leaf.path);
      if (!doc2)
        return;
      doc2.removeExtensionFromLeaf(key);
      const leafs = getLeafsByPath(leaf.path, plugin.pws);
      if (leafs.length === 0) {
        if (doc2 && !doc2.isPermanent) {
          await doc2.unshare();
        }
      }
      leaf.destroy();
    });
    plugin.app.workspace.onLayoutReady(
      async () => {
        this.serverSync = new PeerdraftWebsocketProvider(this.settings.sync);
        for (const docs of plugin.settings.serverShares.files) {
          await SharedDocument.fromPermanentShareDocument({ path: docs[0], persistenceId: docs[1].persistenceId, shareId: docs[1].shareId }, plugin);
        }
        for (const folder of plugin.settings.serverShares.folders) {
          await SharedFolder.fromPermanentShareFolder({ path: folder[0], persistenceId: folder[1].persistenceId, shareId: folder[1].shareId }, plugin);
        }
        updatePeerdraftWorkspace(plugin.app.workspace, plugin.pws);
        plugin.registerEvent(plugin.app.workspace.on("layout-change", () => {
          updatePeerdraftWorkspace(plugin.app.workspace, plugin.pws);
        }));
      }
    );
    plugin.registerEvent(plugin.app.workspace.on("file-menu", (menu, file) => {
      if (file instanceof import_obsidian14.TFolder) {
        const sharedFolder = SharedFolder.findByPath(file.path);
        if (!sharedFolder) {
          if (!SharedFolder.getSharedFolderForSubPath(file.path) && plugin.settings.plan.type === "team") {
            menu.addItem((item) => {
              item.setTitle("Share Folder");
              item.setIcon("users");
              item.onClick(() => {
                SharedFolder.fromTFolder(file, plugin);
              });
            });
          }
        } else {
          menu.addItem((item) => {
            item.setTitle("Copy Peerdraft URL");
            item.setIcon("users");
            item.onClick(() => {
              navigator.clipboard.writeText(plugin.settings.basePath + "/team/" + sharedFolder.shareId);
            });
          });
          menu.addItem((item) => {
            item.setTitle("Stop syncing this folder");
            item.setIcon("refresh-cw-off");
            item.onClick(async () => {
              await sharedFolder.unshare();
            });
          });
          menu.addItem((item) => {
            item.setTitle("Re-create sync from server");
            item.setIcon("refresh-cw");
            item.onClick(async () => {
              await SharedFolder.recreate(sharedFolder, plugin);
            });
          });
        }
      } else {
        const sharedDocument = SharedDocument.findByPath(file.path);
        const sharedFolder = SharedFolder.getSharedFolderForSubPath(file.path);
        if (sharedDocument) {
          menu.addItem((item) => {
            item.setTitle("Copy Peerdraft URL");
            item.setIcon("users");
            item.onClick(() => {
              navigator.clipboard.writeText(plugin.settings.basePath + "/cm/" + sharedDocument.shareId);
            });
          });
          if (!sharedFolder) {
            menu.addItem((item) => {
              item.setTitle("Stop syncing this document");
              item.setIcon("refresh-cw-off");
              item.onClick(async () => {
                await sharedDocument.unshare();
              });
            });
          }
        }
      }
    }));
    plugin.addCommand({
      id: "share",
      name: "Start working together on this document",
      checkCallback(checking) {
        const view = plugin.app.workspace.getActiveViewOfType(import_obsidian14.MarkdownView);
        if (!view)
          return false;
        const file = view.file;
        if (!file)
          return false;
        const doc2 = SharedDocument.findByPath(file.path);
        if (doc2)
          return false;
        if (checking)
          return true;
        if (plugin.settings.plan.type === "team") {
          promptForSessionType(plugin.app).then((result) => {
            if (!result)
              return;
            SharedDocument.fromView(view, plugin, { permanent: result.permanent }).then((doc3) => {
              if (!doc3) {
                return showNotice("ERROR creating sharedDoc");
              }
            });
          });
        } else {
          SharedDocument.fromView(view, plugin, { permanent: false }).then((doc3) => {
            if (!doc3) {
              return showNotice("ERROR creating sharedDoc");
            }
          });
        }
      }
    });
    plugin.addCommand({
      id: "stop-session-with-active-document",
      name: "Stop working together on this document",
      editorCheckCallback: (checking, editor, ctx) => {
        const file = ctx.file;
        if (!file)
          return false;
        const doc2 = SharedDocument.findByPath(file.path);
        if (!doc2 || doc2.isPermanent)
          return false;
        if (checking)
          return true;
        doc2.unshare().then(() => {
        });
      }
    });
    plugin.addCommand({
      id: "join",
      name: "Join session and add document from someone else",
      callback: async () => {
        const url = await promptForURL(plugin.app);
        if (url && url.text) {
          await fromShareURL(url.text, plugin);
        }
      }
    });
    if (plugin.settings.debug) {
      plugin.addCommand({
        id: "clearDatabase",
        name: "DEBUG: clear database (Nothing will be shared after this!)",
        callback: async () => {
          var _a;
          const dbs = await window.indexedDB.databases();
          for (const db of dbs) {
            if ((_a = db.name) == null ? void 0 : _a.startsWith("peerdraft_")) {
              window.indexedDB.deleteDatabase(db.name);
            }
          }
        }
      });
    }
    plugin.registerEvent(plugin.app.vault.on("rename", async (file, oldPath) => {
      if (file instanceof import_obsidian14.TFile) {
        const doc2 = SharedDocument.findByPath(oldPath);
        if (doc2) {
          await doc2.setNewFileLocation(file);
        }
        const oldPathInFolder = SharedFolder.getSharedFolderForSubPath(oldPath);
        const newPathInFolder = SharedFolder.getSharedFolderForSubPath(file.path);
        if (oldPathInFolder && newPathInFolder) {
          if (oldPathInFolder === newPathInFolder) {
            oldPathInFolder.updatePath(oldPath, file.path);
          } else {
            const newDoc = await SharedDocument.fromTFile(file, { permanent: true }, plugin);
            if (newDoc) {
              newPathInFolder.addDocument(newDoc);
            }
            if (doc2) {
            }
          }
        } else if (oldPathInFolder && !newPathInFolder) {
          if (doc2) {
            showNotice("It is not possible to remove a document from a shared folder right now. Created a copy.");
            await SharedFolder.getOrCreatePath(path3.dirname(oldPath), plugin);
            const file2 = await plugin.app.vault.create(oldPath, "");
            if (!file2) {
              showNotice("Error creating file " + oldPath + ".");
              return;
            }
            doc2.setNewFileLocation(file2);
            doc2.syncWithServer();
          }
        } else if (!oldPathInFolder && newPathInFolder) {
          const doc3 = await SharedDocument.fromTFile(file, { permanent: true }, plugin);
          if (doc3) {
            newPathInFolder.addDocument(doc3);
          }
        }
      } else if (file instanceof import_obsidian14.TFolder) {
        const folder = SharedFolder.findByPath(oldPath);
        if (folder) {
          await folder.setNewFolderLocation(file);
        }
      }
    }));
    plugin.registerEvent(plugin.app.vault.on("delete", async (file) => {
      plugin.log("register delete for " + file.path);
      if (file instanceof import_obsidian14.TFolder) {
        const folder = SharedFolder.findByPath(file.path);
        folder == null ? void 0 : folder.unshare();
        return;
      } else if (file instanceof import_obsidian14.TFile) {
        const folder = SharedFolder.getSharedFolderForSubPath(file.path);
        if (!folder) {
          const doc2 = SharedDocument.findByPath(file.path);
          if (doc2) {
            await doc2.unshare();
          }
        }
      }
    }));
    plugin.app.workspace.onLayoutReady(
      () => {
        plugin.registerEvent(plugin.app.vault.on("create", async (file) => {
          if (!(file instanceof import_obsidian14.TFile))
            return;
          const folder = SharedFolder.getSharedFolderForSubPath(file.path);
          if (!folder)
            return;
          if (folder.isFileInSyncObject(file))
            return;
          if (SharedDocument.findByPath(file.path))
            return;
          if (plugin.settings.serverShares.files.has((0, import_obsidian14.normalizePath)(file.path)))
            return;
          const doc2 = await SharedDocument.fromTFile(file, {
            permanent: true
          }, plugin);
          if (doc2) {
            folder.addDocument(doc2);
          }
        }));
      }
    );
    const settingsTab = createSettingsTab(plugin);
    if (!plugin.settings.name) {
      const name = await promptForName(plugin.app);
      if (name && name.text) {
        this.settings.name = name.text;
        saveSettings(this.settings, plugin);
      }
    }
    plugin.addSettingTab(settingsTab);
  }
  onunload() {
    SharedDocument.getAll().forEach((doc2) => {
      doc2.destroy();
    });
    SharedFolder.getAll().forEach((folder) => {
      folder.destroy();
    });
    this.activeStreamClient.destroy();
  }
  log(message) {
    if (this.settings.debug) {
      console.log(message);
    }
  }
};

// src/main.ts
var main_default = PeerdraftPlugin;
/*! Bundled license information:

simple-peer/simplepeer.min.js:
  (*!
  * The buffer module from node.js, for the browser.
  *
  * @author   Feross Aboukhadijeh <https://feross.org>
  * @license  MIT
  *)
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)
  (*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)
  (*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)
  (*! simple-peer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)
*/
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vbm9kZV9tb2R1bGVzL2N1aW50L2xpYi91aW50MzIuanMiLCAiLi4vbm9kZV9tb2R1bGVzL2N1aW50L2xpYi91aW50NjQuanMiLCAiLi4vbm9kZV9tb2R1bGVzL2N1aW50L2luZGV4LmpzIiwgIi4uL25vZGVfbW9kdWxlcy94eGhhc2hqcy9saWIveHhoYXNoLmpzIiwgIi4uL25vZGVfbW9kdWxlcy94eGhhc2hqcy9saWIveHhoYXNoNjQuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3h4aGFzaGpzL2xpYi9pbmRleC5qcyIsICIuLi9ub2RlX21vZHVsZXMvc2ltcGxlLXBlZXIvc2ltcGxlcGVlci5taW4uanMiLCAiLi4vc3JjL21haW4udHMiLCAiLi4vc3JjL3BlZXJkcmFmdFBsdWdpbi50cyIsICIuLi9ub2RlX21vZHVsZXMvbGliMC9tYXRoLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9saWIwL3RpbWUuanMiLCAiLi4vbm9kZV9tb2R1bGVzL2xpYjAvbWFwLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9saWIwL3NldC5qcyIsICIuLi9ub2RlX21vZHVsZXMvbGliMC9hcnJheS5qcyIsICIuLi9ub2RlX21vZHVsZXMvbGliMC9vYnNlcnZhYmxlLmpzIiwgIi4uL3NyYy9zaGFyZWRFbnRpdGllcy9zaGFyZWREb2N1bWVudC50cyIsICIuLi9ub2RlX21vZHVsZXMvbGliMC9iaW5hcnkuanMiLCAiLi4vbm9kZV9tb2R1bGVzL2xpYjAvbnVtYmVyLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9saWIwL3N0cmluZy5qcyIsICIuLi9ub2RlX21vZHVsZXMvbGliMC9lbmNvZGluZy5qcyIsICIuLi9ub2RlX21vZHVsZXMvbGliMC9lcnJvci5qcyIsICIuLi9ub2RlX21vZHVsZXMvbGliMC9kZWNvZGluZy5qcyIsICIuLi9ub2RlX21vZHVsZXMvbGliMC93ZWJjcnlwdG8uanMiLCAiLi4vbm9kZV9tb2R1bGVzL2xpYjAvcmFuZG9tLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9saWIwL3Byb21pc2UuanMiLCAiLi4vbm9kZV9tb2R1bGVzL2xpYjAvY29uZGl0aW9ucy5qcyIsICIuLi9ub2RlX21vZHVsZXMvbGliMC9zdG9yYWdlLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9saWIwL29iamVjdC5qcyIsICIuLi9ub2RlX21vZHVsZXMvbGliMC9mdW5jdGlvbi5qcyIsICIuLi9ub2RlX21vZHVsZXMvbGliMC9lbnZpcm9ubWVudC5qcyIsICIuLi9ub2RlX21vZHVsZXMvbGliMC9idWZmZXIuanMiLCAiLi4vbm9kZV9tb2R1bGVzL2xpYjAvcGFpci5qcyIsICIuLi9ub2RlX21vZHVsZXMvbGliMC9kb20uanMiLCAiLi4vbm9kZV9tb2R1bGVzL2xpYjAvc3ltYm9sLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9saWIwL2xvZ2dpbmcuY29tbW9uLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9saWIwL2xvZ2dpbmcuanMiLCAiLi4vbm9kZV9tb2R1bGVzL2xpYjAvaXRlcmF0b3IuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3lqcy9zcmMvdXRpbHMvQWJzdHJhY3RDb25uZWN0b3IuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3lqcy9zcmMvdXRpbHMvRGVsZXRlU2V0LmpzIiwgIi4uL25vZGVfbW9kdWxlcy95anMvc3JjL3V0aWxzL0RvYy5qcyIsICIuLi9ub2RlX21vZHVsZXMveWpzL3NyYy91dGlscy9VcGRhdGVEZWNvZGVyLmpzIiwgIi4uL25vZGVfbW9kdWxlcy95anMvc3JjL3V0aWxzL1VwZGF0ZUVuY29kZXIuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3lqcy9zcmMvdXRpbHMvZW5jb2RpbmcuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3lqcy9zcmMvdXRpbHMvRXZlbnRIYW5kbGVyLmpzIiwgIi4uL25vZGVfbW9kdWxlcy95anMvc3JjL3V0aWxzL0lELmpzIiwgIi4uL25vZGVfbW9kdWxlcy95anMvc3JjL3V0aWxzL2lzUGFyZW50T2YuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3lqcy9zcmMvdXRpbHMvbG9nZ2luZy5qcyIsICIuLi9ub2RlX21vZHVsZXMveWpzL3NyYy91dGlscy9QZXJtYW5lbnRVc2VyRGF0YS5qcyIsICIuLi9ub2RlX21vZHVsZXMveWpzL3NyYy91dGlscy9SZWxhdGl2ZVBvc2l0aW9uLmpzIiwgIi4uL25vZGVfbW9kdWxlcy95anMvc3JjL3V0aWxzL1NuYXBzaG90LmpzIiwgIi4uL25vZGVfbW9kdWxlcy95anMvc3JjL3V0aWxzL1N0cnVjdFN0b3JlLmpzIiwgIi4uL25vZGVfbW9kdWxlcy95anMvc3JjL3V0aWxzL1RyYW5zYWN0aW9uLmpzIiwgIi4uL25vZGVfbW9kdWxlcy95anMvc3JjL3V0aWxzL1VuZG9NYW5hZ2VyLmpzIiwgIi4uL25vZGVfbW9kdWxlcy95anMvc3JjL3V0aWxzL3VwZGF0ZXMuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3lqcy9zcmMvdXRpbHMvWUV2ZW50LmpzIiwgIi4uL25vZGVfbW9kdWxlcy95anMvc3JjL3R5cGVzL0Fic3RyYWN0VHlwZS5qcyIsICIuLi9ub2RlX21vZHVsZXMveWpzL3NyYy90eXBlcy9ZQXJyYXkuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3lqcy9zcmMvdHlwZXMvWU1hcC5qcyIsICIuLi9ub2RlX21vZHVsZXMveWpzL3NyYy90eXBlcy9ZVGV4dC5qcyIsICIuLi9ub2RlX21vZHVsZXMveWpzL3NyYy90eXBlcy9ZWG1sRnJhZ21lbnQuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3lqcy9zcmMvdHlwZXMvWVhtbEVsZW1lbnQuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3lqcy9zcmMvdHlwZXMvWVhtbEV2ZW50LmpzIiwgIi4uL25vZGVfbW9kdWxlcy95anMvc3JjL3R5cGVzL1lYbWxIb29rLmpzIiwgIi4uL25vZGVfbW9kdWxlcy95anMvc3JjL3R5cGVzL1lYbWxUZXh0LmpzIiwgIi4uL25vZGVfbW9kdWxlcy95anMvc3JjL3N0cnVjdHMvQWJzdHJhY3RTdHJ1Y3QuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3lqcy9zcmMvc3RydWN0cy9HQy5qcyIsICIuLi9ub2RlX21vZHVsZXMveWpzL3NyYy9zdHJ1Y3RzL0NvbnRlbnRCaW5hcnkuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3lqcy9zcmMvc3RydWN0cy9Db250ZW50RGVsZXRlZC5qcyIsICIuLi9ub2RlX21vZHVsZXMveWpzL3NyYy9zdHJ1Y3RzL0NvbnRlbnREb2MuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3lqcy9zcmMvc3RydWN0cy9Db250ZW50RW1iZWQuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3lqcy9zcmMvc3RydWN0cy9Db250ZW50Rm9ybWF0LmpzIiwgIi4uL25vZGVfbW9kdWxlcy95anMvc3JjL3N0cnVjdHMvQ29udGVudEpTT04uanMiLCAiLi4vbm9kZV9tb2R1bGVzL3lqcy9zcmMvc3RydWN0cy9Db250ZW50QW55LmpzIiwgIi4uL25vZGVfbW9kdWxlcy95anMvc3JjL3N0cnVjdHMvQ29udGVudFN0cmluZy5qcyIsICIuLi9ub2RlX21vZHVsZXMveWpzL3NyYy9zdHJ1Y3RzL0NvbnRlbnRUeXBlLmpzIiwgIi4uL25vZGVfbW9kdWxlcy95anMvc3JjL3N0cnVjdHMvSXRlbS5qcyIsICIuLi9ub2RlX21vZHVsZXMveWpzL3NyYy9zdHJ1Y3RzL1NraXAuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3lqcy9zcmMvaW5kZXguanMiLCAiLi4vc3JjL3Rvb2xzLnRzIiwgIi4uL3NyYy91aS50cyIsICIuLi9ub2RlX21vZHVsZXMveS1jb2RlbWlycm9yLm5leHQvc3JjL2luZGV4LmpzIiwgIi4uL25vZGVfbW9kdWxlcy95LWNvZGVtaXJyb3IubmV4dC9zcmMveS1zeW5jLmpzIiwgIi4uL25vZGVfbW9kdWxlcy95LWNvZGVtaXJyb3IubmV4dC9zcmMveS1yYW5nZS5qcyIsICIuLi9ub2RlX21vZHVsZXMveS1jb2RlbWlycm9yLm5leHQvc3JjL3ktcmVtb3RlLXNlbGVjdGlvbnMuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3ktY29kZW1pcnJvci5uZXh0L3NyYy95LXVuZG9tYW5hZ2VyLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9saWIwL211dGV4LmpzIiwgIi4uL3NyYy91dGlscy9wZWVyZHJhZnRSZWNvcmQudHMiLCAiLi4vc3JjL3dvcmtzcGFjZS9wZWVyZHJhZnRMZWFmLnRzIiwgIi4uL3NyYy93b3Jrc3BhY2UvcGVlcmRyYWZ0V29ya3NwYWNlLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9saWIwL3dlYnNvY2tldC5qcyIsICIuLi9ub2RlX21vZHVsZXMvbGliMC9icm9hZGNhc3RjaGFubmVsLmpzIiwgIi4uL25vZGVfbW9kdWxlcy95LXdlYnJ0Yy9zcmMveS13ZWJydGMuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3ktcHJvdG9jb2xzL3N5bmMuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3ktcHJvdG9jb2xzL2F3YXJlbmVzcy5qcyIsICIuLi9ub2RlX21vZHVsZXMveS13ZWJydGMvc3JjL2NyeXB0by5qcyIsICIuLi9zcmMvc2hhcmVkRW50aXRpZXMvc2hhcmVkRW50aXR5LnRzIiwgIi4uL25vZGVfbW9kdWxlcy9saWIwL2luZGV4ZWRkYi5qcyIsICIuLi9ub2RlX21vZHVsZXMveS1pbmRleGVkZGIvc3JjL3ktaW5kZXhlZGRiLmpzIiwgIi4uL3NyYy93b3Jrc3BhY2UvZXhwbG9yZXJWaWV3LnRzIiwgIi4uL3NyYy9zaGFyZWRFbnRpdGllcy9zaGFyZWRGb2xkZXIudHMiLCAiLi4vc3JjL3NldHRpbmdzLnRzIiwgIi4uL3NyYy9zdWJzY3JpcHRpb24udHMiLCAiLi4vc3JjL3VpL3NlbGVjdEZvbGRlci50cyIsICIuLi9ub2RlX21vZHVsZXMvZGV4aWUvc3JjL2dsb2JhbHMvZ2xvYmFsLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9kZXhpZS9zcmMvZnVuY3Rpb25zL3V0aWxzLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9kZXhpZS9zcmMvaGVscGVycy9kZWJ1Zy50cyIsICIuLi9ub2RlX21vZHVsZXMvZGV4aWUvc3JjL2Vycm9ycy9lcnJvcnMuanMiLCAiLi4vbm9kZV9tb2R1bGVzL2RleGllL3NyYy9mdW5jdGlvbnMvY2hhaW5pbmctZnVuY3Rpb25zLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9kZXhpZS9zcmMvaGVscGVycy9wcm9taXNlLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9kZXhpZS9zcmMvZnVuY3Rpb25zL3RlbXAtdHJhbnNhY3Rpb24udHMiLCAiLi4vbm9kZV9tb2R1bGVzL2RleGllL3NyYy9nbG9iYWxzL2NvbnN0YW50cy50cyIsICIuLi9ub2RlX21vZHVsZXMvZGV4aWUvc3JjL2Z1bmN0aW9ucy9jb21iaW5lLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9kZXhpZS9zcmMvZGJjb3JlL2tleXJhbmdlLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9kZXhpZS9zcmMvZnVuY3Rpb25zL3dvcmthcm91bmQtdW5kZWZpbmVkLXByaW1rZXkudHMiLCAiLi4vbm9kZV9tb2R1bGVzL2RleGllL3NyYy9jbGFzc2VzL3RhYmxlL3RhYmxlLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9kZXhpZS9zcmMvaGVscGVycy9FdmVudHMuanMiLCAiLi4vbm9kZV9tb2R1bGVzL2RleGllL3NyYy9mdW5jdGlvbnMvbWFrZS1jbGFzcy1jb25zdHJ1Y3Rvci50cyIsICIuLi9ub2RlX21vZHVsZXMvZGV4aWUvc3JjL2NsYXNzZXMvdGFibGUvdGFibGUtY29uc3RydWN0b3IudHMiLCAiLi4vbm9kZV9tb2R1bGVzL2RleGllL3NyYy9jbGFzc2VzL2NvbGxlY3Rpb24vY29sbGVjdGlvbi1oZWxwZXJzLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9kZXhpZS9zcmMvZnVuY3Rpb25zL2NtcC50cyIsICIuLi9ub2RlX21vZHVsZXMvZGV4aWUvc3JjL2NsYXNzZXMvY29sbGVjdGlvbi9jb2xsZWN0aW9uLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9kZXhpZS9zcmMvY2xhc3Nlcy9jb2xsZWN0aW9uL2NvbGxlY3Rpb24tY29uc3RydWN0b3IudHMiLCAiLi4vbm9kZV9tb2R1bGVzL2RleGllL3NyYy9mdW5jdGlvbnMvY29tcGFyZS1mdW5jdGlvbnMudHMiLCAiLi4vbm9kZV9tb2R1bGVzL2RleGllL3NyYy9jbGFzc2VzL3doZXJlLWNsYXVzZS93aGVyZS1jbGF1c2UtaGVscGVycy50cyIsICIuLi9ub2RlX21vZHVsZXMvZGV4aWUvc3JjL2NsYXNzZXMvd2hlcmUtY2xhdXNlL3doZXJlLWNsYXVzZS50cyIsICIuLi9ub2RlX21vZHVsZXMvZGV4aWUvc3JjL2NsYXNzZXMvd2hlcmUtY2xhdXNlL3doZXJlLWNsYXVzZS1jb25zdHJ1Y3Rvci50cyIsICIuLi9ub2RlX21vZHVsZXMvZGV4aWUvc3JjL2Z1bmN0aW9ucy9ldmVudC13cmFwcGVycy50cyIsICIuLi9ub2RlX21vZHVsZXMvZGV4aWUvc3JjL2dsb2JhbHMvZ2xvYmFsLWV2ZW50cy50cyIsICIuLi9ub2RlX21vZHVsZXMvZGV4aWUvc3JjL2NsYXNzZXMvdHJhbnNhY3Rpb24vdHJhbnNhY3Rpb24udHMiLCAiLi4vbm9kZV9tb2R1bGVzL2RleGllL3NyYy9jbGFzc2VzL3RyYW5zYWN0aW9uL3RyYW5zYWN0aW9uLWNvbnN0cnVjdG9yLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9kZXhpZS9zcmMvaGVscGVycy9pbmRleC1zcGVjLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9kZXhpZS9zcmMvaGVscGVycy90YWJsZS1zY2hlbWEudHMiLCAiLi4vbm9kZV9tb2R1bGVzL2RleGllL3NyYy9mdW5jdGlvbnMvcXVpcmtzLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9kZXhpZS9zcmMvZGJjb3JlL2dldC1rZXktZXh0cmFjdG9yLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9kZXhpZS9zcmMvZGJjb3JlL2RiY29yZS1pbmRleGVkZGIudHMiLCAiLi4vbm9kZV9tb2R1bGVzL2RleGllL3NyYy9jbGFzc2VzL2RleGllL2dlbmVyYXRlLW1pZGRsZXdhcmUtc3RhY2tzLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9kZXhpZS9zcmMvY2xhc3Nlcy92ZXJzaW9uL3NjaGVtYS1oZWxwZXJzLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9kZXhpZS9zcmMvY2xhc3Nlcy92ZXJzaW9uL3ZlcnNpb24udHMiLCAiLi4vbm9kZV9tb2R1bGVzL2RleGllL3NyYy9jbGFzc2VzL3ZlcnNpb24vdmVyc2lvbi1jb25zdHJ1Y3Rvci50cyIsICIuLi9ub2RlX21vZHVsZXMvZGV4aWUvc3JjL2hlbHBlcnMvZGF0YWJhc2UtZW51bWVyYXRvci50cyIsICIuLi9ub2RlX21vZHVsZXMvZGV4aWUvc3JjL2NsYXNzZXMvZGV4aWUvdmlwLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9kZXhpZS9ub2RlX21vZHVsZXMvc2FmYXJpLTE0LWlkYi1maXgvZGlzdC9pbmRleC5qcyIsICIuLi9ub2RlX21vZHVsZXMvZGV4aWUvc3JjL2NsYXNzZXMvZGV4aWUvZGV4aWUtb3Blbi50cyIsICIuLi9ub2RlX21vZHVsZXMvZGV4aWUvc3JjL2hlbHBlcnMveWllbGQtc3VwcG9ydC50cyIsICIuLi9ub2RlX21vZHVsZXMvZGV4aWUvc3JjL2NsYXNzZXMvZGV4aWUvdHJhbnNhY3Rpb24taGVscGVycy50cyIsICIuLi9ub2RlX21vZHVsZXMvZGV4aWUvc3JjL2RiY29yZS92aXJ0dWFsLWluZGV4LW1pZGRsZXdhcmUudHMiLCAiLi4vbm9kZV9tb2R1bGVzL2RleGllL3NyYy9mdW5jdGlvbnMvZ2V0LW9iamVjdC1kaWZmLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9kZXhpZS9zcmMvZGJjb3JlL2dldC1lZmZlY3RpdmUta2V5cy50cyIsICIuLi9ub2RlX21vZHVsZXMvZGV4aWUvc3JjL2hvb2tzL2hvb2tzLW1pZGRsZXdhcmUudHMiLCAiLi4vbm9kZV9tb2R1bGVzL2RleGllL3NyYy9kYmNvcmUvY2FjaGUtZXhpc3RpbmctdmFsdWVzLW1pZGRsZXdhcmUudHMiLCAiLi4vbm9kZV9tb2R1bGVzL2RleGllL3NyYy9oZWxwZXJzL3Jhbmdlc2V0LnRzIiwgIi4uL25vZGVfbW9kdWxlcy9kZXhpZS9zcmMvbGl2ZS1xdWVyeS9vYnNlcnZhYmlsaXR5LW1pZGRsZXdhcmUudHMiLCAiLi4vbm9kZV9tb2R1bGVzL2RleGllL3NyYy9jbGFzc2VzL2RleGllL2RleGllLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9kZXhpZS9zcmMvY2xhc3Nlcy9vYnNlcnZhYmxlL29ic2VydmFibGUudHMiLCAiLi4vbm9kZV9tb2R1bGVzL2RleGllL3NyYy9saXZlLXF1ZXJ5L2V4dGVuZC1vYnNlcnZhYmlsaXR5LXNldC50cyIsICIuLi9ub2RlX21vZHVsZXMvZGV4aWUvc3JjL2xpdmUtcXVlcnkvbGl2ZS1xdWVyeS50cyIsICIuLi9ub2RlX21vZHVsZXMvZGV4aWUvc3JjL2NsYXNzZXMvZGV4aWUvZGV4aWUtZG9tLWRlcGVuZGVuY2llcy50cyIsICIuLi9ub2RlX21vZHVsZXMvZGV4aWUvc3JjL2NsYXNzZXMvZGV4aWUvZGV4aWUtc3RhdGljLXByb3BzLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9kZXhpZS9zcmMvbGl2ZS1xdWVyeS9wcm9wYWdhdGUtbG9jYWxseS50cyIsICIuLi9ub2RlX21vZHVsZXMvZGV4aWUvc3JjL2xpdmUtcXVlcnkvZW5hYmxlLWJyb2FkY2FzdC50cyIsICIuLi9ub2RlX21vZHVsZXMvZGV4aWUvc3JjL2luZGV4LnRzIiwgIi4uL3NyYy9wZXJtYW5lbnRTaGFyZVN0b3JlLnRzIiwgIi4uL3NyYy9wZXJtYW5lbnRTaGFyZVN0b3JlRlMudHMiLCAiLi4vbm9kZV9tb2R1bGVzL2FzeW5jLW11dGV4L2luZGV4Lm1qcyIsICIuLi9ub2RlX21vZHVsZXMvZGlmZi1tYXRjaC1wYXRjaC1lcy9kaXN0L2luZGV4Lm1qcyIsICIuLi9zcmMvYWN0aXZlU3RyZWFtQ2xpZW50LnRzIiwgIi4uL3NyYy9jb29raWUudHMiLCAiLi4vc3JjL3NlcnZlckFQSS50cyIsICIuLi9zcmMvc2hhcmVkRW50aXRpZXMvc2hhcmVkRW50aXR5RmFjdG9yeS50cyIsICIuLi9zcmMvdWkvY2hvb3NlU2Vzc2lvblR5cGUudHMiLCAiLi4vc3JjL3VpL2VudGVyVGV4dC50cyIsICIuLi9zcmMvcGVlcmRyYWZ0V2ViU29ja2V0UHJvdmlkZXIudHMiXSwKICAic291cmNlc0NvbnRlbnQiOiBbIi8qKlxuXHRDLWxpa2UgdW5zaWduZWQgMzIgYml0cyBpbnRlZ2VycyBpbiBKYXZhc2NyaXB0XG5cdENvcHlyaWdodCAoQykgMjAxMywgUGllcnJlIEN1cnRvXG5cdE1JVCBsaWNlbnNlXG4gKi9cbjsoZnVuY3Rpb24gKHJvb3QpIHtcblxuXHQvLyBMb2NhbCBjYWNoZSBmb3IgdHlwaWNhbCByYWRpY2VzXG5cdHZhciByYWRpeFBvd2VyQ2FjaGUgPSB7XG5cdFx0MzY6IFVJTlQzMiggTWF0aC5wb3coMzYsIDUpIClcblx0LFx0MTY6IFVJTlQzMiggTWF0aC5wb3coMTYsIDcpIClcblx0LFx0MTA6IFVJTlQzMiggTWF0aC5wb3coMTAsIDkpIClcblx0LFx0MjogIFVJTlQzMiggTWF0aC5wb3coMiwgMzApIClcblx0fVxuXHR2YXIgcmFkaXhDYWNoZSA9IHtcblx0XHQzNjogVUlOVDMyKDM2KVxuXHQsXHQxNjogVUlOVDMyKDE2KVxuXHQsXHQxMDogVUlOVDMyKDEwKVxuXHQsXHQyOiAgVUlOVDMyKDIpXG5cdH1cblxuXHQvKipcblx0ICpcdFJlcHJlc2VudHMgYW4gdW5zaWduZWQgMzIgYml0cyBpbnRlZ2VyXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd8TnVtYmVyfSBsb3cgYml0cyAgICAgfCBpbnRlZ2VyIGFzIGEgc3RyaW5nIFx0XHQgfCBpbnRlZ2VyIGFzIGEgbnVtYmVyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfE51bWJlcnxVbmRlZmluZWR9IGhpZ2ggYml0cyB8IHJhZGl4IChvcHRpb25hbCwgZGVmYXVsdD0xMClcblx0ICogQHJldHVybiBcblx0ICovXG5cdGZ1bmN0aW9uIFVJTlQzMiAobCwgaCkge1xuXHRcdGlmICggISh0aGlzIGluc3RhbmNlb2YgVUlOVDMyKSApXG5cdFx0XHRyZXR1cm4gbmV3IFVJTlQzMihsLCBoKVxuXG5cdFx0dGhpcy5fbG93ID0gMFxuXHRcdHRoaXMuX2hpZ2ggPSAwXG5cdFx0dGhpcy5yZW1haW5kZXIgPSBudWxsXG5cdFx0aWYgKHR5cGVvZiBoID09ICd1bmRlZmluZWQnKVxuXHRcdFx0cmV0dXJuIGZyb21OdW1iZXIuY2FsbCh0aGlzLCBsKVxuXG5cdFx0aWYgKHR5cGVvZiBsID09ICdzdHJpbmcnKVxuXHRcdFx0cmV0dXJuIGZyb21TdHJpbmcuY2FsbCh0aGlzLCBsLCBoKVxuXG5cdFx0ZnJvbUJpdHMuY2FsbCh0aGlzLCBsLCBoKVxuXHR9XG5cblx0LyoqXG5cdCAqIFNldCB0aGUgY3VycmVudCBfVUlOVDMyXyBvYmplY3Qgd2l0aCBpdHMgbG93IGFuZCBoaWdoIGJpdHNcblx0ICogQG1ldGhvZCBmcm9tQml0c1xuXHQgKiBAcGFyYW0ge051bWJlcn0gbG93IGJpdHNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGhpZ2ggYml0c1xuXHQgKiBAcmV0dXJuIFRoaXNFeHByZXNzaW9uXG5cdCAqL1xuXHRmdW5jdGlvbiBmcm9tQml0cyAobCwgaCkge1xuXHRcdHRoaXMuX2xvdyA9IGwgfCAwXG5cdFx0dGhpcy5faGlnaCA9IGggfCAwXG5cblx0XHRyZXR1cm4gdGhpc1xuXHR9XG5cdFVJTlQzMi5wcm90b3R5cGUuZnJvbUJpdHMgPSBmcm9tQml0c1xuXG5cdC8qKlxuXHQgKiBTZXQgdGhlIGN1cnJlbnQgX1VJTlQzMl8gb2JqZWN0IGZyb20gYSBudW1iZXJcblx0ICogQG1ldGhvZCBmcm9tTnVtYmVyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBudW1iZXJcblx0ICogQHJldHVybiBUaGlzRXhwcmVzc2lvblxuXHQgKi9cblx0ZnVuY3Rpb24gZnJvbU51bWJlciAodmFsdWUpIHtcblx0XHR0aGlzLl9sb3cgPSB2YWx1ZSAmIDB4RkZGRlxuXHRcdHRoaXMuX2hpZ2ggPSB2YWx1ZSA+Pj4gMTZcblxuXHRcdHJldHVybiB0aGlzXG5cdH1cblx0VUlOVDMyLnByb3RvdHlwZS5mcm9tTnVtYmVyID0gZnJvbU51bWJlclxuXG5cdC8qKlxuXHQgKiBTZXQgdGhlIGN1cnJlbnQgX1VJTlQzMl8gb2JqZWN0IGZyb20gYSBzdHJpbmdcblx0ICogQG1ldGhvZCBmcm9tU3RyaW5nXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnRlZ2VyIGFzIGEgc3RyaW5nXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByYWRpeCAob3B0aW9uYWwsIGRlZmF1bHQ9MTApXG5cdCAqIEByZXR1cm4gVGhpc0V4cHJlc3Npb25cblx0ICovXG5cdGZ1bmN0aW9uIGZyb21TdHJpbmcgKHMsIHJhZGl4KSB7XG5cdFx0dmFyIHZhbHVlID0gcGFyc2VJbnQocywgcmFkaXggfHwgMTApXG5cblx0XHR0aGlzLl9sb3cgPSB2YWx1ZSAmIDB4RkZGRlxuXHRcdHRoaXMuX2hpZ2ggPSB2YWx1ZSA+Pj4gMTZcblxuXHRcdHJldHVybiB0aGlzXG5cdH1cblx0VUlOVDMyLnByb3RvdHlwZS5mcm9tU3RyaW5nID0gZnJvbVN0cmluZ1xuXG5cdC8qKlxuXHQgKiBDb252ZXJ0IHRoaXMgX1VJTlQzMl8gdG8gYSBudW1iZXJcblx0ICogQG1ldGhvZCB0b051bWJlclxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9IHRoZSBjb252ZXJ0ZWQgVUlOVDMyXG5cdCAqL1xuXHRVSU5UMzIucHJvdG90eXBlLnRvTnVtYmVyID0gZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiAodGhpcy5faGlnaCAqIDY1NTM2KSArIHRoaXMuX2xvd1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnQgdGhpcyBfVUlOVDMyXyB0byBhIHN0cmluZ1xuXHQgKiBAbWV0aG9kIHRvU3RyaW5nXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByYWRpeCAob3B0aW9uYWwsIGRlZmF1bHQ9MTApXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gdGhlIGNvbnZlcnRlZCBVSU5UMzJcblx0ICovXG5cdFVJTlQzMi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAocmFkaXgpIHtcblx0XHRyZXR1cm4gdGhpcy50b051bWJlcigpLnRvU3RyaW5nKHJhZGl4IHx8IDEwKVxuXHR9XG5cblx0LyoqXG5cdCAqIEFkZCB0d28gX1VJTlQzMl8uIFRoZSBjdXJyZW50IF9VSU5UMzJfIHN0b3JlcyB0aGUgcmVzdWx0XG5cdCAqIEBtZXRob2QgYWRkXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBVSU5UMzJcblx0ICogQHJldHVybiBUaGlzRXhwcmVzc2lvblxuXHQgKi9cblx0VUlOVDMyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAob3RoZXIpIHtcblx0XHR2YXIgYTAwID0gdGhpcy5fbG93ICsgb3RoZXIuX2xvd1xuXHRcdHZhciBhMTYgPSBhMDAgPj4+IDE2XG5cblx0XHRhMTYgKz0gdGhpcy5faGlnaCArIG90aGVyLl9oaWdoXG5cblx0XHR0aGlzLl9sb3cgPSBhMDAgJiAweEZGRkZcblx0XHR0aGlzLl9oaWdoID0gYTE2ICYgMHhGRkZGXG5cblx0XHRyZXR1cm4gdGhpc1xuXHR9XG5cblx0LyoqXG5cdCAqIFN1YnRyYWN0IHR3byBfVUlOVDMyXy4gVGhlIGN1cnJlbnQgX1VJTlQzMl8gc3RvcmVzIHRoZSByZXN1bHRcblx0ICogQG1ldGhvZCBzdWJ0cmFjdFxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVUlOVDMyXG5cdCAqIEByZXR1cm4gVGhpc0V4cHJlc3Npb25cblx0ICovXG5cdFVJTlQzMi5wcm90b3R5cGUuc3VidHJhY3QgPSBmdW5jdGlvbiAob3RoZXIpIHtcblx0XHQvL1RPRE8gaW5saW5lXG5cdFx0cmV0dXJuIHRoaXMuYWRkKCBvdGhlci5jbG9uZSgpLm5lZ2F0ZSgpIClcblx0fVxuXG5cdC8qKlxuXHQgKiBNdWx0aXBseSB0d28gX1VJTlQzMl8uIFRoZSBjdXJyZW50IF9VSU5UMzJfIHN0b3JlcyB0aGUgcmVzdWx0XG5cdCAqIEBtZXRob2QgbXVsdGlwbHlcblx0ICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFVJTlQzMlxuXHQgKiBAcmV0dXJuIFRoaXNFeHByZXNzaW9uXG5cdCAqL1xuXHRVSU5UMzIucHJvdG90eXBlLm11bHRpcGx5ID0gZnVuY3Rpb24gKG90aGVyKSB7XG5cdFx0Lypcblx0XHRcdGEgPSBhMDAgKyBhMTZcblx0XHRcdGIgPSBiMDAgKyBiMTZcblx0XHRcdGEqYiA9IChhMDAgKyBhMTYpKGIwMCArIGIxNilcblx0XHRcdFx0PSBhMDBiMDAgKyBhMDBiMTYgKyBhMTZiMDAgKyBhMTZiMTZcblxuXHRcdFx0YTE2YjE2IG92ZXJmbG93cyB0aGUgMzJiaXRzXG5cdFx0ICovXG5cdFx0dmFyIGExNiA9IHRoaXMuX2hpZ2hcblx0XHR2YXIgYTAwID0gdGhpcy5fbG93XG5cdFx0dmFyIGIxNiA9IG90aGVyLl9oaWdoXG5cdFx0dmFyIGIwMCA9IG90aGVyLl9sb3dcblxuLyogUmVtb3ZlZCB0byBpbmNyZWFzZSBzcGVlZCB1bmRlciBub3JtYWwgY2lyY3Vtc3RhbmNlcyAoaS5lLiBub3QgbXVsdGlwbHlpbmcgYnkgMCBvciAxKVxuXHRcdC8vIHRoaXMgPT0gMCBvciBvdGhlciA9PSAxOiBub3RoaW5nIHRvIGRvXG5cdFx0aWYgKChhMDAgPT0gMCAmJiBhMTYgPT0gMCkgfHwgKGIwMCA9PSAxICYmIGIxNiA9PSAwKSkgcmV0dXJuIHRoaXNcblxuXHRcdC8vIG90aGVyID09IDAgb3IgdGhpcyA9PSAxOiB0aGlzID0gb3RoZXJcblx0XHRpZiAoKGIwMCA9PSAwICYmIGIxNiA9PSAwKSB8fCAoYTAwID09IDEgJiYgYTE2ID09IDApKSB7XG5cdFx0XHR0aGlzLl9sb3cgPSBvdGhlci5fbG93XG5cdFx0XHR0aGlzLl9oaWdoID0gb3RoZXIuX2hpZ2hcblx0XHRcdHJldHVybiB0aGlzXG5cdFx0fVxuKi9cblxuXHRcdHZhciBjMTYsIGMwMFxuXHRcdGMwMCA9IGEwMCAqIGIwMFxuXHRcdGMxNiA9IGMwMCA+Pj4gMTZcblxuXHRcdGMxNiArPSBhMTYgKiBiMDBcblx0XHRjMTYgJj0gMHhGRkZGXHRcdC8vIE5vdCByZXF1aXJlZCBidXQgaW1wcm92ZXMgcGVyZm9ybWFuY2Vcblx0XHRjMTYgKz0gYTAwICogYjE2XG5cblx0XHR0aGlzLl9sb3cgPSBjMDAgJiAweEZGRkZcblx0XHR0aGlzLl9oaWdoID0gYzE2ICYgMHhGRkZGXG5cblx0XHRyZXR1cm4gdGhpc1xuXHR9XG5cblx0LyoqXG5cdCAqIERpdmlkZSB0d28gX1VJTlQzMl8uIFRoZSBjdXJyZW50IF9VSU5UMzJfIHN0b3JlcyB0aGUgcmVzdWx0LlxuXHQgKiBUaGUgcmVtYWluZGVyIGlzIG1hZGUgYXZhaWxhYmxlIGFzIHRoZSBfcmVtYWluZGVyXyBwcm9wZXJ0eSBvblxuXHQgKiB0aGUgX1VJTlQzMl8gb2JqZWN0LiBJdCBjYW4gYmUgbnVsbCwgbWVhbmluZyB0aGVyZSBhcmUgbm8gcmVtYWluZGVyLlxuXHQgKiBAbWV0aG9kIGRpdlxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVUlOVDMyXG5cdCAqIEByZXR1cm4gVGhpc0V4cHJlc3Npb25cblx0ICovXG5cdFVJTlQzMi5wcm90b3R5cGUuZGl2ID0gZnVuY3Rpb24gKG90aGVyKSB7XG5cdFx0aWYgKCAob3RoZXIuX2xvdyA9PSAwKSAmJiAob3RoZXIuX2hpZ2ggPT0gMCkgKSB0aHJvdyBFcnJvcignZGl2aXNpb24gYnkgemVybycpXG5cblx0XHQvLyBvdGhlciA9PSAxXG5cdFx0aWYgKG90aGVyLl9oaWdoID09IDAgJiYgb3RoZXIuX2xvdyA9PSAxKSB7XG5cdFx0XHR0aGlzLnJlbWFpbmRlciA9IG5ldyBVSU5UMzIoMClcblx0XHRcdHJldHVybiB0aGlzXG5cdFx0fVxuXG5cdFx0Ly8gb3RoZXIgPiB0aGlzOiAwXG5cdFx0aWYgKCBvdGhlci5ndCh0aGlzKSApIHtcblx0XHRcdHRoaXMucmVtYWluZGVyID0gdGhpcy5jbG9uZSgpXG5cdFx0XHR0aGlzLl9sb3cgPSAwXG5cdFx0XHR0aGlzLl9oaWdoID0gMFxuXHRcdFx0cmV0dXJuIHRoaXNcblx0XHR9XG5cdFx0Ly8gb3RoZXIgPT0gdGhpczogMVxuXHRcdGlmICggdGhpcy5lcShvdGhlcikgKSB7XG5cdFx0XHR0aGlzLnJlbWFpbmRlciA9IG5ldyBVSU5UMzIoMClcblx0XHRcdHRoaXMuX2xvdyA9IDFcblx0XHRcdHRoaXMuX2hpZ2ggPSAwXG5cdFx0XHRyZXR1cm4gdGhpc1xuXHRcdH1cblxuXHRcdC8vIFNoaWZ0IHRoZSBkaXZpc29yIGxlZnQgdW50aWwgaXQgaXMgaGlnaGVyIHRoYW4gdGhlIGRpdmlkZW5kXG5cdFx0dmFyIF9vdGhlciA9IG90aGVyLmNsb25lKClcblx0XHR2YXIgaSA9IC0xXG5cdFx0d2hpbGUgKCAhdGhpcy5sdChfb3RoZXIpICkge1xuXHRcdFx0Ly8gSGlnaCBiaXQgY2FuIG92ZXJmbG93IHRoZSBkZWZhdWx0IDE2Yml0c1xuXHRcdFx0Ly8gSXRzIG9rIHNpbmNlIHdlIHJpZ2h0IHNoaWZ0IGFmdGVyIHRoaXMgbG9vcFxuXHRcdFx0Ly8gVGhlIG92ZXJmbG93biBiaXQgbXVzdCBiZSBrZXB0IHRob3VnaFxuXHRcdFx0X290aGVyLnNoaWZ0TGVmdCgxLCB0cnVlKVxuXHRcdFx0aSsrXG5cdFx0fVxuXG5cdFx0Ly8gU2V0IHRoZSByZW1haW5kZXJcblx0XHR0aGlzLnJlbWFpbmRlciA9IHRoaXMuY2xvbmUoKVxuXHRcdC8vIEluaXRpYWxpemUgdGhlIGN1cnJlbnQgcmVzdWx0IHRvIDBcblx0XHR0aGlzLl9sb3cgPSAwXG5cdFx0dGhpcy5faGlnaCA9IDBcblx0XHRmb3IgKDsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdF9vdGhlci5zaGlmdFJpZ2h0KDEpXG5cdFx0XHQvLyBJZiBzaGlmdGVkIGRpdmlzb3IgaXMgc21hbGxlciB0aGFuIHRoZSBkaXZpZGVuZFxuXHRcdFx0Ly8gdGhlbiBzdWJ0cmFjdCBpdCBmcm9tIHRoZSBkaXZpZGVuZFxuXHRcdFx0aWYgKCAhdGhpcy5yZW1haW5kZXIubHQoX290aGVyKSApIHtcblx0XHRcdFx0dGhpcy5yZW1haW5kZXIuc3VidHJhY3QoX290aGVyKVxuXHRcdFx0XHQvLyBVcGRhdGUgdGhlIGN1cnJlbnQgcmVzdWx0XG5cdFx0XHRcdGlmIChpID49IDE2KSB7XG5cdFx0XHRcdFx0dGhpcy5faGlnaCB8PSAxIDw8IChpIC0gMTYpXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5fbG93IHw9IDEgPDwgaVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXNcblx0fVxuXG5cdC8qKlxuXHQgKiBOZWdhdGUgdGhlIGN1cnJlbnQgX1VJTlQzMl9cblx0ICogQG1ldGhvZCBuZWdhdGVcblx0ICogQHJldHVybiBUaGlzRXhwcmVzc2lvblxuXHQgKi9cblx0VUlOVDMyLnByb3RvdHlwZS5uZWdhdGUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHYgPSAoIH50aGlzLl9sb3cgJiAweEZGRkYgKSArIDFcblx0XHR0aGlzLl9sb3cgPSB2ICYgMHhGRkZGXG5cdFx0dGhpcy5faGlnaCA9ICh+dGhpcy5faGlnaCArICh2ID4+PiAxNikpICYgMHhGRkZGXG5cblx0XHRyZXR1cm4gdGhpc1xuXHR9XG5cblx0LyoqXG5cdCAqIEVxdWFsc1xuXHQgKiBAbWV0aG9kIGVxXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBVSU5UMzJcblx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0ICovXG5cdFVJTlQzMi5wcm90b3R5cGUuZXF1YWxzID0gVUlOVDMyLnByb3RvdHlwZS5lcSA9IGZ1bmN0aW9uIChvdGhlcikge1xuXHRcdHJldHVybiAodGhpcy5fbG93ID09IG90aGVyLl9sb3cpICYmICh0aGlzLl9oaWdoID09IG90aGVyLl9oaWdoKVxuXHR9XG5cblx0LyoqXG5cdCAqIEdyZWF0ZXIgdGhhbiAoc3RyaWN0KVxuXHQgKiBAbWV0aG9kIGd0XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBVSU5UMzJcblx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0ICovXG5cdFVJTlQzMi5wcm90b3R5cGUuZ3JlYXRlclRoYW4gPSBVSU5UMzIucHJvdG90eXBlLmd0ID0gZnVuY3Rpb24gKG90aGVyKSB7XG5cdFx0aWYgKHRoaXMuX2hpZ2ggPiBvdGhlci5faGlnaCkgcmV0dXJuIHRydWVcblx0XHRpZiAodGhpcy5faGlnaCA8IG90aGVyLl9oaWdoKSByZXR1cm4gZmFsc2Vcblx0XHRyZXR1cm4gdGhpcy5fbG93ID4gb3RoZXIuX2xvd1xuXHR9XG5cblx0LyoqXG5cdCAqIExlc3MgdGhhbiAoc3RyaWN0KVxuXHQgKiBAbWV0aG9kIGx0XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBVSU5UMzJcblx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0ICovXG5cdFVJTlQzMi5wcm90b3R5cGUubGVzc1RoYW4gPSBVSU5UMzIucHJvdG90eXBlLmx0ID0gZnVuY3Rpb24gKG90aGVyKSB7XG5cdFx0aWYgKHRoaXMuX2hpZ2ggPCBvdGhlci5faGlnaCkgcmV0dXJuIHRydWVcblx0XHRpZiAodGhpcy5faGlnaCA+IG90aGVyLl9oaWdoKSByZXR1cm4gZmFsc2Vcblx0XHRyZXR1cm4gdGhpcy5fbG93IDwgb3RoZXIuX2xvd1xuXHR9XG5cblx0LyoqXG5cdCAqIEJpdHdpc2UgT1Jcblx0ICogQG1ldGhvZCBvclxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVUlOVDMyXG5cdCAqIEByZXR1cm4gVGhpc0V4cHJlc3Npb25cblx0ICovXG5cdFVJTlQzMi5wcm90b3R5cGUub3IgPSBmdW5jdGlvbiAob3RoZXIpIHtcblx0XHR0aGlzLl9sb3cgfD0gb3RoZXIuX2xvd1xuXHRcdHRoaXMuX2hpZ2ggfD0gb3RoZXIuX2hpZ2hcblxuXHRcdHJldHVybiB0aGlzXG5cdH1cblxuXHQvKipcblx0ICogQml0d2lzZSBBTkRcblx0ICogQG1ldGhvZCBhbmRcblx0ICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFVJTlQzMlxuXHQgKiBAcmV0dXJuIFRoaXNFeHByZXNzaW9uXG5cdCAqL1xuXHRVSU5UMzIucHJvdG90eXBlLmFuZCA9IGZ1bmN0aW9uIChvdGhlcikge1xuXHRcdHRoaXMuX2xvdyAmPSBvdGhlci5fbG93XG5cdFx0dGhpcy5faGlnaCAmPSBvdGhlci5faGlnaFxuXG5cdFx0cmV0dXJuIHRoaXNcblx0fVxuXG5cdC8qKlxuXHQgKiBCaXR3aXNlIE5PVFxuXHQgKiBAbWV0aG9kIG5vdFxuXHQgKiBAcmV0dXJuIFRoaXNFeHByZXNzaW9uXG5cdCAqL1xuXHRVSU5UMzIucHJvdG90eXBlLm5vdCA9IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX2xvdyA9IH50aGlzLl9sb3cgJiAweEZGRkZcblx0XHR0aGlzLl9oaWdoID0gfnRoaXMuX2hpZ2ggJiAweEZGRkZcblxuXHRcdHJldHVybiB0aGlzXG5cdH1cblxuXHQvKipcblx0ICogQml0d2lzZSBYT1Jcblx0ICogQG1ldGhvZCB4b3Jcblx0ICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFVJTlQzMlxuXHQgKiBAcmV0dXJuIFRoaXNFeHByZXNzaW9uXG5cdCAqL1xuXHRVSU5UMzIucHJvdG90eXBlLnhvciA9IGZ1bmN0aW9uIChvdGhlcikge1xuXHRcdHRoaXMuX2xvdyBePSBvdGhlci5fbG93XG5cdFx0dGhpcy5faGlnaCBePSBvdGhlci5faGlnaFxuXG5cdFx0cmV0dXJuIHRoaXNcblx0fVxuXG5cdC8qKlxuXHQgKiBCaXR3aXNlIHNoaWZ0IHJpZ2h0XG5cdCAqIEBtZXRob2Qgc2hpZnRSaWdodFxuXHQgKiBAcGFyYW0ge051bWJlcn0gbnVtYmVyIG9mIGJpdHMgdG8gc2hpZnRcblx0ICogQHJldHVybiBUaGlzRXhwcmVzc2lvblxuXHQgKi9cblx0VUlOVDMyLnByb3RvdHlwZS5zaGlmdFJpZ2h0ID0gVUlOVDMyLnByb3RvdHlwZS5zaGlmdHIgPSBmdW5jdGlvbiAobikge1xuXHRcdGlmIChuID4gMTYpIHtcblx0XHRcdHRoaXMuX2xvdyA9IHRoaXMuX2hpZ2ggPj4gKG4gLSAxNilcblx0XHRcdHRoaXMuX2hpZ2ggPSAwXG5cdFx0fSBlbHNlIGlmIChuID09IDE2KSB7XG5cdFx0XHR0aGlzLl9sb3cgPSB0aGlzLl9oaWdoXG5cdFx0XHR0aGlzLl9oaWdoID0gMFxuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9sb3cgPSAodGhpcy5fbG93ID4+IG4pIHwgKCAodGhpcy5faGlnaCA8PCAoMTYtbikpICYgMHhGRkZGIClcblx0XHRcdHRoaXMuX2hpZ2ggPj49IG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpc1xuXHR9XG5cblx0LyoqXG5cdCAqIEJpdHdpc2Ugc2hpZnQgbGVmdFxuXHQgKiBAbWV0aG9kIHNoaWZ0TGVmdFxuXHQgKiBAcGFyYW0ge051bWJlcn0gbnVtYmVyIG9mIGJpdHMgdG8gc2hpZnRcblx0ICogQHBhcmFtIHtCb29sZWFufSBhbGxvdyBvdmVyZmxvd1xuXHQgKiBAcmV0dXJuIFRoaXNFeHByZXNzaW9uXG5cdCAqL1xuXHRVSU5UMzIucHJvdG90eXBlLnNoaWZ0TGVmdCA9IFVJTlQzMi5wcm90b3R5cGUuc2hpZnRsID0gZnVuY3Rpb24gKG4sIGFsbG93T3ZlcmZsb3cpIHtcblx0XHRpZiAobiA+IDE2KSB7XG5cdFx0XHR0aGlzLl9oaWdoID0gdGhpcy5fbG93IDw8IChuIC0gMTYpXG5cdFx0XHR0aGlzLl9sb3cgPSAwXG5cdFx0XHRpZiAoIWFsbG93T3ZlcmZsb3cpIHtcblx0XHRcdFx0dGhpcy5faGlnaCAmPSAweEZGRkZcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKG4gPT0gMTYpIHtcblx0XHRcdHRoaXMuX2hpZ2ggPSB0aGlzLl9sb3dcblx0XHRcdHRoaXMuX2xvdyA9IDBcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5faGlnaCA9ICh0aGlzLl9oaWdoIDw8IG4pIHwgKHRoaXMuX2xvdyA+PiAoMTYtbikpXG5cdFx0XHR0aGlzLl9sb3cgPSAodGhpcy5fbG93IDw8IG4pICYgMHhGRkZGXG5cdFx0XHRpZiAoIWFsbG93T3ZlcmZsb3cpIHtcblx0XHRcdFx0Ly8gT3ZlcmZsb3cgb25seSBhbGxvd2VkIG9uIHRoZSBoaWdoIGJpdHMuLi5cblx0XHRcdFx0dGhpcy5faGlnaCAmPSAweEZGRkZcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpc1xuXHR9XG5cblx0LyoqXG5cdCAqIEJpdHdpc2Ugcm90YXRlIGxlZnRcblx0ICogQG1ldGhvZCByb3RsXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBudW1iZXIgb2YgYml0cyB0byByb3RhdGVcblx0ICogQHJldHVybiBUaGlzRXhwcmVzc2lvblxuXHQgKi9cblx0VUlOVDMyLnByb3RvdHlwZS5yb3RhdGVMZWZ0ID0gVUlOVDMyLnByb3RvdHlwZS5yb3RsID0gZnVuY3Rpb24gKG4pIHtcblx0XHR2YXIgdiA9ICh0aGlzLl9oaWdoIDw8IDE2KSB8IHRoaXMuX2xvd1xuXHRcdHYgPSAodiA8PCBuKSB8ICh2ID4+PiAoMzIgLSBuKSlcblx0XHR0aGlzLl9sb3cgPSB2ICYgMHhGRkZGXG5cdFx0dGhpcy5faGlnaCA9IHYgPj4+IDE2XG5cblx0XHRyZXR1cm4gdGhpc1xuXHR9XG5cblx0LyoqXG5cdCAqIEJpdHdpc2Ugcm90YXRlIHJpZ2h0XG5cdCAqIEBtZXRob2Qgcm90clxuXHQgKiBAcGFyYW0ge051bWJlcn0gbnVtYmVyIG9mIGJpdHMgdG8gcm90YXRlXG5cdCAqIEByZXR1cm4gVGhpc0V4cHJlc3Npb25cblx0ICovXG5cdFVJTlQzMi5wcm90b3R5cGUucm90YXRlUmlnaHQgPSBVSU5UMzIucHJvdG90eXBlLnJvdHIgPSBmdW5jdGlvbiAobikge1xuXHRcdHZhciB2ID0gKHRoaXMuX2hpZ2ggPDwgMTYpIHwgdGhpcy5fbG93XG5cdFx0diA9ICh2ID4+PiBuKSB8ICh2IDw8ICgzMiAtIG4pKVxuXHRcdHRoaXMuX2xvdyA9IHYgJiAweEZGRkZcblx0XHR0aGlzLl9oaWdoID0gdiA+Pj4gMTZcblxuXHRcdHJldHVybiB0aGlzXG5cdH1cblxuXHQvKipcblx0ICogQ2xvbmUgdGhlIGN1cnJlbnQgX1VJTlQzMl9cblx0ICogQG1ldGhvZCBjbG9uZVxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IGNsb25lZCBVSU5UMzJcblx0ICovXG5cdFVJTlQzMi5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIG5ldyBVSU5UMzIodGhpcy5fbG93LCB0aGlzLl9oaWdoKVxuXHR9XG5cblx0aWYgKHR5cGVvZiBkZWZpbmUgIT0gJ3VuZGVmaW5lZCcgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIEFNRCAvIFJlcXVpcmVKU1xuXHRcdGRlZmluZShbXSwgZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIFVJTlQzMlxuXHRcdH0pXG5cdH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSAhPSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuXHRcdC8vIE5vZGUuanNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IFVJTlQzMlxuXHR9IGVsc2Uge1xuXHRcdC8vIEJyb3dzZXJcblx0XHRyb290WydVSU5UMzInXSA9IFVJTlQzMlxuXHR9XG5cbn0pKHRoaXMpXG4iLCAiLyoqXG5cdEMtbGlrZSB1bnNpZ25lZCA2NCBiaXRzIGludGVnZXJzIGluIEphdmFzY3JpcHRcblx0Q29weXJpZ2h0IChDKSAyMDEzLCBQaWVycmUgQ3VydG9cblx0TUlUIGxpY2Vuc2VcbiAqL1xuOyhmdW5jdGlvbiAocm9vdCkge1xuXG5cdC8vIExvY2FsIGNhY2hlIGZvciB0eXBpY2FsIHJhZGljZXNcblx0dmFyIHJhZGl4UG93ZXJDYWNoZSA9IHtcblx0XHQxNjogVUlOVDY0KCBNYXRoLnBvdygxNiwgNSkgKVxuXHQsXHQxMDogVUlOVDY0KCBNYXRoLnBvdygxMCwgNSkgKVxuXHQsXHQyOiAgVUlOVDY0KCBNYXRoLnBvdygyLCA1KSApXG5cdH1cblx0dmFyIHJhZGl4Q2FjaGUgPSB7XG5cdFx0MTY6IFVJTlQ2NCgxNilcblx0LFx0MTA6IFVJTlQ2NCgxMClcblx0LFx0MjogIFVJTlQ2NCgyKVxuXHR9XG5cblx0LyoqXG5cdCAqXHRSZXByZXNlbnRzIGFuIHVuc2lnbmVkIDY0IGJpdHMgaW50ZWdlclxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGZpcnN0IGxvdyBiaXRzICg4KVxuXHQgKiBAcGFyYW0ge051bWJlcn0gc2Vjb25kIGxvdyBiaXRzICg4KVxuXHQgKiBAcGFyYW0ge051bWJlcn0gZmlyc3QgaGlnaCBiaXRzICg4KVxuXHQgKiBAcGFyYW0ge051bWJlcn0gc2Vjb25kIGhpZ2ggYml0cyAoOClcblx0ICogb3Jcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGxvdyBiaXRzICgzMilcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGhpZ2ggYml0cyAoMzIpXG5cdCAqIG9yXG5cdCAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gaW50ZWdlciBhcyBhIHN0cmluZyBcdFx0IHwgaW50ZWdlciBhcyBhIG51bWJlclxuXHQgKiBAcGFyYW0ge051bWJlcnxVbmRlZmluZWR9IHJhZGl4IChvcHRpb25hbCwgZGVmYXVsdD0xMClcblx0ICogQHJldHVybiBcblx0ICovXG5cdGZ1bmN0aW9uIFVJTlQ2NCAoYTAwLCBhMTYsIGEzMiwgYTQ4KSB7XG5cdFx0aWYgKCAhKHRoaXMgaW5zdGFuY2VvZiBVSU5UNjQpIClcblx0XHRcdHJldHVybiBuZXcgVUlOVDY0KGEwMCwgYTE2LCBhMzIsIGE0OClcblxuXHRcdHRoaXMucmVtYWluZGVyID0gbnVsbFxuXHRcdGlmICh0eXBlb2YgYTAwID09ICdzdHJpbmcnKVxuXHRcdFx0cmV0dXJuIGZyb21TdHJpbmcuY2FsbCh0aGlzLCBhMDAsIGExNilcblxuXHRcdGlmICh0eXBlb2YgYTE2ID09ICd1bmRlZmluZWQnKVxuXHRcdFx0cmV0dXJuIGZyb21OdW1iZXIuY2FsbCh0aGlzLCBhMDApXG5cblx0XHRmcm9tQml0cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG5cdH1cblxuXHQvKipcblx0ICogU2V0IHRoZSBjdXJyZW50IF9VSU5UNjRfIG9iamVjdCB3aXRoIGl0cyBsb3cgYW5kIGhpZ2ggYml0c1xuXHQgKiBAbWV0aG9kIGZyb21CaXRzXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBmaXJzdCBsb3cgYml0cyAoOClcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHNlY29uZCBsb3cgYml0cyAoOClcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGZpcnN0IGhpZ2ggYml0cyAoOClcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHNlY29uZCBoaWdoIGJpdHMgKDgpXG5cdCAqIG9yXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBsb3cgYml0cyAoMzIpXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBoaWdoIGJpdHMgKDMyKVxuXHQgKiBAcmV0dXJuIFRoaXNFeHByZXNzaW9uXG5cdCAqL1xuXHRmdW5jdGlvbiBmcm9tQml0cyAoYTAwLCBhMTYsIGEzMiwgYTQ4KSB7XG5cdFx0aWYgKHR5cGVvZiBhMzIgPT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdHRoaXMuX2EwMCA9IGEwMCAmIDB4RkZGRlxuXHRcdFx0dGhpcy5fYTE2ID0gYTAwID4+PiAxNlxuXHRcdFx0dGhpcy5fYTMyID0gYTE2ICYgMHhGRkZGXG5cdFx0XHR0aGlzLl9hNDggPSBhMTYgPj4+IDE2XG5cdFx0XHRyZXR1cm4gdGhpc1xuXHRcdH1cblxuXHRcdHRoaXMuX2EwMCA9IGEwMCB8IDBcblx0XHR0aGlzLl9hMTYgPSBhMTYgfCAwXG5cdFx0dGhpcy5fYTMyID0gYTMyIHwgMFxuXHRcdHRoaXMuX2E0OCA9IGE0OCB8IDBcblxuXHRcdHJldHVybiB0aGlzXG5cdH1cblx0VUlOVDY0LnByb3RvdHlwZS5mcm9tQml0cyA9IGZyb21CaXRzXG5cblx0LyoqXG5cdCAqIFNldCB0aGUgY3VycmVudCBfVUlOVDY0XyBvYmplY3QgZnJvbSBhIG51bWJlclxuXHQgKiBAbWV0aG9kIGZyb21OdW1iZXJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IG51bWJlclxuXHQgKiBAcmV0dXJuIFRoaXNFeHByZXNzaW9uXG5cdCAqL1xuXHRmdW5jdGlvbiBmcm9tTnVtYmVyICh2YWx1ZSkge1xuXHRcdHRoaXMuX2EwMCA9IHZhbHVlICYgMHhGRkZGXG5cdFx0dGhpcy5fYTE2ID0gdmFsdWUgPj4+IDE2XG5cdFx0dGhpcy5fYTMyID0gMFxuXHRcdHRoaXMuX2E0OCA9IDBcblxuXHRcdHJldHVybiB0aGlzXG5cdH1cblx0VUlOVDY0LnByb3RvdHlwZS5mcm9tTnVtYmVyID0gZnJvbU51bWJlclxuXG5cdC8qKlxuXHQgKiBTZXQgdGhlIGN1cnJlbnQgX1VJTlQ2NF8gb2JqZWN0IGZyb20gYSBzdHJpbmdcblx0ICogQG1ldGhvZCBmcm9tU3RyaW5nXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnRlZ2VyIGFzIGEgc3RyaW5nXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByYWRpeCAob3B0aW9uYWwsIGRlZmF1bHQ9MTApXG5cdCAqIEByZXR1cm4gVGhpc0V4cHJlc3Npb25cblx0ICovXG5cdGZ1bmN0aW9uIGZyb21TdHJpbmcgKHMsIHJhZGl4KSB7XG5cdFx0cmFkaXggPSByYWRpeCB8fCAxMFxuXG5cdFx0dGhpcy5fYTAwID0gMFxuXHRcdHRoaXMuX2ExNiA9IDBcblx0XHR0aGlzLl9hMzIgPSAwXG5cdFx0dGhpcy5fYTQ4ID0gMFxuXG5cdFx0Lypcblx0XHRcdEluIEphdmFzY3JpcHQsIGJpdHdpc2Ugb3BlcmF0b3JzIG9ubHkgb3BlcmF0ZSBvbiB0aGUgZmlyc3QgMzIgYml0cyBcblx0XHRcdG9mIGEgbnVtYmVyLCBldmVuIHRob3VnaCBwYXJzZUludCgpIGVuY29kZXMgbnVtYmVycyB3aXRoIGEgNTMgYml0cyBcblx0XHRcdG1hbnRpc3NhLlxuXHRcdFx0VGhlcmVmb3JlIFVJTlQ2NCg8TnVtYmVyPikgY2FuIG9ubHkgd29yayBvbiAzMiBiaXRzLlxuXHRcdFx0VGhlIHJhZGl4IG1heGltdW0gdmFsdWUgaXMgMzYgKGFzIHBlciBFQ01BIHNwZWNzKSAoMjYgbGV0dGVycyArIDEwIGRpZ2l0cylcblx0XHRcdG1heGltdW0gaW5wdXQgdmFsdWUgaXMgbSA9IDMyYml0cyBhcyAxID0gMl4zMiAtIDFcblx0XHRcdFNvIHRoZSBtYXhpbXVtIHN1YnN0cmluZyBsZW5ndGggbiBpczpcblx0XHRcdDM2XihuKzEpIC0gMSA9IDJeMzIgLSAxXG5cdFx0XHQzNl4obisxKSA9IDJeMzJcblx0XHRcdChuKzEpbG4oMzYpID0gMzJsbigyKVxuXHRcdFx0biA9IDMybG4oMikvbG4oMzYpIC0gMVxuXHRcdFx0biA9IDUuMTg5NjQ0OTE1Njg3NjkyXG5cdFx0XHRuID0gNVxuXHRcdCAqL1xuXHRcdHZhciByYWRpeFVpbnQgPSByYWRpeFBvd2VyQ2FjaGVbcmFkaXhdIHx8IG5ldyBVSU5UNjQoIE1hdGgucG93KHJhZGl4LCA1KSApXG5cblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gcy5sZW5ndGg7IGkgPCBsZW47IGkgKz0gNSkge1xuXHRcdFx0dmFyIHNpemUgPSBNYXRoLm1pbig1LCBsZW4gLSBpKVxuXHRcdFx0dmFyIHZhbHVlID0gcGFyc2VJbnQoIHMuc2xpY2UoaSwgaSArIHNpemUpLCByYWRpeCApXG5cdFx0XHR0aGlzLm11bHRpcGx5KFxuXHRcdFx0XHRcdHNpemUgPCA1XG5cdFx0XHRcdFx0XHQ/IG5ldyBVSU5UNjQoIE1hdGgucG93KHJhZGl4LCBzaXplKSApXG5cdFx0XHRcdFx0XHQ6IHJhZGl4VWludFxuXHRcdFx0XHQpXG5cdFx0XHRcdC5hZGQoIG5ldyBVSU5UNjQodmFsdWUpIClcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpc1xuXHR9XG5cdFVJTlQ2NC5wcm90b3R5cGUuZnJvbVN0cmluZyA9IGZyb21TdHJpbmdcblxuXHQvKipcblx0ICogQ29udmVydCB0aGlzIF9VSU5UNjRfIHRvIGEgbnVtYmVyIChsYXN0IDMyIGJpdHMgYXJlIGRyb3BwZWQpXG5cdCAqIEBtZXRob2QgdG9OdW1iZXJcblx0ICogQHJldHVybiB7TnVtYmVyfSB0aGUgY29udmVydGVkIFVJTlQ2NFxuXHQgKi9cblx0VUlOVDY0LnByb3RvdHlwZS50b051bWJlciA9IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gKHRoaXMuX2ExNiAqIDY1NTM2KSArIHRoaXMuX2EwMFxuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnQgdGhpcyBfVUlOVDY0XyB0byBhIHN0cmluZ1xuXHQgKiBAbWV0aG9kIHRvU3RyaW5nXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByYWRpeCAob3B0aW9uYWwsIGRlZmF1bHQ9MTApXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gdGhlIGNvbnZlcnRlZCBVSU5UNjRcblx0ICovXG5cdFVJTlQ2NC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAocmFkaXgpIHtcblx0XHRyYWRpeCA9IHJhZGl4IHx8IDEwXG5cdFx0dmFyIHJhZGl4VWludCA9IHJhZGl4Q2FjaGVbcmFkaXhdIHx8IG5ldyBVSU5UNjQocmFkaXgpXG5cblx0XHRpZiAoICF0aGlzLmd0KHJhZGl4VWludCkgKSByZXR1cm4gdGhpcy50b051bWJlcigpLnRvU3RyaW5nKHJhZGl4KVxuXG5cdFx0dmFyIHNlbGYgPSB0aGlzLmNsb25lKClcblx0XHR2YXIgcmVzID0gbmV3IEFycmF5KDY0KVxuXHRcdGZvciAodmFyIGkgPSA2MzsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdHNlbGYuZGl2KHJhZGl4VWludClcblx0XHRcdHJlc1tpXSA9IHNlbGYucmVtYWluZGVyLnRvTnVtYmVyKCkudG9TdHJpbmcocmFkaXgpXG5cdFx0XHRpZiAoICFzZWxmLmd0KHJhZGl4VWludCkgKSBicmVha1xuXHRcdH1cblx0XHRyZXNbaS0xXSA9IHNlbGYudG9OdW1iZXIoKS50b1N0cmluZyhyYWRpeClcblxuXHRcdHJldHVybiByZXMuam9pbignJylcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGQgdHdvIF9VSU5UNjRfLiBUaGUgY3VycmVudCBfVUlOVDY0XyBzdG9yZXMgdGhlIHJlc3VsdFxuXHQgKiBAbWV0aG9kIGFkZFxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVUlOVDY0XG5cdCAqIEByZXR1cm4gVGhpc0V4cHJlc3Npb25cblx0ICovXG5cdFVJTlQ2NC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKG90aGVyKSB7XG5cdFx0dmFyIGEwMCA9IHRoaXMuX2EwMCArIG90aGVyLl9hMDBcblxuXHRcdHZhciBhMTYgPSBhMDAgPj4+IDE2XG5cdFx0YTE2ICs9IHRoaXMuX2ExNiArIG90aGVyLl9hMTZcblxuXHRcdHZhciBhMzIgPSBhMTYgPj4+IDE2XG5cdFx0YTMyICs9IHRoaXMuX2EzMiArIG90aGVyLl9hMzJcblxuXHRcdHZhciBhNDggPSBhMzIgPj4+IDE2XG5cdFx0YTQ4ICs9IHRoaXMuX2E0OCArIG90aGVyLl9hNDhcblxuXHRcdHRoaXMuX2EwMCA9IGEwMCAmIDB4RkZGRlxuXHRcdHRoaXMuX2ExNiA9IGExNiAmIDB4RkZGRlxuXHRcdHRoaXMuX2EzMiA9IGEzMiAmIDB4RkZGRlxuXHRcdHRoaXMuX2E0OCA9IGE0OCAmIDB4RkZGRlxuXG5cdFx0cmV0dXJuIHRoaXNcblx0fVxuXG5cdC8qKlxuXHQgKiBTdWJ0cmFjdCB0d28gX1VJTlQ2NF8uIFRoZSBjdXJyZW50IF9VSU5UNjRfIHN0b3JlcyB0aGUgcmVzdWx0XG5cdCAqIEBtZXRob2Qgc3VidHJhY3Rcblx0ICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFVJTlQ2NFxuXHQgKiBAcmV0dXJuIFRoaXNFeHByZXNzaW9uXG5cdCAqL1xuXHRVSU5UNjQucHJvdG90eXBlLnN1YnRyYWN0ID0gZnVuY3Rpb24gKG90aGVyKSB7XG5cdFx0cmV0dXJuIHRoaXMuYWRkKCBvdGhlci5jbG9uZSgpLm5lZ2F0ZSgpIClcblx0fVxuXG5cdC8qKlxuXHQgKiBNdWx0aXBseSB0d28gX1VJTlQ2NF8uIFRoZSBjdXJyZW50IF9VSU5UNjRfIHN0b3JlcyB0aGUgcmVzdWx0XG5cdCAqIEBtZXRob2QgbXVsdGlwbHlcblx0ICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFVJTlQ2NFxuXHQgKiBAcmV0dXJuIFRoaXNFeHByZXNzaW9uXG5cdCAqL1xuXHRVSU5UNjQucHJvdG90eXBlLm11bHRpcGx5ID0gZnVuY3Rpb24gKG90aGVyKSB7XG5cdFx0Lypcblx0XHRcdGEgPSBhMDAgKyBhMTYgKyBhMzIgKyBhNDhcblx0XHRcdGIgPSBiMDAgKyBiMTYgKyBiMzIgKyBiNDhcblx0XHRcdGEqYiA9IChhMDAgKyBhMTYgKyBhMzIgKyBhNDgpKGIwMCArIGIxNiArIGIzMiArIGI0OClcblx0XHRcdFx0PSBhMDBiMDAgKyBhMDBiMTYgKyBhMDBiMzIgKyBhMDBiNDhcblx0XHRcdFx0KyBhMTZiMDAgKyBhMTZiMTYgKyBhMTZiMzIgKyBhMTZiNDhcblx0XHRcdFx0KyBhMzJiMDAgKyBhMzJiMTYgKyBhMzJiMzIgKyBhMzJiNDhcblx0XHRcdFx0KyBhNDhiMDAgKyBhNDhiMTYgKyBhNDhiMzIgKyBhNDhiNDhcblxuXHRcdFx0YTE2YjQ4LCBhMzJiMzIsIGE0OGIxNiwgYTQ4YjMyIGFuZCBhNDhiNDggb3ZlcmZsb3cgdGhlIDY0IGJpdHNcblx0XHRcdHNvIGl0IGNvbWVzIGRvd24gdG86XG5cdFx0XHRhKmJcdD0gYTAwYjAwICsgYTAwYjE2ICsgYTAwYjMyICsgYTAwYjQ4XG5cdFx0XHRcdCsgYTE2YjAwICsgYTE2YjE2ICsgYTE2YjMyXG5cdFx0XHRcdCsgYTMyYjAwICsgYTMyYjE2XG5cdFx0XHRcdCsgYTQ4YjAwXG5cdFx0XHRcdD0gYTAwYjAwXG5cdFx0XHRcdCsgYTAwYjE2ICsgYTE2YjAwXG5cdFx0XHRcdCsgYTAwYjMyICsgYTE2YjE2ICsgYTMyYjAwXG5cdFx0XHRcdCsgYTAwYjQ4ICsgYTE2YjMyICsgYTMyYjE2ICsgYTQ4YjAwXG5cdFx0ICovXG5cdFx0dmFyIGEwMCA9IHRoaXMuX2EwMFxuXHRcdHZhciBhMTYgPSB0aGlzLl9hMTZcblx0XHR2YXIgYTMyID0gdGhpcy5fYTMyXG5cdFx0dmFyIGE0OCA9IHRoaXMuX2E0OFxuXHRcdHZhciBiMDAgPSBvdGhlci5fYTAwXG5cdFx0dmFyIGIxNiA9IG90aGVyLl9hMTZcblx0XHR2YXIgYjMyID0gb3RoZXIuX2EzMlxuXHRcdHZhciBiNDggPSBvdGhlci5fYTQ4XG5cblx0XHR2YXIgYzAwID0gYTAwICogYjAwXG5cblx0XHR2YXIgYzE2ID0gYzAwID4+PiAxNlxuXHRcdGMxNiArPSBhMDAgKiBiMTZcblx0XHR2YXIgYzMyID0gYzE2ID4+PiAxNlxuXHRcdGMxNiAmPSAweEZGRkZcblx0XHRjMTYgKz0gYTE2ICogYjAwXG5cblx0XHRjMzIgKz0gYzE2ID4+PiAxNlxuXHRcdGMzMiArPSBhMDAgKiBiMzJcblx0XHR2YXIgYzQ4ID0gYzMyID4+PiAxNlxuXHRcdGMzMiAmPSAweEZGRkZcblx0XHRjMzIgKz0gYTE2ICogYjE2XG5cdFx0YzQ4ICs9IGMzMiA+Pj4gMTZcblx0XHRjMzIgJj0gMHhGRkZGXG5cdFx0YzMyICs9IGEzMiAqIGIwMFxuXG5cdFx0YzQ4ICs9IGMzMiA+Pj4gMTZcblx0XHRjNDggKz0gYTAwICogYjQ4XG5cdFx0YzQ4ICY9IDB4RkZGRlxuXHRcdGM0OCArPSBhMTYgKiBiMzJcblx0XHRjNDggJj0gMHhGRkZGXG5cdFx0YzQ4ICs9IGEzMiAqIGIxNlxuXHRcdGM0OCAmPSAweEZGRkZcblx0XHRjNDggKz0gYTQ4ICogYjAwXG5cblx0XHR0aGlzLl9hMDAgPSBjMDAgJiAweEZGRkZcblx0XHR0aGlzLl9hMTYgPSBjMTYgJiAweEZGRkZcblx0XHR0aGlzLl9hMzIgPSBjMzIgJiAweEZGRkZcblx0XHR0aGlzLl9hNDggPSBjNDggJiAweEZGRkZcblxuXHRcdHJldHVybiB0aGlzXG5cdH1cblxuXHQvKipcblx0ICogRGl2aWRlIHR3byBfVUlOVDY0Xy4gVGhlIGN1cnJlbnQgX1VJTlQ2NF8gc3RvcmVzIHRoZSByZXN1bHQuXG5cdCAqIFRoZSByZW1haW5kZXIgaXMgbWFkZSBhdmFpbGFibGUgYXMgdGhlIF9yZW1haW5kZXJfIHByb3BlcnR5IG9uXG5cdCAqIHRoZSBfVUlOVDY0XyBvYmplY3QuIEl0IGNhbiBiZSBudWxsLCBtZWFuaW5nIHRoZXJlIGFyZSBubyByZW1haW5kZXIuXG5cdCAqIEBtZXRob2QgZGl2XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBVSU5UNjRcblx0ICogQHJldHVybiBUaGlzRXhwcmVzc2lvblxuXHQgKi9cblx0VUlOVDY0LnByb3RvdHlwZS5kaXYgPSBmdW5jdGlvbiAob3RoZXIpIHtcblx0XHRpZiAoIChvdGhlci5fYTE2ID09IDApICYmIChvdGhlci5fYTMyID09IDApICYmIChvdGhlci5fYTQ4ID09IDApICkge1xuXHRcdFx0aWYgKG90aGVyLl9hMDAgPT0gMCkgdGhyb3cgRXJyb3IoJ2RpdmlzaW9uIGJ5IHplcm8nKVxuXG5cdFx0XHQvLyBvdGhlciA9PSAxOiB0aGlzXG5cdFx0XHRpZiAob3RoZXIuX2EwMCA9PSAxKSB7XG5cdFx0XHRcdHRoaXMucmVtYWluZGVyID0gbmV3IFVJTlQ2NCgwKVxuXHRcdFx0XHRyZXR1cm4gdGhpc1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIG90aGVyID4gdGhpczogMFxuXHRcdGlmICggb3RoZXIuZ3QodGhpcykgKSB7XG5cdFx0XHR0aGlzLnJlbWFpbmRlciA9IHRoaXMuY2xvbmUoKVxuXHRcdFx0dGhpcy5fYTAwID0gMFxuXHRcdFx0dGhpcy5fYTE2ID0gMFxuXHRcdFx0dGhpcy5fYTMyID0gMFxuXHRcdFx0dGhpcy5fYTQ4ID0gMFxuXHRcdFx0cmV0dXJuIHRoaXNcblx0XHR9XG5cdFx0Ly8gb3RoZXIgPT0gdGhpczogMVxuXHRcdGlmICggdGhpcy5lcShvdGhlcikgKSB7XG5cdFx0XHR0aGlzLnJlbWFpbmRlciA9IG5ldyBVSU5UNjQoMClcblx0XHRcdHRoaXMuX2EwMCA9IDFcblx0XHRcdHRoaXMuX2ExNiA9IDBcblx0XHRcdHRoaXMuX2EzMiA9IDBcblx0XHRcdHRoaXMuX2E0OCA9IDBcblx0XHRcdHJldHVybiB0aGlzXG5cdFx0fVxuXG5cdFx0Ly8gU2hpZnQgdGhlIGRpdmlzb3IgbGVmdCB1bnRpbCBpdCBpcyBoaWdoZXIgdGhhbiB0aGUgZGl2aWRlbmRcblx0XHR2YXIgX290aGVyID0gb3RoZXIuY2xvbmUoKVxuXHRcdHZhciBpID0gLTFcblx0XHR3aGlsZSAoICF0aGlzLmx0KF9vdGhlcikgKSB7XG5cdFx0XHQvLyBIaWdoIGJpdCBjYW4gb3ZlcmZsb3cgdGhlIGRlZmF1bHQgMTZiaXRzXG5cdFx0XHQvLyBJdHMgb2sgc2luY2Ugd2UgcmlnaHQgc2hpZnQgYWZ0ZXIgdGhpcyBsb29wXG5cdFx0XHQvLyBUaGUgb3ZlcmZsb3duIGJpdCBtdXN0IGJlIGtlcHQgdGhvdWdoXG5cdFx0XHRfb3RoZXIuc2hpZnRMZWZ0KDEsIHRydWUpXG5cdFx0XHRpKytcblx0XHR9XG5cblx0XHQvLyBTZXQgdGhlIHJlbWFpbmRlclxuXHRcdHRoaXMucmVtYWluZGVyID0gdGhpcy5jbG9uZSgpXG5cdFx0Ly8gSW5pdGlhbGl6ZSB0aGUgY3VycmVudCByZXN1bHQgdG8gMFxuXHRcdHRoaXMuX2EwMCA9IDBcblx0XHR0aGlzLl9hMTYgPSAwXG5cdFx0dGhpcy5fYTMyID0gMFxuXHRcdHRoaXMuX2E0OCA9IDBcblx0XHRmb3IgKDsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdF9vdGhlci5zaGlmdFJpZ2h0KDEpXG5cdFx0XHQvLyBJZiBzaGlmdGVkIGRpdmlzb3IgaXMgc21hbGxlciB0aGFuIHRoZSBkaXZpZGVuZFxuXHRcdFx0Ly8gdGhlbiBzdWJ0cmFjdCBpdCBmcm9tIHRoZSBkaXZpZGVuZFxuXHRcdFx0aWYgKCAhdGhpcy5yZW1haW5kZXIubHQoX290aGVyKSApIHtcblx0XHRcdFx0dGhpcy5yZW1haW5kZXIuc3VidHJhY3QoX290aGVyKVxuXHRcdFx0XHQvLyBVcGRhdGUgdGhlIGN1cnJlbnQgcmVzdWx0XG5cdFx0XHRcdGlmIChpID49IDQ4KSB7XG5cdFx0XHRcdFx0dGhpcy5fYTQ4IHw9IDEgPDwgKGkgLSA0OClcblx0XHRcdFx0fSBlbHNlIGlmIChpID49IDMyKSB7XG5cdFx0XHRcdFx0dGhpcy5fYTMyIHw9IDEgPDwgKGkgLSAzMilcblx0XHRcdFx0fSBlbHNlIGlmIChpID49IDE2KSB7XG5cdFx0XHRcdFx0dGhpcy5fYTE2IHw9IDEgPDwgKGkgLSAxNilcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLl9hMDAgfD0gMSA8PCBpXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpc1xuXHR9XG5cblx0LyoqXG5cdCAqIE5lZ2F0ZSB0aGUgY3VycmVudCBfVUlOVDY0X1xuXHQgKiBAbWV0aG9kIG5lZ2F0ZVxuXHQgKiBAcmV0dXJuIFRoaXNFeHByZXNzaW9uXG5cdCAqL1xuXHRVSU5UNjQucHJvdG90eXBlLm5lZ2F0ZSA9IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgdiA9ICggfnRoaXMuX2EwMCAmIDB4RkZGRiApICsgMVxuXHRcdHRoaXMuX2EwMCA9IHYgJiAweEZGRkZcblx0XHR2ID0gKH50aGlzLl9hMTYgJiAweEZGRkYpICsgKHYgPj4+IDE2KVxuXHRcdHRoaXMuX2ExNiA9IHYgJiAweEZGRkZcblx0XHR2ID0gKH50aGlzLl9hMzIgJiAweEZGRkYpICsgKHYgPj4+IDE2KVxuXHRcdHRoaXMuX2EzMiA9IHYgJiAweEZGRkZcblx0XHR0aGlzLl9hNDggPSAofnRoaXMuX2E0OCArICh2ID4+PiAxNikpICYgMHhGRkZGXG5cblx0XHRyZXR1cm4gdGhpc1xuXHR9XG5cblx0LyoqXG5cblx0ICogQG1ldGhvZCBlcVxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVUlOVDY0XG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59XG5cdCAqL1xuXHRVSU5UNjQucHJvdG90eXBlLmVxdWFscyA9IFVJTlQ2NC5wcm90b3R5cGUuZXEgPSBmdW5jdGlvbiAob3RoZXIpIHtcblx0XHRyZXR1cm4gKHRoaXMuX2E0OCA9PSBvdGhlci5fYTQ4KSAmJiAodGhpcy5fYTAwID09IG90aGVyLl9hMDApXG5cdFx0XHQgJiYgKHRoaXMuX2EzMiA9PSBvdGhlci5fYTMyKSAmJiAodGhpcy5fYTE2ID09IG90aGVyLl9hMTYpXG5cdH1cblxuXHQvKipcblx0ICogR3JlYXRlciB0aGFuIChzdHJpY3QpXG5cdCAqIEBtZXRob2QgZ3Rcblx0ICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFVJTlQ2NFxuXHQgKiBAcmV0dXJuIHtCb29sZWFufVxuXHQgKi9cblx0VUlOVDY0LnByb3RvdHlwZS5ncmVhdGVyVGhhbiA9IFVJTlQ2NC5wcm90b3R5cGUuZ3QgPSBmdW5jdGlvbiAob3RoZXIpIHtcblx0XHRpZiAodGhpcy5fYTQ4ID4gb3RoZXIuX2E0OCkgcmV0dXJuIHRydWVcblx0XHRpZiAodGhpcy5fYTQ4IDwgb3RoZXIuX2E0OCkgcmV0dXJuIGZhbHNlXG5cdFx0aWYgKHRoaXMuX2EzMiA+IG90aGVyLl9hMzIpIHJldHVybiB0cnVlXG5cdFx0aWYgKHRoaXMuX2EzMiA8IG90aGVyLl9hMzIpIHJldHVybiBmYWxzZVxuXHRcdGlmICh0aGlzLl9hMTYgPiBvdGhlci5fYTE2KSByZXR1cm4gdHJ1ZVxuXHRcdGlmICh0aGlzLl9hMTYgPCBvdGhlci5fYTE2KSByZXR1cm4gZmFsc2Vcblx0XHRyZXR1cm4gdGhpcy5fYTAwID4gb3RoZXIuX2EwMFxuXHR9XG5cblx0LyoqXG5cdCAqIExlc3MgdGhhbiAoc3RyaWN0KVxuXHQgKiBAbWV0aG9kIGx0XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBVSU5UNjRcblx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0ICovXG5cdFVJTlQ2NC5wcm90b3R5cGUubGVzc1RoYW4gPSBVSU5UNjQucHJvdG90eXBlLmx0ID0gZnVuY3Rpb24gKG90aGVyKSB7XG5cdFx0aWYgKHRoaXMuX2E0OCA8IG90aGVyLl9hNDgpIHJldHVybiB0cnVlXG5cdFx0aWYgKHRoaXMuX2E0OCA+IG90aGVyLl9hNDgpIHJldHVybiBmYWxzZVxuXHRcdGlmICh0aGlzLl9hMzIgPCBvdGhlci5fYTMyKSByZXR1cm4gdHJ1ZVxuXHRcdGlmICh0aGlzLl9hMzIgPiBvdGhlci5fYTMyKSByZXR1cm4gZmFsc2Vcblx0XHRpZiAodGhpcy5fYTE2IDwgb3RoZXIuX2ExNikgcmV0dXJuIHRydWVcblx0XHRpZiAodGhpcy5fYTE2ID4gb3RoZXIuX2ExNikgcmV0dXJuIGZhbHNlXG5cdFx0cmV0dXJuIHRoaXMuX2EwMCA8IG90aGVyLl9hMDBcblx0fVxuXG5cdC8qKlxuXHQgKiBCaXR3aXNlIE9SXG5cdCAqIEBtZXRob2Qgb3Jcblx0ICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFVJTlQ2NFxuXHQgKiBAcmV0dXJuIFRoaXNFeHByZXNzaW9uXG5cdCAqL1xuXHRVSU5UNjQucHJvdG90eXBlLm9yID0gZnVuY3Rpb24gKG90aGVyKSB7XG5cdFx0dGhpcy5fYTAwIHw9IG90aGVyLl9hMDBcblx0XHR0aGlzLl9hMTYgfD0gb3RoZXIuX2ExNlxuXHRcdHRoaXMuX2EzMiB8PSBvdGhlci5fYTMyXG5cdFx0dGhpcy5fYTQ4IHw9IG90aGVyLl9hNDhcblxuXHRcdHJldHVybiB0aGlzXG5cdH1cblxuXHQvKipcblx0ICogQml0d2lzZSBBTkRcblx0ICogQG1ldGhvZCBhbmRcblx0ICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFVJTlQ2NFxuXHQgKiBAcmV0dXJuIFRoaXNFeHByZXNzaW9uXG5cdCAqL1xuXHRVSU5UNjQucHJvdG90eXBlLmFuZCA9IGZ1bmN0aW9uIChvdGhlcikge1xuXHRcdHRoaXMuX2EwMCAmPSBvdGhlci5fYTAwXG5cdFx0dGhpcy5fYTE2ICY9IG90aGVyLl9hMTZcblx0XHR0aGlzLl9hMzIgJj0gb3RoZXIuX2EzMlxuXHRcdHRoaXMuX2E0OCAmPSBvdGhlci5fYTQ4XG5cblx0XHRyZXR1cm4gdGhpc1xuXHR9XG5cblx0LyoqXG5cdCAqIEJpdHdpc2UgWE9SXG5cdCAqIEBtZXRob2QgeG9yXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBVSU5UNjRcblx0ICogQHJldHVybiBUaGlzRXhwcmVzc2lvblxuXHQgKi9cblx0VUlOVDY0LnByb3RvdHlwZS54b3IgPSBmdW5jdGlvbiAob3RoZXIpIHtcblx0XHR0aGlzLl9hMDAgXj0gb3RoZXIuX2EwMFxuXHRcdHRoaXMuX2ExNiBePSBvdGhlci5fYTE2XG5cdFx0dGhpcy5fYTMyIF49IG90aGVyLl9hMzJcblx0XHR0aGlzLl9hNDggXj0gb3RoZXIuX2E0OFxuXG5cdFx0cmV0dXJuIHRoaXNcblx0fVxuXG5cdC8qKlxuXHQgKiBCaXR3aXNlIE5PVFxuXHQgKiBAbWV0aG9kIG5vdFxuXHQgKiBAcmV0dXJuIFRoaXNFeHByZXNzaW9uXG5cdCAqL1xuXHRVSU5UNjQucHJvdG90eXBlLm5vdCA9IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX2EwMCA9IH50aGlzLl9hMDAgJiAweEZGRkZcblx0XHR0aGlzLl9hMTYgPSB+dGhpcy5fYTE2ICYgMHhGRkZGXG5cdFx0dGhpcy5fYTMyID0gfnRoaXMuX2EzMiAmIDB4RkZGRlxuXHRcdHRoaXMuX2E0OCA9IH50aGlzLl9hNDggJiAweEZGRkZcblxuXHRcdHJldHVybiB0aGlzXG5cdH1cblxuXHQvKipcblx0ICogQml0d2lzZSBzaGlmdCByaWdodFxuXHQgKiBAbWV0aG9kIHNoaWZ0UmlnaHRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IG51bWJlciBvZiBiaXRzIHRvIHNoaWZ0XG5cdCAqIEByZXR1cm4gVGhpc0V4cHJlc3Npb25cblx0ICovXG5cdFVJTlQ2NC5wcm90b3R5cGUuc2hpZnRSaWdodCA9IFVJTlQ2NC5wcm90b3R5cGUuc2hpZnRyID0gZnVuY3Rpb24gKG4pIHtcblx0XHRuICU9IDY0XG5cdFx0aWYgKG4gPj0gNDgpIHtcblx0XHRcdHRoaXMuX2EwMCA9IHRoaXMuX2E0OCA+PiAobiAtIDQ4KVxuXHRcdFx0dGhpcy5fYTE2ID0gMFxuXHRcdFx0dGhpcy5fYTMyID0gMFxuXHRcdFx0dGhpcy5fYTQ4ID0gMFxuXHRcdH0gZWxzZSBpZiAobiA+PSAzMikge1xuXHRcdFx0biAtPSAzMlxuXHRcdFx0dGhpcy5fYTAwID0gKCAodGhpcy5fYTMyID4+IG4pIHwgKHRoaXMuX2E0OCA8PCAoMTYtbikpICkgJiAweEZGRkZcblx0XHRcdHRoaXMuX2ExNiA9ICh0aGlzLl9hNDggPj4gbikgJiAweEZGRkZcblx0XHRcdHRoaXMuX2EzMiA9IDBcblx0XHRcdHRoaXMuX2E0OCA9IDBcblx0XHR9IGVsc2UgaWYgKG4gPj0gMTYpIHtcblx0XHRcdG4gLT0gMTZcblx0XHRcdHRoaXMuX2EwMCA9ICggKHRoaXMuX2ExNiA+PiBuKSB8ICh0aGlzLl9hMzIgPDwgKDE2LW4pKSApICYgMHhGRkZGXG5cdFx0XHR0aGlzLl9hMTYgPSAoICh0aGlzLl9hMzIgPj4gbikgfCAodGhpcy5fYTQ4IDw8ICgxNi1uKSkgKSAmIDB4RkZGRlxuXHRcdFx0dGhpcy5fYTMyID0gKHRoaXMuX2E0OCA+PiBuKSAmIDB4RkZGRlxuXHRcdFx0dGhpcy5fYTQ4ID0gMFxuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9hMDAgPSAoICh0aGlzLl9hMDAgPj4gbikgfCAodGhpcy5fYTE2IDw8ICgxNi1uKSkgKSAmIDB4RkZGRlxuXHRcdFx0dGhpcy5fYTE2ID0gKCAodGhpcy5fYTE2ID4+IG4pIHwgKHRoaXMuX2EzMiA8PCAoMTYtbikpICkgJiAweEZGRkZcblx0XHRcdHRoaXMuX2EzMiA9ICggKHRoaXMuX2EzMiA+PiBuKSB8ICh0aGlzLl9hNDggPDwgKDE2LW4pKSApICYgMHhGRkZGXG5cdFx0XHR0aGlzLl9hNDggPSAodGhpcy5fYTQ4ID4+IG4pICYgMHhGRkZGXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXNcblx0fVxuXG5cdC8qKlxuXHQgKiBCaXR3aXNlIHNoaWZ0IGxlZnRcblx0ICogQG1ldGhvZCBzaGlmdExlZnRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IG51bWJlciBvZiBiaXRzIHRvIHNoaWZ0XG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gYWxsb3cgb3ZlcmZsb3dcblx0ICogQHJldHVybiBUaGlzRXhwcmVzc2lvblxuXHQgKi9cblx0VUlOVDY0LnByb3RvdHlwZS5zaGlmdExlZnQgPSBVSU5UNjQucHJvdG90eXBlLnNoaWZ0bCA9IGZ1bmN0aW9uIChuLCBhbGxvd092ZXJmbG93KSB7XG5cdFx0biAlPSA2NFxuXHRcdGlmIChuID49IDQ4KSB7XG5cdFx0XHR0aGlzLl9hNDggPSB0aGlzLl9hMDAgPDwgKG4gLSA0OClcblx0XHRcdHRoaXMuX2EzMiA9IDBcblx0XHRcdHRoaXMuX2ExNiA9IDBcblx0XHRcdHRoaXMuX2EwMCA9IDBcblx0XHR9IGVsc2UgaWYgKG4gPj0gMzIpIHtcblx0XHRcdG4gLT0gMzJcblx0XHRcdHRoaXMuX2E0OCA9ICh0aGlzLl9hMTYgPDwgbikgfCAodGhpcy5fYTAwID4+ICgxNi1uKSlcblx0XHRcdHRoaXMuX2EzMiA9ICh0aGlzLl9hMDAgPDwgbikgJiAweEZGRkZcblx0XHRcdHRoaXMuX2ExNiA9IDBcblx0XHRcdHRoaXMuX2EwMCA9IDBcblx0XHR9IGVsc2UgaWYgKG4gPj0gMTYpIHtcblx0XHRcdG4gLT0gMTZcblx0XHRcdHRoaXMuX2E0OCA9ICh0aGlzLl9hMzIgPDwgbikgfCAodGhpcy5fYTE2ID4+ICgxNi1uKSlcblx0XHRcdHRoaXMuX2EzMiA9ICggKHRoaXMuX2ExNiA8PCBuKSB8ICh0aGlzLl9hMDAgPj4gKDE2LW4pKSApICYgMHhGRkZGXG5cdFx0XHR0aGlzLl9hMTYgPSAodGhpcy5fYTAwIDw8IG4pICYgMHhGRkZGXG5cdFx0XHR0aGlzLl9hMDAgPSAwXG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX2E0OCA9ICh0aGlzLl9hNDggPDwgbikgfCAodGhpcy5fYTMyID4+ICgxNi1uKSlcblx0XHRcdHRoaXMuX2EzMiA9ICggKHRoaXMuX2EzMiA8PCBuKSB8ICh0aGlzLl9hMTYgPj4gKDE2LW4pKSApICYgMHhGRkZGXG5cdFx0XHR0aGlzLl9hMTYgPSAoICh0aGlzLl9hMTYgPDwgbikgfCAodGhpcy5fYTAwID4+ICgxNi1uKSkgKSAmIDB4RkZGRlxuXHRcdFx0dGhpcy5fYTAwID0gKHRoaXMuX2EwMCA8PCBuKSAmIDB4RkZGRlxuXHRcdH1cblx0XHRpZiAoIWFsbG93T3ZlcmZsb3cpIHtcblx0XHRcdHRoaXMuX2E0OCAmPSAweEZGRkZcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpc1xuXHR9XG5cblx0LyoqXG5cdCAqIEJpdHdpc2Ugcm90YXRlIGxlZnRcblx0ICogQG1ldGhvZCByb3RsXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBudW1iZXIgb2YgYml0cyB0byByb3RhdGVcblx0ICogQHJldHVybiBUaGlzRXhwcmVzc2lvblxuXHQgKi9cblx0VUlOVDY0LnByb3RvdHlwZS5yb3RhdGVMZWZ0ID0gVUlOVDY0LnByb3RvdHlwZS5yb3RsID0gZnVuY3Rpb24gKG4pIHtcblx0XHRuICU9IDY0XG5cdFx0aWYgKG4gPT0gMCkgcmV0dXJuIHRoaXNcblx0XHRpZiAobiA+PSAzMikge1xuXHRcdFx0Ly8gQS5CLkMuRFxuXHRcdFx0Ly8gQi5DLkQuQSByb3RsKDE2KVxuXHRcdFx0Ly8gQy5ELkEuQiByb3RsKDMyKVxuXHRcdFx0dmFyIHYgPSB0aGlzLl9hMDBcblx0XHRcdHRoaXMuX2EwMCA9IHRoaXMuX2EzMlxuXHRcdFx0dGhpcy5fYTMyID0gdlxuXHRcdFx0diA9IHRoaXMuX2E0OFxuXHRcdFx0dGhpcy5fYTQ4ID0gdGhpcy5fYTE2XG5cdFx0XHR0aGlzLl9hMTYgPSB2XG5cdFx0XHRpZiAobiA9PSAzMikgcmV0dXJuIHRoaXNcblx0XHRcdG4gLT0gMzJcblx0XHR9XG5cblx0XHR2YXIgaGlnaCA9ICh0aGlzLl9hNDggPDwgMTYpIHwgdGhpcy5fYTMyXG5cdFx0dmFyIGxvdyA9ICh0aGlzLl9hMTYgPDwgMTYpIHwgdGhpcy5fYTAwXG5cblx0XHR2YXIgX2hpZ2ggPSAoaGlnaCA8PCBuKSB8IChsb3cgPj4+ICgzMiAtIG4pKVxuXHRcdHZhciBfbG93ID0gKGxvdyA8PCBuKSB8IChoaWdoID4+PiAoMzIgLSBuKSlcblxuXHRcdHRoaXMuX2EwMCA9IF9sb3cgJiAweEZGRkZcblx0XHR0aGlzLl9hMTYgPSBfbG93ID4+PiAxNlxuXHRcdHRoaXMuX2EzMiA9IF9oaWdoICYgMHhGRkZGXG5cdFx0dGhpcy5fYTQ4ID0gX2hpZ2ggPj4+IDE2XG5cblx0XHRyZXR1cm4gdGhpc1xuXHR9XG5cblx0LyoqXG5cdCAqIEJpdHdpc2Ugcm90YXRlIHJpZ2h0XG5cdCAqIEBtZXRob2Qgcm90clxuXHQgKiBAcGFyYW0ge051bWJlcn0gbnVtYmVyIG9mIGJpdHMgdG8gcm90YXRlXG5cdCAqIEByZXR1cm4gVGhpc0V4cHJlc3Npb25cblx0ICovXG5cdFVJTlQ2NC5wcm90b3R5cGUucm90YXRlUmlnaHQgPSBVSU5UNjQucHJvdG90eXBlLnJvdHIgPSBmdW5jdGlvbiAobikge1xuXHRcdG4gJT0gNjRcblx0XHRpZiAobiA9PSAwKSByZXR1cm4gdGhpc1xuXHRcdGlmIChuID49IDMyKSB7XG5cdFx0XHQvLyBBLkIuQy5EXG5cdFx0XHQvLyBELkEuQi5DIHJvdHIoMTYpXG5cdFx0XHQvLyBDLkQuQS5CIHJvdHIoMzIpXG5cdFx0XHR2YXIgdiA9IHRoaXMuX2EwMFxuXHRcdFx0dGhpcy5fYTAwID0gdGhpcy5fYTMyXG5cdFx0XHR0aGlzLl9hMzIgPSB2XG5cdFx0XHR2ID0gdGhpcy5fYTQ4XG5cdFx0XHR0aGlzLl9hNDggPSB0aGlzLl9hMTZcblx0XHRcdHRoaXMuX2ExNiA9IHZcblx0XHRcdGlmIChuID09IDMyKSByZXR1cm4gdGhpc1xuXHRcdFx0biAtPSAzMlxuXHRcdH1cblxuXHRcdHZhciBoaWdoID0gKHRoaXMuX2E0OCA8PCAxNikgfCB0aGlzLl9hMzJcblx0XHR2YXIgbG93ID0gKHRoaXMuX2ExNiA8PCAxNikgfCB0aGlzLl9hMDBcblxuXHRcdHZhciBfaGlnaCA9IChoaWdoID4+PiBuKSB8IChsb3cgPDwgKDMyIC0gbikpXG5cdFx0dmFyIF9sb3cgPSAobG93ID4+PiBuKSB8IChoaWdoIDw8ICgzMiAtIG4pKVxuXG5cdFx0dGhpcy5fYTAwID0gX2xvdyAmIDB4RkZGRlxuXHRcdHRoaXMuX2ExNiA9IF9sb3cgPj4+IDE2XG5cdFx0dGhpcy5fYTMyID0gX2hpZ2ggJiAweEZGRkZcblx0XHR0aGlzLl9hNDggPSBfaGlnaCA+Pj4gMTZcblxuXHRcdHJldHVybiB0aGlzXG5cdH1cblxuXHQvKipcblx0ICogQ2xvbmUgdGhlIGN1cnJlbnQgX1VJTlQ2NF9cblx0ICogQG1ldGhvZCBjbG9uZVxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IGNsb25lZCBVSU5UNjRcblx0ICovXG5cdFVJTlQ2NC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIG5ldyBVSU5UNjQodGhpcy5fYTAwLCB0aGlzLl9hMTYsIHRoaXMuX2EzMiwgdGhpcy5fYTQ4KVxuXHR9XG5cblx0aWYgKHR5cGVvZiBkZWZpbmUgIT0gJ3VuZGVmaW5lZCcgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIEFNRCAvIFJlcXVpcmVKU1xuXHRcdGRlZmluZShbXSwgZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIFVJTlQ2NFxuXHRcdH0pXG5cdH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSAhPSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuXHRcdC8vIE5vZGUuanNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IFVJTlQ2NFxuXHR9IGVsc2Uge1xuXHRcdC8vIEJyb3dzZXJcblx0XHRyb290WydVSU5UNjQnXSA9IFVJTlQ2NFxuXHR9XG5cbn0pKHRoaXMpXG4iLCAiZXhwb3J0cy5VSU5UMzIgPSByZXF1aXJlKCcuL2xpYi91aW50MzInKVxuZXhwb3J0cy5VSU5UNjQgPSByZXF1aXJlKCcuL2xpYi91aW50NjQnKSIsICIvKipcbnh4SGFzaCBpbXBsZW1lbnRhdGlvbiBpbiBwdXJlIEphdmFzY3JpcHRcblxuQ29weXJpZ2h0IChDKSAyMDEzLCBQaWVycmUgQ3VydG9cbk1JVCBsaWNlbnNlXG4qL1xudmFyIFVJTlQzMiA9IHJlcXVpcmUoJ2N1aW50JykuVUlOVDMyXG5cbi8qXG5cdE1lcmdlZCB0aGlzIHNlcXVlbmNlIG9mIG1ldGhvZCBjYWxscyBhcyBpdCBzcGVlZHMgdXBcblx0dGhlIGNhbGN1bGF0aW9ucyBieSBhIGZhY3RvciBvZiAyXG4gKi9cbi8vIHRoaXMudjEuYWRkKCBvdGhlci5tdWx0aXBseShQUklNRTMyXzIpICkucm90bCgxMykubXVsdGlwbHkoUFJJTUUzMl8xKTtcblVJTlQzMi5wcm90b3R5cGUueHhoX3VwZGF0ZSA9IGZ1bmN0aW9uIChsb3csIGhpZ2gpIHtcblx0dmFyIGIwMCA9IFBSSU1FMzJfMi5fbG93XG5cdHZhciBiMTYgPSBQUklNRTMyXzIuX2hpZ2hcblxuXHR2YXIgYzE2LCBjMDBcblx0YzAwID0gbG93ICogYjAwXG5cdGMxNiA9IGMwMCA+Pj4gMTZcblxuXHRjMTYgKz0gaGlnaCAqIGIwMFxuXHRjMTYgJj0gMHhGRkZGXHRcdC8vIE5vdCByZXF1aXJlZCBidXQgaW1wcm92ZXMgcGVyZm9ybWFuY2Vcblx0YzE2ICs9IGxvdyAqIGIxNlxuXG5cdHZhciBhMDAgPSB0aGlzLl9sb3cgKyAoYzAwICYgMHhGRkZGKVxuXHR2YXIgYTE2ID0gYTAwID4+PiAxNlxuXG5cdGExNiArPSB0aGlzLl9oaWdoICsgKGMxNiAmIDB4RkZGRilcblxuXHR2YXIgdiA9IChhMTYgPDwgMTYpIHwgKGEwMCAmIDB4RkZGRilcblx0diA9ICh2IDw8IDEzKSB8ICh2ID4+PiAxOSlcblxuXHRhMDAgPSB2ICYgMHhGRkZGXG5cdGExNiA9IHYgPj4+IDE2XG5cblx0YjAwID0gUFJJTUUzMl8xLl9sb3dcblx0YjE2ID0gUFJJTUUzMl8xLl9oaWdoXG5cblx0YzAwID0gYTAwICogYjAwXG5cdGMxNiA9IGMwMCA+Pj4gMTZcblxuXHRjMTYgKz0gYTE2ICogYjAwXG5cdGMxNiAmPSAweEZGRkZcdFx0Ly8gTm90IHJlcXVpcmVkIGJ1dCBpbXByb3ZlcyBwZXJmb3JtYW5jZVxuXHRjMTYgKz0gYTAwICogYjE2XG5cblx0dGhpcy5fbG93ID0gYzAwICYgMHhGRkZGXG5cdHRoaXMuX2hpZ2ggPSBjMTYgJiAweEZGRkZcbn1cblxuLypcbiAqIENvbnN0YW50c1xuICovXG52YXIgUFJJTUUzMl8xID0gVUlOVDMyKCAnMjY1NDQzNTc2MScgKVxudmFyIFBSSU1FMzJfMiA9IFVJTlQzMiggJzIyNDY4MjI1MTknIClcbnZhciBQUklNRTMyXzMgPSBVSU5UMzIoICczMjY2NDg5OTE3JyApXG52YXIgUFJJTUUzMl80ID0gVUlOVDMyKCAgJzY2ODI2NTI2MycgKVxudmFyIFBSSU1FMzJfNSA9IFVJTlQzMiggICczNzQ3NjEzOTMnIClcblxuLyoqXG4qIENvbnZlcnQgc3RyaW5nIHRvIHByb3BlciBVVEYtOCBhcnJheVxuKiBAcGFyYW0gc3RyIElucHV0IHN0cmluZ1xuKiBAcmV0dXJucyB7VWludDhBcnJheX0gVVRGOCBhcnJheSBpcyByZXR1cm5lZCBhcyB1aW50OCBhcnJheVxuKi9cbmZ1bmN0aW9uIHRvVVRGOEFycmF5IChzdHIpIHtcblx0dmFyIHV0ZjggPSBbXVxuXHRmb3IgKHZhciBpPTAsIG49c3RyLmxlbmd0aDsgaSA8IG47IGkrKykge1xuXHRcdHZhciBjaGFyY29kZSA9IHN0ci5jaGFyQ29kZUF0KGkpXG5cdFx0aWYgKGNoYXJjb2RlIDwgMHg4MCkgdXRmOC5wdXNoKGNoYXJjb2RlKVxuXHRcdGVsc2UgaWYgKGNoYXJjb2RlIDwgMHg4MDApIHtcblx0XHRcdHV0ZjgucHVzaCgweGMwIHwgKGNoYXJjb2RlID4+IDYpLFxuXHRcdFx0MHg4MCB8IChjaGFyY29kZSAmIDB4M2YpKVxuXHRcdH1cblx0XHRlbHNlIGlmIChjaGFyY29kZSA8IDB4ZDgwMCB8fCBjaGFyY29kZSA+PSAweGUwMDApIHtcblx0XHRcdHV0ZjgucHVzaCgweGUwIHwgKGNoYXJjb2RlID4+IDEyKSxcblx0XHRcdDB4ODAgfCAoKGNoYXJjb2RlPj42KSAmIDB4M2YpLFxuXHRcdFx0MHg4MCB8IChjaGFyY29kZSAmIDB4M2YpKVxuXHRcdH1cblx0XHQvLyBzdXJyb2dhdGUgcGFpclxuXHRcdGVsc2Uge1xuXHRcdFx0aSsrO1xuXHRcdFx0Ly8gVVRGLTE2IGVuY29kZXMgMHgxMDAwMC0weDEwRkZGRiBieVxuXHRcdFx0Ly8gc3VidHJhY3RpbmcgMHgxMDAwMCBhbmQgc3BsaXR0aW5nIHRoZVxuXHRcdFx0Ly8gMjAgYml0cyBvZiAweDAtMHhGRkZGRiBpbnRvIHR3byBoYWx2ZXNcblx0XHRcdGNoYXJjb2RlID0gMHgxMDAwMCArICgoKGNoYXJjb2RlICYgMHgzZmYpPDwxMClcblx0XHRcdHwgKHN0ci5jaGFyQ29kZUF0KGkpICYgMHgzZmYpKVxuXHRcdFx0dXRmOC5wdXNoKDB4ZjAgfCAoY2hhcmNvZGUgPj4xOCksXG5cdFx0XHQweDgwIHwgKChjaGFyY29kZT4+MTIpICYgMHgzZiksXG5cdFx0XHQweDgwIHwgKChjaGFyY29kZT4+NikgJiAweDNmKSxcblx0XHRcdDB4ODAgfCAoY2hhcmNvZGUgJiAweDNmKSlcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gbmV3IFVpbnQ4QXJyYXkodXRmOClcbn1cblxuLyoqXG4gKiBYWEggb2JqZWN0IHVzZWQgYXMgYSBjb25zdHJ1Y3RvciBvciBhIGZ1bmN0aW9uXG4gKiBAY29uc3RydWN0b3JcbiAqIG9yXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IGlucHV0IGRhdGFcbiAqIEBwYXJhbSB7TnVtYmVyfFVJTlQzMn0gc2VlZFxuICogQHJldHVybiBUaGlzRXhwcmVzc2lvblxuICogb3JcbiAqIEByZXR1cm4ge1VJTlQzMn0geHhIYXNoXG4gKi9cbmZ1bmN0aW9uIFhYSCAoKSB7XG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID09IDIpXG5cdFx0cmV0dXJuIG5ldyBYWEgoIGFyZ3VtZW50c1sxXSApLnVwZGF0ZSggYXJndW1lbnRzWzBdICkuZGlnZXN0KClcblxuXHRpZiAoISh0aGlzIGluc3RhbmNlb2YgWFhIKSlcblx0XHRyZXR1cm4gbmV3IFhYSCggYXJndW1lbnRzWzBdIClcblxuXHRpbml0LmNhbGwodGhpcywgYXJndW1lbnRzWzBdKVxufVxuXG4vKipcbiAqIEluaXRpYWxpemUgdGhlIFhYSCBpbnN0YW5jZSB3aXRoIHRoZSBnaXZlbiBzZWVkXG4gKiBAbWV0aG9kIGluaXRcbiAqIEBwYXJhbSB7TnVtYmVyfE9iamVjdH0gc2VlZCBhcyBhIG51bWJlciBvciBhbiB1bnNpZ25lZCAzMiBiaXRzIGludGVnZXJcbiAqIEByZXR1cm4gVGhpc0V4cHJlc3Npb25cbiAqL1xuIGZ1bmN0aW9uIGluaXQgKHNlZWQpIHtcblx0dGhpcy5zZWVkID0gc2VlZCBpbnN0YW5jZW9mIFVJTlQzMiA/IHNlZWQuY2xvbmUoKSA6IFVJTlQzMihzZWVkKVxuXHR0aGlzLnYxID0gdGhpcy5zZWVkLmNsb25lKCkuYWRkKFBSSU1FMzJfMSkuYWRkKFBSSU1FMzJfMilcblx0dGhpcy52MiA9IHRoaXMuc2VlZC5jbG9uZSgpLmFkZChQUklNRTMyXzIpXG5cdHRoaXMudjMgPSB0aGlzLnNlZWQuY2xvbmUoKVxuXHR0aGlzLnY0ID0gdGhpcy5zZWVkLmNsb25lKCkuc3VidHJhY3QoUFJJTUUzMl8xKVxuXHR0aGlzLnRvdGFsX2xlbiA9IDBcblx0dGhpcy5tZW1zaXplID0gMFxuXHR0aGlzLm1lbW9yeSA9IG51bGxcblxuXHRyZXR1cm4gdGhpc1xufVxuWFhILnByb3RvdHlwZS5pbml0ID0gaW5pdFxuXG4vKipcbiAqIEFkZCBkYXRhIHRvIGJlIGNvbXB1dGVkIGZvciB0aGUgWFhIIGhhc2hcbiAqIEBtZXRob2QgdXBkYXRlXG4gKiBAcGFyYW0ge1N0cmluZ3xCdWZmZXJ8QXJyYXlCdWZmZXJ9IGlucHV0IGFzIGEgc3RyaW5nIG9yIG5vZGVqcyBCdWZmZXIgb3IgQXJyYXlCdWZmZXJcbiAqIEByZXR1cm4gVGhpc0V4cHJlc3Npb25cbiAqL1xuWFhILnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoaW5wdXQpIHtcblx0dmFyIGlzU3RyaW5nID0gdHlwZW9mIGlucHV0ID09ICdzdHJpbmcnXG5cdHZhciBpc0FycmF5QnVmZmVyXG5cblx0Ly8gQ29udmVydCBhbGwgc3RyaW5ncyB0byB1dGYtOCBmaXJzdCAoaXNzdWUgIzUpXG5cdGlmIChpc1N0cmluZykge1xuXHRcdGlucHV0ID0gdG9VVEY4QXJyYXkoaW5wdXQpXG5cdFx0aXNTdHJpbmcgPSBmYWxzZVxuXHRcdGlzQXJyYXlCdWZmZXIgPSB0cnVlXG5cdH1cblxuXHRpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSBcInVuZGVmaW5lZFwiICYmIGlucHV0IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpXG5cdHtcblx0XHRpc0FycmF5QnVmZmVyID0gdHJ1ZVxuXHRcdGlucHV0ID0gbmV3IFVpbnQ4QXJyYXkoaW5wdXQpO1xuXHR9XG5cblx0dmFyIHAgPSAwXG5cdHZhciBsZW4gPSBpbnB1dC5sZW5ndGhcblx0dmFyIGJFbmQgPSBwICsgbGVuXG5cblx0aWYgKGxlbiA9PSAwKSByZXR1cm4gdGhpc1xuXG5cdHRoaXMudG90YWxfbGVuICs9IGxlblxuXG5cdGlmICh0aGlzLm1lbXNpemUgPT0gMClcblx0e1xuXHRcdGlmIChpc1N0cmluZykge1xuXHRcdFx0dGhpcy5tZW1vcnkgPSAnJ1xuXHRcdH0gZWxzZSBpZiAoaXNBcnJheUJ1ZmZlcikge1xuXHRcdFx0dGhpcy5tZW1vcnkgPSBuZXcgVWludDhBcnJheSgxNilcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5tZW1vcnkgPSBuZXcgQnVmZmVyKDE2KVxuXHRcdH1cblx0fVxuXG5cdGlmICh0aGlzLm1lbXNpemUgKyBsZW4gPCAxNikgICAvLyBmaWxsIGluIHRtcCBidWZmZXJcblx0e1xuXHRcdC8vIFhYSF9tZW1jcHkodGhpcy5tZW1vcnkgKyB0aGlzLm1lbXNpemUsIGlucHV0LCBsZW4pXG5cdFx0aWYgKGlzU3RyaW5nKSB7XG5cdFx0XHR0aGlzLm1lbW9yeSArPSBpbnB1dFxuXHRcdH0gZWxzZSBpZiAoaXNBcnJheUJ1ZmZlcikge1xuXHRcdFx0dGhpcy5tZW1vcnkuc2V0KCBpbnB1dC5zdWJhcnJheSgwLCBsZW4pLCB0aGlzLm1lbXNpemUgKVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRpbnB1dC5jb3B5KCB0aGlzLm1lbW9yeSwgdGhpcy5tZW1zaXplLCAwLCBsZW4gKVxuXHRcdH1cblxuXHRcdHRoaXMubWVtc2l6ZSArPSBsZW5cblx0XHRyZXR1cm4gdGhpc1xuXHR9XG5cblx0aWYgKHRoaXMubWVtc2l6ZSA+IDApICAgLy8gc29tZSBkYXRhIGxlZnQgZnJvbSBwcmV2aW91cyB1cGRhdGVcblx0e1xuXHRcdC8vIFhYSF9tZW1jcHkodGhpcy5tZW1vcnkgKyB0aGlzLm1lbXNpemUsIGlucHV0LCAxNi10aGlzLm1lbXNpemUpO1xuXHRcdGlmIChpc1N0cmluZykge1xuXHRcdFx0dGhpcy5tZW1vcnkgKz0gaW5wdXQuc2xpY2UoMCwgMTYgLSB0aGlzLm1lbXNpemUpXG5cdFx0fSBlbHNlIGlmIChpc0FycmF5QnVmZmVyKSB7XG5cdFx0XHR0aGlzLm1lbW9yeS5zZXQoIGlucHV0LnN1YmFycmF5KDAsIDE2IC0gdGhpcy5tZW1zaXplKSwgdGhpcy5tZW1zaXplIClcblx0XHR9IGVsc2Uge1xuXHRcdFx0aW5wdXQuY29weSggdGhpcy5tZW1vcnksIHRoaXMubWVtc2l6ZSwgMCwgMTYgLSB0aGlzLm1lbXNpemUgKVxuXHRcdH1cblxuXHRcdHZhciBwMzIgPSAwXG5cdFx0aWYgKGlzU3RyaW5nKSB7XG5cdFx0XHR0aGlzLnYxLnh4aF91cGRhdGUoXG5cdFx0XHRcdCh0aGlzLm1lbW9yeS5jaGFyQ29kZUF0KHAzMisxKSA8PCA4KSB8IHRoaXMubWVtb3J5LmNoYXJDb2RlQXQocDMyKVxuXHRcdFx0LFx0KHRoaXMubWVtb3J5LmNoYXJDb2RlQXQocDMyKzMpIDw8IDgpIHwgdGhpcy5tZW1vcnkuY2hhckNvZGVBdChwMzIrMilcblx0XHRcdClcblx0XHRcdHAzMiArPSA0XG5cdFx0XHR0aGlzLnYyLnh4aF91cGRhdGUoXG5cdFx0XHRcdCh0aGlzLm1lbW9yeS5jaGFyQ29kZUF0KHAzMisxKSA8PCA4KSB8IHRoaXMubWVtb3J5LmNoYXJDb2RlQXQocDMyKVxuXHRcdFx0LFx0KHRoaXMubWVtb3J5LmNoYXJDb2RlQXQocDMyKzMpIDw8IDgpIHwgdGhpcy5tZW1vcnkuY2hhckNvZGVBdChwMzIrMilcblx0XHRcdClcblx0XHRcdHAzMiArPSA0XG5cdFx0XHR0aGlzLnYzLnh4aF91cGRhdGUoXG5cdFx0XHRcdCh0aGlzLm1lbW9yeS5jaGFyQ29kZUF0KHAzMisxKSA8PCA4KSB8IHRoaXMubWVtb3J5LmNoYXJDb2RlQXQocDMyKVxuXHRcdFx0LFx0KHRoaXMubWVtb3J5LmNoYXJDb2RlQXQocDMyKzMpIDw8IDgpIHwgdGhpcy5tZW1vcnkuY2hhckNvZGVBdChwMzIrMilcblx0XHRcdClcblx0XHRcdHAzMiArPSA0XG5cdFx0XHR0aGlzLnY0Lnh4aF91cGRhdGUoXG5cdFx0XHRcdCh0aGlzLm1lbW9yeS5jaGFyQ29kZUF0KHAzMisxKSA8PCA4KSB8IHRoaXMubWVtb3J5LmNoYXJDb2RlQXQocDMyKVxuXHRcdFx0LFx0KHRoaXMubWVtb3J5LmNoYXJDb2RlQXQocDMyKzMpIDw8IDgpIHwgdGhpcy5tZW1vcnkuY2hhckNvZGVBdChwMzIrMilcblx0XHRcdClcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy52MS54eGhfdXBkYXRlKFxuXHRcdFx0XHQodGhpcy5tZW1vcnlbcDMyKzFdIDw8IDgpIHwgdGhpcy5tZW1vcnlbcDMyXVxuXHRcdFx0LFx0KHRoaXMubWVtb3J5W3AzMiszXSA8PCA4KSB8IHRoaXMubWVtb3J5W3AzMisyXVxuXHRcdFx0KVxuXHRcdFx0cDMyICs9IDRcblx0XHRcdHRoaXMudjIueHhoX3VwZGF0ZShcblx0XHRcdFx0KHRoaXMubWVtb3J5W3AzMisxXSA8PCA4KSB8IHRoaXMubWVtb3J5W3AzMl1cblx0XHRcdCxcdCh0aGlzLm1lbW9yeVtwMzIrM10gPDwgOCkgfCB0aGlzLm1lbW9yeVtwMzIrMl1cblx0XHRcdClcblx0XHRcdHAzMiArPSA0XG5cdFx0XHR0aGlzLnYzLnh4aF91cGRhdGUoXG5cdFx0XHRcdCh0aGlzLm1lbW9yeVtwMzIrMV0gPDwgOCkgfCB0aGlzLm1lbW9yeVtwMzJdXG5cdFx0XHQsXHQodGhpcy5tZW1vcnlbcDMyKzNdIDw8IDgpIHwgdGhpcy5tZW1vcnlbcDMyKzJdXG5cdFx0XHQpXG5cdFx0XHRwMzIgKz0gNFxuXHRcdFx0dGhpcy52NC54eGhfdXBkYXRlKFxuXHRcdFx0XHQodGhpcy5tZW1vcnlbcDMyKzFdIDw8IDgpIHwgdGhpcy5tZW1vcnlbcDMyXVxuXHRcdFx0LFx0KHRoaXMubWVtb3J5W3AzMiszXSA8PCA4KSB8IHRoaXMubWVtb3J5W3AzMisyXVxuXHRcdFx0KVxuXHRcdH1cblxuXHRcdHAgKz0gMTYgLSB0aGlzLm1lbXNpemVcblx0XHR0aGlzLm1lbXNpemUgPSAwXG5cdFx0aWYgKGlzU3RyaW5nKSB0aGlzLm1lbW9yeSA9ICcnXG5cdH1cblxuXHRpZiAocCA8PSBiRW5kIC0gMTYpXG5cdHtcblx0XHR2YXIgbGltaXQgPSBiRW5kIC0gMTZcblxuXHRcdGRvXG5cdFx0e1xuXHRcdFx0aWYgKGlzU3RyaW5nKSB7XG5cdFx0XHRcdHRoaXMudjEueHhoX3VwZGF0ZShcblx0XHRcdFx0XHQoaW5wdXQuY2hhckNvZGVBdChwKzEpIDw8IDgpIHwgaW5wdXQuY2hhckNvZGVBdChwKVxuXHRcdFx0XHQsXHQoaW5wdXQuY2hhckNvZGVBdChwKzMpIDw8IDgpIHwgaW5wdXQuY2hhckNvZGVBdChwKzIpXG5cdFx0XHRcdClcblx0XHRcdFx0cCArPSA0XG5cdFx0XHRcdHRoaXMudjIueHhoX3VwZGF0ZShcblx0XHRcdFx0XHQoaW5wdXQuY2hhckNvZGVBdChwKzEpIDw8IDgpIHwgaW5wdXQuY2hhckNvZGVBdChwKVxuXHRcdFx0XHQsXHQoaW5wdXQuY2hhckNvZGVBdChwKzMpIDw8IDgpIHwgaW5wdXQuY2hhckNvZGVBdChwKzIpXG5cdFx0XHRcdClcblx0XHRcdFx0cCArPSA0XG5cdFx0XHRcdHRoaXMudjMueHhoX3VwZGF0ZShcblx0XHRcdFx0XHQoaW5wdXQuY2hhckNvZGVBdChwKzEpIDw8IDgpIHwgaW5wdXQuY2hhckNvZGVBdChwKVxuXHRcdFx0XHQsXHQoaW5wdXQuY2hhckNvZGVBdChwKzMpIDw8IDgpIHwgaW5wdXQuY2hhckNvZGVBdChwKzIpXG5cdFx0XHRcdClcblx0XHRcdFx0cCArPSA0XG5cdFx0XHRcdHRoaXMudjQueHhoX3VwZGF0ZShcblx0XHRcdFx0XHQoaW5wdXQuY2hhckNvZGVBdChwKzEpIDw8IDgpIHwgaW5wdXQuY2hhckNvZGVBdChwKVxuXHRcdFx0XHQsXHQoaW5wdXQuY2hhckNvZGVBdChwKzMpIDw8IDgpIHwgaW5wdXQuY2hhckNvZGVBdChwKzIpXG5cdFx0XHRcdClcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMudjEueHhoX3VwZGF0ZShcblx0XHRcdFx0XHQoaW5wdXRbcCsxXSA8PCA4KSB8IGlucHV0W3BdXG5cdFx0XHRcdCxcdChpbnB1dFtwKzNdIDw8IDgpIHwgaW5wdXRbcCsyXVxuXHRcdFx0XHQpXG5cdFx0XHRcdHAgKz0gNFxuXHRcdFx0XHR0aGlzLnYyLnh4aF91cGRhdGUoXG5cdFx0XHRcdFx0KGlucHV0W3ArMV0gPDwgOCkgfCBpbnB1dFtwXVxuXHRcdFx0XHQsXHQoaW5wdXRbcCszXSA8PCA4KSB8IGlucHV0W3ArMl1cblx0XHRcdFx0KVxuXHRcdFx0XHRwICs9IDRcblx0XHRcdFx0dGhpcy52My54eGhfdXBkYXRlKFxuXHRcdFx0XHRcdChpbnB1dFtwKzFdIDw8IDgpIHwgaW5wdXRbcF1cblx0XHRcdFx0LFx0KGlucHV0W3ArM10gPDwgOCkgfCBpbnB1dFtwKzJdXG5cdFx0XHRcdClcblx0XHRcdFx0cCArPSA0XG5cdFx0XHRcdHRoaXMudjQueHhoX3VwZGF0ZShcblx0XHRcdFx0XHQoaW5wdXRbcCsxXSA8PCA4KSB8IGlucHV0W3BdXG5cdFx0XHRcdCxcdChpbnB1dFtwKzNdIDw8IDgpIHwgaW5wdXRbcCsyXVxuXHRcdFx0XHQpXG5cdFx0XHR9XG5cdFx0XHRwICs9IDRcblx0XHR9IHdoaWxlIChwIDw9IGxpbWl0KVxuXHR9XG5cblx0aWYgKHAgPCBiRW5kKVxuXHR7XG5cdFx0Ly8gWFhIX21lbWNweSh0aGlzLm1lbW9yeSwgcCwgYkVuZC1wKTtcblx0XHRpZiAoaXNTdHJpbmcpIHtcblx0XHRcdHRoaXMubWVtb3J5ICs9IGlucHV0LnNsaWNlKHApXG5cdFx0fSBlbHNlIGlmIChpc0FycmF5QnVmZmVyKSB7XG5cdFx0XHR0aGlzLm1lbW9yeS5zZXQoIGlucHV0LnN1YmFycmF5KHAsIGJFbmQpLCB0aGlzLm1lbXNpemUgKVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRpbnB1dC5jb3B5KCB0aGlzLm1lbW9yeSwgdGhpcy5tZW1zaXplLCBwLCBiRW5kIClcblx0XHR9XG5cblx0XHR0aGlzLm1lbXNpemUgPSBiRW5kIC0gcFxuXHR9XG5cblx0cmV0dXJuIHRoaXNcbn1cblxuLyoqXG4gKiBGaW5hbGl6ZSB0aGUgWFhIIGNvbXB1dGF0aW9uLiBUaGUgWFhIIGluc3RhbmNlIGlzIHJlYWR5IGZvciByZXVzZSBmb3IgdGhlIGdpdmVuIHNlZWRcbiAqIEBtZXRob2QgZGlnZXN0XG4gKiBAcmV0dXJuIHtVSU5UMzJ9IHh4SGFzaFxuICovXG5YWEgucHJvdG90eXBlLmRpZ2VzdCA9IGZ1bmN0aW9uICgpIHtcblx0dmFyIGlucHV0ID0gdGhpcy5tZW1vcnlcblx0dmFyIGlzU3RyaW5nID0gdHlwZW9mIGlucHV0ID09ICdzdHJpbmcnXG5cdHZhciBwID0gMFxuXHR2YXIgYkVuZCA9IHRoaXMubWVtc2l6ZVxuXHR2YXIgaDMyLCBoXG5cdHZhciB1ID0gbmV3IFVJTlQzMlxuXG5cdGlmICh0aGlzLnRvdGFsX2xlbiA+PSAxNilcblx0e1xuXHRcdGgzMiA9IHRoaXMudjEucm90bCgxKS5hZGQoIHRoaXMudjIucm90bCg3KS5hZGQoIHRoaXMudjMucm90bCgxMikuYWRkKCB0aGlzLnY0LnJvdGwoMTgpICkgKSApXG5cdH1cblx0ZWxzZVxuXHR7XG5cdFx0aDMyICA9IHRoaXMuc2VlZC5jbG9uZSgpLmFkZCggUFJJTUUzMl81IClcblx0fVxuXG5cdGgzMi5hZGQoIHUuZnJvbU51bWJlcih0aGlzLnRvdGFsX2xlbikgKVxuXG5cdHdoaWxlIChwIDw9IGJFbmQgLSA0KVxuXHR7XG5cdFx0aWYgKGlzU3RyaW5nKSB7XG5cdFx0XHR1LmZyb21CaXRzKFxuXHRcdFx0XHQoaW5wdXQuY2hhckNvZGVBdChwKzEpIDw8IDgpIHwgaW5wdXQuY2hhckNvZGVBdChwKVxuXHRcdFx0LFx0KGlucHV0LmNoYXJDb2RlQXQocCszKSA8PCA4KSB8IGlucHV0LmNoYXJDb2RlQXQocCsyKVxuXHRcdFx0KVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR1LmZyb21CaXRzKFxuXHRcdFx0XHQoaW5wdXRbcCsxXSA8PCA4KSB8IGlucHV0W3BdXG5cdFx0XHQsXHQoaW5wdXRbcCszXSA8PCA4KSB8IGlucHV0W3ArMl1cblx0XHRcdClcblx0XHR9XG5cdFx0aDMyXG5cdFx0XHQuYWRkKCB1Lm11bHRpcGx5KFBSSU1FMzJfMykgKVxuXHRcdFx0LnJvdGwoMTcpXG5cdFx0XHQubXVsdGlwbHkoIFBSSU1FMzJfNCApXG5cdFx0cCArPSA0XG5cdH1cblxuXHR3aGlsZSAocCA8IGJFbmQpXG5cdHtcblx0XHR1LmZyb21CaXRzKCBpc1N0cmluZyA/IGlucHV0LmNoYXJDb2RlQXQocCsrKSA6IGlucHV0W3ArK10sIDAgKVxuXHRcdGgzMlxuXHRcdFx0LmFkZCggdS5tdWx0aXBseShQUklNRTMyXzUpIClcblx0XHRcdC5yb3RsKDExKVxuXHRcdFx0Lm11bHRpcGx5KFBSSU1FMzJfMSlcblx0fVxuXG5cdGggPSBoMzIuY2xvbmUoKS5zaGlmdFJpZ2h0KDE1KVxuXHRoMzIueG9yKGgpLm11bHRpcGx5KFBSSU1FMzJfMilcblxuXHRoID0gaDMyLmNsb25lKCkuc2hpZnRSaWdodCgxMylcblx0aDMyLnhvcihoKS5tdWx0aXBseShQUklNRTMyXzMpXG5cblx0aCA9IGgzMi5jbG9uZSgpLnNoaWZ0UmlnaHQoMTYpXG5cdGgzMi54b3IoaClcblxuXHQvLyBSZXNldCB0aGUgc3RhdGVcblx0dGhpcy5pbml0KCB0aGlzLnNlZWQgKVxuXG5cdHJldHVybiBoMzJcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBYWEhcbiIsICIvKipcbnh4SGFzaDY0IGltcGxlbWVudGF0aW9uIGluIHB1cmUgSmF2YXNjcmlwdFxuXG5Db3B5cmlnaHQgKEMpIDIwMTYsIFBpZXJyZSBDdXJ0b1xuTUlUIGxpY2Vuc2VcbiovXG52YXIgVUlOVDY0ID0gcmVxdWlyZSgnY3VpbnQnKS5VSU5UNjRcblxuLypcbiAqIENvbnN0YW50c1xuICovXG52YXIgUFJJTUU2NF8xID0gVUlOVDY0KCAnMTE0MDA3MTQ3ODUwNzQ2OTQ3OTEnIClcbnZhciBQUklNRTY0XzIgPSBVSU5UNjQoICcxNDAyOTQ2NzM2Njg5NzAxOTcyNycgKVxudmFyIFBSSU1FNjRfMyA9IFVJTlQ2NCggICcxNjA5NTg3OTI5MzkyODM5MTYxJyApXG52YXIgUFJJTUU2NF80ID0gVUlOVDY0KCAgJzk2NTAwMjkyNDIyODc4Mjg1NzknIClcbnZhciBQUklNRTY0XzUgPSBVSU5UNjQoICAnMjg3MDE3NzQ1MDAxMjYwMDI2MScgKVxuXG4vKipcbiogQ29udmVydCBzdHJpbmcgdG8gcHJvcGVyIFVURi04IGFycmF5XG4qIEBwYXJhbSBzdHIgSW5wdXQgc3RyaW5nXG4qIEByZXR1cm5zIHtVaW50OEFycmF5fSBVVEY4IGFycmF5IGlzIHJldHVybmVkIGFzIHVpbnQ4IGFycmF5XG4qL1xuZnVuY3Rpb24gdG9VVEY4QXJyYXkgKHN0cikge1xuXHR2YXIgdXRmOCA9IFtdXG5cdGZvciAodmFyIGk9MCwgbj1zdHIubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG5cdFx0dmFyIGNoYXJjb2RlID0gc3RyLmNoYXJDb2RlQXQoaSlcblx0XHRpZiAoY2hhcmNvZGUgPCAweDgwKSB1dGY4LnB1c2goY2hhcmNvZGUpXG5cdFx0ZWxzZSBpZiAoY2hhcmNvZGUgPCAweDgwMCkge1xuXHRcdFx0dXRmOC5wdXNoKDB4YzAgfCAoY2hhcmNvZGUgPj4gNiksXG5cdFx0XHQweDgwIHwgKGNoYXJjb2RlICYgMHgzZikpXG5cdFx0fVxuXHRcdGVsc2UgaWYgKGNoYXJjb2RlIDwgMHhkODAwIHx8IGNoYXJjb2RlID49IDB4ZTAwMCkge1xuXHRcdFx0dXRmOC5wdXNoKDB4ZTAgfCAoY2hhcmNvZGUgPj4gMTIpLFxuXHRcdFx0MHg4MCB8ICgoY2hhcmNvZGU+PjYpICYgMHgzZiksXG5cdFx0XHQweDgwIHwgKGNoYXJjb2RlICYgMHgzZikpXG5cdFx0fVxuXHRcdC8vIHN1cnJvZ2F0ZSBwYWlyXG5cdFx0ZWxzZSB7XG5cdFx0XHRpKys7XG5cdFx0XHQvLyBVVEYtMTYgZW5jb2RlcyAweDEwMDAwLTB4MTBGRkZGIGJ5XG5cdFx0XHQvLyBzdWJ0cmFjdGluZyAweDEwMDAwIGFuZCBzcGxpdHRpbmcgdGhlXG5cdFx0XHQvLyAyMCBiaXRzIG9mIDB4MC0weEZGRkZGIGludG8gdHdvIGhhbHZlc1xuXHRcdFx0Y2hhcmNvZGUgPSAweDEwMDAwICsgKCgoY2hhcmNvZGUgJiAweDNmZik8PDEwKVxuXHRcdFx0fCAoc3RyLmNoYXJDb2RlQXQoaSkgJiAweDNmZikpXG5cdFx0XHR1dGY4LnB1c2goMHhmMCB8IChjaGFyY29kZSA+PjE4KSxcblx0XHRcdDB4ODAgfCAoKGNoYXJjb2RlPj4xMikgJiAweDNmKSxcblx0XHRcdDB4ODAgfCAoKGNoYXJjb2RlPj42KSAmIDB4M2YpLFxuXHRcdFx0MHg4MCB8IChjaGFyY29kZSAmIDB4M2YpKVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBuZXcgVWludDhBcnJheSh1dGY4KVxufVxuXG4vKipcbiAqIFhYSDY0IG9iamVjdCB1c2VkIGFzIGEgY29uc3RydWN0b3Igb3IgYSBmdW5jdGlvblxuICogQGNvbnN0cnVjdG9yXG4gKiBvclxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBpbnB1dCBkYXRhXG4gKiBAcGFyYW0ge051bWJlcnxVSU5UNjR9IHNlZWRcbiAqIEByZXR1cm4gVGhpc0V4cHJlc3Npb25cbiAqIG9yXG4gKiBAcmV0dXJuIHtVSU5UNjR9IHh4SGFzaFxuICovXG5mdW5jdGlvbiBYWEg2NCAoKSB7XG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID09IDIpXG5cdFx0cmV0dXJuIG5ldyBYWEg2NCggYXJndW1lbnRzWzFdICkudXBkYXRlKCBhcmd1bWVudHNbMF0gKS5kaWdlc3QoKVxuXG5cdGlmICghKHRoaXMgaW5zdGFuY2VvZiBYWEg2NCkpXG5cdFx0cmV0dXJuIG5ldyBYWEg2NCggYXJndW1lbnRzWzBdIClcblxuXHRpbml0LmNhbGwodGhpcywgYXJndW1lbnRzWzBdKVxufVxuXG4vKipcbiAqIEluaXRpYWxpemUgdGhlIFhYSDY0IGluc3RhbmNlIHdpdGggdGhlIGdpdmVuIHNlZWRcbiAqIEBtZXRob2QgaW5pdFxuICogQHBhcmFtIHtOdW1iZXJ8T2JqZWN0fSBzZWVkIGFzIGEgbnVtYmVyIG9yIGFuIHVuc2lnbmVkIDMyIGJpdHMgaW50ZWdlclxuICogQHJldHVybiBUaGlzRXhwcmVzc2lvblxuICovXG4gZnVuY3Rpb24gaW5pdCAoc2VlZCkge1xuXHR0aGlzLnNlZWQgPSBzZWVkIGluc3RhbmNlb2YgVUlOVDY0ID8gc2VlZC5jbG9uZSgpIDogVUlOVDY0KHNlZWQpXG5cdHRoaXMudjEgPSB0aGlzLnNlZWQuY2xvbmUoKS5hZGQoUFJJTUU2NF8xKS5hZGQoUFJJTUU2NF8yKVxuXHR0aGlzLnYyID0gdGhpcy5zZWVkLmNsb25lKCkuYWRkKFBSSU1FNjRfMilcblx0dGhpcy52MyA9IHRoaXMuc2VlZC5jbG9uZSgpXG5cdHRoaXMudjQgPSB0aGlzLnNlZWQuY2xvbmUoKS5zdWJ0cmFjdChQUklNRTY0XzEpXG5cdHRoaXMudG90YWxfbGVuID0gMFxuXHR0aGlzLm1lbXNpemUgPSAwXG5cdHRoaXMubWVtb3J5ID0gbnVsbFxuXG5cdHJldHVybiB0aGlzXG59XG5YWEg2NC5wcm90b3R5cGUuaW5pdCA9IGluaXRcblxuLyoqXG4gKiBBZGQgZGF0YSB0byBiZSBjb21wdXRlZCBmb3IgdGhlIFhYSDY0IGhhc2hcbiAqIEBtZXRob2QgdXBkYXRlXG4gKiBAcGFyYW0ge1N0cmluZ3xCdWZmZXJ8QXJyYXlCdWZmZXJ9IGlucHV0IGFzIGEgc3RyaW5nIG9yIG5vZGVqcyBCdWZmZXIgb3IgQXJyYXlCdWZmZXJcbiAqIEByZXR1cm4gVGhpc0V4cHJlc3Npb25cbiAqL1xuWFhINjQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChpbnB1dCkge1xuXHR2YXIgaXNTdHJpbmcgPSB0eXBlb2YgaW5wdXQgPT0gJ3N0cmluZydcblx0dmFyIGlzQXJyYXlCdWZmZXJcblxuXHQvLyBDb252ZXJ0IGFsbCBzdHJpbmdzIHRvIHV0Zi04IGZpcnN0IChpc3N1ZSAjNSlcblx0aWYgKGlzU3RyaW5nKSB7XG5cdFx0aW5wdXQgPSB0b1VURjhBcnJheShpbnB1dClcblx0XHRpc1N0cmluZyA9IGZhbHNlXG5cdFx0aXNBcnJheUJ1ZmZlciA9IHRydWVcblx0fVxuXG5cdGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09IFwidW5kZWZpbmVkXCIgJiYgaW5wdXQgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcilcblx0e1xuXHRcdGlzQXJyYXlCdWZmZXIgPSB0cnVlXG5cdFx0aW5wdXQgPSBuZXcgVWludDhBcnJheShpbnB1dCk7XG5cdH1cblxuXHR2YXIgcCA9IDBcblx0dmFyIGxlbiA9IGlucHV0Lmxlbmd0aFxuXHR2YXIgYkVuZCA9IHAgKyBsZW5cblxuXHRpZiAobGVuID09IDApIHJldHVybiB0aGlzXG5cblx0dGhpcy50b3RhbF9sZW4gKz0gbGVuXG5cblx0aWYgKHRoaXMubWVtc2l6ZSA9PSAwKVxuXHR7XG5cdFx0aWYgKGlzU3RyaW5nKSB7XG5cdFx0XHR0aGlzLm1lbW9yeSA9ICcnXG5cdFx0fSBlbHNlIGlmIChpc0FycmF5QnVmZmVyKSB7XG5cdFx0XHR0aGlzLm1lbW9yeSA9IG5ldyBVaW50OEFycmF5KDMyKVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLm1lbW9yeSA9IG5ldyBCdWZmZXIoMzIpXG5cdFx0fVxuXHR9XG5cblx0aWYgKHRoaXMubWVtc2l6ZSArIGxlbiA8IDMyKSAgIC8vIGZpbGwgaW4gdG1wIGJ1ZmZlclxuXHR7XG5cdFx0Ly8gWFhINjRfbWVtY3B5KHRoaXMubWVtb3J5ICsgdGhpcy5tZW1zaXplLCBpbnB1dCwgbGVuKVxuXHRcdGlmIChpc1N0cmluZykge1xuXHRcdFx0dGhpcy5tZW1vcnkgKz0gaW5wdXRcblx0XHR9IGVsc2UgaWYgKGlzQXJyYXlCdWZmZXIpIHtcblx0XHRcdHRoaXMubWVtb3J5LnNldCggaW5wdXQuc3ViYXJyYXkoMCwgbGVuKSwgdGhpcy5tZW1zaXplIClcblx0XHR9IGVsc2Uge1xuXHRcdFx0aW5wdXQuY29weSggdGhpcy5tZW1vcnksIHRoaXMubWVtc2l6ZSwgMCwgbGVuIClcblx0XHR9XG5cblx0XHR0aGlzLm1lbXNpemUgKz0gbGVuXG5cdFx0cmV0dXJuIHRoaXNcblx0fVxuXG5cdGlmICh0aGlzLm1lbXNpemUgPiAwKSAgIC8vIHNvbWUgZGF0YSBsZWZ0IGZyb20gcHJldmlvdXMgdXBkYXRlXG5cdHtcblx0XHQvLyBYWEg2NF9tZW1jcHkodGhpcy5tZW1vcnkgKyB0aGlzLm1lbXNpemUsIGlucHV0LCAxNi10aGlzLm1lbXNpemUpO1xuXHRcdGlmIChpc1N0cmluZykge1xuXHRcdFx0dGhpcy5tZW1vcnkgKz0gaW5wdXQuc2xpY2UoMCwgMzIgLSB0aGlzLm1lbXNpemUpXG5cdFx0fSBlbHNlIGlmIChpc0FycmF5QnVmZmVyKSB7XG5cdFx0XHR0aGlzLm1lbW9yeS5zZXQoIGlucHV0LnN1YmFycmF5KDAsIDMyIC0gdGhpcy5tZW1zaXplKSwgdGhpcy5tZW1zaXplIClcblx0XHR9IGVsc2Uge1xuXHRcdFx0aW5wdXQuY29weSggdGhpcy5tZW1vcnksIHRoaXMubWVtc2l6ZSwgMCwgMzIgLSB0aGlzLm1lbXNpemUgKVxuXHRcdH1cblxuXHRcdHZhciBwNjQgPSAwXG5cdFx0aWYgKGlzU3RyaW5nKSB7XG5cdFx0XHR2YXIgb3RoZXJcblx0XHRcdG90aGVyID0gVUlOVDY0KFxuXHRcdFx0XHRcdCh0aGlzLm1lbW9yeS5jaGFyQ29kZUF0KHA2NCsxKSA8PCA4KSB8IHRoaXMubWVtb3J5LmNoYXJDb2RlQXQocDY0KVxuXHRcdFx0XHQsXHQodGhpcy5tZW1vcnkuY2hhckNvZGVBdChwNjQrMykgPDwgOCkgfCB0aGlzLm1lbW9yeS5jaGFyQ29kZUF0KHA2NCsyKVxuXHRcdFx0XHQsXHQodGhpcy5tZW1vcnkuY2hhckNvZGVBdChwNjQrNSkgPDwgOCkgfCB0aGlzLm1lbW9yeS5jaGFyQ29kZUF0KHA2NCs0KVxuXHRcdFx0XHQsXHQodGhpcy5tZW1vcnkuY2hhckNvZGVBdChwNjQrNykgPDwgOCkgfCB0aGlzLm1lbW9yeS5jaGFyQ29kZUF0KHA2NCs2KVxuXHRcdFx0XHQpXG5cdFx0XHR0aGlzLnYxLmFkZCggb3RoZXIubXVsdGlwbHkoUFJJTUU2NF8yKSApLnJvdGwoMzEpLm11bHRpcGx5KFBSSU1FNjRfMSk7XG5cdFx0XHRwNjQgKz0gOFxuXHRcdFx0b3RoZXIgPSBVSU5UNjQoXG5cdFx0XHRcdFx0KHRoaXMubWVtb3J5LmNoYXJDb2RlQXQocDY0KzEpIDw8IDgpIHwgdGhpcy5tZW1vcnkuY2hhckNvZGVBdChwNjQpXG5cdFx0XHRcdCxcdCh0aGlzLm1lbW9yeS5jaGFyQ29kZUF0KHA2NCszKSA8PCA4KSB8IHRoaXMubWVtb3J5LmNoYXJDb2RlQXQocDY0KzIpXG5cdFx0XHRcdCxcdCh0aGlzLm1lbW9yeS5jaGFyQ29kZUF0KHA2NCs1KSA8PCA4KSB8IHRoaXMubWVtb3J5LmNoYXJDb2RlQXQocDY0KzQpXG5cdFx0XHRcdCxcdCh0aGlzLm1lbW9yeS5jaGFyQ29kZUF0KHA2NCs3KSA8PCA4KSB8IHRoaXMubWVtb3J5LmNoYXJDb2RlQXQocDY0KzYpXG5cdFx0XHRcdClcblx0XHRcdHRoaXMudjIuYWRkKCBvdGhlci5tdWx0aXBseShQUklNRTY0XzIpICkucm90bCgzMSkubXVsdGlwbHkoUFJJTUU2NF8xKTtcblx0XHRcdHA2NCArPSA4XG5cdFx0XHRvdGhlciA9IFVJTlQ2NChcblx0XHRcdFx0XHQodGhpcy5tZW1vcnkuY2hhckNvZGVBdChwNjQrMSkgPDwgOCkgfCB0aGlzLm1lbW9yeS5jaGFyQ29kZUF0KHA2NClcblx0XHRcdFx0LFx0KHRoaXMubWVtb3J5LmNoYXJDb2RlQXQocDY0KzMpIDw8IDgpIHwgdGhpcy5tZW1vcnkuY2hhckNvZGVBdChwNjQrMilcblx0XHRcdFx0LFx0KHRoaXMubWVtb3J5LmNoYXJDb2RlQXQocDY0KzUpIDw8IDgpIHwgdGhpcy5tZW1vcnkuY2hhckNvZGVBdChwNjQrNClcblx0XHRcdFx0LFx0KHRoaXMubWVtb3J5LmNoYXJDb2RlQXQocDY0KzcpIDw8IDgpIHwgdGhpcy5tZW1vcnkuY2hhckNvZGVBdChwNjQrNilcblx0XHRcdFx0KVxuXHRcdFx0dGhpcy52My5hZGQoIG90aGVyLm11bHRpcGx5KFBSSU1FNjRfMikgKS5yb3RsKDMxKS5tdWx0aXBseShQUklNRTY0XzEpO1xuXHRcdFx0cDY0ICs9IDhcblx0XHRcdG90aGVyID0gVUlOVDY0KFxuXHRcdFx0XHRcdCh0aGlzLm1lbW9yeS5jaGFyQ29kZUF0KHA2NCsxKSA8PCA4KSB8IHRoaXMubWVtb3J5LmNoYXJDb2RlQXQocDY0KVxuXHRcdFx0XHQsXHQodGhpcy5tZW1vcnkuY2hhckNvZGVBdChwNjQrMykgPDwgOCkgfCB0aGlzLm1lbW9yeS5jaGFyQ29kZUF0KHA2NCsyKVxuXHRcdFx0XHQsXHQodGhpcy5tZW1vcnkuY2hhckNvZGVBdChwNjQrNSkgPDwgOCkgfCB0aGlzLm1lbW9yeS5jaGFyQ29kZUF0KHA2NCs0KVxuXHRcdFx0XHQsXHQodGhpcy5tZW1vcnkuY2hhckNvZGVBdChwNjQrNykgPDwgOCkgfCB0aGlzLm1lbW9yeS5jaGFyQ29kZUF0KHA2NCs2KVxuXHRcdFx0XHQpXG5cdFx0XHR0aGlzLnY0LmFkZCggb3RoZXIubXVsdGlwbHkoUFJJTUU2NF8yKSApLnJvdGwoMzEpLm11bHRpcGx5KFBSSU1FNjRfMSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBvdGhlclxuXHRcdFx0b3RoZXIgPSBVSU5UNjQoXG5cdFx0XHRcdFx0KHRoaXMubWVtb3J5W3A2NCsxXSA8PCA4KSB8IHRoaXMubWVtb3J5W3A2NF1cblx0XHRcdFx0LFx0KHRoaXMubWVtb3J5W3A2NCszXSA8PCA4KSB8IHRoaXMubWVtb3J5W3A2NCsyXVxuXHRcdFx0XHQsXHQodGhpcy5tZW1vcnlbcDY0KzVdIDw8IDgpIHwgdGhpcy5tZW1vcnlbcDY0KzRdXG5cdFx0XHRcdCxcdCh0aGlzLm1lbW9yeVtwNjQrN10gPDwgOCkgfCB0aGlzLm1lbW9yeVtwNjQrNl1cblx0XHRcdFx0KVxuXHRcdFx0dGhpcy52MS5hZGQoIG90aGVyLm11bHRpcGx5KFBSSU1FNjRfMikgKS5yb3RsKDMxKS5tdWx0aXBseShQUklNRTY0XzEpO1xuXHRcdFx0cDY0ICs9IDhcblx0XHRcdG90aGVyID0gVUlOVDY0KFxuXHRcdFx0XHRcdCh0aGlzLm1lbW9yeVtwNjQrMV0gPDwgOCkgfCB0aGlzLm1lbW9yeVtwNjRdXG5cdFx0XHRcdCxcdCh0aGlzLm1lbW9yeVtwNjQrM10gPDwgOCkgfCB0aGlzLm1lbW9yeVtwNjQrMl1cblx0XHRcdFx0LFx0KHRoaXMubWVtb3J5W3A2NCs1XSA8PCA4KSB8IHRoaXMubWVtb3J5W3A2NCs0XVxuXHRcdFx0XHQsXHQodGhpcy5tZW1vcnlbcDY0KzddIDw8IDgpIHwgdGhpcy5tZW1vcnlbcDY0KzZdXG5cdFx0XHRcdClcblx0XHRcdHRoaXMudjIuYWRkKCBvdGhlci5tdWx0aXBseShQUklNRTY0XzIpICkucm90bCgzMSkubXVsdGlwbHkoUFJJTUU2NF8xKTtcblx0XHRcdHA2NCArPSA4XG5cdFx0XHRvdGhlciA9IFVJTlQ2NChcblx0XHRcdFx0XHQodGhpcy5tZW1vcnlbcDY0KzFdIDw8IDgpIHwgdGhpcy5tZW1vcnlbcDY0XVxuXHRcdFx0XHQsXHQodGhpcy5tZW1vcnlbcDY0KzNdIDw8IDgpIHwgdGhpcy5tZW1vcnlbcDY0KzJdXG5cdFx0XHRcdCxcdCh0aGlzLm1lbW9yeVtwNjQrNV0gPDwgOCkgfCB0aGlzLm1lbW9yeVtwNjQrNF1cblx0XHRcdFx0LFx0KHRoaXMubWVtb3J5W3A2NCs3XSA8PCA4KSB8IHRoaXMubWVtb3J5W3A2NCs2XVxuXHRcdFx0XHQpXG5cdFx0XHR0aGlzLnYzLmFkZCggb3RoZXIubXVsdGlwbHkoUFJJTUU2NF8yKSApLnJvdGwoMzEpLm11bHRpcGx5KFBSSU1FNjRfMSk7XG5cdFx0XHRwNjQgKz0gOFxuXHRcdFx0b3RoZXIgPSBVSU5UNjQoXG5cdFx0XHRcdFx0KHRoaXMubWVtb3J5W3A2NCsxXSA8PCA4KSB8IHRoaXMubWVtb3J5W3A2NF1cblx0XHRcdFx0LFx0KHRoaXMubWVtb3J5W3A2NCszXSA8PCA4KSB8IHRoaXMubWVtb3J5W3A2NCsyXVxuXHRcdFx0XHQsXHQodGhpcy5tZW1vcnlbcDY0KzVdIDw8IDgpIHwgdGhpcy5tZW1vcnlbcDY0KzRdXG5cdFx0XHRcdCxcdCh0aGlzLm1lbW9yeVtwNjQrN10gPDwgOCkgfCB0aGlzLm1lbW9yeVtwNjQrNl1cblx0XHRcdFx0KVxuXHRcdFx0dGhpcy52NC5hZGQoIG90aGVyLm11bHRpcGx5KFBSSU1FNjRfMikgKS5yb3RsKDMxKS5tdWx0aXBseShQUklNRTY0XzEpO1xuXHRcdH1cblxuXHRcdHAgKz0gMzIgLSB0aGlzLm1lbXNpemVcblx0XHR0aGlzLm1lbXNpemUgPSAwXG5cdFx0aWYgKGlzU3RyaW5nKSB0aGlzLm1lbW9yeSA9ICcnXG5cdH1cblxuXHRpZiAocCA8PSBiRW5kIC0gMzIpXG5cdHtcblx0XHR2YXIgbGltaXQgPSBiRW5kIC0gMzJcblxuXHRcdGRvXG5cdFx0e1xuXHRcdFx0aWYgKGlzU3RyaW5nKSB7XG5cdFx0XHRcdHZhciBvdGhlclxuXHRcdFx0XHRvdGhlciA9IFVJTlQ2NChcblx0XHRcdFx0XHRcdChpbnB1dC5jaGFyQ29kZUF0KHArMSkgPDwgOCkgfCBpbnB1dC5jaGFyQ29kZUF0KHApXG5cdFx0XHRcdFx0LFx0KGlucHV0LmNoYXJDb2RlQXQocCszKSA8PCA4KSB8IGlucHV0LmNoYXJDb2RlQXQocCsyKVxuXHRcdFx0XHRcdCxcdChpbnB1dC5jaGFyQ29kZUF0KHArNSkgPDwgOCkgfCBpbnB1dC5jaGFyQ29kZUF0KHArNClcblx0XHRcdFx0XHQsXHQoaW5wdXQuY2hhckNvZGVBdChwKzcpIDw8IDgpIHwgaW5wdXQuY2hhckNvZGVBdChwKzYpXG5cdFx0XHRcdFx0KVxuXHRcdFx0XHR0aGlzLnYxLmFkZCggb3RoZXIubXVsdGlwbHkoUFJJTUU2NF8yKSApLnJvdGwoMzEpLm11bHRpcGx5KFBSSU1FNjRfMSk7XG5cdFx0XHRcdHAgKz0gOFxuXHRcdFx0XHRvdGhlciA9IFVJTlQ2NChcblx0XHRcdFx0XHRcdChpbnB1dC5jaGFyQ29kZUF0KHArMSkgPDwgOCkgfCBpbnB1dC5jaGFyQ29kZUF0KHApXG5cdFx0XHRcdFx0LFx0KGlucHV0LmNoYXJDb2RlQXQocCszKSA8PCA4KSB8IGlucHV0LmNoYXJDb2RlQXQocCsyKVxuXHRcdFx0XHRcdCxcdChpbnB1dC5jaGFyQ29kZUF0KHArNSkgPDwgOCkgfCBpbnB1dC5jaGFyQ29kZUF0KHArNClcblx0XHRcdFx0XHQsXHQoaW5wdXQuY2hhckNvZGVBdChwKzcpIDw8IDgpIHwgaW5wdXQuY2hhckNvZGVBdChwKzYpXG5cdFx0XHRcdFx0KVxuXHRcdFx0XHR0aGlzLnYyLmFkZCggb3RoZXIubXVsdGlwbHkoUFJJTUU2NF8yKSApLnJvdGwoMzEpLm11bHRpcGx5KFBSSU1FNjRfMSk7XG5cdFx0XHRcdHAgKz0gOFxuXHRcdFx0XHRvdGhlciA9IFVJTlQ2NChcblx0XHRcdFx0XHRcdChpbnB1dC5jaGFyQ29kZUF0KHArMSkgPDwgOCkgfCBpbnB1dC5jaGFyQ29kZUF0KHApXG5cdFx0XHRcdFx0LFx0KGlucHV0LmNoYXJDb2RlQXQocCszKSA8PCA4KSB8IGlucHV0LmNoYXJDb2RlQXQocCsyKVxuXHRcdFx0XHRcdCxcdChpbnB1dC5jaGFyQ29kZUF0KHArNSkgPDwgOCkgfCBpbnB1dC5jaGFyQ29kZUF0KHArNClcblx0XHRcdFx0XHQsXHQoaW5wdXQuY2hhckNvZGVBdChwKzcpIDw8IDgpIHwgaW5wdXQuY2hhckNvZGVBdChwKzYpXG5cdFx0XHRcdFx0KVxuXHRcdFx0XHR0aGlzLnYzLmFkZCggb3RoZXIubXVsdGlwbHkoUFJJTUU2NF8yKSApLnJvdGwoMzEpLm11bHRpcGx5KFBSSU1FNjRfMSk7XG5cdFx0XHRcdHAgKz0gOFxuXHRcdFx0XHRvdGhlciA9IFVJTlQ2NChcblx0XHRcdFx0XHRcdChpbnB1dC5jaGFyQ29kZUF0KHArMSkgPDwgOCkgfCBpbnB1dC5jaGFyQ29kZUF0KHApXG5cdFx0XHRcdFx0LFx0KGlucHV0LmNoYXJDb2RlQXQocCszKSA8PCA4KSB8IGlucHV0LmNoYXJDb2RlQXQocCsyKVxuXHRcdFx0XHRcdCxcdChpbnB1dC5jaGFyQ29kZUF0KHArNSkgPDwgOCkgfCBpbnB1dC5jaGFyQ29kZUF0KHArNClcblx0XHRcdFx0XHQsXHQoaW5wdXQuY2hhckNvZGVBdChwKzcpIDw8IDgpIHwgaW5wdXQuY2hhckNvZGVBdChwKzYpXG5cdFx0XHRcdFx0KVxuXHRcdFx0XHR0aGlzLnY0LmFkZCggb3RoZXIubXVsdGlwbHkoUFJJTUU2NF8yKSApLnJvdGwoMzEpLm11bHRpcGx5KFBSSU1FNjRfMSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgb3RoZXJcblx0XHRcdFx0b3RoZXIgPSBVSU5UNjQoXG5cdFx0XHRcdFx0XHQoaW5wdXRbcCsxXSA8PCA4KSB8IGlucHV0W3BdXG5cdFx0XHRcdFx0LFx0KGlucHV0W3ArM10gPDwgOCkgfCBpbnB1dFtwKzJdXG5cdFx0XHRcdFx0LFx0KGlucHV0W3ArNV0gPDwgOCkgfCBpbnB1dFtwKzRdXG5cdFx0XHRcdFx0LFx0KGlucHV0W3ArN10gPDwgOCkgfCBpbnB1dFtwKzZdXG5cdFx0XHRcdFx0KVxuXHRcdFx0XHR0aGlzLnYxLmFkZCggb3RoZXIubXVsdGlwbHkoUFJJTUU2NF8yKSApLnJvdGwoMzEpLm11bHRpcGx5KFBSSU1FNjRfMSk7XG5cdFx0XHRcdHAgKz0gOFxuXHRcdFx0XHRvdGhlciA9IFVJTlQ2NChcblx0XHRcdFx0XHRcdChpbnB1dFtwKzFdIDw8IDgpIHwgaW5wdXRbcF1cblx0XHRcdFx0XHQsXHQoaW5wdXRbcCszXSA8PCA4KSB8IGlucHV0W3ArMl1cblx0XHRcdFx0XHQsXHQoaW5wdXRbcCs1XSA8PCA4KSB8IGlucHV0W3ArNF1cblx0XHRcdFx0XHQsXHQoaW5wdXRbcCs3XSA8PCA4KSB8IGlucHV0W3ArNl1cblx0XHRcdFx0XHQpXG5cdFx0XHRcdHRoaXMudjIuYWRkKCBvdGhlci5tdWx0aXBseShQUklNRTY0XzIpICkucm90bCgzMSkubXVsdGlwbHkoUFJJTUU2NF8xKTtcblx0XHRcdFx0cCArPSA4XG5cdFx0XHRcdG90aGVyID0gVUlOVDY0KFxuXHRcdFx0XHRcdFx0KGlucHV0W3ArMV0gPDwgOCkgfCBpbnB1dFtwXVxuXHRcdFx0XHRcdCxcdChpbnB1dFtwKzNdIDw8IDgpIHwgaW5wdXRbcCsyXVxuXHRcdFx0XHRcdCxcdChpbnB1dFtwKzVdIDw8IDgpIHwgaW5wdXRbcCs0XVxuXHRcdFx0XHRcdCxcdChpbnB1dFtwKzddIDw8IDgpIHwgaW5wdXRbcCs2XVxuXHRcdFx0XHRcdClcblx0XHRcdFx0dGhpcy52My5hZGQoIG90aGVyLm11bHRpcGx5KFBSSU1FNjRfMikgKS5yb3RsKDMxKS5tdWx0aXBseShQUklNRTY0XzEpO1xuXHRcdFx0XHRwICs9IDhcblx0XHRcdFx0b3RoZXIgPSBVSU5UNjQoXG5cdFx0XHRcdFx0XHQoaW5wdXRbcCsxXSA8PCA4KSB8IGlucHV0W3BdXG5cdFx0XHRcdFx0LFx0KGlucHV0W3ArM10gPDwgOCkgfCBpbnB1dFtwKzJdXG5cdFx0XHRcdFx0LFx0KGlucHV0W3ArNV0gPDwgOCkgfCBpbnB1dFtwKzRdXG5cdFx0XHRcdFx0LFx0KGlucHV0W3ArN10gPDwgOCkgfCBpbnB1dFtwKzZdXG5cdFx0XHRcdFx0KVxuXHRcdFx0XHR0aGlzLnY0LmFkZCggb3RoZXIubXVsdGlwbHkoUFJJTUU2NF8yKSApLnJvdGwoMzEpLm11bHRpcGx5KFBSSU1FNjRfMSk7XG5cdFx0XHR9XG5cdFx0XHRwICs9IDhcblx0XHR9IHdoaWxlIChwIDw9IGxpbWl0KVxuXHR9XG5cblx0aWYgKHAgPCBiRW5kKVxuXHR7XG5cdFx0Ly8gWFhINjRfbWVtY3B5KHRoaXMubWVtb3J5LCBwLCBiRW5kLXApO1xuXHRcdGlmIChpc1N0cmluZykge1xuXHRcdFx0dGhpcy5tZW1vcnkgKz0gaW5wdXQuc2xpY2UocClcblx0XHR9IGVsc2UgaWYgKGlzQXJyYXlCdWZmZXIpIHtcblx0XHRcdHRoaXMubWVtb3J5LnNldCggaW5wdXQuc3ViYXJyYXkocCwgYkVuZCksIHRoaXMubWVtc2l6ZSApXG5cdFx0fSBlbHNlIHtcblx0XHRcdGlucHV0LmNvcHkoIHRoaXMubWVtb3J5LCB0aGlzLm1lbXNpemUsIHAsIGJFbmQgKVxuXHRcdH1cblxuXHRcdHRoaXMubWVtc2l6ZSA9IGJFbmQgLSBwXG5cdH1cblxuXHRyZXR1cm4gdGhpc1xufVxuXG4vKipcbiAqIEZpbmFsaXplIHRoZSBYWEg2NCBjb21wdXRhdGlvbi4gVGhlIFhYSDY0IGluc3RhbmNlIGlzIHJlYWR5IGZvciByZXVzZSBmb3IgdGhlIGdpdmVuIHNlZWRcbiAqIEBtZXRob2QgZGlnZXN0XG4gKiBAcmV0dXJuIHtVSU5UNjR9IHh4SGFzaFxuICovXG5YWEg2NC5wcm90b3R5cGUuZGlnZXN0ID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgaW5wdXQgPSB0aGlzLm1lbW9yeVxuXHR2YXIgaXNTdHJpbmcgPSB0eXBlb2YgaW5wdXQgPT0gJ3N0cmluZydcblx0dmFyIHAgPSAwXG5cdHZhciBiRW5kID0gdGhpcy5tZW1zaXplXG5cdHZhciBoNjQsIGhcblx0dmFyIHUgPSBuZXcgVUlOVDY0XG5cblx0aWYgKHRoaXMudG90YWxfbGVuID49IDMyKVxuXHR7XG5cdFx0aDY0ID0gdGhpcy52MS5jbG9uZSgpLnJvdGwoMSlcblx0XHRoNjQuYWRkKCB0aGlzLnYyLmNsb25lKCkucm90bCg3KSApXG5cdFx0aDY0LmFkZCggdGhpcy52My5jbG9uZSgpLnJvdGwoMTIpIClcblx0XHRoNjQuYWRkKCB0aGlzLnY0LmNsb25lKCkucm90bCgxOCkgKVxuXG5cdFx0aDY0LnhvciggdGhpcy52MS5tdWx0aXBseShQUklNRTY0XzIpLnJvdGwoMzEpLm11bHRpcGx5KFBSSU1FNjRfMSkgKVxuXHRcdGg2NC5tdWx0aXBseShQUklNRTY0XzEpLmFkZChQUklNRTY0XzQpXG5cblx0XHRoNjQueG9yKCB0aGlzLnYyLm11bHRpcGx5KFBSSU1FNjRfMikucm90bCgzMSkubXVsdGlwbHkoUFJJTUU2NF8xKSApXG5cdFx0aDY0Lm11bHRpcGx5KFBSSU1FNjRfMSkuYWRkKFBSSU1FNjRfNClcblxuXHRcdGg2NC54b3IoIHRoaXMudjMubXVsdGlwbHkoUFJJTUU2NF8yKS5yb3RsKDMxKS5tdWx0aXBseShQUklNRTY0XzEpIClcblx0XHRoNjQubXVsdGlwbHkoUFJJTUU2NF8xKS5hZGQoUFJJTUU2NF80KVxuXG5cdFx0aDY0LnhvciggdGhpcy52NC5tdWx0aXBseShQUklNRTY0XzIpLnJvdGwoMzEpLm11bHRpcGx5KFBSSU1FNjRfMSkgKVxuXHRcdGg2NC5tdWx0aXBseShQUklNRTY0XzEpLmFkZChQUklNRTY0XzQpXG5cdH1cblx0ZWxzZVxuXHR7XG5cdFx0aDY0ICA9IHRoaXMuc2VlZC5jbG9uZSgpLmFkZCggUFJJTUU2NF81IClcblx0fVxuXG5cdGg2NC5hZGQoIHUuZnJvbU51bWJlcih0aGlzLnRvdGFsX2xlbikgKVxuXG5cdHdoaWxlIChwIDw9IGJFbmQgLSA4KVxuXHR7XG5cdFx0aWYgKGlzU3RyaW5nKSB7XG5cdFx0XHR1LmZyb21CaXRzKFxuXHRcdFx0XHQoaW5wdXQuY2hhckNvZGVBdChwKzEpIDw8IDgpIHwgaW5wdXQuY2hhckNvZGVBdChwKVxuXHRcdFx0LFx0KGlucHV0LmNoYXJDb2RlQXQocCszKSA8PCA4KSB8IGlucHV0LmNoYXJDb2RlQXQocCsyKVxuXHRcdFx0LFx0KGlucHV0LmNoYXJDb2RlQXQocCs1KSA8PCA4KSB8IGlucHV0LmNoYXJDb2RlQXQocCs0KVxuXHRcdFx0LFx0KGlucHV0LmNoYXJDb2RlQXQocCs3KSA8PCA4KSB8IGlucHV0LmNoYXJDb2RlQXQocCs2KVxuXHRcdFx0KVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR1LmZyb21CaXRzKFxuXHRcdFx0XHQoaW5wdXRbcCsxXSA8PCA4KSB8IGlucHV0W3BdXG5cdFx0XHQsXHQoaW5wdXRbcCszXSA8PCA4KSB8IGlucHV0W3ArMl1cblx0XHRcdCxcdChpbnB1dFtwKzVdIDw8IDgpIHwgaW5wdXRbcCs0XVxuXHRcdFx0LFx0KGlucHV0W3ArN10gPDwgOCkgfCBpbnB1dFtwKzZdXG5cdFx0XHQpXG5cdFx0fVxuXHRcdHUubXVsdGlwbHkoUFJJTUU2NF8yKS5yb3RsKDMxKS5tdWx0aXBseShQUklNRTY0XzEpXG5cdFx0aDY0XG5cdFx0XHQueG9yKHUpXG5cdFx0XHQucm90bCgyNylcblx0XHRcdC5tdWx0aXBseSggUFJJTUU2NF8xIClcblx0XHRcdC5hZGQoIFBSSU1FNjRfNCApXG5cdFx0cCArPSA4XG5cdH1cblxuXHRpZiAocCArIDQgPD0gYkVuZCkge1xuXHRcdGlmIChpc1N0cmluZykge1xuXHRcdFx0dS5mcm9tQml0cyhcblx0XHRcdFx0KGlucHV0LmNoYXJDb2RlQXQocCsxKSA8PCA4KSB8IGlucHV0LmNoYXJDb2RlQXQocClcblx0XHRcdCxcdChpbnB1dC5jaGFyQ29kZUF0KHArMykgPDwgOCkgfCBpbnB1dC5jaGFyQ29kZUF0KHArMilcblx0XHRcdCxcdDBcblx0XHRcdCxcdDBcblx0XHRcdClcblx0XHR9IGVsc2Uge1xuXHRcdFx0dS5mcm9tQml0cyhcblx0XHRcdFx0KGlucHV0W3ArMV0gPDwgOCkgfCBpbnB1dFtwXVxuXHRcdFx0LFx0KGlucHV0W3ArM10gPDwgOCkgfCBpbnB1dFtwKzJdXG5cdFx0XHQsXHQwXG5cdFx0XHQsXHQwXG5cdFx0XHQpXG5cdFx0fVxuXHRcdGg2NFxuXHRcdFx0LnhvciggdS5tdWx0aXBseShQUklNRTY0XzEpIClcblx0XHRcdC5yb3RsKDIzKVxuXHRcdFx0Lm11bHRpcGx5KCBQUklNRTY0XzIgKVxuXHRcdFx0LmFkZCggUFJJTUU2NF8zIClcblx0XHRwICs9IDRcblx0fVxuXG5cdHdoaWxlIChwIDwgYkVuZClcblx0e1xuXHRcdHUuZnJvbUJpdHMoIGlzU3RyaW5nID8gaW5wdXQuY2hhckNvZGVBdChwKyspIDogaW5wdXRbcCsrXSwgMCwgMCwgMCApXG5cdFx0aDY0XG5cdFx0XHQueG9yKCB1Lm11bHRpcGx5KFBSSU1FNjRfNSkgKVxuXHRcdFx0LnJvdGwoMTEpXG5cdFx0XHQubXVsdGlwbHkoUFJJTUU2NF8xKVxuXHR9XG5cblx0aCA9IGg2NC5jbG9uZSgpLnNoaWZ0UmlnaHQoMzMpXG5cdGg2NC54b3IoaCkubXVsdGlwbHkoUFJJTUU2NF8yKVxuXG5cdGggPSBoNjQuY2xvbmUoKS5zaGlmdFJpZ2h0KDI5KVxuXHRoNjQueG9yKGgpLm11bHRpcGx5KFBSSU1FNjRfMylcblxuXHRoID0gaDY0LmNsb25lKCkuc2hpZnRSaWdodCgzMilcblx0aDY0LnhvcihoKVxuXG5cdC8vIFJlc2V0IHRoZSBzdGF0ZVxuXHR0aGlzLmluaXQoIHRoaXMuc2VlZCApXG5cblx0cmV0dXJuIGg2NFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFhYSDY0XG4iLCAibW9kdWxlLmV4cG9ydHMgPSB7XG5cdGgzMjogcmVxdWlyZShcIi4veHhoYXNoXCIpXG4sXHRoNjQ6IHJlcXVpcmUoXCIuL3h4aGFzaDY0XCIpXG59XG4iLCAiKGZ1bmN0aW9uKGUpe2lmKFwib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgbW9kdWxlKW1vZHVsZS5leHBvcnRzPWUoKTtlbHNlIGlmKFwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZClkZWZpbmUoW10sZSk7ZWxzZXt2YXIgdDt0PVwidW5kZWZpbmVkXCI9PXR5cGVvZiB3aW5kb3c/XCJ1bmRlZmluZWRcIj09dHlwZW9mIGdsb2JhbD9cInVuZGVmaW5lZFwiPT10eXBlb2Ygc2VsZj90aGlzOnNlbGY6Z2xvYmFsOndpbmRvdyx0LlNpbXBsZVBlZXI9ZSgpfX0pKGZ1bmN0aW9uKCl7dmFyIHQ9TWF0aC5mbG9vcixuPU1hdGguYWJzLHI9TWF0aC5wb3c7cmV0dXJuIGZ1bmN0aW9uKCl7ZnVuY3Rpb24gZChzLGUsbil7ZnVuY3Rpb24gdChvLGkpe2lmKCFlW29dKXtpZighc1tvXSl7dmFyIGw9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZTtpZighaSYmbClyZXR1cm4gbChvLCEwKTtpZihyKXJldHVybiByKG8sITApO3ZhciBjPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgYy5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGN9dmFyIGE9ZVtvXT17ZXhwb3J0czp7fX07c1tvXVswXS5jYWxsKGEuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgcj1zW29dWzFdW2VdO3JldHVybiB0KHJ8fGUpfSxhLGEuZXhwb3J0cyxkLHMsZSxuKX1yZXR1cm4gZVtvXS5leHBvcnRzfWZvcih2YXIgcj1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlLGE9MDthPG4ubGVuZ3RoO2ErKyl0KG5bYV0pO3JldHVybiB0fXJldHVybiBkfSgpKHsxOltmdW5jdGlvbihlLHQsbil7J3VzZSBzdHJpY3QnO2Z1bmN0aW9uIHIoZSl7dmFyIHQ9ZS5sZW5ndGg7aWYoMDx0JTQpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNFwiKTt2YXIgbj1lLmluZGV4T2YoXCI9XCIpOy0xPT09biYmKG49dCk7dmFyIHI9bj09PXQ/MDo0LW4lNDtyZXR1cm5bbixyXX1mdW5jdGlvbiBhKGUsdCxuKXtyZXR1cm4gMyoodCtuKS80LW59ZnVuY3Rpb24gbyhlKXt2YXIgdCxuLG89cihlKSxkPW9bMF0scz1vWzFdLGw9bmV3IHAoYShlLGQscykpLGM9MCxmPTA8cz9kLTQ6ZDtmb3Iobj0wO248ZjtuKz00KXQ9dVtlLmNoYXJDb2RlQXQobildPDwxOHx1W2UuY2hhckNvZGVBdChuKzEpXTw8MTJ8dVtlLmNoYXJDb2RlQXQobisyKV08PDZ8dVtlLmNoYXJDb2RlQXQobiszKV0sbFtjKytdPTI1NSZ0Pj4xNixsW2MrK109MjU1JnQ+PjgsbFtjKytdPTI1NSZ0O3JldHVybiAyPT09cyYmKHQ9dVtlLmNoYXJDb2RlQXQobildPDwyfHVbZS5jaGFyQ29kZUF0KG4rMSldPj40LGxbYysrXT0yNTUmdCksMT09PXMmJih0PXVbZS5jaGFyQ29kZUF0KG4pXTw8MTB8dVtlLmNoYXJDb2RlQXQobisxKV08PDR8dVtlLmNoYXJDb2RlQXQobisyKV0+PjIsbFtjKytdPTI1NSZ0Pj44LGxbYysrXT0yNTUmdCksbH1mdW5jdGlvbiBkKGUpe3JldHVybiBjWzYzJmU+PjE4XStjWzYzJmU+PjEyXStjWzYzJmU+PjZdK2NbNjMmZV19ZnVuY3Rpb24gcyhlLHQsbil7Zm9yKHZhciByLGE9W10sbz10O288bjtvKz0zKXI9KDE2NzExNjgwJmVbb108PDE2KSsoNjUyODAmZVtvKzFdPDw4KSsoMjU1JmVbbysyXSksYS5wdXNoKGQocikpO3JldHVybiBhLmpvaW4oXCJcIil9ZnVuY3Rpb24gbChlKXtmb3IodmFyIHQsbj1lLmxlbmd0aCxyPW4lMyxhPVtdLG89MTYzODMsZD0wLGw9bi1yO2Q8bDtkKz1vKWEucHVzaChzKGUsZCxkK28+bD9sOmQrbykpO3JldHVybiAxPT09cj8odD1lW24tMV0sYS5wdXNoKGNbdD4+Ml0rY1s2MyZ0PDw0XStcIj09XCIpKToyPT09ciYmKHQ9KGVbbi0yXTw8OCkrZVtuLTFdLGEucHVzaChjW3Q+PjEwXStjWzYzJnQ+PjRdK2NbNjMmdDw8Ml0rXCI9XCIpKSxhLmpvaW4oXCJcIil9bi5ieXRlTGVuZ3RoPWZ1bmN0aW9uKGUpe3ZhciB0PXIoZSksbj10WzBdLGE9dFsxXTtyZXR1cm4gMyoobithKS80LWF9LG4udG9CeXRlQXJyYXk9byxuLmZyb21CeXRlQXJyYXk9bDtmb3IodmFyIGM9W10sdT1bXSxwPVwidW5kZWZpbmVkXCI9PXR5cGVvZiBVaW50OEFycmF5P0FycmF5OlVpbnQ4QXJyYXksZj1cIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky9cIixnPTAsXz1mLmxlbmd0aDtnPF87KytnKWNbZ109ZltnXSx1W2YuY2hhckNvZGVBdChnKV09Zzt1WzQ1XT02Mix1Wzk1XT02M30se31dLDI6W2Z1bmN0aW9uKCl7fSx7fV0sMzpbZnVuY3Rpb24oZSx0LG4peyhmdW5jdGlvbigpeyhmdW5jdGlvbigpey8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqLyd1c2Ugc3RyaWN0Jzt2YXIgdD1TdHJpbmcuZnJvbUNoYXJDb2RlLG89TWF0aC5taW47ZnVuY3Rpb24gZChlKXtpZigyMTQ3NDgzNjQ3PGUpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUaGUgdmFsdWUgXFxcIlwiK2UrXCJcXFwiIGlzIGludmFsaWQgZm9yIG9wdGlvbiBcXFwic2l6ZVxcXCJcIik7dmFyIHQ9bmV3IFVpbnQ4QXJyYXkoZSk7cmV0dXJuIHQuX19wcm90b19fPXMucHJvdG90eXBlLHR9ZnVuY3Rpb24gcyhlLHQsbil7aWYoXCJudW1iZXJcIj09dHlwZW9mIGUpe2lmKFwic3RyaW5nXCI9PXR5cGVvZiB0KXRocm93IG5ldyBUeXBlRXJyb3IoXCJUaGUgXFxcInN0cmluZ1xcXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIHN0cmluZy4gUmVjZWl2ZWQgdHlwZSBudW1iZXJcIik7cmV0dXJuIHAoZSl9cmV0dXJuIGwoZSx0LG4pfWZ1bmN0aW9uIGwoZSx0LG4pe2lmKFwic3RyaW5nXCI9PXR5cGVvZiBlKXJldHVybiBmKGUsdCk7aWYoQXJyYXlCdWZmZXIuaXNWaWV3KGUpKXJldHVybiBnKGUpO2lmKG51bGw9PWUpdGhyb3cgVHlwZUVycm9yKFwiVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgb3IgQXJyYXktbGlrZSBPYmplY3QuIFJlY2VpdmVkIHR5cGUgXCIrdHlwZW9mIGUpO2lmKEsoZSxBcnJheUJ1ZmZlcil8fGUmJksoZS5idWZmZXIsQXJyYXlCdWZmZXIpKXJldHVybiBfKGUsdCxuKTtpZihcIm51bWJlclwiPT10eXBlb2YgZSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiVGhlIFxcXCJ2YWx1ZVxcXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgb2YgdHlwZSBudW1iZXIuIFJlY2VpdmVkIHR5cGUgbnVtYmVyXCIpO3ZhciByPWUudmFsdWVPZiYmZS52YWx1ZU9mKCk7aWYobnVsbCE9ciYmciE9PWUpcmV0dXJuIHMuZnJvbShyLHQsbik7dmFyIGE9aChlKTtpZihhKXJldHVybiBhO2lmKFwidW5kZWZpbmVkXCIhPXR5cGVvZiBTeW1ib2wmJm51bGwhPVN5bWJvbC50b1ByaW1pdGl2ZSYmXCJmdW5jdGlvblwiPT10eXBlb2YgZVtTeW1ib2wudG9QcmltaXRpdmVdKXJldHVybiBzLmZyb20oZVtTeW1ib2wudG9QcmltaXRpdmVdKFwic3RyaW5nXCIpLHQsbik7dGhyb3cgbmV3IFR5cGVFcnJvcihcIlRoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksIG9yIEFycmF5LWxpa2UgT2JqZWN0LiBSZWNlaXZlZCB0eXBlIFwiK3R5cGVvZiBlKX1mdW5jdGlvbiBjKGUpe2lmKFwibnVtYmVyXCIhPXR5cGVvZiBlKXRocm93IG5ldyBUeXBlRXJyb3IoXCJcXFwic2l6ZVxcXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIG51bWJlclwiKTtlbHNlIGlmKDA+ZSl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlRoZSB2YWx1ZSBcXFwiXCIrZStcIlxcXCIgaXMgaW52YWxpZCBmb3Igb3B0aW9uIFxcXCJzaXplXFxcIlwiKX1mdW5jdGlvbiB1KGUsdCxuKXtyZXR1cm4gYyhlKSwwPj1lP2QoZSk6dm9pZCAwPT09dD9kKGUpOlwic3RyaW5nXCI9PXR5cGVvZiBuP2QoZSkuZmlsbCh0LG4pOmQoZSkuZmlsbCh0KX1mdW5jdGlvbiBwKGUpe3JldHVybiBjKGUpLGQoMD5lPzA6MHxtKGUpKX1mdW5jdGlvbiBmKGUsdCl7aWYoKFwic3RyaW5nXCIhPXR5cGVvZiB0fHxcIlwiPT09dCkmJih0PVwidXRmOFwiKSwhcy5pc0VuY29kaW5nKHQpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJVbmtub3duIGVuY29kaW5nOiBcIit0KTt2YXIgbj0wfGIoZSx0KSxyPWQobiksYT1yLndyaXRlKGUsdCk7cmV0dXJuIGEhPT1uJiYocj1yLnNsaWNlKDAsYSkpLHJ9ZnVuY3Rpb24gZyhlKXtmb3IodmFyIHQ9MD5lLmxlbmd0aD8wOjB8bShlLmxlbmd0aCksbj1kKHQpLHI9MDtyPHQ7cis9MSluW3JdPTI1NSZlW3JdO3JldHVybiBufWZ1bmN0aW9uIF8oZSx0LG4pe2lmKDA+dHx8ZS5ieXRlTGVuZ3RoPHQpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJcXFwib2Zmc2V0XFxcIiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHNcIik7aWYoZS5ieXRlTGVuZ3RoPHQrKG58fDApKXRocm93IG5ldyBSYW5nZUVycm9yKFwiXFxcImxlbmd0aFxcXCIgaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzXCIpO3ZhciByO3JldHVybiByPXZvaWQgMD09PXQmJnZvaWQgMD09PW4/bmV3IFVpbnQ4QXJyYXkoZSk6dm9pZCAwPT09bj9uZXcgVWludDhBcnJheShlLHQpOm5ldyBVaW50OEFycmF5KGUsdCxuKSxyLl9fcHJvdG9fXz1zLnByb3RvdHlwZSxyfWZ1bmN0aW9uIGgoZSl7aWYocy5pc0J1ZmZlcihlKSl7dmFyIHQ9MHxtKGUubGVuZ3RoKSxuPWQodCk7cmV0dXJuIDA9PT1uLmxlbmd0aD9uOihlLmNvcHkobiwwLDAsdCksbil9cmV0dXJuIHZvaWQgMD09PWUubGVuZ3RoP1wiQnVmZmVyXCI9PT1lLnR5cGUmJkFycmF5LmlzQXJyYXkoZS5kYXRhKT9nKGUuZGF0YSk6dm9pZCAwOlwibnVtYmVyXCIhPXR5cGVvZiBlLmxlbmd0aHx8WChlLmxlbmd0aCk/ZCgwKTpnKGUpfWZ1bmN0aW9uIG0oZSl7aWYoZT49MjE0NzQ4MzY0Nyl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkF0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gc2l6ZTogMHhcIisyMTQ3NDgzNjQ3IC50b1N0cmluZygxNikrXCIgYnl0ZXNcIik7cmV0dXJuIDB8ZX1mdW5jdGlvbiBiKGUsdCl7aWYocy5pc0J1ZmZlcihlKSlyZXR1cm4gZS5sZW5ndGg7aWYoQXJyYXlCdWZmZXIuaXNWaWV3KGUpfHxLKGUsQXJyYXlCdWZmZXIpKXJldHVybiBlLmJ5dGVMZW5ndGg7aWYoXCJzdHJpbmdcIiE9dHlwZW9mIGUpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlRoZSBcXFwic3RyaW5nXFxcIiBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBvciBBcnJheUJ1ZmZlci4gUmVjZWl2ZWQgdHlwZSBcIit0eXBlb2YgZSk7dmFyIG49ZS5sZW5ndGgscj0yPGFyZ3VtZW50cy5sZW5ndGgmJiEwPT09YXJndW1lbnRzWzJdO2lmKCFyJiYwPT09bilyZXR1cm4gMDtmb3IodmFyIGE9ITE7Oylzd2l0Y2godCl7Y2FzZVwiYXNjaWlcIjpjYXNlXCJsYXRpbjFcIjpjYXNlXCJiaW5hcnlcIjpyZXR1cm4gbjtjYXNlXCJ1dGY4XCI6Y2FzZVwidXRmLThcIjpyZXR1cm4gSChlKS5sZW5ndGg7Y2FzZVwidWNzMlwiOmNhc2VcInVjcy0yXCI6Y2FzZVwidXRmMTZsZVwiOmNhc2VcInV0Zi0xNmxlXCI6cmV0dXJuIDIqbjtjYXNlXCJoZXhcIjpyZXR1cm4gbj4+PjE7Y2FzZVwiYmFzZTY0XCI6cmV0dXJuIHooZSkubGVuZ3RoO2RlZmF1bHQ6aWYoYSlyZXR1cm4gcj8tMTpIKGUpLmxlbmd0aDt0PShcIlwiK3QpLnRvTG93ZXJDYXNlKCksYT0hMDt9fWZ1bmN0aW9uIHkoZSx0LG4pe3ZhciByPSExO2lmKCh2b2lkIDA9PT10fHwwPnQpJiYodD0wKSx0PnRoaXMubGVuZ3RoKXJldHVyblwiXCI7aWYoKHZvaWQgMD09PW58fG4+dGhpcy5sZW5ndGgpJiYobj10aGlzLmxlbmd0aCksMD49bilyZXR1cm5cIlwiO2lmKG4+Pj49MCx0Pj4+PTAsbjw9dClyZXR1cm5cIlwiO2ZvcihlfHwoZT1cInV0ZjhcIik7Oylzd2l0Y2goZSl7Y2FzZVwiaGV4XCI6cmV0dXJuIFAodGhpcyx0LG4pO2Nhc2VcInV0ZjhcIjpjYXNlXCJ1dGYtOFwiOnJldHVybiB4KHRoaXMsdCxuKTtjYXNlXCJhc2NpaVwiOnJldHVybiBEKHRoaXMsdCxuKTtjYXNlXCJsYXRpbjFcIjpjYXNlXCJiaW5hcnlcIjpyZXR1cm4gSSh0aGlzLHQsbik7Y2FzZVwiYmFzZTY0XCI6cmV0dXJuIEEodGhpcyx0LG4pO2Nhc2VcInVjczJcIjpjYXNlXCJ1Y3MtMlwiOmNhc2VcInV0ZjE2bGVcIjpjYXNlXCJ1dGYtMTZsZVwiOnJldHVybiBNKHRoaXMsdCxuKTtkZWZhdWx0OmlmKHIpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlVua25vd24gZW5jb2Rpbmc6IFwiK2UpO2U9KGUrXCJcIikudG9Mb3dlckNhc2UoKSxyPSEwO319ZnVuY3Rpb24gQyhlLHQsbil7dmFyIHI9ZVt0XTtlW3RdPWVbbl0sZVtuXT1yfWZ1bmN0aW9uIFIoZSx0LG4scixhKXtpZigwPT09ZS5sZW5ndGgpcmV0dXJuLTE7aWYoXCJzdHJpbmdcIj09dHlwZW9mIG4/KHI9bixuPTApOjIxNDc0ODM2NDc8bj9uPTIxNDc0ODM2NDc6LTIxNDc0ODM2NDg+biYmKG49LTIxNDc0ODM2NDgpLG49K24sWChuKSYmKG49YT8wOmUubGVuZ3RoLTEpLDA+biYmKG49ZS5sZW5ndGgrbiksbj49ZS5sZW5ndGgpe2lmKGEpcmV0dXJuLTE7bj1lLmxlbmd0aC0xfWVsc2UgaWYoMD5uKWlmKGEpbj0wO2Vsc2UgcmV0dXJuLTE7aWYoXCJzdHJpbmdcIj09dHlwZW9mIHQmJih0PXMuZnJvbSh0LHIpKSxzLmlzQnVmZmVyKHQpKXJldHVybiAwPT09dC5sZW5ndGg/LTE6RShlLHQsbixyLGEpO2lmKFwibnVtYmVyXCI9PXR5cGVvZiB0KXJldHVybiB0Jj0yNTUsXCJmdW5jdGlvblwiPT10eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZj9hP1VpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChlLHQsbik6VWludDhBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YuY2FsbChlLHQsbik6RShlLFt0XSxuLHIsYSk7dGhyb3cgbmV3IFR5cGVFcnJvcihcInZhbCBtdXN0IGJlIHN0cmluZywgbnVtYmVyIG9yIEJ1ZmZlclwiKX1mdW5jdGlvbiBFKGUsdCxuLHIsYSl7ZnVuY3Rpb24gbyhlLHQpe3JldHVybiAxPT09ZD9lW3RdOmUucmVhZFVJbnQxNkJFKHQqZCl9dmFyIGQ9MSxzPWUubGVuZ3RoLGw9dC5sZW5ndGg7aWYodm9pZCAwIT09ciYmKHI9KHIrXCJcIikudG9Mb3dlckNhc2UoKSxcInVjczJcIj09PXJ8fFwidWNzLTJcIj09PXJ8fFwidXRmMTZsZVwiPT09cnx8XCJ1dGYtMTZsZVwiPT09cikpe2lmKDI+ZS5sZW5ndGh8fDI+dC5sZW5ndGgpcmV0dXJuLTE7ZD0yLHMvPTIsbC89MixuLz0yfXZhciBjO2lmKGEpe3ZhciB1PS0xO2ZvcihjPW47YzxzO2MrKylpZihvKGUsYykhPT1vKHQsLTE9PT11PzA6Yy11KSktMSE9PXUmJihjLT1jLXUpLHU9LTE7ZWxzZSBpZigtMT09PXUmJih1PWMpLGMtdSsxPT09bClyZXR1cm4gdSpkfWVsc2UgZm9yKG4rbD5zJiYobj1zLWwpLGM9bjswPD1jO2MtLSl7Zm9yKHZhciBwPSEwLGY9MDtmPGw7ZisrKWlmKG8oZSxjK2YpIT09byh0LGYpKXtwPSExO2JyZWFrfWlmKHApcmV0dXJuIGN9cmV0dXJuLTF9ZnVuY3Rpb24gdyhlLHQsbixyKXtuPStufHwwO3ZhciBhPWUubGVuZ3RoLW47cj8ocj0rcixyPmEmJihyPWEpKTpyPWE7dmFyIG89dC5sZW5ndGg7cj5vLzImJihyPW8vMik7Zm9yKHZhciBkLHM9MDtzPHI7KytzKXtpZihkPXBhcnNlSW50KHQuc3Vic3RyKDIqcywyKSwxNiksWChkKSlyZXR1cm4gcztlW24rc109ZH1yZXR1cm4gc31mdW5jdGlvbiBTKGUsdCxuLHIpe3JldHVybiBHKEgodCxlLmxlbmd0aC1uKSxlLG4scil9ZnVuY3Rpb24gVChlLHQsbixyKXtyZXR1cm4gRyhZKHQpLGUsbixyKX1mdW5jdGlvbiB2KGUsdCxuLHIpe3JldHVybiBUKGUsdCxuLHIpfWZ1bmN0aW9uIGsoZSx0LG4scil7cmV0dXJuIEcoeih0KSxlLG4scil9ZnVuY3Rpb24gTChlLHQsbixyKXtyZXR1cm4gRyhWKHQsZS5sZW5ndGgtbiksZSxuLHIpfWZ1bmN0aW9uIEEoZSx0LG4pe3JldHVybiAwPT09dCYmbj09PWUubGVuZ3RoPyQuZnJvbUJ5dGVBcnJheShlKTokLmZyb21CeXRlQXJyYXkoZS5zbGljZSh0LG4pKX1mdW5jdGlvbiB4KGUsdCxuKXtuPW8oZS5sZW5ndGgsbik7Zm9yKHZhciByPVtdLGE9dDthPG47KXt2YXIgZD1lW2FdLHM9bnVsbCxsPTIzOTxkPzQ6MjIzPGQ/MzoxOTE8ZD8yOjE7aWYoYStsPD1uKXt2YXIgYyx1LHAsZjsxPT09bD8xMjg+ZCYmKHM9ZCk6Mj09PWw/KGM9ZVthKzFdLDEyOD09KDE5MiZjKSYmKGY9KDMxJmQpPDw2fDYzJmMsMTI3PGYmJihzPWYpKSk6Mz09PWw/KGM9ZVthKzFdLHU9ZVthKzJdLDEyOD09KDE5MiZjKSYmMTI4PT0oMTkyJnUpJiYoZj0oMTUmZCk8PDEyfCg2MyZjKTw8Nnw2MyZ1LDIwNDc8ZiYmKDU1Mjk2PmZ8fDU3MzQzPGYpJiYocz1mKSkpOjQ9PT1sPyhjPWVbYSsxXSx1PWVbYSsyXSxwPWVbYSszXSwxMjg9PSgxOTImYykmJjEyOD09KDE5MiZ1KSYmMTI4PT0oMTkyJnApJiYoZj0oMTUmZCk8PDE4fCg2MyZjKTw8MTJ8KDYzJnUpPDw2fDYzJnAsNjU1MzU8ZiYmMTExNDExMj5mJiYocz1mKSkpOnZvaWQgMH1udWxsPT09cz8ocz02NTUzMyxsPTEpOjY1NTM1PHMmJihzLT02NTUzNixyLnB1c2goNTUyOTZ8MTAyMyZzPj4+MTApLHM9NTYzMjB8MTAyMyZzKSxyLnB1c2gocyksYSs9bH1yZXR1cm4gTihyKX1mdW5jdGlvbiBOKGUpe3ZhciBuPWUubGVuZ3RoO2lmKG48PTQwOTYpcmV0dXJuIHQuYXBwbHkoU3RyaW5nLGUpO2Zvcih2YXIgcj1cIlwiLGE9MDthPG47KXIrPXQuYXBwbHkoU3RyaW5nLGUuc2xpY2UoYSxhKz00MDk2KSk7cmV0dXJuIHJ9ZnVuY3Rpb24gRChlLG4scil7dmFyIGE9XCJcIjtyPW8oZS5sZW5ndGgscik7Zm9yKHZhciBkPW47ZDxyOysrZClhKz10KDEyNyZlW2RdKTtyZXR1cm4gYX1mdW5jdGlvbiBJKGUsbixyKXt2YXIgYT1cIlwiO3I9byhlLmxlbmd0aCxyKTtmb3IodmFyIGQ9bjtkPHI7KytkKWErPXQoZVtkXSk7cmV0dXJuIGF9ZnVuY3Rpb24gUChlLHQsbil7dmFyIHI9ZS5sZW5ndGg7KCF0fHwwPnQpJiYodD0wKSwoIW58fDA+bnx8bj5yKSYmKG49cik7Zm9yKHZhciBhPVwiXCIsbz10O288bjsrK28pYSs9VyhlW29dKTtyZXR1cm4gYX1mdW5jdGlvbiBNKGUsbixyKXtmb3IodmFyIGE9ZS5zbGljZShuLHIpLG89XCJcIixkPTA7ZDxhLmxlbmd0aDtkKz0yKW8rPXQoYVtkXSsyNTYqYVtkKzFdKTtyZXR1cm4gb31mdW5jdGlvbiBPKGUsdCxuKXtpZigwIT1lJTF8fDA+ZSl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIm9mZnNldCBpcyBub3QgdWludFwiKTtpZihlK3Q+bil0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlRyeWluZyB0byBhY2Nlc3MgYmV5b25kIGJ1ZmZlciBsZW5ndGhcIil9ZnVuY3Rpb24gRihlLHQsbixyLGEsbyl7aWYoIXMuaXNCdWZmZXIoZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlxcXCJidWZmZXJcXFwiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2VcIik7aWYodD5hfHx0PG8pdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJcXFwidmFsdWVcXFwiIGFyZ3VtZW50IGlzIG91dCBvZiBib3VuZHNcIik7aWYobityPmUubGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKFwiSW5kZXggb3V0IG9mIHJhbmdlXCIpfWZ1bmN0aW9uIEIoZSx0LG4scil7aWYobityPmUubGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKFwiSW5kZXggb3V0IG9mIHJhbmdlXCIpO2lmKDA+bil0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkluZGV4IG91dCBvZiByYW5nZVwiKX1mdW5jdGlvbiBVKGUsdCxuLHIsYSl7cmV0dXJuIHQ9K3Qsbj4+Pj0wLGF8fEIoZSx0LG4sNCwzNDAyODIzNDY2Mzg1Mjg4NmUyMiwtMzQwMjgyMzQ2NjM4NTI4ODZlMjIpLEoud3JpdGUoZSx0LG4sciwyMyw0KSxuKzR9ZnVuY3Rpb24gaihlLHQsbixyLGEpe3JldHVybiB0PSt0LG4+Pj49MCxhfHxCKGUsdCxuLDgsMTc5NzY5MzEzNDg2MjMxNTdlMjkyLC0xNzk3NjkzMTM0ODYyMzE1N2UyOTIpLEoud3JpdGUoZSx0LG4sciw1Miw4KSxuKzh9ZnVuY3Rpb24gcShlKXtpZihlPWUuc3BsaXQoXCI9XCIpWzBdLGU9ZS50cmltKCkucmVwbGFjZShRLFwiXCIpLDI+ZS5sZW5ndGgpcmV0dXJuXCJcIjtmb3IoOzAhPWUubGVuZ3RoJTQ7KWUrPVwiPVwiO3JldHVybiBlfWZ1bmN0aW9uIFcoZSl7cmV0dXJuIDE2PmU/XCIwXCIrZS50b1N0cmluZygxNik6ZS50b1N0cmluZygxNil9ZnVuY3Rpb24gSChlLHQpe3Q9dHx8MS8wO2Zvcih2YXIgbixyPWUubGVuZ3RoLGE9bnVsbCxvPVtdLGQ9MDtkPHI7KytkKXtpZihuPWUuY2hhckNvZGVBdChkKSw1NTI5NTxuJiY1NzM0ND5uKXtpZighYSl7aWYoNTYzMTk8bil7LTE8KHQtPTMpJiZvLnB1c2goMjM5LDE5MSwxODkpO2NvbnRpbnVlfWVsc2UgaWYoZCsxPT09cil7LTE8KHQtPTMpJiZvLnB1c2goMjM5LDE5MSwxODkpO2NvbnRpbnVlfWE9bjtjb250aW51ZX1pZig1NjMyMD5uKXstMTwodC09MykmJm8ucHVzaCgyMzksMTkxLDE4OSksYT1uO2NvbnRpbnVlfW49KGEtNTUyOTY8PDEwfG4tNTYzMjApKzY1NTM2fWVsc2UgYSYmLTE8KHQtPTMpJiZvLnB1c2goMjM5LDE5MSwxODkpO2lmKGE9bnVsbCwxMjg+bil7aWYoMD4odC09MSkpYnJlYWs7by5wdXNoKG4pfWVsc2UgaWYoMjA0OD5uKXtpZigwPih0LT0yKSlicmVhaztvLnB1c2goMTkyfG4+PjYsMTI4fDYzJm4pfWVsc2UgaWYoNjU1MzY+bil7aWYoMD4odC09MykpYnJlYWs7by5wdXNoKDIyNHxuPj4xMiwxMjh8NjMmbj4+NiwxMjh8NjMmbil9ZWxzZSBpZigxMTE0MTEyPm4pe2lmKDA+KHQtPTQpKWJyZWFrO28ucHVzaCgyNDB8bj4+MTgsMTI4fDYzJm4+PjEyLDEyOHw2MyZuPj42LDEyOHw2MyZuKX1lbHNlIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgY29kZSBwb2ludFwiKX1yZXR1cm4gb31mdW5jdGlvbiBZKGUpe2Zvcih2YXIgdD1bXSxuPTA7bjxlLmxlbmd0aDsrK24pdC5wdXNoKDI1NSZlLmNoYXJDb2RlQXQobikpO3JldHVybiB0fWZ1bmN0aW9uIFYoZSx0KXtmb3IodmFyIG4scixhLG89W10sZD0wO2Q8ZS5sZW5ndGgmJiEoMD4odC09MikpOysrZCluPWUuY2hhckNvZGVBdChkKSxyPW4+PjgsYT1uJTI1NixvLnB1c2goYSksby5wdXNoKHIpO3JldHVybiBvfWZ1bmN0aW9uIHooZSl7cmV0dXJuICQudG9CeXRlQXJyYXkocShlKSl9ZnVuY3Rpb24gRyhlLHQsbixyKXtmb3IodmFyIGE9MDthPHImJiEoYStuPj10Lmxlbmd0aHx8YT49ZS5sZW5ndGgpOysrYSl0W2Erbl09ZVthXTtyZXR1cm4gYX1mdW5jdGlvbiBLKGUsdCl7cmV0dXJuIGUgaW5zdGFuY2VvZiB0fHxudWxsIT1lJiZudWxsIT1lLmNvbnN0cnVjdG9yJiZudWxsIT1lLmNvbnN0cnVjdG9yLm5hbWUmJmUuY29uc3RydWN0b3IubmFtZT09PXQubmFtZX1mdW5jdGlvbiBYKGUpe3JldHVybiBlIT09ZX12YXIgJD1lKFwiYmFzZTY0LWpzXCIpLEo9ZShcImllZWU3NTRcIik7bi5CdWZmZXI9cyxuLlNsb3dCdWZmZXI9ZnVuY3Rpb24oZSl7cmV0dXJuK2UhPWUmJihlPTApLHMuYWxsb2MoK2UpfSxuLklOU1BFQ1RfTUFYX0JZVEVTPTUwO24ua01heExlbmd0aD0yMTQ3NDgzNjQ3LHMuVFlQRURfQVJSQVlfU1VQUE9SVD1mdW5jdGlvbigpe3RyeXt2YXIgZT1uZXcgVWludDhBcnJheSgxKTtyZXR1cm4gZS5fX3Byb3RvX189e19fcHJvdG9fXzpVaW50OEFycmF5LnByb3RvdHlwZSxmb286ZnVuY3Rpb24oKXtyZXR1cm4gNDJ9fSw0Mj09PWUuZm9vKCl9Y2F0Y2godCl7cmV0dXJuITF9fSgpLHMuVFlQRURfQVJSQVlfU1VQUE9SVHx8XCJ1bmRlZmluZWRcIj09dHlwZW9mIGNvbnNvbGV8fFwiZnVuY3Rpb25cIiE9dHlwZW9mIGNvbnNvbGUuZXJyb3J8fGNvbnNvbGUuZXJyb3IoXCJUaGlzIGJyb3dzZXIgbGFja3MgdHlwZWQgYXJyYXkgKFVpbnQ4QXJyYXkpIHN1cHBvcnQgd2hpY2ggaXMgcmVxdWlyZWQgYnkgYGJ1ZmZlcmAgdjUueC4gVXNlIGBidWZmZXJgIHY0LnggaWYgeW91IHJlcXVpcmUgb2xkIGJyb3dzZXIgc3VwcG9ydC5cIiksT2JqZWN0LmRlZmluZVByb3BlcnR5KHMucHJvdG90eXBlLFwicGFyZW50XCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHMuaXNCdWZmZXIodGhpcyk/dGhpcy5idWZmZXI6dm9pZCAwfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzLnByb3RvdHlwZSxcIm9mZnNldFwiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBzLmlzQnVmZmVyKHRoaXMpP3RoaXMuYnl0ZU9mZnNldDp2b2lkIDB9fSksXCJ1bmRlZmluZWRcIiE9dHlwZW9mIFN5bWJvbCYmbnVsbCE9U3ltYm9sLnNwZWNpZXMmJnNbU3ltYm9sLnNwZWNpZXNdPT09cyYmT2JqZWN0LmRlZmluZVByb3BlcnR5KHMsU3ltYm9sLnNwZWNpZXMse3ZhbHVlOm51bGwsY29uZmlndXJhYmxlOiEwLGVudW1lcmFibGU6ITEsd3JpdGFibGU6ITF9KSxzLnBvb2xTaXplPTgxOTIscy5mcm9tPWZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gbChlLHQsbil9LHMucHJvdG90eXBlLl9fcHJvdG9fXz1VaW50OEFycmF5LnByb3RvdHlwZSxzLl9fcHJvdG9fXz1VaW50OEFycmF5LHMuYWxsb2M9ZnVuY3Rpb24oZSx0LG4pe3JldHVybiB1KGUsdCxuKX0scy5hbGxvY1Vuc2FmZT1mdW5jdGlvbihlKXtyZXR1cm4gcChlKX0scy5hbGxvY1Vuc2FmZVNsb3c9ZnVuY3Rpb24oZSl7cmV0dXJuIHAoZSl9LHMuaXNCdWZmZXI9ZnVuY3Rpb24oZSl7cmV0dXJuIG51bGwhPWUmJiEwPT09ZS5faXNCdWZmZXImJmUhPT1zLnByb3RvdHlwZX0scy5jb21wYXJlPWZ1bmN0aW9uKGUsdCl7aWYoSyhlLFVpbnQ4QXJyYXkpJiYoZT1zLmZyb20oZSxlLm9mZnNldCxlLmJ5dGVMZW5ndGgpKSxLKHQsVWludDhBcnJheSkmJih0PXMuZnJvbSh0LHQub2Zmc2V0LHQuYnl0ZUxlbmd0aCkpLCFzLmlzQnVmZmVyKGUpfHwhcy5pc0J1ZmZlcih0KSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiVGhlIFxcXCJidWYxXFxcIiwgXFxcImJ1ZjJcXFwiIGFyZ3VtZW50cyBtdXN0IGJlIG9uZSBvZiB0eXBlIEJ1ZmZlciBvciBVaW50OEFycmF5XCIpO2lmKGU9PT10KXJldHVybiAwO2Zvcih2YXIgbj1lLmxlbmd0aCxyPXQubGVuZ3RoLGQ9MCxsPW8obixyKTtkPGw7KytkKWlmKGVbZF0hPT10W2RdKXtuPWVbZF0scj10W2RdO2JyZWFrfXJldHVybiBuPHI/LTE6cjxuPzE6MH0scy5pc0VuY29kaW5nPWZ1bmN0aW9uKGUpe3N3aXRjaCgoZStcIlwiKS50b0xvd2VyQ2FzZSgpKXtjYXNlXCJoZXhcIjpjYXNlXCJ1dGY4XCI6Y2FzZVwidXRmLThcIjpjYXNlXCJhc2NpaVwiOmNhc2VcImxhdGluMVwiOmNhc2VcImJpbmFyeVwiOmNhc2VcImJhc2U2NFwiOmNhc2VcInVjczJcIjpjYXNlXCJ1Y3MtMlwiOmNhc2VcInV0ZjE2bGVcIjpjYXNlXCJ1dGYtMTZsZVwiOnJldHVybiEwO2RlZmF1bHQ6cmV0dXJuITE7fX0scy5jb25jYXQ9ZnVuY3Rpb24oZSx0KXtpZighQXJyYXkuaXNBcnJheShlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiXFxcImxpc3RcXFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVyc1wiKTtpZigwPT09ZS5sZW5ndGgpcmV0dXJuIHMuYWxsb2MoMCk7dmFyIG47aWYodD09PXZvaWQgMClmb3IodD0wLG49MDtuPGUubGVuZ3RoOysrbil0Kz1lW25dLmxlbmd0aDt2YXIgcj1zLmFsbG9jVW5zYWZlKHQpLGE9MDtmb3Iobj0wO248ZS5sZW5ndGg7KytuKXt2YXIgbz1lW25dO2lmKEsobyxVaW50OEFycmF5KSYmKG89cy5mcm9tKG8pKSwhcy5pc0J1ZmZlcihvKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiXFxcImxpc3RcXFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVyc1wiKTtvLmNvcHkocixhKSxhKz1vLmxlbmd0aH1yZXR1cm4gcn0scy5ieXRlTGVuZ3RoPWIscy5wcm90b3R5cGUuX2lzQnVmZmVyPSEwLHMucHJvdG90eXBlLnN3YXAxNj1mdW5jdGlvbigpe3ZhciBlPXRoaXMubGVuZ3RoO2lmKDAhPWUlMil0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkJ1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzXCIpO2Zvcih2YXIgdD0wO3Q8ZTt0Kz0yKUModGhpcyx0LHQrMSk7cmV0dXJuIHRoaXN9LHMucHJvdG90eXBlLnN3YXAzMj1mdW5jdGlvbigpe3ZhciBlPXRoaXMubGVuZ3RoO2lmKDAhPWUlNCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkJ1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAzMi1iaXRzXCIpO2Zvcih2YXIgdD0wO3Q8ZTt0Kz00KUModGhpcyx0LHQrMyksQyh0aGlzLHQrMSx0KzIpO3JldHVybiB0aGlzfSxzLnByb3RvdHlwZS5zd2FwNjQ9ZnVuY3Rpb24oKXt2YXIgZT10aGlzLmxlbmd0aDtpZigwIT1lJTgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNjQtYml0c1wiKTtmb3IodmFyIHQ9MDt0PGU7dCs9OClDKHRoaXMsdCx0KzcpLEModGhpcyx0KzEsdCs2KSxDKHRoaXMsdCsyLHQrNSksQyh0aGlzLHQrMyx0KzQpO3JldHVybiB0aGlzfSxzLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbigpe3ZhciBlPXRoaXMubGVuZ3RoO3JldHVybiAwPT09ZT9cIlwiOjA9PT1hcmd1bWVudHMubGVuZ3RoP3godGhpcywwLGUpOnkuYXBwbHkodGhpcyxhcmd1bWVudHMpfSxzLnByb3RvdHlwZS50b0xvY2FsZVN0cmluZz1zLnByb3RvdHlwZS50b1N0cmluZyxzLnByb3RvdHlwZS5lcXVhbHM9ZnVuY3Rpb24oZSl7aWYoIXMuaXNCdWZmZXIoZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXJcIik7cmV0dXJuIHRoaXM9PT1lfHwwPT09cy5jb21wYXJlKHRoaXMsZSl9LHMucHJvdG90eXBlLmluc3BlY3Q9ZnVuY3Rpb24oKXt2YXIgZT1cIlwiLHQ9bi5JTlNQRUNUX01BWF9CWVRFUztyZXR1cm4gZT10aGlzLnRvU3RyaW5nKFwiaGV4XCIsMCx0KS5yZXBsYWNlKC8oLnsyfSkvZyxcIiQxIFwiKS50cmltKCksdGhpcy5sZW5ndGg+dCYmKGUrPVwiIC4uLiBcIiksXCI8QnVmZmVyIFwiK2UrXCI+XCJ9LHMucHJvdG90eXBlLmNvbXBhcmU9ZnVuY3Rpb24oZSx0LG4scixhKXtpZihLKGUsVWludDhBcnJheSkmJihlPXMuZnJvbShlLGUub2Zmc2V0LGUuYnl0ZUxlbmd0aCkpLCFzLmlzQnVmZmVyKGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJUaGUgXFxcInRhcmdldFxcXCIgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBCdWZmZXIgb3IgVWludDhBcnJheS4gUmVjZWl2ZWQgdHlwZSBcIit0eXBlb2YgZSk7aWYodm9pZCAwPT09dCYmKHQ9MCksdm9pZCAwPT09biYmKG49ZT9lLmxlbmd0aDowKSx2b2lkIDA9PT1yJiYocj0wKSx2b2lkIDA9PT1hJiYoYT10aGlzLmxlbmd0aCksMD50fHxuPmUubGVuZ3RofHwwPnJ8fGE+dGhpcy5sZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJvdXQgb2YgcmFuZ2UgaW5kZXhcIik7aWYocj49YSYmdD49bilyZXR1cm4gMDtpZihyPj1hKXJldHVybi0xO2lmKHQ+PW4pcmV0dXJuIDE7aWYodD4+Pj0wLG4+Pj49MCxyPj4+PTAsYT4+Pj0wLHRoaXM9PT1lKXJldHVybiAwO2Zvcih2YXIgZD1hLXIsbD1uLXQsYz1vKGQsbCksdT10aGlzLnNsaWNlKHIsYSkscD1lLnNsaWNlKHQsbiksZj0wO2Y8YzsrK2YpaWYodVtmXSE9PXBbZl0pe2Q9dVtmXSxsPXBbZl07YnJlYWt9cmV0dXJuIGQ8bD8tMTpsPGQ/MTowfSxzLnByb3RvdHlwZS5pbmNsdWRlcz1mdW5jdGlvbihlLHQsbil7cmV0dXJuLTEhPT10aGlzLmluZGV4T2YoZSx0LG4pfSxzLnByb3RvdHlwZS5pbmRleE9mPWZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gUih0aGlzLGUsdCxuLCEwKX0scy5wcm90b3R5cGUubGFzdEluZGV4T2Y9ZnVuY3Rpb24oZSx0LG4pe3JldHVybiBSKHRoaXMsZSx0LG4sITEpfSxzLnByb3RvdHlwZS53cml0ZT1mdW5jdGlvbihlLHQsbixyKXtpZih2b2lkIDA9PT10KXI9XCJ1dGY4XCIsbj10aGlzLmxlbmd0aCx0PTA7ZWxzZSBpZih2b2lkIDA9PT1uJiZcInN0cmluZ1wiPT10eXBlb2YgdClyPXQsbj10aGlzLmxlbmd0aCx0PTA7ZWxzZSBpZihpc0Zpbml0ZSh0KSl0Pj4+PTAsaXNGaW5pdGUobik/KG4+Pj49MCx2b2lkIDA9PT1yJiYocj1cInV0ZjhcIikpOihyPW4sbj12b2lkIDApO2Vsc2UgdGhyb3cgbmV3IEVycm9yKFwiQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWRcIik7dmFyIGE9dGhpcy5sZW5ndGgtdDtpZigodm9pZCAwPT09bnx8bj5hKSYmKG49YSksMDxlLmxlbmd0aCYmKDA+bnx8MD50KXx8dD50aGlzLmxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkF0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzXCIpO3J8fChyPVwidXRmOFwiKTtmb3IodmFyIG89ITE7Oylzd2l0Y2gocil7Y2FzZVwiaGV4XCI6cmV0dXJuIHcodGhpcyxlLHQsbik7Y2FzZVwidXRmOFwiOmNhc2VcInV0Zi04XCI6cmV0dXJuIFModGhpcyxlLHQsbik7Y2FzZVwiYXNjaWlcIjpyZXR1cm4gVCh0aGlzLGUsdCxuKTtjYXNlXCJsYXRpbjFcIjpjYXNlXCJiaW5hcnlcIjpyZXR1cm4gdih0aGlzLGUsdCxuKTtjYXNlXCJiYXNlNjRcIjpyZXR1cm4gayh0aGlzLGUsdCxuKTtjYXNlXCJ1Y3MyXCI6Y2FzZVwidWNzLTJcIjpjYXNlXCJ1dGYxNmxlXCI6Y2FzZVwidXRmLTE2bGVcIjpyZXR1cm4gTCh0aGlzLGUsdCxuKTtkZWZhdWx0OmlmKG8pdGhyb3cgbmV3IFR5cGVFcnJvcihcIlVua25vd24gZW5jb2Rpbmc6IFwiK3IpO3I9KFwiXCIrcikudG9Mb3dlckNhc2UoKSxvPSEwO319LHMucHJvdG90eXBlLnRvSlNPTj1mdW5jdGlvbigpe3JldHVybnt0eXBlOlwiQnVmZmVyXCIsZGF0YTpBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnJ8fHRoaXMsMCl9fTtzLnByb3RvdHlwZS5zbGljZT1mdW5jdGlvbihlLHQpe3ZhciBuPXRoaXMubGVuZ3RoO2U9fn5lLHQ9dD09PXZvaWQgMD9uOn5+dCwwPmU/KGUrPW4sMD5lJiYoZT0wKSk6ZT5uJiYoZT1uKSwwPnQ/KHQrPW4sMD50JiYodD0wKSk6dD5uJiYodD1uKSx0PGUmJih0PWUpO3ZhciByPXRoaXMuc3ViYXJyYXkoZSx0KTtyZXR1cm4gci5fX3Byb3RvX189cy5wcm90b3R5cGUscn0scy5wcm90b3R5cGUucmVhZFVJbnRMRT1mdW5jdGlvbihlLHQsbil7ZT4+Pj0wLHQ+Pj49MCxufHxPKGUsdCx0aGlzLmxlbmd0aCk7Zm9yKHZhciByPXRoaXNbZV0sYT0xLG89MDsrK288dCYmKGEqPTI1Nik7KXIrPXRoaXNbZStvXSphO3JldHVybiByfSxzLnByb3RvdHlwZS5yZWFkVUludEJFPWZ1bmN0aW9uKGUsdCxuKXtlPj4+PTAsdD4+Pj0wLG58fE8oZSx0LHRoaXMubGVuZ3RoKTtmb3IodmFyIHI9dGhpc1tlKy0tdF0sYT0xOzA8dCYmKGEqPTI1Nik7KXIrPXRoaXNbZSstLXRdKmE7cmV0dXJuIHJ9LHMucHJvdG90eXBlLnJlYWRVSW50OD1mdW5jdGlvbihlLHQpe3JldHVybiBlPj4+PTAsdHx8TyhlLDEsdGhpcy5sZW5ndGgpLHRoaXNbZV19LHMucHJvdG90eXBlLnJlYWRVSW50MTZMRT1mdW5jdGlvbihlLHQpe3JldHVybiBlPj4+PTAsdHx8TyhlLDIsdGhpcy5sZW5ndGgpLHRoaXNbZV18dGhpc1tlKzFdPDw4fSxzLnByb3RvdHlwZS5yZWFkVUludDE2QkU9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZT4+Pj0wLHR8fE8oZSwyLHRoaXMubGVuZ3RoKSx0aGlzW2VdPDw4fHRoaXNbZSsxXX0scy5wcm90b3R5cGUucmVhZFVJbnQzMkxFPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGU+Pj49MCx0fHxPKGUsNCx0aGlzLmxlbmd0aCksKHRoaXNbZV18dGhpc1tlKzFdPDw4fHRoaXNbZSsyXTw8MTYpKzE2Nzc3MjE2KnRoaXNbZSszXX0scy5wcm90b3R5cGUucmVhZFVJbnQzMkJFPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGU+Pj49MCx0fHxPKGUsNCx0aGlzLmxlbmd0aCksMTY3NzcyMTYqdGhpc1tlXSsodGhpc1tlKzFdPDwxNnx0aGlzW2UrMl08PDh8dGhpc1tlKzNdKX0scy5wcm90b3R5cGUucmVhZEludExFPWZ1bmN0aW9uKGUsdCxuKXtlPj4+PTAsdD4+Pj0wLG58fE8oZSx0LHRoaXMubGVuZ3RoKTtmb3IodmFyIGE9dGhpc1tlXSxvPTEsZD0wOysrZDx0JiYobyo9MjU2KTspYSs9dGhpc1tlK2RdKm87cmV0dXJuIG8qPTEyOCxhPj1vJiYoYS09cigyLDgqdCkpLGF9LHMucHJvdG90eXBlLnJlYWRJbnRCRT1mdW5jdGlvbihlLHQsbil7ZT4+Pj0wLHQ+Pj49MCxufHxPKGUsdCx0aGlzLmxlbmd0aCk7Zm9yKHZhciBhPXQsbz0xLGQ9dGhpc1tlKy0tYV07MDxhJiYobyo9MjU2KTspZCs9dGhpc1tlKy0tYV0qbztyZXR1cm4gbyo9MTI4LGQ+PW8mJihkLT1yKDIsOCp0KSksZH0scy5wcm90b3R5cGUucmVhZEludDg9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZT4+Pj0wLHR8fE8oZSwxLHRoaXMubGVuZ3RoKSwxMjgmdGhpc1tlXT8tMSooMjU1LXRoaXNbZV0rMSk6dGhpc1tlXX0scy5wcm90b3R5cGUucmVhZEludDE2TEU9ZnVuY3Rpb24oZSx0KXtlPj4+PTAsdHx8TyhlLDIsdGhpcy5sZW5ndGgpO3ZhciBuPXRoaXNbZV18dGhpc1tlKzFdPDw4O3JldHVybiAzMjc2OCZuPzQyOTQ5MDE3NjB8bjpufSxzLnByb3RvdHlwZS5yZWFkSW50MTZCRT1mdW5jdGlvbihlLHQpe2U+Pj49MCx0fHxPKGUsMix0aGlzLmxlbmd0aCk7dmFyIG49dGhpc1tlKzFdfHRoaXNbZV08PDg7cmV0dXJuIDMyNzY4Jm4/NDI5NDkwMTc2MHxuOm59LHMucHJvdG90eXBlLnJlYWRJbnQzMkxFPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGU+Pj49MCx0fHxPKGUsNCx0aGlzLmxlbmd0aCksdGhpc1tlXXx0aGlzW2UrMV08PDh8dGhpc1tlKzJdPDwxNnx0aGlzW2UrM108PDI0fSxzLnByb3RvdHlwZS5yZWFkSW50MzJCRT1mdW5jdGlvbihlLHQpe3JldHVybiBlPj4+PTAsdHx8TyhlLDQsdGhpcy5sZW5ndGgpLHRoaXNbZV08PDI0fHRoaXNbZSsxXTw8MTZ8dGhpc1tlKzJdPDw4fHRoaXNbZSszXX0scy5wcm90b3R5cGUucmVhZEZsb2F0TEU9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZT4+Pj0wLHR8fE8oZSw0LHRoaXMubGVuZ3RoKSxKLnJlYWQodGhpcyxlLCEwLDIzLDQpfSxzLnByb3RvdHlwZS5yZWFkRmxvYXRCRT1mdW5jdGlvbihlLHQpe3JldHVybiBlPj4+PTAsdHx8TyhlLDQsdGhpcy5sZW5ndGgpLEoucmVhZCh0aGlzLGUsITEsMjMsNCl9LHMucHJvdG90eXBlLnJlYWREb3VibGVMRT1mdW5jdGlvbihlLHQpe3JldHVybiBlPj4+PTAsdHx8TyhlLDgsdGhpcy5sZW5ndGgpLEoucmVhZCh0aGlzLGUsITAsNTIsOCl9LHMucHJvdG90eXBlLnJlYWREb3VibGVCRT1mdW5jdGlvbihlLHQpe3JldHVybiBlPj4+PTAsdHx8TyhlLDgsdGhpcy5sZW5ndGgpLEoucmVhZCh0aGlzLGUsITEsNTIsOCl9LHMucHJvdG90eXBlLndyaXRlVUludExFPWZ1bmN0aW9uKGUsdCxuLGEpe2lmKGU9K2UsdD4+Pj0wLG4+Pj49MCwhYSl7dmFyIG89cigyLDgqbiktMTtGKHRoaXMsZSx0LG4sbywwKX12YXIgZD0xLHM9MDtmb3IodGhpc1t0XT0yNTUmZTsrK3M8biYmKGQqPTI1Nik7KXRoaXNbdCtzXT0yNTUmZS9kO3JldHVybiB0K259LHMucHJvdG90eXBlLndyaXRlVUludEJFPWZ1bmN0aW9uKGUsdCxuLGEpe2lmKGU9K2UsdD4+Pj0wLG4+Pj49MCwhYSl7dmFyIG89cigyLDgqbiktMTtGKHRoaXMsZSx0LG4sbywwKX12YXIgZD1uLTEscz0xO2Zvcih0aGlzW3QrZF09MjU1JmU7MDw9LS1kJiYocyo9MjU2KTspdGhpc1t0K2RdPTI1NSZlL3M7cmV0dXJuIHQrbn0scy5wcm90b3R5cGUud3JpdGVVSW50OD1mdW5jdGlvbihlLHQsbil7cmV0dXJuIGU9K2UsdD4+Pj0wLG58fEYodGhpcyxlLHQsMSwyNTUsMCksdGhpc1t0XT0yNTUmZSx0KzF9LHMucHJvdG90eXBlLndyaXRlVUludDE2TEU9ZnVuY3Rpb24oZSx0LG4pe3JldHVybiBlPStlLHQ+Pj49MCxufHxGKHRoaXMsZSx0LDIsNjU1MzUsMCksdGhpc1t0XT0yNTUmZSx0aGlzW3QrMV09ZT4+PjgsdCsyfSxzLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFPWZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gZT0rZSx0Pj4+PTAsbnx8Rih0aGlzLGUsdCwyLDY1NTM1LDApLHRoaXNbdF09ZT4+PjgsdGhpc1t0KzFdPTI1NSZlLHQrMn0scy5wcm90b3R5cGUud3JpdGVVSW50MzJMRT1mdW5jdGlvbihlLHQsbil7cmV0dXJuIGU9K2UsdD4+Pj0wLG58fEYodGhpcyxlLHQsNCw0Mjk0OTY3Mjk1LDApLHRoaXNbdCszXT1lPj4+MjQsdGhpc1t0KzJdPWU+Pj4xNix0aGlzW3QrMV09ZT4+PjgsdGhpc1t0XT0yNTUmZSx0KzR9LHMucHJvdG90eXBlLndyaXRlVUludDMyQkU9ZnVuY3Rpb24oZSx0LG4pe3JldHVybiBlPStlLHQ+Pj49MCxufHxGKHRoaXMsZSx0LDQsNDI5NDk2NzI5NSwwKSx0aGlzW3RdPWU+Pj4yNCx0aGlzW3QrMV09ZT4+PjE2LHRoaXNbdCsyXT1lPj4+OCx0aGlzW3QrM109MjU1JmUsdCs0fSxzLnByb3RvdHlwZS53cml0ZUludExFPWZ1bmN0aW9uKGUsdCxuLGEpe2lmKGU9K2UsdD4+Pj0wLCFhKXt2YXIgbz1yKDIsOCpuLTEpO0YodGhpcyxlLHQsbixvLTEsLW8pfXZhciBkPTAscz0xLGw9MDtmb3IodGhpc1t0XT0yNTUmZTsrK2Q8biYmKHMqPTI1Nik7KTA+ZSYmMD09PWwmJjAhPT10aGlzW3QrZC0xXSYmKGw9MSksdGhpc1t0K2RdPTI1NSYoZS9zPj4wKS1sO3JldHVybiB0K259LHMucHJvdG90eXBlLndyaXRlSW50QkU9ZnVuY3Rpb24oZSx0LG4sYSl7aWYoZT0rZSx0Pj4+PTAsIWEpe3ZhciBvPXIoMiw4Km4tMSk7Rih0aGlzLGUsdCxuLG8tMSwtbyl9dmFyIGQ9bi0xLHM9MSxsPTA7Zm9yKHRoaXNbdCtkXT0yNTUmZTswPD0tLWQmJihzKj0yNTYpOykwPmUmJjA9PT1sJiYwIT09dGhpc1t0K2QrMV0mJihsPTEpLHRoaXNbdCtkXT0yNTUmKGUvcz4+MCktbDtyZXR1cm4gdCtufSxzLnByb3RvdHlwZS53cml0ZUludDg9ZnVuY3Rpb24oZSx0LG4pe3JldHVybiBlPStlLHQ+Pj49MCxufHxGKHRoaXMsZSx0LDEsMTI3LC0xMjgpLDA+ZSYmKGU9MjU1K2UrMSksdGhpc1t0XT0yNTUmZSx0KzF9LHMucHJvdG90eXBlLndyaXRlSW50MTZMRT1mdW5jdGlvbihlLHQsbil7cmV0dXJuIGU9K2UsdD4+Pj0wLG58fEYodGhpcyxlLHQsMiwzMjc2NywtMzI3NjgpLHRoaXNbdF09MjU1JmUsdGhpc1t0KzFdPWU+Pj44LHQrMn0scy5wcm90b3R5cGUud3JpdGVJbnQxNkJFPWZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gZT0rZSx0Pj4+PTAsbnx8Rih0aGlzLGUsdCwyLDMyNzY3LC0zMjc2OCksdGhpc1t0XT1lPj4+OCx0aGlzW3QrMV09MjU1JmUsdCsyfSxzLnByb3RvdHlwZS53cml0ZUludDMyTEU9ZnVuY3Rpb24oZSx0LG4pe3JldHVybiBlPStlLHQ+Pj49MCxufHxGKHRoaXMsZSx0LDQsMjE0NzQ4MzY0NywtMjE0NzQ4MzY0OCksdGhpc1t0XT0yNTUmZSx0aGlzW3QrMV09ZT4+PjgsdGhpc1t0KzJdPWU+Pj4xNix0aGlzW3QrM109ZT4+PjI0LHQrNH0scy5wcm90b3R5cGUud3JpdGVJbnQzMkJFPWZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gZT0rZSx0Pj4+PTAsbnx8Rih0aGlzLGUsdCw0LDIxNDc0ODM2NDcsLTIxNDc0ODM2NDgpLDA+ZSYmKGU9NDI5NDk2NzI5NStlKzEpLHRoaXNbdF09ZT4+PjI0LHRoaXNbdCsxXT1lPj4+MTYsdGhpc1t0KzJdPWU+Pj44LHRoaXNbdCszXT0yNTUmZSx0KzR9LHMucHJvdG90eXBlLndyaXRlRmxvYXRMRT1mdW5jdGlvbihlLHQsbil7cmV0dXJuIFUodGhpcyxlLHQsITAsbil9LHMucHJvdG90eXBlLndyaXRlRmxvYXRCRT1mdW5jdGlvbihlLHQsbil7cmV0dXJuIFUodGhpcyxlLHQsITEsbil9LHMucHJvdG90eXBlLndyaXRlRG91YmxlTEU9ZnVuY3Rpb24oZSx0LG4pe3JldHVybiBqKHRoaXMsZSx0LCEwLG4pfSxzLnByb3RvdHlwZS53cml0ZURvdWJsZUJFPWZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gaih0aGlzLGUsdCwhMSxuKX0scy5wcm90b3R5cGUuY29weT1mdW5jdGlvbihlLHQsbixyKXtpZighcy5pc0J1ZmZlcihlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiYXJndW1lbnQgc2hvdWxkIGJlIGEgQnVmZmVyXCIpO2lmKG58fChuPTApLHJ8fDA9PT1yfHwocj10aGlzLmxlbmd0aCksdD49ZS5sZW5ndGgmJih0PWUubGVuZ3RoKSx0fHwodD0wKSwwPHImJnI8biYmKHI9bikscj09PW4pcmV0dXJuIDA7aWYoMD09PWUubGVuZ3RofHwwPT09dGhpcy5sZW5ndGgpcmV0dXJuIDA7aWYoMD50KXRocm93IG5ldyBSYW5nZUVycm9yKFwidGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kc1wiKTtpZigwPm58fG4+PXRoaXMubGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKFwiSW5kZXggb3V0IG9mIHJhbmdlXCIpO2lmKDA+cil0aHJvdyBuZXcgUmFuZ2VFcnJvcihcInNvdXJjZUVuZCBvdXQgb2YgYm91bmRzXCIpO3I+dGhpcy5sZW5ndGgmJihyPXRoaXMubGVuZ3RoKSxlLmxlbmd0aC10PHItbiYmKHI9ZS5sZW5ndGgtdCtuKTt2YXIgYT1yLW47aWYodGhpcz09PWUmJlwiZnVuY3Rpb25cIj09dHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmNvcHlXaXRoaW4pdGhpcy5jb3B5V2l0aGluKHQsbixyKTtlbHNlIGlmKHRoaXM9PT1lJiZuPHQmJnQ8cilmb3IodmFyIG89YS0xOzA8PW87LS1vKWVbbyt0XT10aGlzW28rbl07ZWxzZSBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChlLHRoaXMuc3ViYXJyYXkobixyKSx0KTtyZXR1cm4gYX0scy5wcm90b3R5cGUuZmlsbD1mdW5jdGlvbihlLHQsbixyKXtpZihcInN0cmluZ1wiPT10eXBlb2YgZSl7aWYoXCJzdHJpbmdcIj09dHlwZW9mIHQ/KHI9dCx0PTAsbj10aGlzLmxlbmd0aCk6XCJzdHJpbmdcIj09dHlwZW9mIG4mJihyPW4sbj10aGlzLmxlbmd0aCksdm9pZCAwIT09ciYmXCJzdHJpbmdcIiE9dHlwZW9mIHIpdGhyb3cgbmV3IFR5cGVFcnJvcihcImVuY29kaW5nIG11c3QgYmUgYSBzdHJpbmdcIik7aWYoXCJzdHJpbmdcIj09dHlwZW9mIHImJiFzLmlzRW5jb2RpbmcocikpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlVua25vd24gZW5jb2Rpbmc6IFwiK3IpO2lmKDE9PT1lLmxlbmd0aCl7dmFyIGE9ZS5jaGFyQ29kZUF0KDApOyhcInV0ZjhcIj09PXImJjEyOD5hfHxcImxhdGluMVwiPT09cikmJihlPWEpfX1lbHNlXCJudW1iZXJcIj09dHlwZW9mIGUmJihlJj0yNTUpO2lmKDA+dHx8dGhpcy5sZW5ndGg8dHx8dGhpcy5sZW5ndGg8bil0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk91dCBvZiByYW5nZSBpbmRleFwiKTtpZihuPD10KXJldHVybiB0aGlzO3Q+Pj49MCxuPW49PT12b2lkIDA/dGhpcy5sZW5ndGg6bj4+PjAsZXx8KGU9MCk7dmFyIG87aWYoXCJudW1iZXJcIj09dHlwZW9mIGUpZm9yKG89dDtvPG47KytvKXRoaXNbb109ZTtlbHNle3ZhciBkPXMuaXNCdWZmZXIoZSk/ZTpzLmZyb20oZSxyKSxsPWQubGVuZ3RoO2lmKDA9PT1sKXRocm93IG5ldyBUeXBlRXJyb3IoXCJUaGUgdmFsdWUgXFxcIlwiK2UrXCJcXFwiIGlzIGludmFsaWQgZm9yIGFyZ3VtZW50IFxcXCJ2YWx1ZVxcXCJcIik7Zm9yKG89MDtvPG4tdDsrK28pdGhpc1tvK3RdPWRbbyVsXX1yZXR1cm4gdGhpc307dmFyIFE9L1teKy8wLTlBLVphLXotX10vZ30pLmNhbGwodGhpcyl9KS5jYWxsKHRoaXMsZShcImJ1ZmZlclwiKS5CdWZmZXIpfSx7XCJiYXNlNjQtanNcIjoxLGJ1ZmZlcjozLGllZWU3NTQ6OX1dLDQ6W2Z1bmN0aW9uKGUsdCxuKXsoZnVuY3Rpb24oYSl7KGZ1bmN0aW9uKCl7ZnVuY3Rpb24gcigpe2xldCBlO3RyeXtlPW4uc3RvcmFnZS5nZXRJdGVtKFwiZGVidWdcIil9Y2F0Y2goZSl7fXJldHVybiFlJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgYSYmXCJlbnZcImluIGEmJihlPWEuZW52LkRFQlVHKSxlfW4uZm9ybWF0QXJncz1mdW5jdGlvbihlKXtpZihlWzBdPSh0aGlzLnVzZUNvbG9ycz9cIiVjXCI6XCJcIikrdGhpcy5uYW1lc3BhY2UrKHRoaXMudXNlQ29sb3JzP1wiICVjXCI6XCIgXCIpK2VbMF0rKHRoaXMudXNlQ29sb3JzP1wiJWMgXCI6XCIgXCIpK1wiK1wiK3QuZXhwb3J0cy5odW1hbml6ZSh0aGlzLmRpZmYpLCF0aGlzLnVzZUNvbG9ycylyZXR1cm47Y29uc3Qgbj1cImNvbG9yOiBcIit0aGlzLmNvbG9yO2Uuc3BsaWNlKDEsMCxuLFwiY29sb3I6IGluaGVyaXRcIik7bGV0IHI9MCxhPTA7ZVswXS5yZXBsYWNlKC8lW2EtekEtWiVdL2csZT0+e1wiJSVcIj09PWV8fChyKyssXCIlY1wiPT09ZSYmKGE9cikpfSksZS5zcGxpY2UoYSwwLG4pfSxuLnNhdmU9ZnVuY3Rpb24oZSl7dHJ5e2U/bi5zdG9yYWdlLnNldEl0ZW0oXCJkZWJ1Z1wiLGUpOm4uc3RvcmFnZS5yZW1vdmVJdGVtKFwiZGVidWdcIil9Y2F0Y2goZSl7fX0sbi5sb2FkPXIsbi51c2VDb2xvcnM9ZnVuY3Rpb24oKXtyZXR1cm4hIShcInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93JiZ3aW5kb3cucHJvY2VzcyYmKFwicmVuZGVyZXJcIj09PXdpbmRvdy5wcm9jZXNzLnR5cGV8fHdpbmRvdy5wcm9jZXNzLl9fbndqcykpfHwhKFwidW5kZWZpbmVkXCIhPXR5cGVvZiBuYXZpZ2F0b3ImJm5hdmlnYXRvci51c2VyQWdlbnQmJm5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvKGVkZ2V8dHJpZGVudClcXC8oXFxkKykvKSkmJihcInVuZGVmaW5lZFwiIT10eXBlb2YgZG9jdW1lbnQmJmRvY3VtZW50LmRvY3VtZW50RWxlbWVudCYmZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlJiZkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUuV2Via2l0QXBwZWFyYW5jZXx8XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdyYmd2luZG93LmNvbnNvbGUmJih3aW5kb3cuY29uc29sZS5maXJlYnVnfHx3aW5kb3cuY29uc29sZS5leGNlcHRpb24mJndpbmRvdy5jb25zb2xlLnRhYmxlKXx8XCJ1bmRlZmluZWRcIiE9dHlwZW9mIG5hdmlnYXRvciYmbmF2aWdhdG9yLnVzZXJBZ2VudCYmbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9maXJlZm94XFwvKFxcZCspLykmJjMxPD1wYXJzZUludChSZWdFeHAuJDEsMTApfHxcInVuZGVmaW5lZFwiIT10eXBlb2YgbmF2aWdhdG9yJiZuYXZpZ2F0b3IudXNlckFnZW50JiZuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2FwcGxld2Via2l0XFwvKFxcZCspLykpfSxuLnN0b3JhZ2U9ZnVuY3Rpb24oKXt0cnl7cmV0dXJuIGxvY2FsU3RvcmFnZX1jYXRjaChlKXt9fSgpLG4uZGVzdHJveT0oKCk9PntsZXQgZT0hMTtyZXR1cm4oKT0+e2V8fChlPSEwLGNvbnNvbGUud2FybihcIkluc3RhbmNlIG1ldGhvZCBgZGVidWcuZGVzdHJveSgpYCBpcyBkZXByZWNhdGVkIGFuZCBubyBsb25nZXIgZG9lcyBhbnl0aGluZy4gSXQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24gb2YgYGRlYnVnYC5cIikpfX0pKCksbi5jb2xvcnM9W1wiIzAwMDBDQ1wiLFwiIzAwMDBGRlwiLFwiIzAwMzNDQ1wiLFwiIzAwMzNGRlwiLFwiIzAwNjZDQ1wiLFwiIzAwNjZGRlwiLFwiIzAwOTlDQ1wiLFwiIzAwOTlGRlwiLFwiIzAwQ0MwMFwiLFwiIzAwQ0MzM1wiLFwiIzAwQ0M2NlwiLFwiIzAwQ0M5OVwiLFwiIzAwQ0NDQ1wiLFwiIzAwQ0NGRlwiLFwiIzMzMDBDQ1wiLFwiIzMzMDBGRlwiLFwiIzMzMzNDQ1wiLFwiIzMzMzNGRlwiLFwiIzMzNjZDQ1wiLFwiIzMzNjZGRlwiLFwiIzMzOTlDQ1wiLFwiIzMzOTlGRlwiLFwiIzMzQ0MwMFwiLFwiIzMzQ0MzM1wiLFwiIzMzQ0M2NlwiLFwiIzMzQ0M5OVwiLFwiIzMzQ0NDQ1wiLFwiIzMzQ0NGRlwiLFwiIzY2MDBDQ1wiLFwiIzY2MDBGRlwiLFwiIzY2MzNDQ1wiLFwiIzY2MzNGRlwiLFwiIzY2Q0MwMFwiLFwiIzY2Q0MzM1wiLFwiIzk5MDBDQ1wiLFwiIzk5MDBGRlwiLFwiIzk5MzNDQ1wiLFwiIzk5MzNGRlwiLFwiIzk5Q0MwMFwiLFwiIzk5Q0MzM1wiLFwiI0NDMDAwMFwiLFwiI0NDMDAzM1wiLFwiI0NDMDA2NlwiLFwiI0NDMDA5OVwiLFwiI0NDMDBDQ1wiLFwiI0NDMDBGRlwiLFwiI0NDMzMwMFwiLFwiI0NDMzMzM1wiLFwiI0NDMzM2NlwiLFwiI0NDMzM5OVwiLFwiI0NDMzNDQ1wiLFwiI0NDMzNGRlwiLFwiI0NDNjYwMFwiLFwiI0NDNjYzM1wiLFwiI0NDOTkwMFwiLFwiI0NDOTkzM1wiLFwiI0NDQ0MwMFwiLFwiI0NDQ0MzM1wiLFwiI0ZGMDAwMFwiLFwiI0ZGMDAzM1wiLFwiI0ZGMDA2NlwiLFwiI0ZGMDA5OVwiLFwiI0ZGMDBDQ1wiLFwiI0ZGMDBGRlwiLFwiI0ZGMzMwMFwiLFwiI0ZGMzMzM1wiLFwiI0ZGMzM2NlwiLFwiI0ZGMzM5OVwiLFwiI0ZGMzNDQ1wiLFwiI0ZGMzNGRlwiLFwiI0ZGNjYwMFwiLFwiI0ZGNjYzM1wiLFwiI0ZGOTkwMFwiLFwiI0ZGOTkzM1wiLFwiI0ZGQ0MwMFwiLFwiI0ZGQ0MzM1wiXSxuLmxvZz1jb25zb2xlLmRlYnVnfHxjb25zb2xlLmxvZ3x8KCgpPT57fSksdC5leHBvcnRzPWUoXCIuL2NvbW1vblwiKShuKTtjb25zdHtmb3JtYXR0ZXJzOm99PXQuZXhwb3J0cztvLmo9ZnVuY3Rpb24oZSl7dHJ5e3JldHVybiBKU09OLnN0cmluZ2lmeShlKX1jYXRjaChlKXtyZXR1cm5cIltVbmV4cGVjdGVkSlNPTlBhcnNlRXJyb3JdOiBcIitlLm1lc3NhZ2V9fX0pLmNhbGwodGhpcyl9KS5jYWxsKHRoaXMsZShcIl9wcm9jZXNzXCIpKX0se1wiLi9jb21tb25cIjo1LF9wcm9jZXNzOjEyfV0sNTpbZnVuY3Rpb24oZSx0KXt0LmV4cG9ydHM9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gcihlKXtmdW5jdGlvbiB0KC4uLmUpe2lmKCF0LmVuYWJsZWQpcmV0dXJuO2NvbnN0IGE9dCxvPStuZXcgRGF0ZSxpPW8tKG58fG8pO2EuZGlmZj1pLGEucHJldj1uLGEuY3Vycj1vLG49byxlWzBdPXIuY29lcmNlKGVbMF0pLFwic3RyaW5nXCIhPXR5cGVvZiBlWzBdJiZlLnVuc2hpZnQoXCIlT1wiKTtsZXQgZD0wO2VbMF09ZVswXS5yZXBsYWNlKC8lKFthLXpBLVolXSkvZywodCxuKT0+e2lmKFwiJSVcIj09PXQpcmV0dXJuXCIlXCI7ZCsrO2NvbnN0IG89ci5mb3JtYXR0ZXJzW25dO2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIG8pe2NvbnN0IG49ZVtkXTt0PW8uY2FsbChhLG4pLGUuc3BsaWNlKGQsMSksZC0tfXJldHVybiB0fSksci5mb3JtYXRBcmdzLmNhbGwoYSxlKTtjb25zdCBzPWEubG9nfHxyLmxvZztzLmFwcGx5KGEsZSl9bGV0IG4sbz1udWxsO3JldHVybiB0Lm5hbWVzcGFjZT1lLHQudXNlQ29sb3JzPXIudXNlQ29sb3JzKCksdC5jb2xvcj1yLnNlbGVjdENvbG9yKGUpLHQuZXh0ZW5kPWEsdC5kZXN0cm95PXIuZGVzdHJveSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcImVuYWJsZWRcIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITEsZ2V0OigpPT5udWxsPT09bz9yLmVuYWJsZWQoZSk6byxzZXQ6ZT0+e289ZX19KSxcImZ1bmN0aW9uXCI9PXR5cGVvZiByLmluaXQmJnIuaW5pdCh0KSx0fWZ1bmN0aW9uIGEoZSx0KXtjb25zdCBuPXIodGhpcy5uYW1lc3BhY2UrKFwidW5kZWZpbmVkXCI9PXR5cGVvZiB0P1wiOlwiOnQpK2UpO3JldHVybiBuLmxvZz10aGlzLmxvZyxufWZ1bmN0aW9uIG8oZSl7cmV0dXJuIGUudG9TdHJpbmcoKS5zdWJzdHJpbmcoMixlLnRvU3RyaW5nKCkubGVuZ3RoLTIpLnJlcGxhY2UoL1xcLlxcKlxcPyQvLFwiKlwiKX1yZXR1cm4gci5kZWJ1Zz1yLHIuZGVmYXVsdD1yLHIuY29lcmNlPWZ1bmN0aW9uKGUpe3JldHVybiBlIGluc3RhbmNlb2YgRXJyb3I/ZS5zdGFja3x8ZS5tZXNzYWdlOmV9LHIuZGlzYWJsZT1mdW5jdGlvbigpe2NvbnN0IGU9Wy4uLnIubmFtZXMubWFwKG8pLC4uLnIuc2tpcHMubWFwKG8pLm1hcChlPT5cIi1cIitlKV0uam9pbihcIixcIik7cmV0dXJuIHIuZW5hYmxlKFwiXCIpLGV9LHIuZW5hYmxlPWZ1bmN0aW9uKGUpe3Iuc2F2ZShlKSxyLm5hbWVzPVtdLHIuc2tpcHM9W107bGV0IHQ7Y29uc3Qgbj0oXCJzdHJpbmdcIj09dHlwZW9mIGU/ZTpcIlwiKS5zcGxpdCgvW1xccyxdKy8pLGE9bi5sZW5ndGg7Zm9yKHQ9MDt0PGE7dCsrKW5bdF0mJihlPW5bdF0ucmVwbGFjZSgvXFwqL2csXCIuKj9cIiksXCItXCI9PT1lWzBdP3Iuc2tpcHMucHVzaChuZXcgUmVnRXhwKFwiXlwiK2Uuc3Vic3RyKDEpK1wiJFwiKSk6ci5uYW1lcy5wdXNoKG5ldyBSZWdFeHAoXCJeXCIrZStcIiRcIikpKX0sci5lbmFibGVkPWZ1bmN0aW9uKGUpe2lmKFwiKlwiPT09ZVtlLmxlbmd0aC0xXSlyZXR1cm4hMDtsZXQgdCxuO2Zvcih0PTAsbj1yLnNraXBzLmxlbmd0aDt0PG47dCsrKWlmKHIuc2tpcHNbdF0udGVzdChlKSlyZXR1cm4hMTtmb3IodD0wLG49ci5uYW1lcy5sZW5ndGg7dDxuO3QrKylpZihyLm5hbWVzW3RdLnRlc3QoZSkpcmV0dXJuITA7cmV0dXJuITF9LHIuaHVtYW5pemU9ZShcIm1zXCIpLHIuZGVzdHJveT1mdW5jdGlvbigpe2NvbnNvbGUud2FybihcIkluc3RhbmNlIG1ldGhvZCBgZGVidWcuZGVzdHJveSgpYCBpcyBkZXByZWNhdGVkIGFuZCBubyBsb25nZXIgZG9lcyBhbnl0aGluZy4gSXQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24gb2YgYGRlYnVnYC5cIil9LE9iamVjdC5rZXlzKHQpLmZvckVhY2goZT0+e3JbZV09dFtlXX0pLHIubmFtZXM9W10sci5za2lwcz1bXSxyLmZvcm1hdHRlcnM9e30sci5zZWxlY3RDb2xvcj1mdW5jdGlvbihlKXtsZXQgdD0wO2ZvcihsZXQgbj0wO248ZS5sZW5ndGg7bisrKXQ9KHQ8PDUpLXQrZS5jaGFyQ29kZUF0KG4pLHR8PTA7cmV0dXJuIHIuY29sb3JzW24odCklci5jb2xvcnMubGVuZ3RoXX0sci5lbmFibGUoci5sb2FkKCkpLHJ9fSx7bXM6MTF9XSw2OltmdW5jdGlvbihlLHQpeyd1c2Ugc3RyaWN0JztmdW5jdGlvbiBuKGUsdCl7Zm9yKGNvbnN0IG4gaW4gdClPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxuLHt2YWx1ZTp0W25dLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSk7cmV0dXJuIGV9dC5leHBvcnRzPWZ1bmN0aW9uKGUsdCxyKXtpZighZXx8XCJzdHJpbmdcIj09dHlwZW9mIGUpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlBsZWFzZSBwYXNzIGFuIEVycm9yIHRvIGVyci1jb2RlXCIpO3J8fChyPXt9KSxcIm9iamVjdFwiPT10eXBlb2YgdCYmKHI9dCx0PVwiXCIpLHQmJihyLmNvZGU9dCk7dHJ5e3JldHVybiBuKGUscil9Y2F0Y2godCl7ci5tZXNzYWdlPWUubWVzc2FnZSxyLnN0YWNrPWUuc3RhY2s7Y29uc3QgYT1mdW5jdGlvbigpe307YS5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2YoZSkpO2NvbnN0IG89bihuZXcgYSxyKTtyZXR1cm4gb319fSx7fV0sNzpbZnVuY3Rpb24oZSx0KXsndXNlIHN0cmljdCc7ZnVuY3Rpb24gbihlKXtjb25zb2xlJiZjb25zb2xlLndhcm4mJmNvbnNvbGUud2FybihlKX1mdW5jdGlvbiByKCl7ci5pbml0LmNhbGwodGhpcyl9ZnVuY3Rpb24gYShlKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBlKXRocm93IG5ldyBUeXBlRXJyb3IoXCJUaGUgXFxcImxpc3RlbmVyXFxcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24uIFJlY2VpdmVkIHR5cGUgXCIrdHlwZW9mIGUpfWZ1bmN0aW9uIG8oZSl7cmV0dXJuIHZvaWQgMD09PWUuX21heExpc3RlbmVycz9yLmRlZmF1bHRNYXhMaXN0ZW5lcnM6ZS5fbWF4TGlzdGVuZXJzfWZ1bmN0aW9uIGkoZSx0LHIsaSl7dmFyIGQscyxsO2lmKGEocikscz1lLl9ldmVudHMsdm9pZCAwPT09cz8ocz1lLl9ldmVudHM9T2JqZWN0LmNyZWF0ZShudWxsKSxlLl9ldmVudHNDb3VudD0wKToodm9pZCAwIT09cy5uZXdMaXN0ZW5lciYmKGUuZW1pdChcIm5ld0xpc3RlbmVyXCIsdCxyLmxpc3RlbmVyP3IubGlzdGVuZXI6cikscz1lLl9ldmVudHMpLGw9c1t0XSksdm9pZCAwPT09bClsPXNbdF09ciwrK2UuX2V2ZW50c0NvdW50O2Vsc2UgaWYoXCJmdW5jdGlvblwiPT10eXBlb2YgbD9sPXNbdF09aT9bcixsXTpbbCxyXTppP2wudW5zaGlmdChyKTpsLnB1c2gociksZD1vKGUpLDA8ZCYmbC5sZW5ndGg+ZCYmIWwud2FybmVkKXtsLndhcm5lZD0hMDt2YXIgYz1uZXcgRXJyb3IoXCJQb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5IGxlYWsgZGV0ZWN0ZWQuIFwiK2wubGVuZ3RoK1wiIFwiKyh0K1wiIGxpc3RlbmVycyBhZGRlZC4gVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gaW5jcmVhc2UgbGltaXRcIikpO2MubmFtZT1cIk1heExpc3RlbmVyc0V4Y2VlZGVkV2FybmluZ1wiLGMuZW1pdHRlcj1lLGMudHlwZT10LGMuY291bnQ9bC5sZW5ndGgsbihjKX1yZXR1cm4gZX1mdW5jdGlvbiBkKCl7aWYoIXRoaXMuZmlyZWQpcmV0dXJuIHRoaXMudGFyZ2V0LnJlbW92ZUxpc3RlbmVyKHRoaXMudHlwZSx0aGlzLndyYXBGbiksdGhpcy5maXJlZD0hMCwwPT09YXJndW1lbnRzLmxlbmd0aD90aGlzLmxpc3RlbmVyLmNhbGwodGhpcy50YXJnZXQpOnRoaXMubGlzdGVuZXIuYXBwbHkodGhpcy50YXJnZXQsYXJndW1lbnRzKX1mdW5jdGlvbiBzKGUsdCxuKXt2YXIgcj17ZmlyZWQ6ITEsd3JhcEZuOnZvaWQgMCx0YXJnZXQ6ZSx0eXBlOnQsbGlzdGVuZXI6bn0sYT1kLmJpbmQocik7cmV0dXJuIGEubGlzdGVuZXI9bixyLndyYXBGbj1hLGF9ZnVuY3Rpb24gbChlLHQsbil7dmFyIHI9ZS5fZXZlbnRzO2lmKHI9PT12b2lkIDApcmV0dXJuW107dmFyIGE9clt0XTtyZXR1cm4gdm9pZCAwPT09YT9bXTpcImZ1bmN0aW9uXCI9PXR5cGVvZiBhP24/W2EubGlzdGVuZXJ8fGFdOlthXTpuP2YoYSk6dShhLGEubGVuZ3RoKX1mdW5jdGlvbiBjKGUpe3ZhciB0PXRoaXMuX2V2ZW50cztpZih0IT09dm9pZCAwKXt2YXIgbj10W2VdO2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIG4pcmV0dXJuIDE7aWYodm9pZCAwIT09bilyZXR1cm4gbi5sZW5ndGh9cmV0dXJuIDB9ZnVuY3Rpb24gdShlLHQpe2Zvcih2YXIgbj1BcnJheSh0KSxyPTA7cjx0OysrciluW3JdPWVbcl07cmV0dXJuIG59ZnVuY3Rpb24gcChlLHQpe2Zvcig7dCsxPGUubGVuZ3RoO3QrKyllW3RdPWVbdCsxXTtlLnBvcCgpfWZ1bmN0aW9uIGYoZSl7Zm9yKHZhciB0PUFycmF5KGUubGVuZ3RoKSxuPTA7bjx0Lmxlbmd0aDsrK24pdFtuXT1lW25dLmxpc3RlbmVyfHxlW25dO3JldHVybiB0fWZ1bmN0aW9uIGcoZSx0LG4pe1wiZnVuY3Rpb25cIj09dHlwZW9mIGUub24mJl8oZSxcImVycm9yXCIsdCxuKX1mdW5jdGlvbiBfKGUsdCxuLHIpe2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIGUub24pci5vbmNlP2Uub25jZSh0LG4pOmUub24odCxuKTtlbHNlIGlmKFwiZnVuY3Rpb25cIj09dHlwZW9mIGUuYWRkRXZlbnRMaXN0ZW5lcillLmFkZEV2ZW50TGlzdGVuZXIodCxmdW5jdGlvbiBhKG8pe3Iub25jZSYmZS5yZW1vdmVFdmVudExpc3RlbmVyKHQsYSksbihvKX0pO2Vsc2UgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlRoZSBcXFwiZW1pdHRlclxcXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEV2ZW50RW1pdHRlci4gUmVjZWl2ZWQgdHlwZSBcIit0eXBlb2YgZSl9dmFyIGgsbT1cIm9iamVjdFwiPT10eXBlb2YgUmVmbGVjdD9SZWZsZWN0Om51bGwsYj1tJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBtLmFwcGx5P20uYXBwbHk6ZnVuY3Rpb24oZSx0LG4pe3JldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChlLHQsbil9O2g9bSYmXCJmdW5jdGlvblwiPT10eXBlb2YgbS5vd25LZXlzP20ub3duS2V5czpPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzP2Z1bmN0aW9uKGUpe3JldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhlKS5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKSl9OmZ1bmN0aW9uKGUpe3JldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhlKX07dmFyIHk9TnVtYmVyLmlzTmFOfHxmdW5jdGlvbihlKXtyZXR1cm4gZSE9PWV9O3QuZXhwb3J0cz1yLHQuZXhwb3J0cy5vbmNlPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKG4scil7ZnVuY3Rpb24gYShuKXtlLnJlbW92ZUxpc3RlbmVyKHQsbykscihuKX1mdW5jdGlvbiBvKCl7XCJmdW5jdGlvblwiPT10eXBlb2YgZS5yZW1vdmVMaXN0ZW5lciYmZS5yZW1vdmVMaXN0ZW5lcihcImVycm9yXCIsYSksbihbXS5zbGljZS5jYWxsKGFyZ3VtZW50cykpfV8oZSx0LG8se29uY2U6ITB9KSxcImVycm9yXCIhPT10JiZnKGUsYSx7b25jZTohMH0pfSl9LHIuRXZlbnRFbWl0dGVyPXIsci5wcm90b3R5cGUuX2V2ZW50cz12b2lkIDAsci5wcm90b3R5cGUuX2V2ZW50c0NvdW50PTAsci5wcm90b3R5cGUuX21heExpc3RlbmVycz12b2lkIDA7dmFyIEM9MTA7T2JqZWN0LmRlZmluZVByb3BlcnR5KHIsXCJkZWZhdWx0TWF4TGlzdGVuZXJzXCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIEN9LHNldDpmdW5jdGlvbihlKXtpZihcIm51bWJlclwiIT10eXBlb2YgZXx8MD5lfHx5KGUpKXRocm93IG5ldyBSYW5nZUVycm9yKFwiVGhlIHZhbHVlIG9mIFxcXCJkZWZhdWx0TWF4TGlzdGVuZXJzXFxcIiBpcyBvdXQgb2YgcmFuZ2UuIEl0IG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLiBSZWNlaXZlZCBcIitlK1wiLlwiKTtDPWV9fSksci5pbml0PWZ1bmN0aW9uKCl7KHRoaXMuX2V2ZW50cz09PXZvaWQgMHx8dGhpcy5fZXZlbnRzPT09T2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLl9ldmVudHMpJiYodGhpcy5fZXZlbnRzPU9iamVjdC5jcmVhdGUobnVsbCksdGhpcy5fZXZlbnRzQ291bnQ9MCksdGhpcy5fbWF4TGlzdGVuZXJzPXRoaXMuX21heExpc3RlbmVyc3x8dm9pZCAwfSxyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnM9ZnVuY3Rpb24oZSl7aWYoXCJudW1iZXJcIiE9dHlwZW9mIGV8fDA+ZXx8eShlKSl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlRoZSB2YWx1ZSBvZiBcXFwiblxcXCIgaXMgb3V0IG9mIHJhbmdlLiBJdCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci4gUmVjZWl2ZWQgXCIrZStcIi5cIik7cmV0dXJuIHRoaXMuX21heExpc3RlbmVycz1lLHRoaXN9LHIucHJvdG90eXBlLmdldE1heExpc3RlbmVycz1mdW5jdGlvbigpe3JldHVybiBvKHRoaXMpfSxyLnByb3RvdHlwZS5lbWl0PWZ1bmN0aW9uKGUpe2Zvcih2YXIgdD1bXSxuPTE7bjxhcmd1bWVudHMubGVuZ3RoO24rKyl0LnB1c2goYXJndW1lbnRzW25dKTt2YXIgcj1cImVycm9yXCI9PT1lLGE9dGhpcy5fZXZlbnRzO2lmKGEhPT12b2lkIDApcj1yJiZhLmVycm9yPT09dm9pZCAwO2Vsc2UgaWYoIXIpcmV0dXJuITE7aWYocil7dmFyIG87aWYoMDx0Lmxlbmd0aCYmKG89dFswXSksbyBpbnN0YW5jZW9mIEVycm9yKXRocm93IG87dmFyIGQ9bmV3IEVycm9yKFwiVW5oYW5kbGVkIGVycm9yLlwiKyhvP1wiIChcIitvLm1lc3NhZ2UrXCIpXCI6XCJcIikpO3Rocm93IGQuY29udGV4dD1vLGR9dmFyIHM9YVtlXTtpZihzPT09dm9pZCAwKXJldHVybiExO2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIHMpYihzLHRoaXMsdCk7ZWxzZSBmb3IodmFyIGw9cy5sZW5ndGgsYz11KHMsbCksbj0wO248bDsrK24pYihjW25dLHRoaXMsdCk7cmV0dXJuITB9LHIucHJvdG90eXBlLmFkZExpc3RlbmVyPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGkodGhpcyxlLHQsITEpfSxyLnByb3RvdHlwZS5vbj1yLnByb3RvdHlwZS5hZGRMaXN0ZW5lcixyLnByb3RvdHlwZS5wcmVwZW5kTGlzdGVuZXI9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gaSh0aGlzLGUsdCwhMCl9LHIucHJvdG90eXBlLm9uY2U9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gYSh0KSx0aGlzLm9uKGUscyh0aGlzLGUsdCkpLHRoaXN9LHIucHJvdG90eXBlLnByZXBlbmRPbmNlTGlzdGVuZXI9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gYSh0KSx0aGlzLnByZXBlbmRMaXN0ZW5lcihlLHModGhpcyxlLHQpKSx0aGlzfSxyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lcj1mdW5jdGlvbihlLHQpe3ZhciBuLHIsbyxkLHM7aWYoYSh0KSxyPXRoaXMuX2V2ZW50cyx2b2lkIDA9PT1yKXJldHVybiB0aGlzO2lmKG49cltlXSx2b2lkIDA9PT1uKXJldHVybiB0aGlzO2lmKG49PT10fHxuLmxpc3RlbmVyPT09dCkwPT0tLXRoaXMuX2V2ZW50c0NvdW50P3RoaXMuX2V2ZW50cz1PYmplY3QuY3JlYXRlKG51bGwpOihkZWxldGUgcltlXSxyLnJlbW92ZUxpc3RlbmVyJiZ0aGlzLmVtaXQoXCJyZW1vdmVMaXN0ZW5lclwiLGUsbi5saXN0ZW5lcnx8dCkpO2Vsc2UgaWYoXCJmdW5jdGlvblwiIT10eXBlb2Ygbil7Zm9yKG89LTEsZD1uLmxlbmd0aC0xOzA8PWQ7ZC0tKWlmKG5bZF09PT10fHxuW2RdLmxpc3RlbmVyPT09dCl7cz1uW2RdLmxpc3RlbmVyLG89ZDticmVha31pZigwPm8pcmV0dXJuIHRoaXM7MD09PW8/bi5zaGlmdCgpOnAobixvKSwxPT09bi5sZW5ndGgmJihyW2VdPW5bMF0pLHZvaWQgMCE9PXIucmVtb3ZlTGlzdGVuZXImJnRoaXMuZW1pdChcInJlbW92ZUxpc3RlbmVyXCIsZSxzfHx0KX1yZXR1cm4gdGhpc30sci5wcm90b3R5cGUub2ZmPXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyLHIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycz1mdW5jdGlvbihlKXt2YXIgdCxuLHI7aWYobj10aGlzLl9ldmVudHMsdm9pZCAwPT09bilyZXR1cm4gdGhpcztpZih2b2lkIDA9PT1uLnJlbW92ZUxpc3RlbmVyKXJldHVybiAwPT09YXJndW1lbnRzLmxlbmd0aD8odGhpcy5fZXZlbnRzPU9iamVjdC5jcmVhdGUobnVsbCksdGhpcy5fZXZlbnRzQ291bnQ9MCk6dm9pZCAwIT09bltlXSYmKDA9PS0tdGhpcy5fZXZlbnRzQ291bnQ/dGhpcy5fZXZlbnRzPU9iamVjdC5jcmVhdGUobnVsbCk6ZGVsZXRlIG5bZV0pLHRoaXM7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBhLG89T2JqZWN0LmtleXMobik7Zm9yKHI9MDtyPG8ubGVuZ3RoOysrcilhPW9bcl0sXCJyZW1vdmVMaXN0ZW5lclwiIT09YSYmdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoYSk7cmV0dXJuIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKFwicmVtb3ZlTGlzdGVuZXJcIiksdGhpcy5fZXZlbnRzPU9iamVjdC5jcmVhdGUobnVsbCksdGhpcy5fZXZlbnRzQ291bnQ9MCx0aGlzfWlmKHQ9bltlXSxcImZ1bmN0aW9uXCI9PXR5cGVvZiB0KXRoaXMucmVtb3ZlTGlzdGVuZXIoZSx0KTtlbHNlIGlmKHZvaWQgMCE9PXQpZm9yKHI9dC5sZW5ndGgtMTswPD1yO3ItLSl0aGlzLnJlbW92ZUxpc3RlbmVyKGUsdFtyXSk7cmV0dXJuIHRoaXN9LHIucHJvdG90eXBlLmxpc3RlbmVycz1mdW5jdGlvbihlKXtyZXR1cm4gbCh0aGlzLGUsITApfSxyLnByb3RvdHlwZS5yYXdMaXN0ZW5lcnM9ZnVuY3Rpb24oZSl7cmV0dXJuIGwodGhpcyxlLCExKX0sci5saXN0ZW5lckNvdW50PWZ1bmN0aW9uKGUsdCl7cmV0dXJuXCJmdW5jdGlvblwiPT10eXBlb2YgZS5saXN0ZW5lckNvdW50P2UubGlzdGVuZXJDb3VudCh0KTpjLmNhbGwoZSx0KX0sci5wcm90b3R5cGUubGlzdGVuZXJDb3VudD1jLHIucHJvdG90eXBlLmV2ZW50TmFtZXM9ZnVuY3Rpb24oKXtyZXR1cm4gMDx0aGlzLl9ldmVudHNDb3VudD9oKHRoaXMuX2V2ZW50cyk6W119fSx7fV0sODpbZnVuY3Rpb24oZSx0KXt0LmV4cG9ydHM9ZnVuY3Rpb24oKXtpZihcInVuZGVmaW5lZFwiPT10eXBlb2YgZ2xvYmFsVGhpcylyZXR1cm4gbnVsbDt2YXIgZT17UlRDUGVlckNvbm5lY3Rpb246Z2xvYmFsVGhpcy5SVENQZWVyQ29ubmVjdGlvbnx8Z2xvYmFsVGhpcy5tb3pSVENQZWVyQ29ubmVjdGlvbnx8Z2xvYmFsVGhpcy53ZWJraXRSVENQZWVyQ29ubmVjdGlvbixSVENTZXNzaW9uRGVzY3JpcHRpb246Z2xvYmFsVGhpcy5SVENTZXNzaW9uRGVzY3JpcHRpb258fGdsb2JhbFRoaXMubW96UlRDU2Vzc2lvbkRlc2NyaXB0aW9ufHxnbG9iYWxUaGlzLndlYmtpdFJUQ1Nlc3Npb25EZXNjcmlwdGlvbixSVENJY2VDYW5kaWRhdGU6Z2xvYmFsVGhpcy5SVENJY2VDYW5kaWRhdGV8fGdsb2JhbFRoaXMubW96UlRDSWNlQ2FuZGlkYXRlfHxnbG9iYWxUaGlzLndlYmtpdFJUQ0ljZUNhbmRpZGF0ZX07cmV0dXJuIGUuUlRDUGVlckNvbm5lY3Rpb24/ZTpudWxsfX0se31dLDk6W2Z1bmN0aW9uKGUsYSxvKXsvKiEgaWVlZTc1NC4gQlNELTMtQ2xhdXNlIExpY2Vuc2UuIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZy9vcGVuc291cmNlPiAqL28ucmVhZD1mdW5jdGlvbih0LG4sYSxvLGwpe3ZhciBjLHUscD04Kmwtby0xLGY9KDE8PHApLTEsZz1mPj4xLF89LTcsaD1hP2wtMTowLGI9YT8tMToxLGQ9dFtuK2hdO2ZvcihoKz1iLGM9ZCYoMTw8LV8pLTEsZD4+PS1fLF8rPXA7MDxfO2M9MjU2KmMrdFtuK2hdLGgrPWIsXy09OCk7Zm9yKHU9YyYoMTw8LV8pLTEsYz4+PS1fLF8rPW87MDxfO3U9MjU2KnUrdFtuK2hdLGgrPWIsXy09OCk7aWYoMD09PWMpYz0xLWc7ZWxzZXtpZihjPT09ZilyZXR1cm4gdT9OYU46KGQ/LTE6MSkqKDEvMCk7dSs9cigyLG8pLGMtPWd9cmV0dXJuKGQ/LTE6MSkqdSpyKDIsYy1vKX0sby53cml0ZT1mdW5jdGlvbihhLG8sbCx1LHAsZil7dmFyIGgsYix5LGc9TWF0aC5MTjIsXz1NYXRoLmxvZyxDPTgqZi1wLTEsUj0oMTw8QyktMSxFPVI+PjEsdz0yMz09PXA/cigyLC0yNCktcigyLC03Nyk6MCxTPXU/MDpmLTEsVD11PzE6LTEsZD0wPm98fDA9PT1vJiYwPjEvbz8xOjA7Zm9yKG89bihvKSxpc05hTihvKXx8bz09PTEvMD8oYj1pc05hTihvKT8xOjAsaD1SKTooaD10KF8obykvZyksMT5vKih5PXIoMiwtaCkpJiYoaC0tLHkqPTIpLG8rPTE8PWgrRT93L3k6dypyKDIsMS1FKSwyPD1vKnkmJihoKysseS89MiksaCtFPj1SPyhiPTAsaD1SKToxPD1oK0U/KGI9KG8qeS0xKSpyKDIscCksaCs9RSk6KGI9bypyKDIsRS0xKSpyKDIscCksaD0wKSk7ODw9cDthW2wrU109MjU1JmIsUys9VCxiLz0yNTYscC09OCk7Zm9yKGg9aDw8cHxiLEMrPXA7MDxDO2FbbCtTXT0yNTUmaCxTKz1ULGgvPTI1NixDLT04KTthW2wrUy1UXXw9MTI4KmR9fSx7fV0sMTA6W2Z1bmN0aW9uKGUsdCl7dC5leHBvcnRzPVwiZnVuY3Rpb25cIj09dHlwZW9mIE9iamVjdC5jcmVhdGU/ZnVuY3Rpb24oZSx0KXt0JiYoZS5zdXBlcl89dCxlLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKHQucHJvdG90eXBlLHtjb25zdHJ1Y3Rvcjp7dmFsdWU6ZSxlbnVtZXJhYmxlOiExLHdyaXRhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH19KSl9OmZ1bmN0aW9uKGUsdCl7aWYodCl7ZS5zdXBlcl89dDt2YXIgbj1mdW5jdGlvbigpe307bi5wcm90b3R5cGU9dC5wcm90b3R5cGUsZS5wcm90b3R5cGU9bmV3IG4sZS5wcm90b3R5cGUuY29uc3RydWN0b3I9ZX19fSx7fV0sMTE6W2Z1bmN0aW9uKGUsdCl7dmFyIHI9TWF0aC5yb3VuZDtmdW5jdGlvbiBhKGUpe2lmKGUrPVwiXCIsISgxMDA8ZS5sZW5ndGgpKXt2YXIgdD0vXigtPyg/OlxcZCspP1xcLj9cXGQrKSAqKG1pbGxpc2Vjb25kcz98bXNlY3M/fG1zfHNlY29uZHM/fHNlY3M/fHN8bWludXRlcz98bWlucz98bXxob3Vycz98aHJzP3xofGRheXM/fGR8d2Vla3M/fHd8eWVhcnM/fHlycz98eSk/JC9pLmV4ZWMoZSk7aWYodCl7dmFyIHI9cGFyc2VGbG9hdCh0WzFdKSxuPSh0WzJdfHxcIm1zXCIpLnRvTG93ZXJDYXNlKCk7cmV0dXJuXCJ5ZWFyc1wiPT09bnx8XCJ5ZWFyXCI9PT1ufHxcInlyc1wiPT09bnx8XCJ5clwiPT09bnx8XCJ5XCI9PT1uPzMxNTU3NjAwMDAwKnI6XCJ3ZWVrc1wiPT09bnx8XCJ3ZWVrXCI9PT1ufHxcIndcIj09PW4/NjA0ODAwMDAwKnI6XCJkYXlzXCI9PT1ufHxcImRheVwiPT09bnx8XCJkXCI9PT1uPzg2NDAwMDAwKnI6XCJob3Vyc1wiPT09bnx8XCJob3VyXCI9PT1ufHxcImhyc1wiPT09bnx8XCJoclwiPT09bnx8XCJoXCI9PT1uPzM2MDAwMDAqcjpcIm1pbnV0ZXNcIj09PW58fFwibWludXRlXCI9PT1ufHxcIm1pbnNcIj09PW58fFwibWluXCI9PT1ufHxcIm1cIj09PW4/NjAwMDAqcjpcInNlY29uZHNcIj09PW58fFwic2Vjb25kXCI9PT1ufHxcInNlY3NcIj09PW58fFwic2VjXCI9PT1ufHxcInNcIj09PW4/MTAwMCpyOlwibWlsbGlzZWNvbmRzXCI9PT1ufHxcIm1pbGxpc2Vjb25kXCI9PT1ufHxcIm1zZWNzXCI9PT1ufHxcIm1zZWNcIj09PW58fFwibXNcIj09PW4/cjp2b2lkIDB9fX1mdW5jdGlvbiBvKGUpe3ZhciB0PW4oZSk7cmV0dXJuIDg2NDAwMDAwPD10P3IoZS84NjQwMDAwMCkrXCJkXCI6MzYwMDAwMDw9dD9yKGUvMzYwMDAwMCkrXCJoXCI6NjAwMDA8PXQ/cihlLzYwMDAwKStcIm1cIjoxMDAwPD10P3IoZS8xMDAwKStcInNcIjplK1wibXNcIn1mdW5jdGlvbiBpKGUpe3ZhciB0PW4oZSk7cmV0dXJuIDg2NDAwMDAwPD10P3MoZSx0LDg2NDAwMDAwLFwiZGF5XCIpOjM2MDAwMDA8PXQ/cyhlLHQsMzYwMDAwMCxcImhvdXJcIik6NjAwMDA8PXQ/cyhlLHQsNjAwMDAsXCJtaW51dGVcIik6MTAwMDw9dD9zKGUsdCwxMDAwLFwic2Vjb25kXCIpOmUrXCIgbXNcIn1mdW5jdGlvbiBzKGUsdCxhLG4pe3JldHVybiByKGUvYSkrXCIgXCIrbisodD49MS41KmE/XCJzXCI6XCJcIil9dmFyIGw9MjQqKDYwKjYwMDAwKTt0LmV4cG9ydHM9ZnVuY3Rpb24oZSx0KXt0PXR8fHt9O3ZhciBuPXR5cGVvZiBlO2lmKFwic3RyaW5nXCI9PW4mJjA8ZS5sZW5ndGgpcmV0dXJuIGEoZSk7aWYoXCJudW1iZXJcIj09PW4mJmlzRmluaXRlKGUpKXJldHVybiB0Lmxvbmc/aShlKTpvKGUpO3Rocm93IG5ldyBFcnJvcihcInZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgdmFsaWQgbnVtYmVyLiB2YWw9XCIrSlNPTi5zdHJpbmdpZnkoZSkpfX0se31dLDEyOltmdW5jdGlvbihlLHQpe2Z1bmN0aW9uIG4oKXt0aHJvdyBuZXcgRXJyb3IoXCJzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkXCIpfWZ1bmN0aW9uIHIoKXt0aHJvdyBuZXcgRXJyb3IoXCJjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWRcIil9ZnVuY3Rpb24gYSh0KXtpZihjPT09c2V0VGltZW91dClyZXR1cm4gc2V0VGltZW91dCh0LDApO2lmKChjPT09bnx8IWMpJiZzZXRUaW1lb3V0KXJldHVybiBjPXNldFRpbWVvdXQsc2V0VGltZW91dCh0LDApO3RyeXtyZXR1cm4gYyh0LDApfWNhdGNoKG4pe3RyeXtyZXR1cm4gYy5jYWxsKG51bGwsdCwwKX1jYXRjaChuKXtyZXR1cm4gYy5jYWxsKHRoaXMsdCwwKX19fWZ1bmN0aW9uIG8odCl7aWYodT09PWNsZWFyVGltZW91dClyZXR1cm4gY2xlYXJUaW1lb3V0KHQpO2lmKCh1PT09cnx8IXUpJiZjbGVhclRpbWVvdXQpcmV0dXJuIHU9Y2xlYXJUaW1lb3V0LGNsZWFyVGltZW91dCh0KTt0cnl7cmV0dXJuIHUodCl9Y2F0Y2gobil7dHJ5e3JldHVybiB1LmNhbGwobnVsbCx0KX1jYXRjaChuKXtyZXR1cm4gdS5jYWxsKHRoaXMsdCl9fX1mdW5jdGlvbiBpKCl7XyYmZiYmKF89ITEsZi5sZW5ndGg/Zz1mLmNvbmNhdChnKTpoPS0xLGcubGVuZ3RoJiZkKCkpfWZ1bmN0aW9uIGQoKXtpZighXyl7dmFyIGU9YShpKTtfPSEwO2Zvcih2YXIgdD1nLmxlbmd0aDt0Oyl7Zm9yKGY9ZyxnPVtdOysraDx0OylmJiZmW2hdLnJ1bigpO2g9LTEsdD1nLmxlbmd0aH1mPW51bGwsXz0hMSxvKGUpfX1mdW5jdGlvbiBzKGUsdCl7dGhpcy5mdW49ZSx0aGlzLmFycmF5PXR9ZnVuY3Rpb24gbCgpe312YXIgYyx1LHA9dC5leHBvcnRzPXt9OyhmdW5jdGlvbigpe3RyeXtjPVwiZnVuY3Rpb25cIj09dHlwZW9mIHNldFRpbWVvdXQ/c2V0VGltZW91dDpufWNhdGNoKHQpe2M9bn10cnl7dT1cImZ1bmN0aW9uXCI9PXR5cGVvZiBjbGVhclRpbWVvdXQ/Y2xlYXJUaW1lb3V0OnJ9Y2F0Y2godCl7dT1yfX0pKCk7dmFyIGYsZz1bXSxfPSExLGg9LTE7cC5uZXh0VGljaz1mdW5jdGlvbihlKXt2YXIgdD1BcnJheShhcmd1bWVudHMubGVuZ3RoLTEpO2lmKDE8YXJndW1lbnRzLmxlbmd0aClmb3IodmFyIG49MTtuPGFyZ3VtZW50cy5sZW5ndGg7bisrKXRbbi0xXT1hcmd1bWVudHNbbl07Zy5wdXNoKG5ldyBzKGUsdCkpLDEhPT1nLmxlbmd0aHx8X3x8YShkKX0scy5wcm90b3R5cGUucnVuPWZ1bmN0aW9uKCl7dGhpcy5mdW4uYXBwbHkobnVsbCx0aGlzLmFycmF5KX0scC50aXRsZT1cImJyb3dzZXJcIixwLmJyb3dzZXI9ITAscC5lbnY9e30scC5hcmd2PVtdLHAudmVyc2lvbj1cIlwiLHAudmVyc2lvbnM9e30scC5vbj1sLHAuYWRkTGlzdGVuZXI9bCxwLm9uY2U9bCxwLm9mZj1sLHAucmVtb3ZlTGlzdGVuZXI9bCxwLnJlbW92ZUFsbExpc3RlbmVycz1sLHAuZW1pdD1sLHAucHJlcGVuZExpc3RlbmVyPWwscC5wcmVwZW5kT25jZUxpc3RlbmVyPWwscC5saXN0ZW5lcnM9ZnVuY3Rpb24oKXtyZXR1cm5bXX0scC5iaW5kaW5nPWZ1bmN0aW9uKCl7dGhyb3cgbmV3IEVycm9yKFwicHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWRcIil9LHAuY3dkPWZ1bmN0aW9uKCl7cmV0dXJuXCIvXCJ9LHAuY2hkaXI9ZnVuY3Rpb24oKXt0aHJvdyBuZXcgRXJyb3IoXCJwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWRcIil9LHAudW1hc2s9ZnVuY3Rpb24oKXtyZXR1cm4gMH19LHt9XSwxMzpbZnVuY3Rpb24oZSx0KXsoZnVuY3Rpb24oZSl7KGZ1bmN0aW9uKCl7LyohIHF1ZXVlLW1pY3JvdGFzay4gTUlUIExpY2Vuc2UuIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZy9vcGVuc291cmNlPiAqL2xldCBuO3QuZXhwb3J0cz1cImZ1bmN0aW9uXCI9PXR5cGVvZiBxdWV1ZU1pY3JvdGFzaz9xdWV1ZU1pY3JvdGFzay5iaW5kKFwidW5kZWZpbmVkXCI9PXR5cGVvZiB3aW5kb3c/ZTp3aW5kb3cpOmU9PihufHwobj1Qcm9taXNlLnJlc29sdmUoKSkpLnRoZW4oZSkuY2F0Y2goZT0+c2V0VGltZW91dCgoKT0+e3Rocm93IGV9LDApKX0pLmNhbGwodGhpcyl9KS5jYWxsKHRoaXMsXCJ1bmRlZmluZWRcIj09dHlwZW9mIGdsb2JhbD9cInVuZGVmaW5lZFwiPT10eXBlb2Ygc2VsZj9cInVuZGVmaW5lZFwiPT10eXBlb2Ygd2luZG93P3t9OndpbmRvdzpzZWxmOmdsb2JhbCl9LHt9XSwxNDpbZnVuY3Rpb24oZSx0KXsoZnVuY3Rpb24obixyKXsoZnVuY3Rpb24oKXsndXNlIHN0cmljdCc7dmFyIGE9ZShcInNhZmUtYnVmZmVyXCIpLkJ1ZmZlcixvPXIuY3J5cHRvfHxyLm1zQ3J5cHRvO3QuZXhwb3J0cz1vJiZvLmdldFJhbmRvbVZhbHVlcz9mdW5jdGlvbihlLHQpe2lmKGU+NDI5NDk2NzI5NSl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcInJlcXVlc3RlZCB0b28gbWFueSByYW5kb20gYnl0ZXNcIik7dmFyIHI9YS5hbGxvY1Vuc2FmZShlKTtpZigwPGUpaWYoNjU1MzY8ZSlmb3IodmFyIGk9MDtpPGU7aSs9NjU1MzYpby5nZXRSYW5kb21WYWx1ZXMoci5zbGljZShpLGkrNjU1MzYpKTtlbHNlIG8uZ2V0UmFuZG9tVmFsdWVzKHIpO3JldHVyblwiZnVuY3Rpb25cIj09dHlwZW9mIHQ/bi5uZXh0VGljayhmdW5jdGlvbigpe3QobnVsbCxyKX0pOnJ9OmZ1bmN0aW9uKCl7dGhyb3cgbmV3IEVycm9yKFwiU2VjdXJlIHJhbmRvbSBudW1iZXIgZ2VuZXJhdGlvbiBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoaXMgYnJvd3Nlci5cXG5Vc2UgQ2hyb21lLCBGaXJlZm94IG9yIEludGVybmV0IEV4cGxvcmVyIDExXCIpfX0pLmNhbGwodGhpcyl9KS5jYWxsKHRoaXMsZShcIl9wcm9jZXNzXCIpLFwidW5kZWZpbmVkXCI9PXR5cGVvZiBnbG9iYWw/XCJ1bmRlZmluZWRcIj09dHlwZW9mIHNlbGY/XCJ1bmRlZmluZWRcIj09dHlwZW9mIHdpbmRvdz97fTp3aW5kb3c6c2VsZjpnbG9iYWwpfSx7X3Byb2Nlc3M6MTIsXCJzYWZlLWJ1ZmZlclwiOjMwfV0sMTU6W2Z1bmN0aW9uKGUsdCl7J3VzZSBzdHJpY3QnO2Z1bmN0aW9uIG4oZSx0KXtlLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKHQucHJvdG90eXBlKSxlLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1lLGUuX19wcm90b19fPXR9ZnVuY3Rpb24gcihlLHQscil7ZnVuY3Rpb24gYShlLG4scil7cmV0dXJuXCJzdHJpbmdcIj09dHlwZW9mIHQ/dDp0KGUsbixyKX1yfHwocj1FcnJvcik7dmFyIG89ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0LG4scil7cmV0dXJuIGUuY2FsbCh0aGlzLGEodCxuLHIpKXx8dGhpc31yZXR1cm4gbih0LGUpLHR9KHIpO28ucHJvdG90eXBlLm5hbWU9ci5uYW1lLG8ucHJvdG90eXBlLmNvZGU9ZSxzW2VdPW99ZnVuY3Rpb24gYShlLHQpe2lmKEFycmF5LmlzQXJyYXkoZSkpe3ZhciBuPWUubGVuZ3RoO3JldHVybiBlPWUubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBlK1wiXCJ9KSwyPG4/XCJvbmUgb2YgXCIuY29uY2F0KHQsXCIgXCIpLmNvbmNhdChlLnNsaWNlKDAsbi0xKS5qb2luKFwiLCBcIiksXCIsIG9yIFwiKStlW24tMV06Mj09PW4/XCJvbmUgb2YgXCIuY29uY2F0KHQsXCIgXCIpLmNvbmNhdChlWzBdLFwiIG9yIFwiKS5jb25jYXQoZVsxXSk6XCJvZiBcIi5jb25jYXQodCxcIiBcIikuY29uY2F0KGVbMF0pfXJldHVyblwib2YgXCIuY29uY2F0KHQsXCIgXCIpLmNvbmNhdChlK1wiXCIpfWZ1bmN0aW9uIG8oZSx0LG4pe3JldHVybiBlLnN1YnN0cighbnx8MD5uPzA6K24sdC5sZW5ndGgpPT09dH1mdW5jdGlvbiBpKGUsdCxuKXtyZXR1cm4odm9pZCAwPT09bnx8bj5lLmxlbmd0aCkmJihuPWUubGVuZ3RoKSxlLnN1YnN0cmluZyhuLXQubGVuZ3RoLG4pPT09dH1mdW5jdGlvbiBkKGUsdCxuKXtyZXR1cm5cIm51bWJlclwiIT10eXBlb2YgbiYmKG49MCksIShuK3QubGVuZ3RoPmUubGVuZ3RoKSYmLTEhPT1lLmluZGV4T2YodCxuKX12YXIgcz17fTtyKFwiRVJSX0lOVkFMSURfT1BUX1ZBTFVFXCIsZnVuY3Rpb24oZSx0KXtyZXR1cm5cIlRoZSB2YWx1ZSBcXFwiXCIrdCtcIlxcXCIgaXMgaW52YWxpZCBmb3Igb3B0aW9uIFxcXCJcIitlK1wiXFxcIlwifSxUeXBlRXJyb3IpLHIoXCJFUlJfSU5WQUxJRF9BUkdfVFlQRVwiLGZ1bmN0aW9uKGUsdCxuKXt2YXIgcjtcInN0cmluZ1wiPT10eXBlb2YgdCYmbyh0LFwibm90IFwiKT8ocj1cIm11c3Qgbm90IGJlXCIsdD10LnJlcGxhY2UoL15ub3QgLyxcIlwiKSk6cj1cIm11c3QgYmVcIjt2YXIgcztpZihpKGUsXCIgYXJndW1lbnRcIikpcz1cIlRoZSBcIi5jb25jYXQoZSxcIiBcIikuY29uY2F0KHIsXCIgXCIpLmNvbmNhdChhKHQsXCJ0eXBlXCIpKTtlbHNle3ZhciBsPWQoZSxcIi5cIik/XCJwcm9wZXJ0eVwiOlwiYXJndW1lbnRcIjtzPVwiVGhlIFxcXCJcIi5jb25jYXQoZSxcIlxcXCIgXCIpLmNvbmNhdChsLFwiIFwiKS5jb25jYXQocixcIiBcIikuY29uY2F0KGEodCxcInR5cGVcIikpfXJldHVybiBzKz1cIi4gUmVjZWl2ZWQgdHlwZSBcIi5jb25jYXQodHlwZW9mIG4pLHN9LFR5cGVFcnJvcikscihcIkVSUl9TVFJFQU1fUFVTSF9BRlRFUl9FT0ZcIixcInN0cmVhbS5wdXNoKCkgYWZ0ZXIgRU9GXCIpLHIoXCJFUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRFwiLGZ1bmN0aW9uKGUpe3JldHVyblwiVGhlIFwiK2UrXCIgbWV0aG9kIGlzIG5vdCBpbXBsZW1lbnRlZFwifSkscihcIkVSUl9TVFJFQU1fUFJFTUFUVVJFX0NMT1NFXCIsXCJQcmVtYXR1cmUgY2xvc2VcIikscihcIkVSUl9TVFJFQU1fREVTVFJPWUVEXCIsZnVuY3Rpb24oZSl7cmV0dXJuXCJDYW5ub3QgY2FsbCBcIitlK1wiIGFmdGVyIGEgc3RyZWFtIHdhcyBkZXN0cm95ZWRcIn0pLHIoXCJFUlJfTVVMVElQTEVfQ0FMTEJBQ0tcIixcIkNhbGxiYWNrIGNhbGxlZCBtdWx0aXBsZSB0aW1lc1wiKSxyKFwiRVJSX1NUUkVBTV9DQU5OT1RfUElQRVwiLFwiQ2Fubm90IHBpcGUsIG5vdCByZWFkYWJsZVwiKSxyKFwiRVJSX1NUUkVBTV9XUklURV9BRlRFUl9FTkRcIixcIndyaXRlIGFmdGVyIGVuZFwiKSxyKFwiRVJSX1NUUkVBTV9OVUxMX1ZBTFVFU1wiLFwiTWF5IG5vdCB3cml0ZSBudWxsIHZhbHVlcyB0byBzdHJlYW1cIixUeXBlRXJyb3IpLHIoXCJFUlJfVU5LTk9XTl9FTkNPRElOR1wiLGZ1bmN0aW9uKGUpe3JldHVyblwiVW5rbm93biBlbmNvZGluZzogXCIrZX0sVHlwZUVycm9yKSxyKFwiRVJSX1NUUkVBTV9VTlNISUZUX0FGVEVSX0VORF9FVkVOVFwiLFwic3RyZWFtLnVuc2hpZnQoKSBhZnRlciBlbmQgZXZlbnRcIiksdC5leHBvcnRzLmNvZGVzPXN9LHt9XSwxNjpbZnVuY3Rpb24oZSx0KXsoZnVuY3Rpb24obil7KGZ1bmN0aW9uKCl7J3VzZSBzdHJpY3QnO2Z1bmN0aW9uIHIoZSl7cmV0dXJuIHRoaXMgaW5zdGFuY2VvZiByP3ZvaWQoZC5jYWxsKHRoaXMsZSkscy5jYWxsKHRoaXMsZSksdGhpcy5hbGxvd0hhbGZPcGVuPSEwLGUmJighMT09PWUucmVhZGFibGUmJih0aGlzLnJlYWRhYmxlPSExKSwhMT09PWUud3JpdGFibGUmJih0aGlzLndyaXRhYmxlPSExKSwhMT09PWUuYWxsb3dIYWxmT3BlbiYmKHRoaXMuYWxsb3dIYWxmT3Blbj0hMSx0aGlzLm9uY2UoXCJlbmRcIixhKSkpKTpuZXcgcihlKX1mdW5jdGlvbiBhKCl7dGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRlZHx8bi5uZXh0VGljayhvLHRoaXMpfWZ1bmN0aW9uIG8oZSl7ZS5lbmQoKX12YXIgaT1PYmplY3Qua2V5c3x8ZnVuY3Rpb24oZSl7dmFyIHQ9W107Zm9yKHZhciBuIGluIGUpdC5wdXNoKG4pO3JldHVybiB0fTt0LmV4cG9ydHM9cjt2YXIgZD1lKFwiLi9fc3RyZWFtX3JlYWRhYmxlXCIpLHM9ZShcIi4vX3N0cmVhbV93cml0YWJsZVwiKTtlKFwiaW5oZXJpdHNcIikocixkKTtmb3IodmFyIGwsYz1pKHMucHJvdG90eXBlKSx1PTA7dTxjLmxlbmd0aDt1KyspbD1jW3VdLHIucHJvdG90eXBlW2xdfHwoci5wcm90b3R5cGVbbF09cy5wcm90b3R5cGVbbF0pO09iamVjdC5kZWZpbmVQcm9wZXJ0eShyLnByb3RvdHlwZSxcIndyaXRhYmxlSGlnaFdhdGVyTWFya1wiLHtlbnVtZXJhYmxlOiExLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmhpZ2hXYXRlck1hcmt9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHIucHJvdG90eXBlLFwid3JpdGFibGVCdWZmZXJcIix7ZW51bWVyYWJsZTohMSxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZSYmdGhpcy5fd3JpdGFibGVTdGF0ZS5nZXRCdWZmZXIoKX19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoci5wcm90b3R5cGUsXCJ3cml0YWJsZUxlbmd0aFwiLHtlbnVtZXJhYmxlOiExLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmxlbmd0aH19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoci5wcm90b3R5cGUsXCJkZXN0cm95ZWRcIix7ZW51bWVyYWJsZTohMSxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdm9pZCAwIT09dGhpcy5fcmVhZGFibGVTdGF0ZSYmdm9pZCAwIT09dGhpcy5fd3JpdGFibGVTdGF0ZSYmdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQmJnRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkfSxzZXQ6ZnVuY3Rpb24oZSl7dm9pZCAwPT09dGhpcy5fcmVhZGFibGVTdGF0ZXx8dm9pZCAwPT09dGhpcy5fd3JpdGFibGVTdGF0ZXx8KHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkPWUsdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQ9ZSl9fSl9KS5jYWxsKHRoaXMpfSkuY2FsbCh0aGlzLGUoXCJfcHJvY2Vzc1wiKSl9LHtcIi4vX3N0cmVhbV9yZWFkYWJsZVwiOjE4LFwiLi9fc3RyZWFtX3dyaXRhYmxlXCI6MjAsX3Byb2Nlc3M6MTIsaW5oZXJpdHM6MTB9XSwxNzpbZnVuY3Rpb24oZSx0KXsndXNlIHN0cmljdCc7ZnVuY3Rpb24gbihlKXtyZXR1cm4gdGhpcyBpbnN0YW5jZW9mIG4/dm9pZCByLmNhbGwodGhpcyxlKTpuZXcgbihlKX10LmV4cG9ydHM9bjt2YXIgcj1lKFwiLi9fc3RyZWFtX3RyYW5zZm9ybVwiKTtlKFwiaW5oZXJpdHNcIikobixyKSxuLnByb3RvdHlwZS5fdHJhbnNmb3JtPWZ1bmN0aW9uKGUsdCxuKXtuKG51bGwsZSl9fSx7XCIuL19zdHJlYW1fdHJhbnNmb3JtXCI6MTksaW5oZXJpdHM6MTB9XSwxODpbZnVuY3Rpb24oZSx0KXsoZnVuY3Rpb24obixyKXsoZnVuY3Rpb24oKXsndXNlIHN0cmljdCc7ZnVuY3Rpb24gYShlKXtyZXR1cm4gUC5mcm9tKGUpfWZ1bmN0aW9uIG8oZSl7cmV0dXJuIFAuaXNCdWZmZXIoZSl8fGUgaW5zdGFuY2VvZiBNfWZ1bmN0aW9uIGkoZSx0LG4pe3JldHVyblwiZnVuY3Rpb25cIj09dHlwZW9mIGUucHJlcGVuZExpc3RlbmVyP2UucHJlcGVuZExpc3RlbmVyKHQsbik6dm9pZChlLl9ldmVudHMmJmUuX2V2ZW50c1t0XT9BcnJheS5pc0FycmF5KGUuX2V2ZW50c1t0XSk/ZS5fZXZlbnRzW3RdLnVuc2hpZnQobik6ZS5fZXZlbnRzW3RdPVtuLGUuX2V2ZW50c1t0XV06ZS5vbih0LG4pKX1mdW5jdGlvbiBkKHQsbixyKXtBPUF8fGUoXCIuL19zdHJlYW1fZHVwbGV4XCIpLHQ9dHx8e30sXCJib29sZWFuXCIhPXR5cGVvZiByJiYocj1uIGluc3RhbmNlb2YgQSksdGhpcy5vYmplY3RNb2RlPSEhdC5vYmplY3RNb2RlLHImJih0aGlzLm9iamVjdE1vZGU9dGhpcy5vYmplY3RNb2RlfHwhIXQucmVhZGFibGVPYmplY3RNb2RlKSx0aGlzLmhpZ2hXYXRlck1hcms9SCh0aGlzLHQsXCJyZWFkYWJsZUhpZ2hXYXRlck1hcmtcIixyKSx0aGlzLmJ1ZmZlcj1uZXcgaix0aGlzLmxlbmd0aD0wLHRoaXMucGlwZXM9bnVsbCx0aGlzLnBpcGVzQ291bnQ9MCx0aGlzLmZsb3dpbmc9bnVsbCx0aGlzLmVuZGVkPSExLHRoaXMuZW5kRW1pdHRlZD0hMSx0aGlzLnJlYWRpbmc9ITEsdGhpcy5zeW5jPSEwLHRoaXMubmVlZFJlYWRhYmxlPSExLHRoaXMuZW1pdHRlZFJlYWRhYmxlPSExLHRoaXMucmVhZGFibGVMaXN0ZW5pbmc9ITEsdGhpcy5yZXN1bWVTY2hlZHVsZWQ9ITEsdGhpcy5wYXVzZWQ9ITAsdGhpcy5lbWl0Q2xvc2U9ITEhPT10LmVtaXRDbG9zZSx0aGlzLmF1dG9EZXN0cm95PSEhdC5hdXRvRGVzdHJveSx0aGlzLmRlc3Ryb3llZD0hMSx0aGlzLmRlZmF1bHRFbmNvZGluZz10LmRlZmF1bHRFbmNvZGluZ3x8XCJ1dGY4XCIsdGhpcy5hd2FpdERyYWluPTAsdGhpcy5yZWFkaW5nTW9yZT0hMSx0aGlzLmRlY29kZXI9bnVsbCx0aGlzLmVuY29kaW5nPW51bGwsdC5lbmNvZGluZyYmKCFGJiYoRj1lKFwic3RyaW5nX2RlY29kZXIvXCIpLlN0cmluZ0RlY29kZXIpLHRoaXMuZGVjb2Rlcj1uZXcgRih0LmVuY29kaW5nKSx0aGlzLmVuY29kaW5nPXQuZW5jb2RpbmcpfWZ1bmN0aW9uIHModCl7aWYoQT1BfHxlKFwiLi9fc3RyZWFtX2R1cGxleFwiKSwhKHRoaXMgaW5zdGFuY2VvZiBzKSlyZXR1cm4gbmV3IHModCk7dmFyIG49dGhpcyBpbnN0YW5jZW9mIEE7dGhpcy5fcmVhZGFibGVTdGF0ZT1uZXcgZCh0LHRoaXMsbiksdGhpcy5yZWFkYWJsZT0hMCx0JiYoXCJmdW5jdGlvblwiPT10eXBlb2YgdC5yZWFkJiYodGhpcy5fcmVhZD10LnJlYWQpLFwiZnVuY3Rpb25cIj09dHlwZW9mIHQuZGVzdHJveSYmKHRoaXMuX2Rlc3Ryb3k9dC5kZXN0cm95KSksSS5jYWxsKHRoaXMpfWZ1bmN0aW9uIGwoZSx0LG4scixvKXt4KFwicmVhZGFibGVBZGRDaHVua1wiLHQpO3ZhciBpPWUuX3JlYWRhYmxlU3RhdGU7aWYobnVsbD09PXQpaS5yZWFkaW5nPSExLGcoZSxpKTtlbHNle3ZhciBkO2lmKG98fChkPXUoaSx0KSksZClYKGUsZCk7ZWxzZSBpZighKGkub2JqZWN0TW9kZXx8dCYmMDx0Lmxlbmd0aCkpcnx8KGkucmVhZGluZz0hMSxtKGUsaSkpO2Vsc2UgaWYoXCJzdHJpbmdcIj09dHlwZW9mIHR8fGkub2JqZWN0TW9kZXx8T2JqZWN0LmdldFByb3RvdHlwZU9mKHQpPT09UC5wcm90b3R5cGV8fCh0PWEodCkpLHIpaS5lbmRFbWl0dGVkP1goZSxuZXcgSyk6YyhlLGksdCwhMCk7ZWxzZSBpZihpLmVuZGVkKVgoZSxuZXcgeik7ZWxzZXtpZihpLmRlc3Ryb3llZClyZXR1cm4hMTtpLnJlYWRpbmc9ITEsaS5kZWNvZGVyJiYhbj8odD1pLmRlY29kZXIud3JpdGUodCksaS5vYmplY3RNb2RlfHwwIT09dC5sZW5ndGg/YyhlLGksdCwhMSk6bShlLGkpKTpjKGUsaSx0LCExKX19cmV0dXJuIWkuZW5kZWQmJihpLmxlbmd0aDxpLmhpZ2hXYXRlck1hcmt8fDA9PT1pLmxlbmd0aCl9ZnVuY3Rpb24gYyhlLHQsbixyKXt0LmZsb3dpbmcmJjA9PT10Lmxlbmd0aCYmIXQuc3luYz8odC5hd2FpdERyYWluPTAsZS5lbWl0KFwiZGF0YVwiLG4pKToodC5sZW5ndGgrPXQub2JqZWN0TW9kZT8xOm4ubGVuZ3RoLHI/dC5idWZmZXIudW5zaGlmdChuKTp0LmJ1ZmZlci5wdXNoKG4pLHQubmVlZFJlYWRhYmxlJiZfKGUpKSxtKGUsdCl9ZnVuY3Rpb24gdShlLHQpe3ZhciBuO3JldHVybiBvKHQpfHxcInN0cmluZ1wiPT10eXBlb2YgdHx8dm9pZCAwPT09dHx8ZS5vYmplY3RNb2RlfHwobj1uZXcgVihcImNodW5rXCIsW1wic3RyaW5nXCIsXCJCdWZmZXJcIixcIlVpbnQ4QXJyYXlcIl0sdCkpLG59ZnVuY3Rpb24gcChlKXtyZXR1cm4gMTA3Mzc0MTgyNDw9ZT9lPTEwNzM3NDE4MjQ6KGUtLSxlfD1lPj4+MSxlfD1lPj4+MixlfD1lPj4+NCxlfD1lPj4+OCxlfD1lPj4+MTYsZSsrKSxlfWZ1bmN0aW9uIGYoZSx0KXtyZXR1cm4gMD49ZXx8MD09PXQubGVuZ3RoJiZ0LmVuZGVkPzA6dC5vYmplY3RNb2RlPzE6ZT09PWU/KGU+dC5oaWdoV2F0ZXJNYXJrJiYodC5oaWdoV2F0ZXJNYXJrPXAoZSkpLGU8PXQubGVuZ3RoP2U6dC5lbmRlZD90Lmxlbmd0aDoodC5uZWVkUmVhZGFibGU9ITAsMCkpOnQuZmxvd2luZyYmdC5sZW5ndGg/dC5idWZmZXIuaGVhZC5kYXRhLmxlbmd0aDp0Lmxlbmd0aH1mdW5jdGlvbiBnKGUsdCl7aWYoeChcIm9uRW9mQ2h1bmtcIiksIXQuZW5kZWQpe2lmKHQuZGVjb2Rlcil7dmFyIG49dC5kZWNvZGVyLmVuZCgpO24mJm4ubGVuZ3RoJiYodC5idWZmZXIucHVzaChuKSx0Lmxlbmd0aCs9dC5vYmplY3RNb2RlPzE6bi5sZW5ndGgpfXQuZW5kZWQ9ITAsdC5zeW5jP18oZSk6KHQubmVlZFJlYWRhYmxlPSExLCF0LmVtaXR0ZWRSZWFkYWJsZSYmKHQuZW1pdHRlZFJlYWRhYmxlPSEwLGgoZSkpKX19ZnVuY3Rpb24gXyhlKXt2YXIgdD1lLl9yZWFkYWJsZVN0YXRlO3goXCJlbWl0UmVhZGFibGVcIix0Lm5lZWRSZWFkYWJsZSx0LmVtaXR0ZWRSZWFkYWJsZSksdC5uZWVkUmVhZGFibGU9ITEsdC5lbWl0dGVkUmVhZGFibGV8fCh4KFwiZW1pdFJlYWRhYmxlXCIsdC5mbG93aW5nKSx0LmVtaXR0ZWRSZWFkYWJsZT0hMCxuLm5leHRUaWNrKGgsZSkpfWZ1bmN0aW9uIGgoZSl7dmFyIHQ9ZS5fcmVhZGFibGVTdGF0ZTt4KFwiZW1pdFJlYWRhYmxlX1wiLHQuZGVzdHJveWVkLHQubGVuZ3RoLHQuZW5kZWQpLCF0LmRlc3Ryb3llZCYmKHQubGVuZ3RofHx0LmVuZGVkKSYmKGUuZW1pdChcInJlYWRhYmxlXCIpLHQuZW1pdHRlZFJlYWRhYmxlPSExKSx0Lm5lZWRSZWFkYWJsZT0hdC5mbG93aW5nJiYhdC5lbmRlZCYmdC5sZW5ndGg8PXQuaGlnaFdhdGVyTWFyayxTKGUpfWZ1bmN0aW9uIG0oZSx0KXt0LnJlYWRpbmdNb3JlfHwodC5yZWFkaW5nTW9yZT0hMCxuLm5leHRUaWNrKGIsZSx0KSl9ZnVuY3Rpb24gYihlLHQpe2Zvcig7IXQucmVhZGluZyYmIXQuZW5kZWQmJih0Lmxlbmd0aDx0LmhpZ2hXYXRlck1hcmt8fHQuZmxvd2luZyYmMD09PXQubGVuZ3RoKTspe3ZhciBuPXQubGVuZ3RoO2lmKHgoXCJtYXliZVJlYWRNb3JlIHJlYWQgMFwiKSxlLnJlYWQoMCksbj09PXQubGVuZ3RoKWJyZWFrfXQucmVhZGluZ01vcmU9ITF9ZnVuY3Rpb24geShlKXtyZXR1cm4gZnVuY3Rpb24oKXt2YXIgdD1lLl9yZWFkYWJsZVN0YXRlO3goXCJwaXBlT25EcmFpblwiLHQuYXdhaXREcmFpbiksdC5hd2FpdERyYWluJiZ0LmF3YWl0RHJhaW4tLSwwPT09dC5hd2FpdERyYWluJiZEKGUsXCJkYXRhXCIpJiYodC5mbG93aW5nPSEwLFMoZSkpfX1mdW5jdGlvbiBDKGUpe3ZhciB0PWUuX3JlYWRhYmxlU3RhdGU7dC5yZWFkYWJsZUxpc3RlbmluZz0wPGUubGlzdGVuZXJDb3VudChcInJlYWRhYmxlXCIpLHQucmVzdW1lU2NoZWR1bGVkJiYhdC5wYXVzZWQ/dC5mbG93aW5nPSEwOjA8ZS5saXN0ZW5lckNvdW50KFwiZGF0YVwiKSYmZS5yZXN1bWUoKX1mdW5jdGlvbiBSKGUpe3goXCJyZWFkYWJsZSBuZXh0dGljayByZWFkIDBcIiksZS5yZWFkKDApfWZ1bmN0aW9uIEUoZSx0KXt0LnJlc3VtZVNjaGVkdWxlZHx8KHQucmVzdW1lU2NoZWR1bGVkPSEwLG4ubmV4dFRpY2sodyxlLHQpKX1mdW5jdGlvbiB3KGUsdCl7eChcInJlc3VtZVwiLHQucmVhZGluZyksdC5yZWFkaW5nfHxlLnJlYWQoMCksdC5yZXN1bWVTY2hlZHVsZWQ9ITEsZS5lbWl0KFwicmVzdW1lXCIpLFMoZSksdC5mbG93aW5nJiYhdC5yZWFkaW5nJiZlLnJlYWQoMCl9ZnVuY3Rpb24gUyhlKXt2YXIgdD1lLl9yZWFkYWJsZVN0YXRlO2Zvcih4KFwiZmxvd1wiLHQuZmxvd2luZyk7dC5mbG93aW5nJiZudWxsIT09ZS5yZWFkKCk7KTt9ZnVuY3Rpb24gVChlLHQpe2lmKDA9PT10Lmxlbmd0aClyZXR1cm4gbnVsbDt2YXIgbjtyZXR1cm4gdC5vYmplY3RNb2RlP249dC5idWZmZXIuc2hpZnQoKTohZXx8ZT49dC5sZW5ndGg/KG49dC5kZWNvZGVyP3QuYnVmZmVyLmpvaW4oXCJcIik6MT09PXQuYnVmZmVyLmxlbmd0aD90LmJ1ZmZlci5maXJzdCgpOnQuYnVmZmVyLmNvbmNhdCh0Lmxlbmd0aCksdC5idWZmZXIuY2xlYXIoKSk6bj10LmJ1ZmZlci5jb25zdW1lKGUsdC5kZWNvZGVyKSxufWZ1bmN0aW9uIHYoZSl7dmFyIHQ9ZS5fcmVhZGFibGVTdGF0ZTt4KFwiZW5kUmVhZGFibGVcIix0LmVuZEVtaXR0ZWQpLHQuZW5kRW1pdHRlZHx8KHQuZW5kZWQ9ITAsbi5uZXh0VGljayhrLHQsZSkpfWZ1bmN0aW9uIGsoZSx0KXtpZih4KFwiZW5kUmVhZGFibGVOVFwiLGUuZW5kRW1pdHRlZCxlLmxlbmd0aCksIWUuZW5kRW1pdHRlZCYmMD09PWUubGVuZ3RoJiYoZS5lbmRFbWl0dGVkPSEwLHQucmVhZGFibGU9ITEsdC5lbWl0KFwiZW5kXCIpLGUuYXV0b0Rlc3Ryb3kpKXt2YXIgbj10Ll93cml0YWJsZVN0YXRlOyghbnx8bi5hdXRvRGVzdHJveSYmbi5maW5pc2hlZCkmJnQuZGVzdHJveSgpfX1mdW5jdGlvbiBMKGUsdCl7Zm9yKHZhciBuPTAscj1lLmxlbmd0aDtuPHI7bisrKWlmKGVbbl09PT10KXJldHVybiBuO3JldHVybi0xfXQuZXhwb3J0cz1zO3ZhciBBO3MuUmVhZGFibGVTdGF0ZT1kO3ZhciB4LE49ZShcImV2ZW50c1wiKS5FdmVudEVtaXR0ZXIsRD1mdW5jdGlvbihlLHQpe3JldHVybiBlLmxpc3RlbmVycyh0KS5sZW5ndGh9LEk9ZShcIi4vaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW1cIiksUD1lKFwiYnVmZmVyXCIpLkJ1ZmZlcixNPXIuVWludDhBcnJheXx8ZnVuY3Rpb24oKXt9LE89ZShcInV0aWxcIik7eD1PJiZPLmRlYnVnbG9nP08uZGVidWdsb2coXCJzdHJlYW1cIik6ZnVuY3Rpb24oKXt9O3ZhciBGLEIsVSxqPWUoXCIuL2ludGVybmFsL3N0cmVhbXMvYnVmZmVyX2xpc3RcIikscT1lKFwiLi9pbnRlcm5hbC9zdHJlYW1zL2Rlc3Ryb3lcIiksVz1lKFwiLi9pbnRlcm5hbC9zdHJlYW1zL3N0YXRlXCIpLEg9Vy5nZXRIaWdoV2F0ZXJNYXJrLFk9ZShcIi4uL2Vycm9yc1wiKS5jb2RlcyxWPVkuRVJSX0lOVkFMSURfQVJHX1RZUEUsej1ZLkVSUl9TVFJFQU1fUFVTSF9BRlRFUl9FT0YsRz1ZLkVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVELEs9WS5FUlJfU1RSRUFNX1VOU0hJRlRfQUZURVJfRU5EX0VWRU5UO2UoXCJpbmhlcml0c1wiKShzLEkpO3ZhciBYPXEuZXJyb3JPckRlc3Ryb3ksJD1bXCJlcnJvclwiLFwiY2xvc2VcIixcImRlc3Ryb3lcIixcInBhdXNlXCIsXCJyZXN1bWVcIl07T2JqZWN0LmRlZmluZVByb3BlcnR5KHMucHJvdG90eXBlLFwiZGVzdHJveWVkXCIse2VudW1lcmFibGU6ITEsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHZvaWQgMCE9PXRoaXMuX3JlYWRhYmxlU3RhdGUmJnRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkfSxzZXQ6ZnVuY3Rpb24oZSl7dGhpcy5fcmVhZGFibGVTdGF0ZSYmKHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkPWUpfX0pLHMucHJvdG90eXBlLmRlc3Ryb3k9cS5kZXN0cm95LHMucHJvdG90eXBlLl91bmRlc3Ryb3k9cS51bmRlc3Ryb3kscy5wcm90b3R5cGUuX2Rlc3Ryb3k9ZnVuY3Rpb24oZSx0KXt0KGUpfSxzLnByb3RvdHlwZS5wdXNoPWZ1bmN0aW9uKGUsdCl7dmFyIG4scj10aGlzLl9yZWFkYWJsZVN0YXRlO3JldHVybiByLm9iamVjdE1vZGU/bj0hMDpcInN0cmluZ1wiPT10eXBlb2YgZSYmKHQ9dHx8ci5kZWZhdWx0RW5jb2RpbmcsdCE9PXIuZW5jb2RpbmcmJihlPVAuZnJvbShlLHQpLHQ9XCJcIiksbj0hMCksbCh0aGlzLGUsdCwhMSxuKX0scy5wcm90b3R5cGUudW5zaGlmdD1mdW5jdGlvbihlKXtyZXR1cm4gbCh0aGlzLGUsbnVsbCwhMCwhMSl9LHMucHJvdG90eXBlLmlzUGF1c2VkPWZ1bmN0aW9uKCl7cmV0dXJuITE9PT10aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmd9LHMucHJvdG90eXBlLnNldEVuY29kaW5nPWZ1bmN0aW9uKHQpe0Z8fChGPWUoXCJzdHJpbmdfZGVjb2Rlci9cIikuU3RyaW5nRGVjb2Rlcik7dmFyIG49bmV3IEYodCk7dGhpcy5fcmVhZGFibGVTdGF0ZS5kZWNvZGVyPW4sdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmNvZGluZz10aGlzLl9yZWFkYWJsZVN0YXRlLmRlY29kZXIuZW5jb2Rpbmc7Zm9yKHZhciByPXRoaXMuX3JlYWRhYmxlU3RhdGUuYnVmZmVyLmhlYWQsYT1cIlwiO251bGwhPT1yOylhKz1uLndyaXRlKHIuZGF0YSkscj1yLm5leHQ7cmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuYnVmZmVyLmNsZWFyKCksXCJcIiE9PWEmJnRoaXMuX3JlYWRhYmxlU3RhdGUuYnVmZmVyLnB1c2goYSksdGhpcy5fcmVhZGFibGVTdGF0ZS5sZW5ndGg9YS5sZW5ndGgsdGhpc307cy5wcm90b3R5cGUucmVhZD1mdW5jdGlvbihlKXt4KFwicmVhZFwiLGUpLGU9cGFyc2VJbnQoZSwxMCk7dmFyIHQ9dGhpcy5fcmVhZGFibGVTdGF0ZSxyPWU7aWYoMCE9PWUmJih0LmVtaXR0ZWRSZWFkYWJsZT0hMSksMD09PWUmJnQubmVlZFJlYWRhYmxlJiYoKDA9PT10LmhpZ2hXYXRlck1hcms/MDx0Lmxlbmd0aDp0Lmxlbmd0aD49dC5oaWdoV2F0ZXJNYXJrKXx8dC5lbmRlZCkpcmV0dXJuIHgoXCJyZWFkOiBlbWl0UmVhZGFibGVcIix0Lmxlbmd0aCx0LmVuZGVkKSwwPT09dC5sZW5ndGgmJnQuZW5kZWQ/dih0aGlzKTpfKHRoaXMpLG51bGw7aWYoZT1mKGUsdCksMD09PWUmJnQuZW5kZWQpcmV0dXJuIDA9PT10Lmxlbmd0aCYmdih0aGlzKSxudWxsO3ZhciBhPXQubmVlZFJlYWRhYmxlO3goXCJuZWVkIHJlYWRhYmxlXCIsYSksKDA9PT10Lmxlbmd0aHx8dC5sZW5ndGgtZTx0LmhpZ2hXYXRlck1hcmspJiYoYT0hMCx4KFwibGVuZ3RoIGxlc3MgdGhhbiB3YXRlcm1hcmtcIixhKSksdC5lbmRlZHx8dC5yZWFkaW5nPyhhPSExLHgoXCJyZWFkaW5nIG9yIGVuZGVkXCIsYSkpOmEmJih4KFwiZG8gcmVhZFwiKSx0LnJlYWRpbmc9ITAsdC5zeW5jPSEwLDA9PT10Lmxlbmd0aCYmKHQubmVlZFJlYWRhYmxlPSEwKSx0aGlzLl9yZWFkKHQuaGlnaFdhdGVyTWFyayksdC5zeW5jPSExLCF0LnJlYWRpbmcmJihlPWYocix0KSkpO3ZhciBvO3JldHVybiBvPTA8ZT9UKGUsdCk6bnVsbCxudWxsPT09bz8odC5uZWVkUmVhZGFibGU9dC5sZW5ndGg8PXQuaGlnaFdhdGVyTWFyayxlPTApOih0Lmxlbmd0aC09ZSx0LmF3YWl0RHJhaW49MCksMD09PXQubGVuZ3RoJiYoIXQuZW5kZWQmJih0Lm5lZWRSZWFkYWJsZT0hMCksciE9PWUmJnQuZW5kZWQmJnYodGhpcykpLG51bGwhPT1vJiZ0aGlzLmVtaXQoXCJkYXRhXCIsbyksb30scy5wcm90b3R5cGUuX3JlYWQ9ZnVuY3Rpb24oKXtYKHRoaXMsbmV3IEcoXCJfcmVhZCgpXCIpKX0scy5wcm90b3R5cGUucGlwZT1mdW5jdGlvbihlLHQpe2Z1bmN0aW9uIHIoZSx0KXt4KFwib251bnBpcGVcIiksZT09PXAmJnQmJiExPT09dC5oYXNVbnBpcGVkJiYodC5oYXNVbnBpcGVkPSEwLG8oKSl9ZnVuY3Rpb24gYSgpe3goXCJvbmVuZFwiKSxlLmVuZCgpfWZ1bmN0aW9uIG8oKXt4KFwiY2xlYW51cFwiKSxlLnJlbW92ZUxpc3RlbmVyKFwiY2xvc2VcIixsKSxlLnJlbW92ZUxpc3RlbmVyKFwiZmluaXNoXCIsYyksZS5yZW1vdmVMaXN0ZW5lcihcImRyYWluXCIsaCksZS5yZW1vdmVMaXN0ZW5lcihcImVycm9yXCIscyksZS5yZW1vdmVMaXN0ZW5lcihcInVucGlwZVwiLHIpLHAucmVtb3ZlTGlzdGVuZXIoXCJlbmRcIixhKSxwLnJlbW92ZUxpc3RlbmVyKFwiZW5kXCIsdSkscC5yZW1vdmVMaXN0ZW5lcihcImRhdGFcIixkKSxtPSEwLGYuYXdhaXREcmFpbiYmKCFlLl93cml0YWJsZVN0YXRlfHxlLl93cml0YWJsZVN0YXRlLm5lZWREcmFpbikmJmgoKX1mdW5jdGlvbiBkKHQpe3goXCJvbmRhdGFcIik7dmFyIG49ZS53cml0ZSh0KTt4KFwiZGVzdC53cml0ZVwiLG4pLCExPT09biYmKCgxPT09Zi5waXBlc0NvdW50JiZmLnBpcGVzPT09ZXx8MTxmLnBpcGVzQ291bnQmJi0xIT09TChmLnBpcGVzLGUpKSYmIW0mJih4KFwiZmFsc2Ugd3JpdGUgcmVzcG9uc2UsIHBhdXNlXCIsZi5hd2FpdERyYWluKSxmLmF3YWl0RHJhaW4rKykscC5wYXVzZSgpKX1mdW5jdGlvbiBzKHQpe3goXCJvbmVycm9yXCIsdCksdSgpLGUucmVtb3ZlTGlzdGVuZXIoXCJlcnJvclwiLHMpLDA9PT1EKGUsXCJlcnJvclwiKSYmWChlLHQpfWZ1bmN0aW9uIGwoKXtlLnJlbW92ZUxpc3RlbmVyKFwiZmluaXNoXCIsYyksdSgpfWZ1bmN0aW9uIGMoKXt4KFwib25maW5pc2hcIiksZS5yZW1vdmVMaXN0ZW5lcihcImNsb3NlXCIsbCksdSgpfWZ1bmN0aW9uIHUoKXt4KFwidW5waXBlXCIpLHAudW5waXBlKGUpfXZhciBwPXRoaXMsZj10aGlzLl9yZWFkYWJsZVN0YXRlO3N3aXRjaChmLnBpcGVzQ291bnQpe2Nhc2UgMDpmLnBpcGVzPWU7YnJlYWs7Y2FzZSAxOmYucGlwZXM9W2YucGlwZXMsZV07YnJlYWs7ZGVmYXVsdDpmLnBpcGVzLnB1c2goZSk7fWYucGlwZXNDb3VudCs9MSx4KFwicGlwZSBjb3VudD0lZCBvcHRzPSVqXCIsZi5waXBlc0NvdW50LHQpO3ZhciBnPSghdHx8ITEhPT10LmVuZCkmJmUhPT1uLnN0ZG91dCYmZSE9PW4uc3RkZXJyLF89Zz9hOnU7Zi5lbmRFbWl0dGVkP24ubmV4dFRpY2soXyk6cC5vbmNlKFwiZW5kXCIsXyksZS5vbihcInVucGlwZVwiLHIpO3ZhciBoPXkocCk7ZS5vbihcImRyYWluXCIsaCk7dmFyIG09ITE7cmV0dXJuIHAub24oXCJkYXRhXCIsZCksaShlLFwiZXJyb3JcIixzKSxlLm9uY2UoXCJjbG9zZVwiLGwpLGUub25jZShcImZpbmlzaFwiLGMpLGUuZW1pdChcInBpcGVcIixwKSxmLmZsb3dpbmd8fCh4KFwicGlwZSByZXN1bWVcIikscC5yZXN1bWUoKSksZX0scy5wcm90b3R5cGUudW5waXBlPWZ1bmN0aW9uKGUpe3ZhciB0PXRoaXMuX3JlYWRhYmxlU3RhdGUsbj17aGFzVW5waXBlZDohMX07aWYoMD09PXQucGlwZXNDb3VudClyZXR1cm4gdGhpcztpZigxPT09dC5waXBlc0NvdW50KXJldHVybiBlJiZlIT09dC5waXBlcz90aGlzOihlfHwoZT10LnBpcGVzKSx0LnBpcGVzPW51bGwsdC5waXBlc0NvdW50PTAsdC5mbG93aW5nPSExLGUmJmUuZW1pdChcInVucGlwZVwiLHRoaXMsbiksdGhpcyk7aWYoIWUpe3ZhciByPXQucGlwZXMsYT10LnBpcGVzQ291bnQ7dC5waXBlcz1udWxsLHQucGlwZXNDb3VudD0wLHQuZmxvd2luZz0hMTtmb3IodmFyIG89MDtvPGE7bysrKXJbb10uZW1pdChcInVucGlwZVwiLHRoaXMse2hhc1VucGlwZWQ6ITF9KTtyZXR1cm4gdGhpc312YXIgZD1MKHQucGlwZXMsZSk7cmV0dXJuLTE9PT1kP3RoaXM6KHQucGlwZXMuc3BsaWNlKGQsMSksdC5waXBlc0NvdW50LT0xLDE9PT10LnBpcGVzQ291bnQmJih0LnBpcGVzPXQucGlwZXNbMF0pLGUuZW1pdChcInVucGlwZVwiLHRoaXMsbiksdGhpcyl9LHMucHJvdG90eXBlLm9uPWZ1bmN0aW9uKGUsdCl7dmFyIHI9SS5wcm90b3R5cGUub24uY2FsbCh0aGlzLGUsdCksYT10aGlzLl9yZWFkYWJsZVN0YXRlO3JldHVyblwiZGF0YVwiPT09ZT8oYS5yZWFkYWJsZUxpc3RlbmluZz0wPHRoaXMubGlzdGVuZXJDb3VudChcInJlYWRhYmxlXCIpLCExIT09YS5mbG93aW5nJiZ0aGlzLnJlc3VtZSgpKTpcInJlYWRhYmxlXCI9PWUmJiFhLmVuZEVtaXR0ZWQmJiFhLnJlYWRhYmxlTGlzdGVuaW5nJiYoYS5yZWFkYWJsZUxpc3RlbmluZz1hLm5lZWRSZWFkYWJsZT0hMCxhLmZsb3dpbmc9ITEsYS5lbWl0dGVkUmVhZGFibGU9ITEseChcIm9uIHJlYWRhYmxlXCIsYS5sZW5ndGgsYS5yZWFkaW5nKSxhLmxlbmd0aD9fKHRoaXMpOiFhLnJlYWRpbmcmJm4ubmV4dFRpY2soUix0aGlzKSkscn0scy5wcm90b3R5cGUuYWRkTGlzdGVuZXI9cy5wcm90b3R5cGUub24scy5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXI9ZnVuY3Rpb24oZSx0KXt2YXIgcj1JLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lci5jYWxsKHRoaXMsZSx0KTtyZXR1cm5cInJlYWRhYmxlXCI9PT1lJiZuLm5leHRUaWNrKEMsdGhpcykscn0scy5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzPWZ1bmN0aW9uKGUpe3ZhciB0PUkucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycy5hcHBseSh0aGlzLGFyZ3VtZW50cyk7cmV0dXJuKFwicmVhZGFibGVcIj09PWV8fHZvaWQgMD09PWUpJiZuLm5leHRUaWNrKEMsdGhpcyksdH0scy5wcm90b3R5cGUucmVzdW1lPWZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5fcmVhZGFibGVTdGF0ZTtyZXR1cm4gZS5mbG93aW5nfHwoeChcInJlc3VtZVwiKSxlLmZsb3dpbmc9IWUucmVhZGFibGVMaXN0ZW5pbmcsRSh0aGlzLGUpKSxlLnBhdXNlZD0hMSx0aGlzfSxzLnByb3RvdHlwZS5wYXVzZT1mdW5jdGlvbigpe3JldHVybiB4KFwiY2FsbCBwYXVzZSBmbG93aW5nPSVqXCIsdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nKSwhMSE9PXRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyYmKHgoXCJwYXVzZVwiKSx0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmc9ITEsdGhpcy5lbWl0KFwicGF1c2VcIikpLHRoaXMuX3JlYWRhYmxlU3RhdGUucGF1c2VkPSEwLHRoaXN9LHMucHJvdG90eXBlLndyYXA9ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcyxyPXRoaXMuX3JlYWRhYmxlU3RhdGUsYT0hMTtmb3IodmFyIG8gaW4gZS5vbihcImVuZFwiLGZ1bmN0aW9uKCl7aWYoeChcIndyYXBwZWQgZW5kXCIpLHIuZGVjb2RlciYmIXIuZW5kZWQpe3ZhciBlPXIuZGVjb2Rlci5lbmQoKTtlJiZlLmxlbmd0aCYmdC5wdXNoKGUpfXQucHVzaChudWxsKX0pLGUub24oXCJkYXRhXCIsZnVuY3Rpb24obil7aWYoKHgoXCJ3cmFwcGVkIGRhdGFcIiksci5kZWNvZGVyJiYobj1yLmRlY29kZXIud3JpdGUobikpLCEoci5vYmplY3RNb2RlJiYobnVsbD09PW58fHZvaWQgMD09PW4pKSkmJihyLm9iamVjdE1vZGV8fG4mJm4ubGVuZ3RoKSl7dmFyIG89dC5wdXNoKG4pO298fChhPSEwLGUucGF1c2UoKSl9fSksZSl2b2lkIDA9PT10aGlzW29dJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBlW29dJiYodGhpc1tvXT1mdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gZVt0XS5hcHBseShlLGFyZ3VtZW50cyl9fShvKSk7Zm9yKHZhciBpPTA7aTwkLmxlbmd0aDtpKyspZS5vbigkW2ldLHRoaXMuZW1pdC5iaW5kKHRoaXMsJFtpXSkpO3JldHVybiB0aGlzLl9yZWFkPWZ1bmN0aW9uKHQpe3goXCJ3cmFwcGVkIF9yZWFkXCIsdCksYSYmKGE9ITEsZS5yZXN1bWUoKSl9LHRoaXN9LFwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmKHMucHJvdG90eXBlW1N5bWJvbC5hc3luY0l0ZXJhdG9yXT1mdW5jdGlvbigpe3JldHVybiB2b2lkIDA9PT1CJiYoQj1lKFwiLi9pbnRlcm5hbC9zdHJlYW1zL2FzeW5jX2l0ZXJhdG9yXCIpKSxCKHRoaXMpfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHMucHJvdG90eXBlLFwicmVhZGFibGVIaWdoV2F0ZXJNYXJrXCIse2VudW1lcmFibGU6ITEsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuaGlnaFdhdGVyTWFya319KSxPYmplY3QuZGVmaW5lUHJvcGVydHkocy5wcm90b3R5cGUsXCJyZWFkYWJsZUJ1ZmZlclwiLHtlbnVtZXJhYmxlOiExLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlJiZ0aGlzLl9yZWFkYWJsZVN0YXRlLmJ1ZmZlcn19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkocy5wcm90b3R5cGUsXCJyZWFkYWJsZUZsb3dpbmdcIix7ZW51bWVyYWJsZTohMSxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nfSxzZXQ6ZnVuY3Rpb24oZSl7dGhpcy5fcmVhZGFibGVTdGF0ZSYmKHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZz1lKX19KSxzLl9mcm9tTGlzdD1ULE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzLnByb3RvdHlwZSxcInJlYWRhYmxlTGVuZ3RoXCIse2VudW1lcmFibGU6ITEsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUubGVuZ3RofX0pLFwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmKHMuZnJvbT1mdW5jdGlvbih0LG4pe3JldHVybiB2b2lkIDA9PT1VJiYoVT1lKFwiLi9pbnRlcm5hbC9zdHJlYW1zL2Zyb21cIikpLFUocyx0LG4pfSl9KS5jYWxsKHRoaXMpfSkuY2FsbCh0aGlzLGUoXCJfcHJvY2Vzc1wiKSxcInVuZGVmaW5lZFwiPT10eXBlb2YgZ2xvYmFsP1widW5kZWZpbmVkXCI9PXR5cGVvZiBzZWxmP1widW5kZWZpbmVkXCI9PXR5cGVvZiB3aW5kb3c/e306d2luZG93OnNlbGY6Z2xvYmFsKX0se1wiLi4vZXJyb3JzXCI6MTUsXCIuL19zdHJlYW1fZHVwbGV4XCI6MTYsXCIuL2ludGVybmFsL3N0cmVhbXMvYXN5bmNfaXRlcmF0b3JcIjoyMSxcIi4vaW50ZXJuYWwvc3RyZWFtcy9idWZmZXJfbGlzdFwiOjIyLFwiLi9pbnRlcm5hbC9zdHJlYW1zL2Rlc3Ryb3lcIjoyMyxcIi4vaW50ZXJuYWwvc3RyZWFtcy9mcm9tXCI6MjUsXCIuL2ludGVybmFsL3N0cmVhbXMvc3RhdGVcIjoyNyxcIi4vaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW1cIjoyOCxfcHJvY2VzczoxMixidWZmZXI6MyxldmVudHM6Nyxpbmhlcml0czoxMCxcInN0cmluZ19kZWNvZGVyL1wiOjMxLHV0aWw6Mn1dLDE5OltmdW5jdGlvbihlLHQpeyd1c2Ugc3RyaWN0JztmdW5jdGlvbiBuKGUsdCl7dmFyIG49dGhpcy5fdHJhbnNmb3JtU3RhdGU7bi50cmFuc2Zvcm1pbmc9ITE7dmFyIHI9bi53cml0ZWNiO2lmKG51bGw9PT1yKXJldHVybiB0aGlzLmVtaXQoXCJlcnJvclwiLG5ldyBzKTtuLndyaXRlY2h1bms9bnVsbCxuLndyaXRlY2I9bnVsbCxudWxsIT10JiZ0aGlzLnB1c2godCkscihlKTt2YXIgYT10aGlzLl9yZWFkYWJsZVN0YXRlO2EucmVhZGluZz0hMSwoYS5uZWVkUmVhZGFibGV8fGEubGVuZ3RoPGEuaGlnaFdhdGVyTWFyaykmJnRoaXMuX3JlYWQoYS5oaWdoV2F0ZXJNYXJrKX1mdW5jdGlvbiByKGUpe3JldHVybiB0aGlzIGluc3RhbmNlb2Ygcj92b2lkKHUuY2FsbCh0aGlzLGUpLHRoaXMuX3RyYW5zZm9ybVN0YXRlPXthZnRlclRyYW5zZm9ybTpuLmJpbmQodGhpcyksbmVlZFRyYW5zZm9ybTohMSx0cmFuc2Zvcm1pbmc6ITEsd3JpdGVjYjpudWxsLHdyaXRlY2h1bms6bnVsbCx3cml0ZWVuY29kaW5nOm51bGx9LHRoaXMuX3JlYWRhYmxlU3RhdGUubmVlZFJlYWRhYmxlPSEwLHRoaXMuX3JlYWRhYmxlU3RhdGUuc3luYz0hMSxlJiYoXCJmdW5jdGlvblwiPT10eXBlb2YgZS50cmFuc2Zvcm0mJih0aGlzLl90cmFuc2Zvcm09ZS50cmFuc2Zvcm0pLFwiZnVuY3Rpb25cIj09dHlwZW9mIGUuZmx1c2gmJih0aGlzLl9mbHVzaD1lLmZsdXNoKSksdGhpcy5vbihcInByZWZpbmlzaFwiLGEpKTpuZXcgcihlKX1mdW5jdGlvbiBhKCl7dmFyIGU9dGhpcztcImZ1bmN0aW9uXCIhPXR5cGVvZiB0aGlzLl9mbHVzaHx8dGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQ/byh0aGlzLG51bGwsbnVsbCk6dGhpcy5fZmx1c2goZnVuY3Rpb24odCxuKXtvKGUsdCxuKX0pfWZ1bmN0aW9uIG8oZSx0LG4pe2lmKHQpcmV0dXJuIGUuZW1pdChcImVycm9yXCIsdCk7aWYobnVsbCE9biYmZS5wdXNoKG4pLGUuX3dyaXRhYmxlU3RhdGUubGVuZ3RoKXRocm93IG5ldyBjO2lmKGUuX3RyYW5zZm9ybVN0YXRlLnRyYW5zZm9ybWluZyl0aHJvdyBuZXcgbDtyZXR1cm4gZS5wdXNoKG51bGwpfXQuZXhwb3J0cz1yO3ZhciBpPWUoXCIuLi9lcnJvcnNcIikuY29kZXMsZD1pLkVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVELHM9aS5FUlJfTVVMVElQTEVfQ0FMTEJBQ0ssbD1pLkVSUl9UUkFOU0ZPUk1fQUxSRUFEWV9UUkFOU0ZPUk1JTkcsYz1pLkVSUl9UUkFOU0ZPUk1fV0lUSF9MRU5HVEhfMCx1PWUoXCIuL19zdHJlYW1fZHVwbGV4XCIpO2UoXCJpbmhlcml0c1wiKShyLHUpLHIucHJvdG90eXBlLnB1c2g9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdGhpcy5fdHJhbnNmb3JtU3RhdGUubmVlZFRyYW5zZm9ybT0hMSx1LnByb3RvdHlwZS5wdXNoLmNhbGwodGhpcyxlLHQpfSxyLnByb3RvdHlwZS5fdHJhbnNmb3JtPWZ1bmN0aW9uKGUsdCxuKXtuKG5ldyBkKFwiX3RyYW5zZm9ybSgpXCIpKX0sci5wcm90b3R5cGUuX3dyaXRlPWZ1bmN0aW9uKGUsdCxuKXt2YXIgcj10aGlzLl90cmFuc2Zvcm1TdGF0ZTtpZihyLndyaXRlY2I9bixyLndyaXRlY2h1bms9ZSxyLndyaXRlZW5jb2Rpbmc9dCwhci50cmFuc2Zvcm1pbmcpe3ZhciBhPXRoaXMuX3JlYWRhYmxlU3RhdGU7KHIubmVlZFRyYW5zZm9ybXx8YS5uZWVkUmVhZGFibGV8fGEubGVuZ3RoPGEuaGlnaFdhdGVyTWFyaykmJnRoaXMuX3JlYWQoYS5oaWdoV2F0ZXJNYXJrKX19LHIucHJvdG90eXBlLl9yZWFkPWZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5fdHJhbnNmb3JtU3RhdGU7bnVsbD09PWUud3JpdGVjaHVua3x8ZS50cmFuc2Zvcm1pbmc/ZS5uZWVkVHJhbnNmb3JtPSEwOihlLnRyYW5zZm9ybWluZz0hMCx0aGlzLl90cmFuc2Zvcm0oZS53cml0ZWNodW5rLGUud3JpdGVlbmNvZGluZyxlLmFmdGVyVHJhbnNmb3JtKSl9LHIucHJvdG90eXBlLl9kZXN0cm95PWZ1bmN0aW9uKGUsdCl7dS5wcm90b3R5cGUuX2Rlc3Ryb3kuY2FsbCh0aGlzLGUsZnVuY3Rpb24oZSl7dChlKX0pfX0se1wiLi4vZXJyb3JzXCI6MTUsXCIuL19zdHJlYW1fZHVwbGV4XCI6MTYsaW5oZXJpdHM6MTB9XSwyMDpbZnVuY3Rpb24oZSx0KXsoZnVuY3Rpb24obixyKXsoZnVuY3Rpb24oKXsndXNlIHN0cmljdCc7ZnVuY3Rpb24gYShlKXt2YXIgdD10aGlzO3RoaXMubmV4dD1udWxsLHRoaXMuZW50cnk9bnVsbCx0aGlzLmZpbmlzaD1mdW5jdGlvbigpe3YodCxlKX19ZnVuY3Rpb24gbyhlKXtyZXR1cm4geC5mcm9tKGUpfWZ1bmN0aW9uIGkoZSl7cmV0dXJuIHguaXNCdWZmZXIoZSl8fGUgaW5zdGFuY2VvZiBOfWZ1bmN0aW9uIGQoKXt9ZnVuY3Rpb24gcyh0LG4scil7az1rfHxlKFwiLi9fc3RyZWFtX2R1cGxleFwiKSx0PXR8fHt9LFwiYm9vbGVhblwiIT10eXBlb2YgciYmKHI9biBpbnN0YW5jZW9mIGspLHRoaXMub2JqZWN0TW9kZT0hIXQub2JqZWN0TW9kZSxyJiYodGhpcy5vYmplY3RNb2RlPXRoaXMub2JqZWN0TW9kZXx8ISF0LndyaXRhYmxlT2JqZWN0TW9kZSksdGhpcy5oaWdoV2F0ZXJNYXJrPVAodGhpcyx0LFwid3JpdGFibGVIaWdoV2F0ZXJNYXJrXCIsciksdGhpcy5maW5hbENhbGxlZD0hMSx0aGlzLm5lZWREcmFpbj0hMSx0aGlzLmVuZGluZz0hMSx0aGlzLmVuZGVkPSExLHRoaXMuZmluaXNoZWQ9ITEsdGhpcy5kZXN0cm95ZWQ9ITE7dmFyIG89ITE9PT10LmRlY29kZVN0cmluZ3M7dGhpcy5kZWNvZGVTdHJpbmdzPSFvLHRoaXMuZGVmYXVsdEVuY29kaW5nPXQuZGVmYXVsdEVuY29kaW5nfHxcInV0ZjhcIix0aGlzLmxlbmd0aD0wLHRoaXMud3JpdGluZz0hMSx0aGlzLmNvcmtlZD0wLHRoaXMuc3luYz0hMCx0aGlzLmJ1ZmZlclByb2Nlc3Npbmc9ITEsdGhpcy5vbndyaXRlPWZ1bmN0aW9uKGUpe20obixlKX0sdGhpcy53cml0ZWNiPW51bGwsdGhpcy53cml0ZWxlbj0wLHRoaXMuYnVmZmVyZWRSZXF1ZXN0PW51bGwsdGhpcy5sYXN0QnVmZmVyZWRSZXF1ZXN0PW51bGwsdGhpcy5wZW5kaW5nY2I9MCx0aGlzLnByZWZpbmlzaGVkPSExLHRoaXMuZXJyb3JFbWl0dGVkPSExLHRoaXMuZW1pdENsb3NlPSExIT09dC5lbWl0Q2xvc2UsdGhpcy5hdXRvRGVzdHJveT0hIXQuYXV0b0Rlc3Ryb3ksdGhpcy5idWZmZXJlZFJlcXVlc3RDb3VudD0wLHRoaXMuY29ya2VkUmVxdWVzdHNGcmVlPW5ldyBhKHRoaXMpfWZ1bmN0aW9uIGwodCl7az1rfHxlKFwiLi9fc3RyZWFtX2R1cGxleFwiKTt2YXIgbj10aGlzIGluc3RhbmNlb2YgaztyZXR1cm4gbnx8Vi5jYWxsKGwsdGhpcyk/dm9pZCh0aGlzLl93cml0YWJsZVN0YXRlPW5ldyBzKHQsdGhpcyxuKSx0aGlzLndyaXRhYmxlPSEwLHQmJihcImZ1bmN0aW9uXCI9PXR5cGVvZiB0LndyaXRlJiYodGhpcy5fd3JpdGU9dC53cml0ZSksXCJmdW5jdGlvblwiPT10eXBlb2YgdC53cml0ZXYmJih0aGlzLl93cml0ZXY9dC53cml0ZXYpLFwiZnVuY3Rpb25cIj09dHlwZW9mIHQuZGVzdHJveSYmKHRoaXMuX2Rlc3Ryb3k9dC5kZXN0cm95KSxcImZ1bmN0aW9uXCI9PXR5cGVvZiB0LmZpbmFsJiYodGhpcy5fZmluYWw9dC5maW5hbCkpLEEuY2FsbCh0aGlzKSk6bmV3IGwodCl9ZnVuY3Rpb24gYyhlLHQpe3ZhciByPW5ldyBXO1koZSxyKSxuLm5leHRUaWNrKHQscil9ZnVuY3Rpb24gdShlLHQscixhKXt2YXIgbztyZXR1cm4gbnVsbD09PXI/bz1uZXcgcTpcInN0cmluZ1wiIT10eXBlb2YgciYmIXQub2JqZWN0TW9kZSYmKG89bmV3IE8oXCJjaHVua1wiLFtcInN0cmluZ1wiLFwiQnVmZmVyXCJdLHIpKSwhb3x8KFkoZSxvKSxuLm5leHRUaWNrKGEsbyksITEpfWZ1bmN0aW9uIHAoZSx0LG4pe3JldHVybiBlLm9iamVjdE1vZGV8fCExPT09ZS5kZWNvZGVTdHJpbmdzfHxcInN0cmluZ1wiIT10eXBlb2YgdHx8KHQ9eC5mcm9tKHQsbikpLHR9ZnVuY3Rpb24gZihlLHQsbixyLGEsbyl7aWYoIW4pe3ZhciBpPXAodCxyLGEpO3IhPT1pJiYobj0hMCxhPVwiYnVmZmVyXCIscj1pKX12YXIgZD10Lm9iamVjdE1vZGU/MTpyLmxlbmd0aDt0Lmxlbmd0aCs9ZDt2YXIgcz10Lmxlbmd0aDx0LmhpZ2hXYXRlck1hcms7aWYoc3x8KHQubmVlZERyYWluPSEwKSx0LndyaXRpbmd8fHQuY29ya2VkKXt2YXIgbD10Lmxhc3RCdWZmZXJlZFJlcXVlc3Q7dC5sYXN0QnVmZmVyZWRSZXF1ZXN0PXtjaHVuazpyLGVuY29kaW5nOmEsaXNCdWY6bixjYWxsYmFjazpvLG5leHQ6bnVsbH0sbD9sLm5leHQ9dC5sYXN0QnVmZmVyZWRSZXF1ZXN0OnQuYnVmZmVyZWRSZXF1ZXN0PXQubGFzdEJ1ZmZlcmVkUmVxdWVzdCx0LmJ1ZmZlcmVkUmVxdWVzdENvdW50Kz0xfWVsc2UgZyhlLHQsITEsZCxyLGEsbyk7cmV0dXJuIHN9ZnVuY3Rpb24gZyhlLHQsbixyLGEsbyxpKXt0LndyaXRlbGVuPXIsdC53cml0ZWNiPWksdC53cml0aW5nPSEwLHQuc3luYz0hMCx0LmRlc3Ryb3llZD90Lm9ud3JpdGUobmV3IGooXCJ3cml0ZVwiKSk6bj9lLl93cml0ZXYoYSx0Lm9ud3JpdGUpOmUuX3dyaXRlKGEsbyx0Lm9ud3JpdGUpLHQuc3luYz0hMX1mdW5jdGlvbiBfKGUsdCxyLGEsbyl7LS10LnBlbmRpbmdjYixyPyhuLm5leHRUaWNrKG8sYSksbi5uZXh0VGljayhTLGUsdCksZS5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQ9ITAsWShlLGEpKToobyhhKSxlLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZD0hMCxZKGUsYSksUyhlLHQpKX1mdW5jdGlvbiBoKGUpe2Uud3JpdGluZz0hMSxlLndyaXRlY2I9bnVsbCxlLmxlbmd0aC09ZS53cml0ZWxlbixlLndyaXRlbGVuPTB9ZnVuY3Rpb24gbShlLHQpe3ZhciByPWUuX3dyaXRhYmxlU3RhdGUsYT1yLnN5bmMsbz1yLndyaXRlY2I7aWYoXCJmdW5jdGlvblwiIT10eXBlb2Ygbyl0aHJvdyBuZXcgQjtpZihoKHIpLHQpXyhlLHIsYSx0LG8pO2Vsc2V7dmFyIGk9UihyKXx8ZS5kZXN0cm95ZWQ7aXx8ci5jb3JrZWR8fHIuYnVmZmVyUHJvY2Vzc2luZ3x8IXIuYnVmZmVyZWRSZXF1ZXN0fHxDKGUsciksYT9uLm5leHRUaWNrKGIsZSxyLGksbyk6YihlLHIsaSxvKX19ZnVuY3Rpb24gYihlLHQsbixyKXtufHx5KGUsdCksdC5wZW5kaW5nY2ItLSxyKCksUyhlLHQpfWZ1bmN0aW9uIHkoZSx0KXswPT09dC5sZW5ndGgmJnQubmVlZERyYWluJiYodC5uZWVkRHJhaW49ITEsZS5lbWl0KFwiZHJhaW5cIikpfWZ1bmN0aW9uIEMoZSx0KXt0LmJ1ZmZlclByb2Nlc3Npbmc9ITA7dmFyIG49dC5idWZmZXJlZFJlcXVlc3Q7aWYoZS5fd3JpdGV2JiZuJiZuLm5leHQpe3ZhciByPXQuYnVmZmVyZWRSZXF1ZXN0Q291bnQsbz1BcnJheShyKSxpPXQuY29ya2VkUmVxdWVzdHNGcmVlO2kuZW50cnk9bjtmb3IodmFyIGQ9MCxzPSEwO247KW9bZF09bixuLmlzQnVmfHwocz0hMSksbj1uLm5leHQsZCs9MTtvLmFsbEJ1ZmZlcnM9cyxnKGUsdCwhMCx0Lmxlbmd0aCxvLFwiXCIsaS5maW5pc2gpLHQucGVuZGluZ2NiKyssdC5sYXN0QnVmZmVyZWRSZXF1ZXN0PW51bGwsaS5uZXh0Pyh0LmNvcmtlZFJlcXVlc3RzRnJlZT1pLm5leHQsaS5uZXh0PW51bGwpOnQuY29ya2VkUmVxdWVzdHNGcmVlPW5ldyBhKHQpLHQuYnVmZmVyZWRSZXF1ZXN0Q291bnQ9MH1lbHNle2Zvcig7bjspe3ZhciBsPW4uY2h1bmssYz1uLmVuY29kaW5nLHU9bi5jYWxsYmFjayxwPXQub2JqZWN0TW9kZT8xOmwubGVuZ3RoO2lmKGcoZSx0LCExLHAsbCxjLHUpLG49bi5uZXh0LHQuYnVmZmVyZWRSZXF1ZXN0Q291bnQtLSx0LndyaXRpbmcpYnJlYWt9bnVsbD09PW4mJih0Lmxhc3RCdWZmZXJlZFJlcXVlc3Q9bnVsbCl9dC5idWZmZXJlZFJlcXVlc3Q9bix0LmJ1ZmZlclByb2Nlc3Npbmc9ITF9ZnVuY3Rpb24gUihlKXtyZXR1cm4gZS5lbmRpbmcmJjA9PT1lLmxlbmd0aCYmbnVsbD09PWUuYnVmZmVyZWRSZXF1ZXN0JiYhZS5maW5pc2hlZCYmIWUud3JpdGluZ31mdW5jdGlvbiBFKGUsdCl7ZS5fZmluYWwoZnVuY3Rpb24obil7dC5wZW5kaW5nY2ItLSxuJiZZKGUsbiksdC5wcmVmaW5pc2hlZD0hMCxlLmVtaXQoXCJwcmVmaW5pc2hcIiksUyhlLHQpfSl9ZnVuY3Rpb24gdyhlLHQpe3QucHJlZmluaXNoZWR8fHQuZmluYWxDYWxsZWR8fChcImZ1bmN0aW9uXCIhPXR5cGVvZiBlLl9maW5hbHx8dC5kZXN0cm95ZWQ/KHQucHJlZmluaXNoZWQ9ITAsZS5lbWl0KFwicHJlZmluaXNoXCIpKToodC5wZW5kaW5nY2IrKyx0LmZpbmFsQ2FsbGVkPSEwLG4ubmV4dFRpY2soRSxlLHQpKSl9ZnVuY3Rpb24gUyhlLHQpe3ZhciBuPVIodCk7aWYobiYmKHcoZSx0KSwwPT09dC5wZW5kaW5nY2ImJih0LmZpbmlzaGVkPSEwLGUuZW1pdChcImZpbmlzaFwiKSx0LmF1dG9EZXN0cm95KSkpe3ZhciByPWUuX3JlYWRhYmxlU3RhdGU7KCFyfHxyLmF1dG9EZXN0cm95JiZyLmVuZEVtaXR0ZWQpJiZlLmRlc3Ryb3koKX1yZXR1cm4gbn1mdW5jdGlvbiBUKGUsdCxyKXt0LmVuZGluZz0hMCxTKGUsdCksciYmKHQuZmluaXNoZWQ/bi5uZXh0VGljayhyKTplLm9uY2UoXCJmaW5pc2hcIixyKSksdC5lbmRlZD0hMCxlLndyaXRhYmxlPSExfWZ1bmN0aW9uIHYoZSx0LG4pe3ZhciByPWUuZW50cnk7Zm9yKGUuZW50cnk9bnVsbDtyOyl7dmFyIGE9ci5jYWxsYmFjazt0LnBlbmRpbmdjYi0tLGEobikscj1yLm5leHR9dC5jb3JrZWRSZXF1ZXN0c0ZyZWUubmV4dD1lfXQuZXhwb3J0cz1sO3ZhciBrO2wuV3JpdGFibGVTdGF0ZT1zO3ZhciBMPXtkZXByZWNhdGU6ZShcInV0aWwtZGVwcmVjYXRlXCIpfSxBPWUoXCIuL2ludGVybmFsL3N0cmVhbXMvc3RyZWFtXCIpLHg9ZShcImJ1ZmZlclwiKS5CdWZmZXIsTj1yLlVpbnQ4QXJyYXl8fGZ1bmN0aW9uKCl7fSxEPWUoXCIuL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveVwiKSxJPWUoXCIuL2ludGVybmFsL3N0cmVhbXMvc3RhdGVcIiksUD1JLmdldEhpZ2hXYXRlck1hcmssTT1lKFwiLi4vZXJyb3JzXCIpLmNvZGVzLE89TS5FUlJfSU5WQUxJRF9BUkdfVFlQRSxGPU0uRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQsQj1NLkVSUl9NVUxUSVBMRV9DQUxMQkFDSyxVPU0uRVJSX1NUUkVBTV9DQU5OT1RfUElQRSxqPU0uRVJSX1NUUkVBTV9ERVNUUk9ZRUQscT1NLkVSUl9TVFJFQU1fTlVMTF9WQUxVRVMsVz1NLkVSUl9TVFJFQU1fV1JJVEVfQUZURVJfRU5ELEg9TS5FUlJfVU5LTk9XTl9FTkNPRElORyxZPUQuZXJyb3JPckRlc3Ryb3k7ZShcImluaGVyaXRzXCIpKGwsQSkscy5wcm90b3R5cGUuZ2V0QnVmZmVyPWZ1bmN0aW9uKCl7Zm9yKHZhciBlPXRoaXMuYnVmZmVyZWRSZXF1ZXN0LHQ9W107ZTspdC5wdXNoKGUpLGU9ZS5uZXh0O3JldHVybiB0fSxmdW5jdGlvbigpe3RyeXtPYmplY3QuZGVmaW5lUHJvcGVydHkocy5wcm90b3R5cGUsXCJidWZmZXJcIix7Z2V0OkwuZGVwcmVjYXRlKGZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZ2V0QnVmZmVyKCl9LFwiX3dyaXRhYmxlU3RhdGUuYnVmZmVyIGlzIGRlcHJlY2F0ZWQuIFVzZSBfd3JpdGFibGVTdGF0ZS5nZXRCdWZmZXIgaW5zdGVhZC5cIixcIkRFUDAwMDNcIil9KX1jYXRjaChlKXt9fSgpO3ZhciBWO1wiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmU3ltYm9sLmhhc0luc3RhbmNlJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBGdW5jdGlvbi5wcm90b3R5cGVbU3ltYm9sLmhhc0luc3RhbmNlXT8oVj1GdW5jdGlvbi5wcm90b3R5cGVbU3ltYm9sLmhhc0luc3RhbmNlXSxPYmplY3QuZGVmaW5lUHJvcGVydHkobCxTeW1ib2wuaGFzSW5zdGFuY2Use3ZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiEhVi5jYWxsKHRoaXMsZSl8fCEodGhpcyE9PWwpJiZlJiZlLl93cml0YWJsZVN0YXRlIGluc3RhbmNlb2Ygc319KSk6Vj1mdW5jdGlvbihlKXtyZXR1cm4gZSBpbnN0YW5jZW9mIHRoaXN9LGwucHJvdG90eXBlLnBpcGU9ZnVuY3Rpb24oKXtZKHRoaXMsbmV3IFUpfSxsLnByb3RvdHlwZS53cml0ZT1mdW5jdGlvbihlLHQsbil7dmFyIHI9dGhpcy5fd3JpdGFibGVTdGF0ZSxhPSExLHM9IXIub2JqZWN0TW9kZSYmaShlKTtyZXR1cm4gcyYmIXguaXNCdWZmZXIoZSkmJihlPW8oZSkpLFwiZnVuY3Rpb25cIj09dHlwZW9mIHQmJihuPXQsdD1udWxsKSxzP3Q9XCJidWZmZXJcIjohdCYmKHQ9ci5kZWZhdWx0RW5jb2RpbmcpLFwiZnVuY3Rpb25cIiE9dHlwZW9mIG4mJihuPWQpLHIuZW5kaW5nP2ModGhpcyxuKTooc3x8dSh0aGlzLHIsZSxuKSkmJihyLnBlbmRpbmdjYisrLGE9Zih0aGlzLHIscyxlLHQsbikpLGF9LGwucHJvdG90eXBlLmNvcms9ZnVuY3Rpb24oKXt0aGlzLl93cml0YWJsZVN0YXRlLmNvcmtlZCsrfSxsLnByb3RvdHlwZS51bmNvcms9ZnVuY3Rpb24oKXt2YXIgZT10aGlzLl93cml0YWJsZVN0YXRlO2UuY29ya2VkJiYoZS5jb3JrZWQtLSwhZS53cml0aW5nJiYhZS5jb3JrZWQmJiFlLmJ1ZmZlclByb2Nlc3NpbmcmJmUuYnVmZmVyZWRSZXF1ZXN0JiZDKHRoaXMsZSkpfSxsLnByb3RvdHlwZS5zZXREZWZhdWx0RW5jb2Rpbmc9ZnVuY3Rpb24oZSl7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGUmJihlPWUudG9Mb3dlckNhc2UoKSksISgtMTxbXCJoZXhcIixcInV0ZjhcIixcInV0Zi04XCIsXCJhc2NpaVwiLFwiYmluYXJ5XCIsXCJiYXNlNjRcIixcInVjczJcIixcInVjcy0yXCIsXCJ1dGYxNmxlXCIsXCJ1dGYtMTZsZVwiLFwicmF3XCJdLmluZGV4T2YoKGUrXCJcIikudG9Mb3dlckNhc2UoKSkpKXRocm93IG5ldyBIKGUpO3JldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmRlZmF1bHRFbmNvZGluZz1lLHRoaXN9LE9iamVjdC5kZWZpbmVQcm9wZXJ0eShsLnByb3RvdHlwZSxcIndyaXRhYmxlQnVmZmVyXCIse2VudW1lcmFibGU6ITEsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUmJnRoaXMuX3dyaXRhYmxlU3RhdGUuZ2V0QnVmZmVyKCl9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGwucHJvdG90eXBlLFwid3JpdGFibGVIaWdoV2F0ZXJNYXJrXCIse2VudW1lcmFibGU6ITEsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUuaGlnaFdhdGVyTWFya319KSxsLnByb3RvdHlwZS5fd3JpdGU9ZnVuY3Rpb24oZSx0LG4pe24obmV3IEYoXCJfd3JpdGUoKVwiKSl9LGwucHJvdG90eXBlLl93cml0ZXY9bnVsbCxsLnByb3RvdHlwZS5lbmQ9ZnVuY3Rpb24oZSx0LG4pe3ZhciByPXRoaXMuX3dyaXRhYmxlU3RhdGU7cmV0dXJuXCJmdW5jdGlvblwiPT10eXBlb2YgZT8obj1lLGU9bnVsbCx0PW51bGwpOlwiZnVuY3Rpb25cIj09dHlwZW9mIHQmJihuPXQsdD1udWxsKSxudWxsIT09ZSYmdm9pZCAwIT09ZSYmdGhpcy53cml0ZShlLHQpLHIuY29ya2VkJiYoci5jb3JrZWQ9MSx0aGlzLnVuY29yaygpKSxyLmVuZGluZ3x8VCh0aGlzLHIsbiksdGhpc30sT2JqZWN0LmRlZmluZVByb3BlcnR5KGwucHJvdG90eXBlLFwid3JpdGFibGVMZW5ndGhcIix7ZW51bWVyYWJsZTohMSxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5sZW5ndGh9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGwucHJvdG90eXBlLFwiZGVzdHJveWVkXCIse2VudW1lcmFibGU6ITEsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHZvaWQgMCE9PXRoaXMuX3dyaXRhYmxlU3RhdGUmJnRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkfSxzZXQ6ZnVuY3Rpb24oZSl7dGhpcy5fd3JpdGFibGVTdGF0ZSYmKHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkPWUpfX0pLGwucHJvdG90eXBlLmRlc3Ryb3k9RC5kZXN0cm95LGwucHJvdG90eXBlLl91bmRlc3Ryb3k9RC51bmRlc3Ryb3ksbC5wcm90b3R5cGUuX2Rlc3Ryb3k9ZnVuY3Rpb24oZSx0KXt0KGUpfX0pLmNhbGwodGhpcyl9KS5jYWxsKHRoaXMsZShcIl9wcm9jZXNzXCIpLFwidW5kZWZpbmVkXCI9PXR5cGVvZiBnbG9iYWw/XCJ1bmRlZmluZWRcIj09dHlwZW9mIHNlbGY/XCJ1bmRlZmluZWRcIj09dHlwZW9mIHdpbmRvdz97fTp3aW5kb3c6c2VsZjpnbG9iYWwpfSx7XCIuLi9lcnJvcnNcIjoxNSxcIi4vX3N0cmVhbV9kdXBsZXhcIjoxNixcIi4vaW50ZXJuYWwvc3RyZWFtcy9kZXN0cm95XCI6MjMsXCIuL2ludGVybmFsL3N0cmVhbXMvc3RhdGVcIjoyNyxcIi4vaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW1cIjoyOCxfcHJvY2VzczoxMixidWZmZXI6Myxpbmhlcml0czoxMCxcInV0aWwtZGVwcmVjYXRlXCI6MzJ9XSwyMTpbZnVuY3Rpb24oZSx0KXsoZnVuY3Rpb24obil7KGZ1bmN0aW9uKCl7J3VzZSBzdHJpY3QnO2Z1bmN0aW9uIHIoZSx0LG4pe3JldHVybiB0IGluIGU/T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsdCx7dmFsdWU6bixlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pOmVbdF09bixlfWZ1bmN0aW9uIGEoZSx0KXtyZXR1cm57dmFsdWU6ZSxkb25lOnR9fWZ1bmN0aW9uIG8oZSl7dmFyIHQ9ZVtjXTtpZihudWxsIT09dCl7dmFyIG49ZVtoXS5yZWFkKCk7bnVsbCE9PW4mJihlW2ddPW51bGwsZVtjXT1udWxsLGVbdV09bnVsbCx0KGEobiwhMSkpKX19ZnVuY3Rpb24gaShlKXtuLm5leHRUaWNrKG8sZSl9ZnVuY3Rpb24gZChlLHQpe3JldHVybiBmdW5jdGlvbihuLHIpe2UudGhlbihmdW5jdGlvbigpe3JldHVybiB0W2ZdP3ZvaWQgbihhKHZvaWQgMCwhMCkpOnZvaWQgdFtfXShuLHIpfSxyKX19dmFyIHMsbD1lKFwiLi9lbmQtb2Ytc3RyZWFtXCIpLGM9U3ltYm9sKFwibGFzdFJlc29sdmVcIiksdT1TeW1ib2woXCJsYXN0UmVqZWN0XCIpLHA9U3ltYm9sKFwiZXJyb3JcIiksZj1TeW1ib2woXCJlbmRlZFwiKSxnPVN5bWJvbChcImxhc3RQcm9taXNlXCIpLF89U3ltYm9sKFwiaGFuZGxlUHJvbWlzZVwiKSxoPVN5bWJvbChcInN0cmVhbVwiKSxtPU9iamVjdC5nZXRQcm90b3R5cGVPZihmdW5jdGlvbigpe30pLGI9T2JqZWN0LnNldFByb3RvdHlwZU9mKChzPXtnZXQgc3RyZWFtKCl7cmV0dXJuIHRoaXNbaF19LG5leHQ6ZnVuY3Rpb24oKXt2YXIgZT10aGlzLHQ9dGhpc1twXTtpZihudWxsIT09dClyZXR1cm4gUHJvbWlzZS5yZWplY3QodCk7aWYodGhpc1tmXSlyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGEodm9pZCAwLCEwKSk7aWYodGhpc1toXS5kZXN0cm95ZWQpcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHQscil7bi5uZXh0VGljayhmdW5jdGlvbigpe2VbcF0/cihlW3BdKTp0KGEodm9pZCAwLCEwKSl9KX0pO3ZhciByLG89dGhpc1tnXTtpZihvKXI9bmV3IFByb21pc2UoZChvLHRoaXMpKTtlbHNle3ZhciBpPXRoaXNbaF0ucmVhZCgpO2lmKG51bGwhPT1pKXJldHVybiBQcm9taXNlLnJlc29sdmUoYShpLCExKSk7cj1uZXcgUHJvbWlzZSh0aGlzW19dKX1yZXR1cm4gdGhpc1tnXT1yLHJ9fSxyKHMsU3ltYm9sLmFzeW5jSXRlcmF0b3IsZnVuY3Rpb24oKXtyZXR1cm4gdGhpc30pLHIocyxcInJldHVyblwiLGZ1bmN0aW9uKCl7dmFyIGU9dGhpcztyZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24odCxuKXtlW2hdLmRlc3Ryb3kobnVsbCxmdW5jdGlvbihlKXtyZXR1cm4gZT92b2lkIG4oZSk6dm9pZCB0KGEodm9pZCAwLCEwKSl9KX0pfSkscyksbSk7dC5leHBvcnRzPWZ1bmN0aW9uKGUpe3ZhciB0LG49T2JqZWN0LmNyZWF0ZShiLCh0PXt9LHIodCxoLHt2YWx1ZTplLHdyaXRhYmxlOiEwfSkscih0LGMse3ZhbHVlOm51bGwsd3JpdGFibGU6ITB9KSxyKHQsdSx7dmFsdWU6bnVsbCx3cml0YWJsZTohMH0pLHIodCxwLHt2YWx1ZTpudWxsLHdyaXRhYmxlOiEwfSkscih0LGYse3ZhbHVlOmUuX3JlYWRhYmxlU3RhdGUuZW5kRW1pdHRlZCx3cml0YWJsZTohMH0pLHIodCxfLHt2YWx1ZTpmdW5jdGlvbihlLHQpe3ZhciByPW5baF0ucmVhZCgpO3I/KG5bZ109bnVsbCxuW2NdPW51bGwsblt1XT1udWxsLGUoYShyLCExKSkpOihuW2NdPWUsblt1XT10KX0sd3JpdGFibGU6ITB9KSx0KSk7cmV0dXJuIG5bZ109bnVsbCxsKGUsZnVuY3Rpb24oZSl7aWYoZSYmXCJFUlJfU1RSRUFNX1BSRU1BVFVSRV9DTE9TRVwiIT09ZS5jb2RlKXt2YXIgdD1uW3VdO3JldHVybiBudWxsIT09dCYmKG5bZ109bnVsbCxuW2NdPW51bGwsblt1XT1udWxsLHQoZSkpLHZvaWQobltwXT1lKX12YXIgcj1uW2NdO251bGwhPT1yJiYobltnXT1udWxsLG5bY109bnVsbCxuW3VdPW51bGwscihhKHZvaWQgMCwhMCkpKSxuW2ZdPSEwfSksZS5vbihcInJlYWRhYmxlXCIsaS5iaW5kKG51bGwsbikpLG59fSkuY2FsbCh0aGlzKX0pLmNhbGwodGhpcyxlKFwiX3Byb2Nlc3NcIikpfSx7XCIuL2VuZC1vZi1zdHJlYW1cIjoyNCxfcHJvY2VzczoxMn1dLDIyOltmdW5jdGlvbihlLHQpeyd1c2Ugc3RyaWN0JztmdW5jdGlvbiBuKGUsdCl7dmFyIG49T2JqZWN0LmtleXMoZSk7aWYoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyl7dmFyIHI9T2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTt0JiYocj1yLmZpbHRlcihmdW5jdGlvbih0KXtyZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLHQpLmVudW1lcmFibGV9KSksbi5wdXNoLmFwcGx5KG4scil9cmV0dXJuIG59ZnVuY3Rpb24gcihlKXtmb3IodmFyIHQscj0xO3I8YXJndW1lbnRzLmxlbmd0aDtyKyspdD1udWxsPT1hcmd1bWVudHNbcl0/e306YXJndW1lbnRzW3JdLHIlMj9uKE9iamVjdCh0KSwhMCkuZm9yRWFjaChmdW5jdGlvbihuKXthKGUsbix0W25dKX0pOk9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzP09iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpOm4oT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uKG4pe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLG4sT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LG4pKX0pO3JldHVybiBlfWZ1bmN0aW9uIGEoZSx0LG4pe3JldHVybiB0IGluIGU/T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsdCx7dmFsdWU6bixlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pOmVbdF09bixlfWZ1bmN0aW9uIG8oZSx0KXtpZighKGUgaW5zdGFuY2VvZiB0KSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfWZ1bmN0aW9uIGkoZSx0KXtmb3IodmFyIG4scj0wO3I8dC5sZW5ndGg7cisrKW49dFtyXSxuLmVudW1lcmFibGU9bi5lbnVtZXJhYmxlfHwhMSxuLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiBuJiYobi53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsbi5rZXksbil9ZnVuY3Rpb24gZChlLHQsbil7cmV0dXJuIHQmJmkoZS5wcm90b3R5cGUsdCksbiYmaShlLG4pLGV9ZnVuY3Rpb24gcyhlLHQsbil7dS5wcm90b3R5cGUuY29weS5jYWxsKGUsdCxuKX12YXIgbD1lKFwiYnVmZmVyXCIpLHU9bC5CdWZmZXIscD1lKFwidXRpbFwiKSxmPXAuaW5zcGVjdCxnPWYmJmYuY3VzdG9tfHxcImluc3BlY3RcIjt0LmV4cG9ydHM9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKCl7byh0aGlzLGUpLHRoaXMuaGVhZD1udWxsLHRoaXMudGFpbD1udWxsLHRoaXMubGVuZ3RoPTB9cmV0dXJuIGQoZSxbe2tleTpcInB1c2hcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD17ZGF0YTplLG5leHQ6bnVsbH07MDx0aGlzLmxlbmd0aD90aGlzLnRhaWwubmV4dD10OnRoaXMuaGVhZD10LHRoaXMudGFpbD10LCsrdGhpcy5sZW5ndGh9fSx7a2V5OlwidW5zaGlmdFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PXtkYXRhOmUsbmV4dDp0aGlzLmhlYWR9OzA9PT10aGlzLmxlbmd0aCYmKHRoaXMudGFpbD10KSx0aGlzLmhlYWQ9dCwrK3RoaXMubGVuZ3RofX0se2tleTpcInNoaWZ0XCIsdmFsdWU6ZnVuY3Rpb24oKXtpZigwIT09dGhpcy5sZW5ndGgpe3ZhciBlPXRoaXMuaGVhZC5kYXRhO3JldHVybiB0aGlzLmhlYWQ9MT09PXRoaXMubGVuZ3RoP3RoaXMudGFpbD1udWxsOnRoaXMuaGVhZC5uZXh0LC0tdGhpcy5sZW5ndGgsZX19fSx7a2V5OlwiY2xlYXJcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuaGVhZD10aGlzLnRhaWw9bnVsbCx0aGlzLmxlbmd0aD0wfX0se2tleTpcImpvaW5cIix2YWx1ZTpmdW5jdGlvbihlKXtpZigwPT09dGhpcy5sZW5ndGgpcmV0dXJuXCJcIjtmb3IodmFyIHQ9dGhpcy5oZWFkLG49XCJcIit0LmRhdGE7dD10Lm5leHQ7KW4rPWUrdC5kYXRhO3JldHVybiBufX0se2tleTpcImNvbmNhdFwiLHZhbHVlOmZ1bmN0aW9uKGUpe2lmKDA9PT10aGlzLmxlbmd0aClyZXR1cm4gdS5hbGxvYygwKTtmb3IodmFyIHQ9dS5hbGxvY1Vuc2FmZShlPj4+MCksbj10aGlzLmhlYWQscj0wO247KXMobi5kYXRhLHQscikscis9bi5kYXRhLmxlbmd0aCxuPW4ubmV4dDtyZXR1cm4gdH19LHtrZXk6XCJjb25zdW1lXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXt2YXIgbjtyZXR1cm4gZTx0aGlzLmhlYWQuZGF0YS5sZW5ndGg/KG49dGhpcy5oZWFkLmRhdGEuc2xpY2UoMCxlKSx0aGlzLmhlYWQuZGF0YT10aGlzLmhlYWQuZGF0YS5zbGljZShlKSk6ZT09PXRoaXMuaGVhZC5kYXRhLmxlbmd0aD9uPXRoaXMuc2hpZnQoKTpuPXQ/dGhpcy5fZ2V0U3RyaW5nKGUpOnRoaXMuX2dldEJ1ZmZlcihlKSxufX0se2tleTpcImZpcnN0XCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5oZWFkLmRhdGF9fSx7a2V5OlwiX2dldFN0cmluZ1wiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PXRoaXMuaGVhZCxyPTEsYT10LmRhdGE7Zm9yKGUtPWEubGVuZ3RoO3Q9dC5uZXh0Oyl7dmFyIG89dC5kYXRhLGk9ZT5vLmxlbmd0aD9vLmxlbmd0aDplO2lmKGErPWk9PT1vLmxlbmd0aD9vOm8uc2xpY2UoMCxlKSxlLT1pLDA9PT1lKXtpPT09by5sZW5ndGg/KCsrcix0aGlzLmhlYWQ9dC5uZXh0P3QubmV4dDp0aGlzLnRhaWw9bnVsbCk6KHRoaXMuaGVhZD10LHQuZGF0YT1vLnNsaWNlKGkpKTticmVha30rK3J9cmV0dXJuIHRoaXMubGVuZ3RoLT1yLGF9fSx7a2V5OlwiX2dldEJ1ZmZlclwiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PXUuYWxsb2NVbnNhZmUoZSkscj10aGlzLmhlYWQsYT0xO2ZvcihyLmRhdGEuY29weSh0KSxlLT1yLmRhdGEubGVuZ3RoO3I9ci5uZXh0Oyl7dmFyIG89ci5kYXRhLGk9ZT5vLmxlbmd0aD9vLmxlbmd0aDplO2lmKG8uY29weSh0LHQubGVuZ3RoLWUsMCxpKSxlLT1pLDA9PT1lKXtpPT09by5sZW5ndGg/KCsrYSx0aGlzLmhlYWQ9ci5uZXh0P3IubmV4dDp0aGlzLnRhaWw9bnVsbCk6KHRoaXMuaGVhZD1yLHIuZGF0YT1vLnNsaWNlKGkpKTticmVha30rK2F9cmV0dXJuIHRoaXMubGVuZ3RoLT1hLHR9fSx7a2V5OmcsdmFsdWU6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZih0aGlzLHIoe30sdCx7ZGVwdGg6MCxjdXN0b21JbnNwZWN0OiExfSkpfX1dKSxlfSgpfSx7YnVmZmVyOjMsdXRpbDoyfV0sMjM6W2Z1bmN0aW9uKGUsdCl7KGZ1bmN0aW9uKGUpeyhmdW5jdGlvbigpeyd1c2Ugc3RyaWN0JztmdW5jdGlvbiBuKGUsdCl7YShlLHQpLHIoZSl9ZnVuY3Rpb24gcihlKXtlLl93cml0YWJsZVN0YXRlJiYhZS5fd3JpdGFibGVTdGF0ZS5lbWl0Q2xvc2V8fGUuX3JlYWRhYmxlU3RhdGUmJiFlLl9yZWFkYWJsZVN0YXRlLmVtaXRDbG9zZXx8ZS5lbWl0KFwiY2xvc2VcIil9ZnVuY3Rpb24gYShlLHQpe2UuZW1pdChcImVycm9yXCIsdCl9dC5leHBvcnRzPXtkZXN0cm95OmZ1bmN0aW9uKHQsbyl7dmFyIGk9dGhpcyxkPXRoaXMuX3JlYWRhYmxlU3RhdGUmJnRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkLHM9dGhpcy5fd3JpdGFibGVTdGF0ZSYmdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQ7cmV0dXJuIGR8fHM/KG8/byh0KTp0JiYodGhpcy5fd3JpdGFibGVTdGF0ZT8hdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQmJih0aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZD0hMCxlLm5leHRUaWNrKGEsdGhpcyx0KSk6ZS5uZXh0VGljayhhLHRoaXMsdCkpLHRoaXMpOih0aGlzLl9yZWFkYWJsZVN0YXRlJiYodGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQ9ITApLHRoaXMuX3dyaXRhYmxlU3RhdGUmJih0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZD0hMCksdGhpcy5fZGVzdHJveSh0fHxudWxsLGZ1bmN0aW9uKHQpeyFvJiZ0P2kuX3dyaXRhYmxlU3RhdGU/aS5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQ/ZS5uZXh0VGljayhyLGkpOihpLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZD0hMCxlLm5leHRUaWNrKG4saSx0KSk6ZS5uZXh0VGljayhuLGksdCk6bz8oZS5uZXh0VGljayhyLGkpLG8odCkpOmUubmV4dFRpY2socixpKX0pLHRoaXMpfSx1bmRlc3Ryb3k6ZnVuY3Rpb24oKXt0aGlzLl9yZWFkYWJsZVN0YXRlJiYodGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQ9ITEsdGhpcy5fcmVhZGFibGVTdGF0ZS5yZWFkaW5nPSExLHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5kZWQ9ITEsdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmRFbWl0dGVkPSExKSx0aGlzLl93cml0YWJsZVN0YXRlJiYodGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQ9ITEsdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRlZD0hMSx0aGlzLl93cml0YWJsZVN0YXRlLmVuZGluZz0hMSx0aGlzLl93cml0YWJsZVN0YXRlLmZpbmFsQ2FsbGVkPSExLHRoaXMuX3dyaXRhYmxlU3RhdGUucHJlZmluaXNoZWQ9ITEsdGhpcy5fd3JpdGFibGVTdGF0ZS5maW5pc2hlZD0hMSx0aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZD0hMSl9LGVycm9yT3JEZXN0cm95OmZ1bmN0aW9uKGUsdCl7dmFyIG49ZS5fcmVhZGFibGVTdGF0ZSxyPWUuX3dyaXRhYmxlU3RhdGU7biYmbi5hdXRvRGVzdHJveXx8ciYmci5hdXRvRGVzdHJveT9lLmRlc3Ryb3kodCk6ZS5lbWl0KFwiZXJyb3JcIix0KX19fSkuY2FsbCh0aGlzKX0pLmNhbGwodGhpcyxlKFwiX3Byb2Nlc3NcIikpfSx7X3Byb2Nlc3M6MTJ9XSwyNDpbZnVuY3Rpb24oZSx0KXsndXNlIHN0cmljdCc7ZnVuY3Rpb24gbihlKXt2YXIgdD0hMTtyZXR1cm4gZnVuY3Rpb24oKXtpZighdCl7dD0hMDtmb3IodmFyIG49YXJndW1lbnRzLmxlbmd0aCxyPUFycmF5KG4pLGE9MDthPG47YSsrKXJbYV09YXJndW1lbnRzW2FdO2UuYXBwbHkodGhpcyxyKX19fWZ1bmN0aW9uIHIoKXt9ZnVuY3Rpb24gYShlKXtyZXR1cm4gZS5zZXRIZWFkZXImJlwiZnVuY3Rpb25cIj09dHlwZW9mIGUuYWJvcnR9ZnVuY3Rpb24gbyhlLHQsZCl7aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgdClyZXR1cm4gbyhlLG51bGwsdCk7dHx8KHQ9e30pLGQ9bihkfHxyKTt2YXIgcz10LnJlYWRhYmxlfHwhMSE9PXQucmVhZGFibGUmJmUucmVhZGFibGUsbD10LndyaXRhYmxlfHwhMSE9PXQud3JpdGFibGUmJmUud3JpdGFibGUsYz1mdW5jdGlvbigpe2Uud3JpdGFibGV8fHAoKX0sdT1lLl93cml0YWJsZVN0YXRlJiZlLl93cml0YWJsZVN0YXRlLmZpbmlzaGVkLHA9ZnVuY3Rpb24oKXtsPSExLHU9ITAsc3x8ZC5jYWxsKGUpfSxmPWUuX3JlYWRhYmxlU3RhdGUmJmUuX3JlYWRhYmxlU3RhdGUuZW5kRW1pdHRlZCxnPWZ1bmN0aW9uKCl7cz0hMSxmPSEwLGx8fGQuY2FsbChlKX0sXz1mdW5jdGlvbih0KXtkLmNhbGwoZSx0KX0saD1mdW5jdGlvbigpe3ZhciB0O3JldHVybiBzJiYhZj8oZS5fcmVhZGFibGVTdGF0ZSYmZS5fcmVhZGFibGVTdGF0ZS5lbmRlZHx8KHQ9bmV3IGkpLGQuY2FsbChlLHQpKTpsJiYhdT8oZS5fd3JpdGFibGVTdGF0ZSYmZS5fd3JpdGFibGVTdGF0ZS5lbmRlZHx8KHQ9bmV3IGkpLGQuY2FsbChlLHQpKTp2b2lkIDB9LG09ZnVuY3Rpb24oKXtlLnJlcS5vbihcImZpbmlzaFwiLHApfTtyZXR1cm4gYShlKT8oZS5vbihcImNvbXBsZXRlXCIscCksZS5vbihcImFib3J0XCIsaCksZS5yZXE/bSgpOmUub24oXCJyZXF1ZXN0XCIsbSkpOmwmJiFlLl93cml0YWJsZVN0YXRlJiYoZS5vbihcImVuZFwiLGMpLGUub24oXCJjbG9zZVwiLGMpKSxlLm9uKFwiZW5kXCIsZyksZS5vbihcImZpbmlzaFwiLHApLCExIT09dC5lcnJvciYmZS5vbihcImVycm9yXCIsXyksZS5vbihcImNsb3NlXCIsaCksZnVuY3Rpb24oKXtlLnJlbW92ZUxpc3RlbmVyKFwiY29tcGxldGVcIixwKSxlLnJlbW92ZUxpc3RlbmVyKFwiYWJvcnRcIixoKSxlLnJlbW92ZUxpc3RlbmVyKFwicmVxdWVzdFwiLG0pLGUucmVxJiZlLnJlcS5yZW1vdmVMaXN0ZW5lcihcImZpbmlzaFwiLHApLGUucmVtb3ZlTGlzdGVuZXIoXCJlbmRcIixjKSxlLnJlbW92ZUxpc3RlbmVyKFwiY2xvc2VcIixjKSxlLnJlbW92ZUxpc3RlbmVyKFwiZmluaXNoXCIscCksZS5yZW1vdmVMaXN0ZW5lcihcImVuZFwiLGcpLGUucmVtb3ZlTGlzdGVuZXIoXCJlcnJvclwiLF8pLGUucmVtb3ZlTGlzdGVuZXIoXCJjbG9zZVwiLGgpfX12YXIgaT1lKFwiLi4vLi4vLi4vZXJyb3JzXCIpLmNvZGVzLkVSUl9TVFJFQU1fUFJFTUFUVVJFX0NMT1NFO3QuZXhwb3J0cz1vfSx7XCIuLi8uLi8uLi9lcnJvcnNcIjoxNX1dLDI1OltmdW5jdGlvbihlLHQpe3QuZXhwb3J0cz1mdW5jdGlvbigpe3Rocm93IG5ldyBFcnJvcihcIlJlYWRhYmxlLmZyb20gaXMgbm90IGF2YWlsYWJsZSBpbiB0aGUgYnJvd3NlclwiKX19LHt9XSwyNjpbZnVuY3Rpb24oZSx0KXsndXNlIHN0cmljdCc7ZnVuY3Rpb24gbihlKXt2YXIgdD0hMTtyZXR1cm4gZnVuY3Rpb24oKXt0fHwodD0hMCxlLmFwcGx5KHZvaWQgMCxhcmd1bWVudHMpKX19ZnVuY3Rpb24gcihlKXtpZihlKXRocm93IGV9ZnVuY3Rpb24gYShlKXtyZXR1cm4gZS5zZXRIZWFkZXImJlwiZnVuY3Rpb25cIj09dHlwZW9mIGUuYWJvcnR9ZnVuY3Rpb24gbyh0LHIsbyxpKXtpPW4oaSk7dmFyIGQ9ITE7dC5vbihcImNsb3NlXCIsZnVuY3Rpb24oKXtkPSEwfSksbD09PXZvaWQgMCYmKGw9ZShcIi4vZW5kLW9mLXN0cmVhbVwiKSksbCh0LHtyZWFkYWJsZTpyLHdyaXRhYmxlOm99LGZ1bmN0aW9uKGUpe3JldHVybiBlP2koZSk6dm9pZChkPSEwLGkoKSl9KTt2YXIgcz0hMTtyZXR1cm4gZnVuY3Rpb24oZSl7aWYoIWQpcmV0dXJuIHM/dm9pZCAwOihzPSEwLGEodCk/dC5hYm9ydCgpOlwiZnVuY3Rpb25cIj09dHlwZW9mIHQuZGVzdHJveT90LmRlc3Ryb3koKTp2b2lkIGkoZXx8bmV3IHAoXCJwaXBlXCIpKSl9fWZ1bmN0aW9uIGkoZSl7ZSgpfWZ1bmN0aW9uIGQoZSx0KXtyZXR1cm4gZS5waXBlKHQpfWZ1bmN0aW9uIHMoZSl7cmV0dXJuIGUubGVuZ3RoP1wiZnVuY3Rpb25cIj09dHlwZW9mIGVbZS5sZW5ndGgtMV0/ZS5wb3AoKTpyOnJ9dmFyIGwsYz1lKFwiLi4vLi4vLi4vZXJyb3JzXCIpLmNvZGVzLHU9Yy5FUlJfTUlTU0lOR19BUkdTLHA9Yy5FUlJfU1RSRUFNX0RFU1RST1lFRDt0LmV4cG9ydHM9ZnVuY3Rpb24oKXtmb3IodmFyIGU9YXJndW1lbnRzLmxlbmd0aCx0PUFycmF5KGUpLG49MDtuPGU7bisrKXRbbl09YXJndW1lbnRzW25dO3ZhciByPXModCk7aWYoQXJyYXkuaXNBcnJheSh0WzBdKSYmKHQ9dFswXSksMj50Lmxlbmd0aCl0aHJvdyBuZXcgdShcInN0cmVhbXNcIik7dmFyIGEsbD10Lm1hcChmdW5jdGlvbihlLG4pe3ZhciBkPW48dC5sZW5ndGgtMTtyZXR1cm4gbyhlLGQsMDxuLGZ1bmN0aW9uKGUpe2F8fChhPWUpLGUmJmwuZm9yRWFjaChpKSxkfHwobC5mb3JFYWNoKGkpLHIoYSkpfSl9KTtyZXR1cm4gdC5yZWR1Y2UoZCl9fSx7XCIuLi8uLi8uLi9lcnJvcnNcIjoxNSxcIi4vZW5kLW9mLXN0cmVhbVwiOjI0fV0sMjc6W2Z1bmN0aW9uKGUsbil7J3VzZSBzdHJpY3QnO2Z1bmN0aW9uIHIoZSx0LG4pe3JldHVybiBudWxsPT1lLmhpZ2hXYXRlck1hcms/dD9lW25dOm51bGw6ZS5oaWdoV2F0ZXJNYXJrfXZhciBhPWUoXCIuLi8uLi8uLi9lcnJvcnNcIikuY29kZXMuRVJSX0lOVkFMSURfT1BUX1ZBTFVFO24uZXhwb3J0cz17Z2V0SGlnaFdhdGVyTWFyazpmdW5jdGlvbihlLG4sbyxpKXt2YXIgZD1yKG4saSxvKTtpZihudWxsIT1kKXtpZighKGlzRmluaXRlKGQpJiZ0KGQpPT09ZCl8fDA+ZCl7dmFyIHM9aT9vOlwiaGlnaFdhdGVyTWFya1wiO3Rocm93IG5ldyBhKHMsZCl9cmV0dXJuIHQoZCl9cmV0dXJuIGUub2JqZWN0TW9kZT8xNjoxNjM4NH19fSx7XCIuLi8uLi8uLi9lcnJvcnNcIjoxNX1dLDI4OltmdW5jdGlvbihlLHQpe3QuZXhwb3J0cz1lKFwiZXZlbnRzXCIpLkV2ZW50RW1pdHRlcn0se2V2ZW50czo3fV0sMjk6W2Z1bmN0aW9uKGUsdCxuKXtuPXQuZXhwb3J0cz1lKFwiLi9saWIvX3N0cmVhbV9yZWFkYWJsZS5qc1wiKSxuLlN0cmVhbT1uLG4uUmVhZGFibGU9bixuLldyaXRhYmxlPWUoXCIuL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzXCIpLG4uRHVwbGV4PWUoXCIuL2xpYi9fc3RyZWFtX2R1cGxleC5qc1wiKSxuLlRyYW5zZm9ybT1lKFwiLi9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanNcIiksbi5QYXNzVGhyb3VnaD1lKFwiLi9saWIvX3N0cmVhbV9wYXNzdGhyb3VnaC5qc1wiKSxuLmZpbmlzaGVkPWUoXCIuL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2VuZC1vZi1zdHJlYW0uanNcIiksbi5waXBlbGluZT1lKFwiLi9saWIvaW50ZXJuYWwvc3RyZWFtcy9waXBlbGluZS5qc1wiKX0se1wiLi9saWIvX3N0cmVhbV9kdXBsZXguanNcIjoxNixcIi4vbGliL19zdHJlYW1fcGFzc3Rocm91Z2guanNcIjoxNyxcIi4vbGliL19zdHJlYW1fcmVhZGFibGUuanNcIjoxOCxcIi4vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzXCI6MTksXCIuL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzXCI6MjAsXCIuL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2VuZC1vZi1zdHJlYW0uanNcIjoyNCxcIi4vbGliL2ludGVybmFsL3N0cmVhbXMvcGlwZWxpbmUuanNcIjoyNn1dLDMwOltmdW5jdGlvbihlLHQsbil7ZnVuY3Rpb24gcihlLHQpe2Zvcih2YXIgbiBpbiBlKXRbbl09ZVtuXX1mdW5jdGlvbiBhKGUsdCxuKXtyZXR1cm4gaShlLHQsbil9LyohIHNhZmUtYnVmZmVyLiBNSVQgTGljZW5zZS4gRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnL29wZW5zb3VyY2U+ICovdmFyIG89ZShcImJ1ZmZlclwiKSxpPW8uQnVmZmVyO2kuZnJvbSYmaS5hbGxvYyYmaS5hbGxvY1Vuc2FmZSYmaS5hbGxvY1Vuc2FmZVNsb3c/dC5leHBvcnRzPW86KHIobyxuKSxuLkJ1ZmZlcj1hKSxhLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKGkucHJvdG90eXBlKSxyKGksYSksYS5mcm9tPWZ1bmN0aW9uKGUsdCxuKXtpZihcIm51bWJlclwiPT10eXBlb2YgZSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQXJndW1lbnQgbXVzdCBub3QgYmUgYSBudW1iZXJcIik7cmV0dXJuIGkoZSx0LG4pfSxhLmFsbG9jPWZ1bmN0aW9uKGUsdCxuKXtpZihcIm51bWJlclwiIT10eXBlb2YgZSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlclwiKTt2YXIgcj1pKGUpO3JldHVybiB2b2lkIDA9PT10P3IuZmlsbCgwKTpcInN0cmluZ1wiPT10eXBlb2Ygbj9yLmZpbGwodCxuKTpyLmZpbGwodCkscn0sYS5hbGxvY1Vuc2FmZT1mdW5jdGlvbihlKXtpZihcIm51bWJlclwiIT10eXBlb2YgZSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlclwiKTtyZXR1cm4gaShlKX0sYS5hbGxvY1Vuc2FmZVNsb3c9ZnVuY3Rpb24oZSl7aWYoXCJudW1iZXJcIiE9dHlwZW9mIGUpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkFyZ3VtZW50IG11c3QgYmUgYSBudW1iZXJcIik7cmV0dXJuIG8uU2xvd0J1ZmZlcihlKX19LHtidWZmZXI6M31dLDMxOltmdW5jdGlvbihlLHQsbil7J3VzZSBzdHJpY3QnO2Z1bmN0aW9uIHIoZSl7aWYoIWUpcmV0dXJuXCJ1dGY4XCI7Zm9yKHZhciB0Ozspc3dpdGNoKGUpe2Nhc2VcInV0ZjhcIjpjYXNlXCJ1dGYtOFwiOnJldHVyblwidXRmOFwiO2Nhc2VcInVjczJcIjpjYXNlXCJ1Y3MtMlwiOmNhc2VcInV0ZjE2bGVcIjpjYXNlXCJ1dGYtMTZsZVwiOnJldHVyblwidXRmMTZsZVwiO2Nhc2VcImxhdGluMVwiOmNhc2VcImJpbmFyeVwiOnJldHVyblwibGF0aW4xXCI7Y2FzZVwiYmFzZTY0XCI6Y2FzZVwiYXNjaWlcIjpjYXNlXCJoZXhcIjpyZXR1cm4gZTtkZWZhdWx0OmlmKHQpcmV0dXJuO2U9KFwiXCIrZSkudG9Mb3dlckNhc2UoKSx0PSEwO319ZnVuY3Rpb24gYShlKXt2YXIgdD1yKGUpO2lmKFwic3RyaW5nXCIhPXR5cGVvZiB0JiYobS5pc0VuY29kaW5nPT09Ynx8IWIoZSkpKXRocm93IG5ldyBFcnJvcihcIlVua25vd24gZW5jb2Rpbmc6IFwiK2UpO3JldHVybiB0fHxlfWZ1bmN0aW9uIG8oZSl7dGhpcy5lbmNvZGluZz1hKGUpO3ZhciB0O3N3aXRjaCh0aGlzLmVuY29kaW5nKXtjYXNlXCJ1dGYxNmxlXCI6dGhpcy50ZXh0PXUsdGhpcy5lbmQ9cCx0PTQ7YnJlYWs7Y2FzZVwidXRmOFwiOnRoaXMuZmlsbExhc3Q9Yyx0PTQ7YnJlYWs7Y2FzZVwiYmFzZTY0XCI6dGhpcy50ZXh0PWYsdGhpcy5lbmQ9Zyx0PTM7YnJlYWs7ZGVmYXVsdDpyZXR1cm4gdGhpcy53cml0ZT1fLHZvaWQodGhpcy5lbmQ9aCk7fXRoaXMubGFzdE5lZWQ9MCx0aGlzLmxhc3RUb3RhbD0wLHRoaXMubGFzdENoYXI9bS5hbGxvY1Vuc2FmZSh0KX1mdW5jdGlvbiBkKGUpe2lmKDEyNz49ZSlyZXR1cm4gMDtyZXR1cm4gNj09ZT4+NT8yOjE0PT1lPj40PzM6MzA9PWU+PjM/NDoyPT1lPj42Py0xOi0yfWZ1bmN0aW9uIHMoZSx0LG4pe3ZhciByPXQubGVuZ3RoLTE7aWYocjxuKXJldHVybiAwO3ZhciBhPWQodFtyXSk7cmV0dXJuIDA8PWE/KDA8YSYmKGUubGFzdE5lZWQ9YS0xKSxhKTotLXI8bnx8LTI9PT1hPzA6KGE9ZCh0W3JdKSwwPD1hKT8oMDxhJiYoZS5sYXN0TmVlZD1hLTIpLGEpOi0tcjxufHwtMj09PWE/MDooYT1kKHRbcl0pLDA8PWE/KDA8YSYmKDI9PT1hP2E9MDplLmxhc3ROZWVkPWEtMyksYSk6MCl9ZnVuY3Rpb24gbChlLHQpe2lmKDEyOCE9KDE5MiZ0WzBdKSlyZXR1cm4gZS5sYXN0TmVlZD0wLFwiXFx1RkZGRFwiO2lmKDE8ZS5sYXN0TmVlZCYmMTx0Lmxlbmd0aCl7aWYoMTI4IT0oMTkyJnRbMV0pKXJldHVybiBlLmxhc3ROZWVkPTEsXCJcXHVGRkZEXCI7aWYoMjxlLmxhc3ROZWVkJiYyPHQubGVuZ3RoJiYxMjghPSgxOTImdFsyXSkpcmV0dXJuIGUubGFzdE5lZWQ9MixcIlxcdUZGRkRcIn19ZnVuY3Rpb24gYyhlKXt2YXIgdD10aGlzLmxhc3RUb3RhbC10aGlzLmxhc3ROZWVkLG49bCh0aGlzLGUsdCk7cmV0dXJuIHZvaWQgMD09PW4/dGhpcy5sYXN0TmVlZDw9ZS5sZW5ndGg/KGUuY29weSh0aGlzLmxhc3RDaGFyLHQsMCx0aGlzLmxhc3ROZWVkKSx0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcsMCx0aGlzLmxhc3RUb3RhbCkpOnZvaWQoZS5jb3B5KHRoaXMubGFzdENoYXIsdCwwLGUubGVuZ3RoKSx0aGlzLmxhc3ROZWVkLT1lLmxlbmd0aCk6bn1mdW5jdGlvbiB1KGUsdCl7aWYoMD09KGUubGVuZ3RoLXQpJTIpe3ZhciBuPWUudG9TdHJpbmcoXCJ1dGYxNmxlXCIsdCk7aWYobil7dmFyIHI9bi5jaGFyQ29kZUF0KG4ubGVuZ3RoLTEpO2lmKDU1Mjk2PD1yJiY1NjMxOT49cilyZXR1cm4gdGhpcy5sYXN0TmVlZD0yLHRoaXMubGFzdFRvdGFsPTQsdGhpcy5sYXN0Q2hhclswXT1lW2UubGVuZ3RoLTJdLHRoaXMubGFzdENoYXJbMV09ZVtlLmxlbmd0aC0xXSxuLnNsaWNlKDAsLTEpfXJldHVybiBufXJldHVybiB0aGlzLmxhc3ROZWVkPTEsdGhpcy5sYXN0VG90YWw9Mix0aGlzLmxhc3RDaGFyWzBdPWVbZS5sZW5ndGgtMV0sZS50b1N0cmluZyhcInV0ZjE2bGVcIix0LGUubGVuZ3RoLTEpfWZ1bmN0aW9uIHAoZSl7dmFyIHQ9ZSYmZS5sZW5ndGg/dGhpcy53cml0ZShlKTpcIlwiO2lmKHRoaXMubGFzdE5lZWQpe3ZhciBuPXRoaXMubGFzdFRvdGFsLXRoaXMubGFzdE5lZWQ7cmV0dXJuIHQrdGhpcy5sYXN0Q2hhci50b1N0cmluZyhcInV0ZjE2bGVcIiwwLG4pfXJldHVybiB0fWZ1bmN0aW9uIGYoZSx0KXt2YXIgcj0oZS5sZW5ndGgtdCklMztyZXR1cm4gMD09cj9lLnRvU3RyaW5nKFwiYmFzZTY0XCIsdCk6KHRoaXMubGFzdE5lZWQ9My1yLHRoaXMubGFzdFRvdGFsPTMsMT09cj90aGlzLmxhc3RDaGFyWzBdPWVbZS5sZW5ndGgtMV06KHRoaXMubGFzdENoYXJbMF09ZVtlLmxlbmd0aC0yXSx0aGlzLmxhc3RDaGFyWzFdPWVbZS5sZW5ndGgtMV0pLGUudG9TdHJpbmcoXCJiYXNlNjRcIix0LGUubGVuZ3RoLXIpKX1mdW5jdGlvbiBnKGUpe3ZhciB0PWUmJmUubGVuZ3RoP3RoaXMud3JpdGUoZSk6XCJcIjtyZXR1cm4gdGhpcy5sYXN0TmVlZD90K3RoaXMubGFzdENoYXIudG9TdHJpbmcoXCJiYXNlNjRcIiwwLDMtdGhpcy5sYXN0TmVlZCk6dH1mdW5jdGlvbiBfKGUpe3JldHVybiBlLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcpfWZ1bmN0aW9uIGgoZSl7cmV0dXJuIGUmJmUubGVuZ3RoP3RoaXMud3JpdGUoZSk6XCJcIn12YXIgbT1lKFwic2FmZS1idWZmZXJcIikuQnVmZmVyLGI9bS5pc0VuY29kaW5nfHxmdW5jdGlvbihlKXtzd2l0Y2goZT1cIlwiK2UsZSYmZS50b0xvd2VyQ2FzZSgpKXtjYXNlXCJoZXhcIjpjYXNlXCJ1dGY4XCI6Y2FzZVwidXRmLThcIjpjYXNlXCJhc2NpaVwiOmNhc2VcImJpbmFyeVwiOmNhc2VcImJhc2U2NFwiOmNhc2VcInVjczJcIjpjYXNlXCJ1Y3MtMlwiOmNhc2VcInV0ZjE2bGVcIjpjYXNlXCJ1dGYtMTZsZVwiOmNhc2VcInJhd1wiOnJldHVybiEwO2RlZmF1bHQ6cmV0dXJuITE7fX07bi5TdHJpbmdEZWNvZGVyPW8sby5wcm90b3R5cGUud3JpdGU9ZnVuY3Rpb24oZSl7aWYoMD09PWUubGVuZ3RoKXJldHVyblwiXCI7dmFyIHQsbjtpZih0aGlzLmxhc3ROZWVkKXtpZih0PXRoaXMuZmlsbExhc3QoZSksdm9pZCAwPT09dClyZXR1cm5cIlwiO249dGhpcy5sYXN0TmVlZCx0aGlzLmxhc3ROZWVkPTB9ZWxzZSBuPTA7cmV0dXJuIG48ZS5sZW5ndGg/dD90K3RoaXMudGV4dChlLG4pOnRoaXMudGV4dChlLG4pOnR8fFwiXCJ9LG8ucHJvdG90eXBlLmVuZD1mdW5jdGlvbihlKXt2YXIgdD1lJiZlLmxlbmd0aD90aGlzLndyaXRlKGUpOlwiXCI7cmV0dXJuIHRoaXMubGFzdE5lZWQ/dCtcIlxcdUZGRkRcIjp0fSxvLnByb3RvdHlwZS50ZXh0PWZ1bmN0aW9uKGUsdCl7dmFyIG49cyh0aGlzLGUsdCk7aWYoIXRoaXMubGFzdE5lZWQpcmV0dXJuIGUudG9TdHJpbmcoXCJ1dGY4XCIsdCk7dGhpcy5sYXN0VG90YWw9bjt2YXIgcj1lLmxlbmd0aC0obi10aGlzLmxhc3ROZWVkKTtyZXR1cm4gZS5jb3B5KHRoaXMubGFzdENoYXIsMCxyKSxlLnRvU3RyaW5nKFwidXRmOFwiLHQscil9LG8ucHJvdG90eXBlLmZpbGxMYXN0PWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmxhc3ROZWVkPD1lLmxlbmd0aD8oZS5jb3B5KHRoaXMubGFzdENoYXIsdGhpcy5sYXN0VG90YWwtdGhpcy5sYXN0TmVlZCwwLHRoaXMubGFzdE5lZWQpLHRoaXMubGFzdENoYXIudG9TdHJpbmcodGhpcy5lbmNvZGluZywwLHRoaXMubGFzdFRvdGFsKSk6dm9pZChlLmNvcHkodGhpcy5sYXN0Q2hhcix0aGlzLmxhc3RUb3RhbC10aGlzLmxhc3ROZWVkLDAsZS5sZW5ndGgpLHRoaXMubGFzdE5lZWQtPWUubGVuZ3RoKX19LHtcInNhZmUtYnVmZmVyXCI6MzB9XSwzMjpbZnVuY3Rpb24oZSx0KXsoZnVuY3Rpb24oZSl7KGZ1bmN0aW9uKCl7ZnVuY3Rpb24gbih0KXt0cnl7aWYoIWUubG9jYWxTdG9yYWdlKXJldHVybiExfWNhdGNoKGUpe3JldHVybiExfXZhciBuPWUubG9jYWxTdG9yYWdlW3RdO3JldHVybiBudWxsIT1uJiZcInRydWVcIj09PShuK1wiXCIpLnRvTG93ZXJDYXNlKCl9dC5leHBvcnRzPWZ1bmN0aW9uKGUsdCl7ZnVuY3Rpb24gcigpe2lmKCFhKXtpZihuKFwidGhyb3dEZXByZWNhdGlvblwiKSl0aHJvdyBuZXcgRXJyb3IodCk7ZWxzZSBuKFwidHJhY2VEZXByZWNhdGlvblwiKT9jb25zb2xlLnRyYWNlKHQpOmNvbnNvbGUud2Fybih0KTthPSEwfXJldHVybiBlLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1pZihuKFwibm9EZXByZWNhdGlvblwiKSlyZXR1cm4gZTt2YXIgYT0hMTtyZXR1cm4gcn19KS5jYWxsKHRoaXMpfSkuY2FsbCh0aGlzLFwidW5kZWZpbmVkXCI9PXR5cGVvZiBnbG9iYWw/XCJ1bmRlZmluZWRcIj09dHlwZW9mIHNlbGY/XCJ1bmRlZmluZWRcIj09dHlwZW9mIHdpbmRvdz97fTp3aW5kb3c6c2VsZjpnbG9iYWwpfSx7fV0sXCIvXCI6W2Z1bmN0aW9uKGUsdCl7ZnVuY3Rpb24gbihlKXtyZXR1cm4gZS5yZXBsYWNlKC9hPWljZS1vcHRpb25zOnRyaWNrbGVcXHNcXG4vZyxcIlwiKX1mdW5jdGlvbiByKGUpe2NvbnNvbGUud2FybihlKX0vKiEgc2ltcGxlLXBlZXIuIE1JVCBMaWNlbnNlLiBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmcvb3BlbnNvdXJjZT4gKi9jb25zdCBhPWUoXCJkZWJ1Z1wiKShcInNpbXBsZS1wZWVyXCIpLG89ZShcImdldC1icm93c2VyLXJ0Y1wiKSxpPWUoXCJyYW5kb21ieXRlc1wiKSxkPWUoXCJyZWFkYWJsZS1zdHJlYW1cIikscz1lKFwicXVldWUtbWljcm90YXNrXCIpLGw9ZShcImVyci1jb2RlXCIpLHtCdWZmZXI6Y309ZShcImJ1ZmZlclwiKSx1PTY1NTM2O2NsYXNzIHAgZXh0ZW5kcyBkLkR1cGxleHtjb25zdHJ1Y3RvcihlKXtpZihlPU9iamVjdC5hc3NpZ24oe2FsbG93SGFsZk9wZW46ITF9LGUpLHN1cGVyKGUpLHRoaXMuX2lkPWkoNCkudG9TdHJpbmcoXCJoZXhcIikuc2xpY2UoMCw3KSx0aGlzLl9kZWJ1ZyhcIm5ldyBwZWVyICVvXCIsZSksdGhpcy5jaGFubmVsTmFtZT1lLmluaXRpYXRvcj9lLmNoYW5uZWxOYW1lfHxpKDIwKS50b1N0cmluZyhcImhleFwiKTpudWxsLHRoaXMuaW5pdGlhdG9yPWUuaW5pdGlhdG9yfHwhMSx0aGlzLmNoYW5uZWxDb25maWc9ZS5jaGFubmVsQ29uZmlnfHxwLmNoYW5uZWxDb25maWcsdGhpcy5jaGFubmVsTmVnb3RpYXRlZD10aGlzLmNoYW5uZWxDb25maWcubmVnb3RpYXRlZCx0aGlzLmNvbmZpZz1PYmplY3QuYXNzaWduKHt9LHAuY29uZmlnLGUuY29uZmlnKSx0aGlzLm9mZmVyT3B0aW9ucz1lLm9mZmVyT3B0aW9uc3x8e30sdGhpcy5hbnN3ZXJPcHRpb25zPWUuYW5zd2VyT3B0aW9uc3x8e30sdGhpcy5zZHBUcmFuc2Zvcm09ZS5zZHBUcmFuc2Zvcm18fChlPT5lKSx0aGlzLnN0cmVhbXM9ZS5zdHJlYW1zfHwoZS5zdHJlYW0/W2Uuc3RyZWFtXTpbXSksdGhpcy50cmlja2xlPXZvaWQgMD09PWUudHJpY2tsZXx8ZS50cmlja2xlLHRoaXMuYWxsb3dIYWxmVHJpY2tsZT12b2lkIDAhPT1lLmFsbG93SGFsZlRyaWNrbGUmJmUuYWxsb3dIYWxmVHJpY2tsZSx0aGlzLmljZUNvbXBsZXRlVGltZW91dD1lLmljZUNvbXBsZXRlVGltZW91dHx8NTAwMCx0aGlzLmRlc3Ryb3llZD0hMSx0aGlzLmRlc3Ryb3lpbmc9ITEsdGhpcy5fY29ubmVjdGVkPSExLHRoaXMucmVtb3RlQWRkcmVzcz12b2lkIDAsdGhpcy5yZW1vdGVGYW1pbHk9dm9pZCAwLHRoaXMucmVtb3RlUG9ydD12b2lkIDAsdGhpcy5sb2NhbEFkZHJlc3M9dm9pZCAwLHRoaXMubG9jYWxGYW1pbHk9dm9pZCAwLHRoaXMubG9jYWxQb3J0PXZvaWQgMCx0aGlzLl93cnRjPWUud3J0YyYmXCJvYmplY3RcIj09dHlwZW9mIGUud3J0Yz9lLndydGM6bygpLCF0aGlzLl93cnRjKWlmKFwidW5kZWZpbmVkXCI9PXR5cGVvZiB3aW5kb3cpdGhyb3cgbChuZXcgRXJyb3IoXCJObyBXZWJSVEMgc3VwcG9ydDogU3BlY2lmeSBgb3B0cy53cnRjYCBvcHRpb24gaW4gdGhpcyBlbnZpcm9ubWVudFwiKSxcIkVSUl9XRUJSVENfU1VQUE9SVFwiKTtlbHNlIHRocm93IGwobmV3IEVycm9yKFwiTm8gV2ViUlRDIHN1cHBvcnQ6IE5vdCBhIHN1cHBvcnRlZCBicm93c2VyXCIpLFwiRVJSX1dFQlJUQ19TVVBQT1JUXCIpO3RoaXMuX3BjUmVhZHk9ITEsdGhpcy5fY2hhbm5lbFJlYWR5PSExLHRoaXMuX2ljZUNvbXBsZXRlPSExLHRoaXMuX2ljZUNvbXBsZXRlVGltZXI9bnVsbCx0aGlzLl9jaGFubmVsPW51bGwsdGhpcy5fcGVuZGluZ0NhbmRpZGF0ZXM9W10sdGhpcy5faXNOZWdvdGlhdGluZz0hMSx0aGlzLl9maXJzdE5lZ290aWF0aW9uPSEwLHRoaXMuX2JhdGNoZWROZWdvdGlhdGlvbj0hMSx0aGlzLl9xdWV1ZWROZWdvdGlhdGlvbj0hMSx0aGlzLl9zZW5kZXJzQXdhaXRpbmdTdGFibGU9W10sdGhpcy5fc2VuZGVyTWFwPW5ldyBNYXAsdGhpcy5fY2xvc2luZ0ludGVydmFsPW51bGwsdGhpcy5fcmVtb3RlVHJhY2tzPVtdLHRoaXMuX3JlbW90ZVN0cmVhbXM9W10sdGhpcy5fY2h1bms9bnVsbCx0aGlzLl9jYj1udWxsLHRoaXMuX2ludGVydmFsPW51bGw7dHJ5e3RoaXMuX3BjPW5ldyB0aGlzLl93cnRjLlJUQ1BlZXJDb25uZWN0aW9uKHRoaXMuY29uZmlnKX1jYXRjaChlKXtyZXR1cm4gdm9pZCB0aGlzLmRlc3Ryb3kobChlLFwiRVJSX1BDX0NPTlNUUlVDVE9SXCIpKX10aGlzLl9pc1JlYWN0TmF0aXZlV2VicnRjPVwibnVtYmVyXCI9PXR5cGVvZiB0aGlzLl9wYy5fcGVlckNvbm5lY3Rpb25JZCx0aGlzLl9wYy5vbmljZWNvbm5lY3Rpb25zdGF0ZWNoYW5nZT0oKT0+e3RoaXMuX29uSWNlU3RhdGVDaGFuZ2UoKX0sdGhpcy5fcGMub25pY2VnYXRoZXJpbmdzdGF0ZWNoYW5nZT0oKT0+e3RoaXMuX29uSWNlU3RhdGVDaGFuZ2UoKX0sdGhpcy5fcGMub25jb25uZWN0aW9uc3RhdGVjaGFuZ2U9KCk9Pnt0aGlzLl9vbkNvbm5lY3Rpb25TdGF0ZUNoYW5nZSgpfSx0aGlzLl9wYy5vbnNpZ25hbGluZ3N0YXRlY2hhbmdlPSgpPT57dGhpcy5fb25TaWduYWxpbmdTdGF0ZUNoYW5nZSgpfSx0aGlzLl9wYy5vbmljZWNhbmRpZGF0ZT1lPT57dGhpcy5fb25JY2VDYW5kaWRhdGUoZSl9LFwib2JqZWN0XCI9PXR5cGVvZiB0aGlzLl9wYy5wZWVySWRlbnRpdHkmJnRoaXMuX3BjLnBlZXJJZGVudGl0eS5jYXRjaChlPT57dGhpcy5kZXN0cm95KGwoZSxcIkVSUl9QQ19QRUVSX0lERU5USVRZXCIpKX0pLHRoaXMuaW5pdGlhdG9yfHx0aGlzLmNoYW5uZWxOZWdvdGlhdGVkP3RoaXMuX3NldHVwRGF0YSh7Y2hhbm5lbDp0aGlzLl9wYy5jcmVhdGVEYXRhQ2hhbm5lbCh0aGlzLmNoYW5uZWxOYW1lLHRoaXMuY2hhbm5lbENvbmZpZyl9KTp0aGlzLl9wYy5vbmRhdGFjaGFubmVsPWU9Pnt0aGlzLl9zZXR1cERhdGEoZSl9LHRoaXMuc3RyZWFtcyYmdGhpcy5zdHJlYW1zLmZvckVhY2goZT0+e3RoaXMuYWRkU3RyZWFtKGUpfSksdGhpcy5fcGMub250cmFjaz1lPT57dGhpcy5fb25UcmFjayhlKX0sdGhpcy5fZGVidWcoXCJpbml0aWFsIG5lZ290aWF0aW9uXCIpLHRoaXMuX25lZWRzTmVnb3RpYXRpb24oKSx0aGlzLl9vbkZpbmlzaEJvdW5kPSgpPT57dGhpcy5fb25GaW5pc2goKX0sdGhpcy5vbmNlKFwiZmluaXNoXCIsdGhpcy5fb25GaW5pc2hCb3VuZCl9Z2V0IGJ1ZmZlclNpemUoKXtyZXR1cm4gdGhpcy5fY2hhbm5lbCYmdGhpcy5fY2hhbm5lbC5idWZmZXJlZEFtb3VudHx8MH1nZXQgY29ubmVjdGVkKCl7cmV0dXJuIHRoaXMuX2Nvbm5lY3RlZCYmXCJvcGVuXCI9PT10aGlzLl9jaGFubmVsLnJlYWR5U3RhdGV9YWRkcmVzcygpe3JldHVybntwb3J0OnRoaXMubG9jYWxQb3J0LGZhbWlseTp0aGlzLmxvY2FsRmFtaWx5LGFkZHJlc3M6dGhpcy5sb2NhbEFkZHJlc3N9fXNpZ25hbChlKXtpZighdGhpcy5kZXN0cm95aW5nKXtpZih0aGlzLmRlc3Ryb3llZCl0aHJvdyBsKG5ldyBFcnJvcihcImNhbm5vdCBzaWduYWwgYWZ0ZXIgcGVlciBpcyBkZXN0cm95ZWRcIiksXCJFUlJfREVTVFJPWUVEXCIpO2lmKFwic3RyaW5nXCI9PXR5cGVvZiBlKXRyeXtlPUpTT04ucGFyc2UoZSl9Y2F0Y2godCl7ZT17fX10aGlzLl9kZWJ1ZyhcInNpZ25hbCgpXCIpLGUucmVuZWdvdGlhdGUmJnRoaXMuaW5pdGlhdG9yJiYodGhpcy5fZGVidWcoXCJnb3QgcmVxdWVzdCB0byByZW5lZ290aWF0ZVwiKSx0aGlzLl9uZWVkc05lZ290aWF0aW9uKCkpLGUudHJhbnNjZWl2ZXJSZXF1ZXN0JiZ0aGlzLmluaXRpYXRvciYmKHRoaXMuX2RlYnVnKFwiZ290IHJlcXVlc3QgZm9yIHRyYW5zY2VpdmVyXCIpLHRoaXMuYWRkVHJhbnNjZWl2ZXIoZS50cmFuc2NlaXZlclJlcXVlc3Qua2luZCxlLnRyYW5zY2VpdmVyUmVxdWVzdC5pbml0KSksZS5jYW5kaWRhdGUmJih0aGlzLl9wYy5yZW1vdGVEZXNjcmlwdGlvbiYmdGhpcy5fcGMucmVtb3RlRGVzY3JpcHRpb24udHlwZT90aGlzLl9hZGRJY2VDYW5kaWRhdGUoZS5jYW5kaWRhdGUpOnRoaXMuX3BlbmRpbmdDYW5kaWRhdGVzLnB1c2goZS5jYW5kaWRhdGUpKSxlLnNkcCYmdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24obmV3IHRoaXMuX3dydGMuUlRDU2Vzc2lvbkRlc2NyaXB0aW9uKGUpKS50aGVuKCgpPT57dGhpcy5kZXN0cm95ZWR8fCh0aGlzLl9wZW5kaW5nQ2FuZGlkYXRlcy5mb3JFYWNoKGU9Pnt0aGlzLl9hZGRJY2VDYW5kaWRhdGUoZSl9KSx0aGlzLl9wZW5kaW5nQ2FuZGlkYXRlcz1bXSxcIm9mZmVyXCI9PT10aGlzLl9wYy5yZW1vdGVEZXNjcmlwdGlvbi50eXBlJiZ0aGlzLl9jcmVhdGVBbnN3ZXIoKSl9KS5jYXRjaChlPT57dGhpcy5kZXN0cm95KGwoZSxcIkVSUl9TRVRfUkVNT1RFX0RFU0NSSVBUSU9OXCIpKX0pLGUuc2RwfHxlLmNhbmRpZGF0ZXx8ZS5yZW5lZ290aWF0ZXx8ZS50cmFuc2NlaXZlclJlcXVlc3R8fHRoaXMuZGVzdHJveShsKG5ldyBFcnJvcihcInNpZ25hbCgpIGNhbGxlZCB3aXRoIGludmFsaWQgc2lnbmFsIGRhdGFcIiksXCJFUlJfU0lHTkFMSU5HXCIpKX19X2FkZEljZUNhbmRpZGF0ZShlKXtjb25zdCB0PW5ldyB0aGlzLl93cnRjLlJUQ0ljZUNhbmRpZGF0ZShlKTt0aGlzLl9wYy5hZGRJY2VDYW5kaWRhdGUodCkuY2F0Y2goZT0+eyF0LmFkZHJlc3N8fHQuYWRkcmVzcy5lbmRzV2l0aChcIi5sb2NhbFwiKT9yKFwiSWdub3JpbmcgdW5zdXBwb3J0ZWQgSUNFIGNhbmRpZGF0ZS5cIik6dGhpcy5kZXN0cm95KGwoZSxcIkVSUl9BRERfSUNFX0NBTkRJREFURVwiKSl9KX1zZW5kKGUpe2lmKCF0aGlzLmRlc3Ryb3lpbmcpe2lmKHRoaXMuZGVzdHJveWVkKXRocm93IGwobmV3IEVycm9yKFwiY2Fubm90IHNlbmQgYWZ0ZXIgcGVlciBpcyBkZXN0cm95ZWRcIiksXCJFUlJfREVTVFJPWUVEXCIpO3RoaXMuX2NoYW5uZWwuc2VuZChlKX19YWRkVHJhbnNjZWl2ZXIoZSx0KXtpZighdGhpcy5kZXN0cm95aW5nKXtpZih0aGlzLmRlc3Ryb3llZCl0aHJvdyBsKG5ldyBFcnJvcihcImNhbm5vdCBhZGRUcmFuc2NlaXZlciBhZnRlciBwZWVyIGlzIGRlc3Ryb3llZFwiKSxcIkVSUl9ERVNUUk9ZRURcIik7aWYodGhpcy5fZGVidWcoXCJhZGRUcmFuc2NlaXZlcigpXCIpLHRoaXMuaW5pdGlhdG9yKXRyeXt0aGlzLl9wYy5hZGRUcmFuc2NlaXZlcihlLHQpLHRoaXMuX25lZWRzTmVnb3RpYXRpb24oKX1jYXRjaChlKXt0aGlzLmRlc3Ryb3kobChlLFwiRVJSX0FERF9UUkFOU0NFSVZFUlwiKSl9ZWxzZSB0aGlzLmVtaXQoXCJzaWduYWxcIix7dHlwZTpcInRyYW5zY2VpdmVyUmVxdWVzdFwiLHRyYW5zY2VpdmVyUmVxdWVzdDp7a2luZDplLGluaXQ6dH19KX19YWRkU3RyZWFtKGUpe2lmKCF0aGlzLmRlc3Ryb3lpbmcpe2lmKHRoaXMuZGVzdHJveWVkKXRocm93IGwobmV3IEVycm9yKFwiY2Fubm90IGFkZFN0cmVhbSBhZnRlciBwZWVyIGlzIGRlc3Ryb3llZFwiKSxcIkVSUl9ERVNUUk9ZRURcIik7dGhpcy5fZGVidWcoXCJhZGRTdHJlYW0oKVwiKSxlLmdldFRyYWNrcygpLmZvckVhY2godD0+e3RoaXMuYWRkVHJhY2sodCxlKX0pfX1hZGRUcmFjayhlLHQpe2lmKHRoaXMuZGVzdHJveWluZylyZXR1cm47aWYodGhpcy5kZXN0cm95ZWQpdGhyb3cgbChuZXcgRXJyb3IoXCJjYW5ub3QgYWRkVHJhY2sgYWZ0ZXIgcGVlciBpcyBkZXN0cm95ZWRcIiksXCJFUlJfREVTVFJPWUVEXCIpO3RoaXMuX2RlYnVnKFwiYWRkVHJhY2soKVwiKTtjb25zdCBuPXRoaXMuX3NlbmRlck1hcC5nZXQoZSl8fG5ldyBNYXA7bGV0IHI9bi5nZXQodCk7aWYoIXIpcj10aGlzLl9wYy5hZGRUcmFjayhlLHQpLG4uc2V0KHQsciksdGhpcy5fc2VuZGVyTWFwLnNldChlLG4pLHRoaXMuX25lZWRzTmVnb3RpYXRpb24oKTtlbHNlIGlmKHIucmVtb3ZlZCl0aHJvdyBsKG5ldyBFcnJvcihcIlRyYWNrIGhhcyBiZWVuIHJlbW92ZWQuIFlvdSBzaG91bGQgZW5hYmxlL2Rpc2FibGUgdHJhY2tzIHRoYXQgeW91IHdhbnQgdG8gcmUtYWRkLlwiKSxcIkVSUl9TRU5ERVJfUkVNT1ZFRFwiKTtlbHNlIHRocm93IGwobmV3IEVycm9yKFwiVHJhY2sgaGFzIGFscmVhZHkgYmVlbiBhZGRlZCB0byB0aGF0IHN0cmVhbS5cIiksXCJFUlJfU0VOREVSX0FMUkVBRFlfQURERURcIil9cmVwbGFjZVRyYWNrKGUsdCxuKXtpZih0aGlzLmRlc3Ryb3lpbmcpcmV0dXJuO2lmKHRoaXMuZGVzdHJveWVkKXRocm93IGwobmV3IEVycm9yKFwiY2Fubm90IHJlcGxhY2VUcmFjayBhZnRlciBwZWVyIGlzIGRlc3Ryb3llZFwiKSxcIkVSUl9ERVNUUk9ZRURcIik7dGhpcy5fZGVidWcoXCJyZXBsYWNlVHJhY2soKVwiKTtjb25zdCByPXRoaXMuX3NlbmRlck1hcC5nZXQoZSksYT1yP3IuZ2V0KG4pOm51bGw7aWYoIWEpdGhyb3cgbChuZXcgRXJyb3IoXCJDYW5ub3QgcmVwbGFjZSB0cmFjayB0aGF0IHdhcyBuZXZlciBhZGRlZC5cIiksXCJFUlJfVFJBQ0tfTk9UX0FEREVEXCIpO3QmJnRoaXMuX3NlbmRlck1hcC5zZXQodCxyKSxudWxsPT1hLnJlcGxhY2VUcmFjaz90aGlzLmRlc3Ryb3kobChuZXcgRXJyb3IoXCJyZXBsYWNlVHJhY2sgaXMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXJcIiksXCJFUlJfVU5TVVBQT1JURURfUkVQTEFDRVRSQUNLXCIpKTphLnJlcGxhY2VUcmFjayh0KX1yZW1vdmVUcmFjayhlLHQpe2lmKHRoaXMuZGVzdHJveWluZylyZXR1cm47aWYodGhpcy5kZXN0cm95ZWQpdGhyb3cgbChuZXcgRXJyb3IoXCJjYW5ub3QgcmVtb3ZlVHJhY2sgYWZ0ZXIgcGVlciBpcyBkZXN0cm95ZWRcIiksXCJFUlJfREVTVFJPWUVEXCIpO3RoaXMuX2RlYnVnKFwicmVtb3ZlU2VuZGVyKClcIik7Y29uc3Qgbj10aGlzLl9zZW5kZXJNYXAuZ2V0KGUpLHI9bj9uLmdldCh0KTpudWxsO2lmKCFyKXRocm93IGwobmV3IEVycm9yKFwiQ2Fubm90IHJlbW92ZSB0cmFjayB0aGF0IHdhcyBuZXZlciBhZGRlZC5cIiksXCJFUlJfVFJBQ0tfTk9UX0FEREVEXCIpO3RyeXtyLnJlbW92ZWQ9ITAsdGhpcy5fcGMucmVtb3ZlVHJhY2socil9Y2F0Y2goZSl7XCJOU19FUlJPUl9VTkVYUEVDVEVEXCI9PT1lLm5hbWU/dGhpcy5fc2VuZGVyc0F3YWl0aW5nU3RhYmxlLnB1c2gocik6dGhpcy5kZXN0cm95KGwoZSxcIkVSUl9SRU1PVkVfVFJBQ0tcIikpfXRoaXMuX25lZWRzTmVnb3RpYXRpb24oKX1yZW1vdmVTdHJlYW0oZSl7aWYoIXRoaXMuZGVzdHJveWluZyl7aWYodGhpcy5kZXN0cm95ZWQpdGhyb3cgbChuZXcgRXJyb3IoXCJjYW5ub3QgcmVtb3ZlU3RyZWFtIGFmdGVyIHBlZXIgaXMgZGVzdHJveWVkXCIpLFwiRVJSX0RFU1RST1lFRFwiKTt0aGlzLl9kZWJ1ZyhcInJlbW92ZVNlbmRlcnMoKVwiKSxlLmdldFRyYWNrcygpLmZvckVhY2godD0+e3RoaXMucmVtb3ZlVHJhY2sodCxlKX0pfX1fbmVlZHNOZWdvdGlhdGlvbigpe3RoaXMuX2RlYnVnKFwiX25lZWRzTmVnb3RpYXRpb25cIiksdGhpcy5fYmF0Y2hlZE5lZ290aWF0aW9ufHwodGhpcy5fYmF0Y2hlZE5lZ290aWF0aW9uPSEwLHMoKCk9Pnt0aGlzLl9iYXRjaGVkTmVnb3RpYXRpb249ITEsdGhpcy5pbml0aWF0b3J8fCF0aGlzLl9maXJzdE5lZ290aWF0aW9uPyh0aGlzLl9kZWJ1ZyhcInN0YXJ0aW5nIGJhdGNoZWQgbmVnb3RpYXRpb25cIiksdGhpcy5uZWdvdGlhdGUoKSk6dGhpcy5fZGVidWcoXCJub24taW5pdGlhdG9yIGluaXRpYWwgbmVnb3RpYXRpb24gcmVxdWVzdCBkaXNjYXJkZWRcIiksdGhpcy5fZmlyc3ROZWdvdGlhdGlvbj0hMX0pKX1uZWdvdGlhdGUoKXtpZighdGhpcy5kZXN0cm95aW5nKXtpZih0aGlzLmRlc3Ryb3llZCl0aHJvdyBsKG5ldyBFcnJvcihcImNhbm5vdCBuZWdvdGlhdGUgYWZ0ZXIgcGVlciBpcyBkZXN0cm95ZWRcIiksXCJFUlJfREVTVFJPWUVEXCIpO3RoaXMuaW5pdGlhdG9yP3RoaXMuX2lzTmVnb3RpYXRpbmc/KHRoaXMuX3F1ZXVlZE5lZ290aWF0aW9uPSEwLHRoaXMuX2RlYnVnKFwiYWxyZWFkeSBuZWdvdGlhdGluZywgcXVldWVpbmdcIikpOih0aGlzLl9kZWJ1ZyhcInN0YXJ0IG5lZ290aWF0aW9uXCIpLHNldFRpbWVvdXQoKCk9Pnt0aGlzLl9jcmVhdGVPZmZlcigpfSwwKSk6dGhpcy5faXNOZWdvdGlhdGluZz8odGhpcy5fcXVldWVkTmVnb3RpYXRpb249ITAsdGhpcy5fZGVidWcoXCJhbHJlYWR5IG5lZ290aWF0aW5nLCBxdWV1ZWluZ1wiKSk6KHRoaXMuX2RlYnVnKFwicmVxdWVzdGluZyBuZWdvdGlhdGlvbiBmcm9tIGluaXRpYXRvclwiKSx0aGlzLmVtaXQoXCJzaWduYWxcIix7dHlwZTpcInJlbmVnb3RpYXRlXCIscmVuZWdvdGlhdGU6ITB9KSksdGhpcy5faXNOZWdvdGlhdGluZz0hMH19ZGVzdHJveShlKXt0aGlzLl9kZXN0cm95KGUsKCk9Pnt9KX1fZGVzdHJveShlLHQpe3RoaXMuZGVzdHJveWVkfHx0aGlzLmRlc3Ryb3lpbmd8fCh0aGlzLmRlc3Ryb3lpbmc9ITAsdGhpcy5fZGVidWcoXCJkZXN0cm95aW5nIChlcnJvcjogJXMpXCIsZSYmKGUubWVzc2FnZXx8ZSkpLHMoKCk9PntpZih0aGlzLmRlc3Ryb3llZD0hMCx0aGlzLmRlc3Ryb3lpbmc9ITEsdGhpcy5fZGVidWcoXCJkZXN0cm95IChlcnJvcjogJXMpXCIsZSYmKGUubWVzc2FnZXx8ZSkpLHRoaXMucmVhZGFibGU9dGhpcy53cml0YWJsZT0hMSx0aGlzLl9yZWFkYWJsZVN0YXRlLmVuZGVkfHx0aGlzLnB1c2gobnVsbCksdGhpcy5fd3JpdGFibGVTdGF0ZS5maW5pc2hlZHx8dGhpcy5lbmQoKSx0aGlzLl9jb25uZWN0ZWQ9ITEsdGhpcy5fcGNSZWFkeT0hMSx0aGlzLl9jaGFubmVsUmVhZHk9ITEsdGhpcy5fcmVtb3RlVHJhY2tzPW51bGwsdGhpcy5fcmVtb3RlU3RyZWFtcz1udWxsLHRoaXMuX3NlbmRlck1hcD1udWxsLGNsZWFySW50ZXJ2YWwodGhpcy5fY2xvc2luZ0ludGVydmFsKSx0aGlzLl9jbG9zaW5nSW50ZXJ2YWw9bnVsbCxjbGVhckludGVydmFsKHRoaXMuX2ludGVydmFsKSx0aGlzLl9pbnRlcnZhbD1udWxsLHRoaXMuX2NodW5rPW51bGwsdGhpcy5fY2I9bnVsbCx0aGlzLl9vbkZpbmlzaEJvdW5kJiZ0aGlzLnJlbW92ZUxpc3RlbmVyKFwiZmluaXNoXCIsdGhpcy5fb25GaW5pc2hCb3VuZCksdGhpcy5fb25GaW5pc2hCb3VuZD1udWxsLHRoaXMuX2NoYW5uZWwpe3RyeXt0aGlzLl9jaGFubmVsLmNsb3NlKCl9Y2F0Y2goZSl7fXRoaXMuX2NoYW5uZWwub25tZXNzYWdlPW51bGwsdGhpcy5fY2hhbm5lbC5vbm9wZW49bnVsbCx0aGlzLl9jaGFubmVsLm9uY2xvc2U9bnVsbCx0aGlzLl9jaGFubmVsLm9uZXJyb3I9bnVsbH1pZih0aGlzLl9wYyl7dHJ5e3RoaXMuX3BjLmNsb3NlKCl9Y2F0Y2goZSl7fXRoaXMuX3BjLm9uaWNlY29ubmVjdGlvbnN0YXRlY2hhbmdlPW51bGwsdGhpcy5fcGMub25pY2VnYXRoZXJpbmdzdGF0ZWNoYW5nZT1udWxsLHRoaXMuX3BjLm9uc2lnbmFsaW5nc3RhdGVjaGFuZ2U9bnVsbCx0aGlzLl9wYy5vbmljZWNhbmRpZGF0ZT1udWxsLHRoaXMuX3BjLm9udHJhY2s9bnVsbCx0aGlzLl9wYy5vbmRhdGFjaGFubmVsPW51bGx9dGhpcy5fcGM9bnVsbCx0aGlzLl9jaGFubmVsPW51bGwsZSYmdGhpcy5lbWl0KFwiZXJyb3JcIixlKSx0aGlzLmVtaXQoXCJjbG9zZVwiKSx0KCl9KSl9X3NldHVwRGF0YShlKXtpZighZS5jaGFubmVsKXJldHVybiB0aGlzLmRlc3Ryb3kobChuZXcgRXJyb3IoXCJEYXRhIGNoYW5uZWwgZXZlbnQgaXMgbWlzc2luZyBgY2hhbm5lbGAgcHJvcGVydHlcIiksXCJFUlJfREFUQV9DSEFOTkVMXCIpKTt0aGlzLl9jaGFubmVsPWUuY2hhbm5lbCx0aGlzLl9jaGFubmVsLmJpbmFyeVR5cGU9XCJhcnJheWJ1ZmZlclwiLFwibnVtYmVyXCI9PXR5cGVvZiB0aGlzLl9jaGFubmVsLmJ1ZmZlcmVkQW1vdW50TG93VGhyZXNob2xkJiYodGhpcy5fY2hhbm5lbC5idWZmZXJlZEFtb3VudExvd1RocmVzaG9sZD11KSx0aGlzLmNoYW5uZWxOYW1lPXRoaXMuX2NoYW5uZWwubGFiZWwsdGhpcy5fY2hhbm5lbC5vbm1lc3NhZ2U9ZT0+e3RoaXMuX29uQ2hhbm5lbE1lc3NhZ2UoZSl9LHRoaXMuX2NoYW5uZWwub25idWZmZXJlZGFtb3VudGxvdz0oKT0+e3RoaXMuX29uQ2hhbm5lbEJ1ZmZlcmVkQW1vdW50TG93KCl9LHRoaXMuX2NoYW5uZWwub25vcGVuPSgpPT57dGhpcy5fb25DaGFubmVsT3BlbigpfSx0aGlzLl9jaGFubmVsLm9uY2xvc2U9KCk9Pnt0aGlzLl9vbkNoYW5uZWxDbG9zZSgpfSx0aGlzLl9jaGFubmVsLm9uZXJyb3I9ZT0+e2NvbnN0IHQ9ZS5lcnJvciBpbnN0YW5jZW9mIEVycm9yP2UuZXJyb3I6bmV3IEVycm9yKGBEYXRhY2hhbm5lbCBlcnJvcjogJHtlLm1lc3NhZ2V9ICR7ZS5maWxlbmFtZX06JHtlLmxpbmVub306JHtlLmNvbG5vfWApO3RoaXMuZGVzdHJveShsKHQsXCJFUlJfREFUQV9DSEFOTkVMXCIpKX07bGV0IHQ9ITE7dGhpcy5fY2xvc2luZ0ludGVydmFsPXNldEludGVydmFsKCgpPT57dGhpcy5fY2hhbm5lbCYmXCJjbG9zaW5nXCI9PT10aGlzLl9jaGFubmVsLnJlYWR5U3RhdGU/KHQmJnRoaXMuX29uQ2hhbm5lbENsb3NlKCksdD0hMCk6dD0hMX0sNTAwMCl9X3JlYWQoKXt9X3dyaXRlKGUsdCxuKXtpZih0aGlzLmRlc3Ryb3llZClyZXR1cm4gbihsKG5ldyBFcnJvcihcImNhbm5vdCB3cml0ZSBhZnRlciBwZWVyIGlzIGRlc3Ryb3llZFwiKSxcIkVSUl9EQVRBX0NIQU5ORUxcIikpO2lmKHRoaXMuX2Nvbm5lY3RlZCl7dHJ5e3RoaXMuc2VuZChlKX1jYXRjaChlKXtyZXR1cm4gdGhpcy5kZXN0cm95KGwoZSxcIkVSUl9EQVRBX0NIQU5ORUxcIikpfXRoaXMuX2NoYW5uZWwuYnVmZmVyZWRBbW91bnQ+dT8odGhpcy5fZGVidWcoXCJzdGFydCBiYWNrcHJlc3N1cmU6IGJ1ZmZlcmVkQW1vdW50ICVkXCIsdGhpcy5fY2hhbm5lbC5idWZmZXJlZEFtb3VudCksdGhpcy5fY2I9bik6bihudWxsKX1lbHNlIHRoaXMuX2RlYnVnKFwid3JpdGUgYmVmb3JlIGNvbm5lY3RcIiksdGhpcy5fY2h1bms9ZSx0aGlzLl9jYj1ufV9vbkZpbmlzaCgpe2lmKCF0aGlzLmRlc3Ryb3llZCl7Y29uc3QgZT0oKT0+e3NldFRpbWVvdXQoKCk9PnRoaXMuZGVzdHJveSgpLDFlMyl9O3RoaXMuX2Nvbm5lY3RlZD9lKCk6dGhpcy5vbmNlKFwiY29ubmVjdFwiLGUpfX1fc3RhcnRJY2VDb21wbGV0ZVRpbWVvdXQoKXt0aGlzLmRlc3Ryb3llZHx8dGhpcy5faWNlQ29tcGxldGVUaW1lcnx8KHRoaXMuX2RlYnVnKFwic3RhcnRlZCBpY2VDb21wbGV0ZSB0aW1lb3V0XCIpLHRoaXMuX2ljZUNvbXBsZXRlVGltZXI9c2V0VGltZW91dCgoKT0+e3RoaXMuX2ljZUNvbXBsZXRlfHwodGhpcy5faWNlQ29tcGxldGU9ITAsdGhpcy5fZGVidWcoXCJpY2VDb21wbGV0ZSB0aW1lb3V0IGNvbXBsZXRlZFwiKSx0aGlzLmVtaXQoXCJpY2VUaW1lb3V0XCIpLHRoaXMuZW1pdChcIl9pY2VDb21wbGV0ZVwiKSl9LHRoaXMuaWNlQ29tcGxldGVUaW1lb3V0KSl9X2NyZWF0ZU9mZmVyKCl7dGhpcy5kZXN0cm95ZWR8fHRoaXMuX3BjLmNyZWF0ZU9mZmVyKHRoaXMub2ZmZXJPcHRpb25zKS50aGVuKGU9PntpZih0aGlzLmRlc3Ryb3llZClyZXR1cm47dGhpcy50cmlja2xlfHx0aGlzLmFsbG93SGFsZlRyaWNrbGV8fChlLnNkcD1uKGUuc2RwKSksZS5zZHA9dGhpcy5zZHBUcmFuc2Zvcm0oZS5zZHApO2NvbnN0IHQ9KCk9PntpZighdGhpcy5kZXN0cm95ZWQpe2NvbnN0IHQ9dGhpcy5fcGMubG9jYWxEZXNjcmlwdGlvbnx8ZTt0aGlzLl9kZWJ1ZyhcInNpZ25hbFwiKSx0aGlzLmVtaXQoXCJzaWduYWxcIix7dHlwZTp0LnR5cGUsc2RwOnQuc2RwfSl9fTt0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKGUpLnRoZW4oKCk9Pnt0aGlzLl9kZWJ1ZyhcImNyZWF0ZU9mZmVyIHN1Y2Nlc3NcIiksdGhpcy5kZXN0cm95ZWR8fCh0aGlzLnRyaWNrbGV8fHRoaXMuX2ljZUNvbXBsZXRlP3QoKTp0aGlzLm9uY2UoXCJfaWNlQ29tcGxldGVcIix0KSl9KS5jYXRjaChlPT57dGhpcy5kZXN0cm95KGwoZSxcIkVSUl9TRVRfTE9DQUxfREVTQ1JJUFRJT05cIikpfSl9KS5jYXRjaChlPT57dGhpcy5kZXN0cm95KGwoZSxcIkVSUl9DUkVBVEVfT0ZGRVJcIikpfSl9X3JlcXVlc3RNaXNzaW5nVHJhbnNjZWl2ZXJzKCl7dGhpcy5fcGMuZ2V0VHJhbnNjZWl2ZXJzJiZ0aGlzLl9wYy5nZXRUcmFuc2NlaXZlcnMoKS5mb3JFYWNoKGU9PntlLm1pZHx8IWUuc2VuZGVyLnRyYWNrfHxlLnJlcXVlc3RlZHx8KGUucmVxdWVzdGVkPSEwLHRoaXMuYWRkVHJhbnNjZWl2ZXIoZS5zZW5kZXIudHJhY2sua2luZCkpfSl9X2NyZWF0ZUFuc3dlcigpe3RoaXMuZGVzdHJveWVkfHx0aGlzLl9wYy5jcmVhdGVBbnN3ZXIodGhpcy5hbnN3ZXJPcHRpb25zKS50aGVuKGU9PntpZih0aGlzLmRlc3Ryb3llZClyZXR1cm47dGhpcy50cmlja2xlfHx0aGlzLmFsbG93SGFsZlRyaWNrbGV8fChlLnNkcD1uKGUuc2RwKSksZS5zZHA9dGhpcy5zZHBUcmFuc2Zvcm0oZS5zZHApO2NvbnN0IHQ9KCk9PntpZighdGhpcy5kZXN0cm95ZWQpe2NvbnN0IHQ9dGhpcy5fcGMubG9jYWxEZXNjcmlwdGlvbnx8ZTt0aGlzLl9kZWJ1ZyhcInNpZ25hbFwiKSx0aGlzLmVtaXQoXCJzaWduYWxcIix7dHlwZTp0LnR5cGUsc2RwOnQuc2RwfSksdGhpcy5pbml0aWF0b3J8fHRoaXMuX3JlcXVlc3RNaXNzaW5nVHJhbnNjZWl2ZXJzKCl9fTt0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKGUpLnRoZW4oKCk9Pnt0aGlzLmRlc3Ryb3llZHx8KHRoaXMudHJpY2tsZXx8dGhpcy5faWNlQ29tcGxldGU/dCgpOnRoaXMub25jZShcIl9pY2VDb21wbGV0ZVwiLHQpKX0pLmNhdGNoKGU9Pnt0aGlzLmRlc3Ryb3kobChlLFwiRVJSX1NFVF9MT0NBTF9ERVNDUklQVElPTlwiKSl9KX0pLmNhdGNoKGU9Pnt0aGlzLmRlc3Ryb3kobChlLFwiRVJSX0NSRUFURV9BTlNXRVJcIikpfSl9X29uQ29ubmVjdGlvblN0YXRlQ2hhbmdlKCl7dGhpcy5kZXN0cm95ZWR8fFwiZmFpbGVkXCI9PT10aGlzLl9wYy5jb25uZWN0aW9uU3RhdGUmJnRoaXMuZGVzdHJveShsKG5ldyBFcnJvcihcIkNvbm5lY3Rpb24gZmFpbGVkLlwiKSxcIkVSUl9DT05ORUNUSU9OX0ZBSUxVUkVcIikpfV9vbkljZVN0YXRlQ2hhbmdlKCl7aWYodGhpcy5kZXN0cm95ZWQpcmV0dXJuO2NvbnN0IGU9dGhpcy5fcGMuaWNlQ29ubmVjdGlvblN0YXRlLHQ9dGhpcy5fcGMuaWNlR2F0aGVyaW5nU3RhdGU7dGhpcy5fZGVidWcoXCJpY2VTdGF0ZUNoYW5nZSAoY29ubmVjdGlvbjogJXMpIChnYXRoZXJpbmc6ICVzKVwiLGUsdCksdGhpcy5lbWl0KFwiaWNlU3RhdGVDaGFuZ2VcIixlLHQpLChcImNvbm5lY3RlZFwiPT09ZXx8XCJjb21wbGV0ZWRcIj09PWUpJiYodGhpcy5fcGNSZWFkeT0hMCx0aGlzLl9tYXliZVJlYWR5KCkpLFwiZmFpbGVkXCI9PT1lJiZ0aGlzLmRlc3Ryb3kobChuZXcgRXJyb3IoXCJJY2UgY29ubmVjdGlvbiBmYWlsZWQuXCIpLFwiRVJSX0lDRV9DT05ORUNUSU9OX0ZBSUxVUkVcIikpLFwiY2xvc2VkXCI9PT1lJiZ0aGlzLmRlc3Ryb3kobChuZXcgRXJyb3IoXCJJY2UgY29ubmVjdGlvbiBjbG9zZWQuXCIpLFwiRVJSX0lDRV9DT05ORUNUSU9OX0NMT1NFRFwiKSl9Z2V0U3RhdHMoZSl7Y29uc3QgdD1lPT4oXCJbb2JqZWN0IEFycmF5XVwiPT09T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGUudmFsdWVzKSYmZS52YWx1ZXMuZm9yRWFjaCh0PT57T2JqZWN0LmFzc2lnbihlLHQpfSksZSk7MD09PXRoaXMuX3BjLmdldFN0YXRzLmxlbmd0aHx8dGhpcy5faXNSZWFjdE5hdGl2ZVdlYnJ0Yz90aGlzLl9wYy5nZXRTdGF0cygpLnRoZW4obj0+e2NvbnN0IHI9W107bi5mb3JFYWNoKGU9PntyLnB1c2godChlKSl9KSxlKG51bGwscil9LHQ9PmUodCkpOjA8dGhpcy5fcGMuZ2V0U3RhdHMubGVuZ3RoP3RoaXMuX3BjLmdldFN0YXRzKG49PntpZih0aGlzLmRlc3Ryb3llZClyZXR1cm47Y29uc3Qgcj1bXTtuLnJlc3VsdCgpLmZvckVhY2goZT0+e2NvbnN0IG49e307ZS5uYW1lcygpLmZvckVhY2godD0+e25bdF09ZS5zdGF0KHQpfSksbi5pZD1lLmlkLG4udHlwZT1lLnR5cGUsbi50aW1lc3RhbXA9ZS50aW1lc3RhbXAsci5wdXNoKHQobikpfSksZShudWxsLHIpfSx0PT5lKHQpKTplKG51bGwsW10pfV9tYXliZVJlYWR5KCl7aWYodGhpcy5fZGVidWcoXCJtYXliZVJlYWR5IHBjICVzIGNoYW5uZWwgJXNcIix0aGlzLl9wY1JlYWR5LHRoaXMuX2NoYW5uZWxSZWFkeSksdGhpcy5fY29ubmVjdGVkfHx0aGlzLl9jb25uZWN0aW5nfHwhdGhpcy5fcGNSZWFkeXx8IXRoaXMuX2NoYW5uZWxSZWFkeSlyZXR1cm47dGhpcy5fY29ubmVjdGluZz0hMDtjb25zdCBlPSgpPT57dGhpcy5kZXN0cm95ZWR8fHRoaXMuZ2V0U3RhdHMoKHQsbik9PntpZih0aGlzLmRlc3Ryb3llZClyZXR1cm47dCYmKG49W10pO2NvbnN0IHI9e30sYT17fSxvPXt9O2xldCBpPSExO24uZm9yRWFjaChlPT57KFwicmVtb3RlY2FuZGlkYXRlXCI9PT1lLnR5cGV8fFwicmVtb3RlLWNhbmRpZGF0ZVwiPT09ZS50eXBlKSYmKHJbZS5pZF09ZSksKFwibG9jYWxjYW5kaWRhdGVcIj09PWUudHlwZXx8XCJsb2NhbC1jYW5kaWRhdGVcIj09PWUudHlwZSkmJihhW2UuaWRdPWUpLChcImNhbmRpZGF0ZXBhaXJcIj09PWUudHlwZXx8XCJjYW5kaWRhdGUtcGFpclwiPT09ZS50eXBlKSYmKG9bZS5pZF09ZSl9KTtjb25zdCBkPWU9PntpPSEwO2xldCB0PWFbZS5sb2NhbENhbmRpZGF0ZUlkXTt0JiYodC5pcHx8dC5hZGRyZXNzKT8odGhpcy5sb2NhbEFkZHJlc3M9dC5pcHx8dC5hZGRyZXNzLHRoaXMubG9jYWxQb3J0PSt0LnBvcnQpOnQmJnQuaXBBZGRyZXNzPyh0aGlzLmxvY2FsQWRkcmVzcz10LmlwQWRkcmVzcyx0aGlzLmxvY2FsUG9ydD0rdC5wb3J0TnVtYmVyKTpcInN0cmluZ1wiPT10eXBlb2YgZS5nb29nTG9jYWxBZGRyZXNzJiYodD1lLmdvb2dMb2NhbEFkZHJlc3Muc3BsaXQoXCI6XCIpLHRoaXMubG9jYWxBZGRyZXNzPXRbMF0sdGhpcy5sb2NhbFBvcnQ9K3RbMV0pLHRoaXMubG9jYWxBZGRyZXNzJiYodGhpcy5sb2NhbEZhbWlseT10aGlzLmxvY2FsQWRkcmVzcy5pbmNsdWRlcyhcIjpcIik/XCJJUHY2XCI6XCJJUHY0XCIpO2xldCBuPXJbZS5yZW1vdGVDYW5kaWRhdGVJZF07biYmKG4uaXB8fG4uYWRkcmVzcyk/KHRoaXMucmVtb3RlQWRkcmVzcz1uLmlwfHxuLmFkZHJlc3MsdGhpcy5yZW1vdGVQb3J0PStuLnBvcnQpOm4mJm4uaXBBZGRyZXNzPyh0aGlzLnJlbW90ZUFkZHJlc3M9bi5pcEFkZHJlc3MsdGhpcy5yZW1vdGVQb3J0PStuLnBvcnROdW1iZXIpOlwic3RyaW5nXCI9PXR5cGVvZiBlLmdvb2dSZW1vdGVBZGRyZXNzJiYobj1lLmdvb2dSZW1vdGVBZGRyZXNzLnNwbGl0KFwiOlwiKSx0aGlzLnJlbW90ZUFkZHJlc3M9blswXSx0aGlzLnJlbW90ZVBvcnQ9K25bMV0pLHRoaXMucmVtb3RlQWRkcmVzcyYmKHRoaXMucmVtb3RlRmFtaWx5PXRoaXMucmVtb3RlQWRkcmVzcy5pbmNsdWRlcyhcIjpcIik/XCJJUHY2XCI6XCJJUHY0XCIpLHRoaXMuX2RlYnVnKFwiY29ubmVjdCBsb2NhbDogJXM6JXMgcmVtb3RlOiAlczolc1wiLHRoaXMubG9jYWxBZGRyZXNzLHRoaXMubG9jYWxQb3J0LHRoaXMucmVtb3RlQWRkcmVzcyx0aGlzLnJlbW90ZVBvcnQpfTtpZihuLmZvckVhY2goZT0+e1widHJhbnNwb3J0XCI9PT1lLnR5cGUmJmUuc2VsZWN0ZWRDYW5kaWRhdGVQYWlySWQmJmQob1tlLnNlbGVjdGVkQ2FuZGlkYXRlUGFpcklkXSksKFwiZ29vZ0NhbmRpZGF0ZVBhaXJcIj09PWUudHlwZSYmXCJ0cnVlXCI9PT1lLmdvb2dBY3RpdmVDb25uZWN0aW9ufHwoXCJjYW5kaWRhdGVwYWlyXCI9PT1lLnR5cGV8fFwiY2FuZGlkYXRlLXBhaXJcIj09PWUudHlwZSkmJmUuc2VsZWN0ZWQpJiZkKGUpfSksIWkmJighT2JqZWN0LmtleXMobykubGVuZ3RofHxPYmplY3Qua2V5cyhhKS5sZW5ndGgpKXJldHVybiB2b2lkIHNldFRpbWVvdXQoZSwxMDApO2lmKHRoaXMuX2Nvbm5lY3Rpbmc9ITEsdGhpcy5fY29ubmVjdGVkPSEwLHRoaXMuX2NodW5rKXt0cnl7dGhpcy5zZW5kKHRoaXMuX2NodW5rKX1jYXRjaChlKXtyZXR1cm4gdGhpcy5kZXN0cm95KGwoZSxcIkVSUl9EQVRBX0NIQU5ORUxcIikpfXRoaXMuX2NodW5rPW51bGwsdGhpcy5fZGVidWcoXCJzZW50IGNodW5rIGZyb20gXFxcIndyaXRlIGJlZm9yZSBjb25uZWN0XFxcIlwiKTtjb25zdCBlPXRoaXMuX2NiO3RoaXMuX2NiPW51bGwsZShudWxsKX1cIm51bWJlclwiIT10eXBlb2YgdGhpcy5fY2hhbm5lbC5idWZmZXJlZEFtb3VudExvd1RocmVzaG9sZCYmKHRoaXMuX2ludGVydmFsPXNldEludGVydmFsKCgpPT50aGlzLl9vbkludGVydmFsKCksMTUwKSx0aGlzLl9pbnRlcnZhbC51bnJlZiYmdGhpcy5faW50ZXJ2YWwudW5yZWYoKSksdGhpcy5fZGVidWcoXCJjb25uZWN0XCIpLHRoaXMuZW1pdChcImNvbm5lY3RcIil9KX07ZSgpfV9vbkludGVydmFsKCl7dGhpcy5fY2ImJnRoaXMuX2NoYW5uZWwmJiEodGhpcy5fY2hhbm5lbC5idWZmZXJlZEFtb3VudD51KSYmdGhpcy5fb25DaGFubmVsQnVmZmVyZWRBbW91bnRMb3coKX1fb25TaWduYWxpbmdTdGF0ZUNoYW5nZSgpe3RoaXMuZGVzdHJveWVkfHwoXCJzdGFibGVcIj09PXRoaXMuX3BjLnNpZ25hbGluZ1N0YXRlJiYodGhpcy5faXNOZWdvdGlhdGluZz0hMSx0aGlzLl9kZWJ1ZyhcImZsdXNoaW5nIHNlbmRlciBxdWV1ZVwiLHRoaXMuX3NlbmRlcnNBd2FpdGluZ1N0YWJsZSksdGhpcy5fc2VuZGVyc0F3YWl0aW5nU3RhYmxlLmZvckVhY2goZT0+e3RoaXMuX3BjLnJlbW92ZVRyYWNrKGUpLHRoaXMuX3F1ZXVlZE5lZ290aWF0aW9uPSEwfSksdGhpcy5fc2VuZGVyc0F3YWl0aW5nU3RhYmxlPVtdLHRoaXMuX3F1ZXVlZE5lZ290aWF0aW9uPyh0aGlzLl9kZWJ1ZyhcImZsdXNoaW5nIG5lZ290aWF0aW9uIHF1ZXVlXCIpLHRoaXMuX3F1ZXVlZE5lZ290aWF0aW9uPSExLHRoaXMuX25lZWRzTmVnb3RpYXRpb24oKSk6KHRoaXMuX2RlYnVnKFwibmVnb3RpYXRlZFwiKSx0aGlzLmVtaXQoXCJuZWdvdGlhdGVkXCIpKSksdGhpcy5fZGVidWcoXCJzaWduYWxpbmdTdGF0ZUNoYW5nZSAlc1wiLHRoaXMuX3BjLnNpZ25hbGluZ1N0YXRlKSx0aGlzLmVtaXQoXCJzaWduYWxpbmdTdGF0ZUNoYW5nZVwiLHRoaXMuX3BjLnNpZ25hbGluZ1N0YXRlKSl9X29uSWNlQ2FuZGlkYXRlKGUpe3RoaXMuZGVzdHJveWVkfHwoZS5jYW5kaWRhdGUmJnRoaXMudHJpY2tsZT90aGlzLmVtaXQoXCJzaWduYWxcIix7dHlwZTpcImNhbmRpZGF0ZVwiLGNhbmRpZGF0ZTp7Y2FuZGlkYXRlOmUuY2FuZGlkYXRlLmNhbmRpZGF0ZSxzZHBNTGluZUluZGV4OmUuY2FuZGlkYXRlLnNkcE1MaW5lSW5kZXgsc2RwTWlkOmUuY2FuZGlkYXRlLnNkcE1pZH19KTohZS5jYW5kaWRhdGUmJiF0aGlzLl9pY2VDb21wbGV0ZSYmKHRoaXMuX2ljZUNvbXBsZXRlPSEwLHRoaXMuZW1pdChcIl9pY2VDb21wbGV0ZVwiKSksZS5jYW5kaWRhdGUmJnRoaXMuX3N0YXJ0SWNlQ29tcGxldGVUaW1lb3V0KCkpfV9vbkNoYW5uZWxNZXNzYWdlKGUpe2lmKHRoaXMuZGVzdHJveWVkKXJldHVybjtsZXQgdD1lLmRhdGE7dCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyJiYodD1jLmZyb20odCkpLHRoaXMucHVzaCh0KX1fb25DaGFubmVsQnVmZmVyZWRBbW91bnRMb3coKXtpZighdGhpcy5kZXN0cm95ZWQmJnRoaXMuX2NiKXt0aGlzLl9kZWJ1ZyhcImVuZGluZyBiYWNrcHJlc3N1cmU6IGJ1ZmZlcmVkQW1vdW50ICVkXCIsdGhpcy5fY2hhbm5lbC5idWZmZXJlZEFtb3VudCk7Y29uc3QgZT10aGlzLl9jYjt0aGlzLl9jYj1udWxsLGUobnVsbCl9fV9vbkNoYW5uZWxPcGVuKCl7dGhpcy5fY29ubmVjdGVkfHx0aGlzLmRlc3Ryb3llZHx8KHRoaXMuX2RlYnVnKFwib24gY2hhbm5lbCBvcGVuXCIpLHRoaXMuX2NoYW5uZWxSZWFkeT0hMCx0aGlzLl9tYXliZVJlYWR5KCkpfV9vbkNoYW5uZWxDbG9zZSgpe3RoaXMuZGVzdHJveWVkfHwodGhpcy5fZGVidWcoXCJvbiBjaGFubmVsIGNsb3NlXCIpLHRoaXMuZGVzdHJveSgpKX1fb25UcmFjayhlKXt0aGlzLmRlc3Ryb3llZHx8ZS5zdHJlYW1zLmZvckVhY2godD0+e3RoaXMuX2RlYnVnKFwib24gdHJhY2tcIiksdGhpcy5lbWl0KFwidHJhY2tcIixlLnRyYWNrLHQpLHRoaXMuX3JlbW90ZVRyYWNrcy5wdXNoKHt0cmFjazplLnRyYWNrLHN0cmVhbTp0fSksdGhpcy5fcmVtb3RlU3RyZWFtcy5zb21lKGU9PmUuaWQ9PT10LmlkKXx8KHRoaXMuX3JlbW90ZVN0cmVhbXMucHVzaCh0KSxzKCgpPT57dGhpcy5fZGVidWcoXCJvbiBzdHJlYW1cIiksdGhpcy5lbWl0KFwic3RyZWFtXCIsdCl9KSl9KX1fZGVidWcoKXtjb25zdCBlPVtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtlWzBdPVwiW1wiK3RoaXMuX2lkK1wiXSBcIitlWzBdLGEuYXBwbHkobnVsbCxlKX19cC5XRUJSVENfU1VQUE9SVD0hIW8oKSxwLmNvbmZpZz17aWNlU2VydmVyczpbe3VybHM6W1wic3R1bjpzdHVuLmwuZ29vZ2xlLmNvbToxOTMwMlwiLFwic3R1bjpnbG9iYWwuc3R1bi50d2lsaW8uY29tOjM0NzhcIl19XSxzZHBTZW1hbnRpY3M6XCJ1bmlmaWVkLXBsYW5cIn0scC5jaGFubmVsQ29uZmlnPXt9LHQuZXhwb3J0cz1wfSx7YnVmZmVyOjMsZGVidWc6NCxcImVyci1jb2RlXCI6NixcImdldC1icm93c2VyLXJ0Y1wiOjgsXCJxdWV1ZS1taWNyb3Rhc2tcIjoxMyxyYW5kb21ieXRlczoxNCxcInJlYWRhYmxlLXN0cmVhbVwiOjI5fV19LHt9LFtdKShcIi9cIil9KTsiLCAiaW1wb3J0IFBlZXJkcmFmdFBsdWdpbiBmcm9tICcuL3BlZXJkcmFmdFBsdWdpbic7XG5cbmV4cG9ydCBkZWZhdWx0IFBlZXJkcmFmdFBsdWdpbiIsICJpbXBvcnQgeyBNYXJrZG93blZpZXcsIFBsdWdpbiwgVEZpbGUsIFRGb2xkZXIsIG5vcm1hbGl6ZVBhdGggfSBmcm9tIFwib2JzaWRpYW5cIlxuaW1wb3J0IHsgQWN0aXZlU3RyZWFtQ2xpZW50IH0gZnJvbSBcIi4vYWN0aXZlU3RyZWFtQ2xpZW50XCJcbmltcG9ydCB7IHByZXBhcmVDb21tdW5pY2F0aW9uIH0gZnJvbSBcIi4vY29va2llXCJcbmltcG9ydCB7IFNlcnZlckFQSSB9IGZyb20gXCIuL3NlcnZlckFQSVwiXG5pbXBvcnQgeyBTZXR0aW5ncywgY3JlYXRlU2V0dGluZ3NUYWIsIGdldFNldHRpbmdzLCBtaWdyYXRlU2V0dGluZ3MsIHNhdmVTZXR0aW5ncyB9IGZyb20gXCIuL3NldHRpbmdzXCJcbmltcG9ydCB7IFNoYXJlZERvY3VtZW50IH0gZnJvbSBcIi4vc2hhcmVkRW50aXRpZXMvc2hhcmVkRG9jdW1lbnRcIlxuaW1wb3J0IHsgZnJvbVNoYXJlVVJMIH0gZnJvbSBcIi4vc2hhcmVkRW50aXRpZXMvc2hhcmVkRW50aXR5RmFjdG9yeVwiXG5pbXBvcnQgeyBTaGFyZWRGb2xkZXIgfSBmcm9tIFwiLi9zaGFyZWRFbnRpdGllcy9zaGFyZWRGb2xkZXJcIlxuaW1wb3J0IHsgc2hvd05vdGljZSB9IGZyb20gXCIuL3VpXCJcbmltcG9ydCB7IHByb21wdEZvclNlc3Npb25UeXBlIH0gZnJvbSBcIi4vdWkvY2hvb3NlU2Vzc2lvblR5cGVcIlxuaW1wb3J0IHsgcHJvbXB0Rm9yTmFtZSwgcHJvbXB0Rm9yVVJMIH0gZnJvbSBcIi4vdWkvZW50ZXJUZXh0XCJcbmltcG9ydCB7IFBlZXJkcmFmdFJlY29yZCB9IGZyb20gXCIuL3V0aWxzL3BlZXJkcmFmdFJlY29yZFwiXG5pbXBvcnQgeyBQZWVyZHJhZnRMZWFmIH0gZnJvbSBcIi4vd29ya3NwYWNlL3BlZXJkcmFmdExlYWZcIlxuaW1wb3J0IHsgZ2V0TGVhZnNCeVBhdGgsIHVwZGF0ZVBlZXJkcmFmdFdvcmtzcGFjZSB9IGZyb20gXCIuL3dvcmtzcGFjZS9wZWVyZHJhZnRXb3Jrc3BhY2VcIlxuaW1wb3J0IHsgUGVlcmRyYWZ0V2Vic29ja2V0UHJvdmlkZXIgfSBmcm9tIFwiLi9wZWVyZHJhZnRXZWJTb2NrZXRQcm92aWRlclwiXG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gXCJwYXRoXCJcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGVlcmRyYWZ0UGx1Z2luIGV4dGVuZHMgUGx1Z2luIHtcblxuXHRzZXR0aW5nczogU2V0dGluZ3Ncblx0cHdzOiBQZWVyZHJhZnRSZWNvcmQ8UGVlcmRyYWZ0TGVhZj5cblx0c2VydmVyQVBJOiBTZXJ2ZXJBUElcblx0YWN0aXZlU3RyZWFtQ2xpZW50OiBBY3RpdmVTdHJlYW1DbGllbnRcblx0c2VydmVyU3luYzogUGVlcmRyYWZ0V2Vic29ja2V0UHJvdmlkZXJcblxuXHRhc3luYyBvbmxvYWQoKSB7XG5cblx0XHRjb25zdCBwbHVnaW4gPSB0aGlzXG5cblx0XHRwbHVnaW4uc2V0dGluZ3MgPSBhd2FpdCBtaWdyYXRlU2V0dGluZ3MocGx1Z2luKVxuXG5cdFx0YXdhaXQgcHJlcGFyZUNvbW11bmljYXRpb24ocGx1Z2luKVxuXG5cdFx0cGx1Z2luLnB3cyA9IG5ldyBQZWVyZHJhZnRSZWNvcmQ8UGVlcmRyYWZ0TGVhZj4oKVxuXHRcdHBsdWdpbi5zZXJ2ZXJBUEkgPSBuZXcgU2VydmVyQVBJKHtcblx0XHRcdG9pZDogcGx1Z2luLnNldHRpbmdzLm9pZCxcblx0XHRcdHBlcm1hbmVudFNlc3Npb25Vcmw6IHBsdWdpbi5zZXR0aW5ncy5zZXNzaW9uQVBJXG5cdFx0fSlcblxuXHRcdHBsdWdpbi5hY3RpdmVTdHJlYW1DbGllbnQgPSBuZXcgQWN0aXZlU3RyZWFtQ2xpZW50KHBsdWdpbi5zZXR0aW5ncy5hY3RpdmVzLCB7XG5cdFx0XHRtYXhCYWNrb2ZmVGltZTogMzAwMDAwLFxuXHRcdFx0Y29ubmVjdDogdHJ1ZSxcblx0XHRcdHJlc3luY0ludGVydmFsOiAtMVxuXHRcdH0pXG5cblx0XHRwbHVnaW4ucHdzLm9uKCdhZGQnLCAoa2V5LCBsZWFmKSA9PiB7XG5cdFx0XHRTaGFyZWREb2N1bWVudC5maW5kQnlQYXRoKGxlYWYucGF0aCk/LmFkZEV4dGVuc2lvblRvTGVhZihrZXkpXG5cdFx0XHRsZWFmLm9uKFwiY2hhbmdlUGF0aFwiLCAob2xkUGF0aCkgPT4ge1xuXHRcdFx0XHRjb25zdCBkb2MgPSBTaGFyZWREb2N1bWVudC5maW5kQnlQYXRoKG9sZFBhdGgpXG5cdFx0XHRcdGlmIChkb2MpIHtcblx0XHRcdFx0XHRkb2MucmVtb3ZlRXh0ZW5zaW9uRnJvbUxlYWYoa2V5KVxuXHRcdFx0XHRcdGNvbnN0IGxlYWZzID0gZ2V0TGVhZnNCeVBhdGgob2xkUGF0aCwgcGx1Z2luLnB3cylcblx0XHRcdFx0XHRpZiAobGVhZnMubGVuZ3RoID09PSAwICYmICFkb2MuaXNQZXJtYW5lbnQpIHtcblx0XHRcdFx0XHRcdGRvYy51bnNoYXJlKClcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0U2hhcmVkRG9jdW1lbnQuZmluZEJ5UGF0aChsZWFmLnBhdGgpPy5hZGRFeHRlbnNpb25Ub0xlYWYoa2V5KVxuXHRcdFx0fSlcblx0XHR9KVxuXG5cdFx0cGx1Z2luLnB3cy5vbignZGVsZXRlJywgYXN5bmMgKGtleSwgbGVhZikgPT4ge1xuXHRcdFx0Y29uc3QgZG9jID0gU2hhcmVkRG9jdW1lbnQuZmluZEJ5UGF0aChsZWFmLnBhdGgpXG5cdFx0XHRpZiAoIWRvYykgcmV0dXJuXG5cdFx0XHRkb2MucmVtb3ZlRXh0ZW5zaW9uRnJvbUxlYWYoa2V5KVxuXHRcdFx0Y29uc3QgbGVhZnMgPSBnZXRMZWFmc0J5UGF0aChsZWFmLnBhdGgsIHBsdWdpbi5wd3MpXG5cdFx0XHRpZiAobGVhZnMubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRcdGlmIChkb2MgJiYgIWRvYy5pc1Blcm1hbmVudCkge1xuXHRcdFx0XHRcdGF3YWl0IGRvYy51bnNoYXJlKClcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0bGVhZi5kZXN0cm95KClcblx0XHR9KVxuXG5cdFx0cGx1Z2luLmFwcC53b3Jrc3BhY2Uub25MYXlvdXRSZWFkeShcblx0XHRcdGFzeW5jICgpID0+IHtcblx0XHRcdFx0dGhpcy5zZXJ2ZXJTeW5jID0gbmV3IFBlZXJkcmFmdFdlYnNvY2tldFByb3ZpZGVyKHRoaXMuc2V0dGluZ3Muc3luYylcblx0XHRcdFx0Zm9yIChjb25zdCBkb2NzIG9mIHBsdWdpbi5zZXR0aW5ncy5zZXJ2ZXJTaGFyZXMuZmlsZXMpIHtcblx0XHRcdFx0XHRhd2FpdCBTaGFyZWREb2N1bWVudC5mcm9tUGVybWFuZW50U2hhcmVEb2N1bWVudCh7IHBhdGg6IGRvY3NbMF0sIHBlcnNpc3RlbmNlSWQ6IGRvY3NbMV0ucGVyc2lzdGVuY2VJZCwgc2hhcmVJZDogZG9jc1sxXS5zaGFyZUlkIH0sIHBsdWdpbilcblx0XHRcdFx0fVxuXHRcdFx0XHRmb3IgKGNvbnN0IGZvbGRlciBvZiBwbHVnaW4uc2V0dGluZ3Muc2VydmVyU2hhcmVzLmZvbGRlcnMpIHtcblx0XHRcdFx0XHRhd2FpdCBTaGFyZWRGb2xkZXIuZnJvbVBlcm1hbmVudFNoYXJlRm9sZGVyKHsgcGF0aDogZm9sZGVyWzBdLCBwZXJzaXN0ZW5jZUlkOiBmb2xkZXJbMV0ucGVyc2lzdGVuY2VJZCwgc2hhcmVJZDogZm9sZGVyWzFdLnNoYXJlSWQgfSwgcGx1Z2luKVxuXHRcdFx0XHR9XG5cdFx0XHRcdHVwZGF0ZVBlZXJkcmFmdFdvcmtzcGFjZShwbHVnaW4uYXBwLndvcmtzcGFjZSwgcGx1Z2luLnB3cylcblx0XHRcdFx0cGx1Z2luLnJlZ2lzdGVyRXZlbnQocGx1Z2luLmFwcC53b3Jrc3BhY2Uub24oXCJsYXlvdXQtY2hhbmdlXCIsICgpID0+IHtcblx0XHRcdFx0XHR1cGRhdGVQZWVyZHJhZnRXb3Jrc3BhY2UocGx1Z2luLmFwcC53b3Jrc3BhY2UsIHBsdWdpbi5wd3MpXG5cdFx0XHRcdH0pKVxuXHRcdFx0fVxuXHRcdClcblxuXHRcdHBsdWdpbi5yZWdpc3RlckV2ZW50KHBsdWdpbi5hcHAud29ya3NwYWNlLm9uKCdmaWxlLW1lbnUnLCAobWVudSwgZmlsZSkgPT4ge1xuXHRcdFx0aWYgKGZpbGUgaW5zdGFuY2VvZiBURm9sZGVyKSB7XG5cdFx0XHRcdC8vIE5vdCBzaGFyZWQgZm9sZGVyICYmIG5vdCB3aXRoaW4gc2hhcmVkIGZvbGRlclxuXHRcdFx0XHRjb25zdCBzaGFyZWRGb2xkZXIgPSBTaGFyZWRGb2xkZXIuZmluZEJ5UGF0aChmaWxlLnBhdGgpXG5cdFx0XHRcdGlmICghc2hhcmVkRm9sZGVyKSB7XG5cdFx0XHRcdFx0aWYgKCFTaGFyZWRGb2xkZXIuZ2V0U2hhcmVkRm9sZGVyRm9yU3ViUGF0aChmaWxlLnBhdGgpICYmIHBsdWdpbi5zZXR0aW5ncy5wbGFuLnR5cGUgPT09IFwidGVhbVwiKSB7XG5cdFx0XHRcdFx0XHRtZW51LmFkZEl0ZW0oKGl0ZW0pID0+IHtcblx0XHRcdFx0XHRcdFx0aXRlbS5zZXRUaXRsZSgnU2hhcmUgRm9sZGVyJylcblx0XHRcdFx0XHRcdFx0aXRlbS5zZXRJY29uKCd1c2VycycpXG5cdFx0XHRcdFx0XHRcdGl0ZW0ub25DbGljaygoKSA9PiB7XG5cdFx0XHRcdFx0XHRcdFx0U2hhcmVkRm9sZGVyLmZyb21URm9sZGVyKGZpbGUsIHBsdWdpbilcblx0XHRcdFx0XHRcdFx0fSlcblx0XHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdG1lbnUuYWRkSXRlbShpdGVtID0+IHtcblx0XHRcdFx0XHRcdGl0ZW0uc2V0VGl0bGUoJ0NvcHkgUGVlcmRyYWZ0IFVSTCcpXG5cdFx0XHRcdFx0XHRpdGVtLnNldEljb24oJ3VzZXJzJylcblx0XHRcdFx0XHRcdGl0ZW0ub25DbGljaygoKSA9PiB7XG5cdFx0XHRcdFx0XHRcdG5hdmlnYXRvci5jbGlwYm9hcmQud3JpdGVUZXh0KHBsdWdpbi5zZXR0aW5ncy5iYXNlUGF0aCArICcvdGVhbS8nICsgc2hhcmVkRm9sZGVyLnNoYXJlSWQpXG5cdFx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0bWVudS5hZGRJdGVtKGl0ZW0gPT4ge1xuXHRcdFx0XHRcdFx0aXRlbS5zZXRUaXRsZSgnU3RvcCBzeW5jaW5nIHRoaXMgZm9sZGVyJylcblx0XHRcdFx0XHRcdGl0ZW0uc2V0SWNvbigncmVmcmVzaC1jdy1vZmYnKVxuXHRcdFx0XHRcdFx0aXRlbS5vbkNsaWNrKGFzeW5jICgpID0+IHtcblx0XHRcdFx0XHRcdFx0YXdhaXQgc2hhcmVkRm9sZGVyLnVuc2hhcmUoKVxuXHRcdFx0XHRcdFx0fSlcblx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdG1lbnUuYWRkSXRlbShpdGVtID0+IHtcblx0XHRcdFx0XHRcdGl0ZW0uc2V0VGl0bGUoJ1JlLWNyZWF0ZSBzeW5jIGZyb20gc2VydmVyJylcblx0XHRcdFx0XHRcdGl0ZW0uc2V0SWNvbigncmVmcmVzaC1jdycpXG5cdFx0XHRcdFx0XHRpdGVtLm9uQ2xpY2soYXN5bmMgKCkgPT4ge1xuXHRcdFx0XHRcdFx0XHRhd2FpdCBTaGFyZWRGb2xkZXIucmVjcmVhdGUoc2hhcmVkRm9sZGVyLCBwbHVnaW4pXG5cdFx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNvbnN0IHNoYXJlZERvY3VtZW50ID0gU2hhcmVkRG9jdW1lbnQuZmluZEJ5UGF0aChmaWxlLnBhdGgpXG5cdFx0XHRcdGNvbnN0IHNoYXJlZEZvbGRlciA9IFNoYXJlZEZvbGRlci5nZXRTaGFyZWRGb2xkZXJGb3JTdWJQYXRoKGZpbGUucGF0aClcblx0XHRcdFx0aWYgKHNoYXJlZERvY3VtZW50KSB7XG5cdFx0XHRcdFx0bWVudS5hZGRJdGVtKGl0ZW0gPT4ge1xuXHRcdFx0XHRcdFx0aXRlbS5zZXRUaXRsZSgnQ29weSBQZWVyZHJhZnQgVVJMJylcblx0XHRcdFx0XHRcdGl0ZW0uc2V0SWNvbigndXNlcnMnKVxuXHRcdFx0XHRcdFx0aXRlbS5vbkNsaWNrKCgpID0+IHtcblx0XHRcdFx0XHRcdFx0bmF2aWdhdG9yLmNsaXBib2FyZC53cml0ZVRleHQocGx1Z2luLnNldHRpbmdzLmJhc2VQYXRoICsgJy9jbS8nICsgc2hhcmVkRG9jdW1lbnQuc2hhcmVJZClcblx0XHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0fSlcblx0XHRcdFx0XHRpZiAoIXNoYXJlZEZvbGRlcikge1xuXHRcdFx0XHRcdFx0bWVudS5hZGRJdGVtKGl0ZW0gPT4ge1xuXHRcdFx0XHRcdFx0XHRpdGVtLnNldFRpdGxlKCdTdG9wIHN5bmNpbmcgdGhpcyBkb2N1bWVudCcpXG5cdFx0XHRcdFx0XHRcdGl0ZW0uc2V0SWNvbigncmVmcmVzaC1jdy1vZmYnKVxuXHRcdFx0XHRcdFx0XHRpdGVtLm9uQ2xpY2soYXN5bmMgKCkgPT4ge1xuXHRcdFx0XHRcdFx0XHRcdGF3YWl0IHNoYXJlZERvY3VtZW50LnVuc2hhcmUoKVxuXHRcdFx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdFx0fSlcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KSlcblxuXHRcdHBsdWdpbi5hZGRDb21tYW5kKHtcblx0XHRcdGlkOiBcInNoYXJlXCIsXG5cdFx0XHRuYW1lOiBcIlN0YXJ0IHdvcmtpbmcgdG9nZXRoZXIgb24gdGhpcyBkb2N1bWVudFwiLFxuXHRcdFx0Y2hlY2tDYWxsYmFjayhjaGVja2luZykge1xuXHRcdFx0XHRjb25zdCB2aWV3ID0gcGx1Z2luLmFwcC53b3Jrc3BhY2UuZ2V0QWN0aXZlVmlld09mVHlwZShNYXJrZG93blZpZXcpXG5cdFx0XHRcdGlmICghdmlldykgcmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRjb25zdCBmaWxlID0gdmlldy5maWxlXG5cdFx0XHRcdGlmICghZmlsZSkgcmV0dXJuIGZhbHNlXG5cdFx0XHRcdGNvbnN0IGRvYyA9IFNoYXJlZERvY3VtZW50LmZpbmRCeVBhdGgoZmlsZS5wYXRoKVxuXHRcdFx0XHRpZiAoZG9jKSByZXR1cm4gZmFsc2Vcblx0XHRcdFx0aWYgKGNoZWNraW5nKSByZXR1cm4gdHJ1ZVxuXHRcdFx0XHQvLyBkbyBpdFxuXHRcdFx0XHRpZiAocGx1Z2luLnNldHRpbmdzLnBsYW4udHlwZSA9PT0gXCJ0ZWFtXCIpIHtcblx0XHRcdFx0XHRwcm9tcHRGb3JTZXNzaW9uVHlwZShwbHVnaW4uYXBwKS50aGVuKHJlc3VsdCA9PiB7XG5cdFx0XHRcdFx0XHRpZiAoIXJlc3VsdCkgcmV0dXJuXG5cdFx0XHRcdFx0XHRTaGFyZWREb2N1bWVudC5mcm9tVmlldyh2aWV3LCBwbHVnaW4sIHsgcGVybWFuZW50OiByZXN1bHQucGVybWFuZW50IH0pLnRoZW4oZG9jID0+IHtcblx0XHRcdFx0XHRcdFx0aWYgKCFkb2MpIHtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gc2hvd05vdGljZShcIkVSUk9SIGNyZWF0aW5nIHNoYXJlZERvY1wiKVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0U2hhcmVkRG9jdW1lbnQuZnJvbVZpZXcodmlldywgcGx1Z2luLCB7IHBlcm1hbmVudDogZmFsc2UgfSkudGhlbihkb2MgPT4ge1xuXHRcdFx0XHRcdFx0aWYgKCFkb2MpIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHNob3dOb3RpY2UoXCJFUlJPUiBjcmVhdGluZyBzaGFyZWREb2NcIilcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSlcblxuXHRcdHBsdWdpbi5hZGRDb21tYW5kKHtcblx0XHRcdGlkOiAnc3RvcC1zZXNzaW9uLXdpdGgtYWN0aXZlLWRvY3VtZW50Jyxcblx0XHRcdG5hbWU6ICdTdG9wIHdvcmtpbmcgdG9nZXRoZXIgb24gdGhpcyBkb2N1bWVudCcsXG5cdFx0XHRlZGl0b3JDaGVja0NhbGxiYWNrOiAoY2hlY2tpbmcsIGVkaXRvciwgY3R4KSA9PiB7XG5cdFx0XHRcdGNvbnN0IGZpbGUgPSBjdHguZmlsZVxuXHRcdFx0XHRpZiAoIWZpbGUpIHJldHVybiBmYWxzZVxuXHRcdFx0XHRjb25zdCBkb2MgPSBTaGFyZWREb2N1bWVudC5maW5kQnlQYXRoKGZpbGUucGF0aClcblx0XHRcdFx0aWYgKCFkb2MgfHwgZG9jLmlzUGVybWFuZW50KSByZXR1cm4gZmFsc2Vcblx0XHRcdFx0aWYgKGNoZWNraW5nKSByZXR1cm4gdHJ1ZVxuXHRcdFx0XHRkb2MudW5zaGFyZSgpLnRoZW4oKCkgPT4geyB9KVxuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0cGx1Z2luLmFkZENvbW1hbmQoe1xuXHRcdFx0aWQ6IFwiam9pblwiLFxuXHRcdFx0bmFtZTogXCJKb2luIHNlc3Npb24gYW5kIGFkZCBkb2N1bWVudCBmcm9tIHNvbWVvbmUgZWxzZVwiLFxuXHRcdFx0Y2FsbGJhY2s6IGFzeW5jICgpID0+IHtcblx0XHRcdFx0Y29uc3QgdXJsID0gYXdhaXQgcHJvbXB0Rm9yVVJMKHBsdWdpbi5hcHApXG5cdFx0XHRcdGlmICh1cmwgJiYgdXJsLnRleHQpIHtcblx0XHRcdFx0XHRhd2FpdCBmcm9tU2hhcmVVUkwodXJsLnRleHQsIHBsdWdpbilcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pXG5cblx0XHRpZiAocGx1Z2luLnNldHRpbmdzLmRlYnVnKSB7XG5cdFx0XHRwbHVnaW4uYWRkQ29tbWFuZCh7XG5cdFx0XHRcdGlkOiBcImNsZWFyRGF0YWJhc2VcIixcblx0XHRcdFx0bmFtZTogXCJERUJVRzogY2xlYXIgZGF0YWJhc2UgKE5vdGhpbmcgd2lsbCBiZSBzaGFyZWQgYWZ0ZXIgdGhpcyEpXCIsXG5cdFx0XHRcdGNhbGxiYWNrOiBhc3luYyAoKSA9PiB7XG5cdFx0XHRcdFx0Y29uc3QgZGJzID0gYXdhaXQgd2luZG93LmluZGV4ZWREQi5kYXRhYmFzZXMoKVxuXHRcdFx0XHRcdGZvciAoY29uc3QgZGIgb2YgZGJzKSB7XG5cdFx0XHRcdFx0XHRpZiAoZGIubmFtZT8uc3RhcnRzV2l0aChcInBlZXJkcmFmdF9cIikpIHtcblx0XHRcdFx0XHRcdFx0d2luZG93LmluZGV4ZWREQi5kZWxldGVEYXRhYmFzZShkYi5uYW1lKVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSlcblx0XHR9XG5cblx0XHRwbHVnaW4ucmVnaXN0ZXJFdmVudChwbHVnaW4uYXBwLnZhdWx0Lm9uKCdyZW5hbWUnLCBhc3luYyAoZmlsZSwgb2xkUGF0aCkgPT4ge1xuXHRcdFx0aWYgKGZpbGUgaW5zdGFuY2VvZiBURmlsZSkge1xuXHRcdFx0XHRjb25zdCBkb2MgPSBTaGFyZWREb2N1bWVudC5maW5kQnlQYXRoKG9sZFBhdGgpXG5cdFx0XHRcdGlmIChkb2MpIHtcblx0XHRcdFx0XHRhd2FpdCBkb2Muc2V0TmV3RmlsZUxvY2F0aW9uKGZpbGUpXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjb25zdCBvbGRQYXRoSW5Gb2xkZXIgPSBTaGFyZWRGb2xkZXIuZ2V0U2hhcmVkRm9sZGVyRm9yU3ViUGF0aChvbGRQYXRoKVxuXHRcdFx0XHRjb25zdCBuZXdQYXRoSW5Gb2xkZXIgPSBTaGFyZWRGb2xkZXIuZ2V0U2hhcmVkRm9sZGVyRm9yU3ViUGF0aChmaWxlLnBhdGgpXG5cblx0XHRcdFx0aWYgKG9sZFBhdGhJbkZvbGRlciAmJiBuZXdQYXRoSW5Gb2xkZXIpIHtcblx0XHRcdFx0XHRpZiAob2xkUGF0aEluRm9sZGVyID09PSBuZXdQYXRoSW5Gb2xkZXIpIHtcblx0XHRcdFx0XHRcdG9sZFBhdGhJbkZvbGRlci51cGRhdGVQYXRoKG9sZFBhdGgsIGZpbGUucGF0aClcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y29uc3QgbmV3RG9jID0gYXdhaXQgU2hhcmVkRG9jdW1lbnQuZnJvbVRGaWxlKGZpbGUsIHsgcGVybWFuZW50OiB0cnVlIH0sIHBsdWdpbilcblx0XHRcdFx0XHRcdGlmIChuZXdEb2MpIHtcblx0XHRcdFx0XHRcdFx0bmV3UGF0aEluRm9sZGVyLmFkZERvY3VtZW50KG5ld0RvYylcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmIChkb2MpIHtcblx0XHRcdFx0XHRcdFx0Ly8gb2xkUGF0aEluRm9sZGVyLnJlbW92ZURvY3VtZW50KGRvYylcblx0XHRcdFx0XHRcdFx0Ly8gZG9jLnVuc2hhcmUoKVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIGlmIChvbGRQYXRoSW5Gb2xkZXIgJiYgIW5ld1BhdGhJbkZvbGRlcikge1xuXHRcdFx0XHRcdGlmIChkb2MpIHtcblx0XHRcdFx0XHRcdHNob3dOb3RpY2UoXCJJdCBpcyBub3QgcG9zc2libGUgdG8gcmVtb3ZlIGEgZG9jdW1lbnQgZnJvbSBhIHNoYXJlZCBmb2xkZXIgcmlnaHQgbm93LiBDcmVhdGVkIGEgY29weS5cIilcblx0XHRcdFx0XHRcdC8vIG9sZFBhdGhJbkZvbGRlci5yZW1vdmVEb2N1bWVudChkb2MpXG5cdFx0XHRcdFx0XHRhd2FpdCBTaGFyZWRGb2xkZXIuZ2V0T3JDcmVhdGVQYXRoKHBhdGguZGlybmFtZShvbGRQYXRoKSwgcGx1Z2luKVxuXHRcdFx0XHRcdFx0Y29uc3QgZmlsZSA9IGF3YWl0IHBsdWdpbi5hcHAudmF1bHQuY3JlYXRlKG9sZFBhdGgsICcnKVxuXHRcdFx0XHRcdFx0aWYgKCFmaWxlKSB7XG5cdFx0XHRcdFx0XHRcdHNob3dOb3RpY2UoXCJFcnJvciBjcmVhdGluZyBmaWxlIFwiICsgb2xkUGF0aCArIFwiLlwiKVxuXHRcdFx0XHRcdFx0XHRyZXR1cm5cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGRvYy5zZXROZXdGaWxlTG9jYXRpb24oZmlsZSlcblx0XHRcdFx0XHRcdGRvYy5zeW5jV2l0aFNlcnZlcigpXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2UgaWYgKCFvbGRQYXRoSW5Gb2xkZXIgJiYgbmV3UGF0aEluRm9sZGVyKSB7XG5cdFx0XHRcdFx0Y29uc3QgZG9jID0gYXdhaXQgU2hhcmVkRG9jdW1lbnQuZnJvbVRGaWxlKGZpbGUsIHsgcGVybWFuZW50OiB0cnVlIH0sIHBsdWdpbilcblx0XHRcdFx0XHRpZiAoZG9jKSB7XG5cdFx0XHRcdFx0XHRuZXdQYXRoSW5Gb2xkZXIuYWRkRG9jdW1lbnQoZG9jKVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmIChmaWxlIGluc3RhbmNlb2YgVEZvbGRlcikge1xuXHRcdFx0XHRjb25zdCBmb2xkZXIgPSBTaGFyZWRGb2xkZXIuZmluZEJ5UGF0aChvbGRQYXRoKVxuXHRcdFx0XHRpZiAoZm9sZGVyKSB7XG5cdFx0XHRcdFx0YXdhaXQgZm9sZGVyLnNldE5ld0ZvbGRlckxvY2F0aW9uKGZpbGUpXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KSlcblxuXHRcdHBsdWdpbi5yZWdpc3RlckV2ZW50KHBsdWdpbi5hcHAudmF1bHQub24oJ2RlbGV0ZScsIGFzeW5jIChmaWxlKSA9PiB7XG5cdFx0XHRwbHVnaW4ubG9nKFwicmVnaXN0ZXIgZGVsZXRlIGZvciBcIiArIGZpbGUucGF0aClcblx0XHRcdGlmIChmaWxlIGluc3RhbmNlb2YgVEZvbGRlcikge1xuXHRcdFx0XHRjb25zdCBmb2xkZXIgPSBTaGFyZWRGb2xkZXIuZmluZEJ5UGF0aChmaWxlLnBhdGgpXG5cdFx0XHRcdGZvbGRlcj8udW5zaGFyZSgpXG5cdFx0XHRcdHJldHVyblxuXHRcdFx0fSBlbHNlIGlmIChmaWxlIGluc3RhbmNlb2YgVEZpbGUpIHtcblx0XHRcdFx0Y29uc3QgZm9sZGVyID0gU2hhcmVkRm9sZGVyLmdldFNoYXJlZEZvbGRlckZvclN1YlBhdGgoZmlsZS5wYXRoKVxuXHRcdFx0XHRpZiAoIWZvbGRlcikge1xuXHRcdFx0XHRcdGNvbnN0IGRvYyA9IFNoYXJlZERvY3VtZW50LmZpbmRCeVBhdGgoZmlsZS5wYXRoKVxuXHRcdFx0XHRcdGlmIChkb2MpIHtcblx0XHRcdFx0XHRcdGF3YWl0IGRvYy51bnNoYXJlKClcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdC8qIERvIG5ldCBkZWxldGUgb24gZGVsZXRlIGZpbGVzIGZyb20gU2hhcmVkIEZvbGRlcnMganVzdCB5ZXQuLi5cblx0XHRcdC8vIElmIHlvdSByZWFsbHkgd2FudCB0byByZW1vdmUgYSBmaWxlLCB5b3UgY2FuIG1vdmVcblx0XHRcdGlmIChmaWxlIGluc3RhbmNlb2YgVEZpbGUpe1xuXHRcdFx0XHRjb25zdCBkb2MgPSBTaGFyZWREb2N1bWVudC5maW5kQnlQYXRoKGZpbGUucGF0aClcblx0XHRcdFx0aWYgKGRvYykge1xuXHRcdFx0XHRcdGF3YWl0IGRvYy51bnNoYXJlKClcblx0XHRcdFx0XHRpZiAoZm9sZGVyKSB7XG5cdFx0XHRcdFx0XHRmb2xkZXIucmVtb3ZlRG9jdW1lbnQoZG9jKVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmIChmaWxlIGluc3RhbmNlb2YgVEZvbGRlcikge1xuXHRcdFx0XHRjb25zdCBmb2xkZXIgPSBTaGFyZWRGb2xkZXIuZ2V0U2hhcmVkRm9sZGVyRm9yU3ViUGF0aChmaWxlLnBhdGgpXG5cdFx0XHRcdFx0aWYgKGZvbGRlcikge1xuXHRcdFx0XHRcdFx0Zm9sZGVyLnVuc2hhcmUoKVxuXHRcdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdCovXG5cdFx0fSkpXG5cblx0XHRwbHVnaW4uYXBwLndvcmtzcGFjZS5vbkxheW91dFJlYWR5KFxuXHRcdFx0KCkgPT4ge1xuXHRcdFx0XHRwbHVnaW4ucmVnaXN0ZXJFdmVudCgocGx1Z2luLmFwcC52YXVsdC5vbihcImNyZWF0ZVwiLCBhc3luYyAoZmlsZSkgPT4ge1xuXHRcdFx0XHRcdGlmICghKGZpbGUgaW5zdGFuY2VvZiBURmlsZSkpIHJldHVyblxuXHRcdFx0XHRcdGNvbnN0IGZvbGRlciA9IFNoYXJlZEZvbGRlci5nZXRTaGFyZWRGb2xkZXJGb3JTdWJQYXRoKGZpbGUucGF0aClcblx0XHRcdFx0XHRpZiAoIWZvbGRlcikgcmV0dXJuXG5cdFx0XHRcdFx0aWYgKGZvbGRlci5pc0ZpbGVJblN5bmNPYmplY3QoZmlsZSkpIHJldHVyblxuXHRcdFx0XHRcdGlmIChTaGFyZWREb2N1bWVudC5maW5kQnlQYXRoKGZpbGUucGF0aCkpIHJldHVyblxuXG5cdFx0XHRcdFx0aWYgKHBsdWdpbi5zZXR0aW5ncy5zZXJ2ZXJTaGFyZXMuZmlsZXMuaGFzKG5vcm1hbGl6ZVBhdGgoZmlsZS5wYXRoKSkpIHJldHVyblxuXG5cdFx0XHRcdFx0Y29uc3QgZG9jID0gYXdhaXQgU2hhcmVkRG9jdW1lbnQuZnJvbVRGaWxlKGZpbGUsIHtcblx0XHRcdFx0XHRcdHBlcm1hbmVudDogdHJ1ZVxuXHRcdFx0XHRcdH0sIHBsdWdpbilcblx0XHRcdFx0XHRpZiAoZG9jKSB7XG5cdFx0XHRcdFx0XHRmb2xkZXIuYWRkRG9jdW1lbnQoZG9jKVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSkpKVxuXHRcdFx0fVxuXHRcdClcblxuXHRcdGNvbnN0IHNldHRpbmdzVGFiID0gY3JlYXRlU2V0dGluZ3NUYWIocGx1Z2luKVxuXG5cdFx0aWYgKCFwbHVnaW4uc2V0dGluZ3MubmFtZSkge1xuXHRcdFx0Y29uc3QgbmFtZSA9IGF3YWl0IHByb21wdEZvck5hbWUocGx1Z2luLmFwcClcblx0XHRcdGlmIChuYW1lICYmIG5hbWUudGV4dCkge1xuXHRcdFx0XHR0aGlzLnNldHRpbmdzLm5hbWUgPSBuYW1lLnRleHRcblx0XHRcdFx0c2F2ZVNldHRpbmdzKHRoaXMuc2V0dGluZ3MsIHBsdWdpbilcblx0XHRcdH1cblx0XHR9XG5cdFx0cGx1Z2luLmFkZFNldHRpbmdUYWIoc2V0dGluZ3NUYWIpXG5cdH1cblxuXHRvbnVubG9hZCgpIHtcblx0XHRTaGFyZWREb2N1bWVudC5nZXRBbGwoKS5mb3JFYWNoKChkb2MpID0+IHtcblx0XHRcdGRvYy5kZXN0cm95KClcblx0XHR9KVxuXHRcdFNoYXJlZEZvbGRlci5nZXRBbGwoKS5mb3JFYWNoKGZvbGRlciA9PiB7XG5cdFx0XHRmb2xkZXIuZGVzdHJveSgpXG5cdFx0fSlcblx0XHR0aGlzLmFjdGl2ZVN0cmVhbUNsaWVudC5kZXN0cm95KClcblx0fVxuXG5cdGxvZyhtZXNzYWdlOiBzdHJpbmcpIHtcblx0XHRpZiAodGhpcy5zZXR0aW5ncy5kZWJ1Zykge1xuXHRcdFx0Y29uc29sZS5sb2cobWVzc2FnZSlcblx0XHR9XG5cdH1cblxufVxuXG4iLCAiLyoqXG4gKiBDb21tb24gTWF0aCBleHByZXNzaW9ucy5cbiAqXG4gKiBAbW9kdWxlIG1hdGhcbiAqL1xuXG5leHBvcnQgY29uc3QgZmxvb3IgPSBNYXRoLmZsb29yXG5leHBvcnQgY29uc3QgY2VpbCA9IE1hdGguY2VpbFxuZXhwb3J0IGNvbnN0IGFicyA9IE1hdGguYWJzXG5leHBvcnQgY29uc3QgaW11bCA9IE1hdGguaW11bFxuZXhwb3J0IGNvbnN0IHJvdW5kID0gTWF0aC5yb3VuZFxuZXhwb3J0IGNvbnN0IGxvZzEwID0gTWF0aC5sb2cxMFxuZXhwb3J0IGNvbnN0IGxvZzIgPSBNYXRoLmxvZzJcbmV4cG9ydCBjb25zdCBsb2cgPSBNYXRoLmxvZ1xuZXhwb3J0IGNvbnN0IHNxcnQgPSBNYXRoLnNxcnRcblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSBhXG4gKiBAcGFyYW0ge251bWJlcn0gYlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgc3VtIG9mIGEgYW5kIGJcbiAqL1xuZXhwb3J0IGNvbnN0IGFkZCA9IChhLCBiKSA9PiBhICsgYlxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IGFcbiAqIEBwYXJhbSB7bnVtYmVyfSBiXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBzbWFsbGVyIGVsZW1lbnQgb2YgYSBhbmQgYlxuICovXG5leHBvcnQgY29uc3QgbWluID0gKGEsIGIpID0+IGEgPCBiID8gYSA6IGJcblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSBhXG4gKiBAcGFyYW0ge251bWJlcn0gYlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgYmlnZ2VyIGVsZW1lbnQgb2YgYSBhbmQgYlxuICovXG5leHBvcnQgY29uc3QgbWF4ID0gKGEsIGIpID0+IGEgPiBiID8gYSA6IGJcblxuZXhwb3J0IGNvbnN0IGlzTmFOID0gTnVtYmVyLmlzTmFOXG5cbmV4cG9ydCBjb25zdCBwb3cgPSBNYXRoLnBvd1xuLyoqXG4gKiBCYXNlIDEwIGV4cG9uZW50aWFsIGZ1bmN0aW9uLiBSZXR1cm5zIHRoZSB2YWx1ZSBvZiAxMCByYWlzZWQgdG8gdGhlIHBvd2VyIG9mIHBvdy5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gZXhwXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBleHAxMCA9IGV4cCA9PiBNYXRoLnBvdygxMCwgZXhwKVxuXG5leHBvcnQgY29uc3Qgc2lnbiA9IE1hdGguc2lnblxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBuXG4gKiBAcmV0dXJuIHtib29sZWFufSBXZXRoZXIgbiBpcyBuZWdhdGl2ZS4gVGhpcyBmdW5jdGlvbiBhbHNvIGRpZmZlcmVudGlhdGVzIGJldHdlZW4gLTAgYW5kICswXG4gKi9cbmV4cG9ydCBjb25zdCBpc05lZ2F0aXZlWmVybyA9IG4gPT4gbiAhPT0gMCA/IG4gPCAwIDogMSAvIG4gPCAwXG4iLCAiLyoqXG4gKiBVdGlsaXR5IG1vZHVsZSB0byB3b3JrIHdpdGggdGltZS5cbiAqXG4gKiBAbW9kdWxlIHRpbWVcbiAqL1xuXG5pbXBvcnQgKiBhcyBtZXRyaWMgZnJvbSAnLi9tZXRyaWMuanMnXG5pbXBvcnQgKiBhcyBtYXRoIGZyb20gJy4vbWF0aC5qcydcblxuLyoqXG4gKiBSZXR1cm4gY3VycmVudCB0aW1lLlxuICpcbiAqIEByZXR1cm4ge0RhdGV9XG4gKi9cbmV4cG9ydCBjb25zdCBnZXREYXRlID0gKCkgPT4gbmV3IERhdGUoKVxuXG4vKipcbiAqIFJldHVybiBjdXJyZW50IHVuaXggdGltZS5cbiAqXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBnZXRVbml4VGltZSA9IERhdGUubm93XG5cbi8qKlxuICogVHJhbnNmb3JtIHRpbWUgKGluIG1zKSB0byBhIGh1bWFuIHJlYWRhYmxlIGZvcm1hdC4gRS5nLiAxMTAwID0+IDEuMXMuIDYwcyA9PiAxbWluLiAuMDAxID0+IDEwXHUwM0JDcy5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gZCBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHNcbiAqIEByZXR1cm4ge3N0cmluZ30gaHVtYW5pemVkIGFwcHJveGltYXRpb24gb2YgdGltZVxuICovXG5leHBvcnQgY29uc3QgaHVtYW5pemVEdXJhdGlvbiA9IGQgPT4ge1xuICBpZiAoZCA8IDYwMDAwKSB7XG4gICAgY29uc3QgcCA9IG1ldHJpYy5wcmVmaXgoZCwgLTEpXG4gICAgcmV0dXJuIG1hdGgucm91bmQocC5uICogMTAwKSAvIDEwMCArIHAucHJlZml4ICsgJ3MnXG4gIH1cbiAgZCA9IG1hdGguZmxvb3IoZCAvIDEwMDApXG4gIGNvbnN0IHNlY29uZHMgPSBkICUgNjBcbiAgY29uc3QgbWludXRlcyA9IG1hdGguZmxvb3IoZCAvIDYwKSAlIDYwXG4gIGNvbnN0IGhvdXJzID0gbWF0aC5mbG9vcihkIC8gMzYwMCkgJSAyNFxuICBjb25zdCBkYXlzID0gbWF0aC5mbG9vcihkIC8gODY0MDApXG4gIGlmIChkYXlzID4gMCkge1xuICAgIHJldHVybiBkYXlzICsgJ2QnICsgKChob3VycyA+IDAgfHwgbWludXRlcyA+IDMwKSA/ICcgJyArIChtaW51dGVzID4gMzAgPyBob3VycyArIDEgOiBob3VycykgKyAnaCcgOiAnJylcbiAgfVxuICBpZiAoaG91cnMgPiAwKSB7XG4gICAgLyogYzggaWdub3JlIG5leHQgKi9cbiAgICByZXR1cm4gaG91cnMgKyAnaCcgKyAoKG1pbnV0ZXMgPiAwIHx8IHNlY29uZHMgPiAzMCkgPyAnICcgKyAoc2Vjb25kcyA+IDMwID8gbWludXRlcyArIDEgOiBtaW51dGVzKSArICdtaW4nIDogJycpXG4gIH1cbiAgcmV0dXJuIG1pbnV0ZXMgKyAnbWluJyArIChzZWNvbmRzID4gMCA/ICcgJyArIHNlY29uZHMgKyAncycgOiAnJylcbn1cbiIsICIvKipcbiAqIFV0aWxpdHkgbW9kdWxlIHRvIHdvcmsgd2l0aCBrZXktdmFsdWUgc3RvcmVzLlxuICpcbiAqIEBtb2R1bGUgbWFwXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IE1hcCBpbnN0YW5jZS5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEByZXR1cm4ge01hcDxhbnksIGFueT59XG4gKlxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGUgPSAoKSA9PiBuZXcgTWFwKClcblxuLyoqXG4gKiBDb3B5IGEgTWFwIG9iamVjdCBpbnRvIGEgZnJlc2ggTWFwIG9iamVjdC5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEB0ZW1wbGF0ZSBYLFlcbiAqIEBwYXJhbSB7TWFwPFgsWT59IG1cbiAqIEByZXR1cm4ge01hcDxYLFk+fVxuICovXG5leHBvcnQgY29uc3QgY29weSA9IG0gPT4ge1xuICBjb25zdCByID0gY3JlYXRlKClcbiAgbS5mb3JFYWNoKCh2LCBrKSA9PiB7IHIuc2V0KGssIHYpIH0pXG4gIHJldHVybiByXG59XG5cbi8qKlxuICogR2V0IG1hcCBwcm9wZXJ0eS4gQ3JlYXRlIFQgaWYgcHJvcGVydHkgaXMgdW5kZWZpbmVkIGFuZCBzZXQgVCBvbiBtYXAuXG4gKlxuICogYGBganNcbiAqIGNvbnN0IGxpc3RlbmVycyA9IG1hcC5zZXRJZlVuZGVmaW5lZChldmVudHMsICdldmVudE5hbWUnLCBzZXQuY3JlYXRlKVxuICogbGlzdGVuZXJzLmFkZChsaXN0ZW5lcilcbiAqIGBgYFxuICpcbiAqIEBmdW5jdGlvblxuICogQHRlbXBsYXRlIFYsS1xuICogQHRlbXBsYXRlIHtNYXA8SyxWPn0gTUFQXG4gKiBAcGFyYW0ge01BUH0gbWFwXG4gKiBAcGFyYW0ge0t9IGtleVxuICogQHBhcmFtIHtmdW5jdGlvbigpOlZ9IGNyZWF0ZVRcbiAqIEByZXR1cm4ge1Z9XG4gKi9cbmV4cG9ydCBjb25zdCBzZXRJZlVuZGVmaW5lZCA9IChtYXAsIGtleSwgY3JlYXRlVCkgPT4ge1xuICBsZXQgc2V0ID0gbWFwLmdldChrZXkpXG4gIGlmIChzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIG1hcC5zZXQoa2V5LCBzZXQgPSBjcmVhdGVUKCkpXG4gIH1cbiAgcmV0dXJuIHNldFxufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gQXJyYXkgYW5kIHBvcHVsYXRlcyBpdCB3aXRoIHRoZSBjb250ZW50IG9mIGFsbCBrZXktdmFsdWUgcGFpcnMgdXNpbmcgdGhlIGBmKHZhbHVlLCBrZXkpYCBmdW5jdGlvbi5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEB0ZW1wbGF0ZSBLXG4gKiBAdGVtcGxhdGUgVlxuICogQHRlbXBsYXRlIFJcbiAqIEBwYXJhbSB7TWFwPEssVj59IG1cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oVixLKTpSfSBmXG4gKiBAcmV0dXJuIHtBcnJheTxSPn1cbiAqL1xuZXhwb3J0IGNvbnN0IG1hcCA9IChtLCBmKSA9PiB7XG4gIGNvbnN0IHJlcyA9IFtdXG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIG0pIHtcbiAgICByZXMucHVzaChmKHZhbHVlLCBrZXkpKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyoqXG4gKiBUZXN0cyB3aGV0aGVyIGFueSBrZXktdmFsdWUgcGFpcnMgcGFzcyB0aGUgdGVzdCBpbXBsZW1lbnRlZCBieSBgZih2YWx1ZSwga2V5KWAuXG4gKlxuICogQHRvZG8gc2hvdWxkIHJlbmFtZSB0byBzb21lIC0gc2ltaWxhcmx5IHRvIEFycmF5LnNvbWVcbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEB0ZW1wbGF0ZSBLXG4gKiBAdGVtcGxhdGUgVlxuICogQHBhcmFtIHtNYXA8SyxWPn0gbVxuICogQHBhcmFtIHtmdW5jdGlvbihWLEspOmJvb2xlYW59IGZcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBjb25zdCBhbnkgPSAobSwgZikgPT4ge1xuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBtKSB7XG4gICAgaWYgKGYodmFsdWUsIGtleSkpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG4vKipcbiAqIFRlc3RzIHdoZXRoZXIgYWxsIGtleS12YWx1ZSBwYWlycyBwYXNzIHRoZSB0ZXN0IGltcGxlbWVudGVkIGJ5IGBmKHZhbHVlLCBrZXkpYC5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEB0ZW1wbGF0ZSBLXG4gKiBAdGVtcGxhdGUgVlxuICogQHBhcmFtIHtNYXA8SyxWPn0gbVxuICogQHBhcmFtIHtmdW5jdGlvbihWLEspOmJvb2xlYW59IGZcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBjb25zdCBhbGwgPSAobSwgZikgPT4ge1xuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBtKSB7XG4gICAgaWYgKCFmKHZhbHVlLCBrZXkpKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cbiIsICIvKipcbiAqIFV0aWxpdHkgbW9kdWxlIHRvIHdvcmsgd2l0aCBzZXRzLlxuICpcbiAqIEBtb2R1bGUgc2V0XG4gKi9cblxuZXhwb3J0IGNvbnN0IGNyZWF0ZSA9ICgpID0+IG5ldyBTZXQoKVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge1NldDxUPn0gc2V0XG4gKiBAcmV0dXJuIHtBcnJheTxUPn1cbiAqL1xuZXhwb3J0IGNvbnN0IHRvQXJyYXkgPSBzZXQgPT4gQXJyYXkuZnJvbShzZXQpXG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7U2V0PFQ+fSBzZXRcbiAqIEByZXR1cm4ge1R9XG4gKi9cbmV4cG9ydCBjb25zdCBmaXJzdCA9IHNldCA9PlxuICBzZXQudmFsdWVzKCkubmV4dCgpLnZhbHVlIHx8IHVuZGVmaW5lZFxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge0l0ZXJhYmxlPFQ+fSBlbnRyaWVzXG4gKiBAcmV0dXJuIHtTZXQ8VD59XG4gKi9cbmV4cG9ydCBjb25zdCBmcm9tID0gZW50cmllcyA9PiBuZXcgU2V0KGVudHJpZXMpXG4iLCAiLyoqXG4gKiBVdGlsaXR5IG1vZHVsZSB0byB3b3JrIHdpdGggQXJyYXlzLlxuICpcbiAqIEBtb2R1bGUgYXJyYXlcbiAqL1xuXG5pbXBvcnQgKiBhcyBzZXQgZnJvbSAnLi9zZXQuanMnXG5cbi8qKlxuICogUmV0dXJuIHRoZSBsYXN0IGVsZW1lbnQgb2YgYW4gYXJyYXkuIFRoZSBlbGVtZW50IG11c3QgZXhpc3RcbiAqXG4gKiBAdGVtcGxhdGUgTFxuICogQHBhcmFtIHtBcnJheUxpa2U8TD59IGFyclxuICogQHJldHVybiB7TH1cbiAqL1xuZXhwb3J0IGNvbnN0IGxhc3QgPSBhcnIgPT4gYXJyW2Fyci5sZW5ndGggLSAxXVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBDXG4gKiBAcmV0dXJuIHtBcnJheTxDPn1cbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZSA9ICgpID0+IC8qKiBAdHlwZSB7QXJyYXk8Qz59ICovIChbXSlcblxuLyoqXG4gKiBAdGVtcGxhdGUgRFxuICogQHBhcmFtIHtBcnJheTxEPn0gYVxuICogQHJldHVybiB7QXJyYXk8RD59XG4gKi9cbmV4cG9ydCBjb25zdCBjb3B5ID0gYSA9PiAvKiogQHR5cGUge0FycmF5PEQ+fSAqLyAoYS5zbGljZSgpKVxuXG4vKipcbiAqIEFwcGVuZCBlbGVtZW50cyBmcm9tIHNyYyB0byBkZXN0XG4gKlxuICogQHRlbXBsYXRlIE1cbiAqIEBwYXJhbSB7QXJyYXk8TT59IGRlc3RcbiAqIEBwYXJhbSB7QXJyYXk8TT59IHNyY1xuICovXG5leHBvcnQgY29uc3QgYXBwZW5kVG8gPSAoZGVzdCwgc3JjKSA9PiB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3JjLmxlbmd0aDsgaSsrKSB7XG4gICAgZGVzdC5wdXNoKHNyY1tpXSlcbiAgfVxufVxuXG4vKipcbiAqIFRyYW5zZm9ybXMgc29tZXRoaW5nIGFycmF5LWxpa2UgdG8gYW4gYWN0dWFsIEFycmF5LlxuICpcbiAqIEBmdW5jdGlvblxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7QXJyYXlMaWtlPFQ+fEl0ZXJhYmxlPFQ+fSBhcnJheWxpa2VcbiAqIEByZXR1cm4ge1R9XG4gKi9cbmV4cG9ydCBjb25zdCBmcm9tID0gQXJyYXkuZnJvbVxuXG4vKipcbiAqIFRydWUgaWZmIGNvbmRpdGlvbiBob2xkcyBvbiBldmVyeSBlbGVtZW50IGluIHRoZSBBcnJheS5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEB0ZW1wbGF0ZSBJVEVNXG4gKiBAdGVtcGxhdGUge0FycmF5TGlrZTxJVEVNPn0gQVJSXG4gKlxuICogQHBhcmFtIHtBUlJ9IGFyclxuICogQHBhcmFtIHtmdW5jdGlvbihJVEVNLCBudW1iZXIsIEFSUik6Ym9vbGVhbn0gZlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGNvbnN0IGV2ZXJ5ID0gKGFyciwgZikgPT4ge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGlmICghZihhcnJbaV0sIGksIGFycikpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG4vKipcbiAqIFRydWUgaWZmIGNvbmRpdGlvbiBob2xkcyBvbiBzb21lIGVsZW1lbnQgaW4gdGhlIEFycmF5LlxuICpcbiAqIEBmdW5jdGlvblxuICogQHRlbXBsYXRlIFNcbiAqIEB0ZW1wbGF0ZSB7QXJyYXlMaWtlPFM+fSBBUlJcbiAqIEBwYXJhbSB7QVJSfSBhcnJcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oUywgbnVtYmVyLCBBUlIpOmJvb2xlYW59IGZcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBjb25zdCBzb21lID0gKGFyciwgZikgPT4ge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGlmIChmKGFycltpXSwgaSwgYXJyKSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbi8qKlxuICogQHRlbXBsYXRlIEVMRU1cbiAqXG4gKiBAcGFyYW0ge0FycmF5TGlrZTxFTEVNPn0gYVxuICogQHBhcmFtIHtBcnJheUxpa2U8RUxFTT59IGJcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBjb25zdCBlcXVhbEZsYXQgPSAoYSwgYikgPT4gYS5sZW5ndGggPT09IGIubGVuZ3RoICYmIGV2ZXJ5KGEsIChpdGVtLCBpbmRleCkgPT4gaXRlbSA9PT0gYltpbmRleF0pXG5cbi8qKlxuICogQHRlbXBsYXRlIEVMRU1cbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8RUxFTT4+fSBhcnJcbiAqIEByZXR1cm4ge0FycmF5PEVMRU0+fVxuICovXG5leHBvcnQgY29uc3QgZmxhdHRlbiA9IGFyciA9PiBmb2xkKGFyciwgLyoqIEB0eXBlIHtBcnJheTxFTEVNPn0gKi8gKFtdKSwgKGFjYywgdmFsKSA9PiBhY2MuY29uY2F0KHZhbCkpXG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZW5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24obnVtYmVyLCBBcnJheTxUPik6VH0gZlxuICogQHJldHVybiB7QXJyYXk8VD59XG4gKi9cbmV4cG9ydCBjb25zdCB1bmZvbGQgPSAobGVuLCBmKSA9PiB7XG4gIGNvbnN0IGFycmF5ID0gbmV3IEFycmF5KGxlbilcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGFycmF5W2ldID0gZihpLCBhcnJheSlcbiAgfVxuICByZXR1cm4gYXJyYXlcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHRlbXBsYXRlIFJFU1VMVFxuICogQHBhcmFtIHtBcnJheTxUPn0gYXJyXG4gKiBAcGFyYW0ge1JFU1VMVH0gc2VlZFxuICogQHBhcmFtIHtmdW5jdGlvbihSRVNVTFQsIFQsIG51bWJlcik6UkVTVUxUfSBmb2xkZXJcbiAqL1xuZXhwb3J0IGNvbnN0IGZvbGQgPSAoYXJyLCBzZWVkLCBmb2xkZXIpID0+IGFyci5yZWR1Y2UoZm9sZGVyLCBzZWVkKVxuXG5leHBvcnQgY29uc3QgaXNBcnJheSA9IEFycmF5LmlzQXJyYXlcblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtBcnJheTxUPn0gYXJyXG4gKiBAcmV0dXJuIHtBcnJheTxUPn1cbiAqL1xuZXhwb3J0IGNvbnN0IHVuaXF1ZSA9IGFyciA9PiBmcm9tKHNldC5mcm9tKGFycikpXG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEB0ZW1wbGF0ZSBNXG4gKiBAcGFyYW0ge0FycmF5TGlrZTxUPn0gYXJyXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKFQpOk19IG1hcHBlclxuICogQHJldHVybiB7QXJyYXk8VD59XG4gKi9cbmV4cG9ydCBjb25zdCB1bmlxdWVCeSA9IChhcnIsIG1hcHBlcikgPT4ge1xuICAvKipcbiAgICogQHR5cGUge1NldDxNPn1cbiAgICovXG4gIGNvbnN0IGhhcHBlbmVkID0gc2V0LmNyZWF0ZSgpXG4gIC8qKlxuICAgKiBAdHlwZSB7QXJyYXk8VD59XG4gICAqL1xuICBjb25zdCByZXN1bHQgPSBbXVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGVsID0gYXJyW2ldXG4gICAgY29uc3QgbWFwcGVkID0gbWFwcGVyKGVsKVxuICAgIGlmICghaGFwcGVuZWQuaGFzKG1hcHBlZCkpIHtcbiAgICAgIGhhcHBlbmVkLmFkZChtYXBwZWQpXG4gICAgICByZXN1bHQucHVzaChlbClcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSB7QXJyYXlMaWtlPGFueT59IEFSUlxuICogQHRlbXBsYXRlIHtmdW5jdGlvbihBUlIgZXh0ZW5kcyBBcnJheUxpa2U8aW5mZXIgVD4gPyBUIDogbmV2ZXIsIG51bWJlciwgQVJSKTphbnl9IE1BUFBFUlxuICogQHBhcmFtIHtBUlJ9IGFyclxuICogQHBhcmFtIHtNQVBQRVJ9IG1hcHBlclxuICogQHJldHVybiB7QXJyYXk8TUFQUEVSIGV4dGVuZHMgZnVuY3Rpb24oLi4uYW55KTogaW5mZXIgTSA/IE0gOiBuZXZlcj59XG4gKi9cbmV4cG9ydCBjb25zdCBtYXAgPSAoYXJyLCBtYXBwZXIpID0+IHtcbiAgLyoqXG4gICAqIEB0eXBlIHtBcnJheTxhbnk+fVxuICAgKi9cbiAgY29uc3QgcmVzID0gQXJyYXkoYXJyLmxlbmd0aClcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICByZXNbaV0gPSBtYXBwZXIoLyoqIEB0eXBlIHthbnl9ICovIChhcnJbaV0pLCBpLCAvKiogQHR5cGUge2FueX0gKi8gKGFycikpXG4gIH1cbiAgcmV0dXJuIC8qKiBAdHlwZSB7YW55fSAqLyAocmVzKVxufVxuIiwgIi8qKlxuICogT2JzZXJ2YWJsZSBjbGFzcyBwcm90b3R5cGUuXG4gKlxuICogQG1vZHVsZSBvYnNlcnZhYmxlXG4gKi9cblxuaW1wb3J0ICogYXMgbWFwIGZyb20gJy4vbWFwLmpzJ1xuaW1wb3J0ICogYXMgc2V0IGZyb20gJy4vc2V0LmpzJ1xuaW1wb3J0ICogYXMgYXJyYXkgZnJvbSAnLi9hcnJheS5qcydcblxuLyoqXG4gKiBIYW5kbGVzIG5hbWVkIGV2ZW50cy5cbiAqIEBleHBlcmltZW50YWxcbiAqXG4gKiBUaGlzIGlzIGJhc2ljYWxseSBhIChiZXR0ZXIgdHlwZWQpIGR1cGxpY2F0ZSBvZiBPYnNlcnZhYmxlLCB3aGljaCB3aWxsIHJlcGxhY2UgT2JzZXJ2YWJsZSBpbiB0aGVcbiAqIG5leHQgcmVsZWFzZS5cbiAqXG4gKiBAdGVtcGxhdGUge3tba2V5IGluIGtleW9mIEVWRU5UU106IGZ1bmN0aW9uKC4uLmFueSk6dm9pZH19IEVWRU5UU1xuICovXG5leHBvcnQgY2xhc3MgT2JzZXJ2YWJsZVYyIHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIC8qKlxuICAgICAqIFNvbWUgZGVzYy5cbiAgICAgKiBAdHlwZSB7TWFwPHN0cmluZywgU2V0PGFueT4+fVxuICAgICAqL1xuICAgIHRoaXMuX29ic2VydmVycyA9IG1hcC5jcmVhdGUoKVxuICB9XG5cbiAgLyoqXG4gICAqIEB0ZW1wbGF0ZSB7a2V5b2YgRVZFTlRTICYgc3RyaW5nfSBOQU1FXG4gICAqIEBwYXJhbSB7TkFNRX0gbmFtZVxuICAgKiBAcGFyYW0ge0VWRU5UU1tOQU1FXX0gZlxuICAgKi9cbiAgb24gKG5hbWUsIGYpIHtcbiAgICBtYXAuc2V0SWZVbmRlZmluZWQodGhpcy5fb2JzZXJ2ZXJzLCAvKiogQHR5cGUge3N0cmluZ30gKi8gKG5hbWUpLCBzZXQuY3JlYXRlKS5hZGQoZilcbiAgICByZXR1cm4gZlxuICB9XG5cbiAgLyoqXG4gICAqIEB0ZW1wbGF0ZSB7a2V5b2YgRVZFTlRTICYgc3RyaW5nfSBOQU1FXG4gICAqIEBwYXJhbSB7TkFNRX0gbmFtZVxuICAgKiBAcGFyYW0ge0VWRU5UU1tOQU1FXX0gZlxuICAgKi9cbiAgb25jZSAobmFtZSwgZikge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSAgey4uLmFueX0gYXJnc1xuICAgICAqL1xuICAgIGNvbnN0IF9mID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgIHRoaXMub2ZmKG5hbWUsIC8qKiBAdHlwZSB7YW55fSAqLyAoX2YpKVxuICAgICAgZiguLi5hcmdzKVxuICAgIH1cbiAgICB0aGlzLm9uKG5hbWUsIC8qKiBAdHlwZSB7YW55fSAqLyAoX2YpKVxuICB9XG5cbiAgLyoqXG4gICAqIEB0ZW1wbGF0ZSB7a2V5b2YgRVZFTlRTICYgc3RyaW5nfSBOQU1FXG4gICAqIEBwYXJhbSB7TkFNRX0gbmFtZVxuICAgKiBAcGFyYW0ge0VWRU5UU1tOQU1FXX0gZlxuICAgKi9cbiAgb2ZmIChuYW1lLCBmKSB7XG4gICAgY29uc3Qgb2JzZXJ2ZXJzID0gdGhpcy5fb2JzZXJ2ZXJzLmdldChuYW1lKVxuICAgIGlmIChvYnNlcnZlcnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgb2JzZXJ2ZXJzLmRlbGV0ZShmKVxuICAgICAgaWYgKG9ic2VydmVycy5zaXplID09PSAwKSB7XG4gICAgICAgIHRoaXMuX29ic2VydmVycy5kZWxldGUobmFtZSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRW1pdCBhIG5hbWVkIGV2ZW50LiBBbGwgcmVnaXN0ZXJlZCBldmVudCBsaXN0ZW5lcnMgdGhhdCBsaXN0ZW4gdG8gdGhlXG4gICAqIHNwZWNpZmllZCBuYW1lIHdpbGwgcmVjZWl2ZSB0aGUgZXZlbnQuXG4gICAqXG4gICAqIEB0b2RvIFRoaXMgc2hvdWxkIGNhdGNoIGV4Y2VwdGlvbnNcbiAgICpcbiAgICogQHRlbXBsYXRlIHtrZXlvZiBFVkVOVFMgJiBzdHJpbmd9IE5BTUVcbiAgICogQHBhcmFtIHtOQU1FfSBuYW1lIFRoZSBldmVudCBuYW1lLlxuICAgKiBAcGFyYW0ge1BhcmFtZXRlcnM8RVZFTlRTW05BTUVdPn0gYXJncyBUaGUgYXJndW1lbnRzIHRoYXQgYXJlIGFwcGxpZWQgdG8gdGhlIGV2ZW50IGxpc3RlbmVyLlxuICAgKi9cbiAgZW1pdCAobmFtZSwgYXJncykge1xuICAgIC8vIGNvcHkgYWxsIGxpc3RlbmVycyB0byBhbiBhcnJheSBmaXJzdCB0byBtYWtlIHN1cmUgdGhhdCBubyBldmVudCBpcyBlbWl0dGVkIHRvIGxpc3RlbmVycyB0aGF0IGFyZSBzdWJzY3JpYmVkIHdoaWxlIHRoZSBldmVudCBoYW5kbGVyIGlzIGNhbGxlZC5cbiAgICByZXR1cm4gYXJyYXkuZnJvbSgodGhpcy5fb2JzZXJ2ZXJzLmdldChuYW1lKSB8fCBtYXAuY3JlYXRlKCkpLnZhbHVlcygpKS5mb3JFYWNoKGYgPT4gZiguLi5hcmdzKSlcbiAgfVxuXG4gIGRlc3Ryb3kgKCkge1xuICAgIHRoaXMuX29ic2VydmVycyA9IG1hcC5jcmVhdGUoKVxuICB9XG59XG5cbi8qIGM4IGlnbm9yZSBzdGFydCAqL1xuLyoqXG4gKiBIYW5kbGVzIG5hbWVkIGV2ZW50cy5cbiAqXG4gKiBAZGVwcmVjYXRlZFxuICogQHRlbXBsYXRlIE5cbiAqL1xuZXhwb3J0IGNsYXNzIE9ic2VydmFibGUge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgLyoqXG4gICAgICogU29tZSBkZXNjLlxuICAgICAqIEB0eXBlIHtNYXA8TiwgYW55Pn1cbiAgICAgKi9cbiAgICB0aGlzLl9vYnNlcnZlcnMgPSBtYXAuY3JlYXRlKClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge059IG5hbWVcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gZlxuICAgKi9cbiAgb24gKG5hbWUsIGYpIHtcbiAgICBtYXAuc2V0SWZVbmRlZmluZWQodGhpcy5fb2JzZXJ2ZXJzLCBuYW1lLCBzZXQuY3JlYXRlKS5hZGQoZilcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge059IG5hbWVcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gZlxuICAgKi9cbiAgb25jZSAobmFtZSwgZikge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSAgey4uLmFueX0gYXJnc1xuICAgICAqL1xuICAgIGNvbnN0IF9mID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgIHRoaXMub2ZmKG5hbWUsIF9mKVxuICAgICAgZiguLi5hcmdzKVxuICAgIH1cbiAgICB0aGlzLm9uKG5hbWUsIF9mKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Tn0gbmFtZVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmXG4gICAqL1xuICBvZmYgKG5hbWUsIGYpIHtcbiAgICBjb25zdCBvYnNlcnZlcnMgPSB0aGlzLl9vYnNlcnZlcnMuZ2V0KG5hbWUpXG4gICAgaWYgKG9ic2VydmVycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBvYnNlcnZlcnMuZGVsZXRlKGYpXG4gICAgICBpZiAob2JzZXJ2ZXJzLnNpemUgPT09IDApIHtcbiAgICAgICAgdGhpcy5fb2JzZXJ2ZXJzLmRlbGV0ZShuYW1lKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBFbWl0IGEgbmFtZWQgZXZlbnQuIEFsbCByZWdpc3RlcmVkIGV2ZW50IGxpc3RlbmVycyB0aGF0IGxpc3RlbiB0byB0aGVcbiAgICogc3BlY2lmaWVkIG5hbWUgd2lsbCByZWNlaXZlIHRoZSBldmVudC5cbiAgICpcbiAgICogQHRvZG8gVGhpcyBzaG91bGQgY2F0Y2ggZXhjZXB0aW9uc1xuICAgKlxuICAgKiBAcGFyYW0ge059IG5hbWUgVGhlIGV2ZW50IG5hbWUuXG4gICAqIEBwYXJhbSB7QXJyYXk8YW55Pn0gYXJncyBUaGUgYXJndW1lbnRzIHRoYXQgYXJlIGFwcGxpZWQgdG8gdGhlIGV2ZW50IGxpc3RlbmVyLlxuICAgKi9cbiAgZW1pdCAobmFtZSwgYXJncykge1xuICAgIC8vIGNvcHkgYWxsIGxpc3RlbmVycyB0byBhbiBhcnJheSBmaXJzdCB0byBtYWtlIHN1cmUgdGhhdCBubyBldmVudCBpcyBlbWl0dGVkIHRvIGxpc3RlbmVycyB0aGF0IGFyZSBzdWJzY3JpYmVkIHdoaWxlIHRoZSBldmVudCBoYW5kbGVyIGlzIGNhbGxlZC5cbiAgICByZXR1cm4gYXJyYXkuZnJvbSgodGhpcy5fb2JzZXJ2ZXJzLmdldChuYW1lKSB8fCBtYXAuY3JlYXRlKCkpLnZhbHVlcygpKS5mb3JFYWNoKGYgPT4gZiguLi5hcmdzKSlcbiAgfVxuXG4gIGRlc3Ryb3kgKCkge1xuICAgIHRoaXMuX29ic2VydmVycyA9IG1hcC5jcmVhdGUoKVxuICB9XG59XG4vKiBjOCBpZ25vcmUgZW5kICovXG4iLCAiaW1wb3J0IHsgTWFya2Rvd25WaWV3LCBNZW51LCBURmlsZSwgZGVib3VuY2UsIG5vcm1hbGl6ZVBhdGggfSBmcm9tICdvYnNpZGlhbidcbmltcG9ydCAqIGFzIFkgZnJvbSAneWpzJ1xuaW1wb3J0IHsgY2FsY3VsYXRlSGFzaCwgY3JlYXRlUmFuZG9tSWQsIGdlbmVyYXRlUmFuZG9tU3RyaW5nLCByYW5kb21VaW50MzIgfSBmcm9tICcuLi90b29scydcbmltcG9ydCB7IENvbXBhcnRtZW50IH0gZnJvbSBcIkBjb2RlbWlycm9yL3N0YXRlXCI7XG5pbXBvcnQgUGVlckRyYWZ0UGx1Z2luIGZyb20gJy4uL21haW4nO1xuaW1wb3J0IHsgb3BlbkZpbGVJbk5ld1RhYiwgcGluTGVhZiwgc2hvd05vdGljZSwgdXNlcmNvbG9ycyB9IGZyb20gJy4uL3VpJztcbmltcG9ydCB7IHlDb2xsYWIgfSBmcm9tICd5LWNvZGVtaXJyb3IubmV4dCc7XG5pbXBvcnQgeyBFZGl0b3JWaWV3IH0gZnJvbSAnQGNvZGVtaXJyb3Ivdmlldyc7XG5pbXBvcnQgeyBTdGF0ZUVmZmVjdCB9IGZyb20gXCJAY29kZW1pcnJvci9zdGF0ZVwiO1xuaW1wb3J0IHsgUGVlcmRyYWZ0UmVjb3JkIH0gZnJvbSAnLi4vdXRpbHMvcGVlcmRyYWZ0UmVjb3JkJztcbmltcG9ydCB7IFBlcm1hbmVudFNoYXJlRG9jdW1lbnQgfSBmcm9tICcuLi9wZXJtYW5lbnRTaGFyZVN0b3JlJztcbmltcG9ydCB7IGdldExlYWZJZHNCeVBhdGggfSBmcm9tICcuLi93b3Jrc3BhY2UvcGVlcmRyYWZ0V29ya3NwYWNlJztcbmltcG9ydCB7IFNoYXJlZEVudGl0eSB9IGZyb20gJy4vc2hhcmVkRW50aXR5JztcbmltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgeyBJbmRleGVkZGJQZXJzaXN0ZW5jZSB9IGZyb20gJ3ktaW5kZXhlZGRiJztcbmltcG9ydCB7IGFkZElzU2hhcmVkQ2xhc3MsIHJlbW92ZUlzU2hhcmVkQ2xhc3MgfSBmcm9tICdzcmMvd29ya3NwYWNlL2V4cGxvcmVyVmlldyc7XG5pbXBvcnQgeyBTaGFyZWRGb2xkZXIgfSBmcm9tICcuL3NoYXJlZEZvbGRlcic7XG5pbXBvcnQgeyBNdXRleCB9IGZyb20gJ2FzeW5jLW11dGV4JztcbmltcG9ydCB7IGRpZmYsIGRpZmZDbGVhbnVwRWZmaWNpZW5jeSB9IGZyb20gJ2RpZmYtbWF0Y2gtcGF0Y2gtZXMnXG5pbXBvcnQgeyBhZGQsIGdldERvY0J5UGF0aCwgbW92ZURvYywgcmVtb3ZlRG9jIH0gZnJvbSAnc3JjL3Blcm1hbmVudFNoYXJlU3RvcmVGUyc7XG5cbmV4cG9ydCBjbGFzcyBTaGFyZWREb2N1bWVudCBleHRlbmRzIFNoYXJlZEVudGl0eSB7XG5cbiAgcHJpdmF0ZSBzdGF0aWMgX3VzZXJDb2xvciA9IHVzZXJjb2xvcnNbcmFuZG9tVWludDMyKCkgJSB1c2VyY29sb3JzLmxlbmd0aF1cblxuICBwcml2YXRlIF9pc1Blcm1hbmVudDogYm9vbGVhblxuICBwcml2YXRlIF9maWxlOiBURmlsZVxuXG4gIHByaXZhdGUgX2V4dGVuc2lvbnM6IFBlZXJkcmFmdFJlY29yZDxDb21wYXJ0bWVudD5cblxuICBwcml2YXRlIHN0YXR1c0JhckVudHJ5PzogSFRNTEVsZW1lbnRcblxuICBwcm90ZWN0ZWQgc3RhdGljIF9zaGFyZWRFbnRpdGVzOiBBcnJheTxTaGFyZWREb2N1bWVudD4gPSBuZXcgQXJyYXk8U2hhcmVkRG9jdW1lbnQ+KClcblxuICBwcml2YXRlIG11dGV4ID0gbmV3IE11dGV4XG4gIHByaXZhdGUgbGFzdFVwZGF0ZVRyaWdnZXJlZEJ5RG9jQ2hhbmdlOiBudW1iZXJcblxuICBzdGF0aWMgYXN5bmMgZnJvbVZpZXcodmlldzogTWFya2Rvd25WaWV3LCBwbHVnaW46IFBlZXJEcmFmdFBsdWdpbiwgb3B0cyA9IHsgcGVybWFuZW50OiBmYWxzZSB9KSB7XG4gICAgaWYgKCF2aWV3LmZpbGUpIHJldHVyblxuICAgIGlmICh0aGlzLmZpbmRCeVBhdGgodmlldy5maWxlLnBhdGgpKSByZXR1cm5cbiAgICBjb25zdCBkb2MgPSBhd2FpdCB0aGlzLmZyb21URmlsZSh2aWV3LmZpbGUsIG9wdHMsIHBsdWdpbilcbiAgICBpZiAoZG9jKSB7XG4gICAgICBkb2Muc3RhcnRXZWJSVENTeW5jKClcbiAgICAgIGlmIChkb2MuaXNQZXJtYW5lbnQgJiYgZG9jLl93ZWJSVENQcm92aWRlcikge1xuICAgICAgICBkb2MuZ2V0T3duZXJGcmFnbWVudCgpLmluc2VydCgwLCBkb2MuX3dlYlJUQ1Byb3ZpZGVyLmF3YXJlbmVzcy5jbGllbnRJRC50b0ZpeGVkKDApKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZG9jLmFkZFN0YXR1c0JhckVudHJ5KClcbiAgICAgICAgcGluTGVhZih2aWV3LmxlYWYpXG4gICAgICB9XG4gICAgICBuYXZpZ2F0b3IuY2xpcGJvYXJkLndyaXRlVGV4dChwbHVnaW4uc2V0dGluZ3MuYmFzZVBhdGggKyBcIi9jbS9cIiArIGRvYy5zaGFyZUlkKVxuICAgICAgc2hvd05vdGljZShcIkNvbGxhYm9yYXRpb24gc3RhcnRlZCBmb3IgXCIgKyBkb2MucGF0aCArIFwiLiBMaW5rIGNvcGllZCB0byBDbGlwYm9hcmQuXCIpXG4gICAgfVxuICAgIHJldHVybiBkb2NcbiAgfVxuXG4gIHN0YXRpYyBhc3luYyBmcm9tUGVybWFuZW50U2hhcmVEb2N1bWVudChwZDogUGVybWFuZW50U2hhcmVEb2N1bWVudCwgcGx1Z2luOiBQZWVyRHJhZnRQbHVnaW4pIHtcbiAgICBpZiAodGhpcy5maW5kQnlQYXRoKHBkLnBhdGgpKSByZXR1cm5cbiAgICAvL2xldCBmaWxlQWxyZWFkeVRoZXJlID0gZmFsc2VcbiAgICAvLyBjaGVjayBpZiBwYXRoIGV4aXN0c1xuICAgIGNvbnN0IGZpbGUgPSBwbHVnaW4uYXBwLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChub3JtYWxpemVQYXRoKHBkLnBhdGgpKVxuICAgIGlmICghZmlsZSkge1xuICAgICAgc2hvd05vdGljZShcIkZpbGUgXCIgKyBwZC5wYXRoICsgXCIgbm90IGZvdW5kLiBDcmVhdGluZyBpdCBub3cuXCIpXG4gICAgICBhd2FpdCBTaGFyZWRGb2xkZXIuZ2V0T3JDcmVhdGVQYXRoKHBhdGguZGlybmFtZShwZC5wYXRoKSwgcGx1Z2luKVxuICAgICAgY29uc3QgZmlsZSA9IGF3YWl0IHBsdWdpbi5hcHAudmF1bHQuY3JlYXRlKHBkLnBhdGgsICcnKVxuICAgICAgaWYgKCFmaWxlKSB7XG4gICAgICAgIHNob3dOb3RpY2UoXCJFcnJvciBjcmVhdGluZyBmaWxlIFwiICsgcGQucGF0aCArIFwiLlwiKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIC8vZmlsZUFscmVhZHlUaGVyZSA9IHRydWVcbiAgICB9XG5cbiAgICBjb25zdCBkb2MgPSBuZXcgU2hhcmVkRG9jdW1lbnQoe1xuICAgICAgcGF0aDogcGQucGF0aFxuICAgIH0sIHBsdWdpbilcbiAgICBkb2MuX2lzUGVybWFuZW50ID0gdHJ1ZVxuICAgIGRvYy5fc2hhcmVJZCA9IHBkLnNoYXJlSWRcbiAgICBhd2FpdCBkb2Muc3RhcnRJbmRleGVkREJTeW5jKClcbiAgICAvL2lmIChmaWxlQWxyZWFkeVRoZXJlKSB7XG4gICAgZG9jLnN5bmNXaXRoU2VydmVyKClcbiAgICAvL31cbiAgICBwbHVnaW4uYWN0aXZlU3RyZWFtQ2xpZW50LmFkZChbZG9jLnNoYXJlSWRdKVxuICAgIHJldHVybiBkb2NcbiAgfVxuXG4gIHN0YXRpYyBhc3luYyBmcm9tU2hhcmVVUkwodXJsOiBzdHJpbmcsIHBsdWdpbjogUGVlckRyYWZ0UGx1Z2luKTogUHJvbWlzZTxTaGFyZWREb2N1bWVudCB8IHZvaWQ+IHtcbiAgICBjb25zdCBpZCA9IHVybC5zcGxpdCgnLycpLnBvcCgpXG4gICAgaWYgKCFpZCB8fCAhaWQubWF0Y2goJ15bMC05YS1mXXs4fS1bMC05YS1mXXs0fS1bMC05YS1mXXs0fS1bMC05YS1mXXs0fS1bMC05YS1mXXsxMn0kJykpIHtcbiAgICAgIHNob3dOb3RpY2UoXCJObyB2YWxpZCBwZWVyZHJhZnQgbGlua1wiKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgZXhpc3RpbmdEb2MgPSBTaGFyZWREb2N1bWVudC5maW5kQnlJZChpZClcbiAgICBpZiAoZXhpc3RpbmdEb2MpIHtcbiAgICAgIHNob3dOb3RpY2UoXCJUaGlzIHNoYXJlIGlzIGFscmVhZHkgYWN0aXZlOiBcIiArIGV4aXN0aW5nRG9jLnBhdGgpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCBpc1Blcm1hbmVudCA9IGF3YWl0IHBsdWdpbi5zZXJ2ZXJBUEkuaXNTZXNzaW9uUGVybWFuZW50KGlkKVxuXG4gICAgY29uc3QgeURvYyA9IG5ldyBZLkRvYygpXG5cbiAgICBzaG93Tm90aWNlKFwiVHJ5aW5nIHRvIGluaXRpYXRlIHN5bmMuLi5cIilcblxuICAgIGNvbnN0IGRvYyA9IG5ldyBTaGFyZWREb2N1bWVudCh7XG4gICAgICBpZCxcbiAgICAgIHlEb2NcbiAgICB9LCBwbHVnaW4pXG5cbiAgICAvLyB3YWl0IGZvciBmaXJzdCB1cGRhdGUgdG8gbWFrZSBzdXJlIGl0IHdvcmtzIGFuZCB0byBnZXQgdGhlIGZpbGVuYW1lXG5cbiAgICBhd2FpdCBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZSkgPT4ge1xuICAgICAgZG9jLnN0YXJ0V2ViUlRDU3luYygpXG4gICAgICBpZiAoaXNQZXJtYW5lbnQpIHtcbiAgICAgICAgZG9jLnN5bmNXaXRoU2VydmVyKClcbiAgICAgIH1cbiAgICAgIHlEb2Mub25jZShcInVwZGF0ZVwiLCAoKSA9PiB7XG4gICAgICAgIHJlc29sdmUoKVxuICAgICAgfSlcbiAgICB9KVxuXG4gICAgY29uc3QgZG9jRmlsZW5hbWUgPSBkb2MueURvYy5nZXRUZXh0KFwib3JpZ2luYWxGaWxlbmFtZVwiKS50b1N0cmluZygpXG4gICAgbGV0IGluaXRpYWxGaWxlTmFtZSA9IGBfcGVlcmRyYWZ0X3Nlc3Npb25fJHtpZH1fJHtnZW5lcmF0ZVJhbmRvbVN0cmluZygpfS5tZGBcbiAgICBpZiAoZG9jRmlsZW5hbWUgIT0gJycpIHtcbiAgICAgIGNvbnN0IGZpbGVFeGlzdHMgPSBwbHVnaW4uYXBwLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChub3JtYWxpemVQYXRoKGRvY0ZpbGVuYW1lKSlcbiAgICAgIGlmICghZmlsZUV4aXN0cykge1xuICAgICAgICBpbml0aWFsRmlsZU5hbWUgPSBkb2NGaWxlbmFtZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5pdGlhbEZpbGVOYW1lID0gYF9wZWVyZHJhZnRfJHtnZW5lcmF0ZVJhbmRvbVN0cmluZygpfV8ke2RvY0ZpbGVuYW1lfWBcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBwYXJlbnQgPSBwbHVnaW4uc2V0dGluZ3Mucm9vdCB8fCBwbHVnaW4uYXBwLmZpbGVNYW5hZ2VyLmdldE5ld0ZpbGVQYXJlbnQoJycsIGluaXRpYWxGaWxlTmFtZSkucGF0aFxuICAgIGNvbnN0IGZpbGVQYXRoID0gcGF0aC5qb2luKHBhcmVudCwgaW5pdGlhbEZpbGVOYW1lKVxuICAgIGNvbnN0IGZvbGRlciA9IGF3YWl0IFNoYXJlZEZvbGRlci5nZXRPckNyZWF0ZVBhdGgocGF0aC5kaXJuYW1lKGZpbGVQYXRoKSwgcGx1Z2luKVxuICAgIGNvbnN0IGZpbGUgPSBhd2FpdCBwbHVnaW4uYXBwLnZhdWx0LmNyZWF0ZShmaWxlUGF0aCwgZG9jLmdldFZhbHVlKCkpXG4gICAgYWRkSXNTaGFyZWRDbGFzcyhmaWxlLnBhdGgsIHBsdWdpbilcbiAgICBkb2MuX2ZpbGUgPSBmaWxlXG4gICAgZG9jLl9wYXRoID0gZmlsZS5wYXRoXG5cbiAgICBpZiAoaXNQZXJtYW5lbnQpIHtcbiAgICAgIGRvYy5faXNQZXJtYW5lbnQgPSB0cnVlXG4gICAgICBhd2FpdCBhZGQoZG9jLCBwbHVnaW4pXG4gICAgICBhd2FpdCBkb2Muc3RhcnRJbmRleGVkREJTeW5jKClcbiAgICAgIHBsdWdpbi5hY3RpdmVTdHJlYW1DbGllbnQuYWRkKFtkb2Muc2hhcmVJZF0pXG4gICAgfVxuXG4gICAgY29uc3QgbGVhZiA9IGF3YWl0IG9wZW5GaWxlSW5OZXdUYWIoZmlsZSwgcGx1Z2luLmFwcC53b3Jrc3BhY2UpXG4gICAgZG9jLmFkZFN0YXR1c0JhckVudHJ5KClcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgZG9jLmFkZEV4dGVuc2lvblRvTGVhZihsZWFmLmlkKVxuICAgIHBpbkxlYWYobGVhZilcbiAgICBzaG93Tm90aWNlKFwiSm9pbmVkIFNlc3Npb24gaW4gXCIgKyBkb2MucGF0aCArIFwiLlwiKVxuICAgIHJldHVybiBkb2NcblxuICB9XG5cbiAgc3RhdGljIGFzeW5jIGZyb21JZEFuZFBhdGgoaWQ6IHN0cmluZywgbG9jYXRpb246IHN0cmluZywgcGx1Z2luOiBQZWVyRHJhZnRQbHVnaW4pIHtcbiAgICBjb25zdCBub3JtYWxpemVkUGF0aCA9IG5vcm1hbGl6ZVBhdGgobG9jYXRpb24pXG4gICAgY29uc3QgZXhpc3RpbmdEb2MgPSBTaGFyZWREb2N1bWVudC5maW5kQnlJZChpZClcbiAgICBpZiAoZXhpc3RpbmdEb2MpIHtcbiAgICAgIHNob3dOb3RpY2UoXCJUaGlzIHNoYXJlIGlzIGFscmVhZHkgYWN0aXZlOiBcIiArIGV4aXN0aW5nRG9jLnBhdGgpXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgYXdhaXQgU2hhcmVkRm9sZGVyLmdldE9yQ3JlYXRlUGF0aChwYXRoLmRpcm5hbWUobm9ybWFsaXplZFBhdGgpLCBwbHVnaW4pXG4gICAgc2hvd05vdGljZShcIkNyZWF0aW5nIG5ldyBzeW5jZWQgZmlsZSBcIiArIG5vcm1hbGl6ZWRQYXRoKVxuICAgIGNvbnN0IHlkb2MgPSBhd2FpdCBwbHVnaW4uc2VydmVyU3luYy5yZXF1ZXN0RG9jdW1lbnQoaWQpXG4gICAgY29uc3QgZG9jID0gbmV3IFNoYXJlZERvY3VtZW50KHtcbiAgICAgIGlkLCB5RG9jOiB5ZG9jXG4gICAgfSwgcGx1Z2luKVxuICAgIGRvYy5fcGF0aCA9IG5vcm1hbGl6ZWRQYXRoXG5cbiAgICBjb25zdCBmaWxlID0gYXdhaXQgcGx1Z2luLmFwcC52YXVsdC5jcmVhdGUobm9ybWFsaXplZFBhdGgsIHlkb2MuZ2V0VGV4dChcImNvbnRlbnRcIikudG9TdHJpbmcoKSlcbiAgICBkb2MuX2ZpbGUgPSBmaWxlXG5cbiAgICBkb2Muc3luY1dpdGhTZXJ2ZXIoKVxuICAgIGF3YWl0IGRvYy5zZXRQZXJtYW5lbnQoKVxuICAgIGF3YWl0IGRvYy5zdGFydEluZGV4ZWREQlN5bmMoKVxuICAgIGFkZElzU2hhcmVkQ2xhc3MoZG9jLnBhdGgsIHBsdWdpbilcbiAgfVxuXG5cbiAgc3RhdGljIGFzeW5jIGZyb21URmlsZShmaWxlOiBURmlsZSwgb3B0czogeyBwZXJtYW5lbnQ/OiBib29sZWFuIH0sIHBsdWdpbjogUGVlckRyYWZ0UGx1Z2luKSB7XG4gICAgaWYgKCFbJ21kJywgJ01EJ10uY29udGFpbnMoZmlsZS5leHRlbnNpb24pKSByZXR1cm5cbiAgICBjb25zdCBleGlzdGluZyA9IFNoYXJlZERvY3VtZW50LmZpbmRCeVBhdGgoZmlsZS5wYXRoKVxuICAgIGlmIChleGlzdGluZykgcmV0dXJuIGV4aXN0aW5nXG5cbiAgICBjb25zdCBkb2MgPSBuZXcgU2hhcmVkRG9jdW1lbnQoeyBwYXRoOiBmaWxlLnBhdGggfSwgcGx1Z2luKVxuICAgIGNvbnN0IGxlYWZJZHMgPSBnZXRMZWFmSWRzQnlQYXRoKGZpbGUucGF0aCwgcGx1Z2luLnB3cylcblxuICAgIGlmIChsZWFmSWRzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGNvbnRlbnQgPSAocGx1Z2luLmFwcC53b3Jrc3BhY2UuZ2V0TGVhZkJ5SWQobGVhZklkc1swXSkudmlldyBhcyBNYXJrZG93blZpZXcpLmVkaXRvci5nZXRWYWx1ZSgpXG4gICAgICBkb2MuZ2V0Q29udGVudEZyYWdtZW50KCkuaW5zZXJ0KDAsIGNvbnRlbnQpXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGNvbnRlbnQgPSBhd2FpdCBwbHVnaW4uYXBwLnZhdWx0LnJlYWQoZmlsZSlcbiAgICAgIGRvYy5nZXRDb250ZW50RnJhZ21lbnQoKS5pbnNlcnQoMCwgY29udGVudClcbiAgICB9XG5cbiAgICBkb2MueURvYy5nZXRUZXh0KFwib3JpZ2luYWxGaWxlbmFtZVwiKS5pbnNlcnQoMCwgZmlsZS5uYW1lKVxuXG4gICAgaWYgKG9wdHMucGVybWFuZW50KSB7XG4gICAgICBhd2FpdCBkb2MuaW5pdFNlcnZlcllEb2MoKVxuICAgICAgYXdhaXQgZG9jLnNldFBlcm1hbmVudCgpXG4gICAgICAvLyBkb2Muc3RhcnRXZWJTb2NrZXRTeW5jKClcbiAgICAgIGRvYy5zdGFydEluZGV4ZWREQlN5bmMoKVxuICAgIH0gZWxzZSB7XG4gICAgICBkb2MuX3NoYXJlSWQgPSBjcmVhdGVSYW5kb21JZCgpXG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBpZCBvZiBsZWFmSWRzKSB7XG4gICAgICBkb2MuYWRkRXh0ZW5zaW9uVG9MZWFmKGlkKVxuICAgIH1cblxuICAgIHNob3dOb3RpY2UoYEluaXRpdGlhbGl6ZWQgc2hhcmUgZm9yICR7ZmlsZS5wYXRofWApXG4gICAgcmV0dXJuIGRvY1xuICB9XG5cbiAgc3RhdGljIGZpbmRCeVBhdGgocGF0aDogc3RyaW5nKSB7XG4gICAgcmV0dXJuIHN1cGVyLmZpbmRCeVBhdGgocGF0aCkgYXMgU2hhcmVkRG9jdW1lbnQgfCB1bmRlZmluZWRcbiAgfVxuXG4gIHN0YXRpYyBmaW5kQnlJZChpZDogc3RyaW5nKSB7XG4gICAgcmV0dXJuIHN1cGVyLmZpbmRCeUlkKGlkKSBhcyBTaGFyZWREb2N1bWVudCB8IHVuZGVmaW5lZFxuICB9XG5cbiAgc3RhdGljIGdldEFsbCgpIHtcbiAgICByZXR1cm4gc3VwZXIuZ2V0QWxsKCkgYXMgQXJyYXk8U2hhcmVkRG9jdW1lbnQ+XG4gIH1cblxuICBwcml2YXRlIGNvbnN0cnVjdG9yKG9wdHM6IHtcbiAgICBwYXRoPzogc3RyaW5nLFxuICAgIGlkPzogc3RyaW5nLFxuICAgIHlEb2M/OiBZLkRvY1xuICB9LCBwbHVnaW46IFBlZXJEcmFmdFBsdWdpbikge1xuICAgIHN1cGVyKHBsdWdpbilcbiAgICBpZiAob3B0cy5wYXRoKSB7XG4gICAgICB0aGlzLl9wYXRoID0gbm9ybWFsaXplUGF0aChvcHRzLnBhdGgpXG4gICAgICBjb25zdCBmaWxlID0gdGhpcy5wbHVnaW4uYXBwLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChub3JtYWxpemVQYXRoKG9wdHMucGF0aCkpXG4gICAgICBpZiAoKGZpbGUgaW5zdGFuY2VvZiBURmlsZSkpIHtcbiAgICAgICAgdGhpcy5fZmlsZSA9IGZpbGVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNob3dOb3RpY2UoXCJFUlJPUiBjcmVhdGluZyBzaGFyZWREb2NcIilcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9wdHMuaWQpIHtcbiAgICAgIHRoaXMuX3NoYXJlSWQgPSBvcHRzLmlkXG4gICAgfVxuXG5cbiAgICB0aGlzLnlEb2MgPSBvcHRzLnlEb2MgPz8gbmV3IFkuRG9jKClcbiAgICB0aGlzLnlEb2Mub24oXCJ1cGRhdGVcIiwgKHVwZGF0ZTogVWludDhBcnJheSwgb3JpZ2luOiBhbnksIHlEb2M6IFkuRG9jLCB0cjogWS5UcmFuc2FjdGlvbikgPT4ge1xuICAgICAgaWYgKHRyLmxvY2FsICYmIHRoaXMuaXNQZXJtYW5lbnQpIHtcbiAgICAgICAgcGx1Z2luLnNlcnZlclN5bmMuc2VuZFVwZGF0ZSh0aGlzLCB1cGRhdGUpXG4gICAgICB9XG4gICAgfSlcblxuICAgIFNoYXJlZERvY3VtZW50Ll9zaGFyZWRFbnRpdGVzLnB1c2godGhpcylcbiAgICB0aGlzLl9leHRlbnNpb25zID0gbmV3IFBlZXJkcmFmdFJlY29yZDxDb21wYXJ0bWVudD4oKVxuICAgIHRoaXMuX2V4dGVuc2lvbnMub24oXCJkZWxldGVcIiwgKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuX2V4dGVuc2lvbnMuc2l6ZSA9PT0gMCAmJiB0aGlzLl93ZWJSVENQcm92aWRlcikge1xuICAgICAgICB0aGlzLl93ZWJSVENQcm92aWRlci5hd2FyZW5lc3Muc2V0TG9jYWxTdGF0ZSh7fSlcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgdGhpcy5nZXRDb250ZW50RnJhZ21lbnQoKS5vYnNlcnZlKGFzeW5jICgpID0+IHtcbiAgICAgIGlmICh0aGlzLl9maWxlICYmIHRoaXMuX2V4dGVuc2lvbnMuc2l6ZSA9PT0gMCkge1xuICAgICAgICBkZWJvdW5jZSgoKSA9PiB7XG4gICAgICAgICAgdGhpcy5tdXRleC5ydW5FeGNsdXNpdmUoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeURvY0NvbnRlbnQgPSB0aGlzLmdldFZhbHVlKClcbiAgICAgICAgICAgIGNvbnN0IGZpbGVDb250ZW50ID0gYXdhaXQgdGhpcy5wbHVnaW4uYXBwLnZhdWx0LnJlYWQodGhpcy5fZmlsZSlcbiAgICAgICAgICAgIGlmICh5RG9jQ29udGVudCAhPSBmaWxlQ29udGVudCkge1xuICAgICAgICAgICAgICB0aGlzLmxhc3RVcGRhdGVUcmlnZ2VyZWRCeURvY0NoYW5nZSA9IG5ldyBEYXRlKCkudmFsdWVPZigpXG4gICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLmFwcC52YXVsdC5tb2RpZnkodGhpcy5fZmlsZSwgeURvY0NvbnRlbnQsIHtcbiAgICAgICAgICAgICAgICBtdGltZTogdGhpcy5sYXN0VXBkYXRlVHJpZ2dlcmVkQnlEb2NDaGFuZ2VcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICB9LCAxMDAwLCB0cnVlKSgpXG4gICAgICB9XG4gICAgfSlcblxuICAgIHRoaXMucGx1Z2luLnJlZ2lzdGVyRXZlbnQodGhpcy5wbHVnaW4uYXBwLnZhdWx0Lm9uKFwibW9kaWZ5XCIsIGFzeW5jIChmaWxlKSA9PiB7XG4gICAgICAvLyBvbmx5IHJlYWN0IHRvIGNoYW5nZXMgb2YgdGhpcyBmaWxlLCBhbmQgb25seSBpZiBpdCBkaWRuJ3QgaGFwcGVuIHdpdGhpbiB0aGUgZWRpdG9yLlxuICAgICAgLy8gVGhlIGVkaXRvciBleHRlbnNpb24gdGFrZXMgY2FyZSBvZiB1cGRhdGVzIGluIHRoYXQgY2FzZS5cbiAgICAgIGlmICh0aGlzLmZpbGUgPT09IGZpbGUgJiYgdGhpcy5fZXh0ZW5zaW9ucy5zaXplID09PSAwICYmIHRoaXMuZmlsZS5zdGF0Lm10aW1lICE9IHRoaXMubGFzdFVwZGF0ZVRyaWdnZXJlZEJ5RG9jQ2hhbmdlKSB7XG4gICAgICAgIC8vIGNoZWNrIGlmIGRvY3VtZW50IGFuZCBjb250ZW50IGFjdHVhbGx5IGFyZSBvdXQgb2Ygc3luY1xuICAgICAgICB0aGlzLm11dGV4LnJ1bkV4Y2x1c2l2ZShhc3luYyAoKSA9PiB7XG4gICAgICAgICAgY29uc3QgeURvY0NvbnRlbnQgPSB0aGlzLmdldFZhbHVlKClcbiAgICAgICAgICBjb25zdCBmaWxlQ29udGVudCA9IGF3YWl0IHRoaXMucGx1Z2luLmFwcC52YXVsdC5yZWFkKHRoaXMuX2ZpbGUpXG4gICAgICAgICAgaWYgKHlEb2NDb250ZW50ICE9IGZpbGVDb250ZW50KSB7XG4gICAgICAgICAgICBjb25zdCBkaWZmcyA9IGRpZmYoeURvY0NvbnRlbnQsIGZpbGVDb250ZW50KVxuICAgICAgICAgICAgZGlmZkNsZWFudXBFZmZpY2llbmN5KGRpZmZzKVxuICAgICAgICAgICAgY29uc3QgY29udGVudCA9IHRoaXMuZ2V0Q29udGVudEZyYWdtZW50KClcbiAgICAgICAgICAgIGxldCBwb3MgPSAwXG4gICAgICAgICAgICB0aGlzLnlEb2MudHJhbnNhY3QoKCkgPT4ge1xuICAgICAgICAgICAgICBmb3IgKGNvbnN0IGRpZmYgb2YgZGlmZnMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0ZXh0ID0gZGlmZlsxXSBhcyBzdHJpbmdcbiAgICAgICAgICAgICAgICBjb25zdCBsZW5ndGggPSB0ZXh0Lmxlbmd0aFxuICAgICAgICAgICAgICAgIHN3aXRjaCAoZGlmZlswXSkge1xuICAgICAgICAgICAgICAgICAgLy8ga2VlcFxuICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgcG9zICs9IGxlbmd0aFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlXG4gICAgICAgICAgICAgICAgICBjYXNlIC0xOlxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgY29udGVudC5kZWxldGUocG9zLCBsZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAvLyBhZGRcbiAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQuaW5zZXJ0KHBvcywgdGV4dClcbiAgICAgICAgICAgICAgICAgICAgICBwb3MgKz0gbGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9KSlcblxuICAgIGFkZElzU2hhcmVkQ2xhc3ModGhpcy5wYXRoLCB0aGlzLnBsdWdpbilcbiAgfVxuXG4gIGdldCBmaWxlKCkge1xuICAgIHJldHVybiB0aGlzLl9maWxlXG4gIH1cblxuICBjYWxjdWxhdGVIYXNoKCkge1xuICAgIGNvbnN0IHRleHQgPSB0aGlzLmdldENvbnRlbnRGcmFnbWVudCgpLnRvU3RyaW5nKClcbiAgICByZXR1cm4gY2FsY3VsYXRlSGFzaCh0ZXh0KVxuICB9XG5cbiAgc3RhcnRXZWJSVENTeW5jKCkge1xuICAgIHJldHVybiBzdXBlci5zdGFydFdlYlJUQ1N5bmMoKHByb3ZpZGVyKSA9PiB7XG5cbiAgICAgIHByb3ZpZGVyLmF3YXJlbmVzcy5zZXRMb2NhbFN0YXRlRmllbGQoJ3VzZXInLCB7XG4gICAgICAgIG5hbWU6IHRoaXMucGx1Z2luLnNldHRpbmdzLm5hbWUsXG4gICAgICAgIGNvbG9yOiBTaGFyZWREb2N1bWVudC5fdXNlckNvbG9yLmRhcmssXG4gICAgICAgIGNvbG9yTGlnaHQ6IFNoYXJlZERvY3VtZW50Ll91c2VyQ29sb3IubGlnaHRcbiAgICAgIH0pXG5cblxuICAgICAgcHJvdmlkZXIuYXdhcmVuZXNzLm9uKFwidXBkYXRlXCIsIGFzeW5jIChtc2c6IHsgYWRkZWQ6IEFycmF5PG51bWJlcj4sIHJlbW92ZWQ6IEFycmF5PG51bWJlcj4gfSkgPT4ge1xuICAgICAgICBjb25zdCByZW1vdmVkID0gbXNnLnJlbW92ZWQgPz8gW107XG4gICAgICAgIGlmIChyZW1vdmVkICYmIHJlbW92ZWQubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGNvbnN0IHJlbW92ZWRTdHJpbmdzID0gcmVtb3ZlZC5tYXAoKGlkKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gaWQudG9GaXhlZCgwKTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNvbnN0IG93bmVyID0gdGhpcy5nZXRPd25lckZyYWdtZW50KCkudG9TdHJpbmcoKVxuICAgICAgICAgIGlmIChvd25lciAhPSBwcm92aWRlci5hd2FyZW5lc3MuY2xpZW50SUQudG9TdHJpbmcoKSkge1xuICAgICAgICAgICAgaWYgKHJlbW92ZWRTdHJpbmdzLmluY2x1ZGVzKG93bmVyKSAmJiAhdGhpcy5pc1Blcm1hbmVudCkge1xuICAgICAgICAgICAgICBzaG93Tm90aWNlKFwiU2hhcmVkIHNlc3Npb24gZm9yIFwiICsgdGhpcy5wYXRoICsgXCIgc3RvcHBlZCBieSBvd25lclwiKVxuICAgICAgICAgICAgICBhd2FpdCB0aGlzLnVuc2hhcmUoKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG5cbiAgICAgICAgY29uc3QgYWRkZWQgPSBtc2cuYWRkZWQgPz8gW107XG4gICAgICAgIGlmIChhZGRlZCAmJiBhZGRlZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgY29uc3Qgc3RhdGVzID0gcHJvdmlkZXIuYXdhcmVuZXNzLmdldFN0YXRlcygpXG4gICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgYWRkZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHBlZXIgPSBzdGF0ZXMuZ2V0KGtleSlcbiAgICAgICAgICAgIGlmIChwZWVyICYmIHRoaXMucGF0aCAmJiBrZXkgIT0gdGhpcy5fd2ViUlRDUHJvdmlkZXI/LmF3YXJlbmVzcy5jbGllbnRJRCkge1xuICAgICAgICAgICAgICBzaG93Tm90aWNlKGAke3BlZXIudXNlcj8ubmFtZX0gaXMgd29ya2luZyBvbiAke3RoaXMucGF0aH1gLCAxMDAwMClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pXG5cblxuICAgICAgLypcbiAgICAgIGlmICghdGhpcy5fd2ViUlRDVGltZW91dCkge1xuXG4gICAgICAgIGNvbnN0IGhhbmRsZVRpbWVvdXQgPSAoKSA9PiB7XG4gICAgICAgICAgaWYgKHRoaXMuX2V4dGVuc2lvbnMuc2l6ZSA+IDAgfHwgZ2V0TGVhZklkc0J5UGF0aCh0aGlzLnBhdGgsIHRoaXMucGx1Z2luLnB3cykubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5fd2ViUlRDVGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KGhhbmRsZVRpbWVvdXQsIDYwMDAwKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnN0b3BXZWJSVENTeW5jKClcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl93ZWJSVENUaW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQoaGFuZGxlVGltZW91dCwgNjAwMDApXG5cbiAgICAgICAgcHJvdmlkZXIuZG9jLm9uKCd1cGRhdGUnLCBhc3luYyAodXBkYXRlOiBVaW50OEFycmF5LCBvcmlnaW46IGFueSwgZG9jOiBZLkRvYywgdHI6IFkuVHJhbnNhY3Rpb24pID0+IHtcbiAgICAgICAgICBpZiAodGhpcy5fd2ViUlRDVGltZW91dCAhPSBudWxsKSB7XG4gICAgICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMuX3dlYlJUQ1RpbWVvdXQpXG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX3dlYlJUQ1RpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dChoYW5kbGVUaW1lb3V0LCA2MDAwMClcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICAgICovXG5cbiAgICB9KVxuXG4gIH1cblxuICBhc3luYyBzZXROZXdGaWxlTG9jYXRpb24oZmlsZTogVEZpbGUpIHtcbiAgICBjb25zdCBvbGRQYXRoID0gdGhpcy5fcGF0aFxuICAgIHRoaXMuX2ZpbGUgPSBmaWxlXG4gICAgdGhpcy5fcGF0aCA9IG5vcm1hbGl6ZVBhdGgoZmlsZS5wYXRoKVxuICAgIGlmICh0aGlzLnN0YXR1c0JhckVudHJ5KSB7XG4gICAgICB0aGlzLnJlbW92ZVN0YXR1c1N0YXR1c0JhckVudHJ5KClcbiAgICAgIHRoaXMuYWRkU3RhdHVzQmFyRW50cnkoKVxuICAgIH1cbiAgICBhd2FpdCBtb3ZlRG9jKG9sZFBhdGgsIGZpbGUucGF0aCwgdGhpcy5wbHVnaW4pXG4gICAgcmVtb3ZlSXNTaGFyZWRDbGFzcyhvbGRQYXRoLCB0aGlzLnBsdWdpbilcbiAgICBhZGRJc1NoYXJlZENsYXNzKHRoaXMucGF0aCwgdGhpcy5wbHVnaW4pXG4gIH1cblxuICBhc3luYyBzZXRQZXJtYW5lbnQoKSB7XG4gICAgaWYgKCF0aGlzLl9pc1Blcm1hbmVudCkge1xuICAgICAgdGhpcy5faXNQZXJtYW5lbnQgPSB0cnVlXG4gICAgICBhd2FpdCBhZGQodGhpcywgdGhpcy5wbHVnaW4pXG4gICAgICB0aGlzLnBsdWdpbi5hY3RpdmVTdHJlYW1DbGllbnQuYWRkKFt0aGlzLnNoYXJlSWRdKVxuICAgIH1cbiAgfVxuXG4gIGdldCBpc1Blcm1hbmVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5faXNQZXJtYW5lbnRcbiAgfVxuXG4gIGdldFZhbHVlKCkge1xuICAgIHJldHVybiB0aGlzLmdldENvbnRlbnRGcmFnbWVudCgpLnRvU3RyaW5nKClcbiAgfVxuXG4gIGdldENvbnRlbnRGcmFnbWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy55RG9jLmdldFRleHQoXCJjb250ZW50XCIpXG4gIH1cblxuICBnZXRPd25lckZyYWdtZW50KCkge1xuICAgIHJldHVybiB0aGlzLnlEb2MuZ2V0VGV4dChcIm93bmVyXCIpXG4gIH1cblxuICBhc3luYyBzdGFydEluZGV4ZWREQlN5bmMoKSB7XG4gICAgaWYgKHRoaXMuX2luZGV4ZWREQlByb3ZpZGVyKSByZXR1cm4gdGhpcy5faW5kZXhlZERCUHJvdmlkZXJcbiAgICBjb25zdCBpZCA9IChnZXREb2NCeVBhdGgodGhpcy5wYXRoLCB0aGlzLnBsdWdpbikpPy5wZXJzaXN0ZW5jZUlkXG4gICAgaWYgKCFpZCkgcmV0dXJuXG4gICAgY29uc3QgcHJvdmlkZXIgPSBuZXcgSW5kZXhlZGRiUGVyc2lzdGVuY2UoU2hhcmVkRW50aXR5LkRCX1BFUlNJU1RFTkNFX1BSRUZJWCArIGlkLCB0aGlzLnlEb2MpXG4gICAgdGhpcy5faW5kZXhlZERCUHJvdmlkZXIgPSBwcm92aWRlclxuICAgIGlmICghcHJvdmlkZXIuc3luY2VkKSBhd2FpdCBwcm92aWRlci53aGVuU3luY2VkXG5cbiAgICByZXR1cm4gdGhpcy5faW5kZXhlZERCUHJvdmlkZXJcbiAgfVxuXG4gIGFkZEV4dGVuc2lvblRvTGVhZihsZWFmSWQ6IHN0cmluZykge1xuICAgIC8vIG9ubHkgbWFrZXMgc2Vuc2UgaWYgd2UgaGF2ZSBhIHdlYnJjdCBwcm92aWRlciB0byBzeW5jIHdpdGhcbiAgICBjb25zdCB3ZWJSVENQcm92aWRlciA9IHRoaXMuc3RhcnRXZWJSVENTeW5jKClcbiAgICBpZiAoIXdlYlJUQ1Byb3ZpZGVyKSByZXR1cm5cbiAgICAvLyBhbHJlYWR5IHRoZXJlXG4gICAgaWYgKHRoaXMuX2V4dGVuc2lvbnMuZ2V0KGxlYWZJZCkpIHJldHVyblxuICAgIC8vIG5lZWQgYSBwbGVhZlxuICAgIGNvbnN0IHBMZWFmID0gdGhpcy5wbHVnaW4ucHdzLmdldChsZWFmSWQpXG4gICAgaWYgKCFwTGVhZikgcmV0dXJuXG5cbiAgICAvLyBwYXRoIG5lZWRzIHRvIG1hdGNoXG5cbiAgICBpZiAocExlYWYucGF0aCAhPSB0aGlzLl9wYXRoKSByZXR1cm5cbiAgICBpZiAocExlYWYuaXNQcmV2aWV3KSB7XG4gICAgICBwTGVhZi5vbmNlKFwiY2hhbmdlSXNQcmV2aWV3XCIsICgpID0+IHtcbiAgICAgICAgdGhpcy5hZGRFeHRlbnNpb25Ub0xlYWYobGVhZklkKVxuICAgICAgfSlcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IGxlYWYgPSB0aGlzLnBsdWdpbi5hcHAud29ya3NwYWNlLmdldExlYWZCeUlkKGxlYWZJZClcbiAgICBpZiAoIWxlYWYpIHJldHVyblxuICAgIGNvbnN0IHZpZXcgPSBsZWFmLnZpZXcgYXMgTWFya2Rvd25WaWV3XG4gICAgY29uc3QgZWRpdG9yID0gdmlldy5lZGl0b3JcblxuICAgIGVkaXRvci5zZXRWYWx1ZSh0aGlzLmdldFZhbHVlKCkpXG5cbiAgICBjb25zdCB1bmRvTWFuYWdlciA9IG5ldyBZLlVuZG9NYW5hZ2VyKHRoaXMuZ2V0Q29udGVudEZyYWdtZW50KCkpXG5cbiAgICBjb25zdCBleHRlbnNpb24gPSB5Q29sbGFiKHRoaXMuZ2V0Q29udGVudEZyYWdtZW50KCksIHdlYlJUQ1Byb3ZpZGVyLmF3YXJlbmVzcywgeyB1bmRvTWFuYWdlciB9KVxuICAgIGNvbnN0IGNvbXBhcnRtZW50ID0gbmV3IENvbXBhcnRtZW50KClcblxuICAgIGNvbnN0IGVkaXRvclZpZXcgPSAoZWRpdG9yIGFzIGFueSkuY20gYXMgRWRpdG9yVmlldztcbiAgICBlZGl0b3JWaWV3LmRpc3BhdGNoKHtcbiAgICAgIGVmZmVjdHM6IFN0YXRlRWZmZWN0LmFwcGVuZENvbmZpZy5vZihjb21wYXJ0bWVudC5vZihleHRlbnNpb24pKVxuICAgIH0pXG5cbiAgICB0aGlzLl9leHRlbnNpb25zLnNldChsZWFmSWQsIGNvbXBhcnRtZW50KVxuXG4gICAgLy8gcmVtb3ZlIGlmIHN3aXRjaCB0byBwcmV2aWV3XG4gICAgcExlYWYub25jZShcImNoYW5nZUlzUHJldmlld1wiLCAoKSA9PiB7XG4gICAgICB0aGlzLnJlbW92ZUV4dGVuc2lvbkZyb21MZWFmKGxlYWZJZClcbiAgICAgIC8vIGFkZCBhZ2FpbiBpZiBzd2l0Y2hlZCBiYWNrXG4gICAgICBwTGVhZi5vbmNlKFwiY2hhbmdlSXNQcmV2aWV3XCIsICgpID0+IHtcbiAgICAgICAgdGhpcy5hZGRFeHRlbnNpb25Ub0xlYWYobGVhZklkKVxuICAgICAgfSlcbiAgICB9KVxuXG4gICAgcmV0dXJuIENvbXBhcnRtZW50XG4gIH1cblxuICByZW1vdmVFeHRlbnNpb25Gcm9tTGVhZihsZWFmSWQ6IHN0cmluZykge1xuICAgIGNvbnN0IGxlYWYgPSB0aGlzLnBsdWdpbi5hcHAud29ya3NwYWNlLmdldExlYWZCeUlkKGxlYWZJZClcbiAgICBpZiAobGVhZikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZWRpdG9yID0gKGxlYWYudmlldyBhcyBNYXJrZG93blZpZXcpLmVkaXRvclxuICAgICAgICBjb25zdCBlZGl0b3JWaWV3ID0gKGVkaXRvciBhcyBhbnkpLmNtIGFzIEVkaXRvclZpZXc7XG4gICAgICAgIGNvbnN0IGNvbXBhcnRtZW50ID0gdGhpcy5fZXh0ZW5zaW9ucy5nZXQobGVhZklkKVxuICAgICAgICBpZiAoY29tcGFydG1lbnQpIHtcbiAgICAgICAgICBlZGl0b3JWaWV3LmRpc3BhdGNoKHtcbiAgICAgICAgICAgIGVmZmVjdHM6IGNvbXBhcnRtZW50LnJlY29uZmlndXJlKFtdKVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHRoaXMucGx1Z2luLmxvZyhcImVkaXRvciBhbHJlYWR5IGdvbmVcIilcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fZXh0ZW5zaW9ucy5kZWxldGUobGVhZklkKVxuICB9XG5cbiAgYWRkU3RhdHVzQmFyRW50cnkoKSB7XG4gICAgaWYgKHRoaXMuc3RhdHVzQmFyRW50cnkpIHJldHVyblxuICAgIGNvbnN0IG1lbnUgPSBuZXcgTWVudSgpXG4gICAgbWVudS5hZGRJdGVtKChpdGVtKSA9PiB7XG4gICAgICBpdGVtLnNldFRpdGxlKFwiQ29weSBsaW5rXCIpXG4gICAgICBpdGVtLm9uQ2xpY2soKCkgPT4ge1xuICAgICAgICBuYXZpZ2F0b3IuY2xpcGJvYXJkLndyaXRlVGV4dCh0aGlzLnBsdWdpbi5zZXR0aW5ncy5iYXNlUGF0aCArIFwiL2NtL1wiICsgdGhpcy5zaGFyZUlkKVxuICAgICAgICBzaG93Tm90aWNlKFwiTGluayBjb3BpZWQgdG8gY2xpcGJvYXJkLlwiKVxuICAgICAgfSlcbiAgICB9KVxuXG4gICAgbWVudS5hZGRJdGVtKChpdGVtKSA9PiB7XG4gICAgICBpdGVtLnNldFRpdGxlKFwiU3RvcCBzaGFyZWQgc2Vzc2lvblwiKVxuICAgICAgaXRlbS5vbkNsaWNrKGFzeW5jICgpID0+IHtcbiAgICAgICAgYXdhaXQgdGhpcy51bnNoYXJlKClcbiAgICAgIH0pXG4gICAgfSlcblxuICAgIGNvbnN0IHN0YXR1cyA9IHRoaXMucGx1Z2luLmFkZFN0YXR1c0Jhckl0ZW0oKTtcbiAgICBzdGF0dXMuYWRkQ2xhc3MoJ21vZC1jbGlja2FibGUnKVxuICAgIHN0YXR1cy5jcmVhdGVFbChcInNwYW5cIiwgeyB0ZXh0OiBcIlNoYXJpbmcgJ1wiICsgdGhpcy5wYXRoICsgXCInXCIgfSlcbiAgICBzdGF0dXMub25DbGlja0V2ZW50KChldmVudCkgPT4ge1xuICAgICAgbWVudS5zaG93QXRNb3VzZUV2ZW50KGV2ZW50KTtcbiAgICB9KVxuICAgIHRoaXMuc3RhdHVzQmFyRW50cnkgPSBzdGF0dXNcbiAgfVxuXG4gIHJlbW92ZVN0YXR1c1N0YXR1c0JhckVudHJ5KCkge1xuICAgIGlmICghdGhpcy5zdGF0dXNCYXJFbnRyeSkgcmV0dXJuXG4gICAgdGhpcy5zdGF0dXNCYXJFbnRyeS5yZW1vdmUoKVxuICAgIHRoaXMuc3RhdHVzQmFyRW50cnkgPSB1bmRlZmluZWRcbiAgfVxuXG4gIGFzeW5jIHVuc2hhcmUoKSB7XG4gICAgY29uc3QgZGJFbnRyeSA9IGdldERvY0J5UGF0aCh0aGlzLnBhdGgsIHRoaXMucGx1Z2luKVxuICAgIGlmIChkYkVudHJ5KSB7XG4gICAgICByZW1vdmVEb2ModGhpcy5wYXRoLCB0aGlzLnBsdWdpbilcbiAgICB9XG4gICAgaWYgKHRoaXMuX2luZGV4ZWREQlByb3ZpZGVyKSB7XG4gICAgICBhd2FpdCB0aGlzLl9pbmRleGVkREJQcm92aWRlci5jbGVhckRhdGEoKVxuICAgIH1cbiAgICB0aGlzLmRlc3Ryb3koKVxuICAgIHJlbW92ZUlzU2hhcmVkQ2xhc3ModGhpcy5wYXRoLCB0aGlzLnBsdWdpbilcbiAgfVxuXG5cbiAgZGVzdHJveSgpIHtcbiAgICBpZiAoIXRoaXMuaXNQZXJtYW5lbnQpIHtcbiAgICAgIHNob3dOb3RpY2UoXCJTdG9wcGluZyBjb2xsYWJvcmF0aW9uIG9uIFwiICsgdGhpcy5wYXRoICsgXCIuXCIpXG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IG9mIHRoaXMuX2V4dGVuc2lvbnMua2V5cykge1xuICAgICAgdGhpcy5yZW1vdmVFeHRlbnNpb25Gcm9tTGVhZihrZXkpXG4gICAgfVxuICAgIHRoaXMuX2V4dGVuc2lvbnMuZGVzdHJveSgpXG4gICAgc3VwZXIuZGVzdHJveSgpXG4gICAgdGhpcy5yZW1vdmVTdGF0dXNTdGF0dXNCYXJFbnRyeSgpXG4gICAgU2hhcmVkRG9jdW1lbnQuX3NoYXJlZEVudGl0ZXMuc3BsaWNlKFNoYXJlZERvY3VtZW50Ll9zaGFyZWRFbnRpdGVzLmluZGV4T2YodGhpcyksIDEpXG4gIH1cbn0iLCAiLyogZXNsaW50LWVudiBicm93c2VyICovXG5cbi8qKlxuICogQmluYXJ5IGRhdGEgY29uc3RhbnRzLlxuICpcbiAqIEBtb2R1bGUgYmluYXJ5XG4gKi9cblxuLyoqXG4gKiBuLXRoIGJpdCBhY3RpdmF0ZWQuXG4gKlxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IEJJVDEgPSAxXG5leHBvcnQgY29uc3QgQklUMiA9IDJcbmV4cG9ydCBjb25zdCBCSVQzID0gNFxuZXhwb3J0IGNvbnN0IEJJVDQgPSA4XG5leHBvcnQgY29uc3QgQklUNSA9IDE2XG5leHBvcnQgY29uc3QgQklUNiA9IDMyXG5leHBvcnQgY29uc3QgQklUNyA9IDY0XG5leHBvcnQgY29uc3QgQklUOCA9IDEyOFxuZXhwb3J0IGNvbnN0IEJJVDkgPSAyNTZcbmV4cG9ydCBjb25zdCBCSVQxMCA9IDUxMlxuZXhwb3J0IGNvbnN0IEJJVDExID0gMTAyNFxuZXhwb3J0IGNvbnN0IEJJVDEyID0gMjA0OFxuZXhwb3J0IGNvbnN0IEJJVDEzID0gNDA5NlxuZXhwb3J0IGNvbnN0IEJJVDE0ID0gODE5MlxuZXhwb3J0IGNvbnN0IEJJVDE1ID0gMTYzODRcbmV4cG9ydCBjb25zdCBCSVQxNiA9IDMyNzY4XG5leHBvcnQgY29uc3QgQklUMTcgPSA2NTUzNlxuZXhwb3J0IGNvbnN0IEJJVDE4ID0gMSA8PCAxN1xuZXhwb3J0IGNvbnN0IEJJVDE5ID0gMSA8PCAxOFxuZXhwb3J0IGNvbnN0IEJJVDIwID0gMSA8PCAxOVxuZXhwb3J0IGNvbnN0IEJJVDIxID0gMSA8PCAyMFxuZXhwb3J0IGNvbnN0IEJJVDIyID0gMSA8PCAyMVxuZXhwb3J0IGNvbnN0IEJJVDIzID0gMSA8PCAyMlxuZXhwb3J0IGNvbnN0IEJJVDI0ID0gMSA8PCAyM1xuZXhwb3J0IGNvbnN0IEJJVDI1ID0gMSA8PCAyNFxuZXhwb3J0IGNvbnN0IEJJVDI2ID0gMSA8PCAyNVxuZXhwb3J0IGNvbnN0IEJJVDI3ID0gMSA8PCAyNlxuZXhwb3J0IGNvbnN0IEJJVDI4ID0gMSA8PCAyN1xuZXhwb3J0IGNvbnN0IEJJVDI5ID0gMSA8PCAyOFxuZXhwb3J0IGNvbnN0IEJJVDMwID0gMSA8PCAyOVxuZXhwb3J0IGNvbnN0IEJJVDMxID0gMSA8PCAzMFxuZXhwb3J0IGNvbnN0IEJJVDMyID0gMSA8PCAzMVxuXG4vKipcbiAqIEZpcnN0IG4gYml0cyBhY3RpdmF0ZWQuXG4gKlxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IEJJVFMwID0gMFxuZXhwb3J0IGNvbnN0IEJJVFMxID0gMVxuZXhwb3J0IGNvbnN0IEJJVFMyID0gM1xuZXhwb3J0IGNvbnN0IEJJVFMzID0gN1xuZXhwb3J0IGNvbnN0IEJJVFM0ID0gMTVcbmV4cG9ydCBjb25zdCBCSVRTNSA9IDMxXG5leHBvcnQgY29uc3QgQklUUzYgPSA2M1xuZXhwb3J0IGNvbnN0IEJJVFM3ID0gMTI3XG5leHBvcnQgY29uc3QgQklUUzggPSAyNTVcbmV4cG9ydCBjb25zdCBCSVRTOSA9IDUxMVxuZXhwb3J0IGNvbnN0IEJJVFMxMCA9IDEwMjNcbmV4cG9ydCBjb25zdCBCSVRTMTEgPSAyMDQ3XG5leHBvcnQgY29uc3QgQklUUzEyID0gNDA5NVxuZXhwb3J0IGNvbnN0IEJJVFMxMyA9IDgxOTFcbmV4cG9ydCBjb25zdCBCSVRTMTQgPSAxNjM4M1xuZXhwb3J0IGNvbnN0IEJJVFMxNSA9IDMyNzY3XG5leHBvcnQgY29uc3QgQklUUzE2ID0gNjU1MzVcbmV4cG9ydCBjb25zdCBCSVRTMTcgPSBCSVQxOCAtIDFcbmV4cG9ydCBjb25zdCBCSVRTMTggPSBCSVQxOSAtIDFcbmV4cG9ydCBjb25zdCBCSVRTMTkgPSBCSVQyMCAtIDFcbmV4cG9ydCBjb25zdCBCSVRTMjAgPSBCSVQyMSAtIDFcbmV4cG9ydCBjb25zdCBCSVRTMjEgPSBCSVQyMiAtIDFcbmV4cG9ydCBjb25zdCBCSVRTMjIgPSBCSVQyMyAtIDFcbmV4cG9ydCBjb25zdCBCSVRTMjMgPSBCSVQyNCAtIDFcbmV4cG9ydCBjb25zdCBCSVRTMjQgPSBCSVQyNSAtIDFcbmV4cG9ydCBjb25zdCBCSVRTMjUgPSBCSVQyNiAtIDFcbmV4cG9ydCBjb25zdCBCSVRTMjYgPSBCSVQyNyAtIDFcbmV4cG9ydCBjb25zdCBCSVRTMjcgPSBCSVQyOCAtIDFcbmV4cG9ydCBjb25zdCBCSVRTMjggPSBCSVQyOSAtIDFcbmV4cG9ydCBjb25zdCBCSVRTMjkgPSBCSVQzMCAtIDFcbmV4cG9ydCBjb25zdCBCSVRTMzAgPSBCSVQzMSAtIDFcbi8qKlxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IEJJVFMzMSA9IDB4N0ZGRkZGRkZcbi8qKlxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IEJJVFMzMiA9IDB4RkZGRkZGRkZcbiIsICIvKipcbiAqIFV0aWxpdHkgaGVscGVycyBmb3Igd29ya2luZyB3aXRoIG51bWJlcnMuXG4gKlxuICogQG1vZHVsZSBudW1iZXJcbiAqL1xuXG5pbXBvcnQgKiBhcyBtYXRoIGZyb20gJy4vbWF0aC5qcydcbmltcG9ydCAqIGFzIGJpbmFyeSBmcm9tICcuL2JpbmFyeS5qcydcblxuZXhwb3J0IGNvbnN0IE1BWF9TQUZFX0lOVEVHRVIgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUlxuZXhwb3J0IGNvbnN0IE1JTl9TQUZFX0lOVEVHRVIgPSBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUlxuXG5leHBvcnQgY29uc3QgTE9XRVNUX0lOVDMyID0gMSA8PCAzMVxuZXhwb3J0IGNvbnN0IEhJR0hFU1RfSU5UMzIgPSBiaW5hcnkuQklUUzMxXG5leHBvcnQgY29uc3QgSElHSEVTVF9VSU5UMzIgPSBiaW5hcnkuQklUUzMyXG5cbi8qIGM4IGlnbm9yZSBuZXh0ICovXG5leHBvcnQgY29uc3QgaXNJbnRlZ2VyID0gTnVtYmVyLmlzSW50ZWdlciB8fCAobnVtID0+IHR5cGVvZiBudW0gPT09ICdudW1iZXInICYmIGlzRmluaXRlKG51bSkgJiYgbWF0aC5mbG9vcihudW0pID09PSBudW0pXG5leHBvcnQgY29uc3QgaXNOYU4gPSBOdW1iZXIuaXNOYU5cbmV4cG9ydCBjb25zdCBwYXJzZUludCA9IE51bWJlci5wYXJzZUludFxuXG4vKipcbiAqIENvdW50IHRoZSBudW1iZXIgb2YgXCIxXCIgYml0cyBpbiBhbiB1bnNpZ25lZCAzMmJpdCBudW1iZXIuXG4gKlxuICogU3VwZXIgZnVuIGJpdGNvdW50IGFsZ29yaXRobSBieSBCcmlhbiBLZXJuaWdoYW4uXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IG5cbiAqL1xuZXhwb3J0IGNvbnN0IGNvdW50Qml0cyA9IG4gPT4ge1xuICBuICY9IGJpbmFyeS5CSVRTMzJcbiAgbGV0IGNvdW50ID0gMFxuICB3aGlsZSAobikge1xuICAgIG4gJj0gKG4gLSAxKVxuICAgIGNvdW50KytcbiAgfVxuICByZXR1cm4gY291bnRcbn1cbiIsICJpbXBvcnQgKiBhcyBhcnJheSBmcm9tICcuL2FycmF5LmpzJ1xuXG4vKipcbiAqIFV0aWxpdHkgbW9kdWxlIHRvIHdvcmsgd2l0aCBzdHJpbmdzLlxuICpcbiAqIEBtb2R1bGUgc3RyaW5nXG4gKi9cblxuZXhwb3J0IGNvbnN0IGZyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGVcbmV4cG9ydCBjb25zdCBmcm9tQ29kZVBvaW50ID0gU3RyaW5nLmZyb21Db2RlUG9pbnRcblxuLyoqXG4gKiBUaGUgbGFyZ2VzdCB1dGYxNiBjaGFyYWN0ZXIuXG4gKiBDb3JyZXNwb25kcyB0byBVaW50OEFycmF5KFsyNTUsIDI1NV0pIG9yIGNoYXJjb2Rlb2YoMngyXjgpXG4gKi9cbmV4cG9ydCBjb25zdCBNQVhfVVRGMTZfQ0hBUkFDVEVSID0gZnJvbUNoYXJDb2RlKDY1NTM1KVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBzXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmNvbnN0IHRvTG93ZXJDYXNlID0gcyA9PiBzLnRvTG93ZXJDYXNlKClcblxuY29uc3QgdHJpbUxlZnRSZWdleCA9IC9eXFxzKi9nXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHNcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGNvbnN0IHRyaW1MZWZ0ID0gcyA9PiBzLnJlcGxhY2UodHJpbUxlZnRSZWdleCwgJycpXG5cbmNvbnN0IGZyb21DYW1lbENhc2VSZWdleCA9IC8oW0EtWl0pL2dcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gc1xuICogQHBhcmFtIHtzdHJpbmd9IHNlcGFyYXRvclxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5leHBvcnQgY29uc3QgZnJvbUNhbWVsQ2FzZSA9IChzLCBzZXBhcmF0b3IpID0+IHRyaW1MZWZ0KHMucmVwbGFjZShmcm9tQ2FtZWxDYXNlUmVnZXgsIG1hdGNoID0+IGAke3NlcGFyYXRvcn0ke3RvTG93ZXJDYXNlKG1hdGNoKX1gKSlcblxuLyoqXG4gKiBDb21wdXRlIHRoZSB1dGY4Qnl0ZUxlbmd0aFxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5leHBvcnQgY29uc3QgdXRmOEJ5dGVMZW5ndGggPSBzdHIgPT4gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KHN0cikpLmxlbmd0aFxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9XG4gKi9cbmV4cG9ydCBjb25zdCBfZW5jb2RlVXRmOFBvbHlmaWxsID0gc3RyID0+IHtcbiAgY29uc3QgZW5jb2RlZFN0cmluZyA9IHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChzdHIpKVxuICBjb25zdCBsZW4gPSBlbmNvZGVkU3RyaW5nLmxlbmd0aFxuICBjb25zdCBidWYgPSBuZXcgVWludDhBcnJheShsZW4pXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBidWZbaV0gPSAvKiogQHR5cGUge251bWJlcn0gKi8gKGVuY29kZWRTdHJpbmcuY29kZVBvaW50QXQoaSkpXG4gIH1cbiAgcmV0dXJuIGJ1ZlxufVxuXG4vKiBjOCBpZ25vcmUgbmV4dCAqL1xuZXhwb3J0IGNvbnN0IHV0ZjhUZXh0RW5jb2RlciA9IC8qKiBAdHlwZSB7VGV4dEVuY29kZXJ9ICovICh0eXBlb2YgVGV4dEVuY29kZXIgIT09ICd1bmRlZmluZWQnID8gbmV3IFRleHRFbmNvZGVyKCkgOiBudWxsKVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9XG4gKi9cbmV4cG9ydCBjb25zdCBfZW5jb2RlVXRmOE5hdGl2ZSA9IHN0ciA9PiB1dGY4VGV4dEVuY29kZXIuZW5jb2RlKHN0cilcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtVaW50OEFycmF5fVxuICovXG4vKiBjOCBpZ25vcmUgbmV4dCAqL1xuZXhwb3J0IGNvbnN0IGVuY29kZVV0ZjggPSB1dGY4VGV4dEVuY29kZXIgPyBfZW5jb2RlVXRmOE5hdGl2ZSA6IF9lbmNvZGVVdGY4UG9seWZpbGxcblxuLyoqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZlxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5leHBvcnQgY29uc3QgX2RlY29kZVV0ZjhQb2x5ZmlsbCA9IGJ1ZiA9PiB7XG4gIGxldCByZW1haW5pbmdMZW4gPSBidWYubGVuZ3RoXG4gIGxldCBlbmNvZGVkU3RyaW5nID0gJydcbiAgbGV0IGJ1ZlBvcyA9IDBcbiAgd2hpbGUgKHJlbWFpbmluZ0xlbiA+IDApIHtcbiAgICBjb25zdCBuZXh0TGVuID0gcmVtYWluaW5nTGVuIDwgMTAwMDAgPyByZW1haW5pbmdMZW4gOiAxMDAwMFxuICAgIGNvbnN0IGJ5dGVzID0gYnVmLnN1YmFycmF5KGJ1ZlBvcywgYnVmUG9zICsgbmV4dExlbilcbiAgICBidWZQb3MgKz0gbmV4dExlblxuICAgIC8vIFN0YXJ0aW5nIHdpdGggRVM1LjEgd2UgY2FuIHN1cHBseSBhIGdlbmVyaWMgYXJyYXktbGlrZSBvYmplY3QgYXMgYXJndW1lbnRzXG4gICAgZW5jb2RlZFN0cmluZyArPSBTdHJpbmcuZnJvbUNvZGVQb2ludC5hcHBseShudWxsLCAvKiogQHR5cGUge2FueX0gKi8gKGJ5dGVzKSlcbiAgICByZW1haW5pbmdMZW4gLT0gbmV4dExlblxuICB9XG4gIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoZXNjYXBlKGVuY29kZWRTdHJpbmcpKVxufVxuXG4vKiBjOCBpZ25vcmUgbmV4dCAqL1xuZXhwb3J0IGxldCB1dGY4VGV4dERlY29kZXIgPSB0eXBlb2YgVGV4dERlY29kZXIgPT09ICd1bmRlZmluZWQnID8gbnVsbCA6IG5ldyBUZXh0RGVjb2RlcigndXRmLTgnLCB7IGZhdGFsOiB0cnVlLCBpZ25vcmVCT006IHRydWUgfSlcblxuLyogYzggaWdub3JlIHN0YXJ0ICovXG5pZiAodXRmOFRleHREZWNvZGVyICYmIHV0ZjhUZXh0RGVjb2Rlci5kZWNvZGUobmV3IFVpbnQ4QXJyYXkoKSkubGVuZ3RoID09PSAxKSB7XG4gIC8vIFNhZmFyaSBkb2Vzbid0IGhhbmRsZSBCT00gY29ycmVjdGx5LlxuICAvLyBUaGlzIGZpeGVzIGEgYnVnIGluIFNhZmFyaSAxMy4wLjUgd2hlcmUgaXQgcHJvZHVjZXMgYSBCT00gdGhlIGZpcnN0IHRpbWUgaXQgaXMgY2FsbGVkLlxuICAvLyB1dGY4VGV4dERlY29kZXIuZGVjb2RlKG5ldyBVaW50OEFycmF5KCkpLmxlbmd0aCA9PT0gMSBvbiB0aGUgZmlyc3QgY2FsbCBhbmRcbiAgLy8gdXRmOFRleHREZWNvZGVyLmRlY29kZShuZXcgVWludDhBcnJheSgpKS5sZW5ndGggPT09IDEgb24gdGhlIHNlY29uZCBjYWxsXG4gIC8vIEFub3RoZXIgaXNzdWUgaXMgdGhhdCBmcm9tIHRoZW4gb24gbm8gQk9NIGNoYXJzIGFyZSByZWNvZ25pemVkIGFueW1vcmVcbiAgLyogYzggaWdub3JlIG5leHQgKi9cbiAgdXRmOFRleHREZWNvZGVyID0gbnVsbFxufVxuLyogYzggaWdub3JlIHN0b3AgKi9cblxuLyoqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZlxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5leHBvcnQgY29uc3QgX2RlY29kZVV0ZjhOYXRpdmUgPSBidWYgPT4gLyoqIEB0eXBlIHtUZXh0RGVjb2Rlcn0gKi8gKHV0ZjhUZXh0RGVjb2RlcikuZGVjb2RlKGJ1ZilcblxuLyoqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZlxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG4vKiBjOCBpZ25vcmUgbmV4dCAqL1xuZXhwb3J0IGNvbnN0IGRlY29kZVV0ZjggPSB1dGY4VGV4dERlY29kZXIgPyBfZGVjb2RlVXRmOE5hdGl2ZSA6IF9kZWNvZGVVdGY4UG9seWZpbGxcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIFRoZSBpbml0aWFsIHN0cmluZ1xuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFN0YXJ0aW5nIHBvc2l0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gcmVtb3ZlIE51bWJlciBvZiBjaGFyYWN0ZXJzIHRvIHJlbW92ZVxuICogQHBhcmFtIHtzdHJpbmd9IGluc2VydCBOZXcgY29udGVudCB0byBpbnNlcnRcbiAqL1xuZXhwb3J0IGNvbnN0IHNwbGljZSA9IChzdHIsIGluZGV4LCByZW1vdmUsIGluc2VydCA9ICcnKSA9PiBzdHIuc2xpY2UoMCwgaW5kZXgpICsgaW5zZXJ0ICsgc3RyLnNsaWNlKGluZGV4ICsgcmVtb3ZlKVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBzb3VyY2VcbiAqIEBwYXJhbSB7bnVtYmVyfSBuXG4gKi9cbmV4cG9ydCBjb25zdCByZXBlYXQgPSAoc291cmNlLCBuKSA9PiBhcnJheS51bmZvbGQobiwgKCkgPT4gc291cmNlKS5qb2luKCcnKVxuIiwgIi8qKlxuICogRWZmaWNpZW50IHNjaGVtYS1sZXNzIGJpbmFyeSBlbmNvZGluZyB3aXRoIHN1cHBvcnQgZm9yIHZhcmlhYmxlIGxlbmd0aCBlbmNvZGluZy5cbiAqXG4gKiBVc2UgW2xpYjAvZW5jb2RpbmddIHdpdGggW2xpYjAvZGVjb2RpbmddLiBFdmVyeSBlbmNvZGluZyBmdW5jdGlvbiBoYXMgYSBjb3JyZXNwb25kaW5nIGRlY29kaW5nIGZ1bmN0aW9uLlxuICpcbiAqIEVuY29kZXMgbnVtYmVycyBpbiBsaXR0bGUtZW5kaWFuIG9yZGVyIChsZWFzdCB0byBtb3N0IHNpZ25pZmljYW50IGJ5dGUgb3JkZXIpXG4gKiBhbmQgaXMgY29tcGF0aWJsZSB3aXRoIEdvbGFuZydzIGJpbmFyeSBlbmNvZGluZyAoaHR0cHM6Ly9nb2xhbmcub3JnL3BrZy9lbmNvZGluZy9iaW5hcnkvKVxuICogd2hpY2ggaXMgYWxzbyB1c2VkIGluIFByb3RvY29sIEJ1ZmZlcnMuXG4gKlxuICogYGBganNcbiAqIC8vIGVuY29kaW5nIHN0ZXBcbiAqIGNvbnN0IGVuY29kZXIgPSBlbmNvZGluZy5jcmVhdGVFbmNvZGVyKClcbiAqIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyLCAyNTYpXG4gKiBlbmNvZGluZy53cml0ZVZhclN0cmluZyhlbmNvZGVyLCAnSGVsbG8gd29ybGQhJylcbiAqIGNvbnN0IGJ1ZiA9IGVuY29kaW5nLnRvVWludDhBcnJheShlbmNvZGVyKVxuICogYGBgXG4gKlxuICogYGBganNcbiAqIC8vIGRlY29kaW5nIHN0ZXBcbiAqIGNvbnN0IGRlY29kZXIgPSBkZWNvZGluZy5jcmVhdGVEZWNvZGVyKGJ1ZilcbiAqIGRlY29kaW5nLnJlYWRWYXJVaW50KGRlY29kZXIpIC8vID0+IDI1NlxuICogZGVjb2RpbmcucmVhZFZhclN0cmluZyhkZWNvZGVyKSAvLyA9PiAnSGVsbG8gd29ybGQhJ1xuICogZGVjb2RpbmcuaGFzQ29udGVudChkZWNvZGVyKSAvLyA9PiBmYWxzZSAtIGFsbCBkYXRhIGlzIHJlYWRcbiAqIGBgYFxuICpcbiAqIEBtb2R1bGUgZW5jb2RpbmdcbiAqL1xuXG5pbXBvcnQgKiBhcyBtYXRoIGZyb20gJy4vbWF0aC5qcydcbmltcG9ydCAqIGFzIG51bWJlciBmcm9tICcuL251bWJlci5qcydcbmltcG9ydCAqIGFzIGJpbmFyeSBmcm9tICcuL2JpbmFyeS5qcydcbmltcG9ydCAqIGFzIHN0cmluZyBmcm9tICcuL3N0cmluZy5qcydcbmltcG9ydCAqIGFzIGFycmF5IGZyb20gJy4vYXJyYXkuanMnXG5cbi8qKlxuICogQSBCaW5hcnlFbmNvZGVyIGhhbmRsZXMgdGhlIGVuY29kaW5nIHRvIGFuIFVpbnQ4QXJyYXkuXG4gKi9cbmV4cG9ydCBjbGFzcyBFbmNvZGVyIHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHRoaXMuY3BvcyA9IDBcbiAgICB0aGlzLmNidWYgPSBuZXcgVWludDhBcnJheSgxMDApXG4gICAgLyoqXG4gICAgICogQHR5cGUge0FycmF5PFVpbnQ4QXJyYXk+fVxuICAgICAqL1xuICAgIHRoaXMuYnVmcyA9IFtdXG4gIH1cbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEByZXR1cm4ge0VuY29kZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVFbmNvZGVyID0gKCkgPT4gbmV3IEVuY29kZXIoKVxuXG4vKipcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oRW5jb2Rlcik6dm9pZH0gZlxuICovXG5leHBvcnQgY29uc3QgZW5jb2RlID0gKGYpID0+IHtcbiAgY29uc3QgZW5jb2RlciA9IGNyZWF0ZUVuY29kZXIoKVxuICBmKGVuY29kZXIpXG4gIHJldHVybiB0b1VpbnQ4QXJyYXkoZW5jb2Rlcilcbn1cblxuLyoqXG4gKiBUaGUgY3VycmVudCBsZW5ndGggb2YgdGhlIGVuY29kZWQgZGF0YS5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RW5jb2Rlcn0gZW5jb2RlclxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5leHBvcnQgY29uc3QgbGVuZ3RoID0gZW5jb2RlciA9PiB7XG4gIGxldCBsZW4gPSBlbmNvZGVyLmNwb3NcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbmNvZGVyLmJ1ZnMubGVuZ3RoOyBpKyspIHtcbiAgICBsZW4gKz0gZW5jb2Rlci5idWZzW2ldLmxlbmd0aFxuICB9XG4gIHJldHVybiBsZW5cbn1cblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIGVuY29kZXIgaXMgZW1wdHkuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0VuY29kZXJ9IGVuY29kZXJcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBjb25zdCBoYXNDb250ZW50ID0gZW5jb2RlciA9PiBlbmNvZGVyLmNwb3MgPiAwIHx8IGVuY29kZXIuYnVmcy5sZW5ndGggPiAwXG5cbi8qKlxuICogVHJhbnNmb3JtIHRvIFVpbnQ4QXJyYXkuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0VuY29kZXJ9IGVuY29kZXJcbiAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9IFRoZSBjcmVhdGVkIEFycmF5QnVmZmVyLlxuICovXG5leHBvcnQgY29uc3QgdG9VaW50OEFycmF5ID0gZW5jb2RlciA9PiB7XG4gIGNvbnN0IHVpbnQ4YXJyID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKGVuY29kZXIpKVxuICBsZXQgY3VyUG9zID0gMFxuICBmb3IgKGxldCBpID0gMDsgaSA8IGVuY29kZXIuYnVmcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGQgPSBlbmNvZGVyLmJ1ZnNbaV1cbiAgICB1aW50OGFyci5zZXQoZCwgY3VyUG9zKVxuICAgIGN1clBvcyArPSBkLmxlbmd0aFxuICB9XG4gIHVpbnQ4YXJyLnNldChuZXcgVWludDhBcnJheShlbmNvZGVyLmNidWYuYnVmZmVyLCAwLCBlbmNvZGVyLmNwb3MpLCBjdXJQb3MpXG4gIHJldHVybiB1aW50OGFyclxufVxuXG4vKipcbiAqIFZlcmlmeSB0aGF0IGl0IGlzIHBvc3NpYmxlIHRvIHdyaXRlIGBsZW5gIGJ5dGVzIHd0aWhvdXQgY2hlY2tpbmcuIElmXG4gKiBuZWNlc3NhcnksIGEgbmV3IEJ1ZmZlciB3aXRoIHRoZSByZXF1aXJlZCBsZW5ndGggaXMgYXR0YWNoZWQuXG4gKlxuICogQHBhcmFtIHtFbmNvZGVyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge251bWJlcn0gbGVuXG4gKi9cbmV4cG9ydCBjb25zdCB2ZXJpZnlMZW4gPSAoZW5jb2RlciwgbGVuKSA9PiB7XG4gIGNvbnN0IGJ1ZmZlckxlbiA9IGVuY29kZXIuY2J1Zi5sZW5ndGhcbiAgaWYgKGJ1ZmZlckxlbiAtIGVuY29kZXIuY3BvcyA8IGxlbikge1xuICAgIGVuY29kZXIuYnVmcy5wdXNoKG5ldyBVaW50OEFycmF5KGVuY29kZXIuY2J1Zi5idWZmZXIsIDAsIGVuY29kZXIuY3BvcykpXG4gICAgZW5jb2Rlci5jYnVmID0gbmV3IFVpbnQ4QXJyYXkobWF0aC5tYXgoYnVmZmVyTGVuLCBsZW4pICogMilcbiAgICBlbmNvZGVyLmNwb3MgPSAwXG4gIH1cbn1cblxuLyoqXG4gKiBXcml0ZSBvbmUgYnl0ZSB0byB0aGUgZW5jb2Rlci5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RW5jb2Rlcn0gZW5jb2RlclxuICogQHBhcmFtIHtudW1iZXJ9IG51bSBUaGUgYnl0ZSB0aGF0IGlzIHRvIGJlIGVuY29kZWQuXG4gKi9cbmV4cG9ydCBjb25zdCB3cml0ZSA9IChlbmNvZGVyLCBudW0pID0+IHtcbiAgY29uc3QgYnVmZmVyTGVuID0gZW5jb2Rlci5jYnVmLmxlbmd0aFxuICBpZiAoZW5jb2Rlci5jcG9zID09PSBidWZmZXJMZW4pIHtcbiAgICBlbmNvZGVyLmJ1ZnMucHVzaChlbmNvZGVyLmNidWYpXG4gICAgZW5jb2Rlci5jYnVmID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyTGVuICogMilcbiAgICBlbmNvZGVyLmNwb3MgPSAwXG4gIH1cbiAgZW5jb2Rlci5jYnVmW2VuY29kZXIuY3BvcysrXSA9IG51bVxufVxuXG4vKipcbiAqIFdyaXRlIG9uZSBieXRlIGF0IGEgc3BlY2lmaWMgcG9zaXRpb24uXG4gKiBQb3NpdGlvbiBtdXN0IGFscmVhZHkgYmUgd3JpdHRlbiAoaS5lLiBlbmNvZGVyLmxlbmd0aCA+IHBvcylcbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RW5jb2Rlcn0gZW5jb2RlclxuICogQHBhcmFtIHtudW1iZXJ9IHBvcyBQb3NpdGlvbiB0byB3aGljaCB0byB3cml0ZSBkYXRhXG4gKiBAcGFyYW0ge251bWJlcn0gbnVtIFVuc2lnbmVkIDgtYml0IGludGVnZXJcbiAqL1xuZXhwb3J0IGNvbnN0IHNldCA9IChlbmNvZGVyLCBwb3MsIG51bSkgPT4ge1xuICBsZXQgYnVmZmVyID0gbnVsbFxuICAvLyBpdGVyYXRlIGFsbCBidWZmZXJzIGFuZCBhZGp1c3QgcG9zaXRpb25cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbmNvZGVyLmJ1ZnMubGVuZ3RoICYmIGJ1ZmZlciA9PT0gbnVsbDsgaSsrKSB7XG4gICAgY29uc3QgYiA9IGVuY29kZXIuYnVmc1tpXVxuICAgIGlmIChwb3MgPCBiLmxlbmd0aCkge1xuICAgICAgYnVmZmVyID0gYiAvLyBmb3VuZCBidWZmZXJcbiAgICB9IGVsc2Uge1xuICAgICAgcG9zIC09IGIubGVuZ3RoXG4gICAgfVxuICB9XG4gIGlmIChidWZmZXIgPT09IG51bGwpIHtcbiAgICAvLyB1c2UgY3VycmVudCBidWZmZXJcbiAgICBidWZmZXIgPSBlbmNvZGVyLmNidWZcbiAgfVxuICBidWZmZXJbcG9zXSA9IG51bVxufVxuXG4vKipcbiAqIFdyaXRlIG9uZSBieXRlIGFzIGFuIHVuc2lnbmVkIGludGVnZXIuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0VuY29kZXJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBudW0gVGhlIG51bWJlciB0aGF0IGlzIHRvIGJlIGVuY29kZWQuXG4gKi9cbmV4cG9ydCBjb25zdCB3cml0ZVVpbnQ4ID0gd3JpdGVcblxuLyoqXG4gKiBXcml0ZSBvbmUgYnl0ZSBhcyBhbiB1bnNpZ25lZCBJbnRlZ2VyIGF0IGEgc3BlY2lmaWMgbG9jYXRpb24uXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0VuY29kZXJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBwb3MgVGhlIGxvY2F0aW9uIHdoZXJlIHRoZSBkYXRhIHdpbGwgYmUgd3JpdHRlbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBudW0gVGhlIG51bWJlciB0aGF0IGlzIHRvIGJlIGVuY29kZWQuXG4gKi9cbmV4cG9ydCBjb25zdCBzZXRVaW50OCA9IHNldFxuXG4vKipcbiAqIFdyaXRlIHR3byBieXRlcyBhcyBhbiB1bnNpZ25lZCBpbnRlZ2VyLlxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtFbmNvZGVyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge251bWJlcn0gbnVtIFRoZSBudW1iZXIgdGhhdCBpcyB0byBiZSBlbmNvZGVkLlxuICovXG5leHBvcnQgY29uc3Qgd3JpdGVVaW50MTYgPSAoZW5jb2RlciwgbnVtKSA9PiB7XG4gIHdyaXRlKGVuY29kZXIsIG51bSAmIGJpbmFyeS5CSVRTOClcbiAgd3JpdGUoZW5jb2RlciwgKG51bSA+Pj4gOCkgJiBiaW5hcnkuQklUUzgpXG59XG4vKipcbiAqIFdyaXRlIHR3byBieXRlcyBhcyBhbiB1bnNpZ25lZCBpbnRlZ2VyIGF0IGEgc3BlY2lmaWMgbG9jYXRpb24uXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0VuY29kZXJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBwb3MgVGhlIGxvY2F0aW9uIHdoZXJlIHRoZSBkYXRhIHdpbGwgYmUgd3JpdHRlbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBudW0gVGhlIG51bWJlciB0aGF0IGlzIHRvIGJlIGVuY29kZWQuXG4gKi9cbmV4cG9ydCBjb25zdCBzZXRVaW50MTYgPSAoZW5jb2RlciwgcG9zLCBudW0pID0+IHtcbiAgc2V0KGVuY29kZXIsIHBvcywgbnVtICYgYmluYXJ5LkJJVFM4KVxuICBzZXQoZW5jb2RlciwgcG9zICsgMSwgKG51bSA+Pj4gOCkgJiBiaW5hcnkuQklUUzgpXG59XG5cbi8qKlxuICogV3JpdGUgdHdvIGJ5dGVzIGFzIGFuIHVuc2lnbmVkIGludGVnZXJcbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RW5jb2Rlcn0gZW5jb2RlclxuICogQHBhcmFtIHtudW1iZXJ9IG51bSBUaGUgbnVtYmVyIHRoYXQgaXMgdG8gYmUgZW5jb2RlZC5cbiAqL1xuZXhwb3J0IGNvbnN0IHdyaXRlVWludDMyID0gKGVuY29kZXIsIG51bSkgPT4ge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgIHdyaXRlKGVuY29kZXIsIG51bSAmIGJpbmFyeS5CSVRTOClcbiAgICBudW0gPj4+PSA4XG4gIH1cbn1cblxuLyoqXG4gKiBXcml0ZSB0d28gYnl0ZXMgYXMgYW4gdW5zaWduZWQgaW50ZWdlciBpbiBiaWcgZW5kaWFuIG9yZGVyLlxuICogKG1vc3Qgc2lnbmlmaWNhbnQgYnl0ZSBmaXJzdClcbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RW5jb2Rlcn0gZW5jb2RlclxuICogQHBhcmFtIHtudW1iZXJ9IG51bSBUaGUgbnVtYmVyIHRoYXQgaXMgdG8gYmUgZW5jb2RlZC5cbiAqL1xuZXhwb3J0IGNvbnN0IHdyaXRlVWludDMyQmlnRW5kaWFuID0gKGVuY29kZXIsIG51bSkgPT4ge1xuICBmb3IgKGxldCBpID0gMzsgaSA+PSAwOyBpLS0pIHtcbiAgICB3cml0ZShlbmNvZGVyLCAobnVtID4+PiAoOCAqIGkpKSAmIGJpbmFyeS5CSVRTOClcbiAgfVxufVxuXG4vKipcbiAqIFdyaXRlIHR3byBieXRlcyBhcyBhbiB1bnNpZ25lZCBpbnRlZ2VyIGF0IGEgc3BlY2lmaWMgbG9jYXRpb24uXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0VuY29kZXJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBwb3MgVGhlIGxvY2F0aW9uIHdoZXJlIHRoZSBkYXRhIHdpbGwgYmUgd3JpdHRlbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBudW0gVGhlIG51bWJlciB0aGF0IGlzIHRvIGJlIGVuY29kZWQuXG4gKi9cbmV4cG9ydCBjb25zdCBzZXRVaW50MzIgPSAoZW5jb2RlciwgcG9zLCBudW0pID0+IHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICBzZXQoZW5jb2RlciwgcG9zICsgaSwgbnVtICYgYmluYXJ5LkJJVFM4KVxuICAgIG51bSA+Pj49IDhcbiAgfVxufVxuXG4vKipcbiAqIFdyaXRlIGEgdmFyaWFibGUgbGVuZ3RoIHVuc2lnbmVkIGludGVnZXIuIE1heCBlbmNvZGFibGUgaW50ZWdlciBpcyAyXjUzLlxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtFbmNvZGVyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge251bWJlcn0gbnVtIFRoZSBudW1iZXIgdGhhdCBpcyB0byBiZSBlbmNvZGVkLlxuICovXG5leHBvcnQgY29uc3Qgd3JpdGVWYXJVaW50ID0gKGVuY29kZXIsIG51bSkgPT4ge1xuICB3aGlsZSAobnVtID4gYmluYXJ5LkJJVFM3KSB7XG4gICAgd3JpdGUoZW5jb2RlciwgYmluYXJ5LkJJVDggfCAoYmluYXJ5LkJJVFM3ICYgbnVtKSlcbiAgICBudW0gPSBtYXRoLmZsb29yKG51bSAvIDEyOCkgLy8gc2hpZnQgPj4+IDdcbiAgfVxuICB3cml0ZShlbmNvZGVyLCBiaW5hcnkuQklUUzcgJiBudW0pXG59XG5cbi8qKlxuICogV3JpdGUgYSB2YXJpYWJsZSBsZW5ndGggaW50ZWdlci5cbiAqXG4gKiBXZSB1c2UgdGhlIDd0aCBiaXQgaW5zdGVhZCBmb3Igc2lnbmFsaW5nIHRoYXQgdGhpcyBpcyBhIG5lZ2F0aXZlIG51bWJlci5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RW5jb2Rlcn0gZW5jb2RlclxuICogQHBhcmFtIHtudW1iZXJ9IG51bSBUaGUgbnVtYmVyIHRoYXQgaXMgdG8gYmUgZW5jb2RlZC5cbiAqL1xuZXhwb3J0IGNvbnN0IHdyaXRlVmFySW50ID0gKGVuY29kZXIsIG51bSkgPT4ge1xuICBjb25zdCBpc05lZ2F0aXZlID0gbWF0aC5pc05lZ2F0aXZlWmVybyhudW0pXG4gIGlmIChpc05lZ2F0aXZlKSB7XG4gICAgbnVtID0gLW51bVxuICB9XG4gIC8vICAgICAgICAgICAgIHwtIHdoZXRoZXIgdG8gY29udGludWUgcmVhZGluZyAgICAgICAgIHwtIHdoZXRoZXIgaXMgbmVnYXRpdmUgICAgIHwtIG51bWJlclxuICB3cml0ZShlbmNvZGVyLCAobnVtID4gYmluYXJ5LkJJVFM2ID8gYmluYXJ5LkJJVDggOiAwKSB8IChpc05lZ2F0aXZlID8gYmluYXJ5LkJJVDcgOiAwKSB8IChiaW5hcnkuQklUUzYgJiBudW0pKVxuICBudW0gPSBtYXRoLmZsb29yKG51bSAvIDY0KSAvLyBzaGlmdCA+Pj4gNlxuICAvLyBXZSBkb24ndCBuZWVkIHRvIGNvbnNpZGVyIHRoZSBjYXNlIG9mIG51bSA9PT0gMCBzbyB3ZSBjYW4gdXNlIGEgZGlmZmVyZW50XG4gIC8vIHBhdHRlcm4gaGVyZSB0aGFuIGFib3ZlLlxuICB3aGlsZSAobnVtID4gMCkge1xuICAgIHdyaXRlKGVuY29kZXIsIChudW0gPiBiaW5hcnkuQklUUzcgPyBiaW5hcnkuQklUOCA6IDApIHwgKGJpbmFyeS5CSVRTNyAmIG51bSkpXG4gICAgbnVtID0gbWF0aC5mbG9vcihudW0gLyAxMjgpIC8vIHNoaWZ0ID4+PiA3XG4gIH1cbn1cblxuLyoqXG4gKiBBIGNhY2hlIHRvIHN0b3JlIHN0cmluZ3MgdGVtcG9yYXJpbHlcbiAqL1xuY29uc3QgX3N0ckJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KDMwMDAwKVxuY29uc3QgX21heFN0ckJTaXplID0gX3N0ckJ1ZmZlci5sZW5ndGggLyAzXG5cbi8qKlxuICogV3JpdGUgYSB2YXJpYWJsZSBsZW5ndGggc3RyaW5nLlxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtFbmNvZGVyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBzdHJpbmcgdGhhdCBpcyB0byBiZSBlbmNvZGVkLlxuICovXG5leHBvcnQgY29uc3QgX3dyaXRlVmFyU3RyaW5nTmF0aXZlID0gKGVuY29kZXIsIHN0cikgPT4ge1xuICBpZiAoc3RyLmxlbmd0aCA8IF9tYXhTdHJCU2l6ZSkge1xuICAgIC8vIFdlIGNhbiBlbmNvZGUgdGhlIHN0cmluZyBpbnRvIHRoZSBleGlzdGluZyBidWZmZXJcbiAgICAvKiBjOCBpZ25vcmUgbmV4dCAqL1xuICAgIGNvbnN0IHdyaXR0ZW4gPSBzdHJpbmcudXRmOFRleHRFbmNvZGVyLmVuY29kZUludG8oc3RyLCBfc3RyQnVmZmVyKS53cml0dGVuIHx8IDBcbiAgICB3cml0ZVZhclVpbnQoZW5jb2Rlciwgd3JpdHRlbilcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdyaXR0ZW47IGkrKykge1xuICAgICAgd3JpdGUoZW5jb2RlciwgX3N0ckJ1ZmZlcltpXSlcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgd3JpdGVWYXJVaW50OEFycmF5KGVuY29kZXIsIHN0cmluZy5lbmNvZGVVdGY4KHN0cikpXG4gIH1cbn1cblxuLyoqXG4gKiBXcml0ZSBhIHZhcmlhYmxlIGxlbmd0aCBzdHJpbmcuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0VuY29kZXJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIHN0cmluZyB0aGF0IGlzIHRvIGJlIGVuY29kZWQuXG4gKi9cbmV4cG9ydCBjb25zdCBfd3JpdGVWYXJTdHJpbmdQb2x5ZmlsbCA9IChlbmNvZGVyLCBzdHIpID0+IHtcbiAgY29uc3QgZW5jb2RlZFN0cmluZyA9IHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChzdHIpKVxuICBjb25zdCBsZW4gPSBlbmNvZGVkU3RyaW5nLmxlbmd0aFxuICB3cml0ZVZhclVpbnQoZW5jb2RlciwgbGVuKVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgd3JpdGUoZW5jb2RlciwgLyoqIEB0eXBlIHtudW1iZXJ9ICovIChlbmNvZGVkU3RyaW5nLmNvZGVQb2ludEF0KGkpKSlcbiAgfVxufVxuXG4vKipcbiAqIFdyaXRlIGEgdmFyaWFibGUgbGVuZ3RoIHN0cmluZy5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RW5jb2Rlcn0gZW5jb2RlclxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgc3RyaW5nIHRoYXQgaXMgdG8gYmUgZW5jb2RlZC5cbiAqL1xuLyogYzggaWdub3JlIG5leHQgKi9cbmV4cG9ydCBjb25zdCB3cml0ZVZhclN0cmluZyA9IChzdHJpbmcudXRmOFRleHRFbmNvZGVyICYmIC8qKiBAdHlwZSB7YW55fSAqLyAoc3RyaW5nLnV0ZjhUZXh0RW5jb2RlcikuZW5jb2RlSW50bykgPyBfd3JpdGVWYXJTdHJpbmdOYXRpdmUgOiBfd3JpdGVWYXJTdHJpbmdQb2x5ZmlsbFxuXG4vKipcbiAqIFdyaXRlIGEgc3RyaW5nIHRlcm1pbmF0ZWQgYnkgYSBzcGVjaWFsIGJ5dGUgc2VxdWVuY2UuIFRoaXMgaXMgbm90IHZlcnkgcGVyZm9ybWFudCBhbmQgaXNcbiAqIGdlbmVyYWxseSBkaXNjb3VyYWdlZC4gSG93ZXZlciwgdGhlIHJlc3VsdGluZyBieXRlIGFycmF5cyBhcmUgbGV4aW9ncmFwaGljYWxseSBvcmRlcmVkIHdoaWNoXG4gKiBtYWtlcyB0aGlzIGEgbmljZSBmZWF0dXJlIGZvciBkYXRhYmFzZXMuXG4gKlxuICogVGhlIHN0cmluZyB3aWxsIGJlIGVuY29kZWQgdXNpbmcgdXRmOCBhbmQgdGhlbiB0ZXJtaW5hdGVkIGFuZCBlc2NhcGVkIHVzaW5nIHdyaXRlVGVybWluYXRpbmdVaW50OEFycmF5LlxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtFbmNvZGVyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBzdHJpbmcgdGhhdCBpcyB0byBiZSBlbmNvZGVkLlxuICovXG5leHBvcnQgY29uc3Qgd3JpdGVUZXJtaW5hdGVkU3RyaW5nID0gKGVuY29kZXIsIHN0cikgPT5cbiAgd3JpdGVUZXJtaW5hdGVkVWludDhBcnJheShlbmNvZGVyLCBzdHJpbmcuZW5jb2RlVXRmOChzdHIpKVxuXG4vKipcbiAqIFdyaXRlIGEgdGVybWluYXRpbmcgVWludDhBcnJheS4gTm90ZSB0aGF0IHRoaXMgaXMgbm90IHBlcmZvcm1hbnQgYW5kIGlzIGdlbmVyYWxseVxuICogZGlzY291cmFnZWQuIFRoZXJlIGFyZSBmZXcgc2l0dWF0aW9ucyB3aGVuIHRoaXMgaXMgbmVlZGVkLlxuICpcbiAqIFdlIHVzZSAweDAgYXMgYSB0ZXJtaW5hdGluZyBjaGFyYWN0ZXIuIDB4MSBzZXJ2ZXMgYXMgYW4gZXNjYXBlIGNoYXJhY3RlciBmb3IgMHgwIGFuZCAweDEuXG4gKlxuICogRXhhbXBsZTogWzAsMSwyXSBpcyBlbmNvZGVkIHRvIFsxLDAsMSwxLDIsMF0uIDB4MCwgYW5kIDB4MSBuZWVkZWQgdG8gYmUgZXNjYXBlZCB1c2luZyAweDEuIFRoZW5cbiAqIHRoZSByZXN1bHQgaXMgdGVybWluYXRlZCB1c2luZyB0aGUgMHgwIGNoYXJhY3Rlci5cbiAqXG4gKiBUaGlzIGlzIGJhc2ljYWxseSBob3cgbWFueSBzeXN0ZW1zIGltcGxlbWVudCBudWxsIHRlcm1pbmF0ZWQgc3RyaW5ncy4gSG93ZXZlciwgd2UgdXNlIGFuIGVzY2FwZVxuICogY2hhcmFjdGVyIDB4MSB0byBhdm9pZCBpc3N1ZXMgYW5kIHBvdGVuaWFsIGF0dGFja3Mgb24gb3VyIGRhdGFiYXNlIChpZiB0aGlzIGlzIHVzZWQgYXMgYSBrZXlcbiAqIGVuY29kZXIgZm9yIE5vU3FsIGRhdGFiYXNlcykuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0VuY29kZXJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmIFRoZSBzdHJpbmcgdGhhdCBpcyB0byBiZSBlbmNvZGVkLlxuICovXG5leHBvcnQgY29uc3Qgd3JpdGVUZXJtaW5hdGVkVWludDhBcnJheSA9IChlbmNvZGVyLCBidWYpID0+IHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBidWYubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBiID0gYnVmW2ldXG4gICAgaWYgKGIgPT09IDAgfHwgYiA9PT0gMSkge1xuICAgICAgd3JpdGUoZW5jb2RlciwgMSlcbiAgICB9XG4gICAgd3JpdGUoZW5jb2RlciwgYnVmW2ldKVxuICB9XG4gIHdyaXRlKGVuY29kZXIsIDApXG59XG5cbi8qKlxuICogV3JpdGUgdGhlIGNvbnRlbnQgb2YgYW5vdGhlciBFbmNvZGVyLlxuICpcbiAqIEBUT0RPOiBjYW4gYmUgaW1wcm92ZWQhXG4gKiAgICAgICAgLSBOb3RlOiBTaG91bGQgY29uc2lkZXIgdGhhdCB3aGVuIGFwcGVuZGluZyBhIGxvdCBvZiBzbWFsbCBFbmNvZGVycywgd2Ugc2hvdWxkIHJhdGhlciBjbG9uZSB0aGFuIHJlZmVyZW5jaW5nIHRoZSBvbGQgc3RydWN0dXJlLlxuICogICAgICAgICAgICAgICAgRW5jb2RlcnMgc3RhcnQgd2l0aCBhIHJhdGhlciBiaWcgaW5pdGlhbCBidWZmZXIuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0VuY29kZXJ9IGVuY29kZXIgVGhlIGVuVWludDhBcnJcbiAqIEBwYXJhbSB7RW5jb2Rlcn0gYXBwZW5kIFRoZSBCaW5hcnlFbmNvZGVyIHRvIGJlIHdyaXR0ZW4uXG4gKi9cbmV4cG9ydCBjb25zdCB3cml0ZUJpbmFyeUVuY29kZXIgPSAoZW5jb2RlciwgYXBwZW5kKSA9PiB3cml0ZVVpbnQ4QXJyYXkoZW5jb2RlciwgdG9VaW50OEFycmF5KGFwcGVuZCkpXG5cbi8qKlxuICogQXBwZW5kIGZpeGVkLWxlbmd0aCBVaW50OEFycmF5IHRvIHRoZSBlbmNvZGVyLlxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtFbmNvZGVyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHVpbnQ4QXJyYXlcbiAqL1xuZXhwb3J0IGNvbnN0IHdyaXRlVWludDhBcnJheSA9IChlbmNvZGVyLCB1aW50OEFycmF5KSA9PiB7XG4gIGNvbnN0IGJ1ZmZlckxlbiA9IGVuY29kZXIuY2J1Zi5sZW5ndGhcbiAgY29uc3QgY3BvcyA9IGVuY29kZXIuY3Bvc1xuICBjb25zdCBsZWZ0Q29weUxlbiA9IG1hdGgubWluKGJ1ZmZlckxlbiAtIGNwb3MsIHVpbnQ4QXJyYXkubGVuZ3RoKVxuICBjb25zdCByaWdodENvcHlMZW4gPSB1aW50OEFycmF5Lmxlbmd0aCAtIGxlZnRDb3B5TGVuXG4gIGVuY29kZXIuY2J1Zi5zZXQodWludDhBcnJheS5zdWJhcnJheSgwLCBsZWZ0Q29weUxlbiksIGNwb3MpXG4gIGVuY29kZXIuY3BvcyArPSBsZWZ0Q29weUxlblxuICBpZiAocmlnaHRDb3B5TGVuID4gMCkge1xuICAgIC8vIFN0aWxsIHNvbWV0aGluZyB0byB3cml0ZSwgd3JpdGUgcmlnaHQgaGFsZi4uXG4gICAgLy8gQXBwZW5kIG5ldyBidWZmZXJcbiAgICBlbmNvZGVyLmJ1ZnMucHVzaChlbmNvZGVyLmNidWYpXG4gICAgLy8gbXVzdCBoYXZlIGF0IGxlYXN0IHNpemUgb2YgcmVtYWluaW5nIGJ1ZmZlclxuICAgIGVuY29kZXIuY2J1ZiA9IG5ldyBVaW50OEFycmF5KG1hdGgubWF4KGJ1ZmZlckxlbiAqIDIsIHJpZ2h0Q29weUxlbikpXG4gICAgLy8gY29weSBhcnJheVxuICAgIGVuY29kZXIuY2J1Zi5zZXQodWludDhBcnJheS5zdWJhcnJheShsZWZ0Q29weUxlbikpXG4gICAgZW5jb2Rlci5jcG9zID0gcmlnaHRDb3B5TGVuXG4gIH1cbn1cblxuLyoqXG4gKiBBcHBlbmQgYW4gVWludDhBcnJheSB0byBFbmNvZGVyLlxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtFbmNvZGVyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHVpbnQ4QXJyYXlcbiAqL1xuZXhwb3J0IGNvbnN0IHdyaXRlVmFyVWludDhBcnJheSA9IChlbmNvZGVyLCB1aW50OEFycmF5KSA9PiB7XG4gIHdyaXRlVmFyVWludChlbmNvZGVyLCB1aW50OEFycmF5LmJ5dGVMZW5ndGgpXG4gIHdyaXRlVWludDhBcnJheShlbmNvZGVyLCB1aW50OEFycmF5KVxufVxuXG4vKipcbiAqIENyZWF0ZSBhbiBEYXRhVmlldyBvZiB0aGUgbmV4dCBgbGVuYCBieXRlcy4gVXNlIGl0IHRvIHdyaXRlIGRhdGEgYWZ0ZXJcbiAqIGNhbGxpbmcgdGhpcyBmdW5jdGlvbi5cbiAqXG4gKiBgYGBqc1xuICogLy8gd3JpdGUgZmxvYXQzMiB1c2luZyBEYXRhVmlld1xuICogY29uc3QgZHYgPSB3cml0ZU9uRGF0YVZpZXcoZW5jb2RlciwgNClcbiAqIGR2LnNldEZsb2F0MzIoMCwgMS4xKVxuICogLy8gcmVhZCBmbG9hdDMyIHVzaW5nIERhdGFWaWV3XG4gKiBjb25zdCBkdiA9IHJlYWRGcm9tRGF0YVZpZXcoZW5jb2RlciwgNClcbiAqIGR2LmdldEZsb2F0MzIoMCkgLy8gPT4gMS4xMDAwMDAwMjM4NDE4NTggKGxlYXZpbmcgaXQgdG8gdGhlIHJlYWRlciB0byBmaW5kIG91dCB3aHkgdGhpcyBpcyB0aGUgY29ycmVjdCByZXN1bHQpXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge0VuY29kZXJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZW5cbiAqIEByZXR1cm4ge0RhdGFWaWV3fVxuICovXG5leHBvcnQgY29uc3Qgd3JpdGVPbkRhdGFWaWV3ID0gKGVuY29kZXIsIGxlbikgPT4ge1xuICB2ZXJpZnlMZW4oZW5jb2RlciwgbGVuKVxuICBjb25zdCBkdmlldyA9IG5ldyBEYXRhVmlldyhlbmNvZGVyLmNidWYuYnVmZmVyLCBlbmNvZGVyLmNwb3MsIGxlbilcbiAgZW5jb2Rlci5jcG9zICs9IGxlblxuICByZXR1cm4gZHZpZXdcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VuY29kZXJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBudW1cbiAqL1xuZXhwb3J0IGNvbnN0IHdyaXRlRmxvYXQzMiA9IChlbmNvZGVyLCBudW0pID0+IHdyaXRlT25EYXRhVmlldyhlbmNvZGVyLCA0KS5zZXRGbG9hdDMyKDAsIG51bSwgZmFsc2UpXG5cbi8qKlxuICogQHBhcmFtIHtFbmNvZGVyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge251bWJlcn0gbnVtXG4gKi9cbmV4cG9ydCBjb25zdCB3cml0ZUZsb2F0NjQgPSAoZW5jb2RlciwgbnVtKSA9PiB3cml0ZU9uRGF0YVZpZXcoZW5jb2RlciwgOCkuc2V0RmxvYXQ2NCgwLCBudW0sIGZhbHNlKVxuXG4vKipcbiAqIEBwYXJhbSB7RW5jb2Rlcn0gZW5jb2RlclxuICogQHBhcmFtIHtiaWdpbnR9IG51bVxuICovXG5leHBvcnQgY29uc3Qgd3JpdGVCaWdJbnQ2NCA9IChlbmNvZGVyLCBudW0pID0+IC8qKiBAdHlwZSB7YW55fSAqLyAod3JpdGVPbkRhdGFWaWV3KGVuY29kZXIsIDgpKS5zZXRCaWdJbnQ2NCgwLCBudW0sIGZhbHNlKVxuXG4vKipcbiAqIEBwYXJhbSB7RW5jb2Rlcn0gZW5jb2RlclxuICogQHBhcmFtIHtiaWdpbnR9IG51bVxuICovXG5leHBvcnQgY29uc3Qgd3JpdGVCaWdVaW50NjQgPSAoZW5jb2RlciwgbnVtKSA9PiAvKiogQHR5cGUge2FueX0gKi8gKHdyaXRlT25EYXRhVmlldyhlbmNvZGVyLCA4KSkuc2V0QmlnVWludDY0KDAsIG51bSwgZmFsc2UpXG5cbmNvbnN0IGZsb2F0VGVzdEJlZCA9IG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoNCkpXG4vKipcbiAqIENoZWNrIGlmIGEgbnVtYmVyIGNhbiBiZSBlbmNvZGVkIGFzIGEgMzIgYml0IGZsb2F0LlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBudW1cbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmNvbnN0IGlzRmxvYXQzMiA9IG51bSA9PiB7XG4gIGZsb2F0VGVzdEJlZC5zZXRGbG9hdDMyKDAsIG51bSlcbiAgcmV0dXJuIGZsb2F0VGVzdEJlZC5nZXRGbG9hdDMyKDApID09PSBudW1cbn1cblxuLyoqXG4gKiBFbmNvZGUgZGF0YSB3aXRoIGVmZmljaWVudCBiaW5hcnkgZm9ybWF0LlxuICpcbiAqIERpZmZlcmVuY2VzIHRvIEpTT046XG4gKiBcdTIwMjIgVHJhbnNmb3JtcyBkYXRhIHRvIGEgYmluYXJ5IGZvcm1hdCAobm90IHRvIGEgc3RyaW5nKVxuICogXHUyMDIyIEVuY29kZXMgdW5kZWZpbmVkLCBOYU4sIGFuZCBBcnJheUJ1ZmZlciAodGhlc2UgY2FuJ3QgYmUgcmVwcmVzZW50ZWQgaW4gSlNPTilcbiAqIFx1MjAyMiBOdW1iZXJzIGFyZSBlZmZpY2llbnRseSBlbmNvZGVkIGVpdGhlciBhcyBhIHZhcmlhYmxlIGxlbmd0aCBpbnRlZ2VyLCBhcyBhXG4gKiAgIDMyIGJpdCBmbG9hdCwgYXMgYSA2NCBiaXQgZmxvYXQsIG9yIGFzIGEgNjQgYml0IGJpZ2ludC5cbiAqXG4gKiBFbmNvZGluZyB0YWJsZTpcbiAqXG4gKiB8IERhdGEgVHlwZSAgICAgICAgICAgfCBQcmVmaXggICB8IEVuY29kaW5nIE1ldGhvZCAgICB8IENvbW1lbnQgfFxuICogfCAtLS0tLS0tLS0tLS0tLS0tLS0tIHwgLS0tLS0tLS0gfCAtLS0tLS0tLS0tLS0tLS0tLS0gfCAtLS0tLS0tIHxcbiAqIHwgdW5kZWZpbmVkICAgICAgICAgICB8IDEyNyAgICAgIHwgICAgICAgICAgICAgICAgICAgIHwgRnVuY3Rpb25zLCBzeW1ib2wsIGFuZCBldmVyeXRoaW5nIHRoYXQgY2Fubm90IGJlIGlkZW50aWZpZWQgaXMgZW5jb2RlZCBhcyB1bmRlZmluZWQgfFxuICogfCBudWxsICAgICAgICAgICAgICAgIHwgMTI2ICAgICAgfCAgICAgICAgICAgICAgICAgICAgfCB8XG4gKiB8IGludGVnZXIgICAgICAgICAgICAgfCAxMjUgICAgICB8IHdyaXRlVmFySW50ICAgICAgICB8IE9ubHkgZW5jb2RlcyAzMiBiaXQgc2lnbmVkIGludGVnZXJzIHxcbiAqIHwgZmxvYXQzMiAgICAgICAgICAgICB8IDEyNCAgICAgIHwgd3JpdGVGbG9hdDMyICAgICAgIHwgfFxuICogfCBmbG9hdDY0ICAgICAgICAgICAgIHwgMTIzICAgICAgfCB3cml0ZUZsb2F0NjQgICAgICAgfCB8XG4gKiB8IGJpZ2ludCAgICAgICAgICAgICAgfCAxMjIgICAgICB8IHdyaXRlQmlnSW50NjQgICAgICB8IHxcbiAqIHwgYm9vbGVhbiAoZmFsc2UpICAgICB8IDEyMSAgICAgIHwgICAgICAgICAgICAgICAgICAgIHwgVHJ1ZSBhbmQgZmFsc2UgYXJlIGRpZmZlcmVudCBkYXRhIHR5cGVzIHNvIHdlIHNhdmUgdGhlIGZvbGxvd2luZyBieXRlIHxcbiAqIHwgYm9vbGVhbiAodHJ1ZSkgICAgICB8IDEyMCAgICAgIHwgICAgICAgICAgICAgICAgICAgIHwgLSAwYjAxMTExMDAwIHNvIHRoZSBsYXN0IGJpdCBkZXRlcm1pbmVzIHdoZXRoZXIgdHJ1ZSBvciBmYWxzZSB8XG4gKiB8IHN0cmluZyAgICAgICAgICAgICAgfCAxMTkgICAgICB8IHdyaXRlVmFyU3RyaW5nICAgICB8IHxcbiAqIHwgb2JqZWN0PHN0cmluZyxhbnk+ICB8IDExOCAgICAgIHwgY3VzdG9tICAgICAgICAgICAgIHwgV3JpdGVzIHtsZW5ndGh9IHRoZW4ge2xlbmd0aH0ga2V5LXZhbHVlIHBhaXJzIHxcbiAqIHwgYXJyYXk8YW55PiAgICAgICAgICB8IDExNyAgICAgIHwgY3VzdG9tICAgICAgICAgICAgIHwgV3JpdGVzIHtsZW5ndGh9IHRoZW4ge2xlbmd0aH0ganNvbiB2YWx1ZXMgfFxuICogfCBVaW50OEFycmF5ICAgICAgICAgIHwgMTE2ICAgICAgfCB3cml0ZVZhclVpbnQ4QXJyYXkgfCBXZSB1c2UgVWludDhBcnJheSBmb3IgYW55IGtpbmQgb2YgYmluYXJ5IGRhdGEgfFxuICpcbiAqIFJlYXNvbnMgZm9yIHRoZSBkZWNyZWFzaW5nIHByZWZpeDpcbiAqIFdlIG5lZWQgdGhlIGZpcnN0IGJpdCBmb3IgZXh0ZW5kYWJpbGl0eSAobGF0ZXIgd2UgbWF5IHdhbnQgdG8gZW5jb2RlIHRoZVxuICogcHJlZml4IHdpdGggd3JpdGVWYXJVaW50KS4gVGhlIHJlbWFpbmluZyA3IGJpdHMgYXJlIGRpdmlkZWQgYXMgZm9sbG93czpcbiAqIFswLTMwXSAgIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGRhdGEgcmFuZ2UgaXMgdXNlZCBmb3IgY3VzdG9tIHB1cnBvc2VzXG4gKiAgICAgICAgICAoZGVmaW5lZCBieSB0aGUgZnVuY3Rpb24gdGhhdCB1c2VzIHRoaXMgbGlicmFyeSlcbiAqIFszMS0xMjddIHRoZSBlbmQgb2YgdGhlIGRhdGEgcmFuZ2UgaXMgdXNlZCBmb3IgZGF0YSBlbmNvZGluZyBieVxuICogICAgICAgICAgbGliMC9lbmNvZGluZy5qc1xuICpcbiAqIEBwYXJhbSB7RW5jb2Rlcn0gZW5jb2RlclxuICogQHBhcmFtIHt1bmRlZmluZWR8bnVsbHxudW1iZXJ8YmlnaW50fGJvb2xlYW58c3RyaW5nfE9iamVjdDxzdHJpbmcsYW55PnxBcnJheTxhbnk+fFVpbnQ4QXJyYXl9IGRhdGFcbiAqL1xuZXhwb3J0IGNvbnN0IHdyaXRlQW55ID0gKGVuY29kZXIsIGRhdGEpID0+IHtcbiAgc3dpdGNoICh0eXBlb2YgZGF0YSkge1xuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAvLyBUWVBFIDExOTogU1RSSU5HXG4gICAgICB3cml0ZShlbmNvZGVyLCAxMTkpXG4gICAgICB3cml0ZVZhclN0cmluZyhlbmNvZGVyLCBkYXRhKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdudW1iZXInOlxuICAgICAgaWYgKG51bWJlci5pc0ludGVnZXIoZGF0YSkgJiYgbWF0aC5hYnMoZGF0YSkgPD0gYmluYXJ5LkJJVFMzMSkge1xuICAgICAgICAvLyBUWVBFIDEyNTogSU5URUdFUlxuICAgICAgICB3cml0ZShlbmNvZGVyLCAxMjUpXG4gICAgICAgIHdyaXRlVmFySW50KGVuY29kZXIsIGRhdGEpXG4gICAgICB9IGVsc2UgaWYgKGlzRmxvYXQzMihkYXRhKSkge1xuICAgICAgICAvLyBUWVBFIDEyNDogRkxPQVQzMlxuICAgICAgICB3cml0ZShlbmNvZGVyLCAxMjQpXG4gICAgICAgIHdyaXRlRmxvYXQzMihlbmNvZGVyLCBkYXRhKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVFlQRSAxMjM6IEZMT0FUNjRcbiAgICAgICAgd3JpdGUoZW5jb2RlciwgMTIzKVxuICAgICAgICB3cml0ZUZsb2F0NjQoZW5jb2RlciwgZGF0YSlcbiAgICAgIH1cbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYmlnaW50JzpcbiAgICAgIC8vIFRZUEUgMTIyOiBCaWdJbnRcbiAgICAgIHdyaXRlKGVuY29kZXIsIDEyMilcbiAgICAgIHdyaXRlQmlnSW50NjQoZW5jb2RlciwgZGF0YSlcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIGlmIChkYXRhID09PSBudWxsKSB7XG4gICAgICAgIC8vIFRZUEUgMTI2OiBudWxsXG4gICAgICAgIHdyaXRlKGVuY29kZXIsIDEyNilcbiAgICAgIH0gZWxzZSBpZiAoYXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgICAvLyBUWVBFIDExNzogQXJyYXlcbiAgICAgICAgd3JpdGUoZW5jb2RlciwgMTE3KVxuICAgICAgICB3cml0ZVZhclVpbnQoZW5jb2RlciwgZGF0YS5sZW5ndGgpXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHdyaXRlQW55KGVuY29kZXIsIGRhdGFbaV0pXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgLy8gVFlQRSAxMTY6IEFycmF5QnVmZmVyXG4gICAgICAgIHdyaXRlKGVuY29kZXIsIDExNilcbiAgICAgICAgd3JpdGVWYXJVaW50OEFycmF5KGVuY29kZXIsIGRhdGEpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUWVBFIDExODogT2JqZWN0XG4gICAgICAgIHdyaXRlKGVuY29kZXIsIDExOClcbiAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGRhdGEpXG4gICAgICAgIHdyaXRlVmFyVWludChlbmNvZGVyLCBrZXlzLmxlbmd0aClcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXVxuICAgICAgICAgIHdyaXRlVmFyU3RyaW5nKGVuY29kZXIsIGtleSlcbiAgICAgICAgICB3cml0ZUFueShlbmNvZGVyLCBkYXRhW2tleV0pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAvLyBUWVBFIDEyMC8xMjE6IGJvb2xlYW4gKHRydWUvZmFsc2UpXG4gICAgICB3cml0ZShlbmNvZGVyLCBkYXRhID8gMTIwIDogMTIxKVxuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICAgLy8gVFlQRSAxMjc6IHVuZGVmaW5lZFxuICAgICAgd3JpdGUoZW5jb2RlciwgMTI3KVxuICB9XG59XG5cbi8qKlxuICogTm93IGNvbWUgYSBmZXcgc3RhdGVmdWwgZW5jb2RlciB0aGF0IGhhdmUgdGhlaXIgb3duIGNsYXNzZXMuXG4gKi9cblxuLyoqXG4gKiBCYXNpYyBSdW4gTGVuZ3RoIEVuY29kZXIgLSBhIGJhc2ljIGNvbXByZXNzaW9uIGltcGxlbWVudGF0aW9uLlxuICpcbiAqIEVuY29kZXMgWzEsMSwxLDddIHRvIFsxLDMsNywxXSAoMyB0aW1lcyAxLCAxIHRpbWUgNykuIFRoaXMgZW5jb2RlciBtaWdodCBkbyBtb3JlIGhhcm0gdGhhbiBnb29kIGlmIHRoZXJlIGFyZSBhIGxvdCBvZiB2YWx1ZXMgdGhhdCBhcmUgbm90IHJlcGVhdGVkLlxuICpcbiAqIEl0IHdhcyBvcmlnaW5hbGx5IHVzZWQgZm9yIGltYWdlIGNvbXByZXNzaW9uLiBDb29sIC4uIGFydGljbGUgaHR0cDovL2NzYnJ1Y2UuY29tL2NibS90cmFuc2FjdG9yL3BkZnMvdHJhbnNfdjdfaTA2LnBkZlxuICpcbiAqIEBub3RlIFQgbXVzdCBub3QgYmUgbnVsbCFcbiAqXG4gKiBAdGVtcGxhdGUgVFxuICovXG5leHBvcnQgY2xhc3MgUmxlRW5jb2RlciBleHRlbmRzIEVuY29kZXIge1xuICAvKipcbiAgICogQHBhcmFtIHtmdW5jdGlvbihFbmNvZGVyLCBUKTp2b2lkfSB3cml0ZXJcbiAgICovXG4gIGNvbnN0cnVjdG9yICh3cml0ZXIpIHtcbiAgICBzdXBlcigpXG4gICAgLyoqXG4gICAgICogVGhlIHdyaXRlclxuICAgICAqL1xuICAgIHRoaXMudyA9IHdyaXRlclxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgc3RhdGVcbiAgICAgKiBAdHlwZSB7VHxudWxsfVxuICAgICAqL1xuICAgIHRoaXMucyA9IG51bGxcbiAgICB0aGlzLmNvdW50ID0gMFxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VH0gdlxuICAgKi9cbiAgd3JpdGUgKHYpIHtcbiAgICBpZiAodGhpcy5zID09PSB2KSB7XG4gICAgICB0aGlzLmNvdW50KytcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRoaXMuY291bnQgPiAwKSB7XG4gICAgICAgIC8vIGZsdXNoIGNvdW50ZXIsIHVubGVzcyB0aGlzIGlzIHRoZSBmaXJzdCB2YWx1ZSAoY291bnQgPSAwKVxuICAgICAgICB3cml0ZVZhclVpbnQodGhpcywgdGhpcy5jb3VudCAtIDEpIC8vIHNpbmNlIGNvdW50IGlzIGFsd2F5cyA+IDAsIHdlIGNhbiBkZWNyZW1lbnQgYnkgb25lLiBub24tc3RhbmRhcmQgZW5jb2RpbmcgZnR3XG4gICAgICB9XG4gICAgICB0aGlzLmNvdW50ID0gMVxuICAgICAgLy8gd3JpdGUgZmlyc3QgdmFsdWVcbiAgICAgIHRoaXMudyh0aGlzLCB2KVxuICAgICAgdGhpcy5zID0gdlxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEJhc2ljIGRpZmYgZGVjb2RlciB1c2luZyB2YXJpYWJsZSBsZW5ndGggZW5jb2RpbmcuXG4gKlxuICogRW5jb2RlcyB0aGUgdmFsdWVzIFszLCAxMTAwLCAxMTAxLCAxMDUwLCAwXSB0byBbMywgMTA5NywgMSwgLTUxLCAtMTA1MF0gdXNpbmcgd3JpdGVWYXJJbnQuXG4gKi9cbmV4cG9ydCBjbGFzcyBJbnREaWZmRW5jb2RlciBleHRlbmRzIEVuY29kZXIge1xuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0XG4gICAqL1xuICBjb25zdHJ1Y3RvciAoc3RhcnQpIHtcbiAgICBzdXBlcigpXG4gICAgLyoqXG4gICAgICogQ3VycmVudCBzdGF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5zID0gc3RhcnRcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gdlxuICAgKi9cbiAgd3JpdGUgKHYpIHtcbiAgICB3cml0ZVZhckludCh0aGlzLCB2IC0gdGhpcy5zKVxuICAgIHRoaXMucyA9IHZcbiAgfVxufVxuXG4vKipcbiAqIEEgY29tYmluYXRpb24gb2YgSW50RGlmZkVuY29kZXIgYW5kIFJsZUVuY29kZXIuXG4gKlxuICogQmFzaWNhbGx5IGZpcnN0IHdyaXRlcyB0aGUgSW50RGlmZkVuY29kZXIgYW5kIHRoZW4gY291bnRzIGR1cGxpY2F0ZSBkaWZmcyB1c2luZyBSbGVFbmNvZGluZy5cbiAqXG4gKiBFbmNvZGVzIHRoZSB2YWx1ZXMgWzEsMSwxLDIsMyw0LDUsNl0gYXMgWzEsMSwwLDIsMSw1XSAoUkxFKFsxLDAsMCwxLDEsMSwxLDFdKSBcdTIxRDIgUmxlSW50RGlmZlsxLDEsMCwyLDEsNV0pXG4gKi9cbmV4cG9ydCBjbGFzcyBSbGVJbnREaWZmRW5jb2RlciBleHRlbmRzIEVuY29kZXIge1xuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0XG4gICAqL1xuICBjb25zdHJ1Y3RvciAoc3RhcnQpIHtcbiAgICBzdXBlcigpXG4gICAgLyoqXG4gICAgICogQ3VycmVudCBzdGF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5zID0gc3RhcnRcbiAgICB0aGlzLmNvdW50ID0gMFxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2XG4gICAqL1xuICB3cml0ZSAodikge1xuICAgIGlmICh0aGlzLnMgPT09IHYgJiYgdGhpcy5jb3VudCA+IDApIHtcbiAgICAgIHRoaXMuY291bnQrK1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGhpcy5jb3VudCA+IDApIHtcbiAgICAgICAgLy8gZmx1c2ggY291bnRlciwgdW5sZXNzIHRoaXMgaXMgdGhlIGZpcnN0IHZhbHVlIChjb3VudCA9IDApXG4gICAgICAgIHdyaXRlVmFyVWludCh0aGlzLCB0aGlzLmNvdW50IC0gMSkgLy8gc2luY2UgY291bnQgaXMgYWx3YXlzID4gMCwgd2UgY2FuIGRlY3JlbWVudCBieSBvbmUuIG5vbi1zdGFuZGFyZCBlbmNvZGluZyBmdHdcbiAgICAgIH1cbiAgICAgIHRoaXMuY291bnQgPSAxXG4gICAgICAvLyB3cml0ZSBmaXJzdCB2YWx1ZVxuICAgICAgd3JpdGVWYXJJbnQodGhpcywgdiAtIHRoaXMucylcbiAgICAgIHRoaXMucyA9IHZcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1VpbnRPcHRSbGVFbmNvZGVyfSBlbmNvZGVyXG4gKi9cbmNvbnN0IGZsdXNoVWludE9wdFJsZUVuY29kZXIgPSBlbmNvZGVyID0+IHtcbiAgaWYgKGVuY29kZXIuY291bnQgPiAwKSB7XG4gICAgLy8gZmx1c2ggY291bnRlciwgdW5sZXNzIHRoaXMgaXMgdGhlIGZpcnN0IHZhbHVlIChjb3VudCA9IDApXG4gICAgLy8gY2FzZSAxOiBqdXN0IGEgc2luZ2xlIHZhbHVlLiBzZXQgc2lnbiB0byBwb3NpdGl2ZVxuICAgIC8vIGNhc2UgMjogd3JpdGUgc2V2ZXJhbCB2YWx1ZXMuIHNldCBzaWduIHRvIG5lZ2F0aXZlIHRvIGluZGljYXRlIHRoYXQgdGhlcmUgaXMgYSBsZW5ndGggY29taW5nXG4gICAgd3JpdGVWYXJJbnQoZW5jb2Rlci5lbmNvZGVyLCBlbmNvZGVyLmNvdW50ID09PSAxID8gZW5jb2Rlci5zIDogLWVuY29kZXIucylcbiAgICBpZiAoZW5jb2Rlci5jb3VudCA+IDEpIHtcbiAgICAgIHdyaXRlVmFyVWludChlbmNvZGVyLmVuY29kZXIsIGVuY29kZXIuY291bnQgLSAyKSAvLyBzaW5jZSBjb3VudCBpcyBhbHdheXMgPiAxLCB3ZSBjYW4gZGVjcmVtZW50IGJ5IG9uZS4gbm9uLXN0YW5kYXJkIGVuY29kaW5nIGZ0d1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIE9wdGltaXplZCBSbGUgZW5jb2RlciB0aGF0IGRvZXMgbm90IHN1ZmZlciBmcm9tIHRoZSBtZW50aW9uZWQgcHJvYmxlbSBvZiB0aGUgYmFzaWMgUmxlIGVuY29kZXIuXG4gKlxuICogSW50ZXJuYWxseSB1c2VzIFZhckludCBlbmNvZGVyIHRvIHdyaXRlIHVuc2lnbmVkIGludGVnZXJzLiBJZiB0aGUgaW5wdXQgb2NjdXJzIG11bHRpcGxlIHRpbWVzLCB3ZSB3cml0ZVxuICogd3JpdGUgaXQgYXMgYSBuZWdhdGl2ZSBudW1iZXIuIFRoZSBVaW50T3B0UmxlRGVjb2RlciB0aGVuIHVuZGVyc3RhbmRzIHRoYXQgaXQgbmVlZHMgdG8gcmVhZCBhIGNvdW50LlxuICpcbiAqIEVuY29kZXMgWzEsMiwzLDMsM10gYXMgWzEsMiwtMywzXSAob25jZSAxLCBvbmNlIDIsIHRocmVlIHRpbWVzIDMpXG4gKi9cbmV4cG9ydCBjbGFzcyBVaW50T3B0UmxlRW5jb2RlciB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICB0aGlzLmVuY29kZXIgPSBuZXcgRW5jb2RlcigpXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnMgPSAwXG4gICAgdGhpcy5jb3VudCA9IDBcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gdlxuICAgKi9cbiAgd3JpdGUgKHYpIHtcbiAgICBpZiAodGhpcy5zID09PSB2KSB7XG4gICAgICB0aGlzLmNvdW50KytcbiAgICB9IGVsc2Uge1xuICAgICAgZmx1c2hVaW50T3B0UmxlRW5jb2Rlcih0aGlzKVxuICAgICAgdGhpcy5jb3VudCA9IDFcbiAgICAgIHRoaXMucyA9IHZcbiAgICB9XG4gIH1cblxuICB0b1VpbnQ4QXJyYXkgKCkge1xuICAgIGZsdXNoVWludE9wdFJsZUVuY29kZXIodGhpcylcbiAgICByZXR1cm4gdG9VaW50OEFycmF5KHRoaXMuZW5jb2RlcilcbiAgfVxufVxuXG4vKipcbiAqIEluY3JlYXNpbmcgVWludCBPcHRpbWl6ZWQgUkxFIEVuY29kZXJcbiAqXG4gKiBUaGUgUkxFIGVuY29kZXIgY291bnRzIHRoZSBudW1iZXIgb2Ygc2FtZSBvY2N1cmVuY2VzIG9mIHRoZSBzYW1lIHZhbHVlLlxuICogVGhlIEluY1VpbnRPcHRSbGUgZW5jb2RlciBjb3VudHMgaWYgdGhlIHZhbHVlIGluY3JlYXNlcy5cbiAqIEkuZS4gNywgOCwgOSwgMTAgd2lsbCBiZSBlbmNvZGVkIGFzIFstNywgNF0uIDEsIDMsIDUgd2lsbCBiZSBlbmNvZGVkXG4gKiBhcyBbMSwgMywgNV0uXG4gKi9cbmV4cG9ydCBjbGFzcyBJbmNVaW50T3B0UmxlRW5jb2RlciB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICB0aGlzLmVuY29kZXIgPSBuZXcgRW5jb2RlcigpXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnMgPSAwXG4gICAgdGhpcy5jb3VudCA9IDBcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gdlxuICAgKi9cbiAgd3JpdGUgKHYpIHtcbiAgICBpZiAodGhpcy5zICsgdGhpcy5jb3VudCA9PT0gdikge1xuICAgICAgdGhpcy5jb3VudCsrXG4gICAgfSBlbHNlIHtcbiAgICAgIGZsdXNoVWludE9wdFJsZUVuY29kZXIodGhpcylcbiAgICAgIHRoaXMuY291bnQgPSAxXG4gICAgICB0aGlzLnMgPSB2XG4gICAgfVxuICB9XG5cbiAgdG9VaW50OEFycmF5ICgpIHtcbiAgICBmbHVzaFVpbnRPcHRSbGVFbmNvZGVyKHRoaXMpXG4gICAgcmV0dXJuIHRvVWludDhBcnJheSh0aGlzLmVuY29kZXIpXG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0ludERpZmZPcHRSbGVFbmNvZGVyfSBlbmNvZGVyXG4gKi9cbmNvbnN0IGZsdXNoSW50RGlmZk9wdFJsZUVuY29kZXIgPSBlbmNvZGVyID0+IHtcbiAgaWYgKGVuY29kZXIuY291bnQgPiAwKSB7XG4gICAgLy8gICAgICAgICAgMzEgYml0IG1ha2luZyB1cCB0aGUgZGlmZiB8IHdldGhlciB0byB3cml0ZSB0aGUgY291bnRlclxuICAgIC8vIGNvbnN0IGVuY29kZWREaWZmID0gZW5jb2Rlci5kaWZmIDw8IDEgfCAoZW5jb2Rlci5jb3VudCA9PT0gMSA/IDAgOiAxKVxuICAgIGNvbnN0IGVuY29kZWREaWZmID0gZW5jb2Rlci5kaWZmICogMiArIChlbmNvZGVyLmNvdW50ID09PSAxID8gMCA6IDEpXG4gICAgLy8gZmx1c2ggY291bnRlciwgdW5sZXNzIHRoaXMgaXMgdGhlIGZpcnN0IHZhbHVlIChjb3VudCA9IDApXG4gICAgLy8gY2FzZSAxOiBqdXN0IGEgc2luZ2xlIHZhbHVlLiBzZXQgZmlyc3QgYml0IHRvIHBvc2l0aXZlXG4gICAgLy8gY2FzZSAyOiB3cml0ZSBzZXZlcmFsIHZhbHVlcy4gc2V0IGZpcnN0IGJpdCB0byBuZWdhdGl2ZSB0byBpbmRpY2F0ZSB0aGF0IHRoZXJlIGlzIGEgbGVuZ3RoIGNvbWluZ1xuICAgIHdyaXRlVmFySW50KGVuY29kZXIuZW5jb2RlciwgZW5jb2RlZERpZmYpXG4gICAgaWYgKGVuY29kZXIuY291bnQgPiAxKSB7XG4gICAgICB3cml0ZVZhclVpbnQoZW5jb2Rlci5lbmNvZGVyLCBlbmNvZGVyLmNvdW50IC0gMikgLy8gc2luY2UgY291bnQgaXMgYWx3YXlzID4gMSwgd2UgY2FuIGRlY3JlbWVudCBieSBvbmUuIG5vbi1zdGFuZGFyZCBlbmNvZGluZyBmdHdcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBBIGNvbWJpbmF0aW9uIG9mIHRoZSBJbnREaWZmRW5jb2RlciBhbmQgdGhlIFVpbnRPcHRSbGVFbmNvZGVyLlxuICpcbiAqIFRoZSBjb3VudCBhcHByb2FjaCBpcyBzaW1pbGFyIHRvIHRoZSBVaW50RGlmZk9wdFJsZUVuY29kZXIsIGJ1dCBpbnN0ZWFkIG9mIHVzaW5nIHRoZSBuZWdhdGl2ZSBiaXRmbGFnLCBpdCBlbmNvZGVzXG4gKiBpbiB0aGUgTFNCIHdoZXRoZXIgYSBjb3VudCBpcyB0byBiZSByZWFkLiBUaGVyZWZvcmUgdGhpcyBFbmNvZGVyIG9ubHkgc3VwcG9ydHMgMzEgYml0IGludGVnZXJzIVxuICpcbiAqIEVuY29kZXMgWzEsIDIsIDMsIDJdIGFzIFszLCAxLCA2LCAtMV0gKG1vcmUgc3BlY2lmaWNhbGx5IFsoMSA8PCAxKSB8IDEsICgzIDw8IDApIHwgMCwgLTFdKVxuICpcbiAqIEludGVybmFsbHkgdXNlcyB2YXJpYWJsZSBsZW5ndGggZW5jb2RpbmcuIENvbnRyYXJ5IHRvIG5vcm1hbCBVaW50VmFyIGVuY29kaW5nLCB0aGUgZmlyc3QgYnl0ZSBjb250YWluczpcbiAqICogMSBiaXQgdGhhdCBkZW5vdGVzIHdoZXRoZXIgdGhlIG5leHQgdmFsdWUgaXMgYSBjb3VudCAoTFNCKVxuICogKiAxIGJpdCB0aGF0IGRlbm90ZXMgd2hldGhlciB0aGlzIHZhbHVlIGlzIG5lZ2F0aXZlIChNU0IgLSAxKVxuICogKiAxIGJpdCB0aGF0IGRlbm90ZXMgd2hldGhlciB0byBjb250aW51ZSByZWFkaW5nIHRoZSB2YXJpYWJsZSBsZW5ndGggaW50ZWdlciAoTVNCKVxuICpcbiAqIFRoZXJlZm9yZSwgb25seSBmaXZlIGJpdHMgcmVtYWluIHRvIGVuY29kZSBkaWZmIHJhbmdlcy5cbiAqXG4gKiBVc2UgdGhpcyBFbmNvZGVyIG9ubHkgd2hlbiBhcHByb3ByaWF0ZS4gSW4gbW9zdCBjYXNlcywgdGhpcyBpcyBwcm9iYWJseSBhIGJhZCBpZGVhLlxuICovXG5leHBvcnQgY2xhc3MgSW50RGlmZk9wdFJsZUVuY29kZXIge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgdGhpcy5lbmNvZGVyID0gbmV3IEVuY29kZXIoKVxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5zID0gMFxuICAgIHRoaXMuY291bnQgPSAwXG4gICAgdGhpcy5kaWZmID0gMFxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2XG4gICAqL1xuICB3cml0ZSAodikge1xuICAgIGlmICh0aGlzLmRpZmYgPT09IHYgLSB0aGlzLnMpIHtcbiAgICAgIHRoaXMucyA9IHZcbiAgICAgIHRoaXMuY291bnQrK1xuICAgIH0gZWxzZSB7XG4gICAgICBmbHVzaEludERpZmZPcHRSbGVFbmNvZGVyKHRoaXMpXG4gICAgICB0aGlzLmNvdW50ID0gMVxuICAgICAgdGhpcy5kaWZmID0gdiAtIHRoaXMuc1xuICAgICAgdGhpcy5zID0gdlxuICAgIH1cbiAgfVxuXG4gIHRvVWludDhBcnJheSAoKSB7XG4gICAgZmx1c2hJbnREaWZmT3B0UmxlRW5jb2Rlcih0aGlzKVxuICAgIHJldHVybiB0b1VpbnQ4QXJyYXkodGhpcy5lbmNvZGVyKVxuICB9XG59XG5cbi8qKlxuICogT3B0aW1pemVkIFN0cmluZyBFbmNvZGVyLlxuICpcbiAqIEVuY29kaW5nIG1hbnkgc21hbGwgc3RyaW5ncyBpbiBhIHNpbXBsZSBFbmNvZGVyIGlzIG5vdCB2ZXJ5IGVmZmljaWVudC4gVGhlIGZ1bmN0aW9uIGNhbGwgdG8gZGVjb2RlIGEgc3RyaW5nIHRha2VzIHNvbWUgdGltZSBhbmQgY3JlYXRlcyByZWZlcmVuY2VzIHRoYXQgbXVzdCBiZSBldmVudHVhbGx5IGRlbGV0ZWQuXG4gKiBJbiBwcmFjdGljZSwgd2hlbiBkZWNvZGluZyBzZXZlcmFsIG1pbGxpb24gc21hbGwgc3RyaW5ncywgdGhlIEdDIHdpbGwga2ljayBpbiBtb3JlIGFuZCBtb3JlIG9mdGVuIHRvIGNvbGxlY3Qgb3JwaGFuZWQgc3RyaW5nIG9iamVjdHMgKG9yIG1heWJlIHRoZXJlIGlzIGFub3RoZXIgcmVhc29uPykuXG4gKlxuICogVGhpcyBzdHJpbmcgZW5jb2RlciBzb2x2ZXMgdGhlIGFib3ZlIHByb2JsZW0uIEFsbCBzdHJpbmdzIGFyZSBjb25jYXRlbmF0ZWQgYW5kIHdyaXR0ZW4gYXMgYSBzaW5nbGUgc3RyaW5nIHVzaW5nIGEgc2luZ2xlIGVuY29kaW5nIGNhbGwuXG4gKlxuICogVGhlIGxlbmd0aHMgYXJlIGVuY29kZWQgdXNpbmcgYSBVaW50T3B0UmxlRW5jb2Rlci5cbiAqL1xuZXhwb3J0IGNsYXNzIFN0cmluZ0VuY29kZXIge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge0FycmF5PHN0cmluZz59XG4gICAgICovXG4gICAgdGhpcy5zYXJyID0gW11cbiAgICB0aGlzLnMgPSAnJ1xuICAgIHRoaXMubGVuc0UgPSBuZXcgVWludE9wdFJsZUVuY29kZXIoKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdcbiAgICovXG4gIHdyaXRlIChzdHJpbmcpIHtcbiAgICB0aGlzLnMgKz0gc3RyaW5nXG4gICAgaWYgKHRoaXMucy5sZW5ndGggPiAxOSkge1xuICAgICAgdGhpcy5zYXJyLnB1c2godGhpcy5zKVxuICAgICAgdGhpcy5zID0gJydcbiAgICB9XG4gICAgdGhpcy5sZW5zRS53cml0ZShzdHJpbmcubGVuZ3RoKVxuICB9XG5cbiAgdG9VaW50OEFycmF5ICgpIHtcbiAgICBjb25zdCBlbmNvZGVyID0gbmV3IEVuY29kZXIoKVxuICAgIHRoaXMuc2Fyci5wdXNoKHRoaXMucylcbiAgICB0aGlzLnMgPSAnJ1xuICAgIHdyaXRlVmFyU3RyaW5nKGVuY29kZXIsIHRoaXMuc2Fyci5qb2luKCcnKSlcbiAgICB3cml0ZVVpbnQ4QXJyYXkoZW5jb2RlciwgdGhpcy5sZW5zRS50b1VpbnQ4QXJyYXkoKSlcbiAgICByZXR1cm4gdG9VaW50OEFycmF5KGVuY29kZXIpXG4gIH1cbn1cbiIsICIvKipcbiAqIEVycm9yIGhlbHBlcnMuXG4gKlxuICogQG1vZHVsZSBlcnJvclxuICovXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHNcbiAqIEByZXR1cm4ge0Vycm9yfVxuICovXG4vKiBjOCBpZ25vcmUgbmV4dCAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZSA9IHMgPT4gbmV3IEVycm9yKHMpXG5cbi8qKlxuICogQHRocm93cyB7RXJyb3J9XG4gKiBAcmV0dXJuIHtuZXZlcn1cbiAqL1xuLyogYzggaWdub3JlIG5leHQgMyAqL1xuZXhwb3J0IGNvbnN0IG1ldGhvZFVuaW1wbGVtZW50ZWQgPSAoKSA9PiB7XG4gIHRocm93IGNyZWF0ZSgnTWV0aG9kIHVuaW1wbGVtZW50ZWQnKVxufVxuXG4vKipcbiAqIEB0aHJvd3Mge0Vycm9yfVxuICogQHJldHVybiB7bmV2ZXJ9XG4gKi9cbi8qIGM4IGlnbm9yZSBuZXh0IDMgKi9cbmV4cG9ydCBjb25zdCB1bmV4cGVjdGVkQ2FzZSA9ICgpID0+IHtcbiAgdGhyb3cgY3JlYXRlKCdVbmV4cGVjdGVkIGNhc2UnKVxufVxuIiwgIi8qKlxuICogRWZmaWNpZW50IHNjaGVtYS1sZXNzIGJpbmFyeSBkZWNvZGluZyB3aXRoIHN1cHBvcnQgZm9yIHZhcmlhYmxlIGxlbmd0aCBlbmNvZGluZy5cbiAqXG4gKiBVc2UgW2xpYjAvZGVjb2RpbmddIHdpdGggW2xpYjAvZW5jb2RpbmddLiBFdmVyeSBlbmNvZGluZyBmdW5jdGlvbiBoYXMgYSBjb3JyZXNwb25kaW5nIGRlY29kaW5nIGZ1bmN0aW9uLlxuICpcbiAqIEVuY29kZXMgbnVtYmVycyBpbiBsaXR0bGUtZW5kaWFuIG9yZGVyIChsZWFzdCB0byBtb3N0IHNpZ25pZmljYW50IGJ5dGUgb3JkZXIpXG4gKiBhbmQgaXMgY29tcGF0aWJsZSB3aXRoIEdvbGFuZydzIGJpbmFyeSBlbmNvZGluZyAoaHR0cHM6Ly9nb2xhbmcub3JnL3BrZy9lbmNvZGluZy9iaW5hcnkvKVxuICogd2hpY2ggaXMgYWxzbyB1c2VkIGluIFByb3RvY29sIEJ1ZmZlcnMuXG4gKlxuICogYGBganNcbiAqIC8vIGVuY29kaW5nIHN0ZXBcbiAqIGNvbnN0IGVuY29kZXIgPSBlbmNvZGluZy5jcmVhdGVFbmNvZGVyKClcbiAqIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyLCAyNTYpXG4gKiBlbmNvZGluZy53cml0ZVZhclN0cmluZyhlbmNvZGVyLCAnSGVsbG8gd29ybGQhJylcbiAqIGNvbnN0IGJ1ZiA9IGVuY29kaW5nLnRvVWludDhBcnJheShlbmNvZGVyKVxuICogYGBgXG4gKlxuICogYGBganNcbiAqIC8vIGRlY29kaW5nIHN0ZXBcbiAqIGNvbnN0IGRlY29kZXIgPSBkZWNvZGluZy5jcmVhdGVEZWNvZGVyKGJ1ZilcbiAqIGRlY29kaW5nLnJlYWRWYXJVaW50KGRlY29kZXIpIC8vID0+IDI1NlxuICogZGVjb2RpbmcucmVhZFZhclN0cmluZyhkZWNvZGVyKSAvLyA9PiAnSGVsbG8gd29ybGQhJ1xuICogZGVjb2RpbmcuaGFzQ29udGVudChkZWNvZGVyKSAvLyA9PiBmYWxzZSAtIGFsbCBkYXRhIGlzIHJlYWRcbiAqIGBgYFxuICpcbiAqIEBtb2R1bGUgZGVjb2RpbmdcbiAqL1xuXG5pbXBvcnQgKiBhcyBiaW5hcnkgZnJvbSAnLi9iaW5hcnkuanMnXG5pbXBvcnQgKiBhcyBtYXRoIGZyb20gJy4vbWF0aC5qcydcbmltcG9ydCAqIGFzIG51bWJlciBmcm9tICcuL251bWJlci5qcydcbmltcG9ydCAqIGFzIHN0cmluZyBmcm9tICcuL3N0cmluZy5qcydcbmltcG9ydCAqIGFzIGVycm9yIGZyb20gJy4vZXJyb3IuanMnXG5pbXBvcnQgKiBhcyBlbmNvZGluZyBmcm9tICcuL2VuY29kaW5nLmpzJ1xuXG5jb25zdCBlcnJvclVuZXhwZWN0ZWRFbmRPZkFycmF5ID0gZXJyb3IuY3JlYXRlKCdVbmV4cGVjdGVkIGVuZCBvZiBhcnJheScpXG5jb25zdCBlcnJvckludGVnZXJPdXRPZlJhbmdlID0gZXJyb3IuY3JlYXRlKCdJbnRlZ2VyIG91dCBvZiBSYW5nZScpXG5cbi8qKlxuICogQSBEZWNvZGVyIGhhbmRsZXMgdGhlIGRlY29kaW5nIG9mIGFuIFVpbnQ4QXJyYXkuXG4gKi9cbmV4cG9ydCBjbGFzcyBEZWNvZGVyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7VWludDhBcnJheX0gdWludDhBcnJheSBCaW5hcnkgZGF0YSB0byBkZWNvZGVcbiAgICovXG4gIGNvbnN0cnVjdG9yICh1aW50OEFycmF5KSB7XG4gICAgLyoqXG4gICAgICogRGVjb2RpbmcgdGFyZ2V0LlxuICAgICAqXG4gICAgICogQHR5cGUge1VpbnQ4QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5hcnIgPSB1aW50OEFycmF5XG4gICAgLyoqXG4gICAgICogQ3VycmVudCBkZWNvZGluZyBwb3NpdGlvbi5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5wb3MgPSAwXG4gIH1cbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7VWludDhBcnJheX0gdWludDhBcnJheVxuICogQHJldHVybiB7RGVjb2Rlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZURlY29kZXIgPSB1aW50OEFycmF5ID0+IG5ldyBEZWNvZGVyKHVpbnQ4QXJyYXkpXG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0RlY29kZXJ9IGRlY29kZXJcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBjb25zdCBoYXNDb250ZW50ID0gZGVjb2RlciA9PiBkZWNvZGVyLnBvcyAhPT0gZGVjb2Rlci5hcnIubGVuZ3RoXG5cbi8qKlxuICogQ2xvbmUgYSBkZWNvZGVyIGluc3RhbmNlLlxuICogT3B0aW9uYWxseSBzZXQgYSBuZXcgcG9zaXRpb24gcGFyYW1ldGVyLlxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtEZWNvZGVyfSBkZWNvZGVyIFRoZSBkZWNvZGVyIGluc3RhbmNlXG4gKiBAcGFyYW0ge251bWJlcn0gW25ld1Bvc10gRGVmYXVsdHMgdG8gY3VycmVudCBwb3NpdGlvblxuICogQHJldHVybiB7RGVjb2Rlcn0gQSBjbG9uZSBvZiBgZGVjb2RlcmBcbiAqL1xuZXhwb3J0IGNvbnN0IGNsb25lID0gKGRlY29kZXIsIG5ld1BvcyA9IGRlY29kZXIucG9zKSA9PiB7XG4gIGNvbnN0IF9kZWNvZGVyID0gY3JlYXRlRGVjb2RlcihkZWNvZGVyLmFycilcbiAgX2RlY29kZXIucG9zID0gbmV3UG9zXG4gIHJldHVybiBfZGVjb2RlclxufVxuXG4vKipcbiAqIENyZWF0ZSBhbiBVaW50OEFycmF5IHZpZXcgb2YgdGhlIG5leHQgYGxlbmAgYnl0ZXMgYW5kIGFkdmFuY2UgdGhlIHBvc2l0aW9uIGJ5IGBsZW5gLlxuICpcbiAqIEltcG9ydGFudDogVGhlIFVpbnQ4QXJyYXkgc3RpbGwgcG9pbnRzIHRvIHRoZSB1bmRlcmx5aW5nIEFycmF5QnVmZmVyLiBNYWtlIHN1cmUgdG8gZGlzY2FyZCB0aGUgcmVzdWx0IGFzIHNvb24gYXMgcG9zc2libGUgdG8gcHJldmVudCBhbnkgbWVtb3J5IGxlYWtzLlxuICogICAgICAgICAgICBVc2UgYGJ1ZmZlci5jb3B5VWludDhBcnJheWAgdG8gY29weSB0aGUgcmVzdWx0IGludG8gYSBuZXcgVWludDhBcnJheS5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RGVjb2Rlcn0gZGVjb2RlciBUaGUgZGVjb2RlciBpbnN0YW5jZVxuICogQHBhcmFtIHtudW1iZXJ9IGxlbiBUaGUgbGVuZ3RoIG9mIGJ5dGVzIHRvIHJlYWRcbiAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9XG4gKi9cbmV4cG9ydCBjb25zdCByZWFkVWludDhBcnJheSA9IChkZWNvZGVyLCBsZW4pID0+IHtcbiAgY29uc3QgdmlldyA9IG5ldyBVaW50OEFycmF5KGRlY29kZXIuYXJyLmJ1ZmZlciwgZGVjb2Rlci5wb3MgKyBkZWNvZGVyLmFyci5ieXRlT2Zmc2V0LCBsZW4pXG4gIGRlY29kZXIucG9zICs9IGxlblxuICByZXR1cm4gdmlld1xufVxuXG4vKipcbiAqIFJlYWQgdmFyaWFibGUgbGVuZ3RoIFVpbnQ4QXJyYXkuXG4gKlxuICogSW1wb3J0YW50OiBUaGUgVWludDhBcnJheSBzdGlsbCBwb2ludHMgdG8gdGhlIHVuZGVybHlpbmcgQXJyYXlCdWZmZXIuIE1ha2Ugc3VyZSB0byBkaXNjYXJkIHRoZSByZXN1bHQgYXMgc29vbiBhcyBwb3NzaWJsZSB0byBwcmV2ZW50IGFueSBtZW1vcnkgbGVha3MuXG4gKiAgICAgICAgICAgIFVzZSBgYnVmZmVyLmNvcHlVaW50OEFycmF5YCB0byBjb3B5IHRoZSByZXN1bHQgaW50byBhIG5ldyBVaW50OEFycmF5LlxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtEZWNvZGVyfSBkZWNvZGVyXG4gKiBAcmV0dXJuIHtVaW50OEFycmF5fVxuICovXG5leHBvcnQgY29uc3QgcmVhZFZhclVpbnQ4QXJyYXkgPSBkZWNvZGVyID0+IHJlYWRVaW50OEFycmF5KGRlY29kZXIsIHJlYWRWYXJVaW50KGRlY29kZXIpKVxuXG4vKipcbiAqIFJlYWQgdGhlIHJlc3Qgb2YgdGhlIGNvbnRlbnQgYXMgYW4gQXJyYXlCdWZmZXJcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtEZWNvZGVyfSBkZWNvZGVyXG4gKiBAcmV0dXJuIHtVaW50OEFycmF5fVxuICovXG5leHBvcnQgY29uc3QgcmVhZFRhaWxBc1VpbnQ4QXJyYXkgPSBkZWNvZGVyID0+IHJlYWRVaW50OEFycmF5KGRlY29kZXIsIGRlY29kZXIuYXJyLmxlbmd0aCAtIGRlY29kZXIucG9zKVxuXG4vKipcbiAqIFNraXAgb25lIGJ5dGUsIGp1bXAgdG8gdGhlIG5leHQgcG9zaXRpb24uXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RGVjb2Rlcn0gZGVjb2RlciBUaGUgZGVjb2RlciBpbnN0YW5jZVxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgbmV4dCBwb3NpdGlvblxuICovXG5leHBvcnQgY29uc3Qgc2tpcDggPSBkZWNvZGVyID0+IGRlY29kZXIucG9zKytcblxuLyoqXG4gKiBSZWFkIG9uZSBieXRlIGFzIHVuc2lnbmVkIGludGVnZXIuXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RGVjb2Rlcn0gZGVjb2RlciBUaGUgZGVjb2RlciBpbnN0YW5jZVxuICogQHJldHVybiB7bnVtYmVyfSBVbnNpZ25lZCA4LWJpdCBpbnRlZ2VyXG4gKi9cbmV4cG9ydCBjb25zdCByZWFkVWludDggPSBkZWNvZGVyID0+IGRlY29kZXIuYXJyW2RlY29kZXIucG9zKytdXG5cbi8qKlxuICogUmVhZCAyIGJ5dGVzIGFzIHVuc2lnbmVkIGludGVnZXIuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0RlY29kZXJ9IGRlY29kZXJcbiAqIEByZXR1cm4ge251bWJlcn0gQW4gdW5zaWduZWQgaW50ZWdlci5cbiAqL1xuZXhwb3J0IGNvbnN0IHJlYWRVaW50MTYgPSBkZWNvZGVyID0+IHtcbiAgY29uc3QgdWludCA9XG4gICAgZGVjb2Rlci5hcnJbZGVjb2Rlci5wb3NdICtcbiAgICAoZGVjb2Rlci5hcnJbZGVjb2Rlci5wb3MgKyAxXSA8PCA4KVxuICBkZWNvZGVyLnBvcyArPSAyXG4gIHJldHVybiB1aW50XG59XG5cbi8qKlxuICogUmVhZCA0IGJ5dGVzIGFzIHVuc2lnbmVkIGludGVnZXIuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0RlY29kZXJ9IGRlY29kZXJcbiAqIEByZXR1cm4ge251bWJlcn0gQW4gdW5zaWduZWQgaW50ZWdlci5cbiAqL1xuZXhwb3J0IGNvbnN0IHJlYWRVaW50MzIgPSBkZWNvZGVyID0+IHtcbiAgY29uc3QgdWludCA9XG4gICAgKGRlY29kZXIuYXJyW2RlY29kZXIucG9zXSArXG4gICAgKGRlY29kZXIuYXJyW2RlY29kZXIucG9zICsgMV0gPDwgOCkgK1xuICAgIChkZWNvZGVyLmFycltkZWNvZGVyLnBvcyArIDJdIDw8IDE2KSArXG4gICAgKGRlY29kZXIuYXJyW2RlY29kZXIucG9zICsgM10gPDwgMjQpKSA+Pj4gMFxuICBkZWNvZGVyLnBvcyArPSA0XG4gIHJldHVybiB1aW50XG59XG5cbi8qKlxuICogUmVhZCA0IGJ5dGVzIGFzIHVuc2lnbmVkIGludGVnZXIgaW4gYmlnIGVuZGlhbiBvcmRlci5cbiAqIChtb3N0IHNpZ25pZmljYW50IGJ5dGUgZmlyc3QpXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0RlY29kZXJ9IGRlY29kZXJcbiAqIEByZXR1cm4ge251bWJlcn0gQW4gdW5zaWduZWQgaW50ZWdlci5cbiAqL1xuZXhwb3J0IGNvbnN0IHJlYWRVaW50MzJCaWdFbmRpYW4gPSBkZWNvZGVyID0+IHtcbiAgY29uc3QgdWludCA9XG4gICAgKGRlY29kZXIuYXJyW2RlY29kZXIucG9zICsgM10gK1xuICAgIChkZWNvZGVyLmFycltkZWNvZGVyLnBvcyArIDJdIDw8IDgpICtcbiAgICAoZGVjb2Rlci5hcnJbZGVjb2Rlci5wb3MgKyAxXSA8PCAxNikgK1xuICAgIChkZWNvZGVyLmFycltkZWNvZGVyLnBvc10gPDwgMjQpKSA+Pj4gMFxuICBkZWNvZGVyLnBvcyArPSA0XG4gIHJldHVybiB1aW50XG59XG5cbi8qKlxuICogTG9vayBhaGVhZCB3aXRob3V0IGluY3JlbWVudGluZyB0aGUgcG9zaXRpb25cbiAqIHRvIHRoZSBuZXh0IGJ5dGUgYW5kIHJlYWQgaXQgYXMgdW5zaWduZWQgaW50ZWdlci5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RGVjb2Rlcn0gZGVjb2RlclxuICogQHJldHVybiB7bnVtYmVyfSBBbiB1bnNpZ25lZCBpbnRlZ2VyLlxuICovXG5leHBvcnQgY29uc3QgcGVla1VpbnQ4ID0gZGVjb2RlciA9PiBkZWNvZGVyLmFycltkZWNvZGVyLnBvc11cblxuLyoqXG4gKiBMb29rIGFoZWFkIHdpdGhvdXQgaW5jcmVtZW50aW5nIHRoZSBwb3NpdGlvblxuICogdG8gdGhlIG5leHQgYnl0ZSBhbmQgcmVhZCBpdCBhcyB1bnNpZ25lZCBpbnRlZ2VyLlxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtEZWNvZGVyfSBkZWNvZGVyXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEFuIHVuc2lnbmVkIGludGVnZXIuXG4gKi9cbmV4cG9ydCBjb25zdCBwZWVrVWludDE2ID0gZGVjb2RlciA9PlxuICBkZWNvZGVyLmFycltkZWNvZGVyLnBvc10gK1xuICAoZGVjb2Rlci5hcnJbZGVjb2Rlci5wb3MgKyAxXSA8PCA4KVxuXG4vKipcbiAqIExvb2sgYWhlYWQgd2l0aG91dCBpbmNyZW1lbnRpbmcgdGhlIHBvc2l0aW9uXG4gKiB0byB0aGUgbmV4dCBieXRlIGFuZCByZWFkIGl0IGFzIHVuc2lnbmVkIGludGVnZXIuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0RlY29kZXJ9IGRlY29kZXJcbiAqIEByZXR1cm4ge251bWJlcn0gQW4gdW5zaWduZWQgaW50ZWdlci5cbiAqL1xuZXhwb3J0IGNvbnN0IHBlZWtVaW50MzIgPSBkZWNvZGVyID0+IChcbiAgZGVjb2Rlci5hcnJbZGVjb2Rlci5wb3NdICtcbiAgKGRlY29kZXIuYXJyW2RlY29kZXIucG9zICsgMV0gPDwgOCkgK1xuICAoZGVjb2Rlci5hcnJbZGVjb2Rlci5wb3MgKyAyXSA8PCAxNikgK1xuICAoZGVjb2Rlci5hcnJbZGVjb2Rlci5wb3MgKyAzXSA8PCAyNClcbikgPj4+IDBcblxuLyoqXG4gKiBSZWFkIHVuc2lnbmVkIGludGVnZXIgKDMyYml0KSB3aXRoIHZhcmlhYmxlIGxlbmd0aC5cbiAqIDEvOHRoIG9mIHRoZSBzdG9yYWdlIGlzIHVzZWQgYXMgZW5jb2Rpbmcgb3ZlcmhlYWQuXG4gKiAgKiBudW1iZXJzIDwgMl43IGlzIHN0b3JlZCBpbiBvbmUgYnl0bGVuZ3RoXG4gKiAgKiBudW1iZXJzIDwgMl4xNCBpcyBzdG9yZWQgaW4gdHdvIGJ5bGVuZ3RoXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0RlY29kZXJ9IGRlY29kZXJcbiAqIEByZXR1cm4ge251bWJlcn0gQW4gdW5zaWduZWQgaW50ZWdlci5sZW5ndGhcbiAqL1xuZXhwb3J0IGNvbnN0IHJlYWRWYXJVaW50ID0gZGVjb2RlciA9PiB7XG4gIGxldCBudW0gPSAwXG4gIGxldCBtdWx0ID0gMVxuICBjb25zdCBsZW4gPSBkZWNvZGVyLmFyci5sZW5ndGhcbiAgd2hpbGUgKGRlY29kZXIucG9zIDwgbGVuKSB7XG4gICAgY29uc3QgciA9IGRlY29kZXIuYXJyW2RlY29kZXIucG9zKytdXG4gICAgLy8gbnVtID0gbnVtIHwgKChyICYgYmluYXJ5LkJJVFM3KSA8PCBsZW4pXG4gICAgbnVtID0gbnVtICsgKHIgJiBiaW5hcnkuQklUUzcpICogbXVsdCAvLyBzaGlmdCAkciA8PCAoNyojaXRlcmF0aW9ucykgYW5kIGFkZCBpdCB0byBudW1cbiAgICBtdWx0ICo9IDEyOCAvLyBuZXh0IGl0ZXJhdGlvbiwgc2hpZnQgNyBcIm1vcmVcIiB0byB0aGUgbGVmdFxuICAgIGlmIChyIDwgYmluYXJ5LkJJVDgpIHtcbiAgICAgIHJldHVybiBudW1cbiAgICB9XG4gICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgaWYgKG51bSA+IG51bWJlci5NQVhfU0FGRV9JTlRFR0VSKSB7XG4gICAgICB0aHJvdyBlcnJvckludGVnZXJPdXRPZlJhbmdlXG4gICAgfVxuICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gIH1cbiAgdGhyb3cgZXJyb3JVbmV4cGVjdGVkRW5kT2ZBcnJheVxufVxuXG4vKipcbiAqIFJlYWQgc2lnbmVkIGludGVnZXIgKDMyYml0KSB3aXRoIHZhcmlhYmxlIGxlbmd0aC5cbiAqIDEvOHRoIG9mIHRoZSBzdG9yYWdlIGlzIHVzZWQgYXMgZW5jb2Rpbmcgb3ZlcmhlYWQuXG4gKiAgKiBudW1iZXJzIDwgMl43IGlzIHN0b3JlZCBpbiBvbmUgYnl0bGVuZ3RoXG4gKiAgKiBudW1iZXJzIDwgMl4xNCBpcyBzdG9yZWQgaW4gdHdvIGJ5bGVuZ3RoXG4gKiBAdG9kbyBUaGlzIHNob3VsZCBwcm9iYWJseSBjcmVhdGUgdGhlIGludmVyc2Ugfm51bSBpZiBudW1iZXIgaXMgbmVnYXRpdmUgLSBidXQgdGhpcyB3b3VsZCBiZSBhIGJyZWFraW5nIGNoYW5nZS5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RGVjb2Rlcn0gZGVjb2RlclxuICogQHJldHVybiB7bnVtYmVyfSBBbiB1bnNpZ25lZCBpbnRlZ2VyLmxlbmd0aFxuICovXG5leHBvcnQgY29uc3QgcmVhZFZhckludCA9IGRlY29kZXIgPT4ge1xuICBsZXQgciA9IGRlY29kZXIuYXJyW2RlY29kZXIucG9zKytdXG4gIGxldCBudW0gPSByICYgYmluYXJ5LkJJVFM2XG4gIGxldCBtdWx0ID0gNjRcbiAgY29uc3Qgc2lnbiA9IChyICYgYmluYXJ5LkJJVDcpID4gMCA/IC0xIDogMVxuICBpZiAoKHIgJiBiaW5hcnkuQklUOCkgPT09IDApIHtcbiAgICAvLyBkb24ndCBjb250aW51ZSByZWFkaW5nXG4gICAgcmV0dXJuIHNpZ24gKiBudW1cbiAgfVxuICBjb25zdCBsZW4gPSBkZWNvZGVyLmFyci5sZW5ndGhcbiAgd2hpbGUgKGRlY29kZXIucG9zIDwgbGVuKSB7XG4gICAgciA9IGRlY29kZXIuYXJyW2RlY29kZXIucG9zKytdXG4gICAgLy8gbnVtID0gbnVtIHwgKChyICYgYmluYXJ5LkJJVFM3KSA8PCBsZW4pXG4gICAgbnVtID0gbnVtICsgKHIgJiBiaW5hcnkuQklUUzcpICogbXVsdFxuICAgIG11bHQgKj0gMTI4XG4gICAgaWYgKHIgPCBiaW5hcnkuQklUOCkge1xuICAgICAgcmV0dXJuIHNpZ24gKiBudW1cbiAgICB9XG4gICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgaWYgKG51bSA+IG51bWJlci5NQVhfU0FGRV9JTlRFR0VSKSB7XG4gICAgICB0aHJvdyBlcnJvckludGVnZXJPdXRPZlJhbmdlXG4gICAgfVxuICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gIH1cbiAgdGhyb3cgZXJyb3JVbmV4cGVjdGVkRW5kT2ZBcnJheVxufVxuXG4vKipcbiAqIExvb2sgYWhlYWQgYW5kIHJlYWQgdmFyVWludCB3aXRob3V0IGluY3JlbWVudGluZyBwb3NpdGlvblxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtEZWNvZGVyfSBkZWNvZGVyXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBwZWVrVmFyVWludCA9IGRlY29kZXIgPT4ge1xuICBjb25zdCBwb3MgPSBkZWNvZGVyLnBvc1xuICBjb25zdCBzID0gcmVhZFZhclVpbnQoZGVjb2RlcilcbiAgZGVjb2Rlci5wb3MgPSBwb3NcbiAgcmV0dXJuIHNcbn1cblxuLyoqXG4gKiBMb29rIGFoZWFkIGFuZCByZWFkIHZhclVpbnQgd2l0aG91dCBpbmNyZW1lbnRpbmcgcG9zaXRpb25cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RGVjb2Rlcn0gZGVjb2RlclxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5leHBvcnQgY29uc3QgcGVla1ZhckludCA9IGRlY29kZXIgPT4ge1xuICBjb25zdCBwb3MgPSBkZWNvZGVyLnBvc1xuICBjb25zdCBzID0gcmVhZFZhckludChkZWNvZGVyKVxuICBkZWNvZGVyLnBvcyA9IHBvc1xuICByZXR1cm4gc1xufVxuXG4vKipcbiAqIFdlIGRvbid0IHRlc3QgdGhpcyBmdW5jdGlvbiBhbnltb3JlIGFzIHdlIHVzZSBuYXRpdmUgZGVjb2RpbmcvZW5jb2RpbmcgYnkgZGVmYXVsdCBub3cuXG4gKiBCZXR0ZXIgbm90IG1vZGlmeSB0aGlzIGFueW1vcmUuLlxuICpcbiAqIFRyYW5zZm9ybWluZyB1dGY4IHRvIGEgc3RyaW5nIGlzIHByZXR0eSBleHBlbnNpdmUuIFRoZSBjb2RlIHBlcmZvcm1zIDEweCBiZXR0ZXJcbiAqIHdoZW4gU3RyaW5nLmZyb21Db2RlUG9pbnQgaXMgZmVkIHdpdGggYWxsIGNoYXJhY3RlcnMgYXMgYXJndW1lbnRzLlxuICogQnV0IG1vc3QgZW52aXJvbm1lbnRzIGhhdmUgYSBtYXhpbXVtIG51bWJlciBvZiBhcmd1bWVudHMgcGVyIGZ1bmN0aW9ucy5cbiAqIEZvciBlZmZpZW5jeSByZWFzb25zIHdlIGFwcGx5IGEgbWF4aW11bSBvZiAxMDAwMCBjaGFyYWN0ZXJzIGF0IG9uY2UuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0RlY29kZXJ9IGRlY29kZXJcbiAqIEByZXR1cm4ge1N0cmluZ30gVGhlIHJlYWQgU3RyaW5nLlxuICovXG4vKiBjOCBpZ25vcmUgc3RhcnQgKi9cbmV4cG9ydCBjb25zdCBfcmVhZFZhclN0cmluZ1BvbHlmaWxsID0gZGVjb2RlciA9PiB7XG4gIGxldCByZW1haW5pbmdMZW4gPSByZWFkVmFyVWludChkZWNvZGVyKVxuICBpZiAocmVtYWluaW5nTGVuID09PSAwKSB7XG4gICAgcmV0dXJuICcnXG4gIH0gZWxzZSB7XG4gICAgbGV0IGVuY29kZWRTdHJpbmcgPSBTdHJpbmcuZnJvbUNvZGVQb2ludChyZWFkVWludDgoZGVjb2RlcikpIC8vIHJlbWVtYmVyIHRvIGRlY3JlYXNlIHJlbWFpbmluZ0xlblxuICAgIGlmICgtLXJlbWFpbmluZ0xlbiA8IDEwMCkgeyAvLyBkbyBub3QgY3JlYXRlIGEgVWludDhBcnJheSBmb3Igc21hbGwgc3RyaW5nc1xuICAgICAgd2hpbGUgKHJlbWFpbmluZ0xlbi0tKSB7XG4gICAgICAgIGVuY29kZWRTdHJpbmcgKz0gU3RyaW5nLmZyb21Db2RlUG9pbnQocmVhZFVpbnQ4KGRlY29kZXIpKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB3aGlsZSAocmVtYWluaW5nTGVuID4gMCkge1xuICAgICAgICBjb25zdCBuZXh0TGVuID0gcmVtYWluaW5nTGVuIDwgMTAwMDAgPyByZW1haW5pbmdMZW4gOiAxMDAwMFxuICAgICAgICAvLyB0aGlzIGlzIGRhbmdlcm91cywgd2UgY3JlYXRlIGEgZnJlc2ggYXJyYXkgdmlldyBmcm9tIHRoZSBleGlzdGluZyBidWZmZXJcbiAgICAgICAgY29uc3QgYnl0ZXMgPSBkZWNvZGVyLmFyci5zdWJhcnJheShkZWNvZGVyLnBvcywgZGVjb2Rlci5wb3MgKyBuZXh0TGVuKVxuICAgICAgICBkZWNvZGVyLnBvcyArPSBuZXh0TGVuXG4gICAgICAgIC8vIFN0YXJ0aW5nIHdpdGggRVM1LjEgd2UgY2FuIHN1cHBseSBhIGdlbmVyaWMgYXJyYXktbGlrZSBvYmplY3QgYXMgYXJndW1lbnRzXG4gICAgICAgIGVuY29kZWRTdHJpbmcgKz0gU3RyaW5nLmZyb21Db2RlUG9pbnQuYXBwbHkobnVsbCwgLyoqIEB0eXBlIHthbnl9ICovIChieXRlcykpXG4gICAgICAgIHJlbWFpbmluZ0xlbiAtPSBuZXh0TGVuXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoZXNjYXBlKGVuY29kZWRTdHJpbmcpKVxuICB9XG59XG4vKiBjOCBpZ25vcmUgc3RvcCAqL1xuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtEZWNvZGVyfSBkZWNvZGVyXG4gKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSByZWFkIFN0cmluZ1xuICovXG5leHBvcnQgY29uc3QgX3JlYWRWYXJTdHJpbmdOYXRpdmUgPSBkZWNvZGVyID0+XG4gIC8qKiBAdHlwZSBhbnkgKi8gKHN0cmluZy51dGY4VGV4dERlY29kZXIpLmRlY29kZShyZWFkVmFyVWludDhBcnJheShkZWNvZGVyKSlcblxuLyoqXG4gKiBSZWFkIHN0cmluZyBvZiB2YXJpYWJsZSBsZW5ndGhcbiAqICogdmFyVWludCBpcyB1c2VkIHRvIHN0b3JlIHRoZSBsZW5ndGggb2YgdGhlIHN0cmluZ1xuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtEZWNvZGVyfSBkZWNvZGVyXG4gKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSByZWFkIFN0cmluZ1xuICpcbiAqL1xuLyogYzggaWdub3JlIG5leHQgKi9cbmV4cG9ydCBjb25zdCByZWFkVmFyU3RyaW5nID0gc3RyaW5nLnV0ZjhUZXh0RGVjb2RlciA/IF9yZWFkVmFyU3RyaW5nTmF0aXZlIDogX3JlYWRWYXJTdHJpbmdQb2x5ZmlsbFxuXG4vKipcbiAqIEBwYXJhbSB7RGVjb2Rlcn0gZGVjb2RlclxuICogQHJldHVybiB7VWludDhBcnJheX1cbiAqL1xuZXhwb3J0IGNvbnN0IHJlYWRUZXJtaW5hdGVkVWludDhBcnJheSA9IGRlY29kZXIgPT4ge1xuICBjb25zdCBlbmNvZGVyID0gZW5jb2RpbmcuY3JlYXRlRW5jb2RlcigpXG4gIGxldCBiXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgYiA9IHJlYWRVaW50OChkZWNvZGVyKVxuICAgIGlmIChiID09PSAwKSB7XG4gICAgICByZXR1cm4gZW5jb2RpbmcudG9VaW50OEFycmF5KGVuY29kZXIpXG4gICAgfVxuICAgIGlmIChiID09PSAxKSB7XG4gICAgICBiID0gcmVhZFVpbnQ4KGRlY29kZXIpXG4gICAgfVxuICAgIGVuY29kaW5nLndyaXRlKGVuY29kZXIsIGIpXG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0RlY29kZXJ9IGRlY29kZXJcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGNvbnN0IHJlYWRUZXJtaW5hdGVkU3RyaW5nID0gZGVjb2RlciA9PiBzdHJpbmcuZGVjb2RlVXRmOChyZWFkVGVybWluYXRlZFVpbnQ4QXJyYXkoZGVjb2RlcikpXG5cbi8qKlxuICogTG9vayBhaGVhZCBhbmQgcmVhZCB2YXJTdHJpbmcgd2l0aG91dCBpbmNyZW1lbnRpbmcgcG9zaXRpb25cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RGVjb2Rlcn0gZGVjb2RlclxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5leHBvcnQgY29uc3QgcGVla1ZhclN0cmluZyA9IGRlY29kZXIgPT4ge1xuICBjb25zdCBwb3MgPSBkZWNvZGVyLnBvc1xuICBjb25zdCBzID0gcmVhZFZhclN0cmluZyhkZWNvZGVyKVxuICBkZWNvZGVyLnBvcyA9IHBvc1xuICByZXR1cm4gc1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RGVjb2Rlcn0gZGVjb2RlclxuICogQHBhcmFtIHtudW1iZXJ9IGxlblxuICogQHJldHVybiB7RGF0YVZpZXd9XG4gKi9cbmV4cG9ydCBjb25zdCByZWFkRnJvbURhdGFWaWV3ID0gKGRlY29kZXIsIGxlbikgPT4ge1xuICBjb25zdCBkdiA9IG5ldyBEYXRhVmlldyhkZWNvZGVyLmFyci5idWZmZXIsIGRlY29kZXIuYXJyLmJ5dGVPZmZzZXQgKyBkZWNvZGVyLnBvcywgbGVuKVxuICBkZWNvZGVyLnBvcyArPSBsZW5cbiAgcmV0dXJuIGR2XG59XG5cbi8qKlxuICogQHBhcmFtIHtEZWNvZGVyfSBkZWNvZGVyXG4gKi9cbmV4cG9ydCBjb25zdCByZWFkRmxvYXQzMiA9IGRlY29kZXIgPT4gcmVhZEZyb21EYXRhVmlldyhkZWNvZGVyLCA0KS5nZXRGbG9hdDMyKDAsIGZhbHNlKVxuXG4vKipcbiAqIEBwYXJhbSB7RGVjb2Rlcn0gZGVjb2RlclxuICovXG5leHBvcnQgY29uc3QgcmVhZEZsb2F0NjQgPSBkZWNvZGVyID0+IHJlYWRGcm9tRGF0YVZpZXcoZGVjb2RlciwgOCkuZ2V0RmxvYXQ2NCgwLCBmYWxzZSlcblxuLyoqXG4gKiBAcGFyYW0ge0RlY29kZXJ9IGRlY29kZXJcbiAqL1xuZXhwb3J0IGNvbnN0IHJlYWRCaWdJbnQ2NCA9IGRlY29kZXIgPT4gLyoqIEB0eXBlIHthbnl9ICovIChyZWFkRnJvbURhdGFWaWV3KGRlY29kZXIsIDgpKS5nZXRCaWdJbnQ2NCgwLCBmYWxzZSlcblxuLyoqXG4gKiBAcGFyYW0ge0RlY29kZXJ9IGRlY29kZXJcbiAqL1xuZXhwb3J0IGNvbnN0IHJlYWRCaWdVaW50NjQgPSBkZWNvZGVyID0+IC8qKiBAdHlwZSB7YW55fSAqLyAocmVhZEZyb21EYXRhVmlldyhkZWNvZGVyLCA4KSkuZ2V0QmlnVWludDY0KDAsIGZhbHNlKVxuXG4vKipcbiAqIEB0eXBlIHtBcnJheTxmdW5jdGlvbihEZWNvZGVyKTphbnk+fVxuICovXG5jb25zdCByZWFkQW55TG9va3VwVGFibGUgPSBbXG4gIGRlY29kZXIgPT4gdW5kZWZpbmVkLCAvLyBDQVNFIDEyNzogdW5kZWZpbmVkXG4gIGRlY29kZXIgPT4gbnVsbCwgLy8gQ0FTRSAxMjY6IG51bGxcbiAgcmVhZFZhckludCwgLy8gQ0FTRSAxMjU6IGludGVnZXJcbiAgcmVhZEZsb2F0MzIsIC8vIENBU0UgMTI0OiBmbG9hdDMyXG4gIHJlYWRGbG9hdDY0LCAvLyBDQVNFIDEyMzogZmxvYXQ2NFxuICByZWFkQmlnSW50NjQsIC8vIENBU0UgMTIyOiBiaWdpbnRcbiAgZGVjb2RlciA9PiBmYWxzZSwgLy8gQ0FTRSAxMjE6IGJvb2xlYW4gKGZhbHNlKVxuICBkZWNvZGVyID0+IHRydWUsIC8vIENBU0UgMTIwOiBib29sZWFuICh0cnVlKVxuICByZWFkVmFyU3RyaW5nLCAvLyBDQVNFIDExOTogc3RyaW5nXG4gIGRlY29kZXIgPT4geyAvLyBDQVNFIDExODogb2JqZWN0PHN0cmluZyxhbnk+XG4gICAgY29uc3QgbGVuID0gcmVhZFZhclVpbnQoZGVjb2RlcilcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7T2JqZWN0PHN0cmluZyxhbnk+fVxuICAgICAqL1xuICAgIGNvbnN0IG9iaiA9IHt9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgY29uc3Qga2V5ID0gcmVhZFZhclN0cmluZyhkZWNvZGVyKVxuICAgICAgb2JqW2tleV0gPSByZWFkQW55KGRlY29kZXIpXG4gICAgfVxuICAgIHJldHVybiBvYmpcbiAgfSxcbiAgZGVjb2RlciA9PiB7IC8vIENBU0UgMTE3OiBhcnJheTxhbnk+XG4gICAgY29uc3QgbGVuID0gcmVhZFZhclVpbnQoZGVjb2RlcilcbiAgICBjb25zdCBhcnIgPSBbXVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGFyci5wdXNoKHJlYWRBbnkoZGVjb2RlcikpXG4gICAgfVxuICAgIHJldHVybiBhcnJcbiAgfSxcbiAgcmVhZFZhclVpbnQ4QXJyYXkgLy8gQ0FTRSAxMTY6IFVpbnQ4QXJyYXlcbl1cblxuLyoqXG4gKiBAcGFyYW0ge0RlY29kZXJ9IGRlY29kZXJcbiAqL1xuZXhwb3J0IGNvbnN0IHJlYWRBbnkgPSBkZWNvZGVyID0+IHJlYWRBbnlMb29rdXBUYWJsZVsxMjcgLSByZWFkVWludDgoZGVjb2RlcildKGRlY29kZXIpXG5cbi8qKlxuICogVCBtdXN0IG5vdCBiZSBudWxsLlxuICpcbiAqIEB0ZW1wbGF0ZSBUXG4gKi9cbmV4cG9ydCBjbGFzcyBSbGVEZWNvZGVyIGV4dGVuZHMgRGVjb2RlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHVpbnQ4QXJyYXlcbiAgICogQHBhcmFtIHtmdW5jdGlvbihEZWNvZGVyKTpUfSByZWFkZXJcbiAgICovXG4gIGNvbnN0cnVjdG9yICh1aW50OEFycmF5LCByZWFkZXIpIHtcbiAgICBzdXBlcih1aW50OEFycmF5KVxuICAgIC8qKlxuICAgICAqIFRoZSByZWFkZXJcbiAgICAgKi9cbiAgICB0aGlzLnJlYWRlciA9IHJlYWRlclxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgc3RhdGVcbiAgICAgKiBAdHlwZSB7VHxudWxsfVxuICAgICAqL1xuICAgIHRoaXMucyA9IG51bGxcbiAgICB0aGlzLmNvdW50ID0gMFxuICB9XG5cbiAgcmVhZCAoKSB7XG4gICAgaWYgKHRoaXMuY291bnQgPT09IDApIHtcbiAgICAgIHRoaXMucyA9IHRoaXMucmVhZGVyKHRoaXMpXG4gICAgICBpZiAoaGFzQ29udGVudCh0aGlzKSkge1xuICAgICAgICB0aGlzLmNvdW50ID0gcmVhZFZhclVpbnQodGhpcykgKyAxIC8vIHNlZSBlbmNvZGVyIGltcGxlbWVudGF0aW9uIGZvciB0aGUgcmVhc29uIHdoeSB0aGlzIGlzIGluY3JlbWVudGVkXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNvdW50ID0gLTEgLy8gcmVhZCB0aGUgY3VycmVudCB2YWx1ZSBmb3JldmVyXG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuY291bnQtLVxuICAgIHJldHVybiAvKiogQHR5cGUge1R9ICovICh0aGlzLnMpXG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEludERpZmZEZWNvZGVyIGV4dGVuZHMgRGVjb2RlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHVpbnQ4QXJyYXlcbiAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0XG4gICAqL1xuICBjb25zdHJ1Y3RvciAodWludDhBcnJheSwgc3RhcnQpIHtcbiAgICBzdXBlcih1aW50OEFycmF5KVxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgc3RhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucyA9IHN0YXJ0XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgcmVhZCAoKSB7XG4gICAgdGhpcy5zICs9IHJlYWRWYXJJbnQodGhpcylcbiAgICByZXR1cm4gdGhpcy5zXG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFJsZUludERpZmZEZWNvZGVyIGV4dGVuZHMgRGVjb2RlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHVpbnQ4QXJyYXlcbiAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0XG4gICAqL1xuICBjb25zdHJ1Y3RvciAodWludDhBcnJheSwgc3RhcnQpIHtcbiAgICBzdXBlcih1aW50OEFycmF5KVxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgc3RhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucyA9IHN0YXJ0XG4gICAgdGhpcy5jb3VudCA9IDBcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICByZWFkICgpIHtcbiAgICBpZiAodGhpcy5jb3VudCA9PT0gMCkge1xuICAgICAgdGhpcy5zICs9IHJlYWRWYXJJbnQodGhpcylcbiAgICAgIGlmIChoYXNDb250ZW50KHRoaXMpKSB7XG4gICAgICAgIHRoaXMuY291bnQgPSByZWFkVmFyVWludCh0aGlzKSArIDEgLy8gc2VlIGVuY29kZXIgaW1wbGVtZW50YXRpb24gZm9yIHRoZSByZWFzb24gd2h5IHRoaXMgaXMgaW5jcmVtZW50ZWRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY291bnQgPSAtMSAvLyByZWFkIHRoZSBjdXJyZW50IHZhbHVlIGZvcmV2ZXJcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5jb3VudC0tXG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAodGhpcy5zKVxuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBVaW50T3B0UmxlRGVjb2RlciBleHRlbmRzIERlY29kZXIge1xuICAvKipcbiAgICogQHBhcmFtIHtVaW50OEFycmF5fSB1aW50OEFycmF5XG4gICAqL1xuICBjb25zdHJ1Y3RvciAodWludDhBcnJheSkge1xuICAgIHN1cGVyKHVpbnQ4QXJyYXkpXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnMgPSAwXG4gICAgdGhpcy5jb3VudCA9IDBcbiAgfVxuXG4gIHJlYWQgKCkge1xuICAgIGlmICh0aGlzLmNvdW50ID09PSAwKSB7XG4gICAgICB0aGlzLnMgPSByZWFkVmFySW50KHRoaXMpXG4gICAgICAvLyBpZiB0aGUgc2lnbiBpcyBuZWdhdGl2ZSwgd2UgcmVhZCB0aGUgY291bnQgdG9vLCBvdGhlcndpc2UgY291bnQgaXMgMVxuICAgICAgY29uc3QgaXNOZWdhdGl2ZSA9IG1hdGguaXNOZWdhdGl2ZVplcm8odGhpcy5zKVxuICAgICAgdGhpcy5jb3VudCA9IDFcbiAgICAgIGlmIChpc05lZ2F0aXZlKSB7XG4gICAgICAgIHRoaXMucyA9IC10aGlzLnNcbiAgICAgICAgdGhpcy5jb3VudCA9IHJlYWRWYXJVaW50KHRoaXMpICsgMlxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmNvdW50LS1cbiAgICByZXR1cm4gLyoqIEB0eXBlIHtudW1iZXJ9ICovICh0aGlzLnMpXG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEluY1VpbnRPcHRSbGVEZWNvZGVyIGV4dGVuZHMgRGVjb2RlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHVpbnQ4QXJyYXlcbiAgICovXG4gIGNvbnN0cnVjdG9yICh1aW50OEFycmF5KSB7XG4gICAgc3VwZXIodWludDhBcnJheSlcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucyA9IDBcbiAgICB0aGlzLmNvdW50ID0gMFxuICB9XG5cbiAgcmVhZCAoKSB7XG4gICAgaWYgKHRoaXMuY291bnQgPT09IDApIHtcbiAgICAgIHRoaXMucyA9IHJlYWRWYXJJbnQodGhpcylcbiAgICAgIC8vIGlmIHRoZSBzaWduIGlzIG5lZ2F0aXZlLCB3ZSByZWFkIHRoZSBjb3VudCB0b28sIG90aGVyd2lzZSBjb3VudCBpcyAxXG4gICAgICBjb25zdCBpc05lZ2F0aXZlID0gbWF0aC5pc05lZ2F0aXZlWmVybyh0aGlzLnMpXG4gICAgICB0aGlzLmNvdW50ID0gMVxuICAgICAgaWYgKGlzTmVnYXRpdmUpIHtcbiAgICAgICAgdGhpcy5zID0gLXRoaXMuc1xuICAgICAgICB0aGlzLmNvdW50ID0gcmVhZFZhclVpbnQodGhpcykgKyAyXG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuY291bnQtLVxuICAgIHJldHVybiAvKiogQHR5cGUge251bWJlcn0gKi8gKHRoaXMucysrKVxuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBJbnREaWZmT3B0UmxlRGVjb2RlciBleHRlbmRzIERlY29kZXIge1xuICAvKipcbiAgICogQHBhcmFtIHtVaW50OEFycmF5fSB1aW50OEFycmF5XG4gICAqL1xuICBjb25zdHJ1Y3RvciAodWludDhBcnJheSkge1xuICAgIHN1cGVyKHVpbnQ4QXJyYXkpXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnMgPSAwXG4gICAgdGhpcy5jb3VudCA9IDBcbiAgICB0aGlzLmRpZmYgPSAwXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgcmVhZCAoKSB7XG4gICAgaWYgKHRoaXMuY291bnQgPT09IDApIHtcbiAgICAgIGNvbnN0IGRpZmYgPSByZWFkVmFySW50KHRoaXMpXG4gICAgICAvLyBpZiB0aGUgZmlyc3QgYml0IGlzIHNldCwgd2UgcmVhZCBtb3JlIGRhdGFcbiAgICAgIGNvbnN0IGhhc0NvdW50ID0gZGlmZiAmIDFcbiAgICAgIHRoaXMuZGlmZiA9IG1hdGguZmxvb3IoZGlmZiAvIDIpIC8vIHNoaWZ0ID4+IDFcbiAgICAgIHRoaXMuY291bnQgPSAxXG4gICAgICBpZiAoaGFzQ291bnQpIHtcbiAgICAgICAgdGhpcy5jb3VudCA9IHJlYWRWYXJVaW50KHRoaXMpICsgMlxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnMgKz0gdGhpcy5kaWZmXG4gICAgdGhpcy5jb3VudC0tXG4gICAgcmV0dXJuIHRoaXMuc1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBTdHJpbmdEZWNvZGVyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7VWludDhBcnJheX0gdWludDhBcnJheVxuICAgKi9cbiAgY29uc3RydWN0b3IgKHVpbnQ4QXJyYXkpIHtcbiAgICB0aGlzLmRlY29kZXIgPSBuZXcgVWludE9wdFJsZURlY29kZXIodWludDhBcnJheSlcbiAgICB0aGlzLnN0ciA9IHJlYWRWYXJTdHJpbmcodGhpcy5kZWNvZGVyKVxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5zcG9zID0gMFxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHJlYWQgKCkge1xuICAgIGNvbnN0IGVuZCA9IHRoaXMuc3BvcyArIHRoaXMuZGVjb2Rlci5yZWFkKClcbiAgICBjb25zdCByZXMgPSB0aGlzLnN0ci5zbGljZSh0aGlzLnNwb3MsIGVuZClcbiAgICB0aGlzLnNwb3MgPSBlbmRcbiAgICByZXR1cm4gcmVzXG4gIH1cbn1cbiIsICIvKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cblxuZXhwb3J0IGNvbnN0IHN1YnRsZSA9IGNyeXB0by5zdWJ0bGVcbmV4cG9ydCBjb25zdCBnZXRSYW5kb21WYWx1ZXMgPSBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzLmJpbmQoY3J5cHRvKVxuIiwgIi8qKlxuICogSXNvbW9ycGhpYyBtb2R1bGUgZm9yIHRydWUgcmFuZG9tIG51bWJlcnMgLyBidWZmZXJzIC8gdXVpZHMuXG4gKlxuICogQXR0ZW50aW9uOiBmYWxscyBiYWNrIHRvIE1hdGgucmFuZG9tIGlmIHRoZSBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgY3J5cHRvLlxuICpcbiAqIEBtb2R1bGUgcmFuZG9tXG4gKi9cblxuaW1wb3J0ICogYXMgbWF0aCBmcm9tICcuL21hdGguanMnXG5pbXBvcnQgKiBhcyBiaW5hcnkgZnJvbSAnLi9iaW5hcnkuanMnXG5pbXBvcnQgeyBnZXRSYW5kb21WYWx1ZXMgfSBmcm9tICdsaWIwL3dlYmNyeXB0bydcblxuZXhwb3J0IGNvbnN0IHJhbmQgPSBNYXRoLnJhbmRvbVxuXG5leHBvcnQgY29uc3QgdWludDMyID0gKCkgPT4gZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50MzJBcnJheSgxKSlbMF1cblxuZXhwb3J0IGNvbnN0IHVpbnQ1MyA9ICgpID0+IHtcbiAgY29uc3QgYXJyID0gZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50MzJBcnJheSg4KSlcbiAgcmV0dXJuIChhcnJbMF0gJiBiaW5hcnkuQklUUzIxKSAqIChiaW5hcnkuQklUUzMyICsgMSkgKyAoYXJyWzFdID4+PiAwKVxufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge0FycmF5PFQ+fSBhcnJcbiAqIEByZXR1cm4ge1R9XG4gKi9cbmV4cG9ydCBjb25zdCBvbmVPZiA9IGFyciA9PiBhcnJbbWF0aC5mbG9vcihyYW5kKCkgKiBhcnIubGVuZ3RoKV1cblxuLy8gQHRzLWlnbm9yZVxuY29uc3QgdXVpZHY0VGVtcGxhdGUgPSBbMWU3XSArIC0xZTMgKyAtNGUzICsgLThlMyArIC0xZTExXG5cbi8qKlxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5leHBvcnQgY29uc3QgdXVpZHY0ID0gKCkgPT4gdXVpZHY0VGVtcGxhdGUucmVwbGFjZSgvWzAxOF0vZywgLyoqIEBwYXJhbSB7bnVtYmVyfSBjICovIGMgPT5cbiAgKGMgXiB1aW50MzIoKSAmIDE1ID4+IGMgLyA0KS50b1N0cmluZygxNilcbilcbiIsICIvKipcbiAqIFV0aWxpdHkgaGVscGVycyB0byB3b3JrIHdpdGggcHJvbWlzZXMuXG4gKlxuICogQG1vZHVsZSBwcm9taXNlXG4gKi9cblxuaW1wb3J0ICogYXMgdGltZSBmcm9tICcuL3RpbWUuanMnXG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEBjYWxsYmFjayBQcm9taXNlUmVzb2x2ZVxuICogQHBhcmFtIHtUfFByb21pc2VMaWtlPFQ+fSBbcmVzdWx0XVxuICovXG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oUHJvbWlzZVJlc29sdmU8VD4sZnVuY3Rpb24oRXJyb3IpOnZvaWQpOmFueX0gZlxuICogQHJldHVybiB7UHJvbWlzZTxUPn1cbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZSA9IGYgPT4gLyoqIEB0eXBlIHtQcm9taXNlPFQ+fSAqLyAobmV3IFByb21pc2UoZikpXG5cbi8qKlxuICogQHBhcmFtIHtmdW5jdGlvbihmdW5jdGlvbigpOnZvaWQsZnVuY3Rpb24oRXJyb3IpOnZvaWQpOnZvaWR9IGZcbiAqIEByZXR1cm4ge1Byb21pc2U8dm9pZD59XG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVFbXB0eSA9IGYgPT4gbmV3IFByb21pc2UoZilcblxuLyoqXG4gKiBgUHJvbWlzZS5hbGxgIHdhaXQgZm9yIGFsbCBwcm9taXNlcyBpbiB0aGUgYXJyYXkgdG8gcmVzb2x2ZSBhbmQgcmV0dXJuIHRoZSByZXN1bHRcbiAqIEB0ZW1wbGF0ZSB7dW5rbm93bltdIHwgW119IFBTXG4gKlxuICogQHBhcmFtIHtQU30gcHNcbiAqIEByZXR1cm4ge1Byb21pc2U8eyAtcmVhZG9ubHkgW1AgaW4ga2V5b2YgUFNdOiBBd2FpdGVkPFBTW1BdPiB9Pn1cbiAqL1xuZXhwb3J0IGNvbnN0IGFsbCA9IFByb21pc2UuYWxsLmJpbmQoUHJvbWlzZSlcblxuLyoqXG4gKiBAcGFyYW0ge0Vycm9yfSBbcmVhc29uXVxuICogQHJldHVybiB7UHJvbWlzZTxuZXZlcj59XG4gKi9cbmV4cG9ydCBjb25zdCByZWplY3QgPSByZWFzb24gPT4gUHJvbWlzZS5yZWplY3QocmVhc29uKVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge1R8dm9pZH0gcmVzXG4gKiBAcmV0dXJuIHtQcm9taXNlPFR8dm9pZD59XG4gKi9cbmV4cG9ydCBjb25zdCByZXNvbHZlID0gcmVzID0+IFByb21pc2UucmVzb2x2ZShyZXMpXG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7VH0gcmVzXG4gKiBAcmV0dXJuIHtQcm9taXNlPFQ+fVxuICovXG5leHBvcnQgY29uc3QgcmVzb2x2ZVdpdGggPSByZXMgPT4gUHJvbWlzZS5yZXNvbHZlKHJlcylcblxuLyoqXG4gKiBAdG9kbyBOZXh0IHZlcnNpb24sIHJlb3JkZXIgcGFyYW1ldGVyczogY2hlY2ssIFt0aW1lb3V0LCBbaW50ZXJ2YWxSZXNvbHV0aW9uXV1cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gdGltZW91dFxuICogQHBhcmFtIHtmdW5jdGlvbigpOmJvb2xlYW59IGNoZWNrXG4gKiBAcGFyYW0ge251bWJlcn0gW2ludGVydmFsUmVzb2x1dGlvbl1cbiAqIEByZXR1cm4ge1Byb21pc2U8dm9pZD59XG4gKi9cbmV4cG9ydCBjb25zdCB1bnRpbCA9ICh0aW1lb3V0LCBjaGVjaywgaW50ZXJ2YWxSZXNvbHV0aW9uID0gMTApID0+IGNyZWF0ZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gIGNvbnN0IHN0YXJ0VGltZSA9IHRpbWUuZ2V0VW5peFRpbWUoKVxuICBjb25zdCBoYXNUaW1lb3V0ID0gdGltZW91dCA+IDBcbiAgY29uc3QgdW50aWxJbnRlcnZhbCA9ICgpID0+IHtcbiAgICBpZiAoY2hlY2soKSkge1xuICAgICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbEhhbmRsZSlcbiAgICAgIHJlc29sdmUoKVxuICAgIH0gZWxzZSBpZiAoaGFzVGltZW91dCkge1xuICAgICAgLyogYzggaWdub3JlIGVsc2UgKi9cbiAgICAgIGlmICh0aW1lLmdldFVuaXhUaW1lKCkgLSBzdGFydFRpbWUgPiB0aW1lb3V0KSB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWxIYW5kbGUpXG4gICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ1RpbWVvdXQnKSlcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY29uc3QgaW50ZXJ2YWxIYW5kbGUgPSBzZXRJbnRlcnZhbCh1bnRpbEludGVydmFsLCBpbnRlcnZhbFJlc29sdXRpb24pXG59KVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lb3V0XG4gKiBAcmV0dXJuIHtQcm9taXNlPHVuZGVmaW5lZD59XG4gKi9cbmV4cG9ydCBjb25zdCB3YWl0ID0gdGltZW91dCA9PiBjcmVhdGUoKHJlc29sdmUsIHJlamVjdCkgPT4gc2V0VGltZW91dChyZXNvbHZlLCB0aW1lb3V0KSlcblxuLyoqXG4gKiBDaGVja3MgaWYgYW4gb2JqZWN0IGlzIGEgcHJvbWlzZSB1c2luZyBkdWNrdHlwaW5nLlxuICpcbiAqIFByb21pc2VzIGFyZSBvZnRlbiBwb2x5ZmlsbGVkLCBzbyBpdCBtYWtlcyBzZW5zZSB0byBhZGQgc29tZSBhZGRpdGlvbmFsIGd1YXJhbnRlZXMgaWYgdGhlIHVzZXIgb2YgdGhpc1xuICogbGlicmFyeSBoYXMgc29tZSBpbnNhbmUgZW52aXJvbm1lbnQgd2hlcmUgZ2xvYmFsIFByb21pc2Ugb2JqZWN0cyBhcmUgb3ZlcndyaXR0ZW4uXG4gKlxuICogQHBhcmFtIHthbnl9IHBcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBjb25zdCBpc1Byb21pc2UgPSBwID0+IHAgaW5zdGFuY2VvZiBQcm9taXNlIHx8IChwICYmIHAudGhlbiAmJiBwLmNhdGNoICYmIHAuZmluYWxseSlcbiIsICIvKipcbiAqIE9mdGVuIHVzZWQgY29uZGl0aW9ucy5cbiAqXG4gKiBAbW9kdWxlIGNvbmRpdGlvbnNcbiAqL1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge1R8bnVsbHx1bmRlZmluZWR9IHZcbiAqIEByZXR1cm4ge1R8bnVsbH1cbiAqL1xuLyogYzggaWdub3JlIG5leHQgKi9cbmV4cG9ydCBjb25zdCB1bmRlZmluZWRUb051bGwgPSB2ID0+IHYgPT09IHVuZGVmaW5lZCA/IG51bGwgOiB2XG4iLCAiLyogZXNsaW50LWVudiBicm93c2VyICovXG5cbi8qKlxuICogSXNvbW9ycGhpYyB2YXJpYWJsZSBzdG9yYWdlLlxuICpcbiAqIFVzZXMgTG9jYWxTdG9yYWdlIGluIHRoZSBicm93c2VyIGFuZCBmYWxscyBiYWNrIHRvIGluLW1lbW9yeSBzdG9yYWdlLlxuICpcbiAqIEBtb2R1bGUgc3RvcmFnZVxuICovXG5cbi8qIGM4IGlnbm9yZSBzdGFydCAqL1xuY2xhc3MgVmFyU3RvcmFnZVBvbHlmaWxsIHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHRoaXMubWFwID0gbmV3IE1hcCgpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgKiBAcGFyYW0ge2FueX0gbmV3VmFsdWVcbiAgICovXG4gIHNldEl0ZW0gKGtleSwgbmV3VmFsdWUpIHtcbiAgICB0aGlzLm1hcC5zZXQoa2V5LCBuZXdWYWx1ZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAqL1xuICBnZXRJdGVtIChrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5tYXAuZ2V0KGtleSlcbiAgfVxufVxuLyogYzggaWdub3JlIHN0b3AgKi9cblxuLyoqXG4gKiBAdHlwZSB7YW55fVxuICovXG5sZXQgX2xvY2FsU3RvcmFnZSA9IG5ldyBWYXJTdG9yYWdlUG9seWZpbGwoKVxubGV0IHVzZVBvbHlmaWxsID0gdHJ1ZVxuXG4vKiBjOCBpZ25vcmUgc3RhcnQgKi9cbnRyeSB7XG4gIC8vIGlmIHRoZSBzYW1lLW9yaWdpbiBydWxlIGlzIHZpb2xhdGVkLCBhY2Nlc3NpbmcgbG9jYWxTdG9yYWdlIG1pZ2h0IHRocm93biBhbiBlcnJvclxuICBpZiAodHlwZW9mIGxvY2FsU3RvcmFnZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbG9jYWxTdG9yYWdlKSB7XG4gICAgX2xvY2FsU3RvcmFnZSA9IGxvY2FsU3RvcmFnZVxuICAgIHVzZVBvbHlmaWxsID0gZmFsc2VcbiAgfVxufSBjYXRjaCAoZSkgeyB9XG4vKiBjOCBpZ25vcmUgc3RvcCAqL1xuXG4vKipcbiAqIFRoaXMgaXMgYmFzaWNhbGx5IGxvY2FsU3RvcmFnZSBpbiBicm93c2VyLCBvciBhIHBvbHlmaWxsIGluIG5vZGVqc1xuICovXG4vKiBjOCBpZ25vcmUgbmV4dCAqL1xuZXhwb3J0IGNvbnN0IHZhclN0b3JhZ2UgPSBfbG9jYWxTdG9yYWdlXG5cbi8qKlxuICogQSBwb2x5ZmlsbCBmb3IgYGFkZEV2ZW50TGlzdGVuZXIoJ3N0b3JhZ2UnLCBldmVudCA9PiB7Li59KWAgdGhhdCBkb2VzIG5vdGhpbmcgaWYgdGhlIHBvbHlmaWxsIGlzIGJlaW5nIHVzZWQuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbih7IGtleTogc3RyaW5nLCBuZXdWYWx1ZTogc3RyaW5nLCBvbGRWYWx1ZTogc3RyaW5nIH0pOiB2b2lkfSBldmVudEhhbmRsZXJcbiAqIEBmdW5jdGlvblxuICovXG4vKiBjOCBpZ25vcmUgbmV4dCAqL1xuZXhwb3J0IGNvbnN0IG9uQ2hhbmdlID0gZXZlbnRIYW5kbGVyID0+IHVzZVBvbHlmaWxsIHx8IGFkZEV2ZW50TGlzdGVuZXIoJ3N0b3JhZ2UnLCAvKiogQHR5cGUge2FueX0gKi8gKGV2ZW50SGFuZGxlcikpXG5cbi8qKlxuICogQSBwb2x5ZmlsbCBmb3IgYHJlbW92ZUV2ZW50TGlzdGVuZXIoJ3N0b3JhZ2UnLCBldmVudCA9PiB7Li59KWAgdGhhdCBkb2VzIG5vdGhpbmcgaWYgdGhlIHBvbHlmaWxsIGlzIGJlaW5nIHVzZWQuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbih7IGtleTogc3RyaW5nLCBuZXdWYWx1ZTogc3RyaW5nLCBvbGRWYWx1ZTogc3RyaW5nIH0pOiB2b2lkfSBldmVudEhhbmRsZXJcbiAqIEBmdW5jdGlvblxuICovXG4vKiBjOCBpZ25vcmUgbmV4dCAqL1xuZXhwb3J0IGNvbnN0IG9mZkNoYW5nZSA9IGV2ZW50SGFuZGxlciA9PiB1c2VQb2x5ZmlsbCB8fCByZW1vdmVFdmVudExpc3RlbmVyKCdzdG9yYWdlJywgLyoqIEB0eXBlIHthbnl9ICovIChldmVudEhhbmRsZXIpKVxuIiwgIi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbnMgZm9yIHdvcmtpbmcgd2l0aCBFY21hU2NyaXB0IG9iamVjdHMuXG4gKlxuICogQG1vZHVsZSBvYmplY3RcbiAqL1xuXG4vKipcbiAqIEByZXR1cm4ge09iamVjdDxzdHJpbmcsYW55Pn0gb2JqXG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGUgPSAoKSA9PiBPYmplY3QuY3JlYXRlKG51bGwpXG5cbi8qKlxuICogT2JqZWN0LmFzc2lnblxuICovXG5leHBvcnQgY29uc3QgYXNzaWduID0gT2JqZWN0LmFzc2lnblxuXG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZyxhbnk+fSBvYmpcbiAqL1xuZXhwb3J0IGNvbnN0IGtleXMgPSBPYmplY3Qua2V5c1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSBWXG4gKiBAcGFyYW0ge3tbazpzdHJpbmddOlZ9fSBvYmpcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oVixzdHJpbmcpOmFueX0gZlxuICovXG5leHBvcnQgY29uc3QgZm9yRWFjaCA9IChvYmosIGYpID0+IHtcbiAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XG4gICAgZihvYmpba2V5XSwga2V5KVxuICB9XG59XG5cbi8qKlxuICogQHRvZG8gaW1wbGVtZW50IG1hcFRvQXJyYXkgJiBtYXBcbiAqXG4gKiBAdGVtcGxhdGUgUlxuICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLGFueT59IG9ialxuICogQHBhcmFtIHtmdW5jdGlvbihhbnksc3RyaW5nKTpSfSBmXG4gKiBAcmV0dXJuIHtBcnJheTxSPn1cbiAqL1xuZXhwb3J0IGNvbnN0IG1hcCA9IChvYmosIGYpID0+IHtcbiAgY29uc3QgcmVzdWx0cyA9IFtdXG4gIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xuICAgIHJlc3VsdHMucHVzaChmKG9ialtrZXldLCBrZXkpKVxuICB9XG4gIHJldHVybiByZXN1bHRzXG59XG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLGFueT59IG9ialxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5leHBvcnQgY29uc3QgbGVuZ3RoID0gb2JqID0+IGtleXMob2JqKS5sZW5ndGhcblxuLyoqXG4gKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsYW55Pn0gb2JqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKGFueSxzdHJpbmcpOmJvb2xlYW59IGZcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBjb25zdCBzb21lID0gKG9iaiwgZikgPT4ge1xuICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcbiAgICBpZiAoZihvYmpba2V5XSwga2V5KSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3R8dW5kZWZpbmVkfSBvYmpcbiAqL1xuZXhwb3J0IGNvbnN0IGlzRW1wdHkgPSBvYmogPT4ge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgZm9yIChjb25zdCBfayBpbiBvYmopIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZyxhbnk+fSBvYmpcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oYW55LHN0cmluZyk6Ym9vbGVhbn0gZlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGNvbnN0IGV2ZXJ5ID0gKG9iaiwgZikgPT4ge1xuICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcbiAgICBpZiAoIWYob2JqW2tleV0sIGtleSkpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG4vKipcbiAqIENhbGxzIGBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5YC5cbiAqXG4gKiBAcGFyYW0ge2FueX0gb2JqXG4gKiBAcGFyYW0ge3N0cmluZ3xzeW1ib2x9IGtleVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGNvbnN0IGhhc1Byb3BlcnR5ID0gKG9iaiwga2V5KSA9PiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpXG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLGFueT59IGFcbiAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZyxhbnk+fSBiXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnQgY29uc3QgZXF1YWxGbGF0ID0gKGEsIGIpID0+IGEgPT09IGIgfHwgKGxlbmd0aChhKSA9PT0gbGVuZ3RoKGIpICYmIGV2ZXJ5KGEsICh2YWwsIGtleSkgPT4gKHZhbCAhPT0gdW5kZWZpbmVkIHx8IGhhc1Byb3BlcnR5KGIsIGtleSkpICYmIGJba2V5XSA9PT0gdmFsKSlcbiIsICIvKipcbiAqIENvbW1vbiBmdW5jdGlvbnMgYW5kIGZ1bmN0aW9uIGNhbGwgaGVscGVycy5cbiAqXG4gKiBAbW9kdWxlIGZ1bmN0aW9uXG4gKi9cblxuaW1wb3J0ICogYXMgYXJyYXkgZnJvbSAnLi9hcnJheS5qcydcbmltcG9ydCAqIGFzIG9iamVjdCBmcm9tICcuL29iamVjdC5qcydcblxuLyoqXG4gKiBDYWxscyBhbGwgZnVuY3Rpb25zIGluIGBmc2Agd2l0aCBhcmdzLiBPbmx5IHRocm93cyBhZnRlciBhbGwgZnVuY3Rpb25zIHdlcmUgY2FsbGVkLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8ZnVuY3Rpb24+fSBmc1xuICogQHBhcmFtIHtBcnJheTxhbnk+fSBhcmdzXG4gKi9cbmV4cG9ydCBjb25zdCBjYWxsQWxsID0gKGZzLCBhcmdzLCBpID0gMCkgPT4ge1xuICB0cnkge1xuICAgIGZvciAoOyBpIDwgZnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGZzW2ldKC4uLmFyZ3MpXG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIGlmIChpIDwgZnMubGVuZ3RoKSB7XG4gICAgICBjYWxsQWxsKGZzLCBhcmdzLCBpICsgMSlcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IG5vcCA9ICgpID0+IHt9XG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKTpUfSBmXG4gKiBAcmV0dXJuIHtUfVxuICovXG5leHBvcnQgY29uc3QgYXBwbHkgPSBmID0+IGYoKVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBBXG4gKlxuICogQHBhcmFtIHtBfSBhXG4gKiBAcmV0dXJuIHtBfVxuICovXG5leHBvcnQgY29uc3QgaWQgPSBhID0+IGFcblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICpcbiAqIEBwYXJhbSB7VH0gYVxuICogQHBhcmFtIHtUfSBiXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnQgY29uc3QgZXF1YWxpdHlTdHJpY3QgPSAoYSwgYikgPT4gYSA9PT0gYlxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKlxuICogQHBhcmFtIHtBcnJheTxUPnxvYmplY3R9IGFcbiAqIEBwYXJhbSB7QXJyYXk8VD58b2JqZWN0fSBiXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnQgY29uc3QgZXF1YWxpdHlGbGF0ID0gKGEsIGIpID0+IGEgPT09IGIgfHwgKGEgIT0gbnVsbCAmJiBiICE9IG51bGwgJiYgYS5jb25zdHJ1Y3RvciA9PT0gYi5jb25zdHJ1Y3RvciAmJiAoKGFycmF5LmlzQXJyYXkoYSkgJiYgYXJyYXkuZXF1YWxGbGF0KGEsIC8qKiBAdHlwZSB7QXJyYXk8VD59ICovIChiKSkpIHx8ICh0eXBlb2YgYSA9PT0gJ29iamVjdCcgJiYgb2JqZWN0LmVxdWFsRmxhdChhLCBiKSkpKVxuXG4vKiBjOCBpZ25vcmUgc3RhcnQgKi9cblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gYVxuICogQHBhcmFtIHthbnl9IGJcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBjb25zdCBlcXVhbGl0eURlZXAgPSAoYSwgYikgPT4ge1xuICBpZiAoYSA9PSBudWxsIHx8IGIgPT0gbnVsbCkge1xuICAgIHJldHVybiBlcXVhbGl0eVN0cmljdChhLCBiKVxuICB9XG4gIGlmIChhLmNvbnN0cnVjdG9yICE9PSBiLmNvbnN0cnVjdG9yKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgaWYgKGEgPT09IGIpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIHN3aXRjaCAoYS5jb25zdHJ1Y3Rvcikge1xuICAgIGNhc2UgQXJyYXlCdWZmZXI6XG4gICAgICBhID0gbmV3IFVpbnQ4QXJyYXkoYSlcbiAgICAgIGIgPSBuZXcgVWludDhBcnJheShiKVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1mYWxsdGhyb3VnaFxuICAgIGNhc2UgVWludDhBcnJheToge1xuICAgICAgaWYgKGEuYnl0ZUxlbmd0aCAhPT0gYi5ieXRlTGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrXG4gICAgfVxuICAgIGNhc2UgU2V0OiB7XG4gICAgICBpZiAoYS5zaXplICE9PSBiLnNpemUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIGEpIHtcbiAgICAgICAgaWYgKCFiLmhhcyh2YWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWtcbiAgICB9XG4gICAgY2FzZSBNYXA6IHtcbiAgICAgIGlmIChhLnNpemUgIT09IGIuc2l6ZSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3Qga2V5IG9mIGEua2V5cygpKSB7XG4gICAgICAgIGlmICghYi5oYXMoa2V5KSB8fCAhZXF1YWxpdHlEZWVwKGEuZ2V0KGtleSksIGIuZ2V0KGtleSkpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrXG4gICAgfVxuICAgIGNhc2UgT2JqZWN0OlxuICAgICAgaWYgKG9iamVjdC5sZW5ndGgoYSkgIT09IG9iamVjdC5sZW5ndGgoYikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBhKSB7XG4gICAgICAgIGlmICghb2JqZWN0Lmhhc1Byb3BlcnR5KGEsIGtleSkgfHwgIWVxdWFsaXR5RGVlcChhW2tleV0sIGJba2V5XSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWtcbiAgICBjYXNlIEFycmF5OlxuICAgICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoIWVxdWFsaXR5RGVlcChhW2ldLCBiW2ldKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVha1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBWXG4gKiBAdGVtcGxhdGUge1Z9IE9QVFNcbiAqXG4gKiBAcGFyYW0ge1Z9IHZhbHVlXG4gKiBAcGFyYW0ge0FycmF5PE9QVFM+fSBvcHRpb25zXG4gKi9cbi8vIEB0cy1pZ25vcmVcbmV4cG9ydCBjb25zdCBpc09uZU9mID0gKHZhbHVlLCBvcHRpb25zKSA9PiBvcHRpb25zLmluY2x1ZGVzKHZhbHVlKVxuLyogYzggaWdub3JlIHN0b3AgKi9cblxuZXhwb3J0IGNvbnN0IGlzQXJyYXkgPSBhcnJheS5pc0FycmF5XG5cbi8qKlxuICogQHBhcmFtIHthbnl9IHNcbiAqIEByZXR1cm4ge3MgaXMgU3RyaW5nfVxuICovXG5leHBvcnQgY29uc3QgaXNTdHJpbmcgPSAocykgPT4gcyAmJiBzLmNvbnN0cnVjdG9yID09PSBTdHJpbmdcblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gblxuICogQHJldHVybiB7biBpcyBOdW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBpc051bWJlciA9IG4gPT4gbiAhPSBudWxsICYmIG4uY29uc3RydWN0b3IgPT09IE51bWJlclxuXG4vKipcbiAqIEB0ZW1wbGF0ZSB7YWJzdHJhY3QgbmV3ICguLi5hcmdzOiBhbnkpID0+IGFueX0gVFlQRVxuICogQHBhcmFtIHthbnl9IG5cbiAqIEBwYXJhbSB7VFlQRX0gVFxuICogQHJldHVybiB7biBpcyBJbnN0YW5jZVR5cGU8VFlQRT59XG4gKi9cbmV4cG9ydCBjb25zdCBpcyA9IChuLCBUKSA9PiBuICYmIG4uY29uc3RydWN0b3IgPT09IFRcblxuLyoqXG4gKiBAdGVtcGxhdGUge2Fic3RyYWN0IG5ldyAoLi4uYXJnczogYW55KSA9PiBhbnl9IFRZUEVcbiAqIEBwYXJhbSB7VFlQRX0gVFxuICovXG5leHBvcnQgY29uc3QgaXNUZW1wbGF0ZSA9IChUKSA9PlxuICAvKipcbiAgICogQHBhcmFtIHthbnl9IG5cbiAgICogQHJldHVybiB7biBpcyBJbnN0YW5jZVR5cGU8VFlQRT59XG4gICAqKi9cbiAgbiA9PiBuICYmIG4uY29uc3RydWN0b3IgPT09IFRcbiIsICIvKipcbiAqIElzb21vcnBoaWMgbW9kdWxlIHRvIHdvcmsgYWNjZXNzIHRoZSBlbnZpcm9ubWVudCAocXVlcnkgcGFyYW1zLCBlbnYgdmFyaWFibGVzKS5cbiAqXG4gKiBAbW9kdWxlIG1hcFxuICovXG5cbmltcG9ydCAqIGFzIG1hcCBmcm9tICcuL21hcC5qcydcbmltcG9ydCAqIGFzIHN0cmluZyBmcm9tICcuL3N0cmluZy5qcydcbmltcG9ydCAqIGFzIGNvbmRpdGlvbnMgZnJvbSAnLi9jb25kaXRpb25zLmpzJ1xuaW1wb3J0ICogYXMgc3RvcmFnZSBmcm9tICcuL3N0b3JhZ2UuanMnXG5pbXBvcnQgKiBhcyBmIGZyb20gJy4vZnVuY3Rpb24uanMnXG5cbi8qIGM4IGlnbm9yZSBuZXh0IDIgKi9cbi8vIEB0cy1pZ25vcmVcbmV4cG9ydCBjb25zdCBpc05vZGUgPSB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy5yZWxlYXNlICYmIC9ub2RlfGlvXFwuanMvLnRlc3QocHJvY2Vzcy5yZWxlYXNlLm5hbWUpICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgPyBwcm9jZXNzIDogMCkgPT09ICdbb2JqZWN0IHByb2Nlc3NdJ1xuXG4vKiBjOCBpZ25vcmUgbmV4dCAqL1xuZXhwb3J0IGNvbnN0IGlzQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgIWlzTm9kZVxuLyogYzggaWdub3JlIG5leHQgMyAqL1xuZXhwb3J0IGNvbnN0IGlzTWFjID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCdcbiAgPyAvTWFjLy50ZXN0KG5hdmlnYXRvci5wbGF0Zm9ybSlcbiAgOiBmYWxzZVxuXG4vKipcbiAqIEB0eXBlIHtNYXA8c3RyaW5nLHN0cmluZz59XG4gKi9cbmxldCBwYXJhbXNcbmNvbnN0IGFyZ3MgPSBbXVxuXG4vKiBjOCBpZ25vcmUgc3RhcnQgKi9cbmNvbnN0IGNvbXB1dGVQYXJhbXMgPSAoKSA9PiB7XG4gIGlmIChwYXJhbXMgPT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChpc05vZGUpIHtcbiAgICAgIHBhcmFtcyA9IG1hcC5jcmVhdGUoKVxuICAgICAgY29uc3QgcGFyZ3MgPSBwcm9jZXNzLmFyZ3ZcbiAgICAgIGxldCBjdXJyUGFyYW1OYW1lID0gbnVsbFxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBwYXJnID0gcGFyZ3NbaV1cbiAgICAgICAgaWYgKHBhcmdbMF0gPT09ICctJykge1xuICAgICAgICAgIGlmIChjdXJyUGFyYW1OYW1lICE9PSBudWxsKSB7XG4gICAgICAgICAgICBwYXJhbXMuc2V0KGN1cnJQYXJhbU5hbWUsICcnKVxuICAgICAgICAgIH1cbiAgICAgICAgICBjdXJyUGFyYW1OYW1lID0gcGFyZ1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChjdXJyUGFyYW1OYW1lICE9PSBudWxsKSB7XG4gICAgICAgICAgICBwYXJhbXMuc2V0KGN1cnJQYXJhbU5hbWUsIHBhcmcpXG4gICAgICAgICAgICBjdXJyUGFyYW1OYW1lID0gbnVsbFxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhcmdzLnB1c2gocGFyZylcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjdXJyUGFyYW1OYW1lICE9PSBudWxsKSB7XG4gICAgICAgIHBhcmFtcy5zZXQoY3VyclBhcmFtTmFtZSwgJycpXG4gICAgICB9XG4gICAgICAvLyBpbiBSZWFjdE5hdGl2ZSBmb3IgZXhhbXBsZSB0aGlzIHdvdWxkIG5vdCBiZSB0cnVlICh1bmxlc3MgY29ubmVjdGVkIHRvIHRoZSBSZW1vdGUgRGVidWdnZXIpXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbG9jYXRpb24gPT09ICdvYmplY3QnKSB7XG4gICAgICBwYXJhbXMgPSBtYXAuY3JlYXRlKCk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICAgICAgKGxvY2F0aW9uLnNlYXJjaCB8fCAnPycpLnNsaWNlKDEpLnNwbGl0KCcmJykuZm9yRWFjaCgoa3YpID0+IHtcbiAgICAgICAgaWYgKGt2Lmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgIGNvbnN0IFtrZXksIHZhbHVlXSA9IGt2LnNwbGl0KCc9JylcbiAgICAgICAgICBwYXJhbXMuc2V0KGAtLSR7c3RyaW5nLmZyb21DYW1lbENhc2Uoa2V5LCAnLScpfWAsIHZhbHVlKVxuICAgICAgICAgIHBhcmFtcy5zZXQoYC0ke3N0cmluZy5mcm9tQ2FtZWxDYXNlKGtleSwgJy0nKX1gLCB2YWx1ZSlcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgcGFyYW1zID0gbWFwLmNyZWF0ZSgpXG4gICAgfVxuICB9XG4gIHJldHVybiBwYXJhbXNcbn1cbi8qIGM4IGlnbm9yZSBzdG9wICovXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbi8qIGM4IGlnbm9yZSBuZXh0ICovXG5leHBvcnQgY29uc3QgaGFzUGFyYW0gPSAobmFtZSkgPT4gY29tcHV0ZVBhcmFtcygpLmhhcyhuYW1lKVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge3N0cmluZ30gZGVmYXVsdFZhbFxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG4vKiBjOCBpZ25vcmUgbmV4dCAyICovXG5leHBvcnQgY29uc3QgZ2V0UGFyYW0gPSAobmFtZSwgZGVmYXVsdFZhbCkgPT5cbiAgY29tcHV0ZVBhcmFtcygpLmdldChuYW1lKSB8fCBkZWZhdWx0VmFsXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEByZXR1cm4ge3N0cmluZ3xudWxsfVxuICovXG4vKiBjOCBpZ25vcmUgbmV4dCA0ICovXG5leHBvcnQgY29uc3QgZ2V0VmFyaWFibGUgPSAobmFtZSkgPT5cbiAgaXNOb2RlXG4gICAgPyBjb25kaXRpb25zLnVuZGVmaW5lZFRvTnVsbChwcm9jZXNzLmVudltuYW1lLnRvVXBwZXJDYXNlKCldKVxuICAgIDogY29uZGl0aW9ucy51bmRlZmluZWRUb051bGwoc3RvcmFnZS52YXJTdG9yYWdlLmdldEl0ZW0obmFtZSkpXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEByZXR1cm4ge3N0cmluZ3xudWxsfVxuICovXG4vKiBjOCBpZ25vcmUgbmV4dCAyICovXG5leHBvcnQgY29uc3QgZ2V0Q29uZiA9IChuYW1lKSA9PlxuICBjb21wdXRlUGFyYW1zKCkuZ2V0KCctLScgKyBuYW1lKSB8fCBnZXRWYXJpYWJsZShuYW1lKVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG4vKiBjOCBpZ25vcmUgbmV4dCAyICovXG5leHBvcnQgY29uc3QgaGFzQ29uZiA9IChuYW1lKSA9PlxuICBoYXNQYXJhbSgnLS0nICsgbmFtZSkgfHwgZ2V0VmFyaWFibGUobmFtZSkgIT09IG51bGxcblxuLyogYzggaWdub3JlIG5leHQgKi9cbmV4cG9ydCBjb25zdCBwcm9kdWN0aW9uID0gaGFzQ29uZigncHJvZHVjdGlvbicpXG5cbi8qIGM4IGlnbm9yZSBuZXh0IDIgKi9cbmNvbnN0IGZvcmNlQ29sb3IgPSBpc05vZGUgJiZcbiAgZi5pc09uZU9mKHByb2Nlc3MuZW52LkZPUkNFX0NPTE9SLCBbJ3RydWUnLCAnMScsICcyJ10pXG5cbi8qIGM4IGlnbm9yZSBzdGFydCAqL1xuZXhwb3J0IGNvbnN0IHN1cHBvcnRzQ29sb3IgPSAhaGFzUGFyYW0oJ25vLWNvbG9ycycpICYmXG4gICghaXNOb2RlIHx8IHByb2Nlc3Muc3Rkb3V0LmlzVFRZIHx8IGZvcmNlQ29sb3IpICYmIChcbiAgIWlzTm9kZSB8fCBoYXNQYXJhbSgnY29sb3InKSB8fCBmb3JjZUNvbG9yIHx8XG4gICAgZ2V0VmFyaWFibGUoJ0NPTE9SVEVSTScpICE9PSBudWxsIHx8XG4gICAgKGdldFZhcmlhYmxlKCdURVJNJykgfHwgJycpLmluY2x1ZGVzKCdjb2xvcicpXG4pXG4vKiBjOCBpZ25vcmUgc3RvcCAqL1xuIiwgIi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbnMgdG8gd29yayB3aXRoIGJ1ZmZlcnMgKFVpbnQ4QXJyYXkpLlxuICpcbiAqIEBtb2R1bGUgYnVmZmVyXG4gKi9cblxuaW1wb3J0ICogYXMgc3RyaW5nIGZyb20gJy4vc3RyaW5nLmpzJ1xuaW1wb3J0ICogYXMgZW52IGZyb20gJy4vZW52aXJvbm1lbnQuanMnXG5pbXBvcnQgKiBhcyBhcnJheSBmcm9tICcuL2FycmF5LmpzJ1xuaW1wb3J0ICogYXMgbWF0aCBmcm9tICcuL21hdGguanMnXG5pbXBvcnQgKiBhcyBlbmNvZGluZyBmcm9tICcuL2VuY29kaW5nLmpzJ1xuaW1wb3J0ICogYXMgZGVjb2RpbmcgZnJvbSAnLi9kZWNvZGluZy5qcydcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gbGVuXG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVVaW50OEFycmF5RnJvbUxlbiA9IGxlbiA9PiBuZXcgVWludDhBcnJheShsZW4pXG5cbi8qKlxuICogQ3JlYXRlIFVpbnQ4QXJyYXkgd2l0aCBpbml0aWFsIGNvbnRlbnQgZnJvbSBidWZmZXJcbiAqXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBidWZmZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBieXRlT2Zmc2V0XG4gKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoXG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVVaW50OEFycmF5Vmlld0Zyb21BcnJheUJ1ZmZlciA9IChidWZmZXIsIGJ5dGVPZmZzZXQsIGxlbmd0aCkgPT4gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyLCBieXRlT2Zmc2V0LCBsZW5ndGgpXG5cbi8qKlxuICogQ3JlYXRlIFVpbnQ4QXJyYXkgd2l0aCBpbml0aWFsIGNvbnRlbnQgZnJvbSBidWZmZXJcbiAqXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBidWZmZXJcbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZVVpbnQ4QXJyYXlGcm9tQXJyYXlCdWZmZXIgPSBidWZmZXIgPT4gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKVxuXG4vKiBjOCBpZ25vcmUgc3RhcnQgKi9cbi8qKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBieXRlc1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5jb25zdCB0b0Jhc2U2NEJyb3dzZXIgPSBieXRlcyA9PiB7XG4gIGxldCBzID0gJydcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5ieXRlTGVuZ3RoOyBpKyspIHtcbiAgICBzICs9IHN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0pXG4gIH1cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gIHJldHVybiBidG9hKHMpXG59XG4vKiBjOCBpZ25vcmUgc3RvcCAqL1xuXG4vKipcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnl0ZXNcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuY29uc3QgdG9CYXNlNjROb2RlID0gYnl0ZXMgPT4gQnVmZmVyLmZyb20oYnl0ZXMuYnVmZmVyLCBieXRlcy5ieXRlT2Zmc2V0LCBieXRlcy5ieXRlTGVuZ3RoKS50b1N0cmluZygnYmFzZTY0JylcblxuLyogYzggaWdub3JlIHN0YXJ0ICovXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBzXG4gKiBAcmV0dXJuIHtVaW50OEFycmF5fVxuICovXG5jb25zdCBmcm9tQmFzZTY0QnJvd3NlciA9IHMgPT4ge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgY29uc3QgYSA9IGF0b2IocylcbiAgY29uc3QgYnl0ZXMgPSBjcmVhdGVVaW50OEFycmF5RnJvbUxlbihhLmxlbmd0aClcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgYnl0ZXNbaV0gPSBhLmNoYXJDb2RlQXQoaSlcbiAgfVxuICByZXR1cm4gYnl0ZXNcbn1cbi8qIGM4IGlnbm9yZSBzdG9wICovXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHNcbiAqL1xuY29uc3QgZnJvbUJhc2U2NE5vZGUgPSBzID0+IHtcbiAgY29uc3QgYnVmID0gQnVmZmVyLmZyb20ocywgJ2Jhc2U2NCcpXG4gIHJldHVybiBjcmVhdGVVaW50OEFycmF5Vmlld0Zyb21BcnJheUJ1ZmZlcihidWYuYnVmZmVyLCBidWYuYnl0ZU9mZnNldCwgYnVmLmJ5dGVMZW5ndGgpXG59XG5cbi8qIGM4IGlnbm9yZSBuZXh0ICovXG5leHBvcnQgY29uc3QgdG9CYXNlNjQgPSBlbnYuaXNCcm93c2VyID8gdG9CYXNlNjRCcm93c2VyIDogdG9CYXNlNjROb2RlXG5cbi8qIGM4IGlnbm9yZSBuZXh0ICovXG5leHBvcnQgY29uc3QgZnJvbUJhc2U2NCA9IGVudi5pc0Jyb3dzZXIgPyBmcm9tQmFzZTY0QnJvd3NlciA6IGZyb21CYXNlNjROb2RlXG5cbi8qKlxuICogSW1wbGVtZW50cyBiYXNlNjR1cmwgLSBzZWUgaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9yZmM0NjQ4I3NlY3Rpb24tNVxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWZcbiAqL1xuZXhwb3J0IGNvbnN0IHRvQmFzZTY0VXJsRW5jb2RlZCA9IGJ1ZiA9PiB0b0Jhc2U2NChidWYpLnJlcGxhY2VBbGwoJysnLCAnLScpLnJlcGxhY2VBbGwoJy8nLCAnXycpLnJlcGxhY2VBbGwoJz0nLCAnJylcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gYmFzZTY0XG4gKi9cbmV4cG9ydCBjb25zdCBmcm9tQmFzZTY0VXJsRW5jb2RlZCA9IGJhc2U2NCA9PiBmcm9tQmFzZTY0KGJhc2U2NC5yZXBsYWNlQWxsKCctJywgJysnKS5yZXBsYWNlQWxsKCdfJywgJy8nKSlcblxuLyoqXG4gKiBCYXNlNjQgaXMgYWx3YXlzIGEgbW9yZSBlZmZpY2llbnQgY2hvaWNlLiBUaGlzIGV4aXN0cyBmb3IgdXRpbGl0eSBwdXJwb3NlcyBvbmx5LlxuICpcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmXG4gKi9cbmV4cG9ydCBjb25zdCB0b0hleFN0cmluZyA9IGJ1ZiA9PiBhcnJheS5tYXAoYnVmLCBiID0+IGIudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJykpLmpvaW4oJycpXG5cbi8qKlxuICogTm90ZTogVGhpcyBmdW5jdGlvbiBleHBlY3RzIHRoYXQgdGhlIGhleCBkb2Vzbid0IHN0YXJ0IHdpdGggMHguLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBoZXhcbiAqL1xuZXhwb3J0IGNvbnN0IGZyb21IZXhTdHJpbmcgPSBoZXggPT4ge1xuICBjb25zdCBobGVuID0gaGV4Lmxlbmd0aFxuICBjb25zdCBidWYgPSBuZXcgVWludDhBcnJheShtYXRoLmNlaWwoaGxlbiAvIDIpKVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGhsZW47IGkgKz0gMikge1xuICAgIGJ1ZltidWYubGVuZ3RoIC0gaSAvIDIgLSAxXSA9IE51bWJlci5wYXJzZUludChoZXguc2xpY2UoaGxlbiAtIGkgLSAyLCBobGVuIC0gaSksIDE2KVxuICB9XG4gIHJldHVybiBidWZcbn1cblxuLyoqXG4gKiBDb3B5IHRoZSBjb250ZW50IG9mIGFuIFVpbnQ4QXJyYXkgdmlldyB0byBhIG5ldyBBcnJheUJ1ZmZlci5cbiAqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHVpbnQ4QXJyYXlcbiAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9XG4gKi9cbmV4cG9ydCBjb25zdCBjb3B5VWludDhBcnJheSA9IHVpbnQ4QXJyYXkgPT4ge1xuICBjb25zdCBuZXdCdWYgPSBjcmVhdGVVaW50OEFycmF5RnJvbUxlbih1aW50OEFycmF5LmJ5dGVMZW5ndGgpXG4gIG5ld0J1Zi5zZXQodWludDhBcnJheSlcbiAgcmV0dXJuIG5ld0J1ZlxufVxuXG4vKipcbiAqIEVuY29kZSBhbnl0aGluZyBhcyBhIFVJbnQ4QXJyYXkuIEl0J3MgYSBwdW4gb24gdHlwZXNjcmlwdHMncyBgYW55YCB0eXBlLlxuICogU2VlIGVuY29kaW5nLndyaXRlQW55IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICpcbiAqIEBwYXJhbSB7YW55fSBkYXRhXG4gKiBAcmV0dXJuIHtVaW50OEFycmF5fVxuICovXG5leHBvcnQgY29uc3QgZW5jb2RlQW55ID0gZGF0YSA9PlxuICBlbmNvZGluZy5lbmNvZGUoZW5jb2RlciA9PiBlbmNvZGluZy53cml0ZUFueShlbmNvZGVyLCBkYXRhKSlcblxuLyoqXG4gKiBEZWNvZGUgYW4gYW55LWVuY29kZWQgdmFsdWUuXG4gKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWZcbiAqIEByZXR1cm4ge2FueX1cbiAqL1xuZXhwb3J0IGNvbnN0IGRlY29kZUFueSA9IGJ1ZiA9PiBkZWNvZGluZy5yZWFkQW55KGRlY29kaW5nLmNyZWF0ZURlY29kZXIoYnVmKSlcblxuLyoqXG4gKiBTaGlmdCBCeXRlIEFycmF5IHtOfSBiaXRzIHRvIHRoZSBsZWZ0LiBEb2VzIG5vdCBleHBhbmQgYnl0ZSBhcnJheS5cbiAqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJzXG4gKiBAcGFyYW0ge251bWJlcn0gTiBzaG91bGQgYmUgaW4gdGhlIHJhbmdlIG9mIFswLTddXG4gKi9cbmV4cG9ydCBjb25zdCBzaGlmdE5CaXRzTGVmdCA9IChicywgTikgPT4ge1xuICBpZiAoTiA9PT0gMCkgcmV0dXJuIGJzXG4gIGJzID0gbmV3IFVpbnQ4QXJyYXkoYnMpXG4gIGJzWzBdIDw8PSBOXG4gIGZvciAobGV0IGkgPSAxOyBpIDwgYnMubGVuZ3RoOyBpKyspIHtcbiAgICBic1tpIC0gMV0gfD0gYnNbaV0gPj4+ICg4IC0gTilcbiAgICBic1tpXSA8PD0gTlxuICB9XG4gIHJldHVybiBic1xufVxuIiwgIi8qKlxuICogV29ya2luZyB3aXRoIHZhbHVlIHBhaXJzLlxuICpcbiAqIEBtb2R1bGUgcGFpclxuICovXG5cbi8qKlxuICogQHRlbXBsYXRlIEwsUlxuICovXG5leHBvcnQgY2xhc3MgUGFpciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0x9IGxlZnRcbiAgICogQHBhcmFtIHtSfSByaWdodFxuICAgKi9cbiAgY29uc3RydWN0b3IgKGxlZnQsIHJpZ2h0KSB7XG4gICAgdGhpcy5sZWZ0ID0gbGVmdFxuICAgIHRoaXMucmlnaHQgPSByaWdodFxuICB9XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIEwsUlxuICogQHBhcmFtIHtMfSBsZWZ0XG4gKiBAcGFyYW0ge1J9IHJpZ2h0XG4gKiBAcmV0dXJuIHtQYWlyPEwsUj59XG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGUgPSAobGVmdCwgcmlnaHQpID0+IG5ldyBQYWlyKGxlZnQsIHJpZ2h0KVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBMLFJcbiAqIEBwYXJhbSB7Un0gcmlnaHRcbiAqIEBwYXJhbSB7TH0gbGVmdFxuICogQHJldHVybiB7UGFpcjxMLFI+fVxuICovXG5leHBvcnQgY29uc3QgY3JlYXRlUmV2ZXJzZWQgPSAocmlnaHQsIGxlZnQpID0+IG5ldyBQYWlyKGxlZnQsIHJpZ2h0KVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBMLFJcbiAqIEBwYXJhbSB7QXJyYXk8UGFpcjxMLFI+Pn0gYXJyXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKEwsIFIpOmFueX0gZlxuICovXG5leHBvcnQgY29uc3QgZm9yRWFjaCA9IChhcnIsIGYpID0+IGFyci5mb3JFYWNoKHAgPT4gZihwLmxlZnQsIHAucmlnaHQpKVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBMLFIsWFxuICogQHBhcmFtIHtBcnJheTxQYWlyPEwsUj4+fSBhcnJcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oTCwgUik6WH0gZlxuICogQHJldHVybiB7QXJyYXk8WD59XG4gKi9cbmV4cG9ydCBjb25zdCBtYXAgPSAoYXJyLCBmKSA9PiBhcnIubWFwKHAgPT4gZihwLmxlZnQsIHAucmlnaHQpKVxuIiwgIi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuXG4vKipcbiAqIFV0aWxpdHkgbW9kdWxlIHRvIHdvcmsgd2l0aCB0aGUgRE9NLlxuICpcbiAqIEBtb2R1bGUgZG9tXG4gKi9cblxuaW1wb3J0ICogYXMgcGFpciBmcm9tICcuL3BhaXIuanMnXG5pbXBvcnQgKiBhcyBtYXAgZnJvbSAnLi9tYXAuanMnXG5cbi8qIGM4IGlnbm9yZSBzdGFydCAqL1xuLyoqXG4gKiBAdHlwZSB7RG9jdW1lbnR9XG4gKi9cbmV4cG9ydCBjb25zdCBkb2MgPSAvKiogQHR5cGUge0RvY3VtZW50fSAqLyAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyA/IGRvY3VtZW50IDoge30pXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEByZXR1cm4ge0hUTUxFbGVtZW50fVxuICovXG5leHBvcnQgY29uc3QgY3JlYXRlRWxlbWVudCA9IG5hbWUgPT4gZG9jLmNyZWF0ZUVsZW1lbnQobmFtZSlcblxuLyoqXG4gKiBAcmV0dXJuIHtEb2N1bWVudEZyYWdtZW50fVxuICovXG5leHBvcnQgY29uc3QgY3JlYXRlRG9jdW1lbnRGcmFnbWVudCA9ICgpID0+IGRvYy5jcmVhdGVEb2N1bWVudEZyYWdtZW50KClcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICogQHJldHVybiB7VGV4dH1cbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZVRleHROb2RlID0gdGV4dCA9PiBkb2MuY3JlYXRlVGV4dE5vZGUodGV4dClcblxuZXhwb3J0IGNvbnN0IGRvbVBhcnNlciA9IC8qKiBAdHlwZSB7RE9NUGFyc2VyfSAqLyAodHlwZW9mIERPTVBhcnNlciAhPT0gJ3VuZGVmaW5lZCcgPyBuZXcgRE9NUGFyc2VyKCkgOiBudWxsKVxuXG4vKipcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAqL1xuZXhwb3J0IGNvbnN0IGVtaXRDdXN0b21FdmVudCA9IChlbCwgbmFtZSwgb3B0cykgPT4gZWwuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQobmFtZSwgb3B0cykpXG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtBcnJheTxwYWlyLlBhaXI8c3RyaW5nLHN0cmluZ3xib29sZWFuPj59IGF0dHJzIEFycmF5IG9mIGtleS12YWx1ZSBwYWlyc1xuICogQHJldHVybiB7RWxlbWVudH1cbiAqL1xuZXhwb3J0IGNvbnN0IHNldEF0dHJpYnV0ZXMgPSAoZWwsIGF0dHJzKSA9PiB7XG4gIHBhaXIuZm9yRWFjaChhdHRycywgKGtleSwgdmFsdWUpID0+IHtcbiAgICBpZiAodmFsdWUgPT09IGZhbHNlKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoa2V5KVxuICAgIH0gZWxzZSBpZiAodmFsdWUgPT09IHRydWUpIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZShrZXksICcnKVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSlcbiAgICB9XG4gIH0pXG4gIHJldHVybiBlbFxufVxuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7TWFwPHN0cmluZywgc3RyaW5nPn0gYXR0cnMgQXJyYXkgb2Yga2V5LXZhbHVlIHBhaXJzXG4gKiBAcmV0dXJuIHtFbGVtZW50fVxuICovXG5leHBvcnQgY29uc3Qgc2V0QXR0cmlidXRlc01hcCA9IChlbCwgYXR0cnMpID0+IHtcbiAgYXR0cnMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4geyBlbC5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSkgfSlcbiAgcmV0dXJuIGVsXG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxOb2RlPnxIVE1MQ29sbGVjdGlvbn0gY2hpbGRyZW5cbiAqIEByZXR1cm4ge0RvY3VtZW50RnJhZ21lbnR9XG4gKi9cbmV4cG9ydCBjb25zdCBmcmFnbWVudCA9IGNoaWxkcmVuID0+IHtcbiAgY29uc3QgZnJhZ21lbnQgPSBjcmVhdGVEb2N1bWVudEZyYWdtZW50KClcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIGFwcGVuZENoaWxkKGZyYWdtZW50LCBjaGlsZHJlbltpXSlcbiAgfVxuICByZXR1cm4gZnJhZ21lbnRcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHBhcmVudFxuICogQHBhcmFtIHtBcnJheTxOb2RlPn0gbm9kZXNcbiAqIEByZXR1cm4ge0VsZW1lbnR9XG4gKi9cbmV4cG9ydCBjb25zdCBhcHBlbmQgPSAocGFyZW50LCBub2RlcykgPT4ge1xuICBhcHBlbmRDaGlsZChwYXJlbnQsIGZyYWdtZW50KG5vZGVzKSlcbiAgcmV0dXJuIHBhcmVudFxufVxuXG4vKipcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsXG4gKi9cbmV4cG9ydCBjb25zdCByZW1vdmUgPSBlbCA9PiBlbC5yZW1vdmUoKVxuXG4vKipcbiAqIEBwYXJhbSB7RXZlbnRUYXJnZXR9IGVsXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtFdmVudExpc3RlbmVyfSBmXG4gKi9cbmV4cG9ydCBjb25zdCBhZGRFdmVudExpc3RlbmVyID0gKGVsLCBuYW1lLCBmKSA9PiBlbC5hZGRFdmVudExpc3RlbmVyKG5hbWUsIGYpXG5cbi8qKlxuICogQHBhcmFtIHtFdmVudFRhcmdldH0gZWxcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge0V2ZW50TGlzdGVuZXJ9IGZcbiAqL1xuZXhwb3J0IGNvbnN0IHJlbW92ZUV2ZW50TGlzdGVuZXIgPSAoZWwsIG5hbWUsIGYpID0+IGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIobmFtZSwgZilcblxuLyoqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAqIEBwYXJhbSB7QXJyYXk8cGFpci5QYWlyPHN0cmluZyxFdmVudExpc3RlbmVyPj59IGxpc3RlbmVyc1xuICogQHJldHVybiB7Tm9kZX1cbiAqL1xuZXhwb3J0IGNvbnN0IGFkZEV2ZW50TGlzdGVuZXJzID0gKG5vZGUsIGxpc3RlbmVycykgPT4ge1xuICBwYWlyLmZvckVhY2gobGlzdGVuZXJzLCAobmFtZSwgZikgPT4gYWRkRXZlbnRMaXN0ZW5lcihub2RlLCBuYW1lLCBmKSlcbiAgcmV0dXJuIG5vZGVcbn1cblxuLyoqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAqIEBwYXJhbSB7QXJyYXk8cGFpci5QYWlyPHN0cmluZyxFdmVudExpc3RlbmVyPj59IGxpc3RlbmVyc1xuICogQHJldHVybiB7Tm9kZX1cbiAqL1xuZXhwb3J0IGNvbnN0IHJlbW92ZUV2ZW50TGlzdGVuZXJzID0gKG5vZGUsIGxpc3RlbmVycykgPT4ge1xuICBwYWlyLmZvckVhY2gobGlzdGVuZXJzLCAobmFtZSwgZikgPT4gcmVtb3ZlRXZlbnRMaXN0ZW5lcihub2RlLCBuYW1lLCBmKSlcbiAgcmV0dXJuIG5vZGVcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtBcnJheTxwYWlyLlBhaXI8c3RyaW5nLHN0cmluZz58cGFpci5QYWlyPHN0cmluZyxib29sZWFuPj59IGF0dHJzIEFycmF5IG9mIGtleS12YWx1ZSBwYWlyc1xuICogQHBhcmFtIHtBcnJheTxOb2RlPn0gY2hpbGRyZW5cbiAqIEByZXR1cm4ge0VsZW1lbnR9XG4gKi9cbmV4cG9ydCBjb25zdCBlbGVtZW50ID0gKG5hbWUsIGF0dHJzID0gW10sIGNoaWxkcmVuID0gW10pID0+XG4gIGFwcGVuZChzZXRBdHRyaWJ1dGVzKGNyZWF0ZUVsZW1lbnQobmFtZSksIGF0dHJzKSwgY2hpbGRyZW4pXG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoXG4gKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0XG4gKi9cbmV4cG9ydCBjb25zdCBjYW52YXMgPSAod2lkdGgsIGhlaWdodCkgPT4ge1xuICBjb25zdCBjID0gLyoqIEB0eXBlIHtIVE1MQ2FudmFzRWxlbWVudH0gKi8gKGNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpKVxuICBjLmhlaWdodCA9IGhlaWdodFxuICBjLndpZHRoID0gd2lkdGhcbiAgcmV0dXJuIGNcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdFxuICogQHJldHVybiB7VGV4dH1cbiAqL1xuZXhwb3J0IGNvbnN0IHRleHQgPSBjcmVhdGVUZXh0Tm9kZVxuXG4vKipcbiAqIEBwYXJhbSB7cGFpci5QYWlyPHN0cmluZyxzdHJpbmc+fSBwYWlyXG4gKi9cbmV4cG9ydCBjb25zdCBwYWlyVG9TdHlsZVN0cmluZyA9IHBhaXIgPT4gYCR7cGFpci5sZWZ0fToke3BhaXIucmlnaHR9O2BcblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PHBhaXIuUGFpcjxzdHJpbmcsc3RyaW5nPj59IHBhaXJzXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBjb25zdCBwYWlyc1RvU3R5bGVTdHJpbmcgPSBwYWlycyA9PiBwYWlycy5tYXAocGFpclRvU3R5bGVTdHJpbmcpLmpvaW4oJycpXG5cbi8qKlxuICogQHBhcmFtIHtNYXA8c3RyaW5nLHN0cmluZz59IG1cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGNvbnN0IG1hcFRvU3R5bGVTdHJpbmcgPSBtID0+IG1hcC5tYXAobSwgKHZhbHVlLCBrZXkpID0+IGAke2tleX06JHt2YWx1ZX07YCkuam9pbignJylcblxuLyoqXG4gKiBAdG9kbyBzaG91bGQgYWx3YXlzIHF1ZXJ5IG9uIGEgZG9tIGVsZW1lbnRcbiAqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fFNoYWRvd1Jvb3R9IGVsXG4gKiBAcGFyYW0ge3N0cmluZ30gcXVlcnlcbiAqIEByZXR1cm4ge0hUTUxFbGVtZW50IHwgbnVsbH1cbiAqL1xuZXhwb3J0IGNvbnN0IHF1ZXJ5U2VsZWN0b3IgPSAoZWwsIHF1ZXJ5KSA9PiBlbC5xdWVyeVNlbGVjdG9yKHF1ZXJ5KVxuXG4vKipcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR8U2hhZG93Um9vdH0gZWxcbiAqIEBwYXJhbSB7c3RyaW5nfSBxdWVyeVxuICogQHJldHVybiB7Tm9kZUxpc3RPZjxIVE1MRWxlbWVudD59XG4gKi9cbmV4cG9ydCBjb25zdCBxdWVyeVNlbGVjdG9yQWxsID0gKGVsLCBxdWVyeSkgPT4gZWwucXVlcnlTZWxlY3RvckFsbChxdWVyeSlcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gaWRcbiAqIEByZXR1cm4ge0hUTUxFbGVtZW50fVxuICovXG5leHBvcnQgY29uc3QgZ2V0RWxlbWVudEJ5SWQgPSBpZCA9PiAvKiogQHR5cGUge0hUTUxFbGVtZW50fSAqLyAoZG9jLmdldEVsZW1lbnRCeUlkKGlkKSlcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gaHRtbFxuICogQHJldHVybiB7SFRNTEVsZW1lbnR9XG4gKi9cbmNvbnN0IF9wYXJzZSA9IGh0bWwgPT4gZG9tUGFyc2VyLnBhcnNlRnJvbVN0cmluZyhgPGh0bWw+PGJvZHk+JHtodG1sfTwvYm9keT48L2h0bWw+YCwgJ3RleHQvaHRtbCcpLmJvZHlcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gaHRtbFxuICogQHJldHVybiB7RG9jdW1lbnRGcmFnbWVudH1cbiAqL1xuZXhwb3J0IGNvbnN0IHBhcnNlRnJhZ21lbnQgPSBodG1sID0+IGZyYWdtZW50KC8qKiBAdHlwZSB7YW55fSAqLyAoX3BhcnNlKGh0bWwpLmNoaWxkTm9kZXMpKVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBodG1sXG4gKiBAcmV0dXJuIHtIVE1MRWxlbWVudH1cbiAqL1xuZXhwb3J0IGNvbnN0IHBhcnNlRWxlbWVudCA9IGh0bWwgPT4gLyoqIEB0eXBlIEhUTUxFbGVtZW50ICovIChfcGFyc2UoaHRtbCkuZmlyc3RFbGVtZW50Q2hpbGQpXG5cbi8qKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gb2xkRWxcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR8RG9jdW1lbnRGcmFnbWVudH0gbmV3RWxcbiAqL1xuZXhwb3J0IGNvbnN0IHJlcGxhY2VXaXRoID0gKG9sZEVsLCBuZXdFbCkgPT4gb2xkRWwucmVwbGFjZVdpdGgobmV3RWwpXG5cbi8qKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcGFyZW50XG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbFxuICogQHBhcmFtIHtOb2RlfG51bGx9IHJlZlxuICogQHJldHVybiB7SFRNTEVsZW1lbnR9XG4gKi9cbmV4cG9ydCBjb25zdCBpbnNlcnRCZWZvcmUgPSAocGFyZW50LCBlbCwgcmVmKSA9PiBwYXJlbnQuaW5zZXJ0QmVmb3JlKGVsLCByZWYpXG5cbi8qKlxuICogQHBhcmFtIHtOb2RlfSBwYXJlbnRcbiAqIEBwYXJhbSB7Tm9kZX0gY2hpbGRcbiAqIEByZXR1cm4ge05vZGV9XG4gKi9cbmV4cG9ydCBjb25zdCBhcHBlbmRDaGlsZCA9IChwYXJlbnQsIGNoaWxkKSA9PiBwYXJlbnQuYXBwZW5kQ2hpbGQoY2hpbGQpXG5cbmV4cG9ydCBjb25zdCBFTEVNRU5UX05PREUgPSBkb2MuRUxFTUVOVF9OT0RFXG5leHBvcnQgY29uc3QgVEVYVF9OT0RFID0gZG9jLlRFWFRfTk9ERVxuZXhwb3J0IGNvbnN0IENEQVRBX1NFQ1RJT05fTk9ERSA9IGRvYy5DREFUQV9TRUNUSU9OX05PREVcbmV4cG9ydCBjb25zdCBDT01NRU5UX05PREUgPSBkb2MuQ09NTUVOVF9OT0RFXG5leHBvcnQgY29uc3QgRE9DVU1FTlRfTk9ERSA9IGRvYy5ET0NVTUVOVF9OT0RFXG5leHBvcnQgY29uc3QgRE9DVU1FTlRfVFlQRV9OT0RFID0gZG9jLkRPQ1VNRU5UX1RZUEVfTk9ERVxuZXhwb3J0IGNvbnN0IERPQ1VNRU5UX0ZSQUdNRU5UX05PREUgPSBkb2MuRE9DVU1FTlRfRlJBR01FTlRfTk9ERVxuXG4vKipcbiAqIEBwYXJhbSB7YW55fSBub2RlXG4gKiBAcGFyYW0ge251bWJlcn0gdHlwZVxuICovXG5leHBvcnQgY29uc3QgY2hlY2tOb2RlVHlwZSA9IChub2RlLCB0eXBlKSA9PiBub2RlLm5vZGVUeXBlID09PSB0eXBlXG5cbi8qKlxuICogQHBhcmFtIHtOb2RlfSBwYXJlbnRcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGNoaWxkXG4gKi9cbmV4cG9ydCBjb25zdCBpc1BhcmVudE9mID0gKHBhcmVudCwgY2hpbGQpID0+IHtcbiAgbGV0IHAgPSBjaGlsZC5wYXJlbnROb2RlXG4gIHdoaWxlIChwICYmIHAgIT09IHBhcmVudCkge1xuICAgIHAgPSBwLnBhcmVudE5vZGVcbiAgfVxuICByZXR1cm4gcCA9PT0gcGFyZW50XG59XG4vKiBjOCBpZ25vcmUgc3RvcCAqL1xuIiwgIi8qKlxuICogVXRpbGl0eSBtb2R1bGUgdG8gd29yayB3aXRoIEVjbWFTY3JpcHQgU3ltYm9scy5cbiAqXG4gKiBAbW9kdWxlIHN5bWJvbFxuICovXG5cbi8qKlxuICogUmV0dXJuIGZyZXNoIHN5bWJvbC5cbiAqXG4gKiBAcmV0dXJuIHtTeW1ib2x9XG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGUgPSBTeW1ib2xcblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gc1xuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGNvbnN0IGlzU3ltYm9sID0gcyA9PiB0eXBlb2YgcyA9PT0gJ3N5bWJvbCdcbiIsICJpbXBvcnQgKiBhcyBzeW1ib2wgZnJvbSAnLi9zeW1ib2wuanMnXG5pbXBvcnQgKiBhcyB0aW1lIGZyb20gJy4vdGltZS5qcydcbmltcG9ydCAqIGFzIGVudiBmcm9tICcuL2Vudmlyb25tZW50LmpzJ1xuaW1wb3J0ICogYXMgZnVuYyBmcm9tICcuL2Z1bmN0aW9uLmpzJ1xuXG5leHBvcnQgY29uc3QgQk9MRCA9IHN5bWJvbC5jcmVhdGUoKVxuZXhwb3J0IGNvbnN0IFVOQk9MRCA9IHN5bWJvbC5jcmVhdGUoKVxuZXhwb3J0IGNvbnN0IEJMVUUgPSBzeW1ib2wuY3JlYXRlKClcbmV4cG9ydCBjb25zdCBHUkVZID0gc3ltYm9sLmNyZWF0ZSgpXG5leHBvcnQgY29uc3QgR1JFRU4gPSBzeW1ib2wuY3JlYXRlKClcbmV4cG9ydCBjb25zdCBSRUQgPSBzeW1ib2wuY3JlYXRlKClcbmV4cG9ydCBjb25zdCBQVVJQTEUgPSBzeW1ib2wuY3JlYXRlKClcbmV4cG9ydCBjb25zdCBPUkFOR0UgPSBzeW1ib2wuY3JlYXRlKClcbmV4cG9ydCBjb25zdCBVTkNPTE9SID0gc3ltYm9sLmNyZWF0ZSgpXG5cbi8qIGM4IGlnbm9yZSBzdGFydCAqL1xuLyoqXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZ3xTeW1ib2x8T2JqZWN0fG51bWJlcj59IGFyZ3NcbiAqIEByZXR1cm4ge0FycmF5PHN0cmluZ3xvYmplY3R8bnVtYmVyPn1cbiAqL1xuZXhwb3J0IGNvbnN0IGNvbXB1dGVOb0NvbG9yTG9nZ2luZ0FyZ3MgPSBhcmdzID0+IHtcbiAgY29uc3Qgc3RyQnVpbGRlciA9IFtdXG4gIGNvbnN0IGxvZ0FyZ3MgPSBbXVxuICAvLyB0cnkgd2l0aCBmb3JtYXR0aW5nIHVudGlsIHdlIGZpbmQgc29tZXRoaW5nIHVuc3VwcG9ydGVkXG4gIGxldCBpID0gMFxuICBmb3IgKDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBhcmcgPSBhcmdzW2ldXG4gICAgaWYgKGFyZy5jb25zdHJ1Y3RvciA9PT0gU3RyaW5nIHx8IGFyZy5jb25zdHJ1Y3RvciA9PT0gTnVtYmVyKSB7XG4gICAgICBzdHJCdWlsZGVyLnB1c2goYXJnKVxuICAgIH0gZWxzZSBpZiAoYXJnLmNvbnN0cnVjdG9yID09PSBPYmplY3QpIHtcbiAgICAgIGxvZ0FyZ3MucHVzaChKU09OLnN0cmluZ2lmeShhcmcpKVxuICAgIH1cbiAgfVxuICByZXR1cm4gbG9nQXJnc1xufVxuLyogYzggaWdub3JlIHN0b3AgKi9cblxuY29uc3QgbG9nZ2luZ0NvbG9ycyA9IFtHUkVFTiwgUFVSUExFLCBPUkFOR0UsIEJMVUVdXG5sZXQgbmV4dENvbG9yID0gMFxubGV0IGxhc3RMb2dnaW5nVGltZSA9IHRpbWUuZ2V0VW5peFRpbWUoKVxuXG4vKiBjOCBpZ25vcmUgc3RhcnQgKi9cbi8qKlxuICogQHBhcmFtIHtmdW5jdGlvbiguLi5hbnkpOnZvaWR9IF9wcmludFxuICogQHBhcmFtIHtzdHJpbmd9IG1vZHVsZU5hbWVcbiAqIEByZXR1cm4ge2Z1bmN0aW9uKC4uLmFueSk6dm9pZH1cbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZU1vZHVsZUxvZ2dlciA9IChfcHJpbnQsIG1vZHVsZU5hbWUpID0+IHtcbiAgY29uc3QgY29sb3IgPSBsb2dnaW5nQ29sb3JzW25leHRDb2xvcl1cbiAgY29uc3QgZGVidWdSZWdleFZhciA9IGVudi5nZXRWYXJpYWJsZSgnbG9nJylcbiAgY29uc3QgZG9Mb2dnaW5nID0gZGVidWdSZWdleFZhciAhPT0gbnVsbCAmJlxuICAgIChkZWJ1Z1JlZ2V4VmFyID09PSAnKicgfHwgZGVidWdSZWdleFZhciA9PT0gJ3RydWUnIHx8XG4gICAgICBuZXcgUmVnRXhwKGRlYnVnUmVnZXhWYXIsICdnaScpLnRlc3QobW9kdWxlTmFtZSkpXG4gIG5leHRDb2xvciA9IChuZXh0Q29sb3IgKyAxKSAlIGxvZ2dpbmdDb2xvcnMubGVuZ3RoXG4gIG1vZHVsZU5hbWUgKz0gJzogJ1xuICByZXR1cm4gIWRvTG9nZ2luZ1xuICAgID8gZnVuYy5ub3BcbiAgICA6ICguLi5hcmdzKSA9PiB7XG4gICAgICAgIGNvbnN0IHRpbWVOb3cgPSB0aW1lLmdldFVuaXhUaW1lKClcbiAgICAgICAgY29uc3QgdGltZURpZmYgPSB0aW1lTm93IC0gbGFzdExvZ2dpbmdUaW1lXG4gICAgICAgIGxhc3RMb2dnaW5nVGltZSA9IHRpbWVOb3dcbiAgICAgICAgX3ByaW50KFxuICAgICAgICAgIGNvbG9yLFxuICAgICAgICAgIG1vZHVsZU5hbWUsXG4gICAgICAgICAgVU5DT0xPUixcbiAgICAgICAgICAuLi5hcmdzLm1hcCgoYXJnKSA9PlxuICAgICAgICAgICAgKHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnKVxuICAgICAgICAgICAgICA/IGFyZ1xuICAgICAgICAgICAgICA6IEpTT04uc3RyaW5naWZ5KGFyZylcbiAgICAgICAgICApLFxuICAgICAgICAgIGNvbG9yLFxuICAgICAgICAgICcgKycgKyB0aW1lRGlmZiArICdtcydcbiAgICAgICAgKVxuICAgICAgfVxufVxuLyogYzggaWdub3JlIHN0b3AgKi9cbiIsICIvKipcbiAqIElzb21vcnBoaWMgbG9nZ2luZyBtb2R1bGUgd2l0aCBzdXBwb3J0IGZvciBjb2xvcnMhXG4gKlxuICogQG1vZHVsZSBsb2dnaW5nXG4gKi9cblxuaW1wb3J0ICogYXMgZW52IGZyb20gJy4vZW52aXJvbm1lbnQuanMnXG5pbXBvcnQgKiBhcyBzZXQgZnJvbSAnLi9zZXQuanMnXG5pbXBvcnQgKiBhcyBwYWlyIGZyb20gJy4vcGFpci5qcydcbmltcG9ydCAqIGFzIGRvbSBmcm9tICcuL2RvbS5qcydcbmltcG9ydCAqIGFzIGpzb24gZnJvbSAnLi9qc29uLmpzJ1xuaW1wb3J0ICogYXMgbWFwIGZyb20gJy4vbWFwLmpzJ1xuaW1wb3J0ICogYXMgZXZlbnRsb29wIGZyb20gJy4vZXZlbnRsb29wLmpzJ1xuaW1wb3J0ICogYXMgbWF0aCBmcm9tICcuL21hdGguanMnXG5pbXBvcnQgKiBhcyBjb21tb24gZnJvbSAnLi9sb2dnaW5nLmNvbW1vbi5qcydcblxuZXhwb3J0IHsgQk9MRCwgVU5CT0xELCBCTFVFLCBHUkVZLCBHUkVFTiwgUkVELCBQVVJQTEUsIE9SQU5HRSwgVU5DT0xPUiB9IGZyb20gJy4vbG9nZ2luZy5jb21tb24uanMnXG5cbi8qKlxuICogQHR5cGUge09iamVjdDxTeW1ib2wscGFpci5QYWlyPHN0cmluZyxzdHJpbmc+Pn1cbiAqL1xuY29uc3QgX2Jyb3dzZXJTdHlsZU1hcCA9IHtcbiAgW2NvbW1vbi5CT0xEXTogcGFpci5jcmVhdGUoJ2ZvbnQtd2VpZ2h0JywgJ2JvbGQnKSxcbiAgW2NvbW1vbi5VTkJPTERdOiBwYWlyLmNyZWF0ZSgnZm9udC13ZWlnaHQnLCAnbm9ybWFsJyksXG4gIFtjb21tb24uQkxVRV06IHBhaXIuY3JlYXRlKCdjb2xvcicsICdibHVlJyksXG4gIFtjb21tb24uR1JFRU5dOiBwYWlyLmNyZWF0ZSgnY29sb3InLCAnZ3JlZW4nKSxcbiAgW2NvbW1vbi5HUkVZXTogcGFpci5jcmVhdGUoJ2NvbG9yJywgJ2dyZXknKSxcbiAgW2NvbW1vbi5SRURdOiBwYWlyLmNyZWF0ZSgnY29sb3InLCAncmVkJyksXG4gIFtjb21tb24uUFVSUExFXTogcGFpci5jcmVhdGUoJ2NvbG9yJywgJ3B1cnBsZScpLFxuICBbY29tbW9uLk9SQU5HRV06IHBhaXIuY3JlYXRlKCdjb2xvcicsICdvcmFuZ2UnKSwgLy8gbm90IHdlbGwgc3VwcG9ydGVkIGluIGNocm9tZSB3aGVuIGRlYnVnZ2luZyBub2RlIHdpdGggaW5zcGVjdG9yIC0gVE9ETzogZGVwcmVjYXRlXG4gIFtjb21tb24uVU5DT0xPUl06IHBhaXIuY3JlYXRlKCdjb2xvcicsICdibGFjaycpXG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxzdHJpbmd8U3ltYm9sfE9iamVjdHxudW1iZXI+fSBhcmdzXG4gKiBAcmV0dXJuIHtBcnJheTxzdHJpbmd8b2JqZWN0fG51bWJlcj59XG4gKi9cbi8qIGM4IGlnbm9yZSBzdGFydCAqL1xuY29uc3QgY29tcHV0ZUJyb3dzZXJMb2dnaW5nQXJncyA9IChhcmdzKSA9PiB7XG4gIGNvbnN0IHN0ckJ1aWxkZXIgPSBbXVxuICBjb25zdCBzdHlsZXMgPSBbXVxuICBjb25zdCBjdXJyZW50U3R5bGUgPSBtYXAuY3JlYXRlKClcbiAgLyoqXG4gICAqIEB0eXBlIHtBcnJheTxzdHJpbmd8T2JqZWN0fG51bWJlcj59XG4gICAqL1xuICBsZXQgbG9nQXJncyA9IFtdXG4gIC8vIHRyeSB3aXRoIGZvcm1hdHRpbmcgdW50aWwgd2UgZmluZCBzb21ldGhpbmcgdW5zdXBwb3J0ZWRcbiAgbGV0IGkgPSAwXG4gIGZvciAoOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGFyZyA9IGFyZ3NbaV1cbiAgICAvLyBAdHMtaWdub3JlXG4gICAgY29uc3Qgc3R5bGUgPSBfYnJvd3NlclN0eWxlTWFwW2FyZ11cbiAgICBpZiAoc3R5bGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY3VycmVudFN0eWxlLnNldChzdHlsZS5sZWZ0LCBzdHlsZS5yaWdodClcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGFyZy5jb25zdHJ1Y3RvciA9PT0gU3RyaW5nIHx8IGFyZy5jb25zdHJ1Y3RvciA9PT0gTnVtYmVyKSB7XG4gICAgICAgIGNvbnN0IHN0eWxlID0gZG9tLm1hcFRvU3R5bGVTdHJpbmcoY3VycmVudFN0eWxlKVxuICAgICAgICBpZiAoaSA+IDAgfHwgc3R5bGUubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHN0ckJ1aWxkZXIucHVzaCgnJWMnICsgYXJnKVxuICAgICAgICAgIHN0eWxlcy5wdXNoKHN0eWxlKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0ckJ1aWxkZXIucHVzaChhcmcpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChpID4gMCkge1xuICAgIC8vIGNyZWF0ZSBsb2dBcmdzIHdpdGggd2hhdCB3ZSBoYXZlIHNvIGZhclxuICAgIGxvZ0FyZ3MgPSBzdHlsZXNcbiAgICBsb2dBcmdzLnVuc2hpZnQoc3RyQnVpbGRlci5qb2luKCcnKSlcbiAgfVxuICAvLyBhcHBlbmQgdGhlIHJlc3RcbiAgZm9yICg7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgYXJnID0gYXJnc1tpXVxuICAgIGlmICghKGFyZyBpbnN0YW5jZW9mIFN5bWJvbCkpIHtcbiAgICAgIGxvZ0FyZ3MucHVzaChhcmcpXG4gICAgfVxuICB9XG4gIHJldHVybiBsb2dBcmdzXG59XG4vKiBjOCBpZ25vcmUgc3RvcCAqL1xuXG4vKiBjOCBpZ25vcmUgc3RhcnQgKi9cbmNvbnN0IGNvbXB1dGVMb2dnaW5nQXJncyA9IGVudi5zdXBwb3J0c0NvbG9yXG4gID8gY29tcHV0ZUJyb3dzZXJMb2dnaW5nQXJnc1xuICA6IGNvbW1vbi5jb21wdXRlTm9Db2xvckxvZ2dpbmdBcmdzXG4vKiBjOCBpZ25vcmUgc3RvcCAqL1xuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nfFN5bWJvbHxPYmplY3R8bnVtYmVyPn0gYXJnc1xuICovXG5leHBvcnQgY29uc3QgcHJpbnQgPSAoLi4uYXJncykgPT4ge1xuICBjb25zb2xlLmxvZyguLi5jb21wdXRlTG9nZ2luZ0FyZ3MoYXJncykpXG4gIC8qIGM4IGlnbm9yZSBuZXh0ICovXG4gIHZjb25zb2xlcy5mb3JFYWNoKCh2YykgPT4gdmMucHJpbnQoYXJncykpXG59XG5cbi8qIGM4IGlnbm9yZSBzdGFydCAqL1xuLyoqXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZ3xTeW1ib2x8T2JqZWN0fG51bWJlcj59IGFyZ3NcbiAqL1xuZXhwb3J0IGNvbnN0IHdhcm4gPSAoLi4uYXJncykgPT4ge1xuICBjb25zb2xlLndhcm4oLi4uY29tcHV0ZUxvZ2dpbmdBcmdzKGFyZ3MpKVxuICBhcmdzLnVuc2hpZnQoY29tbW9uLk9SQU5HRSlcbiAgdmNvbnNvbGVzLmZvckVhY2goKHZjKSA9PiB2Yy5wcmludChhcmdzKSlcbn1cbi8qIGM4IGlnbm9yZSBzdG9wICovXG5cbi8qKlxuICogQHBhcmFtIHtFcnJvcn0gZXJyXG4gKi9cbi8qIGM4IGlnbm9yZSBzdGFydCAqL1xuZXhwb3J0IGNvbnN0IHByaW50RXJyb3IgPSAoZXJyKSA9PiB7XG4gIGNvbnNvbGUuZXJyb3IoZXJyKVxuICB2Y29uc29sZXMuZm9yRWFjaCgodmMpID0+IHZjLnByaW50RXJyb3IoZXJyKSlcbn1cbi8qIGM4IGlnbm9yZSBzdG9wICovXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHVybCBpbWFnZSBsb2NhdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCBoZWlnaHQgb2YgdGhlIGltYWdlIGluIHBpeGVsXG4gKi9cbi8qIGM4IGlnbm9yZSBzdGFydCAqL1xuZXhwb3J0IGNvbnN0IHByaW50SW1nID0gKHVybCwgaGVpZ2h0KSA9PiB7XG4gIGlmIChlbnYuaXNCcm93c2VyKSB7XG4gICAgY29uc29sZS5sb2coXG4gICAgICAnJWMgICAgICAgICAgICAgICAgICAgICAgJyxcbiAgICAgIGBmb250LXNpemU6ICR7aGVpZ2h0fXB4OyBiYWNrZ3JvdW5kLXNpemU6IGNvbnRhaW47IGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7IGJhY2tncm91bmQtaW1hZ2U6IHVybCgke3VybH0pYFxuICAgIClcbiAgICAvLyBjb25zb2xlLmxvZygnJWMgICAgICAgICAgICAgICAgJywgYGZvbnQtc2l6ZTogJHtoZWlnaHR9eDsgYmFja2dyb3VuZDogdXJsKCR7dXJsfSkgbm8tcmVwZWF0O2ApXG4gIH1cbiAgdmNvbnNvbGVzLmZvckVhY2goKHZjKSA9PiB2Yy5wcmludEltZyh1cmwsIGhlaWdodCkpXG59XG4vKiBjOCBpZ25vcmUgc3RvcCAqL1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlNjRcbiAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHRcbiAqL1xuLyogYzggaWdub3JlIG5leHQgMiAqL1xuZXhwb3J0IGNvbnN0IHByaW50SW1nQmFzZTY0ID0gKGJhc2U2NCwgaGVpZ2h0KSA9PlxuICBwcmludEltZyhgZGF0YTppbWFnZS9naWY7YmFzZTY0LCR7YmFzZTY0fWAsIGhlaWdodClcblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZ3xTeW1ib2x8T2JqZWN0fG51bWJlcj59IGFyZ3NcbiAqL1xuZXhwb3J0IGNvbnN0IGdyb3VwID0gKC4uLmFyZ3MpID0+IHtcbiAgY29uc29sZS5ncm91cCguLi5jb21wdXRlTG9nZ2luZ0FyZ3MoYXJncykpXG4gIC8qIGM4IGlnbm9yZSBuZXh0ICovXG4gIHZjb25zb2xlcy5mb3JFYWNoKCh2YykgPT4gdmMuZ3JvdXAoYXJncykpXG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxzdHJpbmd8U3ltYm9sfE9iamVjdHxudW1iZXI+fSBhcmdzXG4gKi9cbmV4cG9ydCBjb25zdCBncm91cENvbGxhcHNlZCA9ICguLi5hcmdzKSA9PiB7XG4gIGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQoLi4uY29tcHV0ZUxvZ2dpbmdBcmdzKGFyZ3MpKVxuICAvKiBjOCBpZ25vcmUgbmV4dCAqL1xuICB2Y29uc29sZXMuZm9yRWFjaCgodmMpID0+IHZjLmdyb3VwQ29sbGFwc2VkKGFyZ3MpKVxufVxuXG5leHBvcnQgY29uc3QgZ3JvdXBFbmQgPSAoKSA9PiB7XG4gIGNvbnNvbGUuZ3JvdXBFbmQoKVxuICAvKiBjOCBpZ25vcmUgbmV4dCAqL1xuICB2Y29uc29sZXMuZm9yRWFjaCgodmMpID0+IHZjLmdyb3VwRW5kKCkpXG59XG5cbi8qKlxuICogQHBhcmFtIHtmdW5jdGlvbigpOk5vZGV9IGNyZWF0ZU5vZGVcbiAqL1xuLyogYzggaWdub3JlIG5leHQgMiAqL1xuZXhwb3J0IGNvbnN0IHByaW50RG9tID0gKGNyZWF0ZU5vZGUpID0+XG4gIHZjb25zb2xlcy5mb3JFYWNoKCh2YykgPT4gdmMucHJpbnREb20oY3JlYXRlTm9kZSgpKSlcblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fSBjYW52YXNcbiAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHRcbiAqL1xuLyogYzggaWdub3JlIG5leHQgMiAqL1xuZXhwb3J0IGNvbnN0IHByaW50Q2FudmFzID0gKGNhbnZhcywgaGVpZ2h0KSA9PlxuICBwcmludEltZyhjYW52YXMudG9EYXRhVVJMKCksIGhlaWdodClcblxuZXhwb3J0IGNvbnN0IHZjb25zb2xlcyA9IHNldC5jcmVhdGUoKVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nfFN5bWJvbHxPYmplY3R8bnVtYmVyPn0gYXJnc1xuICogQHJldHVybiB7QXJyYXk8RWxlbWVudD59XG4gKi9cbi8qIGM4IGlnbm9yZSBzdGFydCAqL1xuY29uc3QgX2NvbXB1dGVMaW5lU3BhbnMgPSAoYXJncykgPT4ge1xuICBjb25zdCBzcGFucyA9IFtdXG4gIGNvbnN0IGN1cnJlbnRTdHlsZSA9IG5ldyBNYXAoKVxuICAvLyB0cnkgd2l0aCBmb3JtYXR0aW5nIHVudGlsIHdlIGZpbmQgc29tZXRoaW5nIHVuc3VwcG9ydGVkXG4gIGxldCBpID0gMFxuICBmb3IgKDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBhcmcgPSBhcmdzW2ldXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGNvbnN0IHN0eWxlID0gX2Jyb3dzZXJTdHlsZU1hcFthcmddXG4gICAgaWYgKHN0eWxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGN1cnJlbnRTdHlsZS5zZXQoc3R5bGUubGVmdCwgc3R5bGUucmlnaHQpXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChhcmcuY29uc3RydWN0b3IgPT09IFN0cmluZyB8fCBhcmcuY29uc3RydWN0b3IgPT09IE51bWJlcikge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGNvbnN0IHNwYW4gPSBkb20uZWxlbWVudCgnc3BhbicsIFtcbiAgICAgICAgICBwYWlyLmNyZWF0ZSgnc3R5bGUnLCBkb20ubWFwVG9TdHlsZVN0cmluZyhjdXJyZW50U3R5bGUpKVxuICAgICAgICBdLCBbZG9tLnRleHQoYXJnLnRvU3RyaW5nKCkpXSlcbiAgICAgICAgaWYgKHNwYW4uaW5uZXJIVE1MID09PSAnJykge1xuICAgICAgICAgIHNwYW4uaW5uZXJIVE1MID0gJyZuYnNwOydcbiAgICAgICAgfVxuICAgICAgICBzcGFucy5wdXNoKHNwYW4pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvLyBhcHBlbmQgdGhlIHJlc3RcbiAgZm9yICg7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgbGV0IGNvbnRlbnQgPSBhcmdzW2ldXG4gICAgaWYgKCEoY29udGVudCBpbnN0YW5jZW9mIFN5bWJvbCkpIHtcbiAgICAgIGlmIChjb250ZW50LmNvbnN0cnVjdG9yICE9PSBTdHJpbmcgJiYgY29udGVudC5jb25zdHJ1Y3RvciAhPT0gTnVtYmVyKSB7XG4gICAgICAgIGNvbnRlbnQgPSAnICcgKyBqc29uLnN0cmluZ2lmeShjb250ZW50KSArICcgJ1xuICAgICAgfVxuICAgICAgc3BhbnMucHVzaChcbiAgICAgICAgZG9tLmVsZW1lbnQoJ3NwYW4nLCBbXSwgW2RvbS50ZXh0KC8qKiBAdHlwZSB7c3RyaW5nfSAqLyAoY29udGVudCkpXSlcbiAgICAgIClcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNwYW5zXG59XG4vKiBjOCBpZ25vcmUgc3RvcCAqL1xuXG5jb25zdCBsaW5lU3R5bGUgPVxuICAnZm9udC1mYW1pbHk6bW9ub3NwYWNlO2JvcmRlci1ib3R0b206MXB4IHNvbGlkICNlMmUyZTI7cGFkZGluZzoycHg7J1xuXG4vKiBjOCBpZ25vcmUgc3RhcnQgKi9cbmV4cG9ydCBjbGFzcyBWQ29uc29sZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGRvbVxuICAgKi9cbiAgY29uc3RydWN0b3IgKGRvbSkge1xuICAgIHRoaXMuZG9tID0gZG9tXG4gICAgLyoqXG4gICAgICogQHR5cGUge0VsZW1lbnR9XG4gICAgICovXG4gICAgdGhpcy5jY29udGFpbmVyID0gdGhpcy5kb21cbiAgICB0aGlzLmRlcHRoID0gMFxuICAgIHZjb25zb2xlcy5hZGQodGhpcylcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0FycmF5PHN0cmluZ3xTeW1ib2x8T2JqZWN0fG51bWJlcj59IGFyZ3NcbiAgICogQHBhcmFtIHtib29sZWFufSBjb2xsYXBzZWRcbiAgICovXG4gIGdyb3VwIChhcmdzLCBjb2xsYXBzZWQgPSBmYWxzZSkge1xuICAgIGV2ZW50bG9vcC5lbnF1ZXVlKCgpID0+IHtcbiAgICAgIGNvbnN0IHRyaWFuZ2xlRG93biA9IGRvbS5lbGVtZW50KCdzcGFuJywgW1xuICAgICAgICBwYWlyLmNyZWF0ZSgnaGlkZGVuJywgY29sbGFwc2VkKSxcbiAgICAgICAgcGFpci5jcmVhdGUoJ3N0eWxlJywgJ2NvbG9yOmdyZXk7Zm9udC1zaXplOjEyMCU7JylcbiAgICAgIF0sIFtkb20udGV4dCgnXHUyNUJDJyldKVxuICAgICAgY29uc3QgdHJpYW5nbGVSaWdodCA9IGRvbS5lbGVtZW50KCdzcGFuJywgW1xuICAgICAgICBwYWlyLmNyZWF0ZSgnaGlkZGVuJywgIWNvbGxhcHNlZCksXG4gICAgICAgIHBhaXIuY3JlYXRlKCdzdHlsZScsICdjb2xvcjpncmV5O2ZvbnQtc2l6ZToxMjUlOycpXG4gICAgICBdLCBbZG9tLnRleHQoJ1x1MjVCNicpXSlcbiAgICAgIGNvbnN0IGNvbnRlbnQgPSBkb20uZWxlbWVudChcbiAgICAgICAgJ2RpdicsXG4gICAgICAgIFtwYWlyLmNyZWF0ZShcbiAgICAgICAgICAnc3R5bGUnLFxuICAgICAgICAgIGAke2xpbmVTdHlsZX07cGFkZGluZy1sZWZ0OiR7dGhpcy5kZXB0aCAqIDEwfXB4YFxuICAgICAgICApXSxcbiAgICAgICAgW3RyaWFuZ2xlRG93biwgdHJpYW5nbGVSaWdodCwgZG9tLnRleHQoJyAnKV0uY29uY2F0KFxuICAgICAgICAgIF9jb21wdXRlTGluZVNwYW5zKGFyZ3MpXG4gICAgICAgIClcbiAgICAgIClcbiAgICAgIGNvbnN0IG5leHRDb250YWluZXIgPSBkb20uZWxlbWVudCgnZGl2JywgW1xuICAgICAgICBwYWlyLmNyZWF0ZSgnaGlkZGVuJywgY29sbGFwc2VkKVxuICAgICAgXSlcbiAgICAgIGNvbnN0IG5leHRMaW5lID0gZG9tLmVsZW1lbnQoJ2RpdicsIFtdLCBbY29udGVudCwgbmV4dENvbnRhaW5lcl0pXG4gICAgICBkb20uYXBwZW5kKHRoaXMuY2NvbnRhaW5lciwgW25leHRMaW5lXSlcbiAgICAgIHRoaXMuY2NvbnRhaW5lciA9IG5leHRDb250YWluZXJcbiAgICAgIHRoaXMuZGVwdGgrK1xuICAgICAgLy8gd2hlbiBoZWFkZXIgaXMgY2xpY2tlZCwgY29sbGFwc2UvdW5jb2xsYXBzZSBjb250YWluZXJcbiAgICAgIGRvbS5hZGRFdmVudExpc3RlbmVyKGNvbnRlbnQsICdjbGljaycsIChfZXZlbnQpID0+IHtcbiAgICAgICAgbmV4dENvbnRhaW5lci50b2dnbGVBdHRyaWJ1dGUoJ2hpZGRlbicpXG4gICAgICAgIHRyaWFuZ2xlRG93bi50b2dnbGVBdHRyaWJ1dGUoJ2hpZGRlbicpXG4gICAgICAgIHRyaWFuZ2xlUmlnaHQudG9nZ2xlQXR0cmlidXRlKCdoaWRkZW4nKVxuICAgICAgfSlcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nfFN5bWJvbHxPYmplY3R8bnVtYmVyPn0gYXJnc1xuICAgKi9cbiAgZ3JvdXBDb2xsYXBzZWQgKGFyZ3MpIHtcbiAgICB0aGlzLmdyb3VwKGFyZ3MsIHRydWUpXG4gIH1cblxuICBncm91cEVuZCAoKSB7XG4gICAgZXZlbnRsb29wLmVucXVldWUoKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuZGVwdGggPiAwKSB7XG4gICAgICAgIHRoaXMuZGVwdGgtLVxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHRoaXMuY2NvbnRhaW5lciA9IHRoaXMuY2NvbnRhaW5lci5wYXJlbnRFbGVtZW50LnBhcmVudEVsZW1lbnRcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nfFN5bWJvbHxPYmplY3R8bnVtYmVyPn0gYXJnc1xuICAgKi9cbiAgcHJpbnQgKGFyZ3MpIHtcbiAgICBldmVudGxvb3AuZW5xdWV1ZSgoKSA9PiB7XG4gICAgICBkb20uYXBwZW5kKHRoaXMuY2NvbnRhaW5lciwgW1xuICAgICAgICBkb20uZWxlbWVudCgnZGl2JywgW1xuICAgICAgICAgIHBhaXIuY3JlYXRlKFxuICAgICAgICAgICAgJ3N0eWxlJyxcbiAgICAgICAgICAgIGAke2xpbmVTdHlsZX07cGFkZGluZy1sZWZ0OiR7dGhpcy5kZXB0aCAqIDEwfXB4YFxuICAgICAgICAgIClcbiAgICAgICAgXSwgX2NvbXB1dGVMaW5lU3BhbnMoYXJncykpXG4gICAgICBdKVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtFcnJvcn0gZXJyXG4gICAqL1xuICBwcmludEVycm9yIChlcnIpIHtcbiAgICB0aGlzLnByaW50KFtjb21tb24uUkVELCBjb21tb24uQk9MRCwgZXJyLnRvU3RyaW5nKCldKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcbiAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodFxuICAgKi9cbiAgcHJpbnRJbWcgKHVybCwgaGVpZ2h0KSB7XG4gICAgZXZlbnRsb29wLmVucXVldWUoKCkgPT4ge1xuICAgICAgZG9tLmFwcGVuZCh0aGlzLmNjb250YWluZXIsIFtcbiAgICAgICAgZG9tLmVsZW1lbnQoJ2ltZycsIFtcbiAgICAgICAgICBwYWlyLmNyZWF0ZSgnc3JjJywgdXJsKSxcbiAgICAgICAgICBwYWlyLmNyZWF0ZSgnaGVpZ2h0JywgYCR7bWF0aC5yb3VuZChoZWlnaHQgKiAxLjUpfXB4YClcbiAgICAgICAgXSlcbiAgICAgIF0pXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAgICovXG4gIHByaW50RG9tIChub2RlKSB7XG4gICAgZXZlbnRsb29wLmVucXVldWUoKCkgPT4ge1xuICAgICAgZG9tLmFwcGVuZCh0aGlzLmNjb250YWluZXIsIFtub2RlXSlcbiAgICB9KVxuICB9XG5cbiAgZGVzdHJveSAoKSB7XG4gICAgZXZlbnRsb29wLmVucXVldWUoKCkgPT4ge1xuICAgICAgdmNvbnNvbGVzLmRlbGV0ZSh0aGlzKVxuICAgIH0pXG4gIH1cbn1cbi8qIGM4IGlnbm9yZSBzdG9wICovXG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBkb21cbiAqL1xuLyogYzggaWdub3JlIG5leHQgKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVWQ29uc29sZSA9IChkb20pID0+IG5ldyBWQ29uc29sZShkb20pXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IG1vZHVsZU5hbWVcbiAqIEByZXR1cm4ge2Z1bmN0aW9uKC4uLmFueSk6dm9pZH1cbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZU1vZHVsZUxvZ2dlciA9IChtb2R1bGVOYW1lKSA9PiBjb21tb24uY3JlYXRlTW9kdWxlTG9nZ2VyKHByaW50LCBtb2R1bGVOYW1lKVxuIiwgIi8qKlxuICogVXRpbGl0eSBtb2R1bGUgdG8gY3JlYXRlIGFuZCBtYW5pcHVsYXRlIEl0ZXJhdG9ycy5cbiAqXG4gKiBAbW9kdWxlIGl0ZXJhdG9yXG4gKi9cblxuLyoqXG4gKiBAdGVtcGxhdGUgVCxSXG4gKiBAcGFyYW0ge0l0ZXJhdG9yPFQ+fSBpdGVyYXRvclxuICogQHBhcmFtIHtmdW5jdGlvbihUKTpSfSBmXG4gKiBAcmV0dXJuIHtJdGVyYWJsZUl0ZXJhdG9yPFI+fVxuICovXG5leHBvcnQgY29uc3QgbWFwSXRlcmF0b3IgPSAoaXRlcmF0b3IsIGYpID0+ICh7XG4gIFtTeW1ib2wuaXRlcmF0b3JdICgpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9LFxuICAvLyBAdHMtaWdub3JlXG4gIG5leHQgKCkge1xuICAgIGNvbnN0IHIgPSBpdGVyYXRvci5uZXh0KClcbiAgICByZXR1cm4geyB2YWx1ZTogci5kb25lID8gdW5kZWZpbmVkIDogZihyLnZhbHVlKSwgZG9uZTogci5kb25lIH1cbiAgfVxufSlcblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtmdW5jdGlvbigpOkl0ZXJhdG9yUmVzdWx0PFQ+fSBuZXh0XG4gKiBAcmV0dXJuIHtJdGVyYWJsZUl0ZXJhdG9yPFQ+fVxuICovXG5leHBvcnQgY29uc3QgY3JlYXRlSXRlcmF0b3IgPSBuZXh0ID0+ICh7XG4gIC8qKlxuICAgKiBAcmV0dXJuIHtJdGVyYWJsZUl0ZXJhdG9yPFQ+fVxuICAgKi9cbiAgW1N5bWJvbC5pdGVyYXRvcl0gKCkge1xuICAgIHJldHVybiB0aGlzXG4gIH0sXG4gIC8vIEB0cy1pZ25vcmVcbiAgbmV4dFxufSlcblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtJdGVyYXRvcjxUPn0gaXRlcmF0b3JcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oVCk6Ym9vbGVhbn0gZmlsdGVyXG4gKi9cbmV4cG9ydCBjb25zdCBpdGVyYXRvckZpbHRlciA9IChpdGVyYXRvciwgZmlsdGVyKSA9PiBjcmVhdGVJdGVyYXRvcigoKSA9PiB7XG4gIGxldCByZXNcbiAgZG8ge1xuICAgIHJlcyA9IGl0ZXJhdG9yLm5leHQoKVxuICB9IHdoaWxlICghcmVzLmRvbmUgJiYgIWZpbHRlcihyZXMudmFsdWUpKVxuICByZXR1cm4gcmVzXG59KVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBULE1cbiAqIEBwYXJhbSB7SXRlcmF0b3I8VD59IGl0ZXJhdG9yXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKFQpOk19IGZtYXBcbiAqL1xuZXhwb3J0IGNvbnN0IGl0ZXJhdG9yTWFwID0gKGl0ZXJhdG9yLCBmbWFwKSA9PiBjcmVhdGVJdGVyYXRvcigoKSA9PiB7XG4gIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGl0ZXJhdG9yLm5leHQoKVxuICByZXR1cm4geyBkb25lLCB2YWx1ZTogZG9uZSA/IHVuZGVmaW5lZCA6IGZtYXAodmFsdWUpIH1cbn0pXG4iLCAiXG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAnbGliMC9vYnNlcnZhYmxlJ1xuXG5pbXBvcnQge1xuICBEb2MgLy8gZXNsaW50LWRpc2FibGUtbGluZVxufSBmcm9tICcuLi9pbnRlcm5hbHMuanMnXG5cbi8qKlxuICogVGhpcyBpcyBhbiBhYnN0cmFjdCBpbnRlcmZhY2UgdGhhdCBhbGwgQ29ubmVjdG9ycyBzaG91bGQgaW1wbGVtZW50IHRvIGtlZXAgdGhlbSBpbnRlcmNoYW5nZWFibGUuXG4gKlxuICogQG5vdGUgVGhpcyBpbnRlcmZhY2UgaXMgZXhwZXJpbWVudGFsIGFuZCBpdCBpcyBub3QgYWR2aXNlZCB0byBhY3R1YWxseSBpbmhlcml0IHRoaXMgY2xhc3MuXG4gKiAgICAgICBJdCBqdXN0IHNlcnZlcyBhcyB0eXBpbmcgaW5mb3JtYXRpb24uXG4gKlxuICogQGV4dGVuZHMge09ic2VydmFibGU8YW55Pn1cbiAqL1xuZXhwb3J0IGNsYXNzIEFic3RyYWN0Q29ubmVjdG9yIGV4dGVuZHMgT2JzZXJ2YWJsZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0RvY30geWRvY1xuICAgKiBAcGFyYW0ge2FueX0gYXdhcmVuZXNzXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoeWRvYywgYXdhcmVuZXNzKSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMuZG9jID0geWRvY1xuICAgIHRoaXMuYXdhcmVuZXNzID0gYXdhcmVuZXNzXG4gIH1cbn1cbiIsICJcbmltcG9ydCB7XG4gIGZpbmRJbmRleFNTLFxuICBnZXRTdGF0ZSxcbiAgc3BsaXRJdGVtLFxuICBpdGVyYXRlU3RydWN0cyxcbiAgVXBkYXRlRW5jb2RlclYyLFxuICBEU0RlY29kZXJWMSwgRFNFbmNvZGVyVjEsIERTRGVjb2RlclYyLCBEU0VuY29kZXJWMiwgSXRlbSwgR0MsIFN0cnVjdFN0b3JlLCBUcmFuc2FjdGlvbiwgSUQgLy8gZXNsaW50LWRpc2FibGUtbGluZVxufSBmcm9tICcuLi9pbnRlcm5hbHMuanMnXG5cbmltcG9ydCAqIGFzIGFycmF5IGZyb20gJ2xpYjAvYXJyYXknXG5pbXBvcnQgKiBhcyBtYXRoIGZyb20gJ2xpYjAvbWF0aCdcbmltcG9ydCAqIGFzIG1hcCBmcm9tICdsaWIwL21hcCdcbmltcG9ydCAqIGFzIGVuY29kaW5nIGZyb20gJ2xpYjAvZW5jb2RpbmcnXG5pbXBvcnQgKiBhcyBkZWNvZGluZyBmcm9tICdsaWIwL2RlY29kaW5nJ1xuXG5leHBvcnQgY2xhc3MgRGVsZXRlSXRlbSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gY2xvY2tcbiAgICogQHBhcmFtIHtudW1iZXJ9IGxlblxuICAgKi9cbiAgY29uc3RydWN0b3IgKGNsb2NrLCBsZW4pIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuY2xvY2sgPSBjbG9ja1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5sZW4gPSBsZW5cbiAgfVxufVxuXG4vKipcbiAqIFdlIG5vIGxvbmdlciBtYWludGFpbiBhIERlbGV0ZVN0b3JlLiBEZWxldGVTZXQgaXMgYSB0ZW1wb3Jhcnkgb2JqZWN0IHRoYXQgaXMgY3JlYXRlZCB3aGVuIG5lZWRlZC5cbiAqIC0gV2hlbiBjcmVhdGVkIGluIGEgdHJhbnNhY3Rpb24sIGl0IG11c3Qgb25seSBiZSBhY2Nlc3NlZCBhZnRlciBzb3J0aW5nLCBhbmQgbWVyZ2luZ1xuICogICAtIFRoaXMgRGVsZXRlU2V0IGlzIHNlbmQgdG8gb3RoZXIgY2xpZW50c1xuICogLSBXZSBkbyBub3QgY3JlYXRlIGEgRGVsZXRlU2V0IHdoZW4gd2Ugc2VuZCBhIHN5bmMgbWVzc2FnZS4gVGhlIERlbGV0ZVNldCBtZXNzYWdlIGlzIGNyZWF0ZWQgZGlyZWN0bHkgZnJvbSBTdHJ1Y3RTdG9yZVxuICogLSBXZSByZWFkIGEgRGVsZXRlU2V0IGFzIHBhcnQgb2YgYSBzeW5jL3VwZGF0ZSBtZXNzYWdlLiBJbiB0aGlzIGNhc2UgdGhlIERlbGV0ZVNldCBpcyBhbHJlYWR5IHNvcnRlZCBhbmQgbWVyZ2VkLlxuICovXG5leHBvcnQgY2xhc3MgRGVsZXRlU2V0IHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtNYXA8bnVtYmVyLEFycmF5PERlbGV0ZUl0ZW0+Pn1cbiAgICAgKi9cbiAgICB0aGlzLmNsaWVudHMgPSBuZXcgTWFwKClcbiAgfVxufVxuXG4vKipcbiAqIEl0ZXJhdGUgb3ZlciBhbGwgc3RydWN0cyB0aGF0IHRoZSBEZWxldGVTZXQgZ2Mncy5cbiAqXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtEZWxldGVTZXR9IGRzXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKEdDfEl0ZW0pOnZvaWR9IGZcbiAqXG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IGl0ZXJhdGVEZWxldGVkU3RydWN0cyA9ICh0cmFuc2FjdGlvbiwgZHMsIGYpID0+XG4gIGRzLmNsaWVudHMuZm9yRWFjaCgoZGVsZXRlcywgY2xpZW50aWQpID0+IHtcbiAgICBjb25zdCBzdHJ1Y3RzID0gLyoqIEB0eXBlIHtBcnJheTxHQ3xJdGVtPn0gKi8gKHRyYW5zYWN0aW9uLmRvYy5zdG9yZS5jbGllbnRzLmdldChjbGllbnRpZCkpXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZWxldGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBkZWwgPSBkZWxldGVzW2ldXG4gICAgICBpdGVyYXRlU3RydWN0cyh0cmFuc2FjdGlvbiwgc3RydWN0cywgZGVsLmNsb2NrLCBkZWwubGVuLCBmKVxuICAgIH1cbiAgfSlcblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PERlbGV0ZUl0ZW0+fSBkaXNcbiAqIEBwYXJhbSB7bnVtYmVyfSBjbG9ja1xuICogQHJldHVybiB7bnVtYmVyfG51bGx9XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgZmluZEluZGV4RFMgPSAoZGlzLCBjbG9jaykgPT4ge1xuICBsZXQgbGVmdCA9IDBcbiAgbGV0IHJpZ2h0ID0gZGlzLmxlbmd0aCAtIDFcbiAgd2hpbGUgKGxlZnQgPD0gcmlnaHQpIHtcbiAgICBjb25zdCBtaWRpbmRleCA9IG1hdGguZmxvb3IoKGxlZnQgKyByaWdodCkgLyAyKVxuICAgIGNvbnN0IG1pZCA9IGRpc1ttaWRpbmRleF1cbiAgICBjb25zdCBtaWRjbG9jayA9IG1pZC5jbG9ja1xuICAgIGlmIChtaWRjbG9jayA8PSBjbG9jaykge1xuICAgICAgaWYgKGNsb2NrIDwgbWlkY2xvY2sgKyBtaWQubGVuKSB7XG4gICAgICAgIHJldHVybiBtaWRpbmRleFxuICAgICAgfVxuICAgICAgbGVmdCA9IG1pZGluZGV4ICsgMVxuICAgIH0gZWxzZSB7XG4gICAgICByaWdodCA9IG1pZGluZGV4IC0gMVxuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbFxufVxuXG4vKipcbiAqIEBwYXJhbSB7RGVsZXRlU2V0fSBkc1xuICogQHBhcmFtIHtJRH0gaWRcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgaXNEZWxldGVkID0gKGRzLCBpZCkgPT4ge1xuICBjb25zdCBkaXMgPSBkcy5jbGllbnRzLmdldChpZC5jbGllbnQpXG4gIHJldHVybiBkaXMgIT09IHVuZGVmaW5lZCAmJiBmaW5kSW5kZXhEUyhkaXMsIGlkLmNsb2NrKSAhPT0gbnVsbFxufVxuXG4vKipcbiAqIEBwYXJhbSB7RGVsZXRlU2V0fSBkc1xuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IHNvcnRBbmRNZXJnZURlbGV0ZVNldCA9IGRzID0+IHtcbiAgZHMuY2xpZW50cy5mb3JFYWNoKGRlbHMgPT4ge1xuICAgIGRlbHMuc29ydCgoYSwgYikgPT4gYS5jbG9jayAtIGIuY2xvY2spXG4gICAgLy8gbWVyZ2UgaXRlbXMgd2l0aG91dCBmaWx0ZXJpbmcgb3Igc3BsaWNpbmcgdGhlIGFycmF5XG4gICAgLy8gaSBpcyB0aGUgY3VycmVudCBwb2ludGVyXG4gICAgLy8gaiByZWZlcnMgdG8gdGhlIGN1cnJlbnQgaW5zZXJ0IHBvc2l0aW9uIGZvciB0aGUgcG9pbnRlZCBpdGVtXG4gICAgLy8gdHJ5IHRvIG1lcmdlIGRlbHNbaV0gaW50byBkZWxzW2otMV0gb3Igc2V0IGRlbHNbal09ZGVsc1tpXVxuICAgIGxldCBpLCBqXG4gICAgZm9yIChpID0gMSwgaiA9IDE7IGkgPCBkZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBsZWZ0ID0gZGVsc1tqIC0gMV1cbiAgICAgIGNvbnN0IHJpZ2h0ID0gZGVsc1tpXVxuICAgICAgaWYgKGxlZnQuY2xvY2sgKyBsZWZ0LmxlbiA+PSByaWdodC5jbG9jaykge1xuICAgICAgICBsZWZ0LmxlbiA9IG1hdGgubWF4KGxlZnQubGVuLCByaWdodC5jbG9jayArIHJpZ2h0LmxlbiAtIGxlZnQuY2xvY2spXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaiA8IGkpIHtcbiAgICAgICAgICBkZWxzW2pdID0gcmlnaHRcbiAgICAgICAgfVxuICAgICAgICBqKytcbiAgICAgIH1cbiAgICB9XG4gICAgZGVscy5sZW5ndGggPSBqXG4gIH0pXG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxEZWxldGVTZXQ+fSBkc3NcbiAqIEByZXR1cm4ge0RlbGV0ZVNldH0gQSBmcmVzaCBEZWxldGVTZXRcbiAqL1xuZXhwb3J0IGNvbnN0IG1lcmdlRGVsZXRlU2V0cyA9IGRzcyA9PiB7XG4gIGNvbnN0IG1lcmdlZCA9IG5ldyBEZWxldGVTZXQoKVxuICBmb3IgKGxldCBkc3NJID0gMDsgZHNzSSA8IGRzcy5sZW5ndGg7IGRzc0krKykge1xuICAgIGRzc1tkc3NJXS5jbGllbnRzLmZvckVhY2goKGRlbHNMZWZ0LCBjbGllbnQpID0+IHtcbiAgICAgIGlmICghbWVyZ2VkLmNsaWVudHMuaGFzKGNsaWVudCkpIHtcbiAgICAgICAgLy8gV3JpdGUgYWxsIG1pc3Npbmcga2V5cyBmcm9tIGN1cnJlbnQgZHMgYW5kIGFsbCBmb2xsb3dpbmcuXG4gICAgICAgIC8vIElmIG1lcmdlZCBhbHJlYWR5IGNvbnRhaW5zIGBjbGllbnRgIGN1cnJlbnQgZHMgaGFzIGFscmVhZHkgYmVlbiBhZGRlZC5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtBcnJheTxEZWxldGVJdGVtPn1cbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IGRlbHMgPSBkZWxzTGVmdC5zbGljZSgpXG4gICAgICAgIGZvciAobGV0IGkgPSBkc3NJICsgMTsgaSA8IGRzcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGFycmF5LmFwcGVuZFRvKGRlbHMsIGRzc1tpXS5jbGllbnRzLmdldChjbGllbnQpIHx8IFtdKVxuICAgICAgICB9XG4gICAgICAgIG1lcmdlZC5jbGllbnRzLnNldChjbGllbnQsIGRlbHMpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuICBzb3J0QW5kTWVyZ2VEZWxldGVTZXQobWVyZ2VkKVxuICByZXR1cm4gbWVyZ2VkXG59XG5cbi8qKlxuICogQHBhcmFtIHtEZWxldGVTZXR9IGRzXG4gKiBAcGFyYW0ge251bWJlcn0gY2xpZW50XG4gKiBAcGFyYW0ge251bWJlcn0gY2xvY2tcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGhcbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBhZGRUb0RlbGV0ZVNldCA9IChkcywgY2xpZW50LCBjbG9jaywgbGVuZ3RoKSA9PiB7XG4gIG1hcC5zZXRJZlVuZGVmaW5lZChkcy5jbGllbnRzLCBjbGllbnQsICgpID0+IC8qKiBAdHlwZSB7QXJyYXk8RGVsZXRlSXRlbT59ICovIChbXSkpLnB1c2gobmV3IERlbGV0ZUl0ZW0oY2xvY2ssIGxlbmd0aCkpXG59XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVEZWxldGVTZXQgPSAoKSA9PiBuZXcgRGVsZXRlU2V0KClcblxuLyoqXG4gKiBAcGFyYW0ge1N0cnVjdFN0b3JlfSBzc1xuICogQHJldHVybiB7RGVsZXRlU2V0fSBNZXJnZWQgYW5kIHNvcnRlZCBEZWxldGVTZXRcbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVEZWxldGVTZXRGcm9tU3RydWN0U3RvcmUgPSBzcyA9PiB7XG4gIGNvbnN0IGRzID0gY3JlYXRlRGVsZXRlU2V0KClcbiAgc3MuY2xpZW50cy5mb3JFYWNoKChzdHJ1Y3RzLCBjbGllbnQpID0+IHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QXJyYXk8RGVsZXRlSXRlbT59XG4gICAgICovXG4gICAgY29uc3QgZHNpdGVtcyA9IFtdXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHJ1Y3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBzdHJ1Y3QgPSBzdHJ1Y3RzW2ldXG4gICAgICBpZiAoc3RydWN0LmRlbGV0ZWQpIHtcbiAgICAgICAgY29uc3QgY2xvY2sgPSBzdHJ1Y3QuaWQuY2xvY2tcbiAgICAgICAgbGV0IGxlbiA9IHN0cnVjdC5sZW5ndGhcbiAgICAgICAgaWYgKGkgKyAxIDwgc3RydWN0cy5sZW5ndGgpIHtcbiAgICAgICAgICBmb3IgKGxldCBuZXh0ID0gc3RydWN0c1tpICsgMV07IGkgKyAxIDwgc3RydWN0cy5sZW5ndGggJiYgbmV4dC5kZWxldGVkOyBuZXh0ID0gc3RydWN0c1srK2kgKyAxXSkge1xuICAgICAgICAgICAgbGVuICs9IG5leHQubGVuZ3RoXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGRzaXRlbXMucHVzaChuZXcgRGVsZXRlSXRlbShjbG9jaywgbGVuKSlcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGRzaXRlbXMubGVuZ3RoID4gMCkge1xuICAgICAgZHMuY2xpZW50cy5zZXQoY2xpZW50LCBkc2l0ZW1zKVxuICAgIH1cbiAgfSlcbiAgcmV0dXJuIGRzXG59XG5cbi8qKlxuICogQHBhcmFtIHtEU0VuY29kZXJWMSB8IERTRW5jb2RlclYyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge0RlbGV0ZVNldH0gZHNcbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCB3cml0ZURlbGV0ZVNldCA9IChlbmNvZGVyLCBkcykgPT4ge1xuICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2Rlci5yZXN0RW5jb2RlciwgZHMuY2xpZW50cy5zaXplKVxuXG4gIC8vIEVuc3VyZSB0aGF0IHRoZSBkZWxldGUgc2V0IGlzIHdyaXR0ZW4gaW4gYSBkZXRlcm1pbmlzdGljIG9yZGVyXG4gIGFycmF5LmZyb20oZHMuY2xpZW50cy5lbnRyaWVzKCkpXG4gICAgLnNvcnQoKGEsIGIpID0+IGJbMF0gLSBhWzBdKVxuICAgIC5mb3JFYWNoKChbY2xpZW50LCBkc2l0ZW1zXSkgPT4ge1xuICAgICAgZW5jb2Rlci5yZXNldERzQ3VyVmFsKClcbiAgICAgIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyLnJlc3RFbmNvZGVyLCBjbGllbnQpXG4gICAgICBjb25zdCBsZW4gPSBkc2l0ZW1zLmxlbmd0aFxuICAgICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIucmVzdEVuY29kZXIsIGxlbilcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgY29uc3QgaXRlbSA9IGRzaXRlbXNbaV1cbiAgICAgICAgZW5jb2Rlci53cml0ZURzQ2xvY2soaXRlbS5jbG9jaylcbiAgICAgICAgZW5jb2Rlci53cml0ZURzTGVuKGl0ZW0ubGVuKVxuICAgICAgfVxuICAgIH0pXG59XG5cbi8qKlxuICogQHBhcmFtIHtEU0RlY29kZXJWMSB8IERTRGVjb2RlclYyfSBkZWNvZGVyXG4gKiBAcmV0dXJuIHtEZWxldGVTZXR9XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgcmVhZERlbGV0ZVNldCA9IGRlY29kZXIgPT4ge1xuICBjb25zdCBkcyA9IG5ldyBEZWxldGVTZXQoKVxuICBjb25zdCBudW1DbGllbnRzID0gZGVjb2RpbmcucmVhZFZhclVpbnQoZGVjb2Rlci5yZXN0RGVjb2RlcilcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1DbGllbnRzOyBpKyspIHtcbiAgICBkZWNvZGVyLnJlc2V0RHNDdXJWYWwoKVxuICAgIGNvbnN0IGNsaWVudCA9IGRlY29kaW5nLnJlYWRWYXJVaW50KGRlY29kZXIucmVzdERlY29kZXIpXG4gICAgY29uc3QgbnVtYmVyT2ZEZWxldGVzID0gZGVjb2RpbmcucmVhZFZhclVpbnQoZGVjb2Rlci5yZXN0RGVjb2RlcilcbiAgICBpZiAobnVtYmVyT2ZEZWxldGVzID4gMCkge1xuICAgICAgY29uc3QgZHNGaWVsZCA9IG1hcC5zZXRJZlVuZGVmaW5lZChkcy5jbGllbnRzLCBjbGllbnQsICgpID0+IC8qKiBAdHlwZSB7QXJyYXk8RGVsZXRlSXRlbT59ICovIChbXSkpXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bWJlck9mRGVsZXRlczsgaSsrKSB7XG4gICAgICAgIGRzRmllbGQucHVzaChuZXcgRGVsZXRlSXRlbShkZWNvZGVyLnJlYWREc0Nsb2NrKCksIGRlY29kZXIucmVhZERzTGVuKCkpKVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZHNcbn1cblxuLyoqXG4gKiBAdG9kbyBZRGVjb2RlciBhbHNvIGNvbnRhaW5zIHJlZmVyZW5jZXMgdG8gU3RyaW5nIGFuZCBvdGhlciBEZWNvZGVycy4gV291bGQgbWFrZSBzZW5zZSB0byBleGNoYW5nZSBZRGVjb2Rlci50b1VpbnQ4QXJyYXkgZm9yIFlEZWNvZGVyLkRzVG9VaW50OEFycmF5KCkuLlxuICovXG5cbi8qKlxuICogQHBhcmFtIHtEU0RlY29kZXJWMSB8IERTRGVjb2RlclYyfSBkZWNvZGVyXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtTdHJ1Y3RTdG9yZX0gc3RvcmVcbiAqIEByZXR1cm4ge1VpbnQ4QXJyYXl8bnVsbH0gUmV0dXJucyBhIHYyIHVwZGF0ZSBjb250YWluaW5nIGFsbCBkZWxldGVzIHRoYXQgY291bGRuJ3QgYmUgYXBwbGllZCB5ZXQ7IG9yIG51bGwgaWYgYWxsIGRlbGV0ZXMgd2VyZSBhcHBsaWVkIHN1Y2Nlc3NmdWxseS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCByZWFkQW5kQXBwbHlEZWxldGVTZXQgPSAoZGVjb2RlciwgdHJhbnNhY3Rpb24sIHN0b3JlKSA9PiB7XG4gIGNvbnN0IHVuYXBwbGllZERTID0gbmV3IERlbGV0ZVNldCgpXG4gIGNvbnN0IG51bUNsaWVudHMgPSBkZWNvZGluZy5yZWFkVmFyVWludChkZWNvZGVyLnJlc3REZWNvZGVyKVxuICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUNsaWVudHM7IGkrKykge1xuICAgIGRlY29kZXIucmVzZXREc0N1clZhbCgpXG4gICAgY29uc3QgY2xpZW50ID0gZGVjb2RpbmcucmVhZFZhclVpbnQoZGVjb2Rlci5yZXN0RGVjb2RlcilcbiAgICBjb25zdCBudW1iZXJPZkRlbGV0ZXMgPSBkZWNvZGluZy5yZWFkVmFyVWludChkZWNvZGVyLnJlc3REZWNvZGVyKVxuICAgIGNvbnN0IHN0cnVjdHMgPSBzdG9yZS5jbGllbnRzLmdldChjbGllbnQpIHx8IFtdXG4gICAgY29uc3Qgc3RhdGUgPSBnZXRTdGF0ZShzdG9yZSwgY2xpZW50KVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtYmVyT2ZEZWxldGVzOyBpKyspIHtcbiAgICAgIGNvbnN0IGNsb2NrID0gZGVjb2Rlci5yZWFkRHNDbG9jaygpXG4gICAgICBjb25zdCBjbG9ja0VuZCA9IGNsb2NrICsgZGVjb2Rlci5yZWFkRHNMZW4oKVxuICAgICAgaWYgKGNsb2NrIDwgc3RhdGUpIHtcbiAgICAgICAgaWYgKHN0YXRlIDwgY2xvY2tFbmQpIHtcbiAgICAgICAgICBhZGRUb0RlbGV0ZVNldCh1bmFwcGxpZWREUywgY2xpZW50LCBzdGF0ZSwgY2xvY2tFbmQgLSBzdGF0ZSlcbiAgICAgICAgfVxuICAgICAgICBsZXQgaW5kZXggPSBmaW5kSW5kZXhTUyhzdHJ1Y3RzLCBjbG9jaylcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdlIGNhbiBpZ25vcmUgdGhlIGNhc2Ugb2YgR0MgYW5kIERlbGV0ZSBzdHJ1Y3RzLCBiZWNhdXNlIHdlIGFyZSBnb2luZyB0byBza2lwIHRoZW1cbiAgICAgICAgICogQHR5cGUge0l0ZW19XG4gICAgICAgICAqL1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGxldCBzdHJ1Y3QgPSBzdHJ1Y3RzW2luZGV4XVxuICAgICAgICAvLyBzcGxpdCB0aGUgZmlyc3QgaXRlbSBpZiBuZWNlc3NhcnlcbiAgICAgICAgaWYgKCFzdHJ1Y3QuZGVsZXRlZCAmJiBzdHJ1Y3QuaWQuY2xvY2sgPCBjbG9jaykge1xuICAgICAgICAgIHN0cnVjdHMuc3BsaWNlKGluZGV4ICsgMSwgMCwgc3BsaXRJdGVtKHRyYW5zYWN0aW9uLCBzdHJ1Y3QsIGNsb2NrIC0gc3RydWN0LmlkLmNsb2NrKSlcbiAgICAgICAgICBpbmRleCsrIC8vIGluY3JlYXNlIHdlIG5vdyB3YW50IHRvIHVzZSB0aGUgbmV4dCBzdHJ1Y3RcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoaW5kZXggPCBzdHJ1Y3RzLmxlbmd0aCkge1xuICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICBzdHJ1Y3QgPSBzdHJ1Y3RzW2luZGV4KytdXG4gICAgICAgICAgaWYgKHN0cnVjdC5pZC5jbG9jayA8IGNsb2NrRW5kKSB7XG4gICAgICAgICAgICBpZiAoIXN0cnVjdC5kZWxldGVkKSB7XG4gICAgICAgICAgICAgIGlmIChjbG9ja0VuZCA8IHN0cnVjdC5pZC5jbG9jayArIHN0cnVjdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBzdHJ1Y3RzLnNwbGljZShpbmRleCwgMCwgc3BsaXRJdGVtKHRyYW5zYWN0aW9uLCBzdHJ1Y3QsIGNsb2NrRW5kIC0gc3RydWN0LmlkLmNsb2NrKSlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBzdHJ1Y3QuZGVsZXRlKHRyYW5zYWN0aW9uKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWRkVG9EZWxldGVTZXQodW5hcHBsaWVkRFMsIGNsaWVudCwgY2xvY2ssIGNsb2NrRW5kIC0gY2xvY2spXG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICh1bmFwcGxpZWREUy5jbGllbnRzLnNpemUgPiAwKSB7XG4gICAgY29uc3QgZHMgPSBuZXcgVXBkYXRlRW5jb2RlclYyKClcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQoZHMucmVzdEVuY29kZXIsIDApIC8vIGVuY29kZSAwIHN0cnVjdHNcbiAgICB3cml0ZURlbGV0ZVNldChkcywgdW5hcHBsaWVkRFMpXG4gICAgcmV0dXJuIGRzLnRvVWludDhBcnJheSgpXG4gIH1cbiAgcmV0dXJuIG51bGxcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0RlbGV0ZVNldH0gZHMxXG4gKiBAcGFyYW0ge0RlbGV0ZVNldH0gZHMyXG4gKi9cbmV4cG9ydCBjb25zdCBlcXVhbERlbGV0ZVNldHMgPSAoZHMxLCBkczIpID0+IHtcbiAgaWYgKGRzMS5jbGllbnRzLnNpemUgIT09IGRzMi5jbGllbnRzLnNpemUpIHJldHVybiBmYWxzZVxuICBmb3IgKGNvbnN0IFtjbGllbnQsIGRlbGV0ZUl0ZW1zMV0gb2YgZHMxLmNsaWVudHMuZW50cmllcygpKSB7XG4gICAgY29uc3QgZGVsZXRlSXRlbXMyID0gLyoqIEB0eXBlIHtBcnJheTxpbXBvcnQoJy4uL2ludGVybmFscy5qcycpLkRlbGV0ZUl0ZW0+fSAqLyAoZHMyLmNsaWVudHMuZ2V0KGNsaWVudCkpXG4gICAgaWYgKGRlbGV0ZUl0ZW1zMiA9PT0gdW5kZWZpbmVkIHx8IGRlbGV0ZUl0ZW1zMS5sZW5ndGggIT09IGRlbGV0ZUl0ZW1zMi5sZW5ndGgpIHJldHVybiBmYWxzZVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGVsZXRlSXRlbXMxLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBkaTEgPSBkZWxldGVJdGVtczFbaV1cbiAgICAgIGNvbnN0IGRpMiA9IGRlbGV0ZUl0ZW1zMltpXVxuICAgICAgaWYgKGRpMS5jbG9jayAhPT0gZGkyLmNsb2NrIHx8IGRpMS5sZW4gIT09IGRpMi5sZW4pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlXG59XG4iLCAiLyoqXG4gKiBAbW9kdWxlIFlcbiAqL1xuXG5pbXBvcnQge1xuICBTdHJ1Y3RTdG9yZSxcbiAgQWJzdHJhY3RUeXBlLFxuICBZQXJyYXksXG4gIFlUZXh0LFxuICBZTWFwLFxuICBZWG1sRnJhZ21lbnQsXG4gIHRyYW5zYWN0LFxuICBDb250ZW50RG9jLCBJdGVtLCBUcmFuc2FjdGlvbiwgWUV2ZW50IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbn0gZnJvbSAnLi4vaW50ZXJuYWxzLmpzJ1xuXG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAnbGliMC9vYnNlcnZhYmxlJ1xuaW1wb3J0ICogYXMgcmFuZG9tIGZyb20gJ2xpYjAvcmFuZG9tJ1xuaW1wb3J0ICogYXMgbWFwIGZyb20gJ2xpYjAvbWFwJ1xuaW1wb3J0ICogYXMgYXJyYXkgZnJvbSAnbGliMC9hcnJheSdcbmltcG9ydCAqIGFzIHByb21pc2UgZnJvbSAnbGliMC9wcm9taXNlJ1xuXG5leHBvcnQgY29uc3QgZ2VuZXJhdGVOZXdDbGllbnRJZCA9IHJhbmRvbS51aW50MzJcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBEb2NPcHRzXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtEb2NPcHRzLmdjPXRydWVdIERpc2FibGUgZ2FyYmFnZSBjb2xsZWN0aW9uIChkZWZhdWx0OiBnYz10cnVlKVxuICogQHByb3BlcnR5IHtmdW5jdGlvbihJdGVtKTpib29sZWFufSBbRG9jT3B0cy5nY0ZpbHRlcl0gV2lsbCBiZSBjYWxsZWQgYmVmb3JlIGFuIEl0ZW0gaXMgZ2FyYmFnZSBjb2xsZWN0ZWQuIFJldHVybiBmYWxzZSB0byBrZWVwIHRoZSBJdGVtLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtEb2NPcHRzLmd1aWRdIERlZmluZSBhIGdsb2JhbGx5IHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGlzIGRvY3VtZW50XG4gKiBAcHJvcGVydHkge3N0cmluZyB8IG51bGx9IFtEb2NPcHRzLmNvbGxlY3Rpb25pZF0gQXNzb2NpYXRlIHRoaXMgZG9jdW1lbnQgd2l0aCBhIGNvbGxlY3Rpb24uIFRoaXMgb25seSBwbGF5cyBhIHJvbGUgaWYgeW91ciBwcm92aWRlciBoYXMgYSBjb25jZXB0IG9mIGNvbGxlY3Rpb24uXG4gKiBAcHJvcGVydHkge2FueX0gW0RvY09wdHMubWV0YV0gQW55IGtpbmQgb2YgbWV0YSBpbmZvcm1hdGlvbiB5b3Ugd2FudCB0byBhc3NvY2lhdGUgd2l0aCB0aGlzIGRvY3VtZW50LiBJZiB0aGlzIGlzIGEgc3ViZG9jdW1lbnQsIHJlbW90ZSBwZWVycyB3aWxsIHN0b3JlIHRoZSBtZXRhIGluZm9ybWF0aW9uIGFzIHdlbGwuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtEb2NPcHRzLmF1dG9Mb2FkXSBJZiBhIHN1YmRvY3VtZW50LCBhdXRvbWF0aWNhbGx5IGxvYWQgZG9jdW1lbnQuIElmIHRoaXMgaXMgYSBzdWJkb2N1bWVudCwgcmVtb3RlIHBlZXJzIHdpbGwgbG9hZCB0aGUgZG9jdW1lbnQgYXMgd2VsbCBhdXRvbWF0aWNhbGx5LlxuICogQHByb3BlcnR5IHtib29sZWFufSBbRG9jT3B0cy5zaG91bGRMb2FkXSBXaGV0aGVyIHRoZSBkb2N1bWVudCBzaG91bGQgYmUgc3luY2VkIGJ5IHRoZSBwcm92aWRlciBub3cuIFRoaXMgaXMgdG9nZ2xlZCB0byB0cnVlIHdoZW4geW91IGNhbGwgeWRvYy5sb2FkKClcbiAqL1xuXG4vKipcbiAqIEEgWWpzIGluc3RhbmNlIGhhbmRsZXMgdGhlIHN0YXRlIG9mIHNoYXJlZCBkYXRhLlxuICogQGV4dGVuZHMgT2JzZXJ2YWJsZTxzdHJpbmc+XG4gKi9cbmV4cG9ydCBjbGFzcyBEb2MgZXh0ZW5kcyBPYnNlcnZhYmxlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7RG9jT3B0c30gb3B0cyBjb25maWd1cmF0aW9uXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoeyBndWlkID0gcmFuZG9tLnV1aWR2NCgpLCBjb2xsZWN0aW9uaWQgPSBudWxsLCBnYyA9IHRydWUsIGdjRmlsdGVyID0gKCkgPT4gdHJ1ZSwgbWV0YSA9IG51bGwsIGF1dG9Mb2FkID0gZmFsc2UsIHNob3VsZExvYWQgPSB0cnVlIH0gPSB7fSkge1xuICAgIHN1cGVyKClcbiAgICB0aGlzLmdjID0gZ2NcbiAgICB0aGlzLmdjRmlsdGVyID0gZ2NGaWx0ZXJcbiAgICB0aGlzLmNsaWVudElEID0gZ2VuZXJhdGVOZXdDbGllbnRJZCgpXG4gICAgdGhpcy5ndWlkID0gZ3VpZFxuICAgIHRoaXMuY29sbGVjdGlvbmlkID0gY29sbGVjdGlvbmlkXG4gICAgLyoqXG4gICAgICogQHR5cGUge01hcDxzdHJpbmcsIEFic3RyYWN0VHlwZTxZRXZlbnQ8YW55Pj4+fVxuICAgICAqL1xuICAgIHRoaXMuc2hhcmUgPSBuZXcgTWFwKClcbiAgICB0aGlzLnN0b3JlID0gbmV3IFN0cnVjdFN0b3JlKClcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7VHJhbnNhY3Rpb24gfCBudWxsfVxuICAgICAqL1xuICAgIHRoaXMuX3RyYW5zYWN0aW9uID0gbnVsbFxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBcnJheTxUcmFuc2FjdGlvbj59XG4gICAgICovXG4gICAgdGhpcy5fdHJhbnNhY3Rpb25DbGVhbnVwcyA9IFtdXG4gICAgLyoqXG4gICAgICogQHR5cGUge1NldDxEb2M+fVxuICAgICAqL1xuICAgIHRoaXMuc3ViZG9jcyA9IG5ldyBTZXQoKVxuICAgIC8qKlxuICAgICAqIElmIHRoaXMgZG9jdW1lbnQgaXMgYSBzdWJkb2N1bWVudCAtIGEgZG9jdW1lbnQgaW50ZWdyYXRlZCBpbnRvIGFub3RoZXIgZG9jdW1lbnQgLSB0aGVuIF9pdGVtIGlzIGRlZmluZWQuXG4gICAgICogQHR5cGUge0l0ZW0/fVxuICAgICAqL1xuICAgIHRoaXMuX2l0ZW0gPSBudWxsXG4gICAgdGhpcy5zaG91bGRMb2FkID0gc2hvdWxkTG9hZFxuICAgIHRoaXMuYXV0b0xvYWQgPSBhdXRvTG9hZFxuICAgIHRoaXMubWV0YSA9IG1ldGFcbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIHNldCB0byB0cnVlIHdoZW4gdGhlIHBlcnNpc3RlbmNlIHByb3ZpZGVyIGxvYWRlZCB0aGUgZG9jdW1lbnQgZnJvbSB0aGUgZGF0YWJhc2Ugb3Igd2hlbiB0aGUgYHN5bmNgIGV2ZW50IGZpcmVzLlxuICAgICAqIE5vdGUgdGhhdCBub3QgYWxsIHByb3ZpZGVycyBpbXBsZW1lbnQgdGhpcyBmZWF0dXJlLiBQcm92aWRlciBhdXRob3JzIGFyZSBlbmNvdXJhZ2VkIHRvIGZpcmUgdGhlIGBsb2FkYCBldmVudCB3aGVuIHRoZSBkb2MgY29udGVudCBpcyBsb2FkZWQgZnJvbSB0aGUgZGF0YWJhc2UuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmlzTG9hZGVkID0gZmFsc2VcbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIHNldCB0byB0cnVlIHdoZW4gdGhlIGNvbm5lY3Rpb24gcHJvdmlkZXIgaGFzIHN1Y2Nlc3NmdWxseSBzeW5jZWQgd2l0aCBhIGJhY2tlbmQuXG4gICAgICogTm90ZSB0aGF0IHdoZW4gdXNpbmcgcGVlci10by1wZWVyIHByb3ZpZGVycyB0aGlzIGV2ZW50IG1heSBub3QgcHJvdmlkZSB2ZXJ5IHVzZWZ1bC5cbiAgICAgKiBBbHNvIG5vdGUgdGhhdCBub3QgYWxsIHByb3ZpZGVycyBpbXBsZW1lbnQgdGhpcyBmZWF0dXJlLiBQcm92aWRlciBhdXRob3JzIGFyZSBlbmNvdXJhZ2VkIHRvIGZpcmVcbiAgICAgKiB0aGUgYHN5bmNgIGV2ZW50IHdoZW4gdGhlIGRvYyBoYXMgYmVlbiBzeW5jZWQgKHdpdGggYHRydWVgIGFzIGEgcGFyYW1ldGVyKSBvciBpZiBjb25uZWN0aW9uIGlzXG4gICAgICogbG9zdCAod2l0aCBmYWxzZSBhcyBhIHBhcmFtZXRlcikuXG4gICAgICovXG4gICAgdGhpcy5pc1N5bmNlZCA9IGZhbHNlXG4gICAgLyoqXG4gICAgICogUHJvbWlzZSB0aGF0IHJlc29sdmVzIG9uY2UgdGhlIGRvY3VtZW50IGhhcyBiZWVuIGxvYWRlZCBmcm9tIGEgcHJlc2lzdGVuY2UgcHJvdmlkZXIuXG4gICAgICovXG4gICAgdGhpcy53aGVuTG9hZGVkID0gcHJvbWlzZS5jcmVhdGUocmVzb2x2ZSA9PiB7XG4gICAgICB0aGlzLm9uKCdsb2FkJywgKCkgPT4ge1xuICAgICAgICB0aGlzLmlzTG9hZGVkID0gdHJ1ZVxuICAgICAgICByZXNvbHZlKHRoaXMpXG4gICAgICB9KVxuICAgIH0pXG4gICAgY29uc3QgcHJvdmlkZVN5bmNlZFByb21pc2UgPSAoKSA9PiBwcm9taXNlLmNyZWF0ZShyZXNvbHZlID0+IHtcbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIHtib29sZWFufSBpc1N5bmNlZFxuICAgICAgICovXG4gICAgICBjb25zdCBldmVudEhhbmRsZXIgPSAoaXNTeW5jZWQpID0+IHtcbiAgICAgICAgaWYgKGlzU3luY2VkID09PSB1bmRlZmluZWQgfHwgaXNTeW5jZWQgPT09IHRydWUpIHtcbiAgICAgICAgICB0aGlzLm9mZignc3luYycsIGV2ZW50SGFuZGxlcilcbiAgICAgICAgICByZXNvbHZlKClcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5vbignc3luYycsIGV2ZW50SGFuZGxlcilcbiAgICB9KVxuICAgIHRoaXMub24oJ3N5bmMnLCBpc1N5bmNlZCA9PiB7XG4gICAgICBpZiAoaXNTeW5jZWQgPT09IGZhbHNlICYmIHRoaXMuaXNTeW5jZWQpIHtcbiAgICAgICAgdGhpcy53aGVuU3luY2VkID0gcHJvdmlkZVN5bmNlZFByb21pc2UoKVxuICAgICAgfVxuICAgICAgdGhpcy5pc1N5bmNlZCA9IGlzU3luY2VkID09PSB1bmRlZmluZWQgfHwgaXNTeW5jZWQgPT09IHRydWVcbiAgICAgIGlmICghdGhpcy5pc0xvYWRlZCkge1xuICAgICAgICB0aGlzLmVtaXQoJ2xvYWQnLCBbXSlcbiAgICAgIH1cbiAgICB9KVxuICAgIC8qKlxuICAgICAqIFByb21pc2UgdGhhdCByZXNvbHZlcyBvbmNlIHRoZSBkb2N1bWVudCBoYXMgYmVlbiBzeW5jZWQgd2l0aCBhIGJhY2tlbmQuXG4gICAgICogVGhpcyBwcm9taXNlIGlzIHJlY3JlYXRlZCB3aGVuIHRoZSBjb25uZWN0aW9uIGlzIGxvc3QuXG4gICAgICogTm90ZSB0aGUgZG9jdW1lbnRhdGlvbiBhYm91dCB0aGUgYGlzU3luY2VkYCBwcm9wZXJ0eS5cbiAgICAgKi9cbiAgICB0aGlzLndoZW5TeW5jZWQgPSBwcm92aWRlU3luY2VkUHJvbWlzZSgpXG4gIH1cblxuICAvKipcbiAgICogTm90aWZ5IHRoZSBwYXJlbnQgZG9jdW1lbnQgdGhhdCB5b3UgcmVxdWVzdCB0byBsb2FkIGRhdGEgaW50byB0aGlzIHN1YmRvY3VtZW50IChpZiBpdCBpcyBhIHN1YmRvY3VtZW50KS5cbiAgICpcbiAgICogYGxvYWQoKWAgbWlnaHQgYmUgdXNlZCBpbiB0aGUgZnV0dXJlIHRvIHJlcXVlc3QgYW55IHByb3ZpZGVyIHRvIGxvYWQgdGhlIG1vc3QgY3VycmVudCBkYXRhLlxuICAgKlxuICAgKiBJdCBpcyBzYWZlIHRvIGNhbGwgYGxvYWQoKWAgbXVsdGlwbGUgdGltZXMuXG4gICAqL1xuICBsb2FkICgpIHtcbiAgICBjb25zdCBpdGVtID0gdGhpcy5faXRlbVxuICAgIGlmIChpdGVtICE9PSBudWxsICYmICF0aGlzLnNob3VsZExvYWQpIHtcbiAgICAgIHRyYW5zYWN0KC8qKiBAdHlwZSB7YW55fSAqLyAoaXRlbS5wYXJlbnQpLmRvYywgdHJhbnNhY3Rpb24gPT4ge1xuICAgICAgICB0cmFuc2FjdGlvbi5zdWJkb2NzTG9hZGVkLmFkZCh0aGlzKVxuICAgICAgfSwgbnVsbCwgdHJ1ZSlcbiAgICB9XG4gICAgdGhpcy5zaG91bGRMb2FkID0gdHJ1ZVxuICB9XG5cbiAgZ2V0U3ViZG9jcyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3ViZG9jc1xuICB9XG5cbiAgZ2V0U3ViZG9jR3VpZHMgKCkge1xuICAgIHJldHVybiBuZXcgU2V0KGFycmF5LmZyb20odGhpcy5zdWJkb2NzKS5tYXAoZG9jID0+IGRvYy5ndWlkKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGFuZ2VzIHRoYXQgaGFwcGVuIGluc2lkZSBvZiBhIHRyYW5zYWN0aW9uIGFyZSBidW5kbGVkLiBUaGlzIG1lYW5zIHRoYXRcbiAgICogdGhlIG9ic2VydmVyIGZpcmVzIF9hZnRlcl8gdGhlIHRyYW5zYWN0aW9uIGlzIGZpbmlzaGVkIGFuZCB0aGF0IGFsbCBjaGFuZ2VzXG4gICAqIHRoYXQgaGFwcGVuZWQgaW5zaWRlIG9mIHRoZSB0cmFuc2FjdGlvbiBhcmUgc2VudCBhcyBvbmUgbWVzc2FnZSB0byB0aGVcbiAgICogb3RoZXIgcGVlcnMuXG4gICAqXG4gICAqIEB0ZW1wbGF0ZSBUXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oVHJhbnNhY3Rpb24pOlR9IGYgVGhlIGZ1bmN0aW9uIHRoYXQgc2hvdWxkIGJlIGV4ZWN1dGVkIGFzIGEgdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHthbnl9IFtvcmlnaW5dIE9yaWdpbiBvZiB3aG8gc3RhcnRlZCB0aGUgdHJhbnNhY3Rpb24uIFdpbGwgYmUgc3RvcmVkIG9uIHRyYW5zYWN0aW9uLm9yaWdpblxuICAgKiBAcmV0dXJuIFRcbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgdHJhbnNhY3QgKGYsIG9yaWdpbiA9IG51bGwpIHtcbiAgICByZXR1cm4gdHJhbnNhY3QodGhpcywgZiwgb3JpZ2luKVxuICB9XG5cbiAgLyoqXG4gICAqIERlZmluZSBhIHNoYXJlZCBkYXRhIHR5cGUuXG4gICAqXG4gICAqIE11bHRpcGxlIGNhbGxzIG9mIGB5LmdldChuYW1lLCBUeXBlQ29uc3RydWN0b3IpYCB5aWVsZCB0aGUgc2FtZSByZXN1bHRcbiAgICogYW5kIGRvIG5vdCBvdmVyd3JpdGUgZWFjaCBvdGhlci4gSS5lLlxuICAgKiBgeS5kZWZpbmUobmFtZSwgWS5BcnJheSkgPT09IHkuZGVmaW5lKG5hbWUsIFkuQXJyYXkpYFxuICAgKlxuICAgKiBBZnRlciB0aGlzIG1ldGhvZCBpcyBjYWxsZWQsIHRoZSB0eXBlIGlzIGFsc28gYXZhaWxhYmxlIG9uIGB5LnNoYXJlLmdldChuYW1lKWAuXG4gICAqXG4gICAqICpCZXN0IFByYWN0aWNlczoqXG4gICAqIERlZmluZSBhbGwgdHlwZXMgcmlnaHQgYWZ0ZXIgdGhlIFlqcyBpbnN0YW5jZSBpcyBjcmVhdGVkIGFuZCBzdG9yZSB0aGVtIGluIGEgc2VwYXJhdGUgb2JqZWN0LlxuICAgKiBBbHNvIHVzZSB0aGUgdHlwZWQgbWV0aG9kcyBgZ2V0VGV4dChuYW1lKWAsIGBnZXRBcnJheShuYW1lKWAsIC4uXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqICAgY29uc3QgeSA9IG5ldyBZKC4uKVxuICAgKiAgIGNvbnN0IGFwcFN0YXRlID0ge1xuICAgKiAgICAgZG9jdW1lbnQ6IHkuZ2V0VGV4dCgnZG9jdW1lbnQnKVxuICAgKiAgICAgY29tbWVudHM6IHkuZ2V0QXJyYXkoJ2NvbW1lbnRzJylcbiAgICogICB9XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFR5cGVDb25zdHJ1Y3RvciBUaGUgY29uc3RydWN0b3Igb2YgdGhlIHR5cGUgZGVmaW5pdGlvbi4gRS5nLiBZLlRleHQsIFkuQXJyYXksIFkuTWFwLCAuLi5cbiAgICogQHJldHVybiB7QWJzdHJhY3RUeXBlPGFueT59IFRoZSBjcmVhdGVkIHR5cGUuIENvbnN0cnVjdGVkIHdpdGggVHlwZUNvbnN0cnVjdG9yXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGdldCAobmFtZSwgVHlwZUNvbnN0cnVjdG9yID0gQWJzdHJhY3RUeXBlKSB7XG4gICAgY29uc3QgdHlwZSA9IG1hcC5zZXRJZlVuZGVmaW5lZCh0aGlzLnNoYXJlLCBuYW1lLCAoKSA9PiB7XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBjb25zdCB0ID0gbmV3IFR5cGVDb25zdHJ1Y3RvcigpXG4gICAgICB0Ll9pbnRlZ3JhdGUodGhpcywgbnVsbClcbiAgICAgIHJldHVybiB0XG4gICAgfSlcbiAgICBjb25zdCBDb25zdHIgPSB0eXBlLmNvbnN0cnVjdG9yXG4gICAgaWYgKFR5cGVDb25zdHJ1Y3RvciAhPT0gQWJzdHJhY3RUeXBlICYmIENvbnN0ciAhPT0gVHlwZUNvbnN0cnVjdG9yKSB7XG4gICAgICBpZiAoQ29uc3RyID09PSBBYnN0cmFjdFR5cGUpIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBjb25zdCB0ID0gbmV3IFR5cGVDb25zdHJ1Y3RvcigpXG4gICAgICAgIHQuX21hcCA9IHR5cGUuX21hcFxuICAgICAgICB0eXBlLl9tYXAuZm9yRWFjaCgvKiogQHBhcmFtIHtJdGVtP30gbiAqLyBuID0+IHtcbiAgICAgICAgICBmb3IgKDsgbiAhPT0gbnVsbDsgbiA9IG4ubGVmdCkge1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgbi5wYXJlbnQgPSB0XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICB0Ll9zdGFydCA9IHR5cGUuX3N0YXJ0XG4gICAgICAgIGZvciAobGV0IG4gPSB0Ll9zdGFydDsgbiAhPT0gbnVsbDsgbiA9IG4ucmlnaHQpIHtcbiAgICAgICAgICBuLnBhcmVudCA9IHRcbiAgICAgICAgfVxuICAgICAgICB0Ll9sZW5ndGggPSB0eXBlLl9sZW5ndGhcbiAgICAgICAgdGhpcy5zaGFyZS5zZXQobmFtZSwgdClcbiAgICAgICAgdC5faW50ZWdyYXRlKHRoaXMsIG51bGwpXG4gICAgICAgIHJldHVybiB0XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFR5cGUgd2l0aCB0aGUgbmFtZSAke25hbWV9IGhhcyBhbHJlYWR5IGJlZW4gZGVmaW5lZCB3aXRoIGEgZGlmZmVyZW50IGNvbnN0cnVjdG9yYClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHR5cGVcbiAgfVxuXG4gIC8qKlxuICAgKiBAdGVtcGxhdGUgVFxuICAgKiBAcGFyYW0ge3N0cmluZ30gW25hbWVdXG4gICAqIEByZXR1cm4ge1lBcnJheTxUPn1cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgZ2V0QXJyYXkgKG5hbWUgPSAnJykge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICByZXR1cm4gdGhpcy5nZXQobmFtZSwgWUFycmF5KVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbbmFtZV1cbiAgICogQHJldHVybiB7WVRleHR9XG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGdldFRleHQgKG5hbWUgPSAnJykge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICByZXR1cm4gdGhpcy5nZXQobmFtZSwgWVRleHQpXG4gIH1cblxuICAvKipcbiAgICogQHRlbXBsYXRlIFRcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtuYW1lXVxuICAgKiBAcmV0dXJuIHtZTWFwPFQ+fVxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBnZXRNYXAgKG5hbWUgPSAnJykge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICByZXR1cm4gdGhpcy5nZXQobmFtZSwgWU1hcClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW25hbWVdXG4gICAqIEByZXR1cm4ge1lYbWxGcmFnbWVudH1cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgZ2V0WG1sRnJhZ21lbnQgKG5hbWUgPSAnJykge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICByZXR1cm4gdGhpcy5nZXQobmFtZSwgWVhtbEZyYWdtZW50KVxuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIHRoZSBlbnRpcmUgZG9jdW1lbnQgaW50byBhIGpzIG9iamVjdCwgcmVjdXJzaXZlbHkgdHJhdmVyc2luZyBlYWNoIHlqcyB0eXBlXG4gICAqIERvZXNuJ3QgbG9nIHR5cGVzIHRoYXQgaGF2ZSBub3QgYmVlbiBkZWZpbmVkICh1c2luZyB5ZG9jLmdldFR5cGUoLi4pKS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgRG8gbm90IHVzZSB0aGlzIG1ldGhvZCBhbmQgcmF0aGVyIGNhbGwgdG9KU09OIGRpcmVjdGx5IG9uIHRoZSBzaGFyZWQgdHlwZXMuXG4gICAqXG4gICAqIEByZXR1cm4ge09iamVjdDxzdHJpbmcsIGFueT59XG4gICAqL1xuICB0b0pTT04gKCkge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBhbnk+fVxuICAgICAqL1xuICAgIGNvbnN0IGRvYyA9IHt9XG5cbiAgICB0aGlzLnNoYXJlLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgIGRvY1trZXldID0gdmFsdWUudG9KU09OKClcbiAgICB9KVxuXG4gICAgcmV0dXJuIGRvY1xuICB9XG5cbiAgLyoqXG4gICAqIEVtaXQgYGRlc3Ryb3lgIGV2ZW50IGFuZCB1bnJlZ2lzdGVyIGFsbCBldmVudCBoYW5kbGVycy5cbiAgICovXG4gIGRlc3Ryb3kgKCkge1xuICAgIGFycmF5LmZyb20odGhpcy5zdWJkb2NzKS5mb3JFYWNoKHN1YmRvYyA9PiBzdWJkb2MuZGVzdHJveSgpKVxuICAgIGNvbnN0IGl0ZW0gPSB0aGlzLl9pdGVtXG4gICAgaWYgKGl0ZW0gIT09IG51bGwpIHtcbiAgICAgIHRoaXMuX2l0ZW0gPSBudWxsXG4gICAgICBjb25zdCBjb250ZW50ID0gLyoqIEB0eXBlIHtDb250ZW50RG9jfSAqLyAoaXRlbS5jb250ZW50KVxuICAgICAgY29udGVudC5kb2MgPSBuZXcgRG9jKHsgZ3VpZDogdGhpcy5ndWlkLCAuLi5jb250ZW50Lm9wdHMsIHNob3VsZExvYWQ6IGZhbHNlIH0pXG4gICAgICBjb250ZW50LmRvYy5faXRlbSA9IGl0ZW1cbiAgICAgIHRyYW5zYWN0KC8qKiBAdHlwZSB7YW55fSAqLyAoaXRlbSkucGFyZW50LmRvYywgdHJhbnNhY3Rpb24gPT4ge1xuICAgICAgICBjb25zdCBkb2MgPSBjb250ZW50LmRvY1xuICAgICAgICBpZiAoIWl0ZW0uZGVsZXRlZCkge1xuICAgICAgICAgIHRyYW5zYWN0aW9uLnN1YmRvY3NBZGRlZC5hZGQoZG9jKVxuICAgICAgICB9XG4gICAgICAgIHRyYW5zYWN0aW9uLnN1YmRvY3NSZW1vdmVkLmFkZCh0aGlzKVxuICAgICAgfSwgbnVsbCwgdHJ1ZSlcbiAgICB9XG4gICAgdGhpcy5lbWl0KCdkZXN0cm95ZWQnLCBbdHJ1ZV0pXG4gICAgdGhpcy5lbWl0KCdkZXN0cm95JywgW3RoaXNdKVxuICAgIHN1cGVyLmRlc3Ryb3koKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWVcbiAgICogQHBhcmFtIHtmdW5jdGlvbiguLi5hbnkpOmFueX0gZlxuICAgKi9cbiAgb24gKGV2ZW50TmFtZSwgZikge1xuICAgIHN1cGVyLm9uKGV2ZW50TmFtZSwgZilcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGZcbiAgICovXG4gIG9mZiAoZXZlbnROYW1lLCBmKSB7XG4gICAgc3VwZXIub2ZmKGV2ZW50TmFtZSwgZilcbiAgfVxufVxuIiwgImltcG9ydCAqIGFzIGJ1ZmZlciBmcm9tICdsaWIwL2J1ZmZlcidcbmltcG9ydCAqIGFzIGRlY29kaW5nIGZyb20gJ2xpYjAvZGVjb2RpbmcnXG5pbXBvcnQge1xuICBJRCwgY3JlYXRlSURcbn0gZnJvbSAnLi4vaW50ZXJuYWxzLmpzJ1xuXG5leHBvcnQgY2xhc3MgRFNEZWNvZGVyVjEge1xuICAvKipcbiAgICogQHBhcmFtIHtkZWNvZGluZy5EZWNvZGVyfSBkZWNvZGVyXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoZGVjb2Rlcikge1xuICAgIHRoaXMucmVzdERlY29kZXIgPSBkZWNvZGVyXG4gIH1cblxuICByZXNldERzQ3VyVmFsICgpIHtcbiAgICAvLyBub3BcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICByZWFkRHNDbG9jayAoKSB7XG4gICAgcmV0dXJuIGRlY29kaW5nLnJlYWRWYXJVaW50KHRoaXMucmVzdERlY29kZXIpXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgcmVhZERzTGVuICgpIHtcbiAgICByZXR1cm4gZGVjb2RpbmcucmVhZFZhclVpbnQodGhpcy5yZXN0RGVjb2RlcilcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgVXBkYXRlRGVjb2RlclYxIGV4dGVuZHMgRFNEZWNvZGVyVjEge1xuICAvKipcbiAgICogQHJldHVybiB7SUR9XG4gICAqL1xuICByZWFkTGVmdElEICgpIHtcbiAgICByZXR1cm4gY3JlYXRlSUQoZGVjb2RpbmcucmVhZFZhclVpbnQodGhpcy5yZXN0RGVjb2RlciksIGRlY29kaW5nLnJlYWRWYXJVaW50KHRoaXMucmVzdERlY29kZXIpKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0lEfVxuICAgKi9cbiAgcmVhZFJpZ2h0SUQgKCkge1xuICAgIHJldHVybiBjcmVhdGVJRChkZWNvZGluZy5yZWFkVmFyVWludCh0aGlzLnJlc3REZWNvZGVyKSwgZGVjb2RpbmcucmVhZFZhclVpbnQodGhpcy5yZXN0RGVjb2RlcikpXG4gIH1cblxuICAvKipcbiAgICogUmVhZCB0aGUgbmV4dCBjbGllbnQgaWQuXG4gICAqIFVzZSB0aGlzIGluIGZhdm9yIG9mIHJlYWRJRCB3aGVuZXZlciBwb3NzaWJsZSB0byByZWR1Y2UgdGhlIG51bWJlciBvZiBvYmplY3RzIGNyZWF0ZWQuXG4gICAqL1xuICByZWFkQ2xpZW50ICgpIHtcbiAgICByZXR1cm4gZGVjb2RpbmcucmVhZFZhclVpbnQodGhpcy5yZXN0RGVjb2RlcilcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IGluZm8gQW4gdW5zaWduZWQgOC1iaXQgaW50ZWdlclxuICAgKi9cbiAgcmVhZEluZm8gKCkge1xuICAgIHJldHVybiBkZWNvZGluZy5yZWFkVWludDgodGhpcy5yZXN0RGVjb2RlcilcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICByZWFkU3RyaW5nICgpIHtcbiAgICByZXR1cm4gZGVjb2RpbmcucmVhZFZhclN0cmluZyh0aGlzLnJlc3REZWNvZGVyKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IGlzS2V5XG4gICAqL1xuICByZWFkUGFyZW50SW5mbyAoKSB7XG4gICAgcmV0dXJuIGRlY29kaW5nLnJlYWRWYXJVaW50KHRoaXMucmVzdERlY29kZXIpID09PSAxXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfSBpbmZvIEFuIHVuc2lnbmVkIDgtYml0IGludGVnZXJcbiAgICovXG4gIHJlYWRUeXBlUmVmICgpIHtcbiAgICByZXR1cm4gZGVjb2RpbmcucmVhZFZhclVpbnQodGhpcy5yZXN0RGVjb2RlcilcbiAgfVxuXG4gIC8qKlxuICAgKiBXcml0ZSBsZW4gb2YgYSBzdHJ1Y3QgLSB3ZWxsIHN1aXRlZCBmb3IgT3B0IFJMRSBlbmNvZGVyLlxuICAgKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IGxlblxuICAgKi9cbiAgcmVhZExlbiAoKSB7XG4gICAgcmV0dXJuIGRlY29kaW5nLnJlYWRWYXJVaW50KHRoaXMucmVzdERlY29kZXIpXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7YW55fVxuICAgKi9cbiAgcmVhZEFueSAoKSB7XG4gICAgcmV0dXJuIGRlY29kaW5nLnJlYWRBbnkodGhpcy5yZXN0RGVjb2RlcilcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtVaW50OEFycmF5fVxuICAgKi9cbiAgcmVhZEJ1ZiAoKSB7XG4gICAgcmV0dXJuIGJ1ZmZlci5jb3B5VWludDhBcnJheShkZWNvZGluZy5yZWFkVmFyVWludDhBcnJheSh0aGlzLnJlc3REZWNvZGVyKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBMZWdhY3kgaW1wbGVtZW50YXRpb24gdXNlcyBKU09OIHBhcnNlLiBXZSB1c2UgYW55LWRlY29kaW5nIGluIHYyLlxuICAgKlxuICAgKiBAcmV0dXJuIHthbnl9XG4gICAqL1xuICByZWFkSlNPTiAoKSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UoZGVjb2RpbmcucmVhZFZhclN0cmluZyh0aGlzLnJlc3REZWNvZGVyKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICByZWFkS2V5ICgpIHtcbiAgICByZXR1cm4gZGVjb2RpbmcucmVhZFZhclN0cmluZyh0aGlzLnJlc3REZWNvZGVyKVxuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBEU0RlY29kZXJWMiB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge2RlY29kaW5nLkRlY29kZXJ9IGRlY29kZXJcbiAgICovXG4gIGNvbnN0cnVjdG9yIChkZWNvZGVyKSB7XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmRzQ3VyclZhbCA9IDBcbiAgICB0aGlzLnJlc3REZWNvZGVyID0gZGVjb2RlclxuICB9XG5cbiAgcmVzZXREc0N1clZhbCAoKSB7XG4gICAgdGhpcy5kc0N1cnJWYWwgPSAwXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgcmVhZERzQ2xvY2sgKCkge1xuICAgIHRoaXMuZHNDdXJyVmFsICs9IGRlY29kaW5nLnJlYWRWYXJVaW50KHRoaXMucmVzdERlY29kZXIpXG4gICAgcmV0dXJuIHRoaXMuZHNDdXJyVmFsXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgcmVhZERzTGVuICgpIHtcbiAgICBjb25zdCBkaWZmID0gZGVjb2RpbmcucmVhZFZhclVpbnQodGhpcy5yZXN0RGVjb2RlcikgKyAxXG4gICAgdGhpcy5kc0N1cnJWYWwgKz0gZGlmZlxuICAgIHJldHVybiBkaWZmXG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFVwZGF0ZURlY29kZXJWMiBleHRlbmRzIERTRGVjb2RlclYyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7ZGVjb2RpbmcuRGVjb2Rlcn0gZGVjb2RlclxuICAgKi9cbiAgY29uc3RydWN0b3IgKGRlY29kZXIpIHtcbiAgICBzdXBlcihkZWNvZGVyKVxuICAgIC8qKlxuICAgICAqIExpc3Qgb2YgY2FjaGVkIGtleXMuIElmIHRoZSBrZXlzW2lkXSBkb2VzIG5vdCBleGlzdCwgd2UgcmVhZCBhIG5ldyBrZXlcbiAgICAgKiBmcm9tIHN0cmluZ0VuY29kZXIgYW5kIHB1c2ggaXQgdG8ga2V5cy5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtBcnJheTxzdHJpbmc+fVxuICAgICAqL1xuICAgIHRoaXMua2V5cyA9IFtdXG4gICAgZGVjb2RpbmcucmVhZFZhclVpbnQoZGVjb2RlcikgLy8gcmVhZCBmZWF0dXJlIGZsYWcgLSBjdXJyZW50bHkgdW51c2VkXG4gICAgdGhpcy5rZXlDbG9ja0RlY29kZXIgPSBuZXcgZGVjb2RpbmcuSW50RGlmZk9wdFJsZURlY29kZXIoZGVjb2RpbmcucmVhZFZhclVpbnQ4QXJyYXkoZGVjb2RlcikpXG4gICAgdGhpcy5jbGllbnREZWNvZGVyID0gbmV3IGRlY29kaW5nLlVpbnRPcHRSbGVEZWNvZGVyKGRlY29kaW5nLnJlYWRWYXJVaW50OEFycmF5KGRlY29kZXIpKVxuICAgIHRoaXMubGVmdENsb2NrRGVjb2RlciA9IG5ldyBkZWNvZGluZy5JbnREaWZmT3B0UmxlRGVjb2RlcihkZWNvZGluZy5yZWFkVmFyVWludDhBcnJheShkZWNvZGVyKSlcbiAgICB0aGlzLnJpZ2h0Q2xvY2tEZWNvZGVyID0gbmV3IGRlY29kaW5nLkludERpZmZPcHRSbGVEZWNvZGVyKGRlY29kaW5nLnJlYWRWYXJVaW50OEFycmF5KGRlY29kZXIpKVxuICAgIHRoaXMuaW5mb0RlY29kZXIgPSBuZXcgZGVjb2RpbmcuUmxlRGVjb2RlcihkZWNvZGluZy5yZWFkVmFyVWludDhBcnJheShkZWNvZGVyKSwgZGVjb2RpbmcucmVhZFVpbnQ4KVxuICAgIHRoaXMuc3RyaW5nRGVjb2RlciA9IG5ldyBkZWNvZGluZy5TdHJpbmdEZWNvZGVyKGRlY29kaW5nLnJlYWRWYXJVaW50OEFycmF5KGRlY29kZXIpKVxuICAgIHRoaXMucGFyZW50SW5mb0RlY29kZXIgPSBuZXcgZGVjb2RpbmcuUmxlRGVjb2RlcihkZWNvZGluZy5yZWFkVmFyVWludDhBcnJheShkZWNvZGVyKSwgZGVjb2RpbmcucmVhZFVpbnQ4KVxuICAgIHRoaXMudHlwZVJlZkRlY29kZXIgPSBuZXcgZGVjb2RpbmcuVWludE9wdFJsZURlY29kZXIoZGVjb2RpbmcucmVhZFZhclVpbnQ4QXJyYXkoZGVjb2RlcikpXG4gICAgdGhpcy5sZW5EZWNvZGVyID0gbmV3IGRlY29kaW5nLlVpbnRPcHRSbGVEZWNvZGVyKGRlY29kaW5nLnJlYWRWYXJVaW50OEFycmF5KGRlY29kZXIpKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0lEfVxuICAgKi9cbiAgcmVhZExlZnRJRCAoKSB7XG4gICAgcmV0dXJuIG5ldyBJRCh0aGlzLmNsaWVudERlY29kZXIucmVhZCgpLCB0aGlzLmxlZnRDbG9ja0RlY29kZXIucmVhZCgpKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0lEfVxuICAgKi9cbiAgcmVhZFJpZ2h0SUQgKCkge1xuICAgIHJldHVybiBuZXcgSUQodGhpcy5jbGllbnREZWNvZGVyLnJlYWQoKSwgdGhpcy5yaWdodENsb2NrRGVjb2Rlci5yZWFkKCkpXG4gIH1cblxuICAvKipcbiAgICogUmVhZCB0aGUgbmV4dCBjbGllbnQgaWQuXG4gICAqIFVzZSB0aGlzIGluIGZhdm9yIG9mIHJlYWRJRCB3aGVuZXZlciBwb3NzaWJsZSB0byByZWR1Y2UgdGhlIG51bWJlciBvZiBvYmplY3RzIGNyZWF0ZWQuXG4gICAqL1xuICByZWFkQ2xpZW50ICgpIHtcbiAgICByZXR1cm4gdGhpcy5jbGllbnREZWNvZGVyLnJlYWQoKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn0gaW5mbyBBbiB1bnNpZ25lZCA4LWJpdCBpbnRlZ2VyXG4gICAqL1xuICByZWFkSW5mbyAoKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAodGhpcy5pbmZvRGVjb2Rlci5yZWFkKCkpXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgcmVhZFN0cmluZyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RyaW5nRGVjb2Rlci5yZWFkKClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgcmVhZFBhcmVudEluZm8gKCkge1xuICAgIHJldHVybiB0aGlzLnBhcmVudEluZm9EZWNvZGVyLnJlYWQoKSA9PT0gMVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn0gQW4gdW5zaWduZWQgOC1iaXQgaW50ZWdlclxuICAgKi9cbiAgcmVhZFR5cGVSZWYgKCkge1xuICAgIHJldHVybiB0aGlzLnR5cGVSZWZEZWNvZGVyLnJlYWQoKVxuICB9XG5cbiAgLyoqXG4gICAqIFdyaXRlIGxlbiBvZiBhIHN0cnVjdCAtIHdlbGwgc3VpdGVkIGZvciBPcHQgUkxFIGVuY29kZXIuXG4gICAqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIHJlYWRMZW4gKCkge1xuICAgIHJldHVybiB0aGlzLmxlbkRlY29kZXIucmVhZCgpXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7YW55fVxuICAgKi9cbiAgcmVhZEFueSAoKSB7XG4gICAgcmV0dXJuIGRlY29kaW5nLnJlYWRBbnkodGhpcy5yZXN0RGVjb2RlcilcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtVaW50OEFycmF5fVxuICAgKi9cbiAgcmVhZEJ1ZiAoKSB7XG4gICAgcmV0dXJuIGRlY29kaW5nLnJlYWRWYXJVaW50OEFycmF5KHRoaXMucmVzdERlY29kZXIpXG4gIH1cblxuICAvKipcbiAgICogVGhpcyBpcyBtYWlubHkgaGVyZSBmb3IgbGVnYWN5IHB1cnBvc2VzLlxuICAgKlxuICAgKiBJbml0aWFsIHdlIGluY29kZWQgb2JqZWN0cyB1c2luZyBKU09OLiBOb3cgd2UgdXNlIHRoZSBtdWNoIGZhc3RlciBsaWIwL2FueS1lbmNvZGVyLiBUaGlzIG1ldGhvZCBtYWlubHkgZXhpc3RzIGZvciBsZWdhY3kgcHVycG9zZXMgZm9yIHRoZSB2MSBlbmNvZGVyLlxuICAgKlxuICAgKiBAcmV0dXJuIHthbnl9XG4gICAqL1xuICByZWFkSlNPTiAoKSB7XG4gICAgcmV0dXJuIGRlY29kaW5nLnJlYWRBbnkodGhpcy5yZXN0RGVjb2RlcilcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICByZWFkS2V5ICgpIHtcbiAgICBjb25zdCBrZXlDbG9jayA9IHRoaXMua2V5Q2xvY2tEZWNvZGVyLnJlYWQoKVxuICAgIGlmIChrZXlDbG9jayA8IHRoaXMua2V5cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzLmtleXNba2V5Q2xvY2tdXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGtleSA9IHRoaXMuc3RyaW5nRGVjb2Rlci5yZWFkKClcbiAgICAgIHRoaXMua2V5cy5wdXNoKGtleSlcbiAgICAgIHJldHVybiBrZXlcbiAgICB9XG4gIH1cbn1cbiIsICJcbmltcG9ydCAqIGFzIGVycm9yIGZyb20gJ2xpYjAvZXJyb3InXG5pbXBvcnQgKiBhcyBlbmNvZGluZyBmcm9tICdsaWIwL2VuY29kaW5nJ1xuXG5pbXBvcnQge1xuICBJRCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG59IGZyb20gJy4uL2ludGVybmFscy5qcydcblxuZXhwb3J0IGNsYXNzIERTRW5jb2RlclYxIHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHRoaXMucmVzdEVuY29kZXIgPSBlbmNvZGluZy5jcmVhdGVFbmNvZGVyKClcbiAgfVxuXG4gIHRvVWludDhBcnJheSAoKSB7XG4gICAgcmV0dXJuIGVuY29kaW5nLnRvVWludDhBcnJheSh0aGlzLnJlc3RFbmNvZGVyKVxuICB9XG5cbiAgcmVzZXREc0N1clZhbCAoKSB7XG4gICAgLy8gbm9wXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IGNsb2NrXG4gICAqL1xuICB3cml0ZURzQ2xvY2sgKGNsb2NrKSB7XG4gICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KHRoaXMucmVzdEVuY29kZXIsIGNsb2NrKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBsZW5cbiAgICovXG4gIHdyaXRlRHNMZW4gKGxlbikge1xuICAgIGVuY29kaW5nLndyaXRlVmFyVWludCh0aGlzLnJlc3RFbmNvZGVyLCBsZW4pXG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFVwZGF0ZUVuY29kZXJWMSBleHRlbmRzIERTRW5jb2RlclYxIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7SUR9IGlkXG4gICAqL1xuICB3cml0ZUxlZnRJRCAoaWQpIHtcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQodGhpcy5yZXN0RW5jb2RlciwgaWQuY2xpZW50KVxuICAgIGVuY29kaW5nLndyaXRlVmFyVWludCh0aGlzLnJlc3RFbmNvZGVyLCBpZC5jbG9jaylcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0lEfSBpZFxuICAgKi9cbiAgd3JpdGVSaWdodElEIChpZCkge1xuICAgIGVuY29kaW5nLndyaXRlVmFyVWludCh0aGlzLnJlc3RFbmNvZGVyLCBpZC5jbGllbnQpXG4gICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KHRoaXMucmVzdEVuY29kZXIsIGlkLmNsb2NrKVxuICB9XG5cbiAgLyoqXG4gICAqIFVzZSB3cml0ZUNsaWVudCBhbmQgd3JpdGVDbG9jayBpbnN0ZWFkIG9mIHdyaXRlSUQgaWYgcG9zc2libGUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjbGllbnRcbiAgICovXG4gIHdyaXRlQ2xpZW50IChjbGllbnQpIHtcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQodGhpcy5yZXN0RW5jb2RlciwgY2xpZW50KVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmZvIEFuIHVuc2lnbmVkIDgtYml0IGludGVnZXJcbiAgICovXG4gIHdyaXRlSW5mbyAoaW5mbykge1xuICAgIGVuY29kaW5nLndyaXRlVWludDgodGhpcy5yZXN0RW5jb2RlciwgaW5mbylcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc1xuICAgKi9cbiAgd3JpdGVTdHJpbmcgKHMpIHtcbiAgICBlbmNvZGluZy53cml0ZVZhclN0cmluZyh0aGlzLnJlc3RFbmNvZGVyLCBzKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNZS2V5XG4gICAqL1xuICB3cml0ZVBhcmVudEluZm8gKGlzWUtleSkge1xuICAgIGVuY29kaW5nLndyaXRlVmFyVWludCh0aGlzLnJlc3RFbmNvZGVyLCBpc1lLZXkgPyAxIDogMClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5mbyBBbiB1bnNpZ25lZCA4LWJpdCBpbnRlZ2VyXG4gICAqL1xuICB3cml0ZVR5cGVSZWYgKGluZm8pIHtcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQodGhpcy5yZXN0RW5jb2RlciwgaW5mbylcbiAgfVxuXG4gIC8qKlxuICAgKiBXcml0ZSBsZW4gb2YgYSBzdHJ1Y3QgLSB3ZWxsIHN1aXRlZCBmb3IgT3B0IFJMRSBlbmNvZGVyLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gbGVuXG4gICAqL1xuICB3cml0ZUxlbiAobGVuKSB7XG4gICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KHRoaXMucmVzdEVuY29kZXIsIGxlbilcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2FueX0gYW55XG4gICAqL1xuICB3cml0ZUFueSAoYW55KSB7XG4gICAgZW5jb2Rpbmcud3JpdGVBbnkodGhpcy5yZXN0RW5jb2RlciwgYW55KVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmXG4gICAqL1xuICB3cml0ZUJ1ZiAoYnVmKSB7XG4gICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50OEFycmF5KHRoaXMucmVzdEVuY29kZXIsIGJ1ZilcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2FueX0gZW1iZWRcbiAgICovXG4gIHdyaXRlSlNPTiAoZW1iZWQpIHtcbiAgICBlbmNvZGluZy53cml0ZVZhclN0cmluZyh0aGlzLnJlc3RFbmNvZGVyLCBKU09OLnN0cmluZ2lmeShlbWJlZCkpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgKi9cbiAgd3JpdGVLZXkgKGtleSkge1xuICAgIGVuY29kaW5nLndyaXRlVmFyU3RyaW5nKHRoaXMucmVzdEVuY29kZXIsIGtleSlcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgRFNFbmNvZGVyVjIge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgdGhpcy5yZXN0RW5jb2RlciA9IGVuY29kaW5nLmNyZWF0ZUVuY29kZXIoKSAvLyBlbmNvZGVzIGFsbCB0aGUgcmVzdCAvIG5vbi1vcHRpbWl6ZWRcbiAgICB0aGlzLmRzQ3VyclZhbCA9IDBcbiAgfVxuXG4gIHRvVWludDhBcnJheSAoKSB7XG4gICAgcmV0dXJuIGVuY29kaW5nLnRvVWludDhBcnJheSh0aGlzLnJlc3RFbmNvZGVyKVxuICB9XG5cbiAgcmVzZXREc0N1clZhbCAoKSB7XG4gICAgdGhpcy5kc0N1cnJWYWwgPSAwXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IGNsb2NrXG4gICAqL1xuICB3cml0ZURzQ2xvY2sgKGNsb2NrKSB7XG4gICAgY29uc3QgZGlmZiA9IGNsb2NrIC0gdGhpcy5kc0N1cnJWYWxcbiAgICB0aGlzLmRzQ3VyclZhbCA9IGNsb2NrXG4gICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KHRoaXMucmVzdEVuY29kZXIsIGRpZmYpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IGxlblxuICAgKi9cbiAgd3JpdGVEc0xlbiAobGVuKSB7XG4gICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgZXJyb3IudW5leHBlY3RlZENhc2UoKVxuICAgIH1cbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQodGhpcy5yZXN0RW5jb2RlciwgbGVuIC0gMSlcbiAgICB0aGlzLmRzQ3VyclZhbCArPSBsZW5cbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgVXBkYXRlRW5jb2RlclYyIGV4dGVuZHMgRFNFbmNvZGVyVjIge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgc3VwZXIoKVxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtNYXA8c3RyaW5nLG51bWJlcj59XG4gICAgICovXG4gICAgdGhpcy5rZXlNYXAgPSBuZXcgTWFwKClcbiAgICAvKipcbiAgICAgKiBSZWZlcnMgdG8gdGhlIG5leHQgdW5pcWUga2V5LWlkZW50aWZpZXIgdG8gbWUgdXNlZC5cbiAgICAgKiBTZWUgd3JpdGVLZXkgbWV0aG9kIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICAgICAqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmtleUNsb2NrID0gMFxuICAgIHRoaXMua2V5Q2xvY2tFbmNvZGVyID0gbmV3IGVuY29kaW5nLkludERpZmZPcHRSbGVFbmNvZGVyKClcbiAgICB0aGlzLmNsaWVudEVuY29kZXIgPSBuZXcgZW5jb2RpbmcuVWludE9wdFJsZUVuY29kZXIoKVxuICAgIHRoaXMubGVmdENsb2NrRW5jb2RlciA9IG5ldyBlbmNvZGluZy5JbnREaWZmT3B0UmxlRW5jb2RlcigpXG4gICAgdGhpcy5yaWdodENsb2NrRW5jb2RlciA9IG5ldyBlbmNvZGluZy5JbnREaWZmT3B0UmxlRW5jb2RlcigpXG4gICAgdGhpcy5pbmZvRW5jb2RlciA9IG5ldyBlbmNvZGluZy5SbGVFbmNvZGVyKGVuY29kaW5nLndyaXRlVWludDgpXG4gICAgdGhpcy5zdHJpbmdFbmNvZGVyID0gbmV3IGVuY29kaW5nLlN0cmluZ0VuY29kZXIoKVxuICAgIHRoaXMucGFyZW50SW5mb0VuY29kZXIgPSBuZXcgZW5jb2RpbmcuUmxlRW5jb2RlcihlbmNvZGluZy53cml0ZVVpbnQ4KVxuICAgIHRoaXMudHlwZVJlZkVuY29kZXIgPSBuZXcgZW5jb2RpbmcuVWludE9wdFJsZUVuY29kZXIoKVxuICAgIHRoaXMubGVuRW5jb2RlciA9IG5ldyBlbmNvZGluZy5VaW50T3B0UmxlRW5jb2RlcigpXG4gIH1cblxuICB0b1VpbnQ4QXJyYXkgKCkge1xuICAgIGNvbnN0IGVuY29kZXIgPSBlbmNvZGluZy5jcmVhdGVFbmNvZGVyKClcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2RlciwgMCkgLy8gdGhpcyBpcyBhIGZlYXR1cmUgZmxhZyB0aGF0IHdlIG1pZ2h0IHVzZSBpbiB0aGUgZnV0dXJlXG4gICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50OEFycmF5KGVuY29kZXIsIHRoaXMua2V5Q2xvY2tFbmNvZGVyLnRvVWludDhBcnJheSgpKVxuICAgIGVuY29kaW5nLndyaXRlVmFyVWludDhBcnJheShlbmNvZGVyLCB0aGlzLmNsaWVudEVuY29kZXIudG9VaW50OEFycmF5KCkpXG4gICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50OEFycmF5KGVuY29kZXIsIHRoaXMubGVmdENsb2NrRW5jb2Rlci50b1VpbnQ4QXJyYXkoKSlcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQ4QXJyYXkoZW5jb2RlciwgdGhpcy5yaWdodENsb2NrRW5jb2Rlci50b1VpbnQ4QXJyYXkoKSlcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQ4QXJyYXkoZW5jb2RlciwgZW5jb2RpbmcudG9VaW50OEFycmF5KHRoaXMuaW5mb0VuY29kZXIpKVxuICAgIGVuY29kaW5nLndyaXRlVmFyVWludDhBcnJheShlbmNvZGVyLCB0aGlzLnN0cmluZ0VuY29kZXIudG9VaW50OEFycmF5KCkpXG4gICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50OEFycmF5KGVuY29kZXIsIGVuY29kaW5nLnRvVWludDhBcnJheSh0aGlzLnBhcmVudEluZm9FbmNvZGVyKSlcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQ4QXJyYXkoZW5jb2RlciwgdGhpcy50eXBlUmVmRW5jb2Rlci50b1VpbnQ4QXJyYXkoKSlcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQ4QXJyYXkoZW5jb2RlciwgdGhpcy5sZW5FbmNvZGVyLnRvVWludDhBcnJheSgpKVxuICAgIC8vIEBub3RlIFRoZSByZXN0IGVuY29kZXIgaXMgYXBwZW5kZWQhIChub3RlIHRoZSBtaXNzaW5nIHZhcilcbiAgICBlbmNvZGluZy53cml0ZVVpbnQ4QXJyYXkoZW5jb2RlciwgZW5jb2RpbmcudG9VaW50OEFycmF5KHRoaXMucmVzdEVuY29kZXIpKVxuICAgIHJldHVybiBlbmNvZGluZy50b1VpbnQ4QXJyYXkoZW5jb2RlcilcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0lEfSBpZFxuICAgKi9cbiAgd3JpdGVMZWZ0SUQgKGlkKSB7XG4gICAgdGhpcy5jbGllbnRFbmNvZGVyLndyaXRlKGlkLmNsaWVudClcbiAgICB0aGlzLmxlZnRDbG9ja0VuY29kZXIud3JpdGUoaWQuY2xvY2spXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtJRH0gaWRcbiAgICovXG4gIHdyaXRlUmlnaHRJRCAoaWQpIHtcbiAgICB0aGlzLmNsaWVudEVuY29kZXIud3JpdGUoaWQuY2xpZW50KVxuICAgIHRoaXMucmlnaHRDbG9ja0VuY29kZXIud3JpdGUoaWQuY2xvY2spXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IGNsaWVudFxuICAgKi9cbiAgd3JpdGVDbGllbnQgKGNsaWVudCkge1xuICAgIHRoaXMuY2xpZW50RW5jb2Rlci53cml0ZShjbGllbnQpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZm8gQW4gdW5zaWduZWQgOC1iaXQgaW50ZWdlclxuICAgKi9cbiAgd3JpdGVJbmZvIChpbmZvKSB7XG4gICAgdGhpcy5pbmZvRW5jb2Rlci53cml0ZShpbmZvKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzXG4gICAqL1xuICB3cml0ZVN0cmluZyAocykge1xuICAgIHRoaXMuc3RyaW5nRW5jb2Rlci53cml0ZShzKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNZS2V5XG4gICAqL1xuICB3cml0ZVBhcmVudEluZm8gKGlzWUtleSkge1xuICAgIHRoaXMucGFyZW50SW5mb0VuY29kZXIud3JpdGUoaXNZS2V5ID8gMSA6IDApXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZm8gQW4gdW5zaWduZWQgOC1iaXQgaW50ZWdlclxuICAgKi9cbiAgd3JpdGVUeXBlUmVmIChpbmZvKSB7XG4gICAgdGhpcy50eXBlUmVmRW5jb2Rlci53cml0ZShpbmZvKVxuICB9XG5cbiAgLyoqXG4gICAqIFdyaXRlIGxlbiBvZiBhIHN0cnVjdCAtIHdlbGwgc3VpdGVkIGZvciBPcHQgUkxFIGVuY29kZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBsZW5cbiAgICovXG4gIHdyaXRlTGVuIChsZW4pIHtcbiAgICB0aGlzLmxlbkVuY29kZXIud3JpdGUobGVuKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7YW55fSBhbnlcbiAgICovXG4gIHdyaXRlQW55IChhbnkpIHtcbiAgICBlbmNvZGluZy53cml0ZUFueSh0aGlzLnJlc3RFbmNvZGVyLCBhbnkpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtVaW50OEFycmF5fSBidWZcbiAgICovXG4gIHdyaXRlQnVmIChidWYpIHtcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQ4QXJyYXkodGhpcy5yZXN0RW5jb2RlciwgYnVmKVxuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgaXMgbWFpbmx5IGhlcmUgZm9yIGxlZ2FjeSBwdXJwb3Nlcy5cbiAgICpcbiAgICogSW5pdGlhbCB3ZSBpbmNvZGVkIG9iamVjdHMgdXNpbmcgSlNPTi4gTm93IHdlIHVzZSB0aGUgbXVjaCBmYXN0ZXIgbGliMC9hbnktZW5jb2Rlci4gVGhpcyBtZXRob2QgbWFpbmx5IGV4aXN0cyBmb3IgbGVnYWN5IHB1cnBvc2VzIGZvciB0aGUgdjEgZW5jb2Rlci5cbiAgICpcbiAgICogQHBhcmFtIHthbnl9IGVtYmVkXG4gICAqL1xuICB3cml0ZUpTT04gKGVtYmVkKSB7XG4gICAgZW5jb2Rpbmcud3JpdGVBbnkodGhpcy5yZXN0RW5jb2RlciwgZW1iZWQpXG4gIH1cblxuICAvKipcbiAgICogUHJvcGVydHkga2V5cyBhcmUgb2Z0ZW4gcmV1c2VkLiBGb3IgZXhhbXBsZSwgaW4geS1wcm9zZW1pcnJvciB0aGUga2V5IGBib2xkYCBtaWdodFxuICAgKiBvY2N1ciB2ZXJ5IG9mdGVuLiBGb3IgYSAzZCBhcHBsaWNhdGlvbiwgdGhlIGtleSBgcG9zaXRpb25gIG1pZ2h0IG9jY3VyIHZlcnkgb2Z0ZW4uXG4gICAqXG4gICAqIFdlIGNhY2hlIHRoZXNlIGtleXMgaW4gYSBNYXAgYW5kIHJlZmVyIHRvIHRoZW0gdmlhIGEgdW5pcXVlIG51bWJlci5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgKi9cbiAgd3JpdGVLZXkgKGtleSkge1xuICAgIGNvbnN0IGNsb2NrID0gdGhpcy5rZXlNYXAuZ2V0KGtleSlcbiAgICBpZiAoY2xvY2sgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLyoqXG4gICAgICAgKiBAdG9kbyB1bmNvbW1lbnQgdG8gaW50cm9kdWNlIHRoaXMgZmVhdHVyZSBmaW5hbGx5XG4gICAgICAgKlxuICAgICAgICogQmFja2dyb3VuZC4gVGhlIENvbnRlbnRGb3JtYXQgb2JqZWN0IHdhcyBhbHdheXMgZW5jb2RlZCB1c2luZyB3cml0ZUtleSwgYnV0IHRoZSBkZWNvZGVyIHVzZWQgdG8gdXNlIHJlYWRTdHJpbmcuXG4gICAgICAgKiBGdXJ0aGVybW9yZSwgSSBmb3Jnb3QgdG8gc2V0IHRoZSBrZXljbG9jay4gU28gZXZlcnl0aGluZyB3YXMgd29ya2luZyBmaW5lLlxuICAgICAgICpcbiAgICAgICAqIEhvd2V2ZXIsIHRoaXMgZmVhdHVyZSBoZXJlIGlzIGJhc2ljYWxseSB1c2VsZXNzIGFzIGl0IGlzIG5vdCBiZWluZyB1c2VkIChpdCBhY3R1YWxseSBvbmx5IGNvbnN1bWVzIGV4dHJhIG1lbW9yeSkuXG4gICAgICAgKlxuICAgICAgICogSSBkb24ndCBrbm93IHlldCBob3cgdG8gcmVpbnRyb2R1Y2UgdGhpcyBmZWF0dXJlLi5cbiAgICAgICAqXG4gICAgICAgKiBPbGRlciBjbGllbnRzIHdvbid0IGJlIGFibGUgdG8gcmVhZCB1cGRhdGVzIHdoZW4gd2UgcmVpbnRyb2R1Y2UgdGhpcyBmZWF0dXJlLiBTbyB0aGlzIHNob3VsZCBwcm9iYWJseSBiZSBkb25lIHVzaW5nIGEgZmxhZy5cbiAgICAgICAqXG4gICAgICAgKi9cbiAgICAgIC8vIHRoaXMua2V5TWFwLnNldChrZXksIHRoaXMua2V5Q2xvY2spXG4gICAgICB0aGlzLmtleUNsb2NrRW5jb2Rlci53cml0ZSh0aGlzLmtleUNsb2NrKyspXG4gICAgICB0aGlzLnN0cmluZ0VuY29kZXIud3JpdGUoa2V5KVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmtleUNsb2NrRW5jb2Rlci53cml0ZShjbG9jaylcbiAgICB9XG4gIH1cbn1cbiIsICJcbi8qKlxuICogQG1vZHVsZSBlbmNvZGluZ1xuICovXG4vKlxuICogV2UgdXNlIHRoZSBmaXJzdCBmaXZlIGJpdHMgaW4gdGhlIGluZm8gZmxhZyBmb3IgZGV0ZXJtaW5pbmcgdGhlIHR5cGUgb2YgdGhlIHN0cnVjdC5cbiAqXG4gKiAwOiBHQ1xuICogMTogSXRlbSB3aXRoIERlbGV0ZWQgY29udGVudFxuICogMjogSXRlbSB3aXRoIEpTT04gY29udGVudFxuICogMzogSXRlbSB3aXRoIEJpbmFyeSBjb250ZW50XG4gKiA0OiBJdGVtIHdpdGggU3RyaW5nIGNvbnRlbnRcbiAqIDU6IEl0ZW0gd2l0aCBFbWJlZCBjb250ZW50IChmb3IgcmljaHRleHQgY29udGVudClcbiAqIDY6IEl0ZW0gd2l0aCBGb3JtYXQgY29udGVudCAoYSBmb3JtYXR0aW5nIG1hcmtlciBmb3IgcmljaHRleHQgY29udGVudClcbiAqIDc6IEl0ZW0gd2l0aCBUeXBlXG4gKi9cblxuaW1wb3J0IHtcbiAgZmluZEluZGV4U1MsXG4gIGdldFN0YXRlLFxuICBjcmVhdGVJRCxcbiAgZ2V0U3RhdGVWZWN0b3IsXG4gIHJlYWRBbmRBcHBseURlbGV0ZVNldCxcbiAgd3JpdGVEZWxldGVTZXQsXG4gIGNyZWF0ZURlbGV0ZVNldEZyb21TdHJ1Y3RTdG9yZSxcbiAgdHJhbnNhY3QsXG4gIHJlYWRJdGVtQ29udGVudCxcbiAgVXBkYXRlRGVjb2RlclYxLFxuICBVcGRhdGVEZWNvZGVyVjIsXG4gIFVwZGF0ZUVuY29kZXJWMSxcbiAgVXBkYXRlRW5jb2RlclYyLFxuICBEU0VuY29kZXJWMixcbiAgRFNEZWNvZGVyVjEsXG4gIERTRW5jb2RlclYxLFxuICBtZXJnZVVwZGF0ZXMsXG4gIG1lcmdlVXBkYXRlc1YyLFxuICBTa2lwLFxuICBkaWZmVXBkYXRlVjIsXG4gIGNvbnZlcnRVcGRhdGVGb3JtYXRWMlRvVjEsXG4gIERTRGVjb2RlclYyLCBEb2MsIFRyYW5zYWN0aW9uLCBHQywgSXRlbSwgU3RydWN0U3RvcmUgLy8gZXNsaW50LWRpc2FibGUtbGluZVxufSBmcm9tICcuLi9pbnRlcm5hbHMuanMnXG5cbmltcG9ydCAqIGFzIGVuY29kaW5nIGZyb20gJ2xpYjAvZW5jb2RpbmcnXG5pbXBvcnQgKiBhcyBkZWNvZGluZyBmcm9tICdsaWIwL2RlY29kaW5nJ1xuaW1wb3J0ICogYXMgYmluYXJ5IGZyb20gJ2xpYjAvYmluYXJ5J1xuaW1wb3J0ICogYXMgbWFwIGZyb20gJ2xpYjAvbWFwJ1xuaW1wb3J0ICogYXMgbWF0aCBmcm9tICdsaWIwL21hdGgnXG5pbXBvcnQgKiBhcyBhcnJheSBmcm9tICdsaWIwL2FycmF5J1xuXG4vKipcbiAqIEBwYXJhbSB7VXBkYXRlRW5jb2RlclYxIHwgVXBkYXRlRW5jb2RlclYyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge0FycmF5PEdDfEl0ZW0+fSBzdHJ1Y3RzIEFsbCBzdHJ1Y3RzIGJ5IGBjbGllbnRgXG4gKiBAcGFyYW0ge251bWJlcn0gY2xpZW50XG4gKiBAcGFyYW0ge251bWJlcn0gY2xvY2sgd3JpdGUgc3RydWN0cyBzdGFydGluZyB3aXRoIGBJRChjbGllbnQsY2xvY2spYFxuICpcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCB3cml0ZVN0cnVjdHMgPSAoZW5jb2Rlciwgc3RydWN0cywgY2xpZW50LCBjbG9jaykgPT4ge1xuICAvLyB3cml0ZSBmaXJzdCBpZFxuICBjbG9jayA9IG1hdGgubWF4KGNsb2NrLCBzdHJ1Y3RzWzBdLmlkLmNsb2NrKSAvLyBtYWtlIHN1cmUgdGhlIGZpcnN0IGlkIGV4aXN0c1xuICBjb25zdCBzdGFydE5ld1N0cnVjdHMgPSBmaW5kSW5kZXhTUyhzdHJ1Y3RzLCBjbG9jaylcbiAgLy8gd3JpdGUgIyBlbmNvZGVkIHN0cnVjdHNcbiAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIucmVzdEVuY29kZXIsIHN0cnVjdHMubGVuZ3RoIC0gc3RhcnROZXdTdHJ1Y3RzKVxuICBlbmNvZGVyLndyaXRlQ2xpZW50KGNsaWVudClcbiAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIucmVzdEVuY29kZXIsIGNsb2NrKVxuICBjb25zdCBmaXJzdFN0cnVjdCA9IHN0cnVjdHNbc3RhcnROZXdTdHJ1Y3RzXVxuICAvLyB3cml0ZSBmaXJzdCBzdHJ1Y3Qgd2l0aCBhbiBvZmZzZXRcbiAgZmlyc3RTdHJ1Y3Qud3JpdGUoZW5jb2RlciwgY2xvY2sgLSBmaXJzdFN0cnVjdC5pZC5jbG9jaylcbiAgZm9yIChsZXQgaSA9IHN0YXJ0TmV3U3RydWN0cyArIDE7IGkgPCBzdHJ1Y3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgc3RydWN0c1tpXS53cml0ZShlbmNvZGVyLCAwKVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtVcGRhdGVFbmNvZGVyVjEgfCBVcGRhdGVFbmNvZGVyVjJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7U3RydWN0U3RvcmV9IHN0b3JlXG4gKiBAcGFyYW0ge01hcDxudW1iZXIsbnVtYmVyPn0gX3NtXG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3Qgd3JpdGVDbGllbnRzU3RydWN0cyA9IChlbmNvZGVyLCBzdG9yZSwgX3NtKSA9PiB7XG4gIC8vIHdlIGZpbHRlciBhbGwgdmFsaWQgX3NtIGVudHJpZXMgaW50byBzbVxuICBjb25zdCBzbSA9IG5ldyBNYXAoKVxuICBfc20uZm9yRWFjaCgoY2xvY2ssIGNsaWVudCkgPT4ge1xuICAgIC8vIG9ubHkgd3JpdGUgaWYgbmV3IHN0cnVjdHMgYXJlIGF2YWlsYWJsZVxuICAgIGlmIChnZXRTdGF0ZShzdG9yZSwgY2xpZW50KSA+IGNsb2NrKSB7XG4gICAgICBzbS5zZXQoY2xpZW50LCBjbG9jaylcbiAgICB9XG4gIH0pXG4gIGdldFN0YXRlVmVjdG9yKHN0b3JlKS5mb3JFYWNoKChfY2xvY2ssIGNsaWVudCkgPT4ge1xuICAgIGlmICghX3NtLmhhcyhjbGllbnQpKSB7XG4gICAgICBzbS5zZXQoY2xpZW50LCAwKVxuICAgIH1cbiAgfSlcbiAgLy8gd3JpdGUgIyBzdGF0ZXMgdGhhdCB3ZXJlIHVwZGF0ZWRcbiAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIucmVzdEVuY29kZXIsIHNtLnNpemUpXG4gIC8vIFdyaXRlIGl0ZW1zIHdpdGggaGlnaGVyIGNsaWVudCBpZHMgZmlyc3RcbiAgLy8gVGhpcyBoZWF2aWx5IGltcHJvdmVzIHRoZSBjb25mbGljdCBhbGdvcml0aG0uXG4gIGFycmF5LmZyb20oc20uZW50cmllcygpKS5zb3J0KChhLCBiKSA9PiBiWzBdIC0gYVswXSkuZm9yRWFjaCgoW2NsaWVudCwgY2xvY2tdKSA9PiB7XG4gICAgd3JpdGVTdHJ1Y3RzKGVuY29kZXIsIC8qKiBAdHlwZSB7QXJyYXk8R0N8SXRlbT59ICovIChzdG9yZS5jbGllbnRzLmdldChjbGllbnQpKSwgY2xpZW50LCBjbG9jaylcbiAgfSlcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1VwZGF0ZURlY29kZXJWMSB8IFVwZGF0ZURlY29kZXJWMn0gZGVjb2RlciBUaGUgZGVjb2RlciBvYmplY3QgdG8gcmVhZCBkYXRhIGZyb20uXG4gKiBAcGFyYW0ge0RvY30gZG9jXG4gKiBAcmV0dXJuIHtNYXA8bnVtYmVyLCB7IGk6IG51bWJlciwgcmVmczogQXJyYXk8SXRlbSB8IEdDPiB9Pn1cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCByZWFkQ2xpZW50c1N0cnVjdFJlZnMgPSAoZGVjb2RlciwgZG9jKSA9PiB7XG4gIC8qKlxuICAgKiBAdHlwZSB7TWFwPG51bWJlciwgeyBpOiBudW1iZXIsIHJlZnM6IEFycmF5PEl0ZW0gfCBHQz4gfT59XG4gICAqL1xuICBjb25zdCBjbGllbnRSZWZzID0gbWFwLmNyZWF0ZSgpXG4gIGNvbnN0IG51bU9mU3RhdGVVcGRhdGVzID0gZGVjb2RpbmcucmVhZFZhclVpbnQoZGVjb2Rlci5yZXN0RGVjb2RlcilcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1PZlN0YXRlVXBkYXRlczsgaSsrKSB7XG4gICAgY29uc3QgbnVtYmVyT2ZTdHJ1Y3RzID0gZGVjb2RpbmcucmVhZFZhclVpbnQoZGVjb2Rlci5yZXN0RGVjb2RlcilcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QXJyYXk8R0N8SXRlbT59XG4gICAgICovXG4gICAgY29uc3QgcmVmcyA9IG5ldyBBcnJheShudW1iZXJPZlN0cnVjdHMpXG4gICAgY29uc3QgY2xpZW50ID0gZGVjb2Rlci5yZWFkQ2xpZW50KClcbiAgICBsZXQgY2xvY2sgPSBkZWNvZGluZy5yZWFkVmFyVWludChkZWNvZGVyLnJlc3REZWNvZGVyKVxuICAgIC8vIGNvbnN0IHN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KClcbiAgICBjbGllbnRSZWZzLnNldChjbGllbnQsIHsgaTogMCwgcmVmcyB9KVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtYmVyT2ZTdHJ1Y3RzOyBpKyspIHtcbiAgICAgIGNvbnN0IGluZm8gPSBkZWNvZGVyLnJlYWRJbmZvKClcbiAgICAgIHN3aXRjaCAoYmluYXJ5LkJJVFM1ICYgaW5mbykge1xuICAgICAgICBjYXNlIDA6IHsgLy8gR0NcbiAgICAgICAgICBjb25zdCBsZW4gPSBkZWNvZGVyLnJlYWRMZW4oKVxuICAgICAgICAgIHJlZnNbaV0gPSBuZXcgR0MoY3JlYXRlSUQoY2xpZW50LCBjbG9jayksIGxlbilcbiAgICAgICAgICBjbG9jayArPSBsZW5cbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgMTA6IHsgLy8gU2tpcCBTdHJ1Y3QgKG5vdGhpbmcgdG8gYXBwbHkpXG4gICAgICAgICAgLy8gQHRvZG8gd2UgY291bGQgcmVkdWNlIHRoZSBhbW91bnQgb2YgY2hlY2tzIGJ5IGFkZGluZyBTa2lwIHN0cnVjdCB0byBjbGllbnRSZWZzIHNvIHdlIGtub3cgdGhhdCBzb21ldGhpbmcgaXMgbWlzc2luZy5cbiAgICAgICAgICBjb25zdCBsZW4gPSBkZWNvZGluZy5yZWFkVmFyVWludChkZWNvZGVyLnJlc3REZWNvZGVyKVxuICAgICAgICAgIHJlZnNbaV0gPSBuZXcgU2tpcChjcmVhdGVJRChjbGllbnQsIGNsb2NrKSwgbGVuKVxuICAgICAgICAgIGNsb2NrICs9IGxlblxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDogeyAvLyBJdGVtIHdpdGggY29udGVudFxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFRoZSBvcHRpbWl6ZWQgaW1wbGVtZW50YXRpb24gZG9lc24ndCB1c2UgYW55IHZhcmlhYmxlcyBiZWNhdXNlIGlubGluaW5nIHZhcmlhYmxlcyBpcyBmYXN0ZXIuXG4gICAgICAgICAgICogQmVsb3cgYSBub24tb3B0aW1pemVkIHZlcnNpb24gaXMgc2hvd24gdGhhdCBpbXBsZW1lbnRzIHRoZSBiYXNpYyBhbGdvcml0aG0gd2l0aFxuICAgICAgICAgICAqIGEgZmV3IGNvbW1lbnRzXG4gICAgICAgICAgICovXG4gICAgICAgICAgY29uc3QgY2FudENvcHlQYXJlbnRJbmZvID0gKGluZm8gJiAoYmluYXJ5LkJJVDcgfCBiaW5hcnkuQklUOCkpID09PSAwXG4gICAgICAgICAgLy8gSWYgcGFyZW50ID0gbnVsbCBhbmQgbmVpdGhlciBsZWZ0IG5vciByaWdodCBhcmUgZGVmaW5lZCwgdGhlbiB3ZSBrbm93IHRoYXQgYHBhcmVudGAgaXMgY2hpbGQgb2YgYHlgXG4gICAgICAgICAgLy8gYW5kIHdlIHJlYWQgdGhlIG5leHQgc3RyaW5nIGFzIHBhcmVudFlLZXkuXG4gICAgICAgICAgLy8gSXQgaW5kaWNhdGVzIGhvdyB3ZSBzdG9yZS9yZXRyaWV2ZSBwYXJlbnQgZnJvbSBgeS5zaGFyZWBcbiAgICAgICAgICAvLyBAdHlwZSB7c3RyaW5nfG51bGx9XG4gICAgICAgICAgY29uc3Qgc3RydWN0ID0gbmV3IEl0ZW0oXG4gICAgICAgICAgICBjcmVhdGVJRChjbGllbnQsIGNsb2NrKSxcbiAgICAgICAgICAgIG51bGwsIC8vIGxlZnRkXG4gICAgICAgICAgICAoaW5mbyAmIGJpbmFyeS5CSVQ4KSA9PT0gYmluYXJ5LkJJVDggPyBkZWNvZGVyLnJlYWRMZWZ0SUQoKSA6IG51bGwsIC8vIG9yaWdpblxuICAgICAgICAgICAgbnVsbCwgLy8gcmlnaHRcbiAgICAgICAgICAgIChpbmZvICYgYmluYXJ5LkJJVDcpID09PSBiaW5hcnkuQklUNyA/IGRlY29kZXIucmVhZFJpZ2h0SUQoKSA6IG51bGwsIC8vIHJpZ2h0IG9yaWdpblxuICAgICAgICAgICAgY2FudENvcHlQYXJlbnRJbmZvID8gKGRlY29kZXIucmVhZFBhcmVudEluZm8oKSA/IGRvYy5nZXQoZGVjb2Rlci5yZWFkU3RyaW5nKCkpIDogZGVjb2Rlci5yZWFkTGVmdElEKCkpIDogbnVsbCwgLy8gcGFyZW50XG4gICAgICAgICAgICBjYW50Q29weVBhcmVudEluZm8gJiYgKGluZm8gJiBiaW5hcnkuQklUNikgPT09IGJpbmFyeS5CSVQ2ID8gZGVjb2Rlci5yZWFkU3RyaW5nKCkgOiBudWxsLCAvLyBwYXJlbnRTdWJcbiAgICAgICAgICAgIHJlYWRJdGVtQ29udGVudChkZWNvZGVyLCBpbmZvKSAvLyBpdGVtIGNvbnRlbnRcbiAgICAgICAgICApXG4gICAgICAgICAgLyogQSBub24tb3B0aW1pemVkIGltcGxlbWVudGF0aW9uIG9mIHRoZSBhYm92ZSBhbGdvcml0aG06XG5cbiAgICAgICAgICAvLyBUaGUgaXRlbSB0aGF0IHdhcyBvcmlnaW5hbGx5IHRvIHRoZSBsZWZ0IG9mIHRoaXMgaXRlbS5cbiAgICAgICAgICBjb25zdCBvcmlnaW4gPSAoaW5mbyAmIGJpbmFyeS5CSVQ4KSA9PT0gYmluYXJ5LkJJVDggPyBkZWNvZGVyLnJlYWRMZWZ0SUQoKSA6IG51bGxcbiAgICAgICAgICAvLyBUaGUgaXRlbSB0aGF0IHdhcyBvcmlnaW5hbGx5IHRvIHRoZSByaWdodCBvZiB0aGlzIGl0ZW0uXG4gICAgICAgICAgY29uc3QgcmlnaHRPcmlnaW4gPSAoaW5mbyAmIGJpbmFyeS5CSVQ3KSA9PT0gYmluYXJ5LkJJVDcgPyBkZWNvZGVyLnJlYWRSaWdodElEKCkgOiBudWxsXG4gICAgICAgICAgY29uc3QgY2FudENvcHlQYXJlbnRJbmZvID0gKGluZm8gJiAoYmluYXJ5LkJJVDcgfCBiaW5hcnkuQklUOCkpID09PSAwXG4gICAgICAgICAgY29uc3QgaGFzUGFyZW50WUtleSA9IGNhbnRDb3B5UGFyZW50SW5mbyA/IGRlY29kZXIucmVhZFBhcmVudEluZm8oKSA6IGZhbHNlXG4gICAgICAgICAgLy8gSWYgcGFyZW50ID0gbnVsbCBhbmQgbmVpdGhlciBsZWZ0IG5vciByaWdodCBhcmUgZGVmaW5lZCwgdGhlbiB3ZSBrbm93IHRoYXQgYHBhcmVudGAgaXMgY2hpbGQgb2YgYHlgXG4gICAgICAgICAgLy8gYW5kIHdlIHJlYWQgdGhlIG5leHQgc3RyaW5nIGFzIHBhcmVudFlLZXkuXG4gICAgICAgICAgLy8gSXQgaW5kaWNhdGVzIGhvdyB3ZSBzdG9yZS9yZXRyaWV2ZSBwYXJlbnQgZnJvbSBgeS5zaGFyZWBcbiAgICAgICAgICAvLyBAdHlwZSB7c3RyaW5nfG51bGx9XG4gICAgICAgICAgY29uc3QgcGFyZW50WUtleSA9IGNhbnRDb3B5UGFyZW50SW5mbyAmJiBoYXNQYXJlbnRZS2V5ID8gZGVjb2Rlci5yZWFkU3RyaW5nKCkgOiBudWxsXG5cbiAgICAgICAgICBjb25zdCBzdHJ1Y3QgPSBuZXcgSXRlbShcbiAgICAgICAgICAgIGNyZWF0ZUlEKGNsaWVudCwgY2xvY2spLFxuICAgICAgICAgICAgbnVsbCwgLy8gbGVmdGRcbiAgICAgICAgICAgIG9yaWdpbiwgLy8gb3JpZ2luXG4gICAgICAgICAgICBudWxsLCAvLyByaWdodFxuICAgICAgICAgICAgcmlnaHRPcmlnaW4sIC8vIHJpZ2h0IG9yaWdpblxuICAgICAgICAgICAgY2FudENvcHlQYXJlbnRJbmZvICYmICFoYXNQYXJlbnRZS2V5ID8gZGVjb2Rlci5yZWFkTGVmdElEKCkgOiAocGFyZW50WUtleSAhPT0gbnVsbCA/IGRvYy5nZXQocGFyZW50WUtleSkgOiBudWxsKSwgLy8gcGFyZW50XG4gICAgICAgICAgICBjYW50Q29weVBhcmVudEluZm8gJiYgKGluZm8gJiBiaW5hcnkuQklUNikgPT09IGJpbmFyeS5CSVQ2ID8gZGVjb2Rlci5yZWFkU3RyaW5nKCkgOiBudWxsLCAvLyBwYXJlbnRTdWJcbiAgICAgICAgICAgIHJlYWRJdGVtQ29udGVudChkZWNvZGVyLCBpbmZvKSAvLyBpdGVtIGNvbnRlbnRcbiAgICAgICAgICApXG4gICAgICAgICAgKi9cbiAgICAgICAgICByZWZzW2ldID0gc3RydWN0XG4gICAgICAgICAgY2xvY2sgKz0gc3RydWN0Lmxlbmd0aFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGNvbnNvbGUubG9nKCd0aW1lIHRvIHJlYWQ6ICcsIHBlcmZvcm1hbmNlLm5vdygpIC0gc3RhcnQpIC8vIEB0b2RvIHJlbW92ZVxuICB9XG4gIHJldHVybiBjbGllbnRSZWZzXG59XG5cbi8qKlxuICogUmVzdW1lIGNvbXB1dGluZyBzdHJ1Y3RzIGdlbmVyYXRlZCBieSBzdHJ1Y3QgcmVhZGVycy5cbiAqXG4gKiBXaGlsZSB0aGVyZSBpcyBzb21ldGhpbmcgdG8gZG8sIHdlIGludGVncmF0ZSBzdHJ1Y3RzIGluIHRoaXMgb3JkZXJcbiAqIDEuIHRvcCBlbGVtZW50IG9uIHN0YWNrLCBpZiBzdGFjayBpcyBub3QgZW1wdHlcbiAqIDIuIG5leHQgZWxlbWVudCBmcm9tIGN1cnJlbnQgc3RydWN0IHJlYWRlciAoaWYgZW1wdHksIHVzZSBuZXh0IHN0cnVjdCByZWFkZXIpXG4gKlxuICogSWYgc3RydWN0IGNhdXNhbGx5IGRlcGVuZHMgb24gYW5vdGhlciBzdHJ1Y3QgKHJlZi5taXNzaW5nKSwgd2UgcHV0IG5leHQgcmVhZGVyIG9mXG4gKiBgcmVmLmlkLmNsaWVudGAgb24gdG9wIG9mIHN0YWNrLlxuICpcbiAqIEF0IHNvbWUgcG9pbnQgd2UgZmluZCBhIHN0cnVjdCB0aGF0IGhhcyBubyBjYXVzYWwgZGVwZW5kZW5jaWVzLFxuICogdGhlbiB3ZSBzdGFydCBlbXB0eWluZyB0aGUgc3RhY2suXG4gKlxuICogSXQgaXMgbm90IHBvc3NpYmxlIHRvIGhhdmUgY2lyY2xlczogaS5lLiBzdHJ1Y3QxIChmcm9tIGNsaWVudDEpIGRlcGVuZHMgb24gc3RydWN0MiAoZnJvbSBjbGllbnQyKVxuICogZGVwZW5kcyBvbiBzdHJ1Y3QzIChmcm9tIGNsaWVudDEpLiBUaGVyZWZvcmUgdGhlIG1heCBzdGFjayBzaXplIGlzIGVxYXVsIHRvIGBzdHJ1Y3RSZWFkZXJzLmxlbmd0aGAuXG4gKlxuICogVGhpcyBtZXRob2QgaXMgaW1wbGVtZW50ZWQgaW4gYSB3YXkgc28gdGhhdCB3ZSBjYW4gcmVzdW1lIGNvbXB1dGF0aW9uIGlmIHRoaXMgdXBkYXRlXG4gKiBjYXVzYWxseSBkZXBlbmRzIG9uIGFub3RoZXIgdXBkYXRlLlxuICpcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge1N0cnVjdFN0b3JlfSBzdG9yZVxuICogQHBhcmFtIHtNYXA8bnVtYmVyLCB7IGk6IG51bWJlciwgcmVmczogKEdDIHwgSXRlbSlbXSB9Pn0gY2xpZW50c1N0cnVjdFJlZnNcbiAqIEByZXR1cm4geyBudWxsIHwgeyB1cGRhdGU6IFVpbnQ4QXJyYXksIG1pc3Npbmc6IE1hcDxudW1iZXIsbnVtYmVyPiB9IH1cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IGludGVncmF0ZVN0cnVjdHMgPSAodHJhbnNhY3Rpb24sIHN0b3JlLCBjbGllbnRzU3RydWN0UmVmcykgPT4ge1xuICAvKipcbiAgICogQHR5cGUge0FycmF5PEl0ZW0gfCBHQz59XG4gICAqL1xuICBjb25zdCBzdGFjayA9IFtdXG4gIC8vIHNvcnQgdGhlbSBzbyB0aGF0IHdlIHRha2UgdGhlIGhpZ2hlciBpZCBmaXJzdCwgaW4gY2FzZSBvZiBjb25mbGljdHMgdGhlIGxvd2VyIGlkIHdpbGwgcHJvYmFibHkgbm90IGNvbmZsaWN0IHdpdGggdGhlIGlkIGZyb20gdGhlIGhpZ2hlciB1c2VyLlxuICBsZXQgY2xpZW50c1N0cnVjdFJlZnNJZHMgPSBhcnJheS5mcm9tKGNsaWVudHNTdHJ1Y3RSZWZzLmtleXMoKSkuc29ydCgoYSwgYikgPT4gYSAtIGIpXG4gIGlmIChjbGllbnRzU3RydWN0UmVmc0lkcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG4gIGNvbnN0IGdldE5leHRTdHJ1Y3RUYXJnZXQgPSAoKSA9PiB7XG4gICAgaWYgKGNsaWVudHNTdHJ1Y3RSZWZzSWRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gICAgbGV0IG5leHRTdHJ1Y3RzVGFyZ2V0ID0gLyoqIEB0eXBlIHt7aTpudW1iZXIscmVmczpBcnJheTxHQ3xJdGVtPn19ICovIChjbGllbnRzU3RydWN0UmVmcy5nZXQoY2xpZW50c1N0cnVjdFJlZnNJZHNbY2xpZW50c1N0cnVjdFJlZnNJZHMubGVuZ3RoIC0gMV0pKVxuICAgIHdoaWxlIChuZXh0U3RydWN0c1RhcmdldC5yZWZzLmxlbmd0aCA9PT0gbmV4dFN0cnVjdHNUYXJnZXQuaSkge1xuICAgICAgY2xpZW50c1N0cnVjdFJlZnNJZHMucG9wKClcbiAgICAgIGlmIChjbGllbnRzU3RydWN0UmVmc0lkcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIG5leHRTdHJ1Y3RzVGFyZ2V0ID0gLyoqIEB0eXBlIHt7aTpudW1iZXIscmVmczpBcnJheTxHQ3xJdGVtPn19ICovIChjbGllbnRzU3RydWN0UmVmcy5nZXQoY2xpZW50c1N0cnVjdFJlZnNJZHNbY2xpZW50c1N0cnVjdFJlZnNJZHMubGVuZ3RoIC0gMV0pKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5leHRTdHJ1Y3RzVGFyZ2V0XG4gIH1cbiAgbGV0IGN1clN0cnVjdHNUYXJnZXQgPSBnZXROZXh0U3RydWN0VGFyZ2V0KClcbiAgaWYgKGN1clN0cnVjdHNUYXJnZXQgPT09IG51bGwgJiYgc3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7U3RydWN0U3RvcmV9XG4gICAqL1xuICBjb25zdCByZXN0U3RydWN0cyA9IG5ldyBTdHJ1Y3RTdG9yZSgpXG4gIGNvbnN0IG1pc3NpbmdTViA9IG5ldyBNYXAoKVxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IGNsaWVudFxuICAgKiBAcGFyYW0ge251bWJlcn0gY2xvY2tcbiAgICovXG4gIGNvbnN0IHVwZGF0ZU1pc3NpbmdTdiA9IChjbGllbnQsIGNsb2NrKSA9PiB7XG4gICAgY29uc3QgbWNsb2NrID0gbWlzc2luZ1NWLmdldChjbGllbnQpXG4gICAgaWYgKG1jbG9jayA9PSBudWxsIHx8IG1jbG9jayA+IGNsb2NrKSB7XG4gICAgICBtaXNzaW5nU1Yuc2V0KGNsaWVudCwgY2xvY2spXG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBAdHlwZSB7R0N8SXRlbX1cbiAgICovXG4gIGxldCBzdGFja0hlYWQgPSAvKiogQHR5cGUge2FueX0gKi8gKGN1clN0cnVjdHNUYXJnZXQpLnJlZnNbLyoqIEB0eXBlIHthbnl9ICovIChjdXJTdHJ1Y3RzVGFyZ2V0KS5pKytdXG4gIC8vIGNhY2hpbmcgdGhlIHN0YXRlIGJlY2F1c2UgaXQgaXMgdXNlZCB2ZXJ5IG9mdGVuXG4gIGNvbnN0IHN0YXRlID0gbmV3IE1hcCgpXG5cbiAgY29uc3QgYWRkU3RhY2tUb1Jlc3RTUyA9ICgpID0+IHtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2Ygc3RhY2spIHtcbiAgICAgIGNvbnN0IGNsaWVudCA9IGl0ZW0uaWQuY2xpZW50XG4gICAgICBjb25zdCB1bmFwcGxpY2FibGVJdGVtcyA9IGNsaWVudHNTdHJ1Y3RSZWZzLmdldChjbGllbnQpXG4gICAgICBpZiAodW5hcHBsaWNhYmxlSXRlbXMpIHtcbiAgICAgICAgLy8gZGVjcmVtZW50IGJlY2F1c2Ugd2Ugd2VyZW4ndCBhYmxlIHRvIGFwcGx5IHByZXZpb3VzIG9wZXJhdGlvblxuICAgICAgICB1bmFwcGxpY2FibGVJdGVtcy5pLS1cbiAgICAgICAgcmVzdFN0cnVjdHMuY2xpZW50cy5zZXQoY2xpZW50LCB1bmFwcGxpY2FibGVJdGVtcy5yZWZzLnNsaWNlKHVuYXBwbGljYWJsZUl0ZW1zLmkpKVxuICAgICAgICBjbGllbnRzU3RydWN0UmVmcy5kZWxldGUoY2xpZW50KVxuICAgICAgICB1bmFwcGxpY2FibGVJdGVtcy5pID0gMFxuICAgICAgICB1bmFwcGxpY2FibGVJdGVtcy5yZWZzID0gW11cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGl0ZW0gd2FzIHRoZSBsYXN0IGl0ZW0gb24gY2xpZW50c1N0cnVjdFJlZnMgYW5kIHRoZSBmaWVsZCB3YXMgYWxyZWFkeSBjbGVhcmVkLiBBZGQgaXRlbSB0byByZXN0U3RydWN0cyBhbmQgY29udGludWVcbiAgICAgICAgcmVzdFN0cnVjdHMuY2xpZW50cy5zZXQoY2xpZW50LCBbaXRlbV0pXG4gICAgICB9XG4gICAgICAvLyByZW1vdmUgY2xpZW50IGZyb20gY2xpZW50c1N0cnVjdFJlZnNJZHMgdG8gcHJldmVudCB1c2VycyBmcm9tIGFwcGx5aW5nIHRoZSBzYW1lIHVwZGF0ZSBhZ2FpblxuICAgICAgY2xpZW50c1N0cnVjdFJlZnNJZHMgPSBjbGllbnRzU3RydWN0UmVmc0lkcy5maWx0ZXIoYyA9PiBjICE9PSBjbGllbnQpXG4gICAgfVxuICAgIHN0YWNrLmxlbmd0aCA9IDBcbiAgfVxuXG4gIC8vIGl0ZXJhdGUgb3ZlciBhbGwgc3RydWN0IHJlYWRlcnMgdW50aWwgd2UgYXJlIGRvbmVcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBpZiAoc3RhY2tIZWFkLmNvbnN0cnVjdG9yICE9PSBTa2lwKSB7XG4gICAgICBjb25zdCBsb2NhbENsb2NrID0gbWFwLnNldElmVW5kZWZpbmVkKHN0YXRlLCBzdGFja0hlYWQuaWQuY2xpZW50LCAoKSA9PiBnZXRTdGF0ZShzdG9yZSwgc3RhY2tIZWFkLmlkLmNsaWVudCkpXG4gICAgICBjb25zdCBvZmZzZXQgPSBsb2NhbENsb2NrIC0gc3RhY2tIZWFkLmlkLmNsb2NrXG4gICAgICBpZiAob2Zmc2V0IDwgMCkge1xuICAgICAgICAvLyB1cGRhdGUgZnJvbSB0aGUgc2FtZSBjbGllbnQgaXMgbWlzc2luZ1xuICAgICAgICBzdGFjay5wdXNoKHN0YWNrSGVhZClcbiAgICAgICAgdXBkYXRlTWlzc2luZ1N2KHN0YWNrSGVhZC5pZC5jbGllbnQsIHN0YWNrSGVhZC5pZC5jbG9jayAtIDEpXG4gICAgICAgIC8vIGhpZCBhIGRlYWQgd2FsbCwgYWRkIGFsbCBpdGVtcyBmcm9tIHN0YWNrIHRvIHJlc3RTU1xuICAgICAgICBhZGRTdGFja1RvUmVzdFNTKClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IG1pc3NpbmcgPSBzdGFja0hlYWQuZ2V0TWlzc2luZyh0cmFuc2FjdGlvbiwgc3RvcmUpXG4gICAgICAgIGlmIChtaXNzaW5nICE9PSBudWxsKSB7XG4gICAgICAgICAgc3RhY2sucHVzaChzdGFja0hlYWQpXG4gICAgICAgICAgLy8gZ2V0IHRoZSBzdHJ1Y3QgcmVhZGVyIHRoYXQgaGFzIHRoZSBtaXNzaW5nIHN0cnVjdFxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIEB0eXBlIHt7IHJlZnM6IEFycmF5PEdDfEl0ZW0+LCBpOiBudW1iZXIgfX1cbiAgICAgICAgICAgKi9cbiAgICAgICAgICBjb25zdCBzdHJ1Y3RSZWZzID0gY2xpZW50c1N0cnVjdFJlZnMuZ2V0KC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAobWlzc2luZykpIHx8IHsgcmVmczogW10sIGk6IDAgfVxuICAgICAgICAgIGlmIChzdHJ1Y3RSZWZzLnJlZnMubGVuZ3RoID09PSBzdHJ1Y3RSZWZzLmkpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgdXBkYXRlIG1lc3NhZ2UgY2F1c2FsbHkgZGVwZW5kcyBvbiBhbm90aGVyIHVwZGF0ZSBtZXNzYWdlIHRoYXQgZG9lc24ndCBleGlzdCB5ZXRcbiAgICAgICAgICAgIHVwZGF0ZU1pc3NpbmdTdigvKiogQHR5cGUge251bWJlcn0gKi8gKG1pc3NpbmcpLCBnZXRTdGF0ZShzdG9yZSwgbWlzc2luZykpXG4gICAgICAgICAgICBhZGRTdGFja1RvUmVzdFNTKClcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RhY2tIZWFkID0gc3RydWN0UmVmcy5yZWZzW3N0cnVjdFJlZnMuaSsrXVxuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAob2Zmc2V0ID09PSAwIHx8IG9mZnNldCA8IHN0YWNrSGVhZC5sZW5ndGgpIHtcbiAgICAgICAgICAvLyBhbGwgZmluZSwgYXBwbHkgdGhlIHN0YWNraGVhZFxuICAgICAgICAgIHN0YWNrSGVhZC5pbnRlZ3JhdGUodHJhbnNhY3Rpb24sIG9mZnNldClcbiAgICAgICAgICBzdGF0ZS5zZXQoc3RhY2tIZWFkLmlkLmNsaWVudCwgc3RhY2tIZWFkLmlkLmNsb2NrICsgc3RhY2tIZWFkLmxlbmd0aClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBpdGVyYXRlIHRvIG5leHQgc3RhY2tIZWFkXG4gICAgaWYgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgIHN0YWNrSGVhZCA9IC8qKiBAdHlwZSB7R0N8SXRlbX0gKi8gKHN0YWNrLnBvcCgpKVxuICAgIH0gZWxzZSBpZiAoY3VyU3RydWN0c1RhcmdldCAhPT0gbnVsbCAmJiBjdXJTdHJ1Y3RzVGFyZ2V0LmkgPCBjdXJTdHJ1Y3RzVGFyZ2V0LnJlZnMubGVuZ3RoKSB7XG4gICAgICBzdGFja0hlYWQgPSAvKiogQHR5cGUge0dDfEl0ZW19ICovIChjdXJTdHJ1Y3RzVGFyZ2V0LnJlZnNbY3VyU3RydWN0c1RhcmdldC5pKytdKVxuICAgIH0gZWxzZSB7XG4gICAgICBjdXJTdHJ1Y3RzVGFyZ2V0ID0gZ2V0TmV4dFN0cnVjdFRhcmdldCgpXG4gICAgICBpZiAoY3VyU3RydWN0c1RhcmdldCA9PT0gbnVsbCkge1xuICAgICAgICAvLyB3ZSBhcmUgZG9uZSFcbiAgICAgICAgYnJlYWtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YWNrSGVhZCA9IC8qKiBAdHlwZSB7R0N8SXRlbX0gKi8gKGN1clN0cnVjdHNUYXJnZXQucmVmc1tjdXJTdHJ1Y3RzVGFyZ2V0LmkrK10pXG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChyZXN0U3RydWN0cy5jbGllbnRzLnNpemUgPiAwKSB7XG4gICAgY29uc3QgZW5jb2RlciA9IG5ldyBVcGRhdGVFbmNvZGVyVjIoKVxuICAgIHdyaXRlQ2xpZW50c1N0cnVjdHMoZW5jb2RlciwgcmVzdFN0cnVjdHMsIG5ldyBNYXAoKSlcbiAgICAvLyB3cml0ZSBlbXB0eSBkZWxldGVzZXRcbiAgICAvLyB3cml0ZURlbGV0ZVNldChlbmNvZGVyLCBuZXcgRGVsZXRlU2V0KCkpXG4gICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIucmVzdEVuY29kZXIsIDApIC8vID0+IG5vIG5lZWQgZm9yIGFuIGV4dHJhIGZ1bmN0aW9uIGNhbGwsIGp1c3Qgd3JpdGUgMCBkZWxldGVzXG4gICAgcmV0dXJuIHsgbWlzc2luZzogbWlzc2luZ1NWLCB1cGRhdGU6IGVuY29kZXIudG9VaW50OEFycmF5KCkgfVxuICB9XG4gIHJldHVybiBudWxsXG59XG5cbi8qKlxuICogQHBhcmFtIHtVcGRhdGVFbmNvZGVyVjEgfCBVcGRhdGVFbmNvZGVyVjJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3Qgd3JpdGVTdHJ1Y3RzRnJvbVRyYW5zYWN0aW9uID0gKGVuY29kZXIsIHRyYW5zYWN0aW9uKSA9PiB3cml0ZUNsaWVudHNTdHJ1Y3RzKGVuY29kZXIsIHRyYW5zYWN0aW9uLmRvYy5zdG9yZSwgdHJhbnNhY3Rpb24uYmVmb3JlU3RhdGUpXG5cbi8qKlxuICogUmVhZCBhbmQgYXBwbHkgYSBkb2N1bWVudCB1cGRhdGUuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBoYXMgdGhlIHNhbWUgZWZmZWN0IGFzIGBhcHBseVVwZGF0ZWAgYnV0IGFjY2VwdHMgYW4gZGVjb2Rlci5cbiAqXG4gKiBAcGFyYW0ge2RlY29kaW5nLkRlY29kZXJ9IGRlY29kZXJcbiAqIEBwYXJhbSB7RG9jfSB5ZG9jXG4gKiBAcGFyYW0ge2FueX0gW3RyYW5zYWN0aW9uT3JpZ2luXSBUaGlzIHdpbGwgYmUgc3RvcmVkIG9uIGB0cmFuc2FjdGlvbi5vcmlnaW5gIGFuZCBgLm9uKCd1cGRhdGUnLCAodXBkYXRlLCBvcmlnaW4pKWBcbiAqIEBwYXJhbSB7VXBkYXRlRGVjb2RlclYxIHwgVXBkYXRlRGVjb2RlclYyfSBbc3RydWN0RGVjb2Rlcl1cbiAqXG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IHJlYWRVcGRhdGVWMiA9IChkZWNvZGVyLCB5ZG9jLCB0cmFuc2FjdGlvbk9yaWdpbiwgc3RydWN0RGVjb2RlciA9IG5ldyBVcGRhdGVEZWNvZGVyVjIoZGVjb2RlcikpID0+XG4gIHRyYW5zYWN0KHlkb2MsIHRyYW5zYWN0aW9uID0+IHtcbiAgICAvLyBmb3JjZSB0aGF0IHRyYW5zYWN0aW9uLmxvY2FsIGlzIHNldCB0byBub24tbG9jYWxcbiAgICB0cmFuc2FjdGlvbi5sb2NhbCA9IGZhbHNlXG4gICAgbGV0IHJldHJ5ID0gZmFsc2VcbiAgICBjb25zdCBkb2MgPSB0cmFuc2FjdGlvbi5kb2NcbiAgICBjb25zdCBzdG9yZSA9IGRvYy5zdG9yZVxuICAgIC8vIGxldCBzdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpXG4gICAgY29uc3Qgc3MgPSByZWFkQ2xpZW50c1N0cnVjdFJlZnMoc3RydWN0RGVjb2RlciwgZG9jKVxuICAgIC8vIGNvbnNvbGUubG9nKCd0aW1lIHRvIHJlYWQgc3RydWN0czogJywgcGVyZm9ybWFuY2Uubm93KCkgLSBzdGFydCkgLy8gQHRvZG8gcmVtb3ZlXG4gICAgLy8gc3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKVxuICAgIC8vIGNvbnNvbGUubG9nKCd0aW1lIHRvIG1lcmdlOiAnLCBwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0KSAvLyBAdG9kbyByZW1vdmVcbiAgICAvLyBzdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpXG4gICAgY29uc3QgcmVzdFN0cnVjdHMgPSBpbnRlZ3JhdGVTdHJ1Y3RzKHRyYW5zYWN0aW9uLCBzdG9yZSwgc3MpXG4gICAgY29uc3QgcGVuZGluZyA9IHN0b3JlLnBlbmRpbmdTdHJ1Y3RzXG4gICAgaWYgKHBlbmRpbmcpIHtcbiAgICAgIC8vIGNoZWNrIGlmIHdlIGNhbiBhcHBseSBzb21ldGhpbmdcbiAgICAgIGZvciAoY29uc3QgW2NsaWVudCwgY2xvY2tdIG9mIHBlbmRpbmcubWlzc2luZykge1xuICAgICAgICBpZiAoY2xvY2sgPCBnZXRTdGF0ZShzdG9yZSwgY2xpZW50KSkge1xuICAgICAgICAgIHJldHJ5ID0gdHJ1ZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChyZXN0U3RydWN0cykge1xuICAgICAgICAvLyBtZXJnZSByZXN0U3RydWN0cyBpbnRvIHN0b3JlLnBlbmRpbmdcbiAgICAgICAgZm9yIChjb25zdCBbY2xpZW50LCBjbG9ja10gb2YgcmVzdFN0cnVjdHMubWlzc2luZykge1xuICAgICAgICAgIGNvbnN0IG1jbG9jayA9IHBlbmRpbmcubWlzc2luZy5nZXQoY2xpZW50KVxuICAgICAgICAgIGlmIChtY2xvY2sgPT0gbnVsbCB8fCBtY2xvY2sgPiBjbG9jaykge1xuICAgICAgICAgICAgcGVuZGluZy5taXNzaW5nLnNldChjbGllbnQsIGNsb2NrKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwZW5kaW5nLnVwZGF0ZSA9IG1lcmdlVXBkYXRlc1YyKFtwZW5kaW5nLnVwZGF0ZSwgcmVzdFN0cnVjdHMudXBkYXRlXSlcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RvcmUucGVuZGluZ1N0cnVjdHMgPSByZXN0U3RydWN0c1xuICAgIH1cbiAgICAvLyBjb25zb2xlLmxvZygndGltZSB0byBpbnRlZ3JhdGU6ICcsIHBlcmZvcm1hbmNlLm5vdygpIC0gc3RhcnQpIC8vIEB0b2RvIHJlbW92ZVxuICAgIC8vIHN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KClcbiAgICBjb25zdCBkc1Jlc3QgPSByZWFkQW5kQXBwbHlEZWxldGVTZXQoc3RydWN0RGVjb2RlciwgdHJhbnNhY3Rpb24sIHN0b3JlKVxuICAgIGlmIChzdG9yZS5wZW5kaW5nRHMpIHtcbiAgICAgIC8vIEB0b2RvIHdlIGNvdWxkIG1ha2UgYSBsb3dlci1ib3VuZCBzdGF0ZS12ZWN0b3IgY2hlY2sgYXMgd2UgZG8gYWJvdmVcbiAgICAgIGNvbnN0IHBlbmRpbmdEU1VwZGF0ZSA9IG5ldyBVcGRhdGVEZWNvZGVyVjIoZGVjb2RpbmcuY3JlYXRlRGVjb2RlcihzdG9yZS5wZW5kaW5nRHMpKVxuICAgICAgZGVjb2RpbmcucmVhZFZhclVpbnQocGVuZGluZ0RTVXBkYXRlLnJlc3REZWNvZGVyKSAvLyByZWFkIDAgc3RydWN0cywgYmVjYXVzZSB3ZSBvbmx5IGVuY29kZSBkZWxldGVzIGluIHBlbmRpbmdkc3VwZGF0ZVxuICAgICAgY29uc3QgZHNSZXN0MiA9IHJlYWRBbmRBcHBseURlbGV0ZVNldChwZW5kaW5nRFNVcGRhdGUsIHRyYW5zYWN0aW9uLCBzdG9yZSlcbiAgICAgIGlmIChkc1Jlc3QgJiYgZHNSZXN0Mikge1xuICAgICAgICAvLyBjYXNlIDE6IGRzMSAhPSBudWxsICYmIGRzMiAhPSBudWxsXG4gICAgICAgIHN0b3JlLnBlbmRpbmdEcyA9IG1lcmdlVXBkYXRlc1YyKFtkc1Jlc3QsIGRzUmVzdDJdKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gY2FzZSAyOiBkczEgIT0gbnVsbFxuICAgICAgICAvLyBjYXNlIDM6IGRzMiAhPSBudWxsXG4gICAgICAgIC8vIGNhc2UgNDogZHMxID09IG51bGwgJiYgZHMyID09IG51bGxcbiAgICAgICAgc3RvcmUucGVuZGluZ0RzID0gZHNSZXN0IHx8IGRzUmVzdDJcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRWl0aGVyIGRzUmVzdCA9PSBudWxsICYmIHBlbmRpbmdEcyA9PSBudWxsIE9SIGRzUmVzdCAhPSBudWxsXG4gICAgICBzdG9yZS5wZW5kaW5nRHMgPSBkc1Jlc3RcbiAgICB9XG4gICAgLy8gY29uc29sZS5sb2coJ3RpbWUgdG8gY2xlYW51cDogJywgcGVyZm9ybWFuY2Uubm93KCkgLSBzdGFydCkgLy8gQHRvZG8gcmVtb3ZlXG4gICAgLy8gc3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKVxuXG4gICAgLy8gY29uc29sZS5sb2coJ3RpbWUgdG8gcmVzdW1lIGRlbGV0ZSByZWFkZXJzOiAnLCBwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0KSAvLyBAdG9kbyByZW1vdmVcbiAgICAvLyBzdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpXG4gICAgaWYgKHJldHJ5KSB7XG4gICAgICBjb25zdCB1cGRhdGUgPSAvKiogQHR5cGUge3t1cGRhdGU6IFVpbnQ4QXJyYXl9fSAqLyAoc3RvcmUucGVuZGluZ1N0cnVjdHMpLnVwZGF0ZVxuICAgICAgc3RvcmUucGVuZGluZ1N0cnVjdHMgPSBudWxsXG4gICAgICBhcHBseVVwZGF0ZVYyKHRyYW5zYWN0aW9uLmRvYywgdXBkYXRlKVxuICAgIH1cbiAgfSwgdHJhbnNhY3Rpb25PcmlnaW4sIGZhbHNlKVxuXG4vKipcbiAqIFJlYWQgYW5kIGFwcGx5IGEgZG9jdW1lbnQgdXBkYXRlLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gaGFzIHRoZSBzYW1lIGVmZmVjdCBhcyBgYXBwbHlVcGRhdGVgIGJ1dCBhY2NlcHRzIGFuIGRlY29kZXIuXG4gKlxuICogQHBhcmFtIHtkZWNvZGluZy5EZWNvZGVyfSBkZWNvZGVyXG4gKiBAcGFyYW0ge0RvY30geWRvY1xuICogQHBhcmFtIHthbnl9IFt0cmFuc2FjdGlvbk9yaWdpbl0gVGhpcyB3aWxsIGJlIHN0b3JlZCBvbiBgdHJhbnNhY3Rpb24ub3JpZ2luYCBhbmQgYC5vbigndXBkYXRlJywgKHVwZGF0ZSwgb3JpZ2luKSlgXG4gKlxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCByZWFkVXBkYXRlID0gKGRlY29kZXIsIHlkb2MsIHRyYW5zYWN0aW9uT3JpZ2luKSA9PiByZWFkVXBkYXRlVjIoZGVjb2RlciwgeWRvYywgdHJhbnNhY3Rpb25PcmlnaW4sIG5ldyBVcGRhdGVEZWNvZGVyVjEoZGVjb2RlcikpXG5cbi8qKlxuICogQXBwbHkgYSBkb2N1bWVudCB1cGRhdGUgY3JlYXRlZCBieSwgZm9yIGV4YW1wbGUsIGB5Lm9uKCd1cGRhdGUnLCB1cGRhdGUgPT4gLi4pYCBvciBgdXBkYXRlID0gZW5jb2RlU3RhdGVBc1VwZGF0ZSgpYC5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGhhcyB0aGUgc2FtZSBlZmZlY3QgYXMgYHJlYWRVcGRhdGVgIGJ1dCBhY2NlcHRzIGFuIFVpbnQ4QXJyYXkgaW5zdGVhZCBvZiBhIERlY29kZXIuXG4gKlxuICogQHBhcmFtIHtEb2N9IHlkb2NcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gdXBkYXRlXG4gKiBAcGFyYW0ge2FueX0gW3RyYW5zYWN0aW9uT3JpZ2luXSBUaGlzIHdpbGwgYmUgc3RvcmVkIG9uIGB0cmFuc2FjdGlvbi5vcmlnaW5gIGFuZCBgLm9uKCd1cGRhdGUnLCAodXBkYXRlLCBvcmlnaW4pKWBcbiAqIEBwYXJhbSB7dHlwZW9mIFVwZGF0ZURlY29kZXJWMSB8IHR5cGVvZiBVcGRhdGVEZWNvZGVyVjJ9IFtZRGVjb2Rlcl1cbiAqXG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IGFwcGx5VXBkYXRlVjIgPSAoeWRvYywgdXBkYXRlLCB0cmFuc2FjdGlvbk9yaWdpbiwgWURlY29kZXIgPSBVcGRhdGVEZWNvZGVyVjIpID0+IHtcbiAgY29uc3QgZGVjb2RlciA9IGRlY29kaW5nLmNyZWF0ZURlY29kZXIodXBkYXRlKVxuICByZWFkVXBkYXRlVjIoZGVjb2RlciwgeWRvYywgdHJhbnNhY3Rpb25PcmlnaW4sIG5ldyBZRGVjb2RlcihkZWNvZGVyKSlcbn1cblxuLyoqXG4gKiBBcHBseSBhIGRvY3VtZW50IHVwZGF0ZSBjcmVhdGVkIGJ5LCBmb3IgZXhhbXBsZSwgYHkub24oJ3VwZGF0ZScsIHVwZGF0ZSA9PiAuLilgIG9yIGB1cGRhdGUgPSBlbmNvZGVTdGF0ZUFzVXBkYXRlKClgLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gaGFzIHRoZSBzYW1lIGVmZmVjdCBhcyBgcmVhZFVwZGF0ZWAgYnV0IGFjY2VwdHMgYW4gVWludDhBcnJheSBpbnN0ZWFkIG9mIGEgRGVjb2Rlci5cbiAqXG4gKiBAcGFyYW0ge0RvY30geWRvY1xuICogQHBhcmFtIHtVaW50OEFycmF5fSB1cGRhdGVcbiAqIEBwYXJhbSB7YW55fSBbdHJhbnNhY3Rpb25PcmlnaW5dIFRoaXMgd2lsbCBiZSBzdG9yZWQgb24gYHRyYW5zYWN0aW9uLm9yaWdpbmAgYW5kIGAub24oJ3VwZGF0ZScsICh1cGRhdGUsIG9yaWdpbikpYFxuICpcbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgYXBwbHlVcGRhdGUgPSAoeWRvYywgdXBkYXRlLCB0cmFuc2FjdGlvbk9yaWdpbikgPT4gYXBwbHlVcGRhdGVWMih5ZG9jLCB1cGRhdGUsIHRyYW5zYWN0aW9uT3JpZ2luLCBVcGRhdGVEZWNvZGVyVjEpXG5cbi8qKlxuICogV3JpdGUgYWxsIHRoZSBkb2N1bWVudCBhcyBhIHNpbmdsZSB1cGRhdGUgbWVzc2FnZS4gSWYgeW91IHNwZWNpZnkgdGhlIHN0YXRlIG9mIHRoZSByZW1vdGUgY2xpZW50IChgdGFyZ2V0U3RhdGVWZWN0b3JgKSBpdCB3aWxsXG4gKiBvbmx5IHdyaXRlIHRoZSBvcGVyYXRpb25zIHRoYXQgYXJlIG1pc3NpbmcuXG4gKlxuICogQHBhcmFtIHtVcGRhdGVFbmNvZGVyVjEgfCBVcGRhdGVFbmNvZGVyVjJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7RG9jfSBkb2NcbiAqIEBwYXJhbSB7TWFwPG51bWJlcixudW1iZXI+fSBbdGFyZ2V0U3RhdGVWZWN0b3JdIFRoZSBzdGF0ZSBvZiB0aGUgdGFyZ2V0IHRoYXQgcmVjZWl2ZXMgdGhlIHVwZGF0ZS4gTGVhdmUgZW1wdHkgdG8gd3JpdGUgYWxsIGtub3duIHN0cnVjdHNcbiAqXG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IHdyaXRlU3RhdGVBc1VwZGF0ZSA9IChlbmNvZGVyLCBkb2MsIHRhcmdldFN0YXRlVmVjdG9yID0gbmV3IE1hcCgpKSA9PiB7XG4gIHdyaXRlQ2xpZW50c1N0cnVjdHMoZW5jb2RlciwgZG9jLnN0b3JlLCB0YXJnZXRTdGF0ZVZlY3RvcilcbiAgd3JpdGVEZWxldGVTZXQoZW5jb2RlciwgY3JlYXRlRGVsZXRlU2V0RnJvbVN0cnVjdFN0b3JlKGRvYy5zdG9yZSkpXG59XG5cbi8qKlxuICogV3JpdGUgYWxsIHRoZSBkb2N1bWVudCBhcyBhIHNpbmdsZSB1cGRhdGUgbWVzc2FnZSB0aGF0IGNhbiBiZSBhcHBsaWVkIG9uIHRoZSByZW1vdGUgZG9jdW1lbnQuIElmIHlvdSBzcGVjaWZ5IHRoZSBzdGF0ZSBvZiB0aGUgcmVtb3RlIGNsaWVudCAoYHRhcmdldFN0YXRlYCkgaXQgd2lsbFxuICogb25seSB3cml0ZSB0aGUgb3BlcmF0aW9ucyB0aGF0IGFyZSBtaXNzaW5nLlxuICpcbiAqIFVzZSBgd3JpdGVTdGF0ZUFzVXBkYXRlYCBpbnN0ZWFkIGlmIHlvdSBhcmUgd29ya2luZyB3aXRoIGxpYjAvZW5jb2RpbmcuanMjRW5jb2RlclxuICpcbiAqIEBwYXJhbSB7RG9jfSBkb2NcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gW2VuY29kZWRUYXJnZXRTdGF0ZVZlY3Rvcl0gVGhlIHN0YXRlIG9mIHRoZSB0YXJnZXQgdGhhdCByZWNlaXZlcyB0aGUgdXBkYXRlLiBMZWF2ZSBlbXB0eSB0byB3cml0ZSBhbGwga25vd24gc3RydWN0c1xuICogQHBhcmFtIHtVcGRhdGVFbmNvZGVyVjEgfCBVcGRhdGVFbmNvZGVyVjJ9IFtlbmNvZGVyXVxuICogQHJldHVybiB7VWludDhBcnJheX1cbiAqXG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IGVuY29kZVN0YXRlQXNVcGRhdGVWMiA9IChkb2MsIGVuY29kZWRUYXJnZXRTdGF0ZVZlY3RvciA9IG5ldyBVaW50OEFycmF5KFswXSksIGVuY29kZXIgPSBuZXcgVXBkYXRlRW5jb2RlclYyKCkpID0+IHtcbiAgY29uc3QgdGFyZ2V0U3RhdGVWZWN0b3IgPSBkZWNvZGVTdGF0ZVZlY3RvcihlbmNvZGVkVGFyZ2V0U3RhdGVWZWN0b3IpXG4gIHdyaXRlU3RhdGVBc1VwZGF0ZShlbmNvZGVyLCBkb2MsIHRhcmdldFN0YXRlVmVjdG9yKVxuICBjb25zdCB1cGRhdGVzID0gW2VuY29kZXIudG9VaW50OEFycmF5KCldXG4gIC8vIGFsc28gYWRkIHRoZSBwZW5kaW5nIHVwZGF0ZXMgKGlmIHRoZXJlIGFyZSBhbnkpXG4gIGlmIChkb2Muc3RvcmUucGVuZGluZ0RzKSB7XG4gICAgdXBkYXRlcy5wdXNoKGRvYy5zdG9yZS5wZW5kaW5nRHMpXG4gIH1cbiAgaWYgKGRvYy5zdG9yZS5wZW5kaW5nU3RydWN0cykge1xuICAgIHVwZGF0ZXMucHVzaChkaWZmVXBkYXRlVjIoZG9jLnN0b3JlLnBlbmRpbmdTdHJ1Y3RzLnVwZGF0ZSwgZW5jb2RlZFRhcmdldFN0YXRlVmVjdG9yKSlcbiAgfVxuICBpZiAodXBkYXRlcy5sZW5ndGggPiAxKSB7XG4gICAgaWYgKGVuY29kZXIuY29uc3RydWN0b3IgPT09IFVwZGF0ZUVuY29kZXJWMSkge1xuICAgICAgcmV0dXJuIG1lcmdlVXBkYXRlcyh1cGRhdGVzLm1hcCgodXBkYXRlLCBpKSA9PiBpID09PSAwID8gdXBkYXRlIDogY29udmVydFVwZGF0ZUZvcm1hdFYyVG9WMSh1cGRhdGUpKSlcbiAgICB9IGVsc2UgaWYgKGVuY29kZXIuY29uc3RydWN0b3IgPT09IFVwZGF0ZUVuY29kZXJWMikge1xuICAgICAgcmV0dXJuIG1lcmdlVXBkYXRlc1YyKHVwZGF0ZXMpXG4gICAgfVxuICB9XG4gIHJldHVybiB1cGRhdGVzWzBdXG59XG5cbi8qKlxuICogV3JpdGUgYWxsIHRoZSBkb2N1bWVudCBhcyBhIHNpbmdsZSB1cGRhdGUgbWVzc2FnZSB0aGF0IGNhbiBiZSBhcHBsaWVkIG9uIHRoZSByZW1vdGUgZG9jdW1lbnQuIElmIHlvdSBzcGVjaWZ5IHRoZSBzdGF0ZSBvZiB0aGUgcmVtb3RlIGNsaWVudCAoYHRhcmdldFN0YXRlYCkgaXQgd2lsbFxuICogb25seSB3cml0ZSB0aGUgb3BlcmF0aW9ucyB0aGF0IGFyZSBtaXNzaW5nLlxuICpcbiAqIFVzZSBgd3JpdGVTdGF0ZUFzVXBkYXRlYCBpbnN0ZWFkIGlmIHlvdSBhcmUgd29ya2luZyB3aXRoIGxpYjAvZW5jb2RpbmcuanMjRW5jb2RlclxuICpcbiAqIEBwYXJhbSB7RG9jfSBkb2NcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gW2VuY29kZWRUYXJnZXRTdGF0ZVZlY3Rvcl0gVGhlIHN0YXRlIG9mIHRoZSB0YXJnZXQgdGhhdCByZWNlaXZlcyB0aGUgdXBkYXRlLiBMZWF2ZSBlbXB0eSB0byB3cml0ZSBhbGwga25vd24gc3RydWN0c1xuICogQHJldHVybiB7VWludDhBcnJheX1cbiAqXG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IGVuY29kZVN0YXRlQXNVcGRhdGUgPSAoZG9jLCBlbmNvZGVkVGFyZ2V0U3RhdGVWZWN0b3IpID0+IGVuY29kZVN0YXRlQXNVcGRhdGVWMihkb2MsIGVuY29kZWRUYXJnZXRTdGF0ZVZlY3RvciwgbmV3IFVwZGF0ZUVuY29kZXJWMSgpKVxuXG4vKipcbiAqIFJlYWQgc3RhdGUgdmVjdG9yIGZyb20gRGVjb2RlciBhbmQgcmV0dXJuIGFzIE1hcFxuICpcbiAqIEBwYXJhbSB7RFNEZWNvZGVyVjEgfCBEU0RlY29kZXJWMn0gZGVjb2RlclxuICogQHJldHVybiB7TWFwPG51bWJlcixudW1iZXI+fSBNYXBzIGBjbGllbnRgIHRvIHRoZSBudW1iZXIgbmV4dCBleHBlY3RlZCBgY2xvY2tgIGZyb20gdGhhdCBjbGllbnQuXG4gKlxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCByZWFkU3RhdGVWZWN0b3IgPSBkZWNvZGVyID0+IHtcbiAgY29uc3Qgc3MgPSBuZXcgTWFwKClcbiAgY29uc3Qgc3NMZW5ndGggPSBkZWNvZGluZy5yZWFkVmFyVWludChkZWNvZGVyLnJlc3REZWNvZGVyKVxuICBmb3IgKGxldCBpID0gMDsgaSA8IHNzTGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjbGllbnQgPSBkZWNvZGluZy5yZWFkVmFyVWludChkZWNvZGVyLnJlc3REZWNvZGVyKVxuICAgIGNvbnN0IGNsb2NrID0gZGVjb2RpbmcucmVhZFZhclVpbnQoZGVjb2Rlci5yZXN0RGVjb2RlcilcbiAgICBzcy5zZXQoY2xpZW50LCBjbG9jaylcbiAgfVxuICByZXR1cm4gc3Ncbn1cblxuLyoqXG4gKiBSZWFkIGRlY29kZWRTdGF0ZSBhbmQgcmV0dXJuIFN0YXRlIGFzIE1hcC5cbiAqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGRlY29kZWRTdGF0ZVxuICogQHJldHVybiB7TWFwPG51bWJlcixudW1iZXI+fSBNYXBzIGBjbGllbnRgIHRvIHRoZSBudW1iZXIgbmV4dCBleHBlY3RlZCBgY2xvY2tgIGZyb20gdGhhdCBjbGllbnQuXG4gKlxuICogQGZ1bmN0aW9uXG4gKi9cbi8vIGV4cG9ydCBjb25zdCBkZWNvZGVTdGF0ZVZlY3RvclYyID0gZGVjb2RlZFN0YXRlID0+IHJlYWRTdGF0ZVZlY3RvcihuZXcgRFNEZWNvZGVyVjIoZGVjb2RpbmcuY3JlYXRlRGVjb2RlcihkZWNvZGVkU3RhdGUpKSlcblxuLyoqXG4gKiBSZWFkIGRlY29kZWRTdGF0ZSBhbmQgcmV0dXJuIFN0YXRlIGFzIE1hcC5cbiAqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGRlY29kZWRTdGF0ZVxuICogQHJldHVybiB7TWFwPG51bWJlcixudW1iZXI+fSBNYXBzIGBjbGllbnRgIHRvIHRoZSBudW1iZXIgbmV4dCBleHBlY3RlZCBgY2xvY2tgIGZyb20gdGhhdCBjbGllbnQuXG4gKlxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBkZWNvZGVTdGF0ZVZlY3RvciA9IGRlY29kZWRTdGF0ZSA9PiByZWFkU3RhdGVWZWN0b3IobmV3IERTRGVjb2RlclYxKGRlY29kaW5nLmNyZWF0ZURlY29kZXIoZGVjb2RlZFN0YXRlKSkpXG5cbi8qKlxuICogQHBhcmFtIHtEU0VuY29kZXJWMSB8IERTRW5jb2RlclYyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge01hcDxudW1iZXIsbnVtYmVyPn0gc3ZcbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3Qgd3JpdGVTdGF0ZVZlY3RvciA9IChlbmNvZGVyLCBzdikgPT4ge1xuICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2Rlci5yZXN0RW5jb2Rlciwgc3Yuc2l6ZSlcbiAgYXJyYXkuZnJvbShzdi5lbnRyaWVzKCkpLnNvcnQoKGEsIGIpID0+IGJbMF0gLSBhWzBdKS5mb3JFYWNoKChbY2xpZW50LCBjbG9ja10pID0+IHtcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2Rlci5yZXN0RW5jb2RlciwgY2xpZW50KSAvLyBAdG9kbyB1c2UgYSBzcGVjaWFsIGNsaWVudCBkZWNvZGVyIHRoYXQgaXMgYmFzZWQgb24gbWFwcGluZ1xuICAgIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyLnJlc3RFbmNvZGVyLCBjbG9jaylcbiAgfSlcbiAgcmV0dXJuIGVuY29kZXJcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0RTRW5jb2RlclYxIHwgRFNFbmNvZGVyVjJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7RG9jfSBkb2NcbiAqXG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IHdyaXRlRG9jdW1lbnRTdGF0ZVZlY3RvciA9IChlbmNvZGVyLCBkb2MpID0+IHdyaXRlU3RhdGVWZWN0b3IoZW5jb2RlciwgZ2V0U3RhdGVWZWN0b3IoZG9jLnN0b3JlKSlcblxuLyoqXG4gKiBFbmNvZGUgU3RhdGUgYXMgVWludDhBcnJheS5cbiAqXG4gKiBAcGFyYW0ge0RvY3xNYXA8bnVtYmVyLG51bWJlcj59IGRvY1xuICogQHBhcmFtIHtEU0VuY29kZXJWMSB8IERTRW5jb2RlclYyfSBbZW5jb2Rlcl1cbiAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9XG4gKlxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBlbmNvZGVTdGF0ZVZlY3RvclYyID0gKGRvYywgZW5jb2RlciA9IG5ldyBEU0VuY29kZXJWMigpKSA9PiB7XG4gIGlmIChkb2MgaW5zdGFuY2VvZiBNYXApIHtcbiAgICB3cml0ZVN0YXRlVmVjdG9yKGVuY29kZXIsIGRvYylcbiAgfSBlbHNlIHtcbiAgICB3cml0ZURvY3VtZW50U3RhdGVWZWN0b3IoZW5jb2RlciwgZG9jKVxuICB9XG4gIHJldHVybiBlbmNvZGVyLnRvVWludDhBcnJheSgpXG59XG5cbi8qKlxuICogRW5jb2RlIFN0YXRlIGFzIFVpbnQ4QXJyYXkuXG4gKlxuICogQHBhcmFtIHtEb2N8TWFwPG51bWJlcixudW1iZXI+fSBkb2NcbiAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9XG4gKlxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBlbmNvZGVTdGF0ZVZlY3RvciA9IGRvYyA9PiBlbmNvZGVTdGF0ZVZlY3RvclYyKGRvYywgbmV3IERTRW5jb2RlclYxKCkpXG4iLCAiaW1wb3J0ICogYXMgZiBmcm9tICdsaWIwL2Z1bmN0aW9uJ1xuXG4vKipcbiAqIEdlbmVyYWwgZXZlbnQgaGFuZGxlciBpbXBsZW1lbnRhdGlvbi5cbiAqXG4gKiBAdGVtcGxhdGUgQVJHMCwgQVJHMVxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBjbGFzcyBFdmVudEhhbmRsZXIge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge0FycmF5PGZ1bmN0aW9uKEFSRzAsIEFSRzEpOnZvaWQ+fVxuICAgICAqL1xuICAgIHRoaXMubCA9IFtdXG4gIH1cbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgQVJHMCxBUkcxXG4gKiBAcmV0dXJucyB7RXZlbnRIYW5kbGVyPEFSRzAsQVJHMT59XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgY3JlYXRlRXZlbnRIYW5kbGVyID0gKCkgPT4gbmV3IEV2ZW50SGFuZGxlcigpXG5cbi8qKlxuICogQWRkcyBhbiBldmVudCBsaXN0ZW5lciB0aGF0IGlzIGNhbGxlZCB3aGVuXG4gKiB7QGxpbmsgRXZlbnRIYW5kbGVyI2NhbGxFdmVudExpc3RlbmVyc30gaXMgY2FsbGVkLlxuICpcbiAqIEB0ZW1wbGF0ZSBBUkcwLEFSRzFcbiAqIEBwYXJhbSB7RXZlbnRIYW5kbGVyPEFSRzAsQVJHMT59IGV2ZW50SGFuZGxlclxuICogQHBhcmFtIHtmdW5jdGlvbihBUkcwLEFSRzEpOnZvaWR9IGYgVGhlIGV2ZW50IGhhbmRsZXIuXG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgYWRkRXZlbnRIYW5kbGVyTGlzdGVuZXIgPSAoZXZlbnRIYW5kbGVyLCBmKSA9PlxuICBldmVudEhhbmRsZXIubC5wdXNoKGYpXG5cbi8qKlxuICogUmVtb3ZlcyBhbiBldmVudCBsaXN0ZW5lci5cbiAqXG4gKiBAdGVtcGxhdGUgQVJHMCxBUkcxXG4gKiBAcGFyYW0ge0V2ZW50SGFuZGxlcjxBUkcwLEFSRzE+fSBldmVudEhhbmRsZXJcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oQVJHMCxBUkcxKTp2b2lkfSBmIFRoZSBldmVudCBoYW5kbGVyIHRoYXQgd2FzIGFkZGVkIHdpdGhcbiAqICAgICAgICAgICAgICAgICAgICAge0BsaW5rIEV2ZW50SGFuZGxlciNhZGRFdmVudExpc3RlbmVyfVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IHJlbW92ZUV2ZW50SGFuZGxlckxpc3RlbmVyID0gKGV2ZW50SGFuZGxlciwgZikgPT4ge1xuICBjb25zdCBsID0gZXZlbnRIYW5kbGVyLmxcbiAgY29uc3QgbGVuID0gbC5sZW5ndGhcbiAgZXZlbnRIYW5kbGVyLmwgPSBsLmZpbHRlcihnID0+IGYgIT09IGcpXG4gIGlmIChsZW4gPT09IGV2ZW50SGFuZGxlci5sLmxlbmd0aCkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ1t5anNdIFRyaWVkIHRvIHJlbW92ZSBldmVudCBoYW5kbGVyIHRoYXQgZG9lc25cXCd0IGV4aXN0LicpXG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBldmVudCBsaXN0ZW5lcnMuXG4gKiBAdGVtcGxhdGUgQVJHMCxBUkcxXG4gKiBAcGFyYW0ge0V2ZW50SGFuZGxlcjxBUkcwLEFSRzE+fSBldmVudEhhbmRsZXJcbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCByZW1vdmVBbGxFdmVudEhhbmRsZXJMaXN0ZW5lcnMgPSBldmVudEhhbmRsZXIgPT4ge1xuICBldmVudEhhbmRsZXIubC5sZW5ndGggPSAwXG59XG5cbi8qKlxuICogQ2FsbCBhbGwgZXZlbnQgbGlzdGVuZXJzIHRoYXQgd2VyZSBhZGRlZCB2aWFcbiAqIHtAbGluayBFdmVudEhhbmRsZXIjYWRkRXZlbnRMaXN0ZW5lcn0uXG4gKlxuICogQHRlbXBsYXRlIEFSRzAsQVJHMVxuICogQHBhcmFtIHtFdmVudEhhbmRsZXI8QVJHMCxBUkcxPn0gZXZlbnRIYW5kbGVyXG4gKiBAcGFyYW0ge0FSRzB9IGFyZzBcbiAqIEBwYXJhbSB7QVJHMX0gYXJnMVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IGNhbGxFdmVudEhhbmRsZXJMaXN0ZW5lcnMgPSAoZXZlbnRIYW5kbGVyLCBhcmcwLCBhcmcxKSA9PlxuICBmLmNhbGxBbGwoZXZlbnRIYW5kbGVyLmwsIFthcmcwLCBhcmcxXSlcbiIsICJcbmltcG9ydCB7IEFic3RyYWN0VHlwZSB9IGZyb20gJy4uL2ludGVybmFscy5qcycgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG5pbXBvcnQgKiBhcyBkZWNvZGluZyBmcm9tICdsaWIwL2RlY29kaW5nJ1xuaW1wb3J0ICogYXMgZW5jb2RpbmcgZnJvbSAnbGliMC9lbmNvZGluZydcbmltcG9ydCAqIGFzIGVycm9yIGZyb20gJ2xpYjAvZXJyb3InXG5cbmV4cG9ydCBjbGFzcyBJRCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gY2xpZW50IGNsaWVudCBpZFxuICAgKiBAcGFyYW0ge251bWJlcn0gY2xvY2sgdW5pcXVlIHBlciBjbGllbnQgaWQsIGNvbnRpbnVvdXMgbnVtYmVyXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoY2xpZW50LCBjbG9jaykge1xuICAgIC8qKlxuICAgICAqIENsaWVudCBpZFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5jbGllbnQgPSBjbGllbnRcbiAgICAvKipcbiAgICAgKiB1bmlxdWUgcGVyIGNsaWVudCBpZCwgY29udGludW91cyBudW1iZXJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuY2xvY2sgPSBjbG9ja1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtJRCB8IG51bGx9IGFcbiAqIEBwYXJhbSB7SUQgfCBudWxsfSBiXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICpcbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgY29tcGFyZUlEcyA9IChhLCBiKSA9PiBhID09PSBiIHx8IChhICE9PSBudWxsICYmIGIgIT09IG51bGwgJiYgYS5jbGllbnQgPT09IGIuY2xpZW50ICYmIGEuY2xvY2sgPT09IGIuY2xvY2spXG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IGNsaWVudFxuICogQHBhcmFtIHtudW1iZXJ9IGNsb2NrXG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgY3JlYXRlSUQgPSAoY2xpZW50LCBjbG9jaykgPT4gbmV3IElEKGNsaWVudCwgY2xvY2spXG5cbi8qKlxuICogQHBhcmFtIHtlbmNvZGluZy5FbmNvZGVyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge0lEfSBpZFxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IHdyaXRlSUQgPSAoZW5jb2RlciwgaWQpID0+IHtcbiAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIsIGlkLmNsaWVudClcbiAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIsIGlkLmNsb2NrKVxufVxuXG4vKipcbiAqIFJlYWQgSUQuXG4gKiAqIElmIGZpcnN0IHZhclVpbnQgcmVhZCBpcyAweEZGRkZGRiBhIFJvb3RJRCBpcyByZXR1cm5lZC5cbiAqICogT3RoZXJ3aXNlIGFuIElEIGlzIHJldHVybmVkXG4gKlxuICogQHBhcmFtIHtkZWNvZGluZy5EZWNvZGVyfSBkZWNvZGVyXG4gKiBAcmV0dXJuIHtJRH1cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCByZWFkSUQgPSBkZWNvZGVyID0+XG4gIGNyZWF0ZUlEKGRlY29kaW5nLnJlYWRWYXJVaW50KGRlY29kZXIpLCBkZWNvZGluZy5yZWFkVmFyVWludChkZWNvZGVyKSlcblxuLyoqXG4gKiBUaGUgdG9wIHR5cGVzIGFyZSBtYXBwZWQgZnJvbSB5LnNoYXJlLmdldChrZXluYW1lKSA9PiB0eXBlLlxuICogYHR5cGVgIGRvZXMgbm90IHN0b3JlIGFueSBpbmZvcm1hdGlvbiBhYm91dCB0aGUgYGtleW5hbWVgLlxuICogVGhpcyBmdW5jdGlvbiBmaW5kcyB0aGUgY29ycmVjdCBga2V5bmFtZWAgZm9yIGB0eXBlYCBhbmQgdGhyb3dzIG90aGVyd2lzZS5cbiAqXG4gKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxhbnk+fSB0eXBlXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgZmluZFJvb3RUeXBlS2V5ID0gdHlwZSA9PiB7XG4gIC8vIEB0cy1pZ25vcmUgX3kgbXVzdCBiZSBkZWZpbmVkLCBvdGhlcndpc2UgdW5leHBlY3RlZCBjYXNlXG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHR5cGUuZG9jLnNoYXJlLmVudHJpZXMoKSkge1xuICAgIGlmICh2YWx1ZSA9PT0gdHlwZSkge1xuICAgICAgcmV0dXJuIGtleVxuICAgIH1cbiAgfVxuICB0aHJvdyBlcnJvci51bmV4cGVjdGVkQ2FzZSgpXG59XG4iLCAiXG5pbXBvcnQgeyBBYnN0cmFjdFR5cGUsIEl0ZW0gfSBmcm9tICcuLi9pbnRlcm5hbHMuanMnIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuLyoqXG4gKiBDaGVjayBpZiBgcGFyZW50YCBpcyBhIHBhcmVudCBvZiBgY2hpbGRgLlxuICpcbiAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPGFueT59IHBhcmVudFxuICogQHBhcmFtIHtJdGVtfG51bGx9IGNoaWxkXG4gKiBAcmV0dXJuIHtCb29sZWFufSBXaGV0aGVyIGBwYXJlbnRgIGlzIGEgcGFyZW50IG9mIGBjaGlsZGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgaXNQYXJlbnRPZiA9IChwYXJlbnQsIGNoaWxkKSA9PiB7XG4gIHdoaWxlIChjaGlsZCAhPT0gbnVsbCkge1xuICAgIGlmIChjaGlsZC5wYXJlbnQgPT09IHBhcmVudCkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgY2hpbGQgPSAvKiogQHR5cGUge0Fic3RyYWN0VHlwZTxhbnk+fSAqLyAoY2hpbGQucGFyZW50KS5faXRlbVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuIiwgIlxuaW1wb3J0IHtcbiAgQWJzdHJhY3RUeXBlIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbn0gZnJvbSAnLi4vaW50ZXJuYWxzLmpzJ1xuXG4vKipcbiAqIENvbnZlbmllbnQgaGVscGVyIHRvIGxvZyB0eXBlIGluZm9ybWF0aW9uLlxuICpcbiAqIERvIG5vdCB1c2UgaW4gcHJvZHVjdGl2ZSBzeXN0ZW1zIGFzIHRoZSBvdXRwdXQgY2FuIGJlIGltbWVuc2UhXG4gKlxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0gdHlwZVxuICovXG5leHBvcnQgY29uc3QgbG9nVHlwZSA9IHR5cGUgPT4ge1xuICBjb25zdCByZXMgPSBbXVxuICBsZXQgbiA9IHR5cGUuX3N0YXJ0XG4gIHdoaWxlIChuKSB7XG4gICAgcmVzLnB1c2gobilcbiAgICBuID0gbi5yaWdodFxuICB9XG4gIGNvbnNvbGUubG9nKCdDaGlsZHJlbjogJywgcmVzKVxuICBjb25zb2xlLmxvZygnQ2hpbGRyZW4gY29udGVudDogJywgcmVzLmZpbHRlcihtID0+ICFtLmRlbGV0ZWQpLm1hcChtID0+IG0uY29udGVudCkpXG59XG4iLCAiXG5pbXBvcnQge1xuICBZQXJyYXksXG4gIFlNYXAsXG4gIHJlYWREZWxldGVTZXQsXG4gIHdyaXRlRGVsZXRlU2V0LFxuICBjcmVhdGVEZWxldGVTZXQsXG4gIERTRW5jb2RlclYxLCBEU0RlY29kZXJWMSwgSUQsIERlbGV0ZVNldCwgWUFycmF5RXZlbnQsIFRyYW5zYWN0aW9uLCBEb2MgLy8gZXNsaW50LWRpc2FibGUtbGluZVxufSBmcm9tICcuLi9pbnRlcm5hbHMuanMnXG5cbmltcG9ydCAqIGFzIGRlY29kaW5nIGZyb20gJ2xpYjAvZGVjb2RpbmcnXG5cbmltcG9ydCB7IG1lcmdlRGVsZXRlU2V0cywgaXNEZWxldGVkIH0gZnJvbSAnLi9EZWxldGVTZXQuanMnXG5cbmV4cG9ydCBjbGFzcyBQZXJtYW5lbnRVc2VyRGF0YSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0RvY30gZG9jXG4gICAqIEBwYXJhbSB7WU1hcDxhbnk+fSBbc3RvcmVUeXBlXVxuICAgKi9cbiAgY29uc3RydWN0b3IgKGRvYywgc3RvcmVUeXBlID0gZG9jLmdldE1hcCgndXNlcnMnKSkge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtNYXA8c3RyaW5nLERlbGV0ZVNldD59XG4gICAgICovXG4gICAgY29uc3QgZHNzID0gbmV3IE1hcCgpXG4gICAgdGhpcy55dXNlcnMgPSBzdG9yZVR5cGVcbiAgICB0aGlzLmRvYyA9IGRvY1xuICAgIC8qKlxuICAgICAqIE1hcHMgZnJvbSBjbGllbnRpZCB0byB1c2VyRGVzY3JpcHRpb25cbiAgICAgKlxuICAgICAqIEB0eXBlIHtNYXA8bnVtYmVyLHN0cmluZz59XG4gICAgICovXG4gICAgdGhpcy5jbGllbnRzID0gbmV3IE1hcCgpXG4gICAgdGhpcy5kc3MgPSBkc3NcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1lNYXA8YW55Pn0gdXNlclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VyRGVzY3JpcHRpb25cbiAgICAgKi9cbiAgICBjb25zdCBpbml0VXNlciA9ICh1c2VyLCB1c2VyRGVzY3JpcHRpb24pID0+IHtcbiAgICAgIC8qKlxuICAgICAgICogQHR5cGUge1lBcnJheTxVaW50OEFycmF5Pn1cbiAgICAgICAqL1xuICAgICAgY29uc3QgZHMgPSB1c2VyLmdldCgnZHMnKVxuICAgICAgY29uc3QgaWRzID0gdXNlci5nZXQoJ2lkcycpXG4gICAgICBjb25zdCBhZGRDbGllbnRJZCA9IC8qKiBAcGFyYW0ge251bWJlcn0gY2xpZW50aWQgKi8gY2xpZW50aWQgPT4gdGhpcy5jbGllbnRzLnNldChjbGllbnRpZCwgdXNlckRlc2NyaXB0aW9uKVxuICAgICAgZHMub2JzZXJ2ZSgvKiogQHBhcmFtIHtZQXJyYXlFdmVudDxhbnk+fSBldmVudCAqLyBldmVudCA9PiB7XG4gICAgICAgIGV2ZW50LmNoYW5nZXMuYWRkZWQuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICBpdGVtLmNvbnRlbnQuZ2V0Q29udGVudCgpLmZvckVhY2goZW5jb2RlZERzID0+IHtcbiAgICAgICAgICAgIGlmIChlbmNvZGVkRHMgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgICAgICAgIHRoaXMuZHNzLnNldCh1c2VyRGVzY3JpcHRpb24sIG1lcmdlRGVsZXRlU2V0cyhbdGhpcy5kc3MuZ2V0KHVzZXJEZXNjcmlwdGlvbikgfHwgY3JlYXRlRGVsZXRlU2V0KCksIHJlYWREZWxldGVTZXQobmV3IERTRGVjb2RlclYxKGRlY29kaW5nLmNyZWF0ZURlY29kZXIoZW5jb2RlZERzKSkpXSkpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgICB0aGlzLmRzcy5zZXQodXNlckRlc2NyaXB0aW9uLCBtZXJnZURlbGV0ZVNldHMoZHMubWFwKGVuY29kZWREcyA9PiByZWFkRGVsZXRlU2V0KG5ldyBEU0RlY29kZXJWMShkZWNvZGluZy5jcmVhdGVEZWNvZGVyKGVuY29kZWREcykpKSkpKVxuICAgICAgaWRzLm9ic2VydmUoLyoqIEBwYXJhbSB7WUFycmF5RXZlbnQ8YW55Pn0gZXZlbnQgKi8gZXZlbnQgPT5cbiAgICAgICAgZXZlbnQuY2hhbmdlcy5hZGRlZC5mb3JFYWNoKGl0ZW0gPT4gaXRlbS5jb250ZW50LmdldENvbnRlbnQoKS5mb3JFYWNoKGFkZENsaWVudElkKSlcbiAgICAgIClcbiAgICAgIGlkcy5mb3JFYWNoKGFkZENsaWVudElkKVxuICAgIH1cbiAgICAvLyBvYnNlcnZlIHVzZXJzXG4gICAgc3RvcmVUeXBlLm9ic2VydmUoZXZlbnQgPT4ge1xuICAgICAgZXZlbnQua2V5c0NoYW5nZWQuZm9yRWFjaCh1c2VyRGVzY3JpcHRpb24gPT5cbiAgICAgICAgaW5pdFVzZXIoc3RvcmVUeXBlLmdldCh1c2VyRGVzY3JpcHRpb24pLCB1c2VyRGVzY3JpcHRpb24pXG4gICAgICApXG4gICAgfSlcbiAgICAvLyBhZGQgaW50aWFsIGRhdGFcbiAgICBzdG9yZVR5cGUuZm9yRWFjaChpbml0VXNlcilcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0RvY30gZG9jXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjbGllbnRpZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlckRlc2NyaXB0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjb25mXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oVHJhbnNhY3Rpb24sIERlbGV0ZVNldCk6Ym9vbGVhbn0gW2NvbmYuZmlsdGVyXVxuICAgKi9cbiAgc2V0VXNlck1hcHBpbmcgKGRvYywgY2xpZW50aWQsIHVzZXJEZXNjcmlwdGlvbiwgeyBmaWx0ZXIgPSAoKSA9PiB0cnVlIH0gPSB7fSkge1xuICAgIGNvbnN0IHVzZXJzID0gdGhpcy55dXNlcnNcbiAgICBsZXQgdXNlciA9IHVzZXJzLmdldCh1c2VyRGVzY3JpcHRpb24pXG4gICAgaWYgKCF1c2VyKSB7XG4gICAgICB1c2VyID0gbmV3IFlNYXAoKVxuICAgICAgdXNlci5zZXQoJ2lkcycsIG5ldyBZQXJyYXkoKSlcbiAgICAgIHVzZXIuc2V0KCdkcycsIG5ldyBZQXJyYXkoKSlcbiAgICAgIHVzZXJzLnNldCh1c2VyRGVzY3JpcHRpb24sIHVzZXIpXG4gICAgfVxuICAgIHVzZXIuZ2V0KCdpZHMnKS5wdXNoKFtjbGllbnRpZF0pXG4gICAgdXNlcnMub2JzZXJ2ZShfZXZlbnQgPT4ge1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHVzZXJPdmVyd3JpdGUgPSB1c2Vycy5nZXQodXNlckRlc2NyaXB0aW9uKVxuICAgICAgICBpZiAodXNlck92ZXJ3cml0ZSAhPT0gdXNlcikge1xuICAgICAgICAgIC8vIHVzZXIgd2FzIG92ZXJ3cml0dGVuLCBwb3J0IGFsbCBkYXRhIG92ZXIgdG8gdGhlIG5leHQgdXNlciBvYmplY3RcbiAgICAgICAgICAvLyBAdG9kbyBFeHBlcmltZW50IHdpdGggWS5TZXRzIGhlcmVcbiAgICAgICAgICB1c2VyID0gdXNlck92ZXJ3cml0ZVxuICAgICAgICAgIC8vIEB0b2RvIGl0ZXJhdGUgb3ZlciBvbGQgdHlwZVxuICAgICAgICAgIHRoaXMuY2xpZW50cy5mb3JFYWNoKChfdXNlckRlc2NyaXB0aW9uLCBjbGllbnRpZCkgPT4ge1xuICAgICAgICAgICAgaWYgKHVzZXJEZXNjcmlwdGlvbiA9PT0gX3VzZXJEZXNjcmlwdGlvbikge1xuICAgICAgICAgICAgICB1c2VyLmdldCgnaWRzJykucHVzaChbY2xpZW50aWRdKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgICAgY29uc3QgZW5jb2RlciA9IG5ldyBEU0VuY29kZXJWMSgpXG4gICAgICAgICAgY29uc3QgZHMgPSB0aGlzLmRzcy5nZXQodXNlckRlc2NyaXB0aW9uKVxuICAgICAgICAgIGlmIChkcykge1xuICAgICAgICAgICAgd3JpdGVEZWxldGVTZXQoZW5jb2RlciwgZHMpXG4gICAgICAgICAgICB1c2VyLmdldCgnZHMnKS5wdXNoKFtlbmNvZGVyLnRvVWludDhBcnJheSgpXSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIDApXG4gICAgfSlcbiAgICBkb2Mub24oJ2FmdGVyVHJhbnNhY3Rpb24nLCAvKiogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb24gKi8gdHJhbnNhY3Rpb24gPT4ge1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHlkcyA9IHVzZXIuZ2V0KCdkcycpXG4gICAgICAgIGNvbnN0IGRzID0gdHJhbnNhY3Rpb24uZGVsZXRlU2V0XG4gICAgICAgIGlmICh0cmFuc2FjdGlvbi5sb2NhbCAmJiBkcy5jbGllbnRzLnNpemUgPiAwICYmIGZpbHRlcih0cmFuc2FjdGlvbiwgZHMpKSB7XG4gICAgICAgICAgY29uc3QgZW5jb2RlciA9IG5ldyBEU0VuY29kZXJWMSgpXG4gICAgICAgICAgd3JpdGVEZWxldGVTZXQoZW5jb2RlciwgZHMpXG4gICAgICAgICAgeWRzLnB1c2goW2VuY29kZXIudG9VaW50OEFycmF5KCldKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IGNsaWVudGlkXG4gICAqIEByZXR1cm4ge2FueX1cbiAgICovXG4gIGdldFVzZXJCeUNsaWVudElkIChjbGllbnRpZCkge1xuICAgIHJldHVybiB0aGlzLmNsaWVudHMuZ2V0KGNsaWVudGlkKSB8fCBudWxsXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtJRH0gaWRcbiAgICogQHJldHVybiB7c3RyaW5nIHwgbnVsbH1cbiAgICovXG4gIGdldFVzZXJCeURlbGV0ZWRJZCAoaWQpIHtcbiAgICBmb3IgKGNvbnN0IFt1c2VyRGVzY3JpcHRpb24sIGRzXSBvZiB0aGlzLmRzcy5lbnRyaWVzKCkpIHtcbiAgICAgIGlmIChpc0RlbGV0ZWQoZHMsIGlkKSkge1xuICAgICAgICByZXR1cm4gdXNlckRlc2NyaXB0aW9uXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsXG4gIH1cbn1cbiIsICJcbmltcG9ydCB7XG4gIHdyaXRlSUQsXG4gIHJlYWRJRCxcbiAgY29tcGFyZUlEcyxcbiAgZ2V0U3RhdGUsXG4gIGZpbmRSb290VHlwZUtleSxcbiAgSXRlbSxcbiAgY3JlYXRlSUQsXG4gIENvbnRlbnRUeXBlLFxuICBmb2xsb3dSZWRvbmUsXG4gIElELCBEb2MsIEFic3RyYWN0VHlwZSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG59IGZyb20gJy4uL2ludGVybmFscy5qcydcblxuaW1wb3J0ICogYXMgZW5jb2RpbmcgZnJvbSAnbGliMC9lbmNvZGluZydcbmltcG9ydCAqIGFzIGRlY29kaW5nIGZyb20gJ2xpYjAvZGVjb2RpbmcnXG5pbXBvcnQgKiBhcyBlcnJvciBmcm9tICdsaWIwL2Vycm9yJ1xuXG4vKipcbiAqIEEgcmVsYXRpdmUgcG9zaXRpb24gaXMgYmFzZWQgb24gdGhlIFlqcyBtb2RlbCBhbmQgaXMgbm90IGFmZmVjdGVkIGJ5IGRvY3VtZW50IGNoYW5nZXMuXG4gKiBFLmcuIElmIHlvdSBwbGFjZSBhIHJlbGF0aXZlIHBvc2l0aW9uIGJlZm9yZSBhIGNlcnRhaW4gY2hhcmFjdGVyLCBpdCB3aWxsIGFsd2F5cyBwb2ludCB0byB0aGlzIGNoYXJhY3Rlci5cbiAqIElmIHlvdSBwbGFjZSBhIHJlbGF0aXZlIHBvc2l0aW9uIGF0IHRoZSBlbmQgb2YgYSB0eXBlLCBpdCB3aWxsIGFsd2F5cyBwb2ludCB0byB0aGUgZW5kIG9mIHRoZSB0eXBlLlxuICpcbiAqIEEgbnVtZXJpYyBwb3NpdGlvbiBpcyBvZnRlbiB1bnN1aXRlZCBmb3IgdXNlciBzZWxlY3Rpb25zLCBiZWNhdXNlIGl0IGRvZXMgbm90IGNoYW5nZSB3aGVuIGNvbnRlbnQgaXMgaW5zZXJ0ZWRcbiAqIGJlZm9yZSBvciBhZnRlci5cbiAqXG4gKiBgYGBJbnNlcnQoMCwgJ3gnKSgnYXxiYycpID0gJ3hhfGJjJ2BgYCBXaGVyZSB8IGlzIHRoZSByZWxhdGl2ZSBwb3NpdGlvbi5cbiAqXG4gKiBPbmUgb2YgdGhlIHByb3BlcnRpZXMgbXVzdCBiZSBkZWZpbmVkLlxuICpcbiAqIEBleGFtcGxlXG4gKiAgIC8vIEN1cnJlbnQgY3Vyc29yIHBvc2l0aW9uIGlzIGF0IHBvc2l0aW9uIDEwXG4gKiAgIGNvbnN0IHJlbGF0aXZlUG9zaXRpb24gPSBjcmVhdGVSZWxhdGl2ZVBvc2l0aW9uRnJvbUluZGV4KHlUZXh0LCAxMClcbiAqICAgLy8gbW9kaWZ5IHlUZXh0XG4gKiAgIHlUZXh0Lmluc2VydCgwLCAnYWJjJylcbiAqICAgeVRleHQuZGVsZXRlKDMsIDEwKVxuICogICAvLyBDb21wdXRlIHRoZSBjdXJzb3IgcG9zaXRpb25cbiAqICAgY29uc3QgYWJzb2x1dGVQb3NpdGlvbiA9IGNyZWF0ZUFic29sdXRlUG9zaXRpb25Gcm9tUmVsYXRpdmVQb3NpdGlvbih5LCByZWxhdGl2ZVBvc2l0aW9uKVxuICogICBhYnNvbHV0ZVBvc2l0aW9uLnR5cGUgPT09IHlUZXh0IC8vID0+IHRydWVcbiAqICAgY29uc29sZS5sb2coJ2N1cnNvciBsb2NhdGlvbiBpcyAnICsgYWJzb2x1dGVQb3NpdGlvbi5pbmRleCkgLy8gPT4gY3Vyc29yIGxvY2F0aW9uIGlzIDNcbiAqXG4gKi9cbmV4cG9ydCBjbGFzcyBSZWxhdGl2ZVBvc2l0aW9uIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7SUR8bnVsbH0gdHlwZVxuICAgKiBAcGFyYW0ge3N0cmluZ3xudWxsfSB0bmFtZVxuICAgKiBAcGFyYW0ge0lEfG51bGx9IGl0ZW1cbiAgICogQHBhcmFtIHtudW1iZXJ9IGFzc29jXG4gICAqL1xuICBjb25zdHJ1Y3RvciAodHlwZSwgdG5hbWUsIGl0ZW0sIGFzc29jID0gMCkge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtJRHxudWxsfVxuICAgICAqL1xuICAgIHRoaXMudHlwZSA9IHR5cGVcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7c3RyaW5nfG51bGx9XG4gICAgICovXG4gICAgdGhpcy50bmFtZSA9IHRuYW1lXG4gICAgLyoqXG4gICAgICogQHR5cGUge0lEIHwgbnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLml0ZW0gPSBpdGVtXG4gICAgLyoqXG4gICAgICogQSByZWxhdGl2ZSBwb3NpdGlvbiBpcyBhc3NvY2lhdGVkIHRvIGEgc3BlY2lmaWMgY2hhcmFjdGVyLiBCeSBkZWZhdWx0XG4gICAgICogYXNzb2MgPj0gMCwgdGhlIHJlbGF0aXZlIHBvc2l0aW9uIGlzIGFzc29jaWF0ZWQgdG8gdGhlIGNoYXJhY3RlclxuICAgICAqIGFmdGVyIHRoZSBtZWFudCBwb3NpdGlvbi5cbiAgICAgKiBJLmUuIHBvc2l0aW9uIDEgaW4gJ2FiJyBpcyBhc3NvY2lhdGVkIHRvIGNoYXJhY3RlciAnYicuXG4gICAgICpcbiAgICAgKiBJZiBhc3NvYyA8IDAsIHRoZW4gdGhlIHJlbGF0aXZlIHBvc2l0aW9uIGlzIGFzc29jaWF0ZWQgdG8gdGhlIGNhaGFyYWN0ZXJcbiAgICAgKiBiZWZvcmUgdGhlIG1lYW50IHBvc2l0aW9uLlxuICAgICAqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmFzc29jID0gYXNzb2NcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7UmVsYXRpdmVQb3NpdGlvbn0gcnBvc1xuICogQHJldHVybiB7YW55fVxuICovXG5leHBvcnQgY29uc3QgcmVsYXRpdmVQb3NpdGlvblRvSlNPTiA9IHJwb3MgPT4ge1xuICBjb25zdCBqc29uID0ge31cbiAgaWYgKHJwb3MudHlwZSkge1xuICAgIGpzb24udHlwZSA9IHJwb3MudHlwZVxuICB9XG4gIGlmIChycG9zLnRuYW1lKSB7XG4gICAganNvbi50bmFtZSA9IHJwb3MudG5hbWVcbiAgfVxuICBpZiAocnBvcy5pdGVtKSB7XG4gICAganNvbi5pdGVtID0gcnBvcy5pdGVtXG4gIH1cbiAgaWYgKHJwb3MuYXNzb2MgIT0gbnVsbCkge1xuICAgIGpzb24uYXNzb2MgPSBycG9zLmFzc29jXG4gIH1cbiAgcmV0dXJuIGpzb25cbn1cblxuLyoqXG4gKiBAcGFyYW0ge2FueX0ganNvblxuICogQHJldHVybiB7UmVsYXRpdmVQb3NpdGlvbn1cbiAqXG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZVJlbGF0aXZlUG9zaXRpb25Gcm9tSlNPTiA9IGpzb24gPT4gbmV3IFJlbGF0aXZlUG9zaXRpb24oanNvbi50eXBlID09IG51bGwgPyBudWxsIDogY3JlYXRlSUQoanNvbi50eXBlLmNsaWVudCwganNvbi50eXBlLmNsb2NrKSwganNvbi50bmFtZSB8fCBudWxsLCBqc29uLml0ZW0gPT0gbnVsbCA/IG51bGwgOiBjcmVhdGVJRChqc29uLml0ZW0uY2xpZW50LCBqc29uLml0ZW0uY2xvY2spLCBqc29uLmFzc29jID09IG51bGwgPyAwIDoganNvbi5hc3NvYylcblxuZXhwb3J0IGNsYXNzIEFic29sdXRlUG9zaXRpb24ge1xuICAvKipcbiAgICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0gdHlwZVxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAgICogQHBhcmFtIHtudW1iZXJ9IFthc3NvY11cbiAgICovXG4gIGNvbnN0cnVjdG9yICh0eXBlLCBpbmRleCwgYXNzb2MgPSAwKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge0Fic3RyYWN0VHlwZTxhbnk+fVxuICAgICAqL1xuICAgIHRoaXMudHlwZSA9IHR5cGVcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuaW5kZXggPSBpbmRleFxuICAgIHRoaXMuYXNzb2MgPSBhc3NvY1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0gdHlwZVxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gKiBAcGFyYW0ge251bWJlcn0gW2Fzc29jXVxuICpcbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgY3JlYXRlQWJzb2x1dGVQb3NpdGlvbiA9ICh0eXBlLCBpbmRleCwgYXNzb2MgPSAwKSA9PiBuZXcgQWJzb2x1dGVQb3NpdGlvbih0eXBlLCBpbmRleCwgYXNzb2MpXG5cbi8qKlxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0gdHlwZVxuICogQHBhcmFtIHtJRHxudWxsfSBpdGVtXG4gKiBAcGFyYW0ge251bWJlcn0gW2Fzc29jXVxuICpcbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgY3JlYXRlUmVsYXRpdmVQb3NpdGlvbiA9ICh0eXBlLCBpdGVtLCBhc3NvYykgPT4ge1xuICBsZXQgdHlwZWlkID0gbnVsbFxuICBsZXQgdG5hbWUgPSBudWxsXG4gIGlmICh0eXBlLl9pdGVtID09PSBudWxsKSB7XG4gICAgdG5hbWUgPSBmaW5kUm9vdFR5cGVLZXkodHlwZSlcbiAgfSBlbHNlIHtcbiAgICB0eXBlaWQgPSBjcmVhdGVJRCh0eXBlLl9pdGVtLmlkLmNsaWVudCwgdHlwZS5faXRlbS5pZC5jbG9jaylcbiAgfVxuICByZXR1cm4gbmV3IFJlbGF0aXZlUG9zaXRpb24odHlwZWlkLCB0bmFtZSwgaXRlbSwgYXNzb2MpXG59XG5cbi8qKlxuICogQ3JlYXRlIGEgcmVsYXRpdmVQb3NpdGlvbiBiYXNlZCBvbiBhIGFic29sdXRlIHBvc2l0aW9uLlxuICpcbiAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPGFueT59IHR5cGUgVGhlIGJhc2UgdHlwZSAoZS5nLiBZVGV4dCBvciBZQXJyYXkpLlxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBhYnNvbHV0ZSBwb3NpdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbYXNzb2NdXG4gKiBAcmV0dXJuIHtSZWxhdGl2ZVBvc2l0aW9ufVxuICpcbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgY3JlYXRlUmVsYXRpdmVQb3NpdGlvbkZyb21UeXBlSW5kZXggPSAodHlwZSwgaW5kZXgsIGFzc29jID0gMCkgPT4ge1xuICBsZXQgdCA9IHR5cGUuX3N0YXJ0XG4gIGlmIChhc3NvYyA8IDApIHtcbiAgICAvLyBhc3NvY2lhdGVkIHRvIHRoZSBsZWZ0IGNoYXJhY3RlciBvciB0aGUgYmVnaW5uaW5nIG9mIGEgdHlwZSwgaW5jcmVtZW50IGluZGV4IGlmIHBvc3NpYmxlLlxuICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGNyZWF0ZVJlbGF0aXZlUG9zaXRpb24odHlwZSwgbnVsbCwgYXNzb2MpXG4gICAgfVxuICAgIGluZGV4LS1cbiAgfVxuICB3aGlsZSAodCAhPT0gbnVsbCkge1xuICAgIGlmICghdC5kZWxldGVkICYmIHQuY291bnRhYmxlKSB7XG4gICAgICBpZiAodC5sZW5ndGggPiBpbmRleCkge1xuICAgICAgICAvLyBjYXNlIDE6IGZvdW5kIHBvc2l0aW9uIHNvbWV3aGVyZSBpbiB0aGUgbGlua2VkIGxpc3RcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVJlbGF0aXZlUG9zaXRpb24odHlwZSwgY3JlYXRlSUQodC5pZC5jbGllbnQsIHQuaWQuY2xvY2sgKyBpbmRleCksIGFzc29jKVxuICAgICAgfVxuICAgICAgaW5kZXggLT0gdC5sZW5ndGhcbiAgICB9XG4gICAgaWYgKHQucmlnaHQgPT09IG51bGwgJiYgYXNzb2MgPCAwKSB7XG4gICAgICAvLyBsZWZ0LWFzc29jaWF0ZWQgcG9zaXRpb24sIHJldHVybiBsYXN0IGF2YWlsYWJsZSBpZFxuICAgICAgcmV0dXJuIGNyZWF0ZVJlbGF0aXZlUG9zaXRpb24odHlwZSwgdC5sYXN0SWQsIGFzc29jKVxuICAgIH1cbiAgICB0ID0gdC5yaWdodFxuICB9XG4gIHJldHVybiBjcmVhdGVSZWxhdGl2ZVBvc2l0aW9uKHR5cGUsIG51bGwsIGFzc29jKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7ZW5jb2RpbmcuRW5jb2Rlcn0gZW5jb2RlclxuICogQHBhcmFtIHtSZWxhdGl2ZVBvc2l0aW9ufSBycG9zXG4gKlxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCB3cml0ZVJlbGF0aXZlUG9zaXRpb24gPSAoZW5jb2RlciwgcnBvcykgPT4ge1xuICBjb25zdCB7IHR5cGUsIHRuYW1lLCBpdGVtLCBhc3NvYyB9ID0gcnBvc1xuICBpZiAoaXRlbSAhPT0gbnVsbCkge1xuICAgIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyLCAwKVxuICAgIHdyaXRlSUQoZW5jb2RlciwgaXRlbSlcbiAgfSBlbHNlIGlmICh0bmFtZSAhPT0gbnVsbCkge1xuICAgIC8vIGNhc2UgMjogZm91bmQgcG9zaXRpb24gYXQgdGhlIGVuZCBvZiB0aGUgbGlzdCBhbmQgdHlwZSBpcyBzdG9yZWQgaW4geS5zaGFyZVxuICAgIGVuY29kaW5nLndyaXRlVWludDgoZW5jb2RlciwgMSlcbiAgICBlbmNvZGluZy53cml0ZVZhclN0cmluZyhlbmNvZGVyLCB0bmFtZSlcbiAgfSBlbHNlIGlmICh0eXBlICE9PSBudWxsKSB7XG4gICAgLy8gY2FzZSAzOiBmb3VuZCBwb3NpdGlvbiBhdCB0aGUgZW5kIG9mIHRoZSBsaXN0IGFuZCB0eXBlIGlzIGF0dGFjaGVkIHRvIGFuIGl0ZW1cbiAgICBlbmNvZGluZy53cml0ZVVpbnQ4KGVuY29kZXIsIDIpXG4gICAgd3JpdGVJRChlbmNvZGVyLCB0eXBlKVxuICB9IGVsc2Uge1xuICAgIHRocm93IGVycm9yLnVuZXhwZWN0ZWRDYXNlKClcbiAgfVxuICBlbmNvZGluZy53cml0ZVZhckludChlbmNvZGVyLCBhc3NvYylcbiAgcmV0dXJuIGVuY29kZXJcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1JlbGF0aXZlUG9zaXRpb259IHJwb3NcbiAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9XG4gKi9cbmV4cG9ydCBjb25zdCBlbmNvZGVSZWxhdGl2ZVBvc2l0aW9uID0gcnBvcyA9PiB7XG4gIGNvbnN0IGVuY29kZXIgPSBlbmNvZGluZy5jcmVhdGVFbmNvZGVyKClcbiAgd3JpdGVSZWxhdGl2ZVBvc2l0aW9uKGVuY29kZXIsIHJwb3MpXG4gIHJldHVybiBlbmNvZGluZy50b1VpbnQ4QXJyYXkoZW5jb2Rlcilcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2RlY29kaW5nLkRlY29kZXJ9IGRlY29kZXJcbiAqIEByZXR1cm4ge1JlbGF0aXZlUG9zaXRpb259XG4gKlxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCByZWFkUmVsYXRpdmVQb3NpdGlvbiA9IGRlY29kZXIgPT4ge1xuICBsZXQgdHlwZSA9IG51bGxcbiAgbGV0IHRuYW1lID0gbnVsbFxuICBsZXQgaXRlbUlEID0gbnVsbFxuICBzd2l0Y2ggKGRlY29kaW5nLnJlYWRWYXJVaW50KGRlY29kZXIpKSB7XG4gICAgY2FzZSAwOlxuICAgICAgLy8gY2FzZSAxOiBmb3VuZCBwb3NpdGlvbiBzb21ld2hlcmUgaW4gdGhlIGxpbmtlZCBsaXN0XG4gICAgICBpdGVtSUQgPSByZWFkSUQoZGVjb2RlcilcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAxOlxuICAgICAgLy8gY2FzZSAyOiBmb3VuZCBwb3NpdGlvbiBhdCB0aGUgZW5kIG9mIHRoZSBsaXN0IGFuZCB0eXBlIGlzIHN0b3JlZCBpbiB5LnNoYXJlXG4gICAgICB0bmFtZSA9IGRlY29kaW5nLnJlYWRWYXJTdHJpbmcoZGVjb2RlcilcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAyOiB7XG4gICAgICAvLyBjYXNlIDM6IGZvdW5kIHBvc2l0aW9uIGF0IHRoZSBlbmQgb2YgdGhlIGxpc3QgYW5kIHR5cGUgaXMgYXR0YWNoZWQgdG8gYW4gaXRlbVxuICAgICAgdHlwZSA9IHJlYWRJRChkZWNvZGVyKVxuICAgIH1cbiAgfVxuICBjb25zdCBhc3NvYyA9IGRlY29kaW5nLmhhc0NvbnRlbnQoZGVjb2RlcikgPyBkZWNvZGluZy5yZWFkVmFySW50KGRlY29kZXIpIDogMFxuICByZXR1cm4gbmV3IFJlbGF0aXZlUG9zaXRpb24odHlwZSwgdG5hbWUsIGl0ZW1JRCwgYXNzb2MpXG59XG5cbi8qKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSB1aW50OEFycmF5XG4gKiBAcmV0dXJuIHtSZWxhdGl2ZVBvc2l0aW9ufVxuICovXG5leHBvcnQgY29uc3QgZGVjb2RlUmVsYXRpdmVQb3NpdGlvbiA9IHVpbnQ4QXJyYXkgPT4gcmVhZFJlbGF0aXZlUG9zaXRpb24oZGVjb2RpbmcuY3JlYXRlRGVjb2Rlcih1aW50OEFycmF5KSlcblxuLyoqXG4gKiBAcGFyYW0ge1JlbGF0aXZlUG9zaXRpb259IHJwb3NcbiAqIEBwYXJhbSB7RG9jfSBkb2NcbiAqIEByZXR1cm4ge0Fic29sdXRlUG9zaXRpb258bnVsbH1cbiAqXG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZUFic29sdXRlUG9zaXRpb25Gcm9tUmVsYXRpdmVQb3NpdGlvbiA9IChycG9zLCBkb2MpID0+IHtcbiAgY29uc3Qgc3RvcmUgPSBkb2Muc3RvcmVcbiAgY29uc3QgcmlnaHRJRCA9IHJwb3MuaXRlbVxuICBjb25zdCB0eXBlSUQgPSBycG9zLnR5cGVcbiAgY29uc3QgdG5hbWUgPSBycG9zLnRuYW1lXG4gIGNvbnN0IGFzc29jID0gcnBvcy5hc3NvY1xuICBsZXQgdHlwZSA9IG51bGxcbiAgbGV0IGluZGV4ID0gMFxuICBpZiAocmlnaHRJRCAhPT0gbnVsbCkge1xuICAgIGlmIChnZXRTdGF0ZShzdG9yZSwgcmlnaHRJRC5jbGllbnQpIDw9IHJpZ2h0SUQuY2xvY2spIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICAgIGNvbnN0IHJlcyA9IGZvbGxvd1JlZG9uZShzdG9yZSwgcmlnaHRJRClcbiAgICBjb25zdCByaWdodCA9IHJlcy5pdGVtXG4gICAgaWYgKCEocmlnaHQgaW5zdGFuY2VvZiBJdGVtKSkge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gICAgdHlwZSA9IC8qKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT59ICovIChyaWdodC5wYXJlbnQpXG4gICAgaWYgKHR5cGUuX2l0ZW0gPT09IG51bGwgfHwgIXR5cGUuX2l0ZW0uZGVsZXRlZCkge1xuICAgICAgaW5kZXggPSAocmlnaHQuZGVsZXRlZCB8fCAhcmlnaHQuY291bnRhYmxlKSA/IDAgOiAocmVzLmRpZmYgKyAoYXNzb2MgPj0gMCA/IDAgOiAxKSkgLy8gYWRqdXN0IHBvc2l0aW9uIGJhc2VkIG9uIGxlZnQgYXNzb2NpYXRpb24gaWYgbmVjZXNzYXJ5XG4gICAgICBsZXQgbiA9IHJpZ2h0LmxlZnRcbiAgICAgIHdoaWxlIChuICE9PSBudWxsKSB7XG4gICAgICAgIGlmICghbi5kZWxldGVkICYmIG4uY291bnRhYmxlKSB7XG4gICAgICAgICAgaW5kZXggKz0gbi5sZW5ndGhcbiAgICAgICAgfVxuICAgICAgICBuID0gbi5sZWZ0XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICh0bmFtZSAhPT0gbnVsbCkge1xuICAgICAgdHlwZSA9IGRvYy5nZXQodG5hbWUpXG4gICAgfSBlbHNlIGlmICh0eXBlSUQgIT09IG51bGwpIHtcbiAgICAgIGlmIChnZXRTdGF0ZShzdG9yZSwgdHlwZUlELmNsaWVudCkgPD0gdHlwZUlELmNsb2NrKSB7XG4gICAgICAgIC8vIHR5cGUgZG9lcyBub3QgZXhpc3QgeWV0XG4gICAgICAgIHJldHVybiBudWxsXG4gICAgICB9XG4gICAgICBjb25zdCB7IGl0ZW0gfSA9IGZvbGxvd1JlZG9uZShzdG9yZSwgdHlwZUlEKVxuICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBJdGVtICYmIGl0ZW0uY29udGVudCBpbnN0YW5jZW9mIENvbnRlbnRUeXBlKSB7XG4gICAgICAgIHR5cGUgPSBpdGVtLmNvbnRlbnQudHlwZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gc3RydWN0IGlzIGdhcmJhZ2UgY29sbGVjdGVkXG4gICAgICAgIHJldHVybiBudWxsXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IGVycm9yLnVuZXhwZWN0ZWRDYXNlKClcbiAgICB9XG4gICAgaWYgKGFzc29jID49IDApIHtcbiAgICAgIGluZGV4ID0gdHlwZS5fbGVuZ3RoXG4gICAgfSBlbHNlIHtcbiAgICAgIGluZGV4ID0gMFxuICAgIH1cbiAgfVxuICByZXR1cm4gY3JlYXRlQWJzb2x1dGVQb3NpdGlvbih0eXBlLCBpbmRleCwgcnBvcy5hc3NvYylcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1JlbGF0aXZlUG9zaXRpb258bnVsbH0gYVxuICogQHBhcmFtIHtSZWxhdGl2ZVBvc2l0aW9ufG51bGx9IGJcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKlxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBjb21wYXJlUmVsYXRpdmVQb3NpdGlvbnMgPSAoYSwgYikgPT4gYSA9PT0gYiB8fCAoXG4gIGEgIT09IG51bGwgJiYgYiAhPT0gbnVsbCAmJiBhLnRuYW1lID09PSBiLnRuYW1lICYmIGNvbXBhcmVJRHMoYS5pdGVtLCBiLml0ZW0pICYmIGNvbXBhcmVJRHMoYS50eXBlLCBiLnR5cGUpICYmIGEuYXNzb2MgPT09IGIuYXNzb2NcbilcbiIsICJcbmltcG9ydCB7XG4gIGlzRGVsZXRlZCxcbiAgY3JlYXRlRGVsZXRlU2V0RnJvbVN0cnVjdFN0b3JlLFxuICBnZXRTdGF0ZVZlY3RvcixcbiAgZ2V0SXRlbUNsZWFuU3RhcnQsXG4gIGl0ZXJhdGVEZWxldGVkU3RydWN0cyxcbiAgd3JpdGVEZWxldGVTZXQsXG4gIHdyaXRlU3RhdGVWZWN0b3IsXG4gIHJlYWREZWxldGVTZXQsXG4gIHJlYWRTdGF0ZVZlY3RvcixcbiAgY3JlYXRlRGVsZXRlU2V0LFxuICBjcmVhdGVJRCxcbiAgZ2V0U3RhdGUsXG4gIGZpbmRJbmRleFNTLFxuICBVcGRhdGVFbmNvZGVyVjIsXG4gIGFwcGx5VXBkYXRlVjIsXG4gIExhenlTdHJ1Y3RSZWFkZXIsXG4gIGVxdWFsRGVsZXRlU2V0cyxcbiAgVXBkYXRlRGVjb2RlclYxLCBVcGRhdGVEZWNvZGVyVjIsIERTRW5jb2RlclYxLCBEU0VuY29kZXJWMiwgRFNEZWNvZGVyVjEsIERTRGVjb2RlclYyLCBUcmFuc2FjdGlvbiwgRG9jLCBEZWxldGVTZXQsIEl0ZW0sIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgbWVyZ2VEZWxldGVTZXRzXG59IGZyb20gJy4uL2ludGVybmFscy5qcydcblxuaW1wb3J0ICogYXMgbWFwIGZyb20gJ2xpYjAvbWFwJ1xuaW1wb3J0ICogYXMgc2V0IGZyb20gJ2xpYjAvc2V0J1xuaW1wb3J0ICogYXMgZGVjb2RpbmcgZnJvbSAnbGliMC9kZWNvZGluZydcbmltcG9ydCAqIGFzIGVuY29kaW5nIGZyb20gJ2xpYjAvZW5jb2RpbmcnXG5cbmV4cG9ydCBjbGFzcyBTbmFwc2hvdCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0RlbGV0ZVNldH0gZHNcbiAgICogQHBhcmFtIHtNYXA8bnVtYmVyLG51bWJlcj59IHN2IHN0YXRlIG1hcFxuICAgKi9cbiAgY29uc3RydWN0b3IgKGRzLCBzdikge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtEZWxldGVTZXR9XG4gICAgICovXG4gICAgdGhpcy5kcyA9IGRzXG4gICAgLyoqXG4gICAgICogU3RhdGUgTWFwXG4gICAgICogQHR5cGUge01hcDxudW1iZXIsbnVtYmVyPn1cbiAgICAgKi9cbiAgICB0aGlzLnN2ID0gc3ZcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7U25hcHNob3R9IHNuYXAxXG4gKiBAcGFyYW0ge1NuYXBzaG90fSBzbmFwMlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGNvbnN0IGVxdWFsU25hcHNob3RzID0gKHNuYXAxLCBzbmFwMikgPT4ge1xuICBjb25zdCBkczEgPSBzbmFwMS5kcy5jbGllbnRzXG4gIGNvbnN0IGRzMiA9IHNuYXAyLmRzLmNsaWVudHNcbiAgY29uc3Qgc3YxID0gc25hcDEuc3ZcbiAgY29uc3Qgc3YyID0gc25hcDIuc3ZcbiAgaWYgKHN2MS5zaXplICE9PSBzdjIuc2l6ZSB8fCBkczEuc2l6ZSAhPT0gZHMyLnNpemUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBzdjEuZW50cmllcygpKSB7XG4gICAgaWYgKHN2Mi5nZXQoa2V5KSAhPT0gdmFsdWUpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuICBmb3IgKGNvbnN0IFtjbGllbnQsIGRzaXRlbXMxXSBvZiBkczEuZW50cmllcygpKSB7XG4gICAgY29uc3QgZHNpdGVtczIgPSBkczIuZ2V0KGNsaWVudCkgfHwgW11cbiAgICBpZiAoZHNpdGVtczEubGVuZ3RoICE9PSBkc2l0ZW1zMi5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRzaXRlbXMxLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBkc2l0ZW0xID0gZHNpdGVtczFbaV1cbiAgICAgIGNvbnN0IGRzaXRlbTIgPSBkc2l0ZW1zMltpXVxuICAgICAgaWYgKGRzaXRlbTEuY2xvY2sgIT09IGRzaXRlbTIuY2xvY2sgfHwgZHNpdGVtMS5sZW4gIT09IGRzaXRlbTIubGVuKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG4vKipcbiAqIEBwYXJhbSB7U25hcHNob3R9IHNuYXBzaG90XG4gKiBAcGFyYW0ge0RTRW5jb2RlclYxIHwgRFNFbmNvZGVyVjJ9IFtlbmNvZGVyXVxuICogQHJldHVybiB7VWludDhBcnJheX1cbiAqL1xuZXhwb3J0IGNvbnN0IGVuY29kZVNuYXBzaG90VjIgPSAoc25hcHNob3QsIGVuY29kZXIgPSBuZXcgRFNFbmNvZGVyVjIoKSkgPT4ge1xuICB3cml0ZURlbGV0ZVNldChlbmNvZGVyLCBzbmFwc2hvdC5kcylcbiAgd3JpdGVTdGF0ZVZlY3RvcihlbmNvZGVyLCBzbmFwc2hvdC5zdilcbiAgcmV0dXJuIGVuY29kZXIudG9VaW50OEFycmF5KClcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1NuYXBzaG90fSBzbmFwc2hvdFxuICogQHJldHVybiB7VWludDhBcnJheX1cbiAqL1xuZXhwb3J0IGNvbnN0IGVuY29kZVNuYXBzaG90ID0gc25hcHNob3QgPT4gZW5jb2RlU25hcHNob3RWMihzbmFwc2hvdCwgbmV3IERTRW5jb2RlclYxKCkpXG5cbi8qKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWZcbiAqIEBwYXJhbSB7RFNEZWNvZGVyVjEgfCBEU0RlY29kZXJWMn0gW2RlY29kZXJdXG4gKiBAcmV0dXJuIHtTbmFwc2hvdH1cbiAqL1xuZXhwb3J0IGNvbnN0IGRlY29kZVNuYXBzaG90VjIgPSAoYnVmLCBkZWNvZGVyID0gbmV3IERTRGVjb2RlclYyKGRlY29kaW5nLmNyZWF0ZURlY29kZXIoYnVmKSkpID0+IHtcbiAgcmV0dXJuIG5ldyBTbmFwc2hvdChyZWFkRGVsZXRlU2V0KGRlY29kZXIpLCByZWFkU3RhdGVWZWN0b3IoZGVjb2RlcikpXG59XG5cbi8qKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWZcbiAqIEByZXR1cm4ge1NuYXBzaG90fVxuICovXG5leHBvcnQgY29uc3QgZGVjb2RlU25hcHNob3QgPSBidWYgPT4gZGVjb2RlU25hcHNob3RWMihidWYsIG5ldyBEU0RlY29kZXJWMShkZWNvZGluZy5jcmVhdGVEZWNvZGVyKGJ1ZikpKVxuXG4vKipcbiAqIEBwYXJhbSB7RGVsZXRlU2V0fSBkc1xuICogQHBhcmFtIHtNYXA8bnVtYmVyLG51bWJlcj59IHNtXG4gKiBAcmV0dXJuIHtTbmFwc2hvdH1cbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZVNuYXBzaG90ID0gKGRzLCBzbSkgPT4gbmV3IFNuYXBzaG90KGRzLCBzbSlcblxuZXhwb3J0IGNvbnN0IGVtcHR5U25hcHNob3QgPSBjcmVhdGVTbmFwc2hvdChjcmVhdGVEZWxldGVTZXQoKSwgbmV3IE1hcCgpKVxuXG4vKipcbiAqIEBwYXJhbSB7RG9jfSBkb2NcbiAqIEByZXR1cm4ge1NuYXBzaG90fVxuICovXG5leHBvcnQgY29uc3Qgc25hcHNob3QgPSBkb2MgPT4gY3JlYXRlU25hcHNob3QoY3JlYXRlRGVsZXRlU2V0RnJvbVN0cnVjdFN0b3JlKGRvYy5zdG9yZSksIGdldFN0YXRlVmVjdG9yKGRvYy5zdG9yZSkpXG5cbi8qKlxuICogQHBhcmFtIHtJdGVtfSBpdGVtXG4gKiBAcGFyYW0ge1NuYXBzaG90fHVuZGVmaW5lZH0gc25hcHNob3RcbiAqXG4gKiBAcHJvdGVjdGVkXG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IGlzVmlzaWJsZSA9IChpdGVtLCBzbmFwc2hvdCkgPT4gc25hcHNob3QgPT09IHVuZGVmaW5lZFxuICA/ICFpdGVtLmRlbGV0ZWRcbiAgOiBzbmFwc2hvdC5zdi5oYXMoaXRlbS5pZC5jbGllbnQpICYmIChzbmFwc2hvdC5zdi5nZXQoaXRlbS5pZC5jbGllbnQpIHx8IDApID4gaXRlbS5pZC5jbG9jayAmJiAhaXNEZWxldGVkKHNuYXBzaG90LmRzLCBpdGVtLmlkKVxuXG4vKipcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge1NuYXBzaG90fSBzbmFwc2hvdFxuICovXG5leHBvcnQgY29uc3Qgc3BsaXRTbmFwc2hvdEFmZmVjdGVkU3RydWN0cyA9ICh0cmFuc2FjdGlvbiwgc25hcHNob3QpID0+IHtcbiAgY29uc3QgbWV0YSA9IG1hcC5zZXRJZlVuZGVmaW5lZCh0cmFuc2FjdGlvbi5tZXRhLCBzcGxpdFNuYXBzaG90QWZmZWN0ZWRTdHJ1Y3RzLCBzZXQuY3JlYXRlKVxuICBjb25zdCBzdG9yZSA9IHRyYW5zYWN0aW9uLmRvYy5zdG9yZVxuICAvLyBjaGVjayBpZiB3ZSBhbHJlYWR5IHNwbGl0IGZvciB0aGlzIHNuYXBzaG90XG4gIGlmICghbWV0YS5oYXMoc25hcHNob3QpKSB7XG4gICAgc25hcHNob3Quc3YuZm9yRWFjaCgoY2xvY2ssIGNsaWVudCkgPT4ge1xuICAgICAgaWYgKGNsb2NrIDwgZ2V0U3RhdGUoc3RvcmUsIGNsaWVudCkpIHtcbiAgICAgICAgZ2V0SXRlbUNsZWFuU3RhcnQodHJhbnNhY3Rpb24sIGNyZWF0ZUlEKGNsaWVudCwgY2xvY2spKVxuICAgICAgfVxuICAgIH0pXG4gICAgaXRlcmF0ZURlbGV0ZWRTdHJ1Y3RzKHRyYW5zYWN0aW9uLCBzbmFwc2hvdC5kcywgX2l0ZW0gPT4ge30pXG4gICAgbWV0YS5hZGQoc25hcHNob3QpXG4gIH1cbn1cblxuLyoqXG4gKiBAZXhhbXBsZVxuICogIGNvbnN0IHlkb2MgPSBuZXcgWS5Eb2MoeyBnYzogZmFsc2UgfSlcbiAqICB5ZG9jLmdldFRleHQoKS5pbnNlcnQoMCwgJ3dvcmxkIScpXG4gKiAgY29uc3Qgc25hcHNob3QgPSBZLnNuYXBzaG90KHlkb2MpXG4gKiAgeWRvYy5nZXRUZXh0KCkuaW5zZXJ0KDAsICdoZWxsbyAnKVxuICogIGNvbnN0IHJlc3RvcmVkID0gWS5jcmVhdGVEb2NGcm9tU25hcHNob3QoeWRvYywgc25hcHNob3QpXG4gKiAgYXNzZXJ0KHJlc3RvcmVkLmdldFRleHQoKS50b1N0cmluZygpID09PSAnd29ybGQhJylcbiAqXG4gKiBAcGFyYW0ge0RvY30gb3JpZ2luRG9jXG4gKiBAcGFyYW0ge1NuYXBzaG90fSBzbmFwc2hvdFxuICogQHBhcmFtIHtEb2N9IFtuZXdEb2NdIE9wdGlvbmFsbHksIHlvdSBtYXkgZGVmaW5lIHRoZSBZanMgZG9jdW1lbnQgdGhhdCByZWNlaXZlcyB0aGUgZGF0YSBmcm9tIG9yaWdpbkRvY1xuICogQHJldHVybiB7RG9jfVxuICovXG5leHBvcnQgY29uc3QgY3JlYXRlRG9jRnJvbVNuYXBzaG90ID0gKG9yaWdpbkRvYywgc25hcHNob3QsIG5ld0RvYyA9IG5ldyBEb2MoKSkgPT4ge1xuICBpZiAob3JpZ2luRG9jLmdjKSB7XG4gICAgLy8gd2Ugc2hvdWxkIG5vdCB0cnkgdG8gcmVzdG9yZSBhIEdDLWVkIGRvY3VtZW50LCBiZWNhdXNlIHNvbWUgb2YgdGhlIHJlc3RvcmVkIGl0ZW1zIG1pZ2h0IGhhdmUgdGhlaXIgY29udGVudCBkZWxldGVkXG4gICAgdGhyb3cgbmV3IEVycm9yKCdHYXJiYWdlLWNvbGxlY3Rpb24gbXVzdCBiZSBkaXNhYmxlZCBpbiBgb3JpZ2luRG9jYCEnKVxuICB9XG4gIGNvbnN0IHsgc3YsIGRzIH0gPSBzbmFwc2hvdFxuXG4gIGNvbnN0IGVuY29kZXIgPSBuZXcgVXBkYXRlRW5jb2RlclYyKClcbiAgb3JpZ2luRG9jLnRyYW5zYWN0KHRyYW5zYWN0aW9uID0+IHtcbiAgICBsZXQgc2l6ZSA9IDBcbiAgICBzdi5mb3JFYWNoKGNsb2NrID0+IHtcbiAgICAgIGlmIChjbG9jayA+IDApIHtcbiAgICAgICAgc2l6ZSsrXG4gICAgICB9XG4gICAgfSlcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2Rlci5yZXN0RW5jb2Rlciwgc2l6ZSlcbiAgICAvLyBzcGxpdHRpbmcgdGhlIHN0cnVjdHMgYmVmb3JlIHdyaXRpbmcgdGhlbSB0byB0aGUgZW5jb2RlclxuICAgIGZvciAoY29uc3QgW2NsaWVudCwgY2xvY2tdIG9mIHN2KSB7XG4gICAgICBpZiAoY2xvY2sgPT09IDApIHtcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cbiAgICAgIGlmIChjbG9jayA8IGdldFN0YXRlKG9yaWdpbkRvYy5zdG9yZSwgY2xpZW50KSkge1xuICAgICAgICBnZXRJdGVtQ2xlYW5TdGFydCh0cmFuc2FjdGlvbiwgY3JlYXRlSUQoY2xpZW50LCBjbG9jaykpXG4gICAgICB9XG4gICAgICBjb25zdCBzdHJ1Y3RzID0gb3JpZ2luRG9jLnN0b3JlLmNsaWVudHMuZ2V0KGNsaWVudCkgfHwgW11cbiAgICAgIGNvbnN0IGxhc3RTdHJ1Y3RJbmRleCA9IGZpbmRJbmRleFNTKHN0cnVjdHMsIGNsb2NrIC0gMSlcbiAgICAgIC8vIHdyaXRlICMgZW5jb2RlZCBzdHJ1Y3RzXG4gICAgICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2Rlci5yZXN0RW5jb2RlciwgbGFzdFN0cnVjdEluZGV4ICsgMSlcbiAgICAgIGVuY29kZXIud3JpdGVDbGllbnQoY2xpZW50KVxuICAgICAgLy8gZmlyc3QgY2xvY2sgd3JpdHRlbiBpcyAwXG4gICAgICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2Rlci5yZXN0RW5jb2RlciwgMClcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IGxhc3RTdHJ1Y3RJbmRleDsgaSsrKSB7XG4gICAgICAgIHN0cnVjdHNbaV0ud3JpdGUoZW5jb2RlciwgMClcbiAgICAgIH1cbiAgICB9XG4gICAgd3JpdGVEZWxldGVTZXQoZW5jb2RlciwgZHMpXG4gIH0pXG5cbiAgYXBwbHlVcGRhdGVWMihuZXdEb2MsIGVuY29kZXIudG9VaW50OEFycmF5KCksICdzbmFwc2hvdCcpXG4gIHJldHVybiBuZXdEb2Ncbn1cblxuLyoqXG4gKiBAcGFyYW0ge1NuYXBzaG90fSBzbmFwc2hvdFxuICogQHBhcmFtIHtVaW50OEFycmF5fSB1cGRhdGVcbiAqIEBwYXJhbSB7dHlwZW9mIFVwZGF0ZURlY29kZXJWMiB8IHR5cGVvZiBVcGRhdGVEZWNvZGVyVjF9IFtZRGVjb2Rlcl1cbiAqL1xuZXhwb3J0IGNvbnN0IHNuYXBzaG90Q29udGFpbnNVcGRhdGVWMiA9IChzbmFwc2hvdCwgdXBkYXRlLCBZRGVjb2RlciA9IFVwZGF0ZURlY29kZXJWMikgPT4ge1xuICBjb25zdCBzdHJ1Y3RzID0gW11cbiAgY29uc3QgdXBkYXRlRGVjb2RlciA9IG5ldyBZRGVjb2RlcihkZWNvZGluZy5jcmVhdGVEZWNvZGVyKHVwZGF0ZSkpXG4gIGNvbnN0IGxhenlEZWNvZGVyID0gbmV3IExhenlTdHJ1Y3RSZWFkZXIodXBkYXRlRGVjb2RlciwgZmFsc2UpXG4gIGZvciAobGV0IGN1cnIgPSBsYXp5RGVjb2Rlci5jdXJyOyBjdXJyICE9PSBudWxsOyBjdXJyID0gbGF6eURlY29kZXIubmV4dCgpKSB7XG4gICAgc3RydWN0cy5wdXNoKGN1cnIpXG4gICAgaWYgKChzbmFwc2hvdC5zdi5nZXQoY3Vyci5pZC5jbGllbnQpIHx8IDApIDwgY3Vyci5pZC5jbG9jayArIGN1cnIubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cbiAgY29uc3QgbWVyZ2VkRFMgPSBtZXJnZURlbGV0ZVNldHMoW3NuYXBzaG90LmRzLCByZWFkRGVsZXRlU2V0KHVwZGF0ZURlY29kZXIpXSlcbiAgcmV0dXJuIGVxdWFsRGVsZXRlU2V0cyhzbmFwc2hvdC5kcywgbWVyZ2VkRFMpXG59XG5cbi8qKlxuICogQHBhcmFtIHtTbmFwc2hvdH0gc25hcHNob3RcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gdXBkYXRlXG4gKi9cbmV4cG9ydCBjb25zdCBzbmFwc2hvdENvbnRhaW5zVXBkYXRlID0gKHNuYXBzaG90LCB1cGRhdGUpID0+IHNuYXBzaG90Q29udGFpbnNVcGRhdGVWMihzbmFwc2hvdCwgdXBkYXRlLCBVcGRhdGVEZWNvZGVyVjEpXG4iLCAiXG5pbXBvcnQge1xuICBHQyxcbiAgc3BsaXRJdGVtLFxuICBUcmFuc2FjdGlvbiwgSUQsIEl0ZW0sIERTRGVjb2RlclYyIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbn0gZnJvbSAnLi4vaW50ZXJuYWxzLmpzJ1xuXG5pbXBvcnQgKiBhcyBtYXRoIGZyb20gJ2xpYjAvbWF0aCdcbmltcG9ydCAqIGFzIGVycm9yIGZyb20gJ2xpYjAvZXJyb3InXG5cbmV4cG9ydCBjbGFzcyBTdHJ1Y3RTdG9yZSB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7TWFwPG51bWJlcixBcnJheTxHQ3xJdGVtPj59XG4gICAgICovXG4gICAgdGhpcy5jbGllbnRzID0gbmV3IE1hcCgpXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bGwgfCB7IG1pc3Npbmc6IE1hcDxudW1iZXIsIG51bWJlcj4sIHVwZGF0ZTogVWludDhBcnJheSB9fVxuICAgICAqL1xuICAgIHRoaXMucGVuZGluZ1N0cnVjdHMgPSBudWxsXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bGwgfCBVaW50OEFycmF5fVxuICAgICAqL1xuICAgIHRoaXMucGVuZGluZ0RzID0gbnVsbFxuICB9XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSBzdGF0ZXMgYXMgYSBNYXA8Y2xpZW50LGNsb2NrPi5cbiAqIE5vdGUgdGhhdCBjbG9jayByZWZlcnMgdG8gdGhlIG5leHQgZXhwZWN0ZWQgY2xvY2sgaWQuXG4gKlxuICogQHBhcmFtIHtTdHJ1Y3RTdG9yZX0gc3RvcmVcbiAqIEByZXR1cm4ge01hcDxudW1iZXIsbnVtYmVyPn1cbiAqXG4gKiBAcHVibGljXG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IGdldFN0YXRlVmVjdG9yID0gc3RvcmUgPT4ge1xuICBjb25zdCBzbSA9IG5ldyBNYXAoKVxuICBzdG9yZS5jbGllbnRzLmZvckVhY2goKHN0cnVjdHMsIGNsaWVudCkgPT4ge1xuICAgIGNvbnN0IHN0cnVjdCA9IHN0cnVjdHNbc3RydWN0cy5sZW5ndGggLSAxXVxuICAgIHNtLnNldChjbGllbnQsIHN0cnVjdC5pZC5jbG9jayArIHN0cnVjdC5sZW5ndGgpXG4gIH0pXG4gIHJldHVybiBzbVxufVxuXG4vKipcbiAqIEBwYXJhbSB7U3RydWN0U3RvcmV9IHN0b3JlXG4gKiBAcGFyYW0ge251bWJlcn0gY2xpZW50XG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKlxuICogQHB1YmxpY1xuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRTdGF0ZSA9IChzdG9yZSwgY2xpZW50KSA9PiB7XG4gIGNvbnN0IHN0cnVjdHMgPSBzdG9yZS5jbGllbnRzLmdldChjbGllbnQpXG4gIGlmIChzdHJ1Y3RzID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gMFxuICB9XG4gIGNvbnN0IGxhc3RTdHJ1Y3QgPSBzdHJ1Y3RzW3N0cnVjdHMubGVuZ3RoIC0gMV1cbiAgcmV0dXJuIGxhc3RTdHJ1Y3QuaWQuY2xvY2sgKyBsYXN0U3RydWN0Lmxlbmd0aFxufVxuXG4vKipcbiAqIEBwYXJhbSB7U3RydWN0U3RvcmV9IHN0b3JlXG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgaW50ZWdyZXR5Q2hlY2sgPSBzdG9yZSA9PiB7XG4gIHN0b3JlLmNsaWVudHMuZm9yRWFjaChzdHJ1Y3RzID0+IHtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IHN0cnVjdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGwgPSBzdHJ1Y3RzW2kgLSAxXVxuICAgICAgY29uc3QgciA9IHN0cnVjdHNbaV1cbiAgICAgIGlmIChsLmlkLmNsb2NrICsgbC5sZW5ndGggIT09IHIuaWQuY2xvY2spIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdHJ1Y3RTdG9yZSBmYWlsZWQgaW50ZWdyZXR5IGNoZWNrJylcbiAgICAgIH1cbiAgICB9XG4gIH0pXG59XG5cbi8qKlxuICogQHBhcmFtIHtTdHJ1Y3RTdG9yZX0gc3RvcmVcbiAqIEBwYXJhbSB7R0N8SXRlbX0gc3RydWN0XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgYWRkU3RydWN0ID0gKHN0b3JlLCBzdHJ1Y3QpID0+IHtcbiAgbGV0IHN0cnVjdHMgPSBzdG9yZS5jbGllbnRzLmdldChzdHJ1Y3QuaWQuY2xpZW50KVxuICBpZiAoc3RydWN0cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RydWN0cyA9IFtdXG4gICAgc3RvcmUuY2xpZW50cy5zZXQoc3RydWN0LmlkLmNsaWVudCwgc3RydWN0cylcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBsYXN0U3RydWN0ID0gc3RydWN0c1tzdHJ1Y3RzLmxlbmd0aCAtIDFdXG4gICAgaWYgKGxhc3RTdHJ1Y3QuaWQuY2xvY2sgKyBsYXN0U3RydWN0Lmxlbmd0aCAhPT0gc3RydWN0LmlkLmNsb2NrKSB7XG4gICAgICB0aHJvdyBlcnJvci51bmV4cGVjdGVkQ2FzZSgpXG4gICAgfVxuICB9XG4gIHN0cnVjdHMucHVzaChzdHJ1Y3QpXG59XG5cbi8qKlxuICogUGVyZm9ybSBhIGJpbmFyeSBzZWFyY2ggb24gYSBzb3J0ZWQgYXJyYXlcbiAqIEBwYXJhbSB7QXJyYXk8SXRlbXxHQz59IHN0cnVjdHNcbiAqIEBwYXJhbSB7bnVtYmVyfSBjbG9ja1xuICogQHJldHVybiB7bnVtYmVyfVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IGZpbmRJbmRleFNTID0gKHN0cnVjdHMsIGNsb2NrKSA9PiB7XG4gIGxldCBsZWZ0ID0gMFxuICBsZXQgcmlnaHQgPSBzdHJ1Y3RzLmxlbmd0aCAtIDFcbiAgbGV0IG1pZCA9IHN0cnVjdHNbcmlnaHRdXG4gIGxldCBtaWRjbG9jayA9IG1pZC5pZC5jbG9ja1xuICBpZiAobWlkY2xvY2sgPT09IGNsb2NrKSB7XG4gICAgcmV0dXJuIHJpZ2h0XG4gIH1cbiAgLy8gQHRvZG8gZG9lcyBpdCBldmVuIG1ha2Ugc2Vuc2UgdG8gcGl2b3QgdGhlIHNlYXJjaD9cbiAgLy8gSWYgYSBnb29kIHNwbGl0IG1pc3NlcywgaXQgbWlnaHQgYWN0dWFsbHkgaW5jcmVhc2UgdGhlIHRpbWUgdG8gZmluZCB0aGUgY29ycmVjdCBpdGVtLlxuICAvLyBDdXJyZW50bHksIHRoZSBvbmx5IGFkdmFudGFnZSBpcyB0aGF0IHNlYXJjaCB3aXRoIHBpdm90aW5nIG1pZ2h0IGZpbmQgdGhlIGl0ZW0gb24gdGhlIGZpcnN0IHRyeS5cbiAgbGV0IG1pZGluZGV4ID0gbWF0aC5mbG9vcigoY2xvY2sgLyAobWlkY2xvY2sgKyBtaWQubGVuZ3RoIC0gMSkpICogcmlnaHQpIC8vIHBpdm90aW5nIHRoZSBzZWFyY2hcbiAgd2hpbGUgKGxlZnQgPD0gcmlnaHQpIHtcbiAgICBtaWQgPSBzdHJ1Y3RzW21pZGluZGV4XVxuICAgIG1pZGNsb2NrID0gbWlkLmlkLmNsb2NrXG4gICAgaWYgKG1pZGNsb2NrIDw9IGNsb2NrKSB7XG4gICAgICBpZiAoY2xvY2sgPCBtaWRjbG9jayArIG1pZC5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG1pZGluZGV4XG4gICAgICB9XG4gICAgICBsZWZ0ID0gbWlkaW5kZXggKyAxXG4gICAgfSBlbHNlIHtcbiAgICAgIHJpZ2h0ID0gbWlkaW5kZXggLSAxXG4gICAgfVxuICAgIG1pZGluZGV4ID0gbWF0aC5mbG9vcigobGVmdCArIHJpZ2h0KSAvIDIpXG4gIH1cbiAgLy8gQWx3YXlzIGNoZWNrIHN0YXRlIGJlZm9yZSBsb29raW5nIGZvciBhIHN0cnVjdCBpbiBTdHJ1Y3RTdG9yZVxuICAvLyBUaGVyZWZvcmUgdGhlIGNhc2Ugb2Ygbm90IGZpbmRpbmcgYSBzdHJ1Y3QgaXMgdW5leHBlY3RlZFxuICB0aHJvdyBlcnJvci51bmV4cGVjdGVkQ2FzZSgpXG59XG5cbi8qKlxuICogRXhwZWN0cyB0aGF0IGlkIGlzIGFjdHVhbGx5IGluIHN0b3JlLiBUaGlzIGZ1bmN0aW9uIHRocm93cyBvciBpcyBhbiBpbmZpbml0ZSBsb29wIG90aGVyd2lzZS5cbiAqXG4gKiBAcGFyYW0ge1N0cnVjdFN0b3JlfSBzdG9yZVxuICogQHBhcmFtIHtJRH0gaWRcbiAqIEByZXR1cm4ge0dDfEl0ZW19XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgZmluZCA9IChzdG9yZSwgaWQpID0+IHtcbiAgLyoqXG4gICAqIEB0eXBlIHtBcnJheTxHQ3xJdGVtPn1cbiAgICovXG4gIC8vIEB0cy1pZ25vcmVcbiAgY29uc3Qgc3RydWN0cyA9IHN0b3JlLmNsaWVudHMuZ2V0KGlkLmNsaWVudClcbiAgcmV0dXJuIHN0cnVjdHNbZmluZEluZGV4U1Moc3RydWN0cywgaWQuY2xvY2spXVxufVxuXG4vKipcbiAqIEV4cGVjdHMgdGhhdCBpZCBpcyBhY3R1YWxseSBpbiBzdG9yZS4gVGhpcyBmdW5jdGlvbiB0aHJvd3Mgb3IgaXMgYW4gaW5maW5pdGUgbG9vcCBvdGhlcndpc2UuXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRJdGVtID0gLyoqIEB0eXBlIHtmdW5jdGlvbihTdHJ1Y3RTdG9yZSxJRCk6SXRlbX0gKi8gKGZpbmQpXG5cbi8qKlxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXk8SXRlbXxHQz59IHN0cnVjdHNcbiAqIEBwYXJhbSB7bnVtYmVyfSBjbG9ja1xuICovXG5leHBvcnQgY29uc3QgZmluZEluZGV4Q2xlYW5TdGFydCA9ICh0cmFuc2FjdGlvbiwgc3RydWN0cywgY2xvY2spID0+IHtcbiAgY29uc3QgaW5kZXggPSBmaW5kSW5kZXhTUyhzdHJ1Y3RzLCBjbG9jaylcbiAgY29uc3Qgc3RydWN0ID0gc3RydWN0c1tpbmRleF1cbiAgaWYgKHN0cnVjdC5pZC5jbG9jayA8IGNsb2NrICYmIHN0cnVjdCBpbnN0YW5jZW9mIEl0ZW0pIHtcbiAgICBzdHJ1Y3RzLnNwbGljZShpbmRleCArIDEsIDAsIHNwbGl0SXRlbSh0cmFuc2FjdGlvbiwgc3RydWN0LCBjbG9jayAtIHN0cnVjdC5pZC5jbG9jaykpXG4gICAgcmV0dXJuIGluZGV4ICsgMVxuICB9XG4gIHJldHVybiBpbmRleFxufVxuXG4vKipcbiAqIEV4cGVjdHMgdGhhdCBpZCBpcyBhY3R1YWxseSBpbiBzdG9yZS4gVGhpcyBmdW5jdGlvbiB0aHJvd3Mgb3IgaXMgYW4gaW5maW5pdGUgbG9vcCBvdGhlcndpc2UuXG4gKlxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7SUR9IGlkXG4gKiBAcmV0dXJuIHtJdGVtfVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IGdldEl0ZW1DbGVhblN0YXJ0ID0gKHRyYW5zYWN0aW9uLCBpZCkgPT4ge1xuICBjb25zdCBzdHJ1Y3RzID0gLyoqIEB0eXBlIHtBcnJheTxJdGVtPn0gKi8gKHRyYW5zYWN0aW9uLmRvYy5zdG9yZS5jbGllbnRzLmdldChpZC5jbGllbnQpKVxuICByZXR1cm4gc3RydWN0c1tmaW5kSW5kZXhDbGVhblN0YXJ0KHRyYW5zYWN0aW9uLCBzdHJ1Y3RzLCBpZC5jbG9jayldXG59XG5cbi8qKlxuICogRXhwZWN0cyB0aGF0IGlkIGlzIGFjdHVhbGx5IGluIHN0b3JlLiBUaGlzIGZ1bmN0aW9uIHRocm93cyBvciBpcyBhbiBpbmZpbml0ZSBsb29wIG90aGVyd2lzZS5cbiAqXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtTdHJ1Y3RTdG9yZX0gc3RvcmVcbiAqIEBwYXJhbSB7SUR9IGlkXG4gKiBAcmV0dXJuIHtJdGVtfVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IGdldEl0ZW1DbGVhbkVuZCA9ICh0cmFuc2FjdGlvbiwgc3RvcmUsIGlkKSA9PiB7XG4gIC8qKlxuICAgKiBAdHlwZSB7QXJyYXk8SXRlbT59XG4gICAqL1xuICAvLyBAdHMtaWdub3JlXG4gIGNvbnN0IHN0cnVjdHMgPSBzdG9yZS5jbGllbnRzLmdldChpZC5jbGllbnQpXG4gIGNvbnN0IGluZGV4ID0gZmluZEluZGV4U1Moc3RydWN0cywgaWQuY2xvY2spXG4gIGNvbnN0IHN0cnVjdCA9IHN0cnVjdHNbaW5kZXhdXG4gIGlmIChpZC5jbG9jayAhPT0gc3RydWN0LmlkLmNsb2NrICsgc3RydWN0Lmxlbmd0aCAtIDEgJiYgc3RydWN0LmNvbnN0cnVjdG9yICE9PSBHQykge1xuICAgIHN0cnVjdHMuc3BsaWNlKGluZGV4ICsgMSwgMCwgc3BsaXRJdGVtKHRyYW5zYWN0aW9uLCBzdHJ1Y3QsIGlkLmNsb2NrIC0gc3RydWN0LmlkLmNsb2NrICsgMSkpXG4gIH1cbiAgcmV0dXJuIHN0cnVjdFxufVxuXG4vKipcbiAqIFJlcGxhY2UgYGl0ZW1gIHdpdGggYG5ld2l0ZW1gIGluIHN0b3JlXG4gKiBAcGFyYW0ge1N0cnVjdFN0b3JlfSBzdG9yZVxuICogQHBhcmFtIHtHQ3xJdGVtfSBzdHJ1Y3RcbiAqIEBwYXJhbSB7R0N8SXRlbX0gbmV3U3RydWN0XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgcmVwbGFjZVN0cnVjdCA9IChzdG9yZSwgc3RydWN0LCBuZXdTdHJ1Y3QpID0+IHtcbiAgY29uc3Qgc3RydWN0cyA9IC8qKiBAdHlwZSB7QXJyYXk8R0N8SXRlbT59ICovIChzdG9yZS5jbGllbnRzLmdldChzdHJ1Y3QuaWQuY2xpZW50KSlcbiAgc3RydWN0c1tmaW5kSW5kZXhTUyhzdHJ1Y3RzLCBzdHJ1Y3QuaWQuY2xvY2spXSA9IG5ld1N0cnVjdFxufVxuXG4vKipcbiAqIEl0ZXJhdGUgb3ZlciBhIHJhbmdlIG9mIHN0cnVjdHNcbiAqXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtBcnJheTxJdGVtfEdDPn0gc3RydWN0c1xuICogQHBhcmFtIHtudW1iZXJ9IGNsb2NrU3RhcnQgSW5jbHVzaXZlIHN0YXJ0XG4gKiBAcGFyYW0ge251bWJlcn0gbGVuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKEdDfEl0ZW0pOnZvaWR9IGZcbiAqXG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IGl0ZXJhdGVTdHJ1Y3RzID0gKHRyYW5zYWN0aW9uLCBzdHJ1Y3RzLCBjbG9ja1N0YXJ0LCBsZW4sIGYpID0+IHtcbiAgaWYgKGxlbiA9PT0gMCkge1xuICAgIHJldHVyblxuICB9XG4gIGNvbnN0IGNsb2NrRW5kID0gY2xvY2tTdGFydCArIGxlblxuICBsZXQgaW5kZXggPSBmaW5kSW5kZXhDbGVhblN0YXJ0KHRyYW5zYWN0aW9uLCBzdHJ1Y3RzLCBjbG9ja1N0YXJ0KVxuICBsZXQgc3RydWN0XG4gIGRvIHtcbiAgICBzdHJ1Y3QgPSBzdHJ1Y3RzW2luZGV4KytdXG4gICAgaWYgKGNsb2NrRW5kIDwgc3RydWN0LmlkLmNsb2NrICsgc3RydWN0Lmxlbmd0aCkge1xuICAgICAgZmluZEluZGV4Q2xlYW5TdGFydCh0cmFuc2FjdGlvbiwgc3RydWN0cywgY2xvY2tFbmQpXG4gICAgfVxuICAgIGYoc3RydWN0KVxuICB9IHdoaWxlIChpbmRleCA8IHN0cnVjdHMubGVuZ3RoICYmIHN0cnVjdHNbaW5kZXhdLmlkLmNsb2NrIDwgY2xvY2tFbmQpXG59XG4iLCAiXG5pbXBvcnQge1xuICBnZXRTdGF0ZSxcbiAgd3JpdGVTdHJ1Y3RzRnJvbVRyYW5zYWN0aW9uLFxuICB3cml0ZURlbGV0ZVNldCxcbiAgRGVsZXRlU2V0LFxuICBzb3J0QW5kTWVyZ2VEZWxldGVTZXQsXG4gIGdldFN0YXRlVmVjdG9yLFxuICBmaW5kSW5kZXhTUyxcbiAgY2FsbEV2ZW50SGFuZGxlckxpc3RlbmVycyxcbiAgSXRlbSxcbiAgZ2VuZXJhdGVOZXdDbGllbnRJZCxcbiAgY3JlYXRlSUQsXG4gIGNsZWFudXBZVGV4dEFmdGVyVHJhbnNhY3Rpb24sXG4gIFVwZGF0ZUVuY29kZXJWMSwgVXBkYXRlRW5jb2RlclYyLCBHQywgU3RydWN0U3RvcmUsIEFic3RyYWN0VHlwZSwgQWJzdHJhY3RTdHJ1Y3QsIFlFdmVudCwgRG9jIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbn0gZnJvbSAnLi4vaW50ZXJuYWxzLmpzJ1xuXG5pbXBvcnQgKiBhcyBtYXAgZnJvbSAnbGliMC9tYXAnXG5pbXBvcnQgKiBhcyBtYXRoIGZyb20gJ2xpYjAvbWF0aCdcbmltcG9ydCAqIGFzIHNldCBmcm9tICdsaWIwL3NldCdcbmltcG9ydCAqIGFzIGxvZ2dpbmcgZnJvbSAnbGliMC9sb2dnaW5nJ1xuaW1wb3J0IHsgY2FsbEFsbCB9IGZyb20gJ2xpYjAvZnVuY3Rpb24nXG5cbi8qKlxuICogQSB0cmFuc2FjdGlvbiBpcyBjcmVhdGVkIGZvciBldmVyeSBjaGFuZ2Ugb24gdGhlIFlqcyBtb2RlbC4gSXQgaXMgcG9zc2libGVcbiAqIHRvIGJ1bmRsZSBjaGFuZ2VzIG9uIHRoZSBZanMgbW9kZWwgaW4gYSBzaW5nbGUgdHJhbnNhY3Rpb24gdG9cbiAqIG1pbmltaXplIHRoZSBudW1iZXIgb24gbWVzc2FnZXMgc2VudCBhbmQgdGhlIG51bWJlciBvZiBvYnNlcnZlciBjYWxscy5cbiAqIElmIHBvc3NpYmxlIHRoZSB1c2VyIG9mIHRoaXMgbGlicmFyeSBzaG91bGQgYnVuZGxlIGFzIG1hbnkgY2hhbmdlcyBhc1xuICogcG9zc2libGUuIEhlcmUgaXMgYW4gZXhhbXBsZSB0byBpbGx1c3RyYXRlIHRoZSBhZHZhbnRhZ2VzIG9mIGJ1bmRsaW5nOlxuICpcbiAqIEBleGFtcGxlXG4gKiBjb25zdCBtYXAgPSB5LmRlZmluZSgnbWFwJywgWU1hcClcbiAqIC8vIExvZyBjb250ZW50IHdoZW4gY2hhbmdlIGlzIHRyaWdnZXJlZFxuICogbWFwLm9ic2VydmUoKCkgPT4ge1xuICogICBjb25zb2xlLmxvZygnY2hhbmdlIHRyaWdnZXJlZCcpXG4gKiB9KVxuICogLy8gRWFjaCBjaGFuZ2Ugb24gdGhlIG1hcCB0eXBlIHRyaWdnZXJzIGEgbG9nIG1lc3NhZ2U6XG4gKiBtYXAuc2V0KCdhJywgMCkgLy8gPT4gXCJjaGFuZ2UgdHJpZ2dlcmVkXCJcbiAqIG1hcC5zZXQoJ2InLCAwKSAvLyA9PiBcImNoYW5nZSB0cmlnZ2VyZWRcIlxuICogLy8gV2hlbiBwdXQgaW4gYSB0cmFuc2FjdGlvbiwgaXQgd2lsbCB0cmlnZ2VyIHRoZSBsb2cgYWZ0ZXIgdGhlIHRyYW5zYWN0aW9uOlxuICogeS50cmFuc2FjdCgoKSA9PiB7XG4gKiAgIG1hcC5zZXQoJ2EnLCAxKVxuICogICBtYXAuc2V0KCdiJywgMSlcbiAqIH0pIC8vID0+IFwiY2hhbmdlIHRyaWdnZXJlZFwiXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY2xhc3MgVHJhbnNhY3Rpb24ge1xuICAvKipcbiAgICogQHBhcmFtIHtEb2N9IGRvY1xuICAgKiBAcGFyYW0ge2FueX0gb3JpZ2luXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gbG9jYWxcbiAgICovXG4gIGNvbnN0cnVjdG9yIChkb2MsIG9yaWdpbiwgbG9jYWwpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgWWpzIGluc3RhbmNlLlxuICAgICAqIEB0eXBlIHtEb2N9XG4gICAgICovXG4gICAgdGhpcy5kb2MgPSBkb2NcbiAgICAvKipcbiAgICAgKiBEZXNjcmliZXMgdGhlIHNldCBvZiBkZWxldGVkIGl0ZW1zIGJ5IGlkc1xuICAgICAqIEB0eXBlIHtEZWxldGVTZXR9XG4gICAgICovXG4gICAgdGhpcy5kZWxldGVTZXQgPSBuZXcgRGVsZXRlU2V0KClcbiAgICAvKipcbiAgICAgKiBIb2xkcyB0aGUgc3RhdGUgYmVmb3JlIHRoZSB0cmFuc2FjdGlvbiBzdGFydGVkLlxuICAgICAqIEB0eXBlIHtNYXA8TnVtYmVyLE51bWJlcj59XG4gICAgICovXG4gICAgdGhpcy5iZWZvcmVTdGF0ZSA9IGdldFN0YXRlVmVjdG9yKGRvYy5zdG9yZSlcbiAgICAvKipcbiAgICAgKiBIb2xkcyB0aGUgc3RhdGUgYWZ0ZXIgdGhlIHRyYW5zYWN0aW9uLlxuICAgICAqIEB0eXBlIHtNYXA8TnVtYmVyLE51bWJlcj59XG4gICAgICovXG4gICAgdGhpcy5hZnRlclN0YXRlID0gbmV3IE1hcCgpXG4gICAgLyoqXG4gICAgICogQWxsIHR5cGVzIHRoYXQgd2VyZSBkaXJlY3RseSBtb2RpZmllZCAocHJvcGVydHkgYWRkZWQgb3IgY2hpbGRcbiAgICAgKiBpbnNlcnRlZC9kZWxldGVkKS4gTmV3IHR5cGVzIGFyZSBub3QgaW5jbHVkZWQgaW4gdGhpcyBTZXQuXG4gICAgICogTWFwcyBmcm9tIHR5cGUgdG8gcGFyZW50U3VicyAoYGl0ZW0ucGFyZW50U3ViID0gbnVsbGAgZm9yIFlBcnJheSlcbiAgICAgKiBAdHlwZSB7TWFwPEFic3RyYWN0VHlwZTxZRXZlbnQ8YW55Pj4sU2V0PFN0cmluZ3xudWxsPj59XG4gICAgICovXG4gICAgdGhpcy5jaGFuZ2VkID0gbmV3IE1hcCgpXG4gICAgLyoqXG4gICAgICogU3RvcmVzIHRoZSBldmVudHMgZm9yIHRoZSB0eXBlcyB0aGF0IG9ic2VydmUgYWxzbyBjaGlsZCBlbGVtZW50cy5cbiAgICAgKiBJdCBpcyBtYWlubHkgdXNlZCBieSBgb2JzZXJ2ZURlZXBgLlxuICAgICAqIEB0eXBlIHtNYXA8QWJzdHJhY3RUeXBlPFlFdmVudDxhbnk+PixBcnJheTxZRXZlbnQ8YW55Pj4+fVxuICAgICAqL1xuICAgIHRoaXMuY2hhbmdlZFBhcmVudFR5cGVzID0gbmV3IE1hcCgpXG4gICAgLyoqXG4gICAgICogQHR5cGUge0FycmF5PEFic3RyYWN0U3RydWN0Pn1cbiAgICAgKi9cbiAgICB0aGlzLl9tZXJnZVN0cnVjdHMgPSBbXVxuICAgIC8qKlxuICAgICAqIEB0eXBlIHthbnl9XG4gICAgICovXG4gICAgdGhpcy5vcmlnaW4gPSBvcmlnaW5cbiAgICAvKipcbiAgICAgKiBTdG9yZXMgbWV0YSBpbmZvcm1hdGlvbiBvbiB0aGUgdHJhbnNhY3Rpb25cbiAgICAgKiBAdHlwZSB7TWFwPGFueSxhbnk+fVxuICAgICAqL1xuICAgIHRoaXMubWV0YSA9IG5ldyBNYXAoKVxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhpcyBjaGFuZ2Ugb3JpZ2luYXRlcyBmcm9tIHRoaXMgZG9jLlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMubG9jYWwgPSBsb2NhbFxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtTZXQ8RG9jPn1cbiAgICAgKi9cbiAgICB0aGlzLnN1YmRvY3NBZGRlZCA9IG5ldyBTZXQoKVxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtTZXQ8RG9jPn1cbiAgICAgKi9cbiAgICB0aGlzLnN1YmRvY3NSZW1vdmVkID0gbmV3IFNldCgpXG4gICAgLyoqXG4gICAgICogQHR5cGUge1NldDxEb2M+fVxuICAgICAqL1xuICAgIHRoaXMuc3ViZG9jc0xvYWRlZCA9IG5ldyBTZXQoKVxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuX25lZWRGb3JtYXR0aW5nQ2xlYW51cCA9IGZhbHNlXG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1VwZGF0ZUVuY29kZXJWMSB8IFVwZGF0ZUVuY29kZXJWMn0gZW5jb2RlclxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgZGF0YSB3YXMgd3JpdHRlbi5cbiAqL1xuZXhwb3J0IGNvbnN0IHdyaXRlVXBkYXRlTWVzc2FnZUZyb21UcmFuc2FjdGlvbiA9IChlbmNvZGVyLCB0cmFuc2FjdGlvbikgPT4ge1xuICBpZiAodHJhbnNhY3Rpb24uZGVsZXRlU2V0LmNsaWVudHMuc2l6ZSA9PT0gMCAmJiAhbWFwLmFueSh0cmFuc2FjdGlvbi5hZnRlclN0YXRlLCAoY2xvY2ssIGNsaWVudCkgPT4gdHJhbnNhY3Rpb24uYmVmb3JlU3RhdGUuZ2V0KGNsaWVudCkgIT09IGNsb2NrKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIHNvcnRBbmRNZXJnZURlbGV0ZVNldCh0cmFuc2FjdGlvbi5kZWxldGVTZXQpXG4gIHdyaXRlU3RydWN0c0Zyb21UcmFuc2FjdGlvbihlbmNvZGVyLCB0cmFuc2FjdGlvbilcbiAgd3JpdGVEZWxldGVTZXQoZW5jb2RlciwgdHJhbnNhY3Rpb24uZGVsZXRlU2V0KVxuICByZXR1cm4gdHJ1ZVxufVxuXG4vKipcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgbmV4dElEID0gdHJhbnNhY3Rpb24gPT4ge1xuICBjb25zdCB5ID0gdHJhbnNhY3Rpb24uZG9jXG4gIHJldHVybiBjcmVhdGVJRCh5LmNsaWVudElELCBnZXRTdGF0ZSh5LnN0b3JlLCB5LmNsaWVudElEKSlcbn1cblxuLyoqXG4gKiBJZiBgdHlwZS5wYXJlbnRgIHdhcyBhZGRlZCBpbiBjdXJyZW50IHRyYW5zYWN0aW9uLCBgdHlwZWAgdGVjaG5pY2FsbHlcbiAqIGRpZCBub3QgY2hhbmdlLCBpdCB3YXMganVzdCBhZGRlZCBhbmQgd2Ugc2hvdWxkIG5vdCBmaXJlIGV2ZW50cyBmb3IgYHR5cGVgLlxuICpcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxZRXZlbnQ8YW55Pj59IHR5cGVcbiAqIEBwYXJhbSB7c3RyaW5nfG51bGx9IHBhcmVudFN1YlxuICovXG5leHBvcnQgY29uc3QgYWRkQ2hhbmdlZFR5cGVUb1RyYW5zYWN0aW9uID0gKHRyYW5zYWN0aW9uLCB0eXBlLCBwYXJlbnRTdWIpID0+IHtcbiAgY29uc3QgaXRlbSA9IHR5cGUuX2l0ZW1cbiAgaWYgKGl0ZW0gPT09IG51bGwgfHwgKGl0ZW0uaWQuY2xvY2sgPCAodHJhbnNhY3Rpb24uYmVmb3JlU3RhdGUuZ2V0KGl0ZW0uaWQuY2xpZW50KSB8fCAwKSAmJiAhaXRlbS5kZWxldGVkKSkge1xuICAgIG1hcC5zZXRJZlVuZGVmaW5lZCh0cmFuc2FjdGlvbi5jaGFuZ2VkLCB0eXBlLCBzZXQuY3JlYXRlKS5hZGQocGFyZW50U3ViKVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxBYnN0cmFjdFN0cnVjdD59IHN0cnVjdHNcbiAqIEBwYXJhbSB7bnVtYmVyfSBwb3NcbiAqIEByZXR1cm4ge251bWJlcn0gIyBvZiBtZXJnZWQgc3RydWN0c1xuICovXG5jb25zdCB0cnlUb01lcmdlV2l0aExlZnRzID0gKHN0cnVjdHMsIHBvcykgPT4ge1xuICBsZXQgcmlnaHQgPSBzdHJ1Y3RzW3Bvc11cbiAgbGV0IGxlZnQgPSBzdHJ1Y3RzW3BvcyAtIDFdXG4gIGxldCBpID0gcG9zXG4gIGZvciAoOyBpID4gMDsgcmlnaHQgPSBsZWZ0LCBsZWZ0ID0gc3RydWN0c1stLWkgLSAxXSkge1xuICAgIGlmIChsZWZ0LmRlbGV0ZWQgPT09IHJpZ2h0LmRlbGV0ZWQgJiYgbGVmdC5jb25zdHJ1Y3RvciA9PT0gcmlnaHQuY29uc3RydWN0b3IpIHtcbiAgICAgIGlmIChsZWZ0Lm1lcmdlV2l0aChyaWdodCkpIHtcbiAgICAgICAgaWYgKHJpZ2h0IGluc3RhbmNlb2YgSXRlbSAmJiByaWdodC5wYXJlbnRTdWIgIT09IG51bGwgJiYgLyoqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55Pn0gKi8gKHJpZ2h0LnBhcmVudCkuX21hcC5nZXQocmlnaHQucGFyZW50U3ViKSA9PT0gcmlnaHQpIHtcbiAgICAgICAgICAvKiogQHR5cGUge0Fic3RyYWN0VHlwZTxhbnk+fSAqLyAocmlnaHQucGFyZW50KS5fbWFwLnNldChyaWdodC5wYXJlbnRTdWIsIC8qKiBAdHlwZSB7SXRlbX0gKi8gKGxlZnQpKVxuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG4gICAgfVxuICAgIGJyZWFrXG4gIH1cbiAgY29uc3QgbWVyZ2VkID0gcG9zIC0gaVxuICBpZiAobWVyZ2VkKSB7XG4gICAgLy8gcmVtb3ZlIGFsbCBtZXJnZWQgc3RydWN0cyBmcm9tIHRoZSBhcnJheVxuICAgIHN0cnVjdHMuc3BsaWNlKHBvcyArIDEgLSBtZXJnZWQsIG1lcmdlZClcbiAgfVxuICByZXR1cm4gbWVyZ2VkXG59XG5cbi8qKlxuICogQHBhcmFtIHtEZWxldGVTZXR9IGRzXG4gKiBAcGFyYW0ge1N0cnVjdFN0b3JlfSBzdG9yZVxuICogQHBhcmFtIHtmdW5jdGlvbihJdGVtKTpib29sZWFufSBnY0ZpbHRlclxuICovXG5jb25zdCB0cnlHY0RlbGV0ZVNldCA9IChkcywgc3RvcmUsIGdjRmlsdGVyKSA9PiB7XG4gIGZvciAoY29uc3QgW2NsaWVudCwgZGVsZXRlSXRlbXNdIG9mIGRzLmNsaWVudHMuZW50cmllcygpKSB7XG4gICAgY29uc3Qgc3RydWN0cyA9IC8qKiBAdHlwZSB7QXJyYXk8R0N8SXRlbT59ICovIChzdG9yZS5jbGllbnRzLmdldChjbGllbnQpKVxuICAgIGZvciAobGV0IGRpID0gZGVsZXRlSXRlbXMubGVuZ3RoIC0gMTsgZGkgPj0gMDsgZGktLSkge1xuICAgICAgY29uc3QgZGVsZXRlSXRlbSA9IGRlbGV0ZUl0ZW1zW2RpXVxuICAgICAgY29uc3QgZW5kRGVsZXRlSXRlbUNsb2NrID0gZGVsZXRlSXRlbS5jbG9jayArIGRlbGV0ZUl0ZW0ubGVuXG4gICAgICBmb3IgKFxuICAgICAgICBsZXQgc2kgPSBmaW5kSW5kZXhTUyhzdHJ1Y3RzLCBkZWxldGVJdGVtLmNsb2NrKSwgc3RydWN0ID0gc3RydWN0c1tzaV07XG4gICAgICAgIHNpIDwgc3RydWN0cy5sZW5ndGggJiYgc3RydWN0LmlkLmNsb2NrIDwgZW5kRGVsZXRlSXRlbUNsb2NrO1xuICAgICAgICBzdHJ1Y3QgPSBzdHJ1Y3RzWysrc2ldXG4gICAgICApIHtcbiAgICAgICAgY29uc3Qgc3RydWN0ID0gc3RydWN0c1tzaV1cbiAgICAgICAgaWYgKGRlbGV0ZUl0ZW0uY2xvY2sgKyBkZWxldGVJdGVtLmxlbiA8PSBzdHJ1Y3QuaWQuY2xvY2spIHtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdHJ1Y3QgaW5zdGFuY2VvZiBJdGVtICYmIHN0cnVjdC5kZWxldGVkICYmICFzdHJ1Y3Qua2VlcCAmJiBnY0ZpbHRlcihzdHJ1Y3QpKSB7XG4gICAgICAgICAgc3RydWN0LmdjKHN0b3JlLCBmYWxzZSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7RGVsZXRlU2V0fSBkc1xuICogQHBhcmFtIHtTdHJ1Y3RTdG9yZX0gc3RvcmVcbiAqL1xuY29uc3QgdHJ5TWVyZ2VEZWxldGVTZXQgPSAoZHMsIHN0b3JlKSA9PiB7XG4gIC8vIHRyeSB0byBtZXJnZSBkZWxldGVkIC8gZ2MnZCBpdGVtc1xuICAvLyBtZXJnZSBmcm9tIHJpZ2h0IHRvIGxlZnQgZm9yIGJldHRlciBlZmZpY2llY3kgYW5kIHNvIHdlIGRvbid0IG1pc3MgYW55IG1lcmdlIHRhcmdldHNcbiAgZHMuY2xpZW50cy5mb3JFYWNoKChkZWxldGVJdGVtcywgY2xpZW50KSA9PiB7XG4gICAgY29uc3Qgc3RydWN0cyA9IC8qKiBAdHlwZSB7QXJyYXk8R0N8SXRlbT59ICovIChzdG9yZS5jbGllbnRzLmdldChjbGllbnQpKVxuICAgIGZvciAobGV0IGRpID0gZGVsZXRlSXRlbXMubGVuZ3RoIC0gMTsgZGkgPj0gMDsgZGktLSkge1xuICAgICAgY29uc3QgZGVsZXRlSXRlbSA9IGRlbGV0ZUl0ZW1zW2RpXVxuICAgICAgLy8gc3RhcnQgd2l0aCBtZXJnaW5nIHRoZSBpdGVtIG5leHQgdG8gdGhlIGxhc3QgZGVsZXRlZCBpdGVtXG4gICAgICBjb25zdCBtb3N0UmlnaHRJbmRleFRvQ2hlY2sgPSBtYXRoLm1pbihzdHJ1Y3RzLmxlbmd0aCAtIDEsIDEgKyBmaW5kSW5kZXhTUyhzdHJ1Y3RzLCBkZWxldGVJdGVtLmNsb2NrICsgZGVsZXRlSXRlbS5sZW4gLSAxKSlcbiAgICAgIGZvciAoXG4gICAgICAgIGxldCBzaSA9IG1vc3RSaWdodEluZGV4VG9DaGVjaywgc3RydWN0ID0gc3RydWN0c1tzaV07XG4gICAgICAgIHNpID4gMCAmJiBzdHJ1Y3QuaWQuY2xvY2sgPj0gZGVsZXRlSXRlbS5jbG9jaztcbiAgICAgICAgc3RydWN0ID0gc3RydWN0c1tzaV1cbiAgICAgICkge1xuICAgICAgICBzaSAtPSAxICsgdHJ5VG9NZXJnZVdpdGhMZWZ0cyhzdHJ1Y3RzLCBzaSlcbiAgICAgIH1cbiAgICB9XG4gIH0pXG59XG5cbi8qKlxuICogQHBhcmFtIHtEZWxldGVTZXR9IGRzXG4gKiBAcGFyYW0ge1N0cnVjdFN0b3JlfSBzdG9yZVxuICogQHBhcmFtIHtmdW5jdGlvbihJdGVtKTpib29sZWFufSBnY0ZpbHRlclxuICovXG5leHBvcnQgY29uc3QgdHJ5R2MgPSAoZHMsIHN0b3JlLCBnY0ZpbHRlcikgPT4ge1xuICB0cnlHY0RlbGV0ZVNldChkcywgc3RvcmUsIGdjRmlsdGVyKVxuICB0cnlNZXJnZURlbGV0ZVNldChkcywgc3RvcmUpXG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxUcmFuc2FjdGlvbj59IHRyYW5zYWN0aW9uQ2xlYW51cHNcbiAqIEBwYXJhbSB7bnVtYmVyfSBpXG4gKi9cbmNvbnN0IGNsZWFudXBUcmFuc2FjdGlvbnMgPSAodHJhbnNhY3Rpb25DbGVhbnVwcywgaSkgPT4ge1xuICBpZiAoaSA8IHRyYW5zYWN0aW9uQ2xlYW51cHMubGVuZ3RoKSB7XG4gICAgY29uc3QgdHJhbnNhY3Rpb24gPSB0cmFuc2FjdGlvbkNsZWFudXBzW2ldXG4gICAgY29uc3QgZG9jID0gdHJhbnNhY3Rpb24uZG9jXG4gICAgY29uc3Qgc3RvcmUgPSBkb2Muc3RvcmVcbiAgICBjb25zdCBkcyA9IHRyYW5zYWN0aW9uLmRlbGV0ZVNldFxuICAgIGNvbnN0IG1lcmdlU3RydWN0cyA9IHRyYW5zYWN0aW9uLl9tZXJnZVN0cnVjdHNcbiAgICB0cnkge1xuICAgICAgc29ydEFuZE1lcmdlRGVsZXRlU2V0KGRzKVxuICAgICAgdHJhbnNhY3Rpb24uYWZ0ZXJTdGF0ZSA9IGdldFN0YXRlVmVjdG9yKHRyYW5zYWN0aW9uLmRvYy5zdG9yZSlcbiAgICAgIGRvYy5lbWl0KCdiZWZvcmVPYnNlcnZlckNhbGxzJywgW3RyYW5zYWN0aW9uLCBkb2NdKVxuICAgICAgLyoqXG4gICAgICAgKiBBbiBhcnJheSBvZiBldmVudCBjYWxsYmFja3MuXG4gICAgICAgKlxuICAgICAgICogRWFjaCBjYWxsYmFjayBpcyBjYWxsZWQgZXZlbiBpZiB0aGUgb3RoZXIgb25lcyB0aHJvdyBlcnJvcnMuXG4gICAgICAgKlxuICAgICAgICogQHR5cGUge0FycmF5PGZ1bmN0aW9uKCk6dm9pZD59XG4gICAgICAgKi9cbiAgICAgIGNvbnN0IGZzID0gW11cbiAgICAgIC8vIG9ic2VydmUgZXZlbnRzIG9uIGNoYW5nZWQgdHlwZXNcbiAgICAgIHRyYW5zYWN0aW9uLmNoYW5nZWQuZm9yRWFjaCgoc3VicywgaXRlbXR5cGUpID0+XG4gICAgICAgIGZzLnB1c2goKCkgPT4ge1xuICAgICAgICAgIGlmIChpdGVtdHlwZS5faXRlbSA9PT0gbnVsbCB8fCAhaXRlbXR5cGUuX2l0ZW0uZGVsZXRlZCkge1xuICAgICAgICAgICAgaXRlbXR5cGUuX2NhbGxPYnNlcnZlcih0cmFuc2FjdGlvbiwgc3VicylcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICApXG4gICAgICBmcy5wdXNoKCgpID0+IHtcbiAgICAgICAgLy8gZGVlcCBvYnNlcnZlIGV2ZW50c1xuICAgICAgICB0cmFuc2FjdGlvbi5jaGFuZ2VkUGFyZW50VHlwZXMuZm9yRWFjaCgoZXZlbnRzLCB0eXBlKSA9PiB7XG4gICAgICAgICAgLy8gV2UgbmVlZCB0byB0aGluayBhYm91dCB0aGUgcG9zc2liaWxpdHkgdGhhdCB0aGUgdXNlciB0cmFuc2Zvcm1zIHRoZVxuICAgICAgICAgIC8vIFkuRG9jIGluIHRoZSBldmVudC5cbiAgICAgICAgICBpZiAodHlwZS5fZEVILmwubGVuZ3RoID4gMCAmJiAodHlwZS5faXRlbSA9PT0gbnVsbCB8fCAhdHlwZS5faXRlbS5kZWxldGVkKSkge1xuICAgICAgICAgICAgZXZlbnRzID0gZXZlbnRzXG4gICAgICAgICAgICAgIC5maWx0ZXIoZXZlbnQgPT5cbiAgICAgICAgICAgICAgICBldmVudC50YXJnZXQuX2l0ZW0gPT09IG51bGwgfHwgIWV2ZW50LnRhcmdldC5faXRlbS5kZWxldGVkXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIGV2ZW50c1xuICAgICAgICAgICAgICAuZm9yRWFjaChldmVudCA9PiB7XG4gICAgICAgICAgICAgICAgZXZlbnQuY3VycmVudFRhcmdldCA9IHR5cGVcbiAgICAgICAgICAgICAgICAvLyBwYXRoIGlzIHJlbGF0aXZlIHRvIHRoZSBjdXJyZW50IHRhcmdldFxuICAgICAgICAgICAgICAgIGV2ZW50Ll9wYXRoID0gbnVsbFxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgLy8gc29ydCBldmVudHMgYnkgcGF0aCBsZW5ndGggc28gdGhhdCB0b3AtbGV2ZWwgZXZlbnRzIGFyZSBmaXJlZCBmaXJzdC5cbiAgICAgICAgICAgIGV2ZW50c1xuICAgICAgICAgICAgICAuc29ydCgoZXZlbnQxLCBldmVudDIpID0+IGV2ZW50MS5wYXRoLmxlbmd0aCAtIGV2ZW50Mi5wYXRoLmxlbmd0aClcbiAgICAgICAgICAgIC8vIFdlIGRvbid0IG5lZWQgdG8gY2hlY2sgZm9yIGV2ZW50cy5sZW5ndGhcbiAgICAgICAgICAgIC8vIGJlY2F1c2Ugd2Uga25vdyBpdCBoYXMgYXQgbGVhc3Qgb25lIGVsZW1lbnRcbiAgICAgICAgICAgIGNhbGxFdmVudEhhbmRsZXJMaXN0ZW5lcnModHlwZS5fZEVILCBldmVudHMsIHRyYW5zYWN0aW9uKVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgICBmcy5wdXNoKCgpID0+IGRvYy5lbWl0KCdhZnRlclRyYW5zYWN0aW9uJywgW3RyYW5zYWN0aW9uLCBkb2NdKSlcbiAgICAgIGNhbGxBbGwoZnMsIFtdKVxuICAgICAgaWYgKHRyYW5zYWN0aW9uLl9uZWVkRm9ybWF0dGluZ0NsZWFudXApIHtcbiAgICAgICAgY2xlYW51cFlUZXh0QWZ0ZXJUcmFuc2FjdGlvbih0cmFuc2FjdGlvbilcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgLy8gUmVwbGFjZSBkZWxldGVkIGl0ZW1zIHdpdGggSXRlbURlbGV0ZWQgLyBHQy5cbiAgICAgIC8vIFRoaXMgaXMgd2hlcmUgY29udGVudCBpcyBhY3R1YWxseSByZW1vdmUgZnJvbSB0aGUgWWpzIERvYy5cbiAgICAgIGlmIChkb2MuZ2MpIHtcbiAgICAgICAgdHJ5R2NEZWxldGVTZXQoZHMsIHN0b3JlLCBkb2MuZ2NGaWx0ZXIpXG4gICAgICB9XG4gICAgICB0cnlNZXJnZURlbGV0ZVNldChkcywgc3RvcmUpXG5cbiAgICAgIC8vIG9uIGFsbCBhZmZlY3RlZCBzdG9yZS5jbGllbnRzIHByb3BzLCB0cnkgdG8gbWVyZ2VcbiAgICAgIHRyYW5zYWN0aW9uLmFmdGVyU3RhdGUuZm9yRWFjaCgoY2xvY2ssIGNsaWVudCkgPT4ge1xuICAgICAgICBjb25zdCBiZWZvcmVDbG9jayA9IHRyYW5zYWN0aW9uLmJlZm9yZVN0YXRlLmdldChjbGllbnQpIHx8IDBcbiAgICAgICAgaWYgKGJlZm9yZUNsb2NrICE9PSBjbG9jaykge1xuICAgICAgICAgIGNvbnN0IHN0cnVjdHMgPSAvKiogQHR5cGUge0FycmF5PEdDfEl0ZW0+fSAqLyAoc3RvcmUuY2xpZW50cy5nZXQoY2xpZW50KSlcbiAgICAgICAgICAvLyB3ZSBpdGVyYXRlIGZyb20gcmlnaHQgdG8gbGVmdCBzbyB3ZSBjYW4gc2FmZWx5IHJlbW92ZSBlbnRyaWVzXG4gICAgICAgICAgY29uc3QgZmlyc3RDaGFuZ2VQb3MgPSBtYXRoLm1heChmaW5kSW5kZXhTUyhzdHJ1Y3RzLCBiZWZvcmVDbG9jayksIDEpXG4gICAgICAgICAgZm9yIChsZXQgaSA9IHN0cnVjdHMubGVuZ3RoIC0gMTsgaSA+PSBmaXJzdENoYW5nZVBvczspIHtcbiAgICAgICAgICAgIGkgLT0gMSArIHRyeVRvTWVyZ2VXaXRoTGVmdHMoc3RydWN0cywgaSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICAvLyB0cnkgdG8gbWVyZ2UgbWVyZ2VTdHJ1Y3RzXG4gICAgICAvLyBAdG9kbzogaXQgbWFrZXMgbW9yZSBzZW5zZSB0byB0cmFuc2Zvcm0gbWVyZ2VTdHJ1Y3RzIHRvIGEgRFMsIHNvcnQgaXQsIGFuZCBtZXJnZSBmcm9tIHJpZ2h0IHRvIGxlZnRcbiAgICAgIC8vICAgICAgICBidXQgYXQgdGhlIG1vbWVudCBEUyBkb2VzIG5vdCBoYW5kbGUgZHVwbGljYXRlc1xuICAgICAgZm9yIChsZXQgaSA9IG1lcmdlU3RydWN0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBjb25zdCB7IGNsaWVudCwgY2xvY2sgfSA9IG1lcmdlU3RydWN0c1tpXS5pZFxuICAgICAgICBjb25zdCBzdHJ1Y3RzID0gLyoqIEB0eXBlIHtBcnJheTxHQ3xJdGVtPn0gKi8gKHN0b3JlLmNsaWVudHMuZ2V0KGNsaWVudCkpXG4gICAgICAgIGNvbnN0IHJlcGxhY2VkU3RydWN0UG9zID0gZmluZEluZGV4U1Moc3RydWN0cywgY2xvY2spXG4gICAgICAgIGlmIChyZXBsYWNlZFN0cnVjdFBvcyArIDEgPCBzdHJ1Y3RzLmxlbmd0aCkge1xuICAgICAgICAgIGlmICh0cnlUb01lcmdlV2l0aExlZnRzKHN0cnVjdHMsIHJlcGxhY2VkU3RydWN0UG9zICsgMSkgPiAxKSB7XG4gICAgICAgICAgICBjb250aW51ZSAvLyBubyBuZWVkIHRvIHBlcmZvcm0gbmV4dCBjaGVjaywgYm90aCBhcmUgYWxyZWFkeSBtZXJnZWRcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlcGxhY2VkU3RydWN0UG9zID4gMCkge1xuICAgICAgICAgIHRyeVRvTWVyZ2VXaXRoTGVmdHMoc3RydWN0cywgcmVwbGFjZWRTdHJ1Y3RQb3MpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghdHJhbnNhY3Rpb24ubG9jYWwgJiYgdHJhbnNhY3Rpb24uYWZ0ZXJTdGF0ZS5nZXQoZG9jLmNsaWVudElEKSAhPT0gdHJhbnNhY3Rpb24uYmVmb3JlU3RhdGUuZ2V0KGRvYy5jbGllbnRJRCkpIHtcbiAgICAgICAgbG9nZ2luZy5wcmludChsb2dnaW5nLk9SQU5HRSwgbG9nZ2luZy5CT0xELCAnW3lqc10gJywgbG9nZ2luZy5VTkJPTEQsIGxvZ2dpbmcuUkVELCAnQ2hhbmdlZCB0aGUgY2xpZW50LWlkIGJlY2F1c2UgYW5vdGhlciBjbGllbnQgc2VlbXMgdG8gYmUgdXNpbmcgaXQuJylcbiAgICAgICAgZG9jLmNsaWVudElEID0gZ2VuZXJhdGVOZXdDbGllbnRJZCgpXG4gICAgICB9XG4gICAgICAvLyBAdG9kbyBNZXJnZSBhbGwgdGhlIHRyYW5zYWN0aW9ucyBpbnRvIG9uZSBhbmQgcHJvdmlkZSBzZW5kIHRoZSBkYXRhIGFzIGEgc2luZ2xlIHVwZGF0ZSBtZXNzYWdlXG4gICAgICBkb2MuZW1pdCgnYWZ0ZXJUcmFuc2FjdGlvbkNsZWFudXAnLCBbdHJhbnNhY3Rpb24sIGRvY10pXG4gICAgICBpZiAoZG9jLl9vYnNlcnZlcnMuaGFzKCd1cGRhdGUnKSkge1xuICAgICAgICBjb25zdCBlbmNvZGVyID0gbmV3IFVwZGF0ZUVuY29kZXJWMSgpXG4gICAgICAgIGNvbnN0IGhhc0NvbnRlbnQgPSB3cml0ZVVwZGF0ZU1lc3NhZ2VGcm9tVHJhbnNhY3Rpb24oZW5jb2RlciwgdHJhbnNhY3Rpb24pXG4gICAgICAgIGlmIChoYXNDb250ZW50KSB7XG4gICAgICAgICAgZG9jLmVtaXQoJ3VwZGF0ZScsIFtlbmNvZGVyLnRvVWludDhBcnJheSgpLCB0cmFuc2FjdGlvbi5vcmlnaW4sIGRvYywgdHJhbnNhY3Rpb25dKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZG9jLl9vYnNlcnZlcnMuaGFzKCd1cGRhdGVWMicpKSB7XG4gICAgICAgIGNvbnN0IGVuY29kZXIgPSBuZXcgVXBkYXRlRW5jb2RlclYyKClcbiAgICAgICAgY29uc3QgaGFzQ29udGVudCA9IHdyaXRlVXBkYXRlTWVzc2FnZUZyb21UcmFuc2FjdGlvbihlbmNvZGVyLCB0cmFuc2FjdGlvbilcbiAgICAgICAgaWYgKGhhc0NvbnRlbnQpIHtcbiAgICAgICAgICBkb2MuZW1pdCgndXBkYXRlVjInLCBbZW5jb2Rlci50b1VpbnQ4QXJyYXkoKSwgdHJhbnNhY3Rpb24ub3JpZ2luLCBkb2MsIHRyYW5zYWN0aW9uXSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgeyBzdWJkb2NzQWRkZWQsIHN1YmRvY3NMb2FkZWQsIHN1YmRvY3NSZW1vdmVkIH0gPSB0cmFuc2FjdGlvblxuICAgICAgaWYgKHN1YmRvY3NBZGRlZC5zaXplID4gMCB8fCBzdWJkb2NzUmVtb3ZlZC5zaXplID4gMCB8fCBzdWJkb2NzTG9hZGVkLnNpemUgPiAwKSB7XG4gICAgICAgIHN1YmRvY3NBZGRlZC5mb3JFYWNoKHN1YmRvYyA9PiB7XG4gICAgICAgICAgc3ViZG9jLmNsaWVudElEID0gZG9jLmNsaWVudElEXG4gICAgICAgICAgaWYgKHN1YmRvYy5jb2xsZWN0aW9uaWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgc3ViZG9jLmNvbGxlY3Rpb25pZCA9IGRvYy5jb2xsZWN0aW9uaWRcbiAgICAgICAgICB9XG4gICAgICAgICAgZG9jLnN1YmRvY3MuYWRkKHN1YmRvYylcbiAgICAgICAgfSlcbiAgICAgICAgc3ViZG9jc1JlbW92ZWQuZm9yRWFjaChzdWJkb2MgPT4gZG9jLnN1YmRvY3MuZGVsZXRlKHN1YmRvYykpXG4gICAgICAgIGRvYy5lbWl0KCdzdWJkb2NzJywgW3sgbG9hZGVkOiBzdWJkb2NzTG9hZGVkLCBhZGRlZDogc3ViZG9jc0FkZGVkLCByZW1vdmVkOiBzdWJkb2NzUmVtb3ZlZCB9LCBkb2MsIHRyYW5zYWN0aW9uXSlcbiAgICAgICAgc3ViZG9jc1JlbW92ZWQuZm9yRWFjaChzdWJkb2MgPT4gc3ViZG9jLmRlc3Ryb3koKSlcbiAgICAgIH1cblxuICAgICAgaWYgKHRyYW5zYWN0aW9uQ2xlYW51cHMubGVuZ3RoIDw9IGkgKyAxKSB7XG4gICAgICAgIGRvYy5fdHJhbnNhY3Rpb25DbGVhbnVwcyA9IFtdXG4gICAgICAgIGRvYy5lbWl0KCdhZnRlckFsbFRyYW5zYWN0aW9ucycsIFtkb2MsIHRyYW5zYWN0aW9uQ2xlYW51cHNdKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2xlYW51cFRyYW5zYWN0aW9ucyh0cmFuc2FjdGlvbkNsZWFudXBzLCBpICsgMSlcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBJbXBsZW1lbnRzIHRoZSBmdW5jdGlvbmFsaXR5IG9mIGB5LnRyYW5zYWN0KCgpPT57Li59KWBcbiAqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtEb2N9IGRvY1xuICogQHBhcmFtIHtmdW5jdGlvbihUcmFuc2FjdGlvbik6VH0gZlxuICogQHBhcmFtIHthbnl9IFtvcmlnaW49dHJ1ZV1cbiAqIEByZXR1cm4ge1R9XG4gKlxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCB0cmFuc2FjdCA9IChkb2MsIGYsIG9yaWdpbiA9IG51bGwsIGxvY2FsID0gdHJ1ZSkgPT4ge1xuICBjb25zdCB0cmFuc2FjdGlvbkNsZWFudXBzID0gZG9jLl90cmFuc2FjdGlvbkNsZWFudXBzXG4gIGxldCBpbml0aWFsQ2FsbCA9IGZhbHNlXG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgbGV0IHJlc3VsdCA9IG51bGxcbiAgaWYgKGRvYy5fdHJhbnNhY3Rpb24gPT09IG51bGwpIHtcbiAgICBpbml0aWFsQ2FsbCA9IHRydWVcbiAgICBkb2MuX3RyYW5zYWN0aW9uID0gbmV3IFRyYW5zYWN0aW9uKGRvYywgb3JpZ2luLCBsb2NhbClcbiAgICB0cmFuc2FjdGlvbkNsZWFudXBzLnB1c2goZG9jLl90cmFuc2FjdGlvbilcbiAgICBpZiAodHJhbnNhY3Rpb25DbGVhbnVwcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGRvYy5lbWl0KCdiZWZvcmVBbGxUcmFuc2FjdGlvbnMnLCBbZG9jXSlcbiAgICB9XG4gICAgZG9jLmVtaXQoJ2JlZm9yZVRyYW5zYWN0aW9uJywgW2RvYy5fdHJhbnNhY3Rpb24sIGRvY10pXG4gIH1cbiAgdHJ5IHtcbiAgICByZXN1bHQgPSBmKGRvYy5fdHJhbnNhY3Rpb24pXG4gIH0gZmluYWxseSB7XG4gICAgaWYgKGluaXRpYWxDYWxsKSB7XG4gICAgICBjb25zdCBmaW5pc2hDbGVhbnVwID0gZG9jLl90cmFuc2FjdGlvbiA9PT0gdHJhbnNhY3Rpb25DbGVhbnVwc1swXVxuICAgICAgZG9jLl90cmFuc2FjdGlvbiA9IG51bGxcbiAgICAgIGlmIChmaW5pc2hDbGVhbnVwKSB7XG4gICAgICAgIC8vIFRoZSBmaXJzdCB0cmFuc2FjdGlvbiBlbmRlZCwgbm93IHByb2Nlc3Mgb2JzZXJ2ZXIgY2FsbHMuXG4gICAgICAgIC8vIE9ic2VydmVyIGNhbGwgbWF5IGNyZWF0ZSBuZXcgdHJhbnNhY3Rpb25zIGZvciB3aGljaCB3ZSBuZWVkIHRvIGNhbGwgdGhlIG9ic2VydmVycyBhbmQgZG8gY2xlYW51cC5cbiAgICAgICAgLy8gV2UgZG9uJ3Qgd2FudCB0byBuZXN0IHRoZXNlIGNhbGxzLCBzbyB3ZSBleGVjdXRlIHRoZXNlIGNhbGxzIG9uZSBhZnRlclxuICAgICAgICAvLyBhbm90aGVyLlxuICAgICAgICAvLyBBbHNvIHdlIG5lZWQgdG8gZW5zdXJlIHRoYXQgYWxsIGNsZWFudXBzIGFyZSBjYWxsZWQsIGV2ZW4gaWYgdGhlXG4gICAgICAgIC8vIG9ic2VydmVzIHRocm93IGVycm9ycy5cbiAgICAgICAgLy8gVGhpcyBmaWxlIGlzIGZ1bGwgb2YgaGFja3kgdHJ5IHt9IGZpbmFsbHkge30gYmxvY2tzIHRvIGVuc3VyZSB0aGF0IGFuXG4gICAgICAgIC8vIGV2ZW50IGNhbiB0aHJvdyBlcnJvcnMgYW5kIGFsc28gdGhhdCB0aGUgY2xlYW51cCBpcyBjYWxsZWQuXG4gICAgICAgIGNsZWFudXBUcmFuc2FjdGlvbnModHJhbnNhY3Rpb25DbGVhbnVwcywgMClcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdFxufVxuIiwgImltcG9ydCB7XG4gIG1lcmdlRGVsZXRlU2V0cyxcbiAgaXRlcmF0ZURlbGV0ZWRTdHJ1Y3RzLFxuICBrZWVwSXRlbSxcbiAgdHJhbnNhY3QsXG4gIGNyZWF0ZUlELFxuICByZWRvSXRlbSxcbiAgaXNQYXJlbnRPZixcbiAgZm9sbG93UmVkb25lLFxuICBnZXRJdGVtQ2xlYW5TdGFydCxcbiAgaXNEZWxldGVkLFxuICBhZGRUb0RlbGV0ZVNldCxcbiAgVHJhbnNhY3Rpb24sIERvYywgSXRlbSwgR0MsIERlbGV0ZVNldCwgQWJzdHJhY3RUeXBlIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbn0gZnJvbSAnLi4vaW50ZXJuYWxzLmpzJ1xuXG5pbXBvcnQgKiBhcyB0aW1lIGZyb20gJ2xpYjAvdGltZSdcbmltcG9ydCAqIGFzIGFycmF5IGZyb20gJ2xpYjAvYXJyYXknXG5pbXBvcnQgKiBhcyBsb2dnaW5nIGZyb20gJ2xpYjAvbG9nZ2luZydcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdsaWIwL29ic2VydmFibGUnXG5cbmV4cG9ydCBjbGFzcyBTdGFja0l0ZW0ge1xuICAvKipcbiAgICogQHBhcmFtIHtEZWxldGVTZXR9IGRlbGV0aW9uc1xuICAgKiBAcGFyYW0ge0RlbGV0ZVNldH0gaW5zZXJ0aW9uc1xuICAgKi9cbiAgY29uc3RydWN0b3IgKGRlbGV0aW9ucywgaW5zZXJ0aW9ucykge1xuICAgIHRoaXMuaW5zZXJ0aW9ucyA9IGluc2VydGlvbnNcbiAgICB0aGlzLmRlbGV0aW9ucyA9IGRlbGV0aW9uc1xuICAgIC8qKlxuICAgICAqIFVzZSB0aGlzIHRvIHNhdmUgYW5kIHJlc3RvcmUgbWV0YWRhdGEgbGlrZSBzZWxlY3Rpb24gcmFuZ2VcbiAgICAgKi9cbiAgICB0aGlzLm1ldGEgPSBuZXcgTWFwKClcbiAgfVxufVxuLyoqXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0clxuICogQHBhcmFtIHtVbmRvTWFuYWdlcn0gdW1cbiAqIEBwYXJhbSB7U3RhY2tJdGVtfSBzdGFja0l0ZW1cbiAqL1xuY29uc3QgY2xlYXJVbmRvTWFuYWdlclN0YWNrSXRlbSA9ICh0ciwgdW0sIHN0YWNrSXRlbSkgPT4ge1xuICBpdGVyYXRlRGVsZXRlZFN0cnVjdHModHIsIHN0YWNrSXRlbS5kZWxldGlvbnMsIGl0ZW0gPT4ge1xuICAgIGlmIChpdGVtIGluc3RhbmNlb2YgSXRlbSAmJiB1bS5zY29wZS5zb21lKHR5cGUgPT4gaXNQYXJlbnRPZih0eXBlLCBpdGVtKSkpIHtcbiAgICAgIGtlZXBJdGVtKGl0ZW0sIGZhbHNlKVxuICAgIH1cbiAgfSlcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1VuZG9NYW5hZ2VyfSB1bmRvTWFuYWdlclxuICogQHBhcmFtIHtBcnJheTxTdGFja0l0ZW0+fSBzdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50VHlwZVxuICogQHJldHVybiB7U3RhY2tJdGVtP31cbiAqL1xuY29uc3QgcG9wU3RhY2tJdGVtID0gKHVuZG9NYW5hZ2VyLCBzdGFjaywgZXZlbnRUeXBlKSA9PiB7XG4gIC8qKlxuICAgKiBXaGV0aGVyIGEgY2hhbmdlIGhhcHBlbmVkXG4gICAqIEB0eXBlIHtTdGFja0l0ZW0/fVxuICAgKi9cbiAgbGV0IHJlc3VsdCA9IG51bGxcbiAgLyoqXG4gICAqIEtlZXAgYSByZWZlcmVuY2UgdG8gdGhlIHRyYW5zYWN0aW9uIHNvIHdlIGNhbiBmaXJlIHRoZSBldmVudCB3aXRoIHRoZSBjaGFuZ2VkUGFyZW50VHlwZXNcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIGxldCBfdHIgPSBudWxsXG4gIGNvbnN0IGRvYyA9IHVuZG9NYW5hZ2VyLmRvY1xuICBjb25zdCBzY29wZSA9IHVuZG9NYW5hZ2VyLnNjb3BlXG4gIHRyYW5zYWN0KGRvYywgdHJhbnNhY3Rpb24gPT4ge1xuICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiAwICYmIHJlc3VsdCA9PT0gbnVsbCkge1xuICAgICAgY29uc3Qgc3RvcmUgPSBkb2Muc3RvcmVcbiAgICAgIGNvbnN0IHN0YWNrSXRlbSA9IC8qKiBAdHlwZSB7U3RhY2tJdGVtfSAqLyAoc3RhY2sucG9wKCkpXG4gICAgICAvKipcbiAgICAgICAqIEB0eXBlIHtTZXQ8SXRlbT59XG4gICAgICAgKi9cbiAgICAgIGNvbnN0IGl0ZW1zVG9SZWRvID0gbmV3IFNldCgpXG4gICAgICAvKipcbiAgICAgICAqIEB0eXBlIHtBcnJheTxJdGVtPn1cbiAgICAgICAqL1xuICAgICAgY29uc3QgaXRlbXNUb0RlbGV0ZSA9IFtdXG4gICAgICBsZXQgcGVyZm9ybWVkQ2hhbmdlID0gZmFsc2VcbiAgICAgIGl0ZXJhdGVEZWxldGVkU3RydWN0cyh0cmFuc2FjdGlvbiwgc3RhY2tJdGVtLmluc2VydGlvbnMsIHN0cnVjdCA9PiB7XG4gICAgICAgIGlmIChzdHJ1Y3QgaW5zdGFuY2VvZiBJdGVtKSB7XG4gICAgICAgICAgaWYgKHN0cnVjdC5yZWRvbmUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGxldCB7IGl0ZW0sIGRpZmYgfSA9IGZvbGxvd1JlZG9uZShzdG9yZSwgc3RydWN0LmlkKVxuICAgICAgICAgICAgaWYgKGRpZmYgPiAwKSB7XG4gICAgICAgICAgICAgIGl0ZW0gPSBnZXRJdGVtQ2xlYW5TdGFydCh0cmFuc2FjdGlvbiwgY3JlYXRlSUQoaXRlbS5pZC5jbGllbnQsIGl0ZW0uaWQuY2xvY2sgKyBkaWZmKSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0cnVjdCA9IGl0ZW1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFzdHJ1Y3QuZGVsZXRlZCAmJiBzY29wZS5zb21lKHR5cGUgPT4gaXNQYXJlbnRPZih0eXBlLCAvKiogQHR5cGUge0l0ZW19ICovIChzdHJ1Y3QpKSkpIHtcbiAgICAgICAgICAgIGl0ZW1zVG9EZWxldGUucHVzaChzdHJ1Y3QpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgaXRlcmF0ZURlbGV0ZWRTdHJ1Y3RzKHRyYW5zYWN0aW9uLCBzdGFja0l0ZW0uZGVsZXRpb25zLCBzdHJ1Y3QgPT4ge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgc3RydWN0IGluc3RhbmNlb2YgSXRlbSAmJlxuICAgICAgICAgIHNjb3BlLnNvbWUodHlwZSA9PiBpc1BhcmVudE9mKHR5cGUsIHN0cnVjdCkpICYmXG4gICAgICAgICAgLy8gTmV2ZXIgcmVkbyBzdHJ1Y3RzIGluIHN0YWNrSXRlbS5pbnNlcnRpb25zIGJlY2F1c2UgdGhleSB3ZXJlIGNyZWF0ZWQgYW5kIGRlbGV0ZWQgaW4gdGhlIHNhbWUgY2FwdHVyZSBpbnRlcnZhbC5cbiAgICAgICAgICAhaXNEZWxldGVkKHN0YWNrSXRlbS5pbnNlcnRpb25zLCBzdHJ1Y3QuaWQpXG4gICAgICAgICkge1xuICAgICAgICAgIGl0ZW1zVG9SZWRvLmFkZChzdHJ1Y3QpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICBpdGVtc1RvUmVkby5mb3JFYWNoKHN0cnVjdCA9PiB7XG4gICAgICAgIHBlcmZvcm1lZENoYW5nZSA9IHJlZG9JdGVtKHRyYW5zYWN0aW9uLCBzdHJ1Y3QsIGl0ZW1zVG9SZWRvLCBzdGFja0l0ZW0uaW5zZXJ0aW9ucywgdW5kb01hbmFnZXIuaWdub3JlUmVtb3RlTWFwQ2hhbmdlcywgdW5kb01hbmFnZXIpICE9PSBudWxsIHx8IHBlcmZvcm1lZENoYW5nZVxuICAgICAgfSlcbiAgICAgIC8vIFdlIHdhbnQgdG8gZGVsZXRlIGluIHJldmVyc2Ugb3JkZXIgc28gdGhhdCBjaGlsZHJlbiBhcmUgZGVsZXRlZCBiZWZvcmVcbiAgICAgIC8vIHBhcmVudHMsIHNvIHdlIGhhdmUgbW9yZSBpbmZvcm1hdGlvbiBhdmFpbGFibGUgd2hlbiBpdGVtcyBhcmUgZmlsdGVyZWQuXG4gICAgICBmb3IgKGxldCBpID0gaXRlbXNUb0RlbGV0ZS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBjb25zdCBpdGVtID0gaXRlbXNUb0RlbGV0ZVtpXVxuICAgICAgICBpZiAodW5kb01hbmFnZXIuZGVsZXRlRmlsdGVyKGl0ZW0pKSB7XG4gICAgICAgICAgaXRlbS5kZWxldGUodHJhbnNhY3Rpb24pXG4gICAgICAgICAgcGVyZm9ybWVkQ2hhbmdlID0gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXN1bHQgPSBwZXJmb3JtZWRDaGFuZ2UgPyBzdGFja0l0ZW0gOiBudWxsXG4gICAgfVxuICAgIHRyYW5zYWN0aW9uLmNoYW5nZWQuZm9yRWFjaCgoc3ViUHJvcHMsIHR5cGUpID0+IHtcbiAgICAgIC8vIGRlc3Ryb3kgc2VhcmNoIG1hcmtlciBpZiBuZWNlc3NhcnlcbiAgICAgIGlmIChzdWJQcm9wcy5oYXMobnVsbCkgJiYgdHlwZS5fc2VhcmNoTWFya2VyKSB7XG4gICAgICAgIHR5cGUuX3NlYXJjaE1hcmtlci5sZW5ndGggPSAwXG4gICAgICB9XG4gICAgfSlcbiAgICBfdHIgPSB0cmFuc2FjdGlvblxuICB9LCB1bmRvTWFuYWdlcilcbiAgaWYgKHJlc3VsdCAhPSBudWxsKSB7XG4gICAgY29uc3QgY2hhbmdlZFBhcmVudFR5cGVzID0gX3RyLmNoYW5nZWRQYXJlbnRUeXBlc1xuICAgIHVuZG9NYW5hZ2VyLmVtaXQoJ3N0YWNrLWl0ZW0tcG9wcGVkJywgW3sgc3RhY2tJdGVtOiByZXN1bHQsIHR5cGU6IGV2ZW50VHlwZSwgY2hhbmdlZFBhcmVudFR5cGVzIH0sIHVuZG9NYW5hZ2VyXSlcbiAgfVxuICByZXR1cm4gcmVzdWx0XG59XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gVW5kb01hbmFnZXJPcHRpb25zXG4gKiBAcHJvcGVydHkge251bWJlcn0gW1VuZG9NYW5hZ2VyT3B0aW9ucy5jYXB0dXJlVGltZW91dD01MDBdXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9uKFRyYW5zYWN0aW9uKTpib29sZWFufSBbVW5kb01hbmFnZXJPcHRpb25zLmNhcHR1cmVUcmFuc2FjdGlvbl0gRG8gbm90IGNhcHR1cmUgY2hhbmdlcyBvZiBhIFRyYW5zYWN0aW9uIGlmIHJlc3VsdCBmYWxzZS5cbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb24oSXRlbSk6Ym9vbGVhbn0gW1VuZG9NYW5hZ2VyT3B0aW9ucy5kZWxldGVGaWx0ZXI9KCk9PnRydWVdIFNvbWV0aW1lc1xuICogaXQgaXMgbmVjZXNzYXJ5IHRvIGZpbHRlciB3aGF0IGFuIFVuZG8vUmVkbyBvcGVyYXRpb24gY2FuIGRlbGV0ZS4gSWYgdGhpc1xuICogZmlsdGVyIHJldHVybnMgZmFsc2UsIHRoZSB0eXBlL2l0ZW0gd29uJ3QgYmUgZGVsZXRlZCBldmVuIGl0IGlzIGluIHRoZVxuICogdW5kby9yZWRvIHNjb3BlLlxuICogQHByb3BlcnR5IHtTZXQ8YW55Pn0gW1VuZG9NYW5hZ2VyT3B0aW9ucy50cmFja2VkT3JpZ2lucz1uZXcgU2V0KFtudWxsXSldXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtpZ25vcmVSZW1vdGVNYXBDaGFuZ2VzXSBFeHBlcmltZW50YWwuIEJ5IGRlZmF1bHQsIHRoZSBVbmRvTWFuYWdlciB3aWxsIG5ldmVyIG92ZXJ3cml0ZSByZW1vdGUgY2hhbmdlcy4gRW5hYmxlIHRoaXMgcHJvcGVydHkgdG8gZW5hYmxlIG92ZXJ3cml0aW5nIHJlbW90ZSBjaGFuZ2VzIG9uIGtleS12YWx1ZSBjaGFuZ2VzIChZLk1hcCwgcHJvcGVydGllcyBvbiBZLlhtbCwgZXRjLi4pLlxuICogQHByb3BlcnR5IHtEb2N9IFtkb2NdIFRoZSBkb2N1bWVudCB0aGF0IHRoaXMgVW5kb01hbmFnZXIgb3BlcmF0ZXMgb24uIE9ubHkgbmVlZGVkIGlmIHR5cGVTY29wZSBpcyBlbXB0eS5cbiAqL1xuXG4vKipcbiAqIEZpcmVzICdzdGFjay1pdGVtLWFkZGVkJyBldmVudCB3aGVuIGEgc3RhY2sgaXRlbSB3YXMgYWRkZWQgdG8gZWl0aGVyIHRoZSB1bmRvLSBvclxuICogdGhlIHJlZG8tc3RhY2suIFlvdSBtYXkgc3RvcmUgYWRkaXRpb25hbCBzdGFjayBpbmZvcm1hdGlvbiB2aWEgdGhlXG4gKiBtZXRhZGF0YSBwcm9wZXJ0eSBvbiBgZXZlbnQuc3RhY2tJdGVtLm1ldGFgIChpdCBpcyBhIGBNYXBgIG9mIG1ldGFkYXRhIHByb3BlcnRpZXMpLlxuICogRmlyZXMgJ3N0YWNrLWl0ZW0tcG9wcGVkJyBldmVudCB3aGVuIGEgc3RhY2sgaXRlbSB3YXMgcG9wcGVkIGZyb20gZWl0aGVyIHRoZVxuICogdW5kby0gb3IgdGhlIHJlZG8tc3RhY2suIFlvdSBtYXkgcmVzdG9yZSB0aGUgc2F2ZWQgc3RhY2sgaW5mb3JtYXRpb24gZnJvbSBgZXZlbnQuc3RhY2tJdGVtLm1ldGFgLlxuICpcbiAqIEBleHRlbmRzIHtPYnNlcnZhYmxlPCdzdGFjay1pdGVtLWFkZGVkJ3wnc3RhY2staXRlbS1wb3BwZWQnfCdzdGFjay1jbGVhcmVkJ3wnc3RhY2staXRlbS11cGRhdGVkJz59XG4gKi9cbmV4cG9ydCBjbGFzcyBVbmRvTWFuYWdlciBleHRlbmRzIE9ic2VydmFibGUge1xuICAvKipcbiAgICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55PnxBcnJheTxBYnN0cmFjdFR5cGU8YW55Pj59IHR5cGVTY29wZSBBY2NlcHRzIGVpdGhlciBhIHNpbmdsZSB0eXBlLCBvciBhbiBhcnJheSBvZiB0eXBlc1xuICAgKiBAcGFyYW0ge1VuZG9NYW5hZ2VyT3B0aW9uc30gb3B0aW9uc1xuICAgKi9cbiAgY29uc3RydWN0b3IgKHR5cGVTY29wZSwge1xuICAgIGNhcHR1cmVUaW1lb3V0ID0gNTAwLFxuICAgIGNhcHR1cmVUcmFuc2FjdGlvbiA9IF90ciA9PiB0cnVlLFxuICAgIGRlbGV0ZUZpbHRlciA9ICgpID0+IHRydWUsXG4gICAgdHJhY2tlZE9yaWdpbnMgPSBuZXcgU2V0KFtudWxsXSksXG4gICAgaWdub3JlUmVtb3RlTWFwQ2hhbmdlcyA9IGZhbHNlLFxuICAgIGRvYyA9IC8qKiBAdHlwZSB7RG9jfSAqLyAoYXJyYXkuaXNBcnJheSh0eXBlU2NvcGUpID8gdHlwZVNjb3BlWzBdLmRvYyA6IHR5cGVTY29wZS5kb2MpXG4gIH0gPSB7fSkge1xuICAgIHN1cGVyKClcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QXJyYXk8QWJzdHJhY3RUeXBlPGFueT4+fVxuICAgICAqL1xuICAgIHRoaXMuc2NvcGUgPSBbXVxuICAgIHRoaXMuZG9jID0gZG9jXG4gICAgdGhpcy5hZGRUb1Njb3BlKHR5cGVTY29wZSlcbiAgICB0aGlzLmRlbGV0ZUZpbHRlciA9IGRlbGV0ZUZpbHRlclxuICAgIHRyYWNrZWRPcmlnaW5zLmFkZCh0aGlzKVxuICAgIHRoaXMudHJhY2tlZE9yaWdpbnMgPSB0cmFja2VkT3JpZ2luc1xuICAgIHRoaXMuY2FwdHVyZVRyYW5zYWN0aW9uID0gY2FwdHVyZVRyYW5zYWN0aW9uXG4gICAgLyoqXG4gICAgICogQHR5cGUge0FycmF5PFN0YWNrSXRlbT59XG4gICAgICovXG4gICAgdGhpcy51bmRvU3RhY2sgPSBbXVxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBcnJheTxTdGFja0l0ZW0+fVxuICAgICAqL1xuICAgIHRoaXMucmVkb1N0YWNrID0gW11cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSBjbGllbnQgaXMgY3VycmVudGx5IHVuZG9pbmcgKGNhbGxpbmcgVW5kb01hbmFnZXIudW5kbylcbiAgICAgKlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMudW5kb2luZyA9IGZhbHNlXG4gICAgdGhpcy5yZWRvaW5nID0gZmFsc2VcbiAgICB0aGlzLmxhc3RDaGFuZ2UgPSAwXG4gICAgdGhpcy5pZ25vcmVSZW1vdGVNYXBDaGFuZ2VzID0gaWdub3JlUmVtb3RlTWFwQ2hhbmdlc1xuICAgIHRoaXMuY2FwdHVyZVRpbWVvdXQgPSBjYXB0dXJlVGltZW91dFxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAgICovXG4gICAgdGhpcy5hZnRlclRyYW5zYWN0aW9uSGFuZGxlciA9IHRyYW5zYWN0aW9uID0+IHtcbiAgICAgIC8vIE9ubHkgdHJhY2sgY2VydGFpbiB0cmFuc2FjdGlvbnNcbiAgICAgIGlmIChcbiAgICAgICAgIXRoaXMuY2FwdHVyZVRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKSB8fFxuICAgICAgICAhdGhpcy5zY29wZS5zb21lKHR5cGUgPT4gdHJhbnNhY3Rpb24uY2hhbmdlZFBhcmVudFR5cGVzLmhhcyh0eXBlKSkgfHxcbiAgICAgICAgKCF0aGlzLnRyYWNrZWRPcmlnaW5zLmhhcyh0cmFuc2FjdGlvbi5vcmlnaW4pICYmICghdHJhbnNhY3Rpb24ub3JpZ2luIHx8ICF0aGlzLnRyYWNrZWRPcmlnaW5zLmhhcyh0cmFuc2FjdGlvbi5vcmlnaW4uY29uc3RydWN0b3IpKSlcbiAgICAgICkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIGNvbnN0IHVuZG9pbmcgPSB0aGlzLnVuZG9pbmdcbiAgICAgIGNvbnN0IHJlZG9pbmcgPSB0aGlzLnJlZG9pbmdcbiAgICAgIGNvbnN0IHN0YWNrID0gdW5kb2luZyA/IHRoaXMucmVkb1N0YWNrIDogdGhpcy51bmRvU3RhY2tcbiAgICAgIGlmICh1bmRvaW5nKSB7XG4gICAgICAgIHRoaXMuc3RvcENhcHR1cmluZygpIC8vIG5leHQgdW5kbyBzaG91bGQgbm90IGJlIGFwcGVuZGVkIHRvIGxhc3Qgc3RhY2sgaXRlbVxuICAgICAgfSBlbHNlIGlmICghcmVkb2luZykge1xuICAgICAgICAvLyBuZWl0aGVyIHVuZG9pbmcgbm9yIHJlZG9pbmc6IGRlbGV0ZSByZWRvU3RhY2tcbiAgICAgICAgdGhpcy5jbGVhcihmYWxzZSwgdHJ1ZSlcbiAgICAgIH1cbiAgICAgIGNvbnN0IGluc2VydGlvbnMgPSBuZXcgRGVsZXRlU2V0KClcbiAgICAgIHRyYW5zYWN0aW9uLmFmdGVyU3RhdGUuZm9yRWFjaCgoZW5kQ2xvY2ssIGNsaWVudCkgPT4ge1xuICAgICAgICBjb25zdCBzdGFydENsb2NrID0gdHJhbnNhY3Rpb24uYmVmb3JlU3RhdGUuZ2V0KGNsaWVudCkgfHwgMFxuICAgICAgICBjb25zdCBsZW4gPSBlbmRDbG9jayAtIHN0YXJ0Q2xvY2tcbiAgICAgICAgaWYgKGxlbiA+IDApIHtcbiAgICAgICAgICBhZGRUb0RlbGV0ZVNldChpbnNlcnRpb25zLCBjbGllbnQsIHN0YXJ0Q2xvY2ssIGxlbilcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIGNvbnN0IG5vdyA9IHRpbWUuZ2V0VW5peFRpbWUoKVxuICAgICAgbGV0IGRpZEFkZCA9IGZhbHNlXG4gICAgICBpZiAodGhpcy5sYXN0Q2hhbmdlID4gMCAmJiBub3cgLSB0aGlzLmxhc3RDaGFuZ2UgPCB0aGlzLmNhcHR1cmVUaW1lb3V0ICYmIHN0YWNrLmxlbmd0aCA+IDAgJiYgIXVuZG9pbmcgJiYgIXJlZG9pbmcpIHtcbiAgICAgICAgLy8gYXBwZW5kIGNoYW5nZSB0byBsYXN0IHN0YWNrIG9wXG4gICAgICAgIGNvbnN0IGxhc3RPcCA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdXG4gICAgICAgIGxhc3RPcC5kZWxldGlvbnMgPSBtZXJnZURlbGV0ZVNldHMoW2xhc3RPcC5kZWxldGlvbnMsIHRyYW5zYWN0aW9uLmRlbGV0ZVNldF0pXG4gICAgICAgIGxhc3RPcC5pbnNlcnRpb25zID0gbWVyZ2VEZWxldGVTZXRzKFtsYXN0T3AuaW5zZXJ0aW9ucywgaW5zZXJ0aW9uc10pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBjcmVhdGUgYSBuZXcgc3RhY2sgb3BcbiAgICAgICAgc3RhY2sucHVzaChuZXcgU3RhY2tJdGVtKHRyYW5zYWN0aW9uLmRlbGV0ZVNldCwgaW5zZXJ0aW9ucykpXG4gICAgICAgIGRpZEFkZCA9IHRydWVcbiAgICAgIH1cbiAgICAgIGlmICghdW5kb2luZyAmJiAhcmVkb2luZykge1xuICAgICAgICB0aGlzLmxhc3RDaGFuZ2UgPSBub3dcbiAgICAgIH1cbiAgICAgIC8vIG1ha2Ugc3VyZSB0aGF0IGRlbGV0ZWQgc3RydWN0cyBhcmUgbm90IGdjJ2RcbiAgICAgIGl0ZXJhdGVEZWxldGVkU3RydWN0cyh0cmFuc2FjdGlvbiwgdHJhbnNhY3Rpb24uZGVsZXRlU2V0LCAvKiogQHBhcmFtIHtJdGVtfEdDfSBpdGVtICovIGl0ZW0gPT4ge1xuICAgICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIEl0ZW0gJiYgdGhpcy5zY29wZS5zb21lKHR5cGUgPT4gaXNQYXJlbnRPZih0eXBlLCBpdGVtKSkpIHtcbiAgICAgICAgICBrZWVwSXRlbShpdGVtLCB0cnVlKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgY29uc3QgY2hhbmdlRXZlbnQgPSBbeyBzdGFja0l0ZW06IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdLCBvcmlnaW46IHRyYW5zYWN0aW9uLm9yaWdpbiwgdHlwZTogdW5kb2luZyA/ICdyZWRvJyA6ICd1bmRvJywgY2hhbmdlZFBhcmVudFR5cGVzOiB0cmFuc2FjdGlvbi5jaGFuZ2VkUGFyZW50VHlwZXMgfSwgdGhpc11cbiAgICAgIGlmIChkaWRBZGQpIHtcbiAgICAgICAgdGhpcy5lbWl0KCdzdGFjay1pdGVtLWFkZGVkJywgY2hhbmdlRXZlbnQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmVtaXQoJ3N0YWNrLWl0ZW0tdXBkYXRlZCcsIGNoYW5nZUV2ZW50KVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmRvYy5vbignYWZ0ZXJUcmFuc2FjdGlvbicsIHRoaXMuYWZ0ZXJUcmFuc2FjdGlvbkhhbmRsZXIpXG4gICAgdGhpcy5kb2Mub24oJ2Rlc3Ryb3knLCAoKSA9PiB7XG4gICAgICB0aGlzLmRlc3Ryb3koKVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtBcnJheTxBYnN0cmFjdFR5cGU8YW55Pj4gfCBBYnN0cmFjdFR5cGU8YW55Pn0geXR5cGVzXG4gICAqL1xuICBhZGRUb1Njb3BlICh5dHlwZXMpIHtcbiAgICB5dHlwZXMgPSBhcnJheS5pc0FycmF5KHl0eXBlcykgPyB5dHlwZXMgOiBbeXR5cGVzXVxuICAgIHl0eXBlcy5mb3JFYWNoKHl0eXBlID0+IHtcbiAgICAgIGlmICh0aGlzLnNjb3BlLmV2ZXJ5KHl0ID0+IHl0ICE9PSB5dHlwZSkpIHtcbiAgICAgICAgaWYgKHl0eXBlLmRvYyAhPT0gdGhpcy5kb2MpIGxvZ2dpbmcud2FybignW3lqcyM1MDldIE5vdCBzYW1lIFkuRG9jJykgLy8gdXNlIE11bHRpRG9jVW5kb01hbmFnZXIgaW5zdGVhZC4gYWxzbyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3lqcy95anMvaXNzdWVzLzUwOVxuICAgICAgICB0aGlzLnNjb3BlLnB1c2goeXR5cGUpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2FueX0gb3JpZ2luXG4gICAqL1xuICBhZGRUcmFja2VkT3JpZ2luIChvcmlnaW4pIHtcbiAgICB0aGlzLnRyYWNrZWRPcmlnaW5zLmFkZChvcmlnaW4pXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHthbnl9IG9yaWdpblxuICAgKi9cbiAgcmVtb3ZlVHJhY2tlZE9yaWdpbiAob3JpZ2luKSB7XG4gICAgdGhpcy50cmFja2VkT3JpZ2lucy5kZWxldGUob3JpZ2luKVxuICB9XG5cbiAgY2xlYXIgKGNsZWFyVW5kb1N0YWNrID0gdHJ1ZSwgY2xlYXJSZWRvU3RhY2sgPSB0cnVlKSB7XG4gICAgaWYgKChjbGVhclVuZG9TdGFjayAmJiB0aGlzLmNhblVuZG8oKSkgfHwgKGNsZWFyUmVkb1N0YWNrICYmIHRoaXMuY2FuUmVkbygpKSkge1xuICAgICAgdGhpcy5kb2MudHJhbnNhY3QodHIgPT4ge1xuICAgICAgICBpZiAoY2xlYXJVbmRvU3RhY2spIHtcbiAgICAgICAgICB0aGlzLnVuZG9TdGFjay5mb3JFYWNoKGl0ZW0gPT4gY2xlYXJVbmRvTWFuYWdlclN0YWNrSXRlbSh0ciwgdGhpcywgaXRlbSkpXG4gICAgICAgICAgdGhpcy51bmRvU3RhY2sgPSBbXVxuICAgICAgICB9XG4gICAgICAgIGlmIChjbGVhclJlZG9TdGFjaykge1xuICAgICAgICAgIHRoaXMucmVkb1N0YWNrLmZvckVhY2goaXRlbSA9PiBjbGVhclVuZG9NYW5hZ2VyU3RhY2tJdGVtKHRyLCB0aGlzLCBpdGVtKSlcbiAgICAgICAgICB0aGlzLnJlZG9TdGFjayA9IFtdXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbWl0KCdzdGFjay1jbGVhcmVkJywgW3sgdW5kb1N0YWNrQ2xlYXJlZDogY2xlYXJVbmRvU3RhY2ssIHJlZG9TdGFja0NsZWFyZWQ6IGNsZWFyUmVkb1N0YWNrIH1dKVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVW5kb01hbmFnZXIgbWVyZ2VzIFVuZG8tU3RhY2tJdGVtIGlmIHRoZXkgYXJlIGNyZWF0ZWQgd2l0aGluIHRpbWUtZ2FwXG4gICAqIHNtYWxsZXIgdGhhbiBgb3B0aW9ucy5jYXB0dXJlVGltZW91dGAuIENhbGwgYHVtLnN0b3BDYXB0dXJpbmcoKWAgc28gdGhhdCB0aGUgbmV4dFxuICAgKiBTdGFja0l0ZW0gd29uJ3QgYmUgbWVyZ2VkLlxuICAgKlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAgICAgLy8gd2l0aG91dCBzdG9wQ2FwdHVyaW5nXG4gICAqICAgICB5dGV4dC5pbnNlcnQoMCwgJ2EnKVxuICAgKiAgICAgeXRleHQuaW5zZXJ0KDEsICdiJylcbiAgICogICAgIHVtLnVuZG8oKVxuICAgKiAgICAgeXRleHQudG9TdHJpbmcoKSAvLyA9PiAnJyAobm90ZSB0aGF0ICdhYicgd2FzIHJlbW92ZWQpXG4gICAqICAgICAvLyB3aXRoIHN0b3BDYXB0dXJpbmdcbiAgICogICAgIHl0ZXh0Lmluc2VydCgwLCAnYScpXG4gICAqICAgICB1bS5zdG9wQ2FwdHVyaW5nKClcbiAgICogICAgIHl0ZXh0Lmluc2VydCgwLCAnYicpXG4gICAqICAgICB1bS51bmRvKClcbiAgICogICAgIHl0ZXh0LnRvU3RyaW5nKCkgLy8gPT4gJ2EnIChub3RlIHRoYXQgb25seSAnYicgd2FzIHJlbW92ZWQpXG4gICAqXG4gICAqL1xuICBzdG9wQ2FwdHVyaW5nICgpIHtcbiAgICB0aGlzLmxhc3RDaGFuZ2UgPSAwXG4gIH1cblxuICAvKipcbiAgICogVW5kbyBsYXN0IGNoYW5nZXMgb24gdHlwZS5cbiAgICpcbiAgICogQHJldHVybiB7U3RhY2tJdGVtP30gUmV0dXJucyBTdGFja0l0ZW0gaWYgYSBjaGFuZ2Ugd2FzIGFwcGxpZWRcbiAgICovXG4gIHVuZG8gKCkge1xuICAgIHRoaXMudW5kb2luZyA9IHRydWVcbiAgICBsZXQgcmVzXG4gICAgdHJ5IHtcbiAgICAgIHJlcyA9IHBvcFN0YWNrSXRlbSh0aGlzLCB0aGlzLnVuZG9TdGFjaywgJ3VuZG8nKVxuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLnVuZG9pbmcgPSBmYWxzZVxuICAgIH1cbiAgICByZXR1cm4gcmVzXG4gIH1cblxuICAvKipcbiAgICogUmVkbyBsYXN0IHVuZG8gb3BlcmF0aW9uLlxuICAgKlxuICAgKiBAcmV0dXJuIHtTdGFja0l0ZW0/fSBSZXR1cm5zIFN0YWNrSXRlbSBpZiBhIGNoYW5nZSB3YXMgYXBwbGllZFxuICAgKi9cbiAgcmVkbyAoKSB7XG4gICAgdGhpcy5yZWRvaW5nID0gdHJ1ZVxuICAgIGxldCByZXNcbiAgICB0cnkge1xuICAgICAgcmVzID0gcG9wU3RhY2tJdGVtKHRoaXMsIHRoaXMucmVkb1N0YWNrLCAncmVkbycpXG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMucmVkb2luZyA9IGZhbHNlXG4gICAgfVxuICAgIHJldHVybiByZXNcbiAgfVxuXG4gIC8qKlxuICAgKiBBcmUgdW5kbyBzdGVwcyBhdmFpbGFibGU/XG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IGB0cnVlYCBpZiB1bmRvIGlzIHBvc3NpYmxlXG4gICAqL1xuICBjYW5VbmRvICgpIHtcbiAgICByZXR1cm4gdGhpcy51bmRvU3RhY2subGVuZ3RoID4gMFxuICB9XG5cbiAgLyoqXG4gICAqIEFyZSByZWRvIHN0ZXBzIGF2YWlsYWJsZT9cbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gYHRydWVgIGlmIHJlZG8gaXMgcG9zc2libGVcbiAgICovXG4gIGNhblJlZG8gKCkge1xuICAgIHJldHVybiB0aGlzLnJlZG9TdGFjay5sZW5ndGggPiAwXG4gIH1cblxuICBkZXN0cm95ICgpIHtcbiAgICB0aGlzLnRyYWNrZWRPcmlnaW5zLmRlbGV0ZSh0aGlzKVxuICAgIHRoaXMuZG9jLm9mZignYWZ0ZXJUcmFuc2FjdGlvbicsIHRoaXMuYWZ0ZXJUcmFuc2FjdGlvbkhhbmRsZXIpXG4gICAgc3VwZXIuZGVzdHJveSgpXG4gIH1cbn1cbiIsICJcbmltcG9ydCAqIGFzIGJpbmFyeSBmcm9tICdsaWIwL2JpbmFyeSdcbmltcG9ydCAqIGFzIGRlY29kaW5nIGZyb20gJ2xpYjAvZGVjb2RpbmcnXG5pbXBvcnQgKiBhcyBlbmNvZGluZyBmcm9tICdsaWIwL2VuY29kaW5nJ1xuaW1wb3J0ICogYXMgZXJyb3IgZnJvbSAnbGliMC9lcnJvcidcbmltcG9ydCAqIGFzIGYgZnJvbSAnbGliMC9mdW5jdGlvbidcbmltcG9ydCAqIGFzIGxvZ2dpbmcgZnJvbSAnbGliMC9sb2dnaW5nJ1xuaW1wb3J0ICogYXMgbWFwIGZyb20gJ2xpYjAvbWFwJ1xuaW1wb3J0ICogYXMgbWF0aCBmcm9tICdsaWIwL21hdGgnXG5pbXBvcnQgKiBhcyBzdHJpbmcgZnJvbSAnbGliMC9zdHJpbmcnXG5cbmltcG9ydCB7XG4gIENvbnRlbnRBbnksXG4gIENvbnRlbnRCaW5hcnksXG4gIENvbnRlbnREZWxldGVkLFxuICBDb250ZW50RG9jLFxuICBDb250ZW50RW1iZWQsXG4gIENvbnRlbnRGb3JtYXQsXG4gIENvbnRlbnRKU09OLFxuICBDb250ZW50U3RyaW5nLFxuICBDb250ZW50VHlwZSxcbiAgY3JlYXRlSUQsXG4gIGRlY29kZVN0YXRlVmVjdG9yLFxuICBEU0VuY29kZXJWMSxcbiAgRFNFbmNvZGVyVjIsXG4gIEdDLFxuICBJdGVtLFxuICBtZXJnZURlbGV0ZVNldHMsXG4gIHJlYWREZWxldGVTZXQsXG4gIHJlYWRJdGVtQ29udGVudCxcbiAgU2tpcCxcbiAgVXBkYXRlRGVjb2RlclYxLFxuICBVcGRhdGVEZWNvZGVyVjIsXG4gIFVwZGF0ZUVuY29kZXJWMSxcbiAgVXBkYXRlRW5jb2RlclYyLFxuICB3cml0ZURlbGV0ZVNldCxcbiAgWVhtbEVsZW1lbnQsXG4gIFlYbWxIb29rXG59IGZyb20gJy4uL2ludGVybmFscy5qcydcblxuLyoqXG4gKiBAcGFyYW0ge1VwZGF0ZURlY29kZXJWMSB8IFVwZGF0ZURlY29kZXJWMn0gZGVjb2RlclxuICovXG5mdW5jdGlvbiAqIGxhenlTdHJ1Y3RSZWFkZXJHZW5lcmF0b3IgKGRlY29kZXIpIHtcbiAgY29uc3QgbnVtT2ZTdGF0ZVVwZGF0ZXMgPSBkZWNvZGluZy5yZWFkVmFyVWludChkZWNvZGVyLnJlc3REZWNvZGVyKVxuICBmb3IgKGxldCBpID0gMDsgaSA8IG51bU9mU3RhdGVVcGRhdGVzOyBpKyspIHtcbiAgICBjb25zdCBudW1iZXJPZlN0cnVjdHMgPSBkZWNvZGluZy5yZWFkVmFyVWludChkZWNvZGVyLnJlc3REZWNvZGVyKVxuICAgIGNvbnN0IGNsaWVudCA9IGRlY29kZXIucmVhZENsaWVudCgpXG4gICAgbGV0IGNsb2NrID0gZGVjb2RpbmcucmVhZFZhclVpbnQoZGVjb2Rlci5yZXN0RGVjb2RlcilcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bWJlck9mU3RydWN0czsgaSsrKSB7XG4gICAgICBjb25zdCBpbmZvID0gZGVjb2Rlci5yZWFkSW5mbygpXG4gICAgICAvLyBAdG9kbyB1c2Ugc3dpdGNoIGluc3RlYWQgb2YgaWZzXG4gICAgICBpZiAoaW5mbyA9PT0gMTApIHtcbiAgICAgICAgY29uc3QgbGVuID0gZGVjb2RpbmcucmVhZFZhclVpbnQoZGVjb2Rlci5yZXN0RGVjb2RlcilcbiAgICAgICAgeWllbGQgbmV3IFNraXAoY3JlYXRlSUQoY2xpZW50LCBjbG9jayksIGxlbilcbiAgICAgICAgY2xvY2sgKz0gbGVuXG4gICAgICB9IGVsc2UgaWYgKChiaW5hcnkuQklUUzUgJiBpbmZvKSAhPT0gMCkge1xuICAgICAgICBjb25zdCBjYW50Q29weVBhcmVudEluZm8gPSAoaW5mbyAmIChiaW5hcnkuQklUNyB8IGJpbmFyeS5CSVQ4KSkgPT09IDBcbiAgICAgICAgLy8gSWYgcGFyZW50ID0gbnVsbCBhbmQgbmVpdGhlciBsZWZ0IG5vciByaWdodCBhcmUgZGVmaW5lZCwgdGhlbiB3ZSBrbm93IHRoYXQgYHBhcmVudGAgaXMgY2hpbGQgb2YgYHlgXG4gICAgICAgIC8vIGFuZCB3ZSByZWFkIHRoZSBuZXh0IHN0cmluZyBhcyBwYXJlbnRZS2V5LlxuICAgICAgICAvLyBJdCBpbmRpY2F0ZXMgaG93IHdlIHN0b3JlL3JldHJpZXZlIHBhcmVudCBmcm9tIGB5LnNoYXJlYFxuICAgICAgICAvLyBAdHlwZSB7c3RyaW5nfG51bGx9XG4gICAgICAgIGNvbnN0IHN0cnVjdCA9IG5ldyBJdGVtKFxuICAgICAgICAgIGNyZWF0ZUlEKGNsaWVudCwgY2xvY2spLFxuICAgICAgICAgIG51bGwsIC8vIGxlZnRcbiAgICAgICAgICAoaW5mbyAmIGJpbmFyeS5CSVQ4KSA9PT0gYmluYXJ5LkJJVDggPyBkZWNvZGVyLnJlYWRMZWZ0SUQoKSA6IG51bGwsIC8vIG9yaWdpblxuICAgICAgICAgIG51bGwsIC8vIHJpZ2h0XG4gICAgICAgICAgKGluZm8gJiBiaW5hcnkuQklUNykgPT09IGJpbmFyeS5CSVQ3ID8gZGVjb2Rlci5yZWFkUmlnaHRJRCgpIDogbnVsbCwgLy8gcmlnaHQgb3JpZ2luXG4gICAgICAgICAgLy8gQHRzLWlnbm9yZSBGb3JjZSB3cml0aW5nIGEgc3RyaW5nIGhlcmUuXG4gICAgICAgICAgY2FudENvcHlQYXJlbnRJbmZvID8gKGRlY29kZXIucmVhZFBhcmVudEluZm8oKSA/IGRlY29kZXIucmVhZFN0cmluZygpIDogZGVjb2Rlci5yZWFkTGVmdElEKCkpIDogbnVsbCwgLy8gcGFyZW50XG4gICAgICAgICAgY2FudENvcHlQYXJlbnRJbmZvICYmIChpbmZvICYgYmluYXJ5LkJJVDYpID09PSBiaW5hcnkuQklUNiA/IGRlY29kZXIucmVhZFN0cmluZygpIDogbnVsbCwgLy8gcGFyZW50U3ViXG4gICAgICAgICAgcmVhZEl0ZW1Db250ZW50KGRlY29kZXIsIGluZm8pIC8vIGl0ZW0gY29udGVudFxuICAgICAgICApXG4gICAgICAgIHlpZWxkIHN0cnVjdFxuICAgICAgICBjbG9jayArPSBzdHJ1Y3QubGVuZ3RoXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBsZW4gPSBkZWNvZGVyLnJlYWRMZW4oKVxuICAgICAgICB5aWVsZCBuZXcgR0MoY3JlYXRlSUQoY2xpZW50LCBjbG9jayksIGxlbilcbiAgICAgICAgY2xvY2sgKz0gbGVuXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBMYXp5U3RydWN0UmVhZGVyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7VXBkYXRlRGVjb2RlclYxIHwgVXBkYXRlRGVjb2RlclYyfSBkZWNvZGVyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gZmlsdGVyU2tpcHNcbiAgICovXG4gIGNvbnN0cnVjdG9yIChkZWNvZGVyLCBmaWx0ZXJTa2lwcykge1xuICAgIHRoaXMuZ2VuID0gbGF6eVN0cnVjdFJlYWRlckdlbmVyYXRvcihkZWNvZGVyKVxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudWxsIHwgSXRlbSB8IFNraXAgfCBHQ31cbiAgICAgKi9cbiAgICB0aGlzLmN1cnIgPSBudWxsXG4gICAgdGhpcy5kb25lID0gZmFsc2VcbiAgICB0aGlzLmZpbHRlclNraXBzID0gZmlsdGVyU2tpcHNcbiAgICB0aGlzLm5leHQoKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0l0ZW0gfCBHQyB8IFNraXAgfG51bGx9XG4gICAqL1xuICBuZXh0ICgpIHtcbiAgICAvLyBpZ25vcmUgXCJTa2lwXCIgc3RydWN0c1xuICAgIGRvIHtcbiAgICAgIHRoaXMuY3VyciA9IHRoaXMuZ2VuLm5leHQoKS52YWx1ZSB8fCBudWxsXG4gICAgfSB3aGlsZSAodGhpcy5maWx0ZXJTa2lwcyAmJiB0aGlzLmN1cnIgIT09IG51bGwgJiYgdGhpcy5jdXJyLmNvbnN0cnVjdG9yID09PSBTa2lwKVxuICAgIHJldHVybiB0aGlzLmN1cnJcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gdXBkYXRlXG4gKlxuICovXG5leHBvcnQgY29uc3QgbG9nVXBkYXRlID0gdXBkYXRlID0+IGxvZ1VwZGF0ZVYyKHVwZGF0ZSwgVXBkYXRlRGVjb2RlclYxKVxuXG4vKipcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gdXBkYXRlXG4gKiBAcGFyYW0ge3R5cGVvZiBVcGRhdGVEZWNvZGVyVjIgfCB0eXBlb2YgVXBkYXRlRGVjb2RlclYxfSBbWURlY29kZXJdXG4gKlxuICovXG5leHBvcnQgY29uc3QgbG9nVXBkYXRlVjIgPSAodXBkYXRlLCBZRGVjb2RlciA9IFVwZGF0ZURlY29kZXJWMikgPT4ge1xuICBjb25zdCBzdHJ1Y3RzID0gW11cbiAgY29uc3QgdXBkYXRlRGVjb2RlciA9IG5ldyBZRGVjb2RlcihkZWNvZGluZy5jcmVhdGVEZWNvZGVyKHVwZGF0ZSkpXG4gIGNvbnN0IGxhenlEZWNvZGVyID0gbmV3IExhenlTdHJ1Y3RSZWFkZXIodXBkYXRlRGVjb2RlciwgZmFsc2UpXG4gIGZvciAobGV0IGN1cnIgPSBsYXp5RGVjb2Rlci5jdXJyOyBjdXJyICE9PSBudWxsOyBjdXJyID0gbGF6eURlY29kZXIubmV4dCgpKSB7XG4gICAgc3RydWN0cy5wdXNoKGN1cnIpXG4gIH1cbiAgbG9nZ2luZy5wcmludCgnU3RydWN0czogJywgc3RydWN0cylcbiAgY29uc3QgZHMgPSByZWFkRGVsZXRlU2V0KHVwZGF0ZURlY29kZXIpXG4gIGxvZ2dpbmcucHJpbnQoJ0RlbGV0ZVNldDogJywgZHMpXG59XG5cbi8qKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSB1cGRhdGVcbiAqXG4gKi9cbmV4cG9ydCBjb25zdCBkZWNvZGVVcGRhdGUgPSAodXBkYXRlKSA9PiBkZWNvZGVVcGRhdGVWMih1cGRhdGUsIFVwZGF0ZURlY29kZXJWMSlcblxuLyoqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHVwZGF0ZVxuICogQHBhcmFtIHt0eXBlb2YgVXBkYXRlRGVjb2RlclYyIHwgdHlwZW9mIFVwZGF0ZURlY29kZXJWMX0gW1lEZWNvZGVyXVxuICpcbiAqL1xuZXhwb3J0IGNvbnN0IGRlY29kZVVwZGF0ZVYyID0gKHVwZGF0ZSwgWURlY29kZXIgPSBVcGRhdGVEZWNvZGVyVjIpID0+IHtcbiAgY29uc3Qgc3RydWN0cyA9IFtdXG4gIGNvbnN0IHVwZGF0ZURlY29kZXIgPSBuZXcgWURlY29kZXIoZGVjb2RpbmcuY3JlYXRlRGVjb2Rlcih1cGRhdGUpKVxuICBjb25zdCBsYXp5RGVjb2RlciA9IG5ldyBMYXp5U3RydWN0UmVhZGVyKHVwZGF0ZURlY29kZXIsIGZhbHNlKVxuICBmb3IgKGxldCBjdXJyID0gbGF6eURlY29kZXIuY3VycjsgY3VyciAhPT0gbnVsbDsgY3VyciA9IGxhenlEZWNvZGVyLm5leHQoKSkge1xuICAgIHN0cnVjdHMucHVzaChjdXJyKVxuICB9XG4gIHJldHVybiB7XG4gICAgc3RydWN0cyxcbiAgICBkczogcmVhZERlbGV0ZVNldCh1cGRhdGVEZWNvZGVyKVxuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBMYXp5U3RydWN0V3JpdGVyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7VXBkYXRlRW5jb2RlclYxIHwgVXBkYXRlRW5jb2RlclYyfSBlbmNvZGVyXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoZW5jb2Rlcikge1xuICAgIHRoaXMuY3VyckNsaWVudCA9IDBcbiAgICB0aGlzLnN0YXJ0Q2xvY2sgPSAwXG4gICAgdGhpcy53cml0dGVuID0gMFxuICAgIHRoaXMuZW5jb2RlciA9IGVuY29kZXJcbiAgICAvKipcbiAgICAgKiBXZSB3YW50IHRvIHdyaXRlIG9wZXJhdGlvbnMgbGF6aWx5LCBidXQgYWxzbyB3ZSBuZWVkIHRvIGtub3cgYmVmb3JlaGFuZCBob3cgbWFueSBvcGVyYXRpb25zIHdlIHdhbnQgdG8gd3JpdGUgZm9yIGVhY2ggY2xpZW50LlxuICAgICAqXG4gICAgICogVGhpcyBraW5kIG9mIG1ldGEtaW5mb3JtYXRpb24gKCNjbGllbnRzLCAjc3RydWN0cy1wZXItY2xpZW50LXdyaXR0ZW4pIGlzIHdyaXR0ZW4gdG8gdGhlIHJlc3RFbmNvZGVyLlxuICAgICAqXG4gICAgICogV2UgZnJhZ21lbnQgdGhlIHJlc3RFbmNvZGVyIGFuZCBzdG9yZSBhIHNsaWNlIG9mIGl0IHBlci1jbGllbnQgdW50aWwgd2Uga25vdyBob3cgbWFueSBjbGllbnRzIHRoZXJlIGFyZS5cbiAgICAgKiBXaGVuIHdlIGZsdXNoICh0b1VpbnQ4QXJyYXkpIHdlIHdyaXRlIHRoZSByZXN0RW5jb2RlciB1c2luZyB0aGUgZnJhZ21lbnRzIGFuZCB0aGUgbWV0YS1pbmZvcm1hdGlvbi5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtBcnJheTx7IHdyaXR0ZW46IG51bWJlciwgcmVzdEVuY29kZXI6IFVpbnQ4QXJyYXkgfT59XG4gICAgICovXG4gICAgdGhpcy5jbGllbnRTdHJ1Y3RzID0gW11cbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8VWludDhBcnJheT59IHVwZGF0ZXNcbiAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9XG4gKi9cbmV4cG9ydCBjb25zdCBtZXJnZVVwZGF0ZXMgPSB1cGRhdGVzID0+IG1lcmdlVXBkYXRlc1YyKHVwZGF0ZXMsIFVwZGF0ZURlY29kZXJWMSwgVXBkYXRlRW5jb2RlclYxKVxuXG4vKipcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gdXBkYXRlXG4gKiBAcGFyYW0ge3R5cGVvZiBEU0VuY29kZXJWMSB8IHR5cGVvZiBEU0VuY29kZXJWMn0gWUVuY29kZXJcbiAqIEBwYXJhbSB7dHlwZW9mIFVwZGF0ZURlY29kZXJWMSB8IHR5cGVvZiBVcGRhdGVEZWNvZGVyVjJ9IFlEZWNvZGVyXG4gKiBAcmV0dXJuIHtVaW50OEFycmF5fVxuICovXG5leHBvcnQgY29uc3QgZW5jb2RlU3RhdGVWZWN0b3JGcm9tVXBkYXRlVjIgPSAodXBkYXRlLCBZRW5jb2RlciA9IERTRW5jb2RlclYyLCBZRGVjb2RlciA9IFVwZGF0ZURlY29kZXJWMikgPT4ge1xuICBjb25zdCBlbmNvZGVyID0gbmV3IFlFbmNvZGVyKClcbiAgY29uc3QgdXBkYXRlRGVjb2RlciA9IG5ldyBMYXp5U3RydWN0UmVhZGVyKG5ldyBZRGVjb2RlcihkZWNvZGluZy5jcmVhdGVEZWNvZGVyKHVwZGF0ZSkpLCBmYWxzZSlcbiAgbGV0IGN1cnIgPSB1cGRhdGVEZWNvZGVyLmN1cnJcbiAgaWYgKGN1cnIgIT09IG51bGwpIHtcbiAgICBsZXQgc2l6ZSA9IDBcbiAgICBsZXQgY3VyckNsaWVudCA9IGN1cnIuaWQuY2xpZW50XG4gICAgbGV0IHN0b3BDb3VudGluZyA9IGN1cnIuaWQuY2xvY2sgIT09IDAgLy8gbXVzdCBzdGFydCBhdCAwXG4gICAgbGV0IGN1cnJDbG9jayA9IHN0b3BDb3VudGluZyA/IDAgOiBjdXJyLmlkLmNsb2NrICsgY3Vyci5sZW5ndGhcbiAgICBmb3IgKDsgY3VyciAhPT0gbnVsbDsgY3VyciA9IHVwZGF0ZURlY29kZXIubmV4dCgpKSB7XG4gICAgICBpZiAoY3VyckNsaWVudCAhPT0gY3Vyci5pZC5jbGllbnQpIHtcbiAgICAgICAgaWYgKGN1cnJDbG9jayAhPT0gMCkge1xuICAgICAgICAgIHNpemUrK1xuICAgICAgICAgIC8vIFdlIGZvdW5kIGEgbmV3IGNsaWVudFxuICAgICAgICAgIC8vIHdyaXRlIHdoYXQgd2UgaGF2ZSB0byB0aGUgZW5jb2RlclxuICAgICAgICAgIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyLnJlc3RFbmNvZGVyLCBjdXJyQ2xpZW50KVxuICAgICAgICAgIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyLnJlc3RFbmNvZGVyLCBjdXJyQ2xvY2spXG4gICAgICAgIH1cbiAgICAgICAgY3VyckNsaWVudCA9IGN1cnIuaWQuY2xpZW50XG4gICAgICAgIGN1cnJDbG9jayA9IDBcbiAgICAgICAgc3RvcENvdW50aW5nID0gY3Vyci5pZC5jbG9jayAhPT0gMFxuICAgICAgfVxuICAgICAgLy8gd2UgaWdub3JlIHNraXBzXG4gICAgICBpZiAoY3Vyci5jb25zdHJ1Y3RvciA9PT0gU2tpcCkge1xuICAgICAgICBzdG9wQ291bnRpbmcgPSB0cnVlXG4gICAgICB9XG4gICAgICBpZiAoIXN0b3BDb3VudGluZykge1xuICAgICAgICBjdXJyQ2xvY2sgPSBjdXJyLmlkLmNsb2NrICsgY3Vyci5sZW5ndGhcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gd3JpdGUgd2hhdCB3ZSBoYXZlXG4gICAgaWYgKGN1cnJDbG9jayAhPT0gMCkge1xuICAgICAgc2l6ZSsrXG4gICAgICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2Rlci5yZXN0RW5jb2RlciwgY3VyckNsaWVudClcbiAgICAgIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyLnJlc3RFbmNvZGVyLCBjdXJyQ2xvY2spXG4gICAgfVxuICAgIC8vIHByZXBlbmQgdGhlIHNpemUgb2YgdGhlIHN0YXRlIHZlY3RvclxuICAgIGNvbnN0IGVuYyA9IGVuY29kaW5nLmNyZWF0ZUVuY29kZXIoKVxuICAgIGVuY29kaW5nLndyaXRlVmFyVWludChlbmMsIHNpemUpXG4gICAgZW5jb2Rpbmcud3JpdGVCaW5hcnlFbmNvZGVyKGVuYywgZW5jb2Rlci5yZXN0RW5jb2RlcilcbiAgICBlbmNvZGVyLnJlc3RFbmNvZGVyID0gZW5jXG4gICAgcmV0dXJuIGVuY29kZXIudG9VaW50OEFycmF5KClcbiAgfSBlbHNlIHtcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2Rlci5yZXN0RW5jb2RlciwgMClcbiAgICByZXR1cm4gZW5jb2Rlci50b1VpbnQ4QXJyYXkoKVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSB1cGRhdGVcbiAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9XG4gKi9cbmV4cG9ydCBjb25zdCBlbmNvZGVTdGF0ZVZlY3RvckZyb21VcGRhdGUgPSB1cGRhdGUgPT4gZW5jb2RlU3RhdGVWZWN0b3JGcm9tVXBkYXRlVjIodXBkYXRlLCBEU0VuY29kZXJWMSwgVXBkYXRlRGVjb2RlclYxKVxuXG4vKipcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gdXBkYXRlXG4gKiBAcGFyYW0ge3R5cGVvZiBVcGRhdGVEZWNvZGVyVjEgfCB0eXBlb2YgVXBkYXRlRGVjb2RlclYyfSBZRGVjb2RlclxuICogQHJldHVybiB7eyBmcm9tOiBNYXA8bnVtYmVyLG51bWJlcj4sIHRvOiBNYXA8bnVtYmVyLG51bWJlcj4gfX1cbiAqL1xuZXhwb3J0IGNvbnN0IHBhcnNlVXBkYXRlTWV0YVYyID0gKHVwZGF0ZSwgWURlY29kZXIgPSBVcGRhdGVEZWNvZGVyVjIpID0+IHtcbiAgLyoqXG4gICAqIEB0eXBlIHtNYXA8bnVtYmVyLCBudW1iZXI+fVxuICAgKi9cbiAgY29uc3QgZnJvbSA9IG5ldyBNYXAoKVxuICAvKipcbiAgICogQHR5cGUge01hcDxudW1iZXIsIG51bWJlcj59XG4gICAqL1xuICBjb25zdCB0byA9IG5ldyBNYXAoKVxuICBjb25zdCB1cGRhdGVEZWNvZGVyID0gbmV3IExhenlTdHJ1Y3RSZWFkZXIobmV3IFlEZWNvZGVyKGRlY29kaW5nLmNyZWF0ZURlY29kZXIodXBkYXRlKSksIGZhbHNlKVxuICBsZXQgY3VyciA9IHVwZGF0ZURlY29kZXIuY3VyclxuICBpZiAoY3VyciAhPT0gbnVsbCkge1xuICAgIGxldCBjdXJyQ2xpZW50ID0gY3Vyci5pZC5jbGllbnRcbiAgICBsZXQgY3VyckNsb2NrID0gY3Vyci5pZC5jbG9ja1xuICAgIC8vIHdyaXRlIHRoZSBiZWdpbm5pbmcgdG8gYGZyb21gXG4gICAgZnJvbS5zZXQoY3VyckNsaWVudCwgY3VyckNsb2NrKVxuICAgIGZvciAoOyBjdXJyICE9PSBudWxsOyBjdXJyID0gdXBkYXRlRGVjb2Rlci5uZXh0KCkpIHtcbiAgICAgIGlmIChjdXJyQ2xpZW50ICE9PSBjdXJyLmlkLmNsaWVudCkge1xuICAgICAgICAvLyBXZSBmb3VuZCBhIG5ldyBjbGllbnRcbiAgICAgICAgLy8gd3JpdGUgdGhlIGVuZCB0byBgdG9gXG4gICAgICAgIHRvLnNldChjdXJyQ2xpZW50LCBjdXJyQ2xvY2spXG4gICAgICAgIC8vIHdyaXRlIHRoZSBiZWdpbm5pbmcgdG8gYGZyb21gXG4gICAgICAgIGZyb20uc2V0KGN1cnIuaWQuY2xpZW50LCBjdXJyLmlkLmNsb2NrKVxuICAgICAgICAvLyB1cGRhdGUgY3VyckNsaWVudFxuICAgICAgICBjdXJyQ2xpZW50ID0gY3Vyci5pZC5jbGllbnRcbiAgICAgIH1cbiAgICAgIGN1cnJDbG9jayA9IGN1cnIuaWQuY2xvY2sgKyBjdXJyLmxlbmd0aFxuICAgIH1cbiAgICAvLyB3cml0ZSB0aGUgZW5kIHRvIGB0b2BcbiAgICB0by5zZXQoY3VyckNsaWVudCwgY3VyckNsb2NrKVxuICB9XG4gIHJldHVybiB7IGZyb20sIHRvIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHVwZGF0ZVxuICogQHJldHVybiB7eyBmcm9tOiBNYXA8bnVtYmVyLG51bWJlcj4sIHRvOiBNYXA8bnVtYmVyLG51bWJlcj4gfX1cbiAqL1xuZXhwb3J0IGNvbnN0IHBhcnNlVXBkYXRlTWV0YSA9IHVwZGF0ZSA9PiBwYXJzZVVwZGF0ZU1ldGFWMih1cGRhdGUsIFVwZGF0ZURlY29kZXJWMSlcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyBpbnRlbmRlZCB0byBzbGljZSBhbnkga2luZCBvZiBzdHJ1Y3QgYW5kIHJldHJpZXZlIHRoZSByaWdodCBwYXJ0LlxuICogSXQgZG9lcyBub3QgaGFuZGxlIHNpZGUtZWZmZWN0cywgc28gaXQgc2hvdWxkIG9ubHkgYmUgdXNlZCBieSB0aGUgbGF6eS1lbmNvZGVyLlxuICpcbiAqIEBwYXJhbSB7SXRlbSB8IEdDIHwgU2tpcH0gbGVmdFxuICogQHBhcmFtIHtudW1iZXJ9IGRpZmZcbiAqIEByZXR1cm4ge0l0ZW0gfCBHQ31cbiAqL1xuY29uc3Qgc2xpY2VTdHJ1Y3QgPSAobGVmdCwgZGlmZikgPT4ge1xuICBpZiAobGVmdC5jb25zdHJ1Y3RvciA9PT0gR0MpIHtcbiAgICBjb25zdCB7IGNsaWVudCwgY2xvY2sgfSA9IGxlZnQuaWRcbiAgICByZXR1cm4gbmV3IEdDKGNyZWF0ZUlEKGNsaWVudCwgY2xvY2sgKyBkaWZmKSwgbGVmdC5sZW5ndGggLSBkaWZmKVxuICB9IGVsc2UgaWYgKGxlZnQuY29uc3RydWN0b3IgPT09IFNraXApIHtcbiAgICBjb25zdCB7IGNsaWVudCwgY2xvY2sgfSA9IGxlZnQuaWRcbiAgICByZXR1cm4gbmV3IFNraXAoY3JlYXRlSUQoY2xpZW50LCBjbG9jayArIGRpZmYpLCBsZWZ0Lmxlbmd0aCAtIGRpZmYpXG4gIH0gZWxzZSB7XG4gICAgY29uc3QgbGVmdEl0ZW0gPSAvKiogQHR5cGUge0l0ZW19ICovIChsZWZ0KVxuICAgIGNvbnN0IHsgY2xpZW50LCBjbG9jayB9ID0gbGVmdEl0ZW0uaWRcbiAgICByZXR1cm4gbmV3IEl0ZW0oXG4gICAgICBjcmVhdGVJRChjbGllbnQsIGNsb2NrICsgZGlmZiksXG4gICAgICBudWxsLFxuICAgICAgY3JlYXRlSUQoY2xpZW50LCBjbG9jayArIGRpZmYgLSAxKSxcbiAgICAgIG51bGwsXG4gICAgICBsZWZ0SXRlbS5yaWdodE9yaWdpbixcbiAgICAgIGxlZnRJdGVtLnBhcmVudCxcbiAgICAgIGxlZnRJdGVtLnBhcmVudFN1YixcbiAgICAgIGxlZnRJdGVtLmNvbnRlbnQuc3BsaWNlKGRpZmYpXG4gICAgKVxuICB9XG59XG5cbi8qKlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gd29ya3Mgc2ltaWxhcmx5IHRvIGByZWFkVXBkYXRlVjJgLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8VWludDhBcnJheT59IHVwZGF0ZXNcbiAqIEBwYXJhbSB7dHlwZW9mIFVwZGF0ZURlY29kZXJWMSB8IHR5cGVvZiBVcGRhdGVEZWNvZGVyVjJ9IFtZRGVjb2Rlcl1cbiAqIEBwYXJhbSB7dHlwZW9mIFVwZGF0ZUVuY29kZXJWMSB8IHR5cGVvZiBVcGRhdGVFbmNvZGVyVjJ9IFtZRW5jb2Rlcl1cbiAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9XG4gKi9cbmV4cG9ydCBjb25zdCBtZXJnZVVwZGF0ZXNWMiA9ICh1cGRhdGVzLCBZRGVjb2RlciA9IFVwZGF0ZURlY29kZXJWMiwgWUVuY29kZXIgPSBVcGRhdGVFbmNvZGVyVjIpID0+IHtcbiAgaWYgKHVwZGF0ZXMubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIHVwZGF0ZXNbMF1cbiAgfVxuICBjb25zdCB1cGRhdGVEZWNvZGVycyA9IHVwZGF0ZXMubWFwKHVwZGF0ZSA9PiBuZXcgWURlY29kZXIoZGVjb2RpbmcuY3JlYXRlRGVjb2Rlcih1cGRhdGUpKSlcbiAgbGV0IGxhenlTdHJ1Y3REZWNvZGVycyA9IHVwZGF0ZURlY29kZXJzLm1hcChkZWNvZGVyID0+IG5ldyBMYXp5U3RydWN0UmVhZGVyKGRlY29kZXIsIHRydWUpKVxuXG4gIC8qKlxuICAgKiBAdG9kbyB3ZSBkb24ndCBuZWVkIG9mZnNldCBiZWNhdXNlIHdlIGFsd2F5cyBzbGljZSBiZWZvcmVcbiAgICogQHR5cGUge251bGwgfCB7IHN0cnVjdDogSXRlbSB8IEdDIHwgU2tpcCwgb2Zmc2V0OiBudW1iZXIgfX1cbiAgICovXG4gIGxldCBjdXJyV3JpdGUgPSBudWxsXG5cbiAgY29uc3QgdXBkYXRlRW5jb2RlciA9IG5ldyBZRW5jb2RlcigpXG4gIC8vIHdyaXRlIHN0cnVjdHMgbGF6aWx5XG4gIGNvbnN0IGxhenlTdHJ1Y3RFbmNvZGVyID0gbmV3IExhenlTdHJ1Y3RXcml0ZXIodXBkYXRlRW5jb2RlcilcblxuICAvLyBOb3RlOiBXZSBuZWVkIHRvIGVuc3VyZSB0aGF0IGFsbCBsYXp5U3RydWN0RGVjb2RlcnMgYXJlIGZ1bGx5IGNvbnN1bWVkXG4gIC8vIE5vdGU6IFNob3VsZCBtZXJnZSBkb2N1bWVudCB1cGRhdGVzIHdoZW5ldmVyIHBvc3NpYmxlIC0gZXZlbiBmcm9tIGRpZmZlcmVudCB1cGRhdGVzXG4gIC8vIE5vdGU6IFNob3VsZCBoYW5kbGUgdGhhdCBzb21lIG9wZXJhdGlvbnMgY2Fubm90IGJlIGFwcGxpZWQgeWV0ICgpXG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICAvLyBXcml0ZSBoaWdoZXIgY2xpZW50cyBmaXJzdCDih5Igc29ydCBieSBjbGllbnRJRCAmIGNsb2NrIGFuZCByZW1vdmUgZGVjb2RlcnMgd2l0aG91dCBjb250ZW50XG4gICAgbGF6eVN0cnVjdERlY29kZXJzID0gbGF6eVN0cnVjdERlY29kZXJzLmZpbHRlcihkZWMgPT4gZGVjLmN1cnIgIT09IG51bGwpXG4gICAgbGF6eVN0cnVjdERlY29kZXJzLnNvcnQoXG4gICAgICAvKiogQHR5cGUge2Z1bmN0aW9uKGFueSxhbnkpOm51bWJlcn0gKi8gKGRlYzEsIGRlYzIpID0+IHtcbiAgICAgICAgaWYgKGRlYzEuY3Vyci5pZC5jbGllbnQgPT09IGRlYzIuY3Vyci5pZC5jbGllbnQpIHtcbiAgICAgICAgICBjb25zdCBjbG9ja0RpZmYgPSBkZWMxLmN1cnIuaWQuY2xvY2sgLSBkZWMyLmN1cnIuaWQuY2xvY2tcbiAgICAgICAgICBpZiAoY2xvY2tEaWZmID09PSAwKSB7XG4gICAgICAgICAgICAvLyBAdG9kbyByZW1vdmUgcmVmZXJlbmNlcyB0byBza2lwIHNpbmNlIHRoZSBzdHJ1Y3REZWNvZGVycyBtdXN0IGZpbHRlciBTa2lwcy5cbiAgICAgICAgICAgIHJldHVybiBkZWMxLmN1cnIuY29uc3RydWN0b3IgPT09IGRlYzIuY3Vyci5jb25zdHJ1Y3RvclxuICAgICAgICAgICAgICA/IDBcbiAgICAgICAgICAgICAgOiBkZWMxLmN1cnIuY29uc3RydWN0b3IgPT09IFNraXAgPyAxIDogLTEgLy8gd2UgYXJlIGZpbHRlcmluZyBza2lwcyBhbnl3YXkuXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjbG9ja0RpZmZcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGRlYzIuY3Vyci5pZC5jbGllbnQgLSBkZWMxLmN1cnIuaWQuY2xpZW50XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICApXG4gICAgaWYgKGxhenlTdHJ1Y3REZWNvZGVycy5sZW5ndGggPT09IDApIHtcbiAgICAgIGJyZWFrXG4gICAgfVxuICAgIGNvbnN0IGN1cnJEZWNvZGVyID0gbGF6eVN0cnVjdERlY29kZXJzWzBdXG4gICAgLy8gd3JpdGUgZnJvbSBjdXJyRGVjb2RlciB1bnRpbCB0aGUgbmV4dCBvcGVyYXRpb24gaXMgZnJvbSBhbm90aGVyIGNsaWVudCBvciBpZiBmaWxsZXItc3RydWN0XG4gICAgLy8gdGhlbiB3ZSBuZWVkIHRvIHJlb3JkZXIgdGhlIGRlY29kZXJzIGFuZCBmaW5kIHRoZSBuZXh0IG9wZXJhdGlvbiB0byB3cml0ZVxuICAgIGNvbnN0IGZpcnN0Q2xpZW50ID0gLyoqIEB0eXBlIHtJdGVtIHwgR0N9ICovIChjdXJyRGVjb2Rlci5jdXJyKS5pZC5jbGllbnRcblxuICAgIGlmIChjdXJyV3JpdGUgIT09IG51bGwpIHtcbiAgICAgIGxldCBjdXJyID0gLyoqIEB0eXBlIHtJdGVtIHwgR0MgfCBudWxsfSAqLyAoY3VyckRlY29kZXIuY3VycilcbiAgICAgIGxldCBpdGVyYXRlZCA9IGZhbHNlXG5cbiAgICAgIC8vIGl0ZXJhdGUgdW50aWwgd2UgZmluZCBzb21ldGhpbmcgdGhhdCB3ZSBoYXZlbid0IHdyaXR0ZW4gYWxyZWFkeVxuICAgICAgLy8gcmVtZW1iZXI6IGZpcnN0IHRoZSBoaWdoIGNsaWVudC1pZHMgYXJlIHdyaXR0ZW5cbiAgICAgIHdoaWxlIChjdXJyICE9PSBudWxsICYmIGN1cnIuaWQuY2xvY2sgKyBjdXJyLmxlbmd0aCA8PSBjdXJyV3JpdGUuc3RydWN0LmlkLmNsb2NrICsgY3VycldyaXRlLnN0cnVjdC5sZW5ndGggJiYgY3Vyci5pZC5jbGllbnQgPj0gY3VycldyaXRlLnN0cnVjdC5pZC5jbGllbnQpIHtcbiAgICAgICAgY3VyciA9IGN1cnJEZWNvZGVyLm5leHQoKVxuICAgICAgICBpdGVyYXRlZCA9IHRydWVcbiAgICAgIH1cbiAgICAgIGlmIChcbiAgICAgICAgY3VyciA9PT0gbnVsbCB8fCAvLyBjdXJyZW50IGRlY29kZXIgaXMgZW1wdHlcbiAgICAgICAgY3Vyci5pZC5jbGllbnQgIT09IGZpcnN0Q2xpZW50IHx8IC8vIGNoZWNrIHdoZXRoZXIgdGhlcmUgaXMgYW5vdGhlciBkZWNvZGVyIHRoYXQgaGFzIGhhcyB1cGRhdGVzIGZyb20gYGZpcnN0Q2xpZW50YFxuICAgICAgICAoaXRlcmF0ZWQgJiYgY3Vyci5pZC5jbG9jayA+IGN1cnJXcml0ZS5zdHJ1Y3QuaWQuY2xvY2sgKyBjdXJyV3JpdGUuc3RydWN0Lmxlbmd0aCkgLy8gdGhlIGFib3ZlIHdoaWxlIGxvb3Agd2FzIHVzZWQgYW5kIHdlIGFyZSBwb3RlbnRpYWxseSBtaXNzaW5nIHVwZGF0ZXNcbiAgICAgICkge1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICBpZiAoZmlyc3RDbGllbnQgIT09IGN1cnJXcml0ZS5zdHJ1Y3QuaWQuY2xpZW50KSB7XG4gICAgICAgIHdyaXRlU3RydWN0VG9MYXp5U3RydWN0V3JpdGVyKGxhenlTdHJ1Y3RFbmNvZGVyLCBjdXJyV3JpdGUuc3RydWN0LCBjdXJyV3JpdGUub2Zmc2V0KVxuICAgICAgICBjdXJyV3JpdGUgPSB7IHN0cnVjdDogY3Vyciwgb2Zmc2V0OiAwIH1cbiAgICAgICAgY3VyckRlY29kZXIubmV4dCgpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoY3VycldyaXRlLnN0cnVjdC5pZC5jbG9jayArIGN1cnJXcml0ZS5zdHJ1Y3QubGVuZ3RoIDwgY3Vyci5pZC5jbG9jaykge1xuICAgICAgICAgIC8vIEB0b2RvIHdyaXRlIGN1cnJTdHJ1Y3QgJiBzZXQgY3VyclN0cnVjdCA9IFNraXAoY2xvY2sgPSBjdXJyU3RydWN0LmlkLmNsb2NrICsgY3VyclN0cnVjdC5sZW5ndGgsIGxlbmd0aCA9IGN1cnIuaWQuY2xvY2sgLSBzZWxmLmNsb2NrKVxuICAgICAgICAgIGlmIChjdXJyV3JpdGUuc3RydWN0LmNvbnN0cnVjdG9yID09PSBTa2lwKSB7XG4gICAgICAgICAgICAvLyBleHRlbmQgZXhpc3Rpbmcgc2tpcFxuICAgICAgICAgICAgY3VycldyaXRlLnN0cnVjdC5sZW5ndGggPSBjdXJyLmlkLmNsb2NrICsgY3Vyci5sZW5ndGggLSBjdXJyV3JpdGUuc3RydWN0LmlkLmNsb2NrXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdyaXRlU3RydWN0VG9MYXp5U3RydWN0V3JpdGVyKGxhenlTdHJ1Y3RFbmNvZGVyLCBjdXJyV3JpdGUuc3RydWN0LCBjdXJyV3JpdGUub2Zmc2V0KVxuICAgICAgICAgICAgY29uc3QgZGlmZiA9IGN1cnIuaWQuY2xvY2sgLSBjdXJyV3JpdGUuc3RydWN0LmlkLmNsb2NrIC0gY3VycldyaXRlLnN0cnVjdC5sZW5ndGhcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHR5cGUge1NraXB9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNvbnN0IHN0cnVjdCA9IG5ldyBTa2lwKGNyZWF0ZUlEKGZpcnN0Q2xpZW50LCBjdXJyV3JpdGUuc3RydWN0LmlkLmNsb2NrICsgY3VycldyaXRlLnN0cnVjdC5sZW5ndGgpLCBkaWZmKVxuICAgICAgICAgICAgY3VycldyaXRlID0geyBzdHJ1Y3QsIG9mZnNldDogMCB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgeyAvLyBpZiAoY3VycldyaXRlLnN0cnVjdC5pZC5jbG9jayArIGN1cnJXcml0ZS5zdHJ1Y3QubGVuZ3RoID49IGN1cnIuaWQuY2xvY2spIHtcbiAgICAgICAgICBjb25zdCBkaWZmID0gY3VycldyaXRlLnN0cnVjdC5pZC5jbG9jayArIGN1cnJXcml0ZS5zdHJ1Y3QubGVuZ3RoIC0gY3Vyci5pZC5jbG9ja1xuICAgICAgICAgIGlmIChkaWZmID4gMCkge1xuICAgICAgICAgICAgaWYgKGN1cnJXcml0ZS5zdHJ1Y3QuY29uc3RydWN0b3IgPT09IFNraXApIHtcbiAgICAgICAgICAgICAgLy8gcHJlZmVyIHRvIHNsaWNlIFNraXAgYmVjYXVzZSB0aGUgb3RoZXIgc3RydWN0IG1pZ2h0IGNvbnRhaW4gbW9yZSBpbmZvcm1hdGlvblxuICAgICAgICAgICAgICBjdXJyV3JpdGUuc3RydWN0Lmxlbmd0aCAtPSBkaWZmXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjdXJyID0gc2xpY2VTdHJ1Y3QoY3VyciwgZGlmZilcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFjdXJyV3JpdGUuc3RydWN0Lm1lcmdlV2l0aCgvKiogQHR5cGUge2FueX0gKi8gKGN1cnIpKSkge1xuICAgICAgICAgICAgd3JpdGVTdHJ1Y3RUb0xhenlTdHJ1Y3RXcml0ZXIobGF6eVN0cnVjdEVuY29kZXIsIGN1cnJXcml0ZS5zdHJ1Y3QsIGN1cnJXcml0ZS5vZmZzZXQpXG4gICAgICAgICAgICBjdXJyV3JpdGUgPSB7IHN0cnVjdDogY3Vyciwgb2Zmc2V0OiAwIH1cbiAgICAgICAgICAgIGN1cnJEZWNvZGVyLm5leHQoKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyV3JpdGUgPSB7IHN0cnVjdDogLyoqIEB0eXBlIHtJdGVtIHwgR0N9ICovIChjdXJyRGVjb2Rlci5jdXJyKSwgb2Zmc2V0OiAwIH1cbiAgICAgIGN1cnJEZWNvZGVyLm5leHQoKVxuICAgIH1cbiAgICBmb3IgKFxuICAgICAgbGV0IG5leHQgPSBjdXJyRGVjb2Rlci5jdXJyO1xuICAgICAgbmV4dCAhPT0gbnVsbCAmJiBuZXh0LmlkLmNsaWVudCA9PT0gZmlyc3RDbGllbnQgJiYgbmV4dC5pZC5jbG9jayA9PT0gY3VycldyaXRlLnN0cnVjdC5pZC5jbG9jayArIGN1cnJXcml0ZS5zdHJ1Y3QubGVuZ3RoICYmIG5leHQuY29uc3RydWN0b3IgIT09IFNraXA7XG4gICAgICBuZXh0ID0gY3VyckRlY29kZXIubmV4dCgpXG4gICAgKSB7XG4gICAgICB3cml0ZVN0cnVjdFRvTGF6eVN0cnVjdFdyaXRlcihsYXp5U3RydWN0RW5jb2RlciwgY3VycldyaXRlLnN0cnVjdCwgY3VycldyaXRlLm9mZnNldClcbiAgICAgIGN1cnJXcml0ZSA9IHsgc3RydWN0OiBuZXh0LCBvZmZzZXQ6IDAgfVxuICAgIH1cbiAgfVxuICBpZiAoY3VycldyaXRlICE9PSBudWxsKSB7XG4gICAgd3JpdGVTdHJ1Y3RUb0xhenlTdHJ1Y3RXcml0ZXIobGF6eVN0cnVjdEVuY29kZXIsIGN1cnJXcml0ZS5zdHJ1Y3QsIGN1cnJXcml0ZS5vZmZzZXQpXG4gICAgY3VycldyaXRlID0gbnVsbFxuICB9XG4gIGZpbmlzaExhenlTdHJ1Y3RXcml0aW5nKGxhenlTdHJ1Y3RFbmNvZGVyKVxuXG4gIGNvbnN0IGRzcyA9IHVwZGF0ZURlY29kZXJzLm1hcChkZWNvZGVyID0+IHJlYWREZWxldGVTZXQoZGVjb2RlcikpXG4gIGNvbnN0IGRzID0gbWVyZ2VEZWxldGVTZXRzKGRzcylcbiAgd3JpdGVEZWxldGVTZXQodXBkYXRlRW5jb2RlciwgZHMpXG4gIHJldHVybiB1cGRhdGVFbmNvZGVyLnRvVWludDhBcnJheSgpXG59XG5cbi8qKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSB1cGRhdGVcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gc3ZcbiAqIEBwYXJhbSB7dHlwZW9mIFVwZGF0ZURlY29kZXJWMSB8IHR5cGVvZiBVcGRhdGVEZWNvZGVyVjJ9IFtZRGVjb2Rlcl1cbiAqIEBwYXJhbSB7dHlwZW9mIFVwZGF0ZUVuY29kZXJWMSB8IHR5cGVvZiBVcGRhdGVFbmNvZGVyVjJ9IFtZRW5jb2Rlcl1cbiAqL1xuZXhwb3J0IGNvbnN0IGRpZmZVcGRhdGVWMiA9ICh1cGRhdGUsIHN2LCBZRGVjb2RlciA9IFVwZGF0ZURlY29kZXJWMiwgWUVuY29kZXIgPSBVcGRhdGVFbmNvZGVyVjIpID0+IHtcbiAgY29uc3Qgc3RhdGUgPSBkZWNvZGVTdGF0ZVZlY3RvcihzdilcbiAgY29uc3QgZW5jb2RlciA9IG5ldyBZRW5jb2RlcigpXG4gIGNvbnN0IGxhenlTdHJ1Y3RXcml0ZXIgPSBuZXcgTGF6eVN0cnVjdFdyaXRlcihlbmNvZGVyKVxuICBjb25zdCBkZWNvZGVyID0gbmV3IFlEZWNvZGVyKGRlY29kaW5nLmNyZWF0ZURlY29kZXIodXBkYXRlKSlcbiAgY29uc3QgcmVhZGVyID0gbmV3IExhenlTdHJ1Y3RSZWFkZXIoZGVjb2RlciwgZmFsc2UpXG4gIHdoaWxlIChyZWFkZXIuY3Vycikge1xuICAgIGNvbnN0IGN1cnIgPSByZWFkZXIuY3VyclxuICAgIGNvbnN0IGN1cnJDbGllbnQgPSBjdXJyLmlkLmNsaWVudFxuICAgIGNvbnN0IHN2Q2xvY2sgPSBzdGF0ZS5nZXQoY3VyckNsaWVudCkgfHwgMFxuICAgIGlmIChyZWFkZXIuY3Vyci5jb25zdHJ1Y3RvciA9PT0gU2tpcCkge1xuICAgICAgLy8gdGhlIGZpcnN0IHdyaXR0ZW4gc3RydWN0IHNob3VsZG4ndCBiZSBhIHNraXBcbiAgICAgIHJlYWRlci5uZXh0KClcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIGlmIChjdXJyLmlkLmNsb2NrICsgY3Vyci5sZW5ndGggPiBzdkNsb2NrKSB7XG4gICAgICB3cml0ZVN0cnVjdFRvTGF6eVN0cnVjdFdyaXRlcihsYXp5U3RydWN0V3JpdGVyLCBjdXJyLCBtYXRoLm1heChzdkNsb2NrIC0gY3Vyci5pZC5jbG9jaywgMCkpXG4gICAgICByZWFkZXIubmV4dCgpXG4gICAgICB3aGlsZSAocmVhZGVyLmN1cnIgJiYgcmVhZGVyLmN1cnIuaWQuY2xpZW50ID09PSBjdXJyQ2xpZW50KSB7XG4gICAgICAgIHdyaXRlU3RydWN0VG9MYXp5U3RydWN0V3JpdGVyKGxhenlTdHJ1Y3RXcml0ZXIsIHJlYWRlci5jdXJyLCAwKVxuICAgICAgICByZWFkZXIubmV4dCgpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHJlYWQgdW50aWwgc29tZXRoaW5nIG5ldyBjb21lcyB1cFxuICAgICAgd2hpbGUgKHJlYWRlci5jdXJyICYmIHJlYWRlci5jdXJyLmlkLmNsaWVudCA9PT0gY3VyckNsaWVudCAmJiByZWFkZXIuY3Vyci5pZC5jbG9jayArIHJlYWRlci5jdXJyLmxlbmd0aCA8PSBzdkNsb2NrKSB7XG4gICAgICAgIHJlYWRlci5uZXh0KClcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZmluaXNoTGF6eVN0cnVjdFdyaXRpbmcobGF6eVN0cnVjdFdyaXRlcilcbiAgLy8gd3JpdGUgZHNcbiAgY29uc3QgZHMgPSByZWFkRGVsZXRlU2V0KGRlY29kZXIpXG4gIHdyaXRlRGVsZXRlU2V0KGVuY29kZXIsIGRzKVxuICByZXR1cm4gZW5jb2Rlci50b1VpbnQ4QXJyYXkoKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gdXBkYXRlXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHN2XG4gKi9cbmV4cG9ydCBjb25zdCBkaWZmVXBkYXRlID0gKHVwZGF0ZSwgc3YpID0+IGRpZmZVcGRhdGVWMih1cGRhdGUsIHN2LCBVcGRhdGVEZWNvZGVyVjEsIFVwZGF0ZUVuY29kZXJWMSlcblxuLyoqXG4gKiBAcGFyYW0ge0xhenlTdHJ1Y3RXcml0ZXJ9IGxhenlXcml0ZXJcbiAqL1xuY29uc3QgZmx1c2hMYXp5U3RydWN0V3JpdGVyID0gbGF6eVdyaXRlciA9PiB7XG4gIGlmIChsYXp5V3JpdGVyLndyaXR0ZW4gPiAwKSB7XG4gICAgbGF6eVdyaXRlci5jbGllbnRTdHJ1Y3RzLnB1c2goeyB3cml0dGVuOiBsYXp5V3JpdGVyLndyaXR0ZW4sIHJlc3RFbmNvZGVyOiBlbmNvZGluZy50b1VpbnQ4QXJyYXkobGF6eVdyaXRlci5lbmNvZGVyLnJlc3RFbmNvZGVyKSB9KVxuICAgIGxhenlXcml0ZXIuZW5jb2Rlci5yZXN0RW5jb2RlciA9IGVuY29kaW5nLmNyZWF0ZUVuY29kZXIoKVxuICAgIGxhenlXcml0ZXIud3JpdHRlbiA9IDBcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7TGF6eVN0cnVjdFdyaXRlcn0gbGF6eVdyaXRlclxuICogQHBhcmFtIHtJdGVtIHwgR0N9IHN0cnVjdFxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICovXG5jb25zdCB3cml0ZVN0cnVjdFRvTGF6eVN0cnVjdFdyaXRlciA9IChsYXp5V3JpdGVyLCBzdHJ1Y3QsIG9mZnNldCkgPT4ge1xuICAvLyBmbHVzaCBjdXJyIGlmIHdlIHN0YXJ0IGFub3RoZXIgY2xpZW50XG4gIGlmIChsYXp5V3JpdGVyLndyaXR0ZW4gPiAwICYmIGxhenlXcml0ZXIuY3VyckNsaWVudCAhPT0gc3RydWN0LmlkLmNsaWVudCkge1xuICAgIGZsdXNoTGF6eVN0cnVjdFdyaXRlcihsYXp5V3JpdGVyKVxuICB9XG4gIGlmIChsYXp5V3JpdGVyLndyaXR0ZW4gPT09IDApIHtcbiAgICBsYXp5V3JpdGVyLmN1cnJDbGllbnQgPSBzdHJ1Y3QuaWQuY2xpZW50XG4gICAgLy8gd3JpdGUgbmV4dCBjbGllbnRcbiAgICBsYXp5V3JpdGVyLmVuY29kZXIud3JpdGVDbGllbnQoc3RydWN0LmlkLmNsaWVudClcbiAgICAvLyB3cml0ZSBzdGFydENsb2NrXG4gICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGxhenlXcml0ZXIuZW5jb2Rlci5yZXN0RW5jb2Rlciwgc3RydWN0LmlkLmNsb2NrICsgb2Zmc2V0KVxuICB9XG4gIHN0cnVjdC53cml0ZShsYXp5V3JpdGVyLmVuY29kZXIsIG9mZnNldClcbiAgbGF6eVdyaXRlci53cml0dGVuKytcbn1cbi8qKlxuICogQ2FsbCB0aGlzIGZ1bmN0aW9uIHdoZW4gd2UgY29sbGVjdGVkIGFsbCBwYXJ0cyBhbmQgd2FudCB0b1xuICogcHV0IGFsbCB0aGUgcGFydHMgdG9nZXRoZXIuIEFmdGVyIGNhbGxpbmcgdGhpcyBtZXRob2QsXG4gKiB5b3UgY2FuIGNvbnRpbnVlIHVzaW5nIHRoZSBVcGRhdGVFbmNvZGVyLlxuICpcbiAqIEBwYXJhbSB7TGF6eVN0cnVjdFdyaXRlcn0gbGF6eVdyaXRlclxuICovXG5jb25zdCBmaW5pc2hMYXp5U3RydWN0V3JpdGluZyA9IChsYXp5V3JpdGVyKSA9PiB7XG4gIGZsdXNoTGF6eVN0cnVjdFdyaXRlcihsYXp5V3JpdGVyKVxuXG4gIC8vIHRoaXMgaXMgYSBmcmVzaCBlbmNvZGVyIGJlY2F1c2Ugd2UgY2FsbGVkIGZsdXNoQ3VyclxuICBjb25zdCByZXN0RW5jb2RlciA9IGxhenlXcml0ZXIuZW5jb2Rlci5yZXN0RW5jb2RlclxuXG4gIC8qKlxuICAgKiBOb3cgd2UgcHV0IGFsbCB0aGUgZnJhZ21lbnRzIHRvZ2V0aGVyLlxuICAgKiBUaGlzIHdvcmtzIHNpbWlsYXJseSB0byBgd3JpdGVDbGllbnRzU3RydWN0c2BcbiAgICovXG5cbiAgLy8gd3JpdGUgIyBzdGF0ZXMgdGhhdCB3ZXJlIHVwZGF0ZWQgLSBpLmUuIHRoZSBjbGllbnRzXG4gIGVuY29kaW5nLndyaXRlVmFyVWludChyZXN0RW5jb2RlciwgbGF6eVdyaXRlci5jbGllbnRTdHJ1Y3RzLmxlbmd0aClcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxhenlXcml0ZXIuY2xpZW50U3RydWN0cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHBhcnRTdHJ1Y3RzID0gbGF6eVdyaXRlci5jbGllbnRTdHJ1Y3RzW2ldXG4gICAgLyoqXG4gICAgICogV29ya3Mgc2ltaWxhcmx5IHRvIGB3cml0ZVN0cnVjdHNgXG4gICAgICovXG4gICAgLy8gd3JpdGUgIyBlbmNvZGVkIHN0cnVjdHNcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQocmVzdEVuY29kZXIsIHBhcnRTdHJ1Y3RzLndyaXR0ZW4pXG4gICAgLy8gd3JpdGUgdGhlIHJlc3Qgb2YgdGhlIGZyYWdtZW50XG4gICAgZW5jb2Rpbmcud3JpdGVVaW50OEFycmF5KHJlc3RFbmNvZGVyLCBwYXJ0U3RydWN0cy5yZXN0RW5jb2RlcilcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gdXBkYXRlXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKEl0ZW18R0N8U2tpcCk6SXRlbXxHQ3xTa2lwfSBibG9ja1RyYW5zZm9ybWVyXG4gKiBAcGFyYW0ge3R5cGVvZiBVcGRhdGVEZWNvZGVyVjIgfCB0eXBlb2YgVXBkYXRlRGVjb2RlclYxfSBZRGVjb2RlclxuICogQHBhcmFtIHt0eXBlb2YgVXBkYXRlRW5jb2RlclYyIHwgdHlwZW9mIFVwZGF0ZUVuY29kZXJWMSB9IFlFbmNvZGVyXG4gKi9cbmV4cG9ydCBjb25zdCBjb252ZXJ0VXBkYXRlRm9ybWF0ID0gKHVwZGF0ZSwgYmxvY2tUcmFuc2Zvcm1lciwgWURlY29kZXIsIFlFbmNvZGVyKSA9PiB7XG4gIGNvbnN0IHVwZGF0ZURlY29kZXIgPSBuZXcgWURlY29kZXIoZGVjb2RpbmcuY3JlYXRlRGVjb2Rlcih1cGRhdGUpKVxuICBjb25zdCBsYXp5RGVjb2RlciA9IG5ldyBMYXp5U3RydWN0UmVhZGVyKHVwZGF0ZURlY29kZXIsIGZhbHNlKVxuICBjb25zdCB1cGRhdGVFbmNvZGVyID0gbmV3IFlFbmNvZGVyKClcbiAgY29uc3QgbGF6eVdyaXRlciA9IG5ldyBMYXp5U3RydWN0V3JpdGVyKHVwZGF0ZUVuY29kZXIpXG4gIGZvciAobGV0IGN1cnIgPSBsYXp5RGVjb2Rlci5jdXJyOyBjdXJyICE9PSBudWxsOyBjdXJyID0gbGF6eURlY29kZXIubmV4dCgpKSB7XG4gICAgd3JpdGVTdHJ1Y3RUb0xhenlTdHJ1Y3RXcml0ZXIobGF6eVdyaXRlciwgYmxvY2tUcmFuc2Zvcm1lcihjdXJyKSwgMClcbiAgfVxuICBmaW5pc2hMYXp5U3RydWN0V3JpdGluZyhsYXp5V3JpdGVyKVxuICBjb25zdCBkcyA9IHJlYWREZWxldGVTZXQodXBkYXRlRGVjb2RlcilcbiAgd3JpdGVEZWxldGVTZXQodXBkYXRlRW5jb2RlciwgZHMpXG4gIHJldHVybiB1cGRhdGVFbmNvZGVyLnRvVWludDhBcnJheSgpXG59XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT2JmdXNjYXRvck9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW09iZnVzY2F0b3JPcHRpb25zLmZvcm1hdHRpbmc9dHJ1ZV1cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW09iZnVzY2F0b3JPcHRpb25zLnN1YmRvY3M9dHJ1ZV1cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW09iZnVzY2F0b3JPcHRpb25zLnl4bWw9dHJ1ZV0gV2hldGhlciB0byBvYmZ1c2NhdGUgbm9kZU5hbWUgLyBob29rTmFtZVxuICovXG5cbi8qKlxuICogQHBhcmFtIHtPYmZ1c2NhdG9yT3B0aW9uc30gb2JmdXNjYXRvclxuICovXG5jb25zdCBjcmVhdGVPYmZ1c2NhdG9yID0gKHsgZm9ybWF0dGluZyA9IHRydWUsIHN1YmRvY3MgPSB0cnVlLCB5eG1sID0gdHJ1ZSB9ID0ge30pID0+IHtcbiAgbGV0IGkgPSAwXG4gIGNvbnN0IG1hcEtleUNhY2hlID0gbWFwLmNyZWF0ZSgpXG4gIGNvbnN0IG5vZGVOYW1lQ2FjaGUgPSBtYXAuY3JlYXRlKClcbiAgY29uc3QgZm9ybWF0dGluZ0tleUNhY2hlID0gbWFwLmNyZWF0ZSgpXG4gIGNvbnN0IGZvcm1hdHRpbmdWYWx1ZUNhY2hlID0gbWFwLmNyZWF0ZSgpXG4gIGZvcm1hdHRpbmdWYWx1ZUNhY2hlLnNldChudWxsLCBudWxsKSAvLyBlbmQgb2YgYSBmb3JtYXR0aW5nIHJhbmdlIHNob3VsZCBhbHdheXMgYmUgdGhlIGVuZCBvZiBhIGZvcm1hdHRpbmcgcmFuZ2VcbiAgLyoqXG4gICAqIEBwYXJhbSB7SXRlbXxHQ3xTa2lwfSBibG9ja1xuICAgKiBAcmV0dXJuIHtJdGVtfEdDfFNraXB9XG4gICAqL1xuICByZXR1cm4gYmxvY2sgPT4ge1xuICAgIHN3aXRjaCAoYmxvY2suY29uc3RydWN0b3IpIHtcbiAgICAgIGNhc2UgR0M6XG4gICAgICBjYXNlIFNraXA6XG4gICAgICAgIHJldHVybiBibG9ja1xuICAgICAgY2FzZSBJdGVtOiB7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSAvKiogQHR5cGUge0l0ZW19ICovIChibG9jaylcbiAgICAgICAgY29uc3QgY29udGVudCA9IGl0ZW0uY29udGVudFxuICAgICAgICBzd2l0Y2ggKGNvbnRlbnQuY29uc3RydWN0b3IpIHtcbiAgICAgICAgICBjYXNlIENvbnRlbnREZWxldGVkOlxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICBjYXNlIENvbnRlbnRUeXBlOiB7XG4gICAgICAgICAgICBpZiAoeXhtbCkge1xuICAgICAgICAgICAgICBjb25zdCB0eXBlID0gLyoqIEB0eXBlIHtDb250ZW50VHlwZX0gKi8gKGNvbnRlbnQpLnR5cGVcbiAgICAgICAgICAgICAgaWYgKHR5cGUgaW5zdGFuY2VvZiBZWG1sRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHR5cGUubm9kZU5hbWUgPSBtYXAuc2V0SWZVbmRlZmluZWQobm9kZU5hbWVDYWNoZSwgdHlwZS5ub2RlTmFtZSwgKCkgPT4gJ25vZGUtJyArIGkpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHR5cGUgaW5zdGFuY2VvZiBZWG1sSG9vaykge1xuICAgICAgICAgICAgICAgIHR5cGUuaG9va05hbWUgPSBtYXAuc2V0SWZVbmRlZmluZWQobm9kZU5hbWVDYWNoZSwgdHlwZS5ob29rTmFtZSwgKCkgPT4gJ2hvb2stJyArIGkpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgQ29udGVudEFueToge1xuICAgICAgICAgICAgY29uc3QgYyA9IC8qKiBAdHlwZSB7Q29udGVudEFueX0gKi8gKGNvbnRlbnQpXG4gICAgICAgICAgICBjLmFyciA9IGMuYXJyLm1hcCgoKSA9PiBpKVxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBDb250ZW50QmluYXJ5OiB7XG4gICAgICAgICAgICBjb25zdCBjID0gLyoqIEB0eXBlIHtDb250ZW50QmluYXJ5fSAqLyAoY29udGVudClcbiAgICAgICAgICAgIGMuY29udGVudCA9IG5ldyBVaW50OEFycmF5KFtpXSlcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgQ29udGVudERvYzoge1xuICAgICAgICAgICAgY29uc3QgYyA9IC8qKiBAdHlwZSB7Q29udGVudERvY30gKi8gKGNvbnRlbnQpXG4gICAgICAgICAgICBpZiAoc3ViZG9jcykge1xuICAgICAgICAgICAgICBjLm9wdHMgPSB7fVxuICAgICAgICAgICAgICBjLmRvYy5ndWlkID0gaSArICcnXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIENvbnRlbnRFbWJlZDoge1xuICAgICAgICAgICAgY29uc3QgYyA9IC8qKiBAdHlwZSB7Q29udGVudEVtYmVkfSAqLyAoY29udGVudClcbiAgICAgICAgICAgIGMuZW1iZWQgPSB7fVxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBDb250ZW50Rm9ybWF0OiB7XG4gICAgICAgICAgICBjb25zdCBjID0gLyoqIEB0eXBlIHtDb250ZW50Rm9ybWF0fSAqLyAoY29udGVudClcbiAgICAgICAgICAgIGlmIChmb3JtYXR0aW5nKSB7XG4gICAgICAgICAgICAgIGMua2V5ID0gbWFwLnNldElmVW5kZWZpbmVkKGZvcm1hdHRpbmdLZXlDYWNoZSwgYy5rZXksICgpID0+IGkgKyAnJylcbiAgICAgICAgICAgICAgYy52YWx1ZSA9IG1hcC5zZXRJZlVuZGVmaW5lZChmb3JtYXR0aW5nVmFsdWVDYWNoZSwgYy52YWx1ZSwgKCkgPT4gKHsgaSB9KSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgQ29udGVudEpTT046IHtcbiAgICAgICAgICAgIGNvbnN0IGMgPSAvKiogQHR5cGUge0NvbnRlbnRKU09OfSAqLyAoY29udGVudClcbiAgICAgICAgICAgIGMuYXJyID0gYy5hcnIubWFwKCgpID0+IGkpXG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIENvbnRlbnRTdHJpbmc6IHtcbiAgICAgICAgICAgIGNvbnN0IGMgPSAvKiogQHR5cGUge0NvbnRlbnRTdHJpbmd9ICovIChjb250ZW50KVxuICAgICAgICAgICAgYy5zdHIgPSBzdHJpbmcucmVwZWF0KChpICUgMTApICsgJycsIGMuc3RyLmxlbmd0aClcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAvLyB1bmtub3duIGNvbnRlbnQgdHlwZVxuICAgICAgICAgICAgZXJyb3IudW5leHBlY3RlZENhc2UoKVxuICAgICAgICB9XG4gICAgICAgIGlmIChpdGVtLnBhcmVudFN1Yikge1xuICAgICAgICAgIGl0ZW0ucGFyZW50U3ViID0gbWFwLnNldElmVW5kZWZpbmVkKG1hcEtleUNhY2hlLCBpdGVtLnBhcmVudFN1YiwgKCkgPT4gaSArICcnKVxuICAgICAgICB9XG4gICAgICAgIGkrK1xuICAgICAgICByZXR1cm4gYmxvY2tcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIC8vIHVua25vd24gYmxvY2stdHlwZVxuICAgICAgICBlcnJvci51bmV4cGVjdGVkQ2FzZSgpXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBvYmZ1c2NhdGVzIHRoZSBjb250ZW50IG9mIGEgWWpzIHVwZGF0ZS4gVGhpcyBpcyB1c2VmdWwgdG8gc2hhcmVcbiAqIGJ1Z2d5IFlqcyBkb2N1bWVudHMgd2hpbGUgc2lnbmlmaWNhbnRseSBsaW1pdGluZyB0aGUgcG9zc2liaWxpdHkgdGhhdCBhXG4gKiBkZXZlbG9wZXIgY2FuIG9uIHRoZSB1c2VyLiBOb3RlIHRoYXQgaXQgbWlnaHQgc3RpbGwgYmUgcG9zc2libGUgdG8gZGVkdWNlXG4gKiBzb21lIGluZm9ybWF0aW9uIGJ5IGFuYWx5emluZyB0aGUgXCJzdHJ1Y3R1cmVcIiBvZiB0aGUgZG9jdW1lbnQgb3IgYnkgYW5hbHl6aW5nXG4gKiB0aGUgdHlwaW5nIGJlaGF2aW9yIHVzaW5nIHRoZSBDUkRULXJlbGF0ZWQgbWV0YWRhdGEgdGhhdCBpcyBzdGlsbCBrZXB0IGZ1bGx5XG4gKiBpbnRhY3QuXG4gKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSB1cGRhdGVcbiAqIEBwYXJhbSB7T2JmdXNjYXRvck9wdGlvbnN9IFtvcHRzXVxuICovXG5leHBvcnQgY29uc3Qgb2JmdXNjYXRlVXBkYXRlID0gKHVwZGF0ZSwgb3B0cykgPT4gY29udmVydFVwZGF0ZUZvcm1hdCh1cGRhdGUsIGNyZWF0ZU9iZnVzY2F0b3Iob3B0cyksIFVwZGF0ZURlY29kZXJWMSwgVXBkYXRlRW5jb2RlclYxKVxuXG4vKipcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gdXBkYXRlXG4gKiBAcGFyYW0ge09iZnVzY2F0b3JPcHRpb25zfSBbb3B0c11cbiAqL1xuZXhwb3J0IGNvbnN0IG9iZnVzY2F0ZVVwZGF0ZVYyID0gKHVwZGF0ZSwgb3B0cykgPT4gY29udmVydFVwZGF0ZUZvcm1hdCh1cGRhdGUsIGNyZWF0ZU9iZnVzY2F0b3Iob3B0cyksIFVwZGF0ZURlY29kZXJWMiwgVXBkYXRlRW5jb2RlclYyKVxuXG4vKipcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gdXBkYXRlXG4gKi9cbmV4cG9ydCBjb25zdCBjb252ZXJ0VXBkYXRlRm9ybWF0VjFUb1YyID0gdXBkYXRlID0+IGNvbnZlcnRVcGRhdGVGb3JtYXQodXBkYXRlLCBmLmlkLCBVcGRhdGVEZWNvZGVyVjEsIFVwZGF0ZUVuY29kZXJWMilcblxuLyoqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHVwZGF0ZVxuICovXG5leHBvcnQgY29uc3QgY29udmVydFVwZGF0ZUZvcm1hdFYyVG9WMSA9IHVwZGF0ZSA9PiBjb252ZXJ0VXBkYXRlRm9ybWF0KHVwZGF0ZSwgZi5pZCwgVXBkYXRlRGVjb2RlclYyLCBVcGRhdGVFbmNvZGVyVjEpXG4iLCAiXG5pbXBvcnQge1xuICBpc0RlbGV0ZWQsXG4gIEl0ZW0sIEFic3RyYWN0VHlwZSwgVHJhbnNhY3Rpb24sIEFic3RyYWN0U3RydWN0IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbn0gZnJvbSAnLi4vaW50ZXJuYWxzLmpzJ1xuXG5pbXBvcnQgKiBhcyBzZXQgZnJvbSAnbGliMC9zZXQnXG5pbXBvcnQgKiBhcyBhcnJheSBmcm9tICdsaWIwL2FycmF5J1xuaW1wb3J0ICogYXMgZXJyb3IgZnJvbSAnbGliMC9lcnJvcidcblxuY29uc3QgZXJyb3JDb21wdXRlQ2hhbmdlcyA9ICdZb3UgbXVzdCBub3QgY29tcHV0ZSBjaGFuZ2VzIGFmdGVyIHRoZSBldmVudC1oYW5kbGVyIGZpcmVkLidcblxuLyoqXG4gKiBAdGVtcGxhdGUge0Fic3RyYWN0VHlwZTxhbnk+fSBUXG4gKiBZRXZlbnQgZGVzY3JpYmVzIHRoZSBjaGFuZ2VzIG9uIGEgWVR5cGUuXG4gKi9cbmV4cG9ydCBjbGFzcyBZRXZlbnQge1xuICAvKipcbiAgICogQHBhcmFtIHtUfSB0YXJnZXQgVGhlIGNoYW5nZWQgdHlwZS5cbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICovXG4gIGNvbnN0cnVjdG9yICh0YXJnZXQsIHRyYW5zYWN0aW9uKSB7XG4gICAgLyoqXG4gICAgICogVGhlIHR5cGUgb24gd2hpY2ggdGhpcyBldmVudCB3YXMgY3JlYXRlZCBvbi5cbiAgICAgKiBAdHlwZSB7VH1cbiAgICAgKi9cbiAgICB0aGlzLnRhcmdldCA9IHRhcmdldFxuICAgIC8qKlxuICAgICAqIFRoZSBjdXJyZW50IHRhcmdldCBvbiB3aGljaCB0aGUgb2JzZXJ2ZSBjYWxsYmFjayBpcyBjYWxsZWQuXG4gICAgICogQHR5cGUge0Fic3RyYWN0VHlwZTxhbnk+fVxuICAgICAqL1xuICAgIHRoaXMuY3VycmVudFRhcmdldCA9IHRhcmdldFxuICAgIC8qKlxuICAgICAqIFRoZSB0cmFuc2FjdGlvbiB0aGF0IHRyaWdnZXJlZCB0aGlzIGV2ZW50LlxuICAgICAqIEB0eXBlIHtUcmFuc2FjdGlvbn1cbiAgICAgKi9cbiAgICB0aGlzLnRyYW5zYWN0aW9uID0gdHJhbnNhY3Rpb25cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7T2JqZWN0fG51bGx9XG4gICAgICovXG4gICAgdGhpcy5fY2hhbmdlcyA9IG51bGxcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVsbCB8IE1hcDxzdHJpbmcsIHsgYWN0aW9uOiAnYWRkJyB8ICd1cGRhdGUnIHwgJ2RlbGV0ZScsIG9sZFZhbHVlOiBhbnksIG5ld1ZhbHVlOiBhbnkgfT59XG4gICAgICovXG4gICAgdGhpcy5fa2V5cyA9IG51bGxcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVsbCB8IEFycmF5PHsgaW5zZXJ0Pzogc3RyaW5nIHwgQXJyYXk8YW55PiB8IG9iamVjdCB8IEFic3RyYWN0VHlwZTxhbnk+LCByZXRhaW4/OiBudW1iZXIsIGRlbGV0ZT86IG51bWJlciwgYXR0cmlidXRlcz86IE9iamVjdDxzdHJpbmcsIGFueT4gfT59XG4gICAgICovXG4gICAgdGhpcy5fZGVsdGEgPSBudWxsXG4gICAgLyoqXG4gICAgICogQHR5cGUge0FycmF5PHN0cmluZ3xudW1iZXI+fG51bGx9XG4gICAgICovXG4gICAgdGhpcy5fcGF0aCA9IG51bGxcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wdXRlcyB0aGUgcGF0aCBmcm9tIGB5YCB0byB0aGUgY2hhbmdlZCB0eXBlLlxuICAgKlxuICAgKiBAdG9kbyB2MTQgc2hvdWxkIHN0YW5kYXJkaXplIG9uIHBhdGg6IEFycmF5PHtwYXJlbnQsIGluZGV4fT4gYmVjYXVzZSB0aGF0IGlzIGVhc2llciB0byB3b3JrIHdpdGguXG4gICAqXG4gICAqIFRoZSBmb2xsb3dpbmcgcHJvcGVydHkgaG9sZHM6XG4gICAqIEBleGFtcGxlXG4gICAqICAgbGV0IHR5cGUgPSB5XG4gICAqICAgZXZlbnQucGF0aC5mb3JFYWNoKGRpciA9PiB7XG4gICAqICAgICB0eXBlID0gdHlwZS5nZXQoZGlyKVxuICAgKiAgIH0pXG4gICAqICAgdHlwZSA9PT0gZXZlbnQudGFyZ2V0IC8vID0+IHRydWVcbiAgICovXG4gIGdldCBwYXRoICgpIHtcbiAgICByZXR1cm4gdGhpcy5fcGF0aCB8fCAodGhpcy5fcGF0aCA9IGdldFBhdGhUbyh0aGlzLmN1cnJlbnRUYXJnZXQsIHRoaXMudGFyZ2V0KSlcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIHN0cnVjdCBpcyBkZWxldGVkIGJ5IHRoaXMgZXZlbnQuXG4gICAqXG4gICAqIEluIGNvbnRyYXN0IHRvIGNoYW5nZS5kZWxldGVkLCB0aGlzIG1ldGhvZCBhbHNvIHJldHVybnMgdHJ1ZSBpZiB0aGUgc3RydWN0IHdhcyBhZGRlZCBhbmQgdGhlbiBkZWxldGVkLlxuICAgKlxuICAgKiBAcGFyYW0ge0Fic3RyYWN0U3RydWN0fSBzdHJ1Y3RcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGRlbGV0ZXMgKHN0cnVjdCkge1xuICAgIHJldHVybiBpc0RlbGV0ZWQodGhpcy50cmFuc2FjdGlvbi5kZWxldGVTZXQsIHN0cnVjdC5pZClcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7TWFwPHN0cmluZywgeyBhY3Rpb246ICdhZGQnIHwgJ3VwZGF0ZScgfCAnZGVsZXRlJywgb2xkVmFsdWU6IGFueSwgbmV3VmFsdWU6IGFueSB9Pn1cbiAgICovXG4gIGdldCBrZXlzICgpIHtcbiAgICBpZiAodGhpcy5fa2V5cyA9PT0gbnVsbCkge1xuICAgICAgaWYgKHRoaXMudHJhbnNhY3Rpb24uZG9jLl90cmFuc2FjdGlvbkNsZWFudXBzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBlcnJvci5jcmVhdGUoZXJyb3JDb21wdXRlQ2hhbmdlcylcbiAgICAgIH1cbiAgICAgIGNvbnN0IGtleXMgPSBuZXcgTWFwKClcbiAgICAgIGNvbnN0IHRhcmdldCA9IHRoaXMudGFyZ2V0XG4gICAgICBjb25zdCBjaGFuZ2VkID0gLyoqIEB0eXBlIFNldDxzdHJpbmd8bnVsbD4gKi8gKHRoaXMudHJhbnNhY3Rpb24uY2hhbmdlZC5nZXQodGFyZ2V0KSlcbiAgICAgIGNoYW5nZWQuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICBpZiAoa2V5ICE9PSBudWxsKSB7XG4gICAgICAgICAgY29uc3QgaXRlbSA9IC8qKiBAdHlwZSB7SXRlbX0gKi8gKHRhcmdldC5fbWFwLmdldChrZXkpKVxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIEB0eXBlIHsnZGVsZXRlJyB8ICdhZGQnIHwgJ3VwZGF0ZSd9XG4gICAgICAgICAgICovXG4gICAgICAgICAgbGV0IGFjdGlvblxuICAgICAgICAgIGxldCBvbGRWYWx1ZVxuICAgICAgICAgIGlmICh0aGlzLmFkZHMoaXRlbSkpIHtcbiAgICAgICAgICAgIGxldCBwcmV2ID0gaXRlbS5sZWZ0XG4gICAgICAgICAgICB3aGlsZSAocHJldiAhPT0gbnVsbCAmJiB0aGlzLmFkZHMocHJldikpIHtcbiAgICAgICAgICAgICAgcHJldiA9IHByZXYubGVmdFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuZGVsZXRlcyhpdGVtKSkge1xuICAgICAgICAgICAgICBpZiAocHJldiAhPT0gbnVsbCAmJiB0aGlzLmRlbGV0ZXMocHJldikpIHtcbiAgICAgICAgICAgICAgICBhY3Rpb24gPSAnZGVsZXRlJ1xuICAgICAgICAgICAgICAgIG9sZFZhbHVlID0gYXJyYXkubGFzdChwcmV2LmNvbnRlbnQuZ2V0Q29udGVudCgpKVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAocHJldiAhPT0gbnVsbCAmJiB0aGlzLmRlbGV0ZXMocHJldikpIHtcbiAgICAgICAgICAgICAgICBhY3Rpb24gPSAndXBkYXRlJ1xuICAgICAgICAgICAgICAgIG9sZFZhbHVlID0gYXJyYXkubGFzdChwcmV2LmNvbnRlbnQuZ2V0Q29udGVudCgpKVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFjdGlvbiA9ICdhZGQnXG4gICAgICAgICAgICAgICAgb2xkVmFsdWUgPSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kZWxldGVzKGl0ZW0pKSB7XG4gICAgICAgICAgICAgIGFjdGlvbiA9ICdkZWxldGUnXG4gICAgICAgICAgICAgIG9sZFZhbHVlID0gYXJyYXkubGFzdCgvKiogQHR5cGUge0l0ZW19ICovIGl0ZW0uY29udGVudC5nZXRDb250ZW50KCkpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gLy8gbm9wXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGtleXMuc2V0KGtleSwgeyBhY3Rpb24sIG9sZFZhbHVlIH0pXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICB0aGlzLl9rZXlzID0ga2V5c1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fa2V5c1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgaXMgYSBjb21wdXRlZCBwcm9wZXJ0eS4gTm90ZSB0aGF0IHRoaXMgY2FuIG9ubHkgYmUgc2FmZWx5IGNvbXB1dGVkIGR1cmluZyB0aGVcbiAgICogZXZlbnQgY2FsbC4gQ29tcHV0aW5nIHRoaXMgcHJvcGVydHkgYWZ0ZXIgb3RoZXIgY2hhbmdlcyBoYXBwZW5lZCBtaWdodCByZXN1bHQgaW5cbiAgICogdW5leHBlY3RlZCBiZWhhdmlvciAoaW5jb3JyZWN0IGNvbXB1dGF0aW9uIG9mIGRlbHRhcykuIEEgc2FmZSB3YXkgdG8gY29sbGVjdCBjaGFuZ2VzXG4gICAqIGlzIHRvIHN0b3JlIHRoZSBgY2hhbmdlc2Agb3IgdGhlIGBkZWx0YWAgb2JqZWN0LiBBdm9pZCBzdG9yaW5nIHRoZSBgdHJhbnNhY3Rpb25gIG9iamVjdC5cbiAgICpcbiAgICogQHR5cGUge0FycmF5PHtpbnNlcnQ/OiBzdHJpbmcgfCBBcnJheTxhbnk+IHwgb2JqZWN0IHwgQWJzdHJhY3RUeXBlPGFueT4sIHJldGFpbj86IG51bWJlciwgZGVsZXRlPzogbnVtYmVyLCBhdHRyaWJ1dGVzPzogT2JqZWN0PHN0cmluZywgYW55Pn0+fVxuICAgKi9cbiAgZ2V0IGRlbHRhICgpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFuZ2VzLmRlbHRhXG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgYSBzdHJ1Y3QgaXMgYWRkZWQgYnkgdGhpcyBldmVudC5cbiAgICpcbiAgICogSW4gY29udHJhc3QgdG8gY2hhbmdlLmRlbGV0ZWQsIHRoaXMgbWV0aG9kIGFsc28gcmV0dXJucyB0cnVlIGlmIHRoZSBzdHJ1Y3Qgd2FzIGFkZGVkIGFuZCB0aGVuIGRlbGV0ZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7QWJzdHJhY3RTdHJ1Y3R9IHN0cnVjdFxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgYWRkcyAoc3RydWN0KSB7XG4gICAgcmV0dXJuIHN0cnVjdC5pZC5jbG9jayA+PSAodGhpcy50cmFuc2FjdGlvbi5iZWZvcmVTdGF0ZS5nZXQoc3RydWN0LmlkLmNsaWVudCkgfHwgMClcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGlzIGEgY29tcHV0ZWQgcHJvcGVydHkuIE5vdGUgdGhhdCB0aGlzIGNhbiBvbmx5IGJlIHNhZmVseSBjb21wdXRlZCBkdXJpbmcgdGhlXG4gICAqIGV2ZW50IGNhbGwuIENvbXB1dGluZyB0aGlzIHByb3BlcnR5IGFmdGVyIG90aGVyIGNoYW5nZXMgaGFwcGVuZWQgbWlnaHQgcmVzdWx0IGluXG4gICAqIHVuZXhwZWN0ZWQgYmVoYXZpb3IgKGluY29ycmVjdCBjb21wdXRhdGlvbiBvZiBkZWx0YXMpLiBBIHNhZmUgd2F5IHRvIGNvbGxlY3QgY2hhbmdlc1xuICAgKiBpcyB0byBzdG9yZSB0aGUgYGNoYW5nZXNgIG9yIHRoZSBgZGVsdGFgIG9iamVjdC4gQXZvaWQgc3RvcmluZyB0aGUgYHRyYW5zYWN0aW9uYCBvYmplY3QuXG4gICAqXG4gICAqIEB0eXBlIHt7YWRkZWQ6U2V0PEl0ZW0+LGRlbGV0ZWQ6U2V0PEl0ZW0+LGtleXM6TWFwPHN0cmluZyx7YWN0aW9uOidhZGQnfCd1cGRhdGUnfCdkZWxldGUnLG9sZFZhbHVlOmFueX0+LGRlbHRhOkFycmF5PHtpbnNlcnQ/OkFycmF5PGFueT58c3RyaW5nLCBkZWxldGU/Om51bWJlciwgcmV0YWluPzpudW1iZXJ9Pn19XG4gICAqL1xuICBnZXQgY2hhbmdlcyAoKSB7XG4gICAgbGV0IGNoYW5nZXMgPSB0aGlzLl9jaGFuZ2VzXG4gICAgaWYgKGNoYW5nZXMgPT09IG51bGwpIHtcbiAgICAgIGlmICh0aGlzLnRyYW5zYWN0aW9uLmRvYy5fdHJhbnNhY3Rpb25DbGVhbnVwcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgZXJyb3IuY3JlYXRlKGVycm9yQ29tcHV0ZUNoYW5nZXMpXG4gICAgICB9XG4gICAgICBjb25zdCB0YXJnZXQgPSB0aGlzLnRhcmdldFxuICAgICAgY29uc3QgYWRkZWQgPSBzZXQuY3JlYXRlKClcbiAgICAgIGNvbnN0IGRlbGV0ZWQgPSBzZXQuY3JlYXRlKClcbiAgICAgIC8qKlxuICAgICAgICogQHR5cGUge0FycmF5PHtpbnNlcnQ6QXJyYXk8YW55Pn18e2RlbGV0ZTpudW1iZXJ9fHtyZXRhaW46bnVtYmVyfT59XG4gICAgICAgKi9cbiAgICAgIGNvbnN0IGRlbHRhID0gW11cbiAgICAgIGNoYW5nZXMgPSB7XG4gICAgICAgIGFkZGVkLFxuICAgICAgICBkZWxldGVkLFxuICAgICAgICBkZWx0YSxcbiAgICAgICAga2V5czogdGhpcy5rZXlzXG4gICAgICB9XG4gICAgICBjb25zdCBjaGFuZ2VkID0gLyoqIEB0eXBlIFNldDxzdHJpbmd8bnVsbD4gKi8gKHRoaXMudHJhbnNhY3Rpb24uY2hhbmdlZC5nZXQodGFyZ2V0KSlcbiAgICAgIGlmIChjaGFuZ2VkLmhhcyhudWxsKSkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge2FueX1cbiAgICAgICAgICovXG4gICAgICAgIGxldCBsYXN0T3AgPSBudWxsXG4gICAgICAgIGNvbnN0IHBhY2tPcCA9ICgpID0+IHtcbiAgICAgICAgICBpZiAobGFzdE9wKSB7XG4gICAgICAgICAgICBkZWx0YS5wdXNoKGxhc3RPcClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaXRlbSA9IHRhcmdldC5fc3RhcnQ7IGl0ZW0gIT09IG51bGw7IGl0ZW0gPSBpdGVtLnJpZ2h0KSB7XG4gICAgICAgICAgaWYgKGl0ZW0uZGVsZXRlZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZGVsZXRlcyhpdGVtKSAmJiAhdGhpcy5hZGRzKGl0ZW0pKSB7XG4gICAgICAgICAgICAgIGlmIChsYXN0T3AgPT09IG51bGwgfHwgbGFzdE9wLmRlbGV0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcGFja09wKClcbiAgICAgICAgICAgICAgICBsYXN0T3AgPSB7IGRlbGV0ZTogMCB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbGFzdE9wLmRlbGV0ZSArPSBpdGVtLmxlbmd0aFxuICAgICAgICAgICAgICBkZWxldGVkLmFkZChpdGVtKVxuICAgICAgICAgICAgfSAvLyBlbHNlIG5vcFxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5hZGRzKGl0ZW0pKSB7XG4gICAgICAgICAgICAgIGlmIChsYXN0T3AgPT09IG51bGwgfHwgbGFzdE9wLmluc2VydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcGFja09wKClcbiAgICAgICAgICAgICAgICBsYXN0T3AgPSB7IGluc2VydDogW10gfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGxhc3RPcC5pbnNlcnQgPSBsYXN0T3AuaW5zZXJ0LmNvbmNhdChpdGVtLmNvbnRlbnQuZ2V0Q29udGVudCgpKVxuICAgICAgICAgICAgICBhZGRlZC5hZGQoaXRlbSlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChsYXN0T3AgPT09IG51bGwgfHwgbGFzdE9wLnJldGFpbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcGFja09wKClcbiAgICAgICAgICAgICAgICBsYXN0T3AgPSB7IHJldGFpbjogMCB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbGFzdE9wLnJldGFpbiArPSBpdGVtLmxlbmd0aFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobGFzdE9wICE9PSBudWxsICYmIGxhc3RPcC5yZXRhaW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHBhY2tPcCgpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuX2NoYW5nZXMgPSBjaGFuZ2VzXG4gICAgfVxuICAgIHJldHVybiAvKiogQHR5cGUge2FueX0gKi8gKGNoYW5nZXMpXG4gIH1cbn1cblxuLyoqXG4gKiBDb21wdXRlIHRoZSBwYXRoIGZyb20gdGhpcyB0eXBlIHRvIHRoZSBzcGVjaWZpZWQgdGFyZ2V0LlxuICpcbiAqIEBleGFtcGxlXG4gKiAgIC8vIGBjaGlsZGAgc2hvdWxkIGJlIGFjY2Vzc2libGUgdmlhIGB0eXBlLmdldChwYXRoWzBdKS5nZXQocGF0aFsxXSkuLmBcbiAqICAgY29uc3QgcGF0aCA9IHR5cGUuZ2V0UGF0aFRvKGNoaWxkKVxuICogICAvLyBhc3N1bWluZyBgdHlwZSBpbnN0YW5jZW9mIFlBcnJheWBcbiAqICAgY29uc29sZS5sb2cocGF0aCkgLy8gbWlnaHQgbG9vayBsaWtlID0+IFsyLCAna2V5MSddXG4gKiAgIGNoaWxkID09PSB0eXBlLmdldChwYXRoWzBdKS5nZXQocGF0aFsxXSlcbiAqXG4gKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxhbnk+fSBwYXJlbnRcbiAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPGFueT59IGNoaWxkIHRhcmdldFxuICogQHJldHVybiB7QXJyYXk8c3RyaW5nfG51bWJlcj59IFBhdGggdG8gdGhlIHRhcmdldFxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgZ2V0UGF0aFRvID0gKHBhcmVudCwgY2hpbGQpID0+IHtcbiAgY29uc3QgcGF0aCA9IFtdXG4gIHdoaWxlIChjaGlsZC5faXRlbSAhPT0gbnVsbCAmJiBjaGlsZCAhPT0gcGFyZW50KSB7XG4gICAgaWYgKGNoaWxkLl9pdGVtLnBhcmVudFN1YiAhPT0gbnVsbCkge1xuICAgICAgLy8gcGFyZW50IGlzIG1hcC1pc2hcbiAgICAgIHBhdGgudW5zaGlmdChjaGlsZC5faXRlbS5wYXJlbnRTdWIpXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHBhcmVudCBpcyBhcnJheS1pc2hcbiAgICAgIGxldCBpID0gMFxuICAgICAgbGV0IGMgPSAvKiogQHR5cGUge0Fic3RyYWN0VHlwZTxhbnk+fSAqLyAoY2hpbGQuX2l0ZW0ucGFyZW50KS5fc3RhcnRcbiAgICAgIHdoaWxlIChjICE9PSBjaGlsZC5faXRlbSAmJiBjICE9PSBudWxsKSB7XG4gICAgICAgIGlmICghYy5kZWxldGVkKSB7XG4gICAgICAgICAgaSsrXG4gICAgICAgIH1cbiAgICAgICAgYyA9IGMucmlnaHRcbiAgICAgIH1cbiAgICAgIHBhdGgudW5zaGlmdChpKVxuICAgIH1cbiAgICBjaGlsZCA9IC8qKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT59ICovIChjaGlsZC5faXRlbS5wYXJlbnQpXG4gIH1cbiAgcmV0dXJuIHBhdGhcbn1cbiIsICJcbmltcG9ydCB7XG4gIHJlbW92ZUV2ZW50SGFuZGxlckxpc3RlbmVyLFxuICBjYWxsRXZlbnRIYW5kbGVyTGlzdGVuZXJzLFxuICBhZGRFdmVudEhhbmRsZXJMaXN0ZW5lcixcbiAgY3JlYXRlRXZlbnRIYW5kbGVyLFxuICBnZXRTdGF0ZSxcbiAgaXNWaXNpYmxlLFxuICBDb250ZW50VHlwZSxcbiAgY3JlYXRlSUQsXG4gIENvbnRlbnRBbnksXG4gIENvbnRlbnRCaW5hcnksXG4gIGdldEl0ZW1DbGVhblN0YXJ0LFxuICBDb250ZW50RG9jLCBZVGV4dCwgWUFycmF5LCBVcGRhdGVFbmNvZGVyVjEsIFVwZGF0ZUVuY29kZXJWMiwgRG9jLCBTbmFwc2hvdCwgVHJhbnNhY3Rpb24sIEV2ZW50SGFuZGxlciwgWUV2ZW50LCBJdGVtLCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG59IGZyb20gJy4uL2ludGVybmFscy5qcydcblxuaW1wb3J0ICogYXMgbWFwIGZyb20gJ2xpYjAvbWFwJ1xuaW1wb3J0ICogYXMgaXRlcmF0b3IgZnJvbSAnbGliMC9pdGVyYXRvcidcbmltcG9ydCAqIGFzIGVycm9yIGZyb20gJ2xpYjAvZXJyb3InXG5pbXBvcnQgKiBhcyBtYXRoIGZyb20gJ2xpYjAvbWF0aCdcblxuY29uc3QgbWF4U2VhcmNoTWFya2VyID0gODBcblxuLyoqXG4gKiBBIHVuaXF1ZSB0aW1lc3RhbXAgdGhhdCBpZGVudGlmaWVzIGVhY2ggbWFya2VyLlxuICpcbiAqIFRpbWUgaXMgcmVsYXRpdmUsLi4gdGhpcyBpcyBtb3JlIGxpa2UgYW4gZXZlci1pbmNyZWFzaW5nIGNsb2NrLlxuICpcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmxldCBnbG9iYWxTZWFyY2hNYXJrZXJUaW1lc3RhbXAgPSAwXG5cbmV4cG9ydCBjbGFzcyBBcnJheVNlYXJjaE1hcmtlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0l0ZW19IHBcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gICAqL1xuICBjb25zdHJ1Y3RvciAocCwgaW5kZXgpIHtcbiAgICBwLm1hcmtlciA9IHRydWVcbiAgICB0aGlzLnAgPSBwXG4gICAgdGhpcy5pbmRleCA9IGluZGV4XG4gICAgdGhpcy50aW1lc3RhbXAgPSBnbG9iYWxTZWFyY2hNYXJrZXJUaW1lc3RhbXArK1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheVNlYXJjaE1hcmtlcn0gbWFya2VyXG4gKi9cbmNvbnN0IHJlZnJlc2hNYXJrZXJUaW1lc3RhbXAgPSBtYXJrZXIgPT4geyBtYXJrZXIudGltZXN0YW1wID0gZ2xvYmFsU2VhcmNoTWFya2VyVGltZXN0YW1wKysgfVxuXG4vKipcbiAqIFRoaXMgaXMgcmF0aGVyIGNvbXBsZXggc28gdGhpcyBmdW5jdGlvbiBpcyB0aGUgb25seSB0aGluZyB0aGF0IHNob3VsZCBvdmVyd3JpdGUgYSBtYXJrZXJcbiAqXG4gKiBAcGFyYW0ge0FycmF5U2VhcmNoTWFya2VyfSBtYXJrZXJcbiAqIEBwYXJhbSB7SXRlbX0gcFxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gKi9cbmNvbnN0IG92ZXJ3cml0ZU1hcmtlciA9IChtYXJrZXIsIHAsIGluZGV4KSA9PiB7XG4gIG1hcmtlci5wLm1hcmtlciA9IGZhbHNlXG4gIG1hcmtlci5wID0gcFxuICBwLm1hcmtlciA9IHRydWVcbiAgbWFya2VyLmluZGV4ID0gaW5kZXhcbiAgbWFya2VyLnRpbWVzdGFtcCA9IGdsb2JhbFNlYXJjaE1hcmtlclRpbWVzdGFtcCsrXG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxBcnJheVNlYXJjaE1hcmtlcj59IHNlYXJjaE1hcmtlclxuICogQHBhcmFtIHtJdGVtfSBwXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAqL1xuY29uc3QgbWFya1Bvc2l0aW9uID0gKHNlYXJjaE1hcmtlciwgcCwgaW5kZXgpID0+IHtcbiAgaWYgKHNlYXJjaE1hcmtlci5sZW5ndGggPj0gbWF4U2VhcmNoTWFya2VyKSB7XG4gICAgLy8gb3ZlcnJpZGUgb2xkZXN0IG1hcmtlciAod2UgZG9uJ3Qgd2FudCB0byBjcmVhdGUgbW9yZSBvYmplY3RzKVxuICAgIGNvbnN0IG1hcmtlciA9IHNlYXJjaE1hcmtlci5yZWR1Y2UoKGEsIGIpID0+IGEudGltZXN0YW1wIDwgYi50aW1lc3RhbXAgPyBhIDogYilcbiAgICBvdmVyd3JpdGVNYXJrZXIobWFya2VyLCBwLCBpbmRleClcbiAgICByZXR1cm4gbWFya2VyXG4gIH0gZWxzZSB7XG4gICAgLy8gY3JlYXRlIG5ldyBtYXJrZXJcbiAgICBjb25zdCBwbSA9IG5ldyBBcnJheVNlYXJjaE1hcmtlcihwLCBpbmRleClcbiAgICBzZWFyY2hNYXJrZXIucHVzaChwbSlcbiAgICByZXR1cm4gcG1cbiAgfVxufVxuXG4vKipcbiAqIFNlYXJjaCBtYXJrZXIgaGVscCB1cyB0byBmaW5kIHBvc2l0aW9ucyBpbiB0aGUgYXNzb2NpYXRpdmUgYXJyYXkgZmFzdGVyLlxuICpcbiAqIFRoZXkgc3BlZWQgdXAgdGhlIHByb2Nlc3Mgb2YgZmluZGluZyBhIHBvc2l0aW9uIHdpdGhvdXQgbXVjaCBib29ra2VlcGluZy5cbiAqXG4gKiBBIG1heGltdW0gb2YgYG1heFNlYXJjaE1hcmtlcmAgb2JqZWN0cyBhcmUgY3JlYXRlZC5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGFsd2F5cyByZXR1cm5zIGEgcmVmcmVzaGVkIG1hcmtlciAodXBkYXRlZCB0aW1lc3RhbXApXG4gKlxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0geWFycmF5XG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAqL1xuZXhwb3J0IGNvbnN0IGZpbmRNYXJrZXIgPSAoeWFycmF5LCBpbmRleCkgPT4ge1xuICBpZiAoeWFycmF5Ll9zdGFydCA9PT0gbnVsbCB8fCBpbmRleCA9PT0gMCB8fCB5YXJyYXkuX3NlYXJjaE1hcmtlciA9PT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsXG4gIH1cbiAgY29uc3QgbWFya2VyID0geWFycmF5Ll9zZWFyY2hNYXJrZXIubGVuZ3RoID09PSAwID8gbnVsbCA6IHlhcnJheS5fc2VhcmNoTWFya2VyLnJlZHVjZSgoYSwgYikgPT4gbWF0aC5hYnMoaW5kZXggLSBhLmluZGV4KSA8IG1hdGguYWJzKGluZGV4IC0gYi5pbmRleCkgPyBhIDogYilcbiAgbGV0IHAgPSB5YXJyYXkuX3N0YXJ0XG4gIGxldCBwaW5kZXggPSAwXG4gIGlmIChtYXJrZXIgIT09IG51bGwpIHtcbiAgICBwID0gbWFya2VyLnBcbiAgICBwaW5kZXggPSBtYXJrZXIuaW5kZXhcbiAgICByZWZyZXNoTWFya2VyVGltZXN0YW1wKG1hcmtlcikgLy8gd2UgdXNlZCBpdCwgd2UgbWlnaHQgbmVlZCB0byB1c2UgaXQgYWdhaW5cbiAgfVxuICAvLyBpdGVyYXRlIHRvIHJpZ2h0IGlmIHBvc3NpYmxlXG4gIHdoaWxlIChwLnJpZ2h0ICE9PSBudWxsICYmIHBpbmRleCA8IGluZGV4KSB7XG4gICAgaWYgKCFwLmRlbGV0ZWQgJiYgcC5jb3VudGFibGUpIHtcbiAgICAgIGlmIChpbmRleCA8IHBpbmRleCArIHAubGVuZ3RoKSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBwaW5kZXggKz0gcC5sZW5ndGhcbiAgICB9XG4gICAgcCA9IHAucmlnaHRcbiAgfVxuICAvLyBpdGVyYXRlIHRvIGxlZnQgaWYgbmVjZXNzYXJ5IChtaWdodCBiZSB0aGF0IHBpbmRleCA+IGluZGV4KVxuICB3aGlsZSAocC5sZWZ0ICE9PSBudWxsICYmIHBpbmRleCA+IGluZGV4KSB7XG4gICAgcCA9IHAubGVmdFxuICAgIGlmICghcC5kZWxldGVkICYmIHAuY291bnRhYmxlKSB7XG4gICAgICBwaW5kZXggLT0gcC5sZW5ndGhcbiAgICB9XG4gIH1cbiAgLy8gd2Ugd2FudCB0byBtYWtlIHN1cmUgdGhhdCBwIGNhbid0IGJlIG1lcmdlZCB3aXRoIGxlZnQsIGJlY2F1c2UgdGhhdCB3b3VsZCBzY3JldyB1cCBldmVyeXRoaW5nXG4gIC8vIGluIHRoYXQgY2FzIGp1c3QgcmV0dXJuIHdoYXQgd2UgaGF2ZSAoaXQgaXMgbW9zdCBsaWtlbHkgdGhlIGJlc3QgbWFya2VyIGFueXdheSlcbiAgLy8gaXRlcmF0ZSB0byBsZWZ0IHVudGlsIHAgY2FuJ3QgYmUgbWVyZ2VkIHdpdGggbGVmdFxuICB3aGlsZSAocC5sZWZ0ICE9PSBudWxsICYmIHAubGVmdC5pZC5jbGllbnQgPT09IHAuaWQuY2xpZW50ICYmIHAubGVmdC5pZC5jbG9jayArIHAubGVmdC5sZW5ndGggPT09IHAuaWQuY2xvY2spIHtcbiAgICBwID0gcC5sZWZ0XG4gICAgaWYgKCFwLmRlbGV0ZWQgJiYgcC5jb3VudGFibGUpIHtcbiAgICAgIHBpbmRleCAtPSBwLmxlbmd0aFxuICAgIH1cbiAgfVxuXG4gIC8vIEB0b2RvIHJlbW92ZSFcbiAgLy8gYXNzdXJlIHBvc2l0aW9uXG4gIC8vIHtcbiAgLy8gICBsZXQgc3RhcnQgPSB5YXJyYXkuX3N0YXJ0XG4gIC8vICAgbGV0IHBvcyA9IDBcbiAgLy8gICB3aGlsZSAoc3RhcnQgIT09IHApIHtcbiAgLy8gICAgIGlmICghc3RhcnQuZGVsZXRlZCAmJiBzdGFydC5jb3VudGFibGUpIHtcbiAgLy8gICAgICAgcG9zICs9IHN0YXJ0Lmxlbmd0aFxuICAvLyAgICAgfVxuICAvLyAgICAgc3RhcnQgPSAvKiogQHR5cGUge0l0ZW19ICovIChzdGFydC5yaWdodClcbiAgLy8gICB9XG4gIC8vICAgaWYgKHBvcyAhPT0gcGluZGV4KSB7XG4gIC8vICAgICBkZWJ1Z2dlclxuICAvLyAgICAgdGhyb3cgbmV3IEVycm9yKCdHb3RjaGEgcG9zaXRpb24gZmFpbCEnKVxuICAvLyAgIH1cbiAgLy8gfVxuICAvLyBpZiAobWFya2VyKSB7XG4gIC8vICAgaWYgKHdpbmRvdy5sZW5ndGhlcyA9PSBudWxsKSB7XG4gIC8vICAgICB3aW5kb3cubGVuZ3RoZXMgPSBbXVxuICAvLyAgICAgd2luZG93LmdldExlbmd0aGVzID0gKCkgPT4gd2luZG93Lmxlbmd0aGVzLnNvcnQoKGEsIGIpID0+IGEgLSBiKVxuICAvLyAgIH1cbiAgLy8gICB3aW5kb3cubGVuZ3RoZXMucHVzaChtYXJrZXIuaW5kZXggLSBwaW5kZXgpXG4gIC8vICAgY29uc29sZS5sb2coJ2Rpc3RhbmNlJywgbWFya2VyLmluZGV4IC0gcGluZGV4LCAnbGVuJywgcCAmJiBwLnBhcmVudC5sZW5ndGgpXG4gIC8vIH1cbiAgaWYgKG1hcmtlciAhPT0gbnVsbCAmJiBtYXRoLmFicyhtYXJrZXIuaW5kZXggLSBwaW5kZXgpIDwgLyoqIEB0eXBlIHtZVGV4dHxZQXJyYXk8YW55Pn0gKi8gKHAucGFyZW50KS5sZW5ndGggLyBtYXhTZWFyY2hNYXJrZXIpIHtcbiAgICAvLyBhZGp1c3QgZXhpc3RpbmcgbWFya2VyXG4gICAgb3ZlcndyaXRlTWFya2VyKG1hcmtlciwgcCwgcGluZGV4KVxuICAgIHJldHVybiBtYXJrZXJcbiAgfSBlbHNlIHtcbiAgICAvLyBjcmVhdGUgbmV3IG1hcmtlclxuICAgIHJldHVybiBtYXJrUG9zaXRpb24oeWFycmF5Ll9zZWFyY2hNYXJrZXIsIHAsIHBpbmRleClcbiAgfVxufVxuXG4vKipcbiAqIFVwZGF0ZSBtYXJrZXJzIHdoZW4gYSBjaGFuZ2UgaGFwcGVuZWQuXG4gKlxuICogVGhpcyBzaG91bGQgYmUgY2FsbGVkIGJlZm9yZSBkb2luZyBhIGRlbGV0aW9uIVxuICpcbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXlTZWFyY2hNYXJrZXI+fSBzZWFyY2hNYXJrZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICogQHBhcmFtIHtudW1iZXJ9IGxlbiBJZiBpbnNlcnRpb24sIGxlbiBpcyBwb3NpdGl2ZS4gSWYgZGVsZXRpb24sIGxlbiBpcyBuZWdhdGl2ZS5cbiAqL1xuZXhwb3J0IGNvbnN0IHVwZGF0ZU1hcmtlckNoYW5nZXMgPSAoc2VhcmNoTWFya2VyLCBpbmRleCwgbGVuKSA9PiB7XG4gIGZvciAobGV0IGkgPSBzZWFyY2hNYXJrZXIubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBjb25zdCBtID0gc2VhcmNoTWFya2VyW2ldXG4gICAgaWYgKGxlbiA+IDApIHtcbiAgICAgIC8qKlxuICAgICAgICogQHR5cGUge0l0ZW18bnVsbH1cbiAgICAgICAqL1xuICAgICAgbGV0IHAgPSBtLnBcbiAgICAgIHAubWFya2VyID0gZmFsc2VcbiAgICAgIC8vIElkZWFsbHkgd2UganVzdCB3YW50IHRvIGRvIGEgc2ltcGxlIHBvc2l0aW9uIGNvbXBhcmlzb24sIGJ1dCB0aGlzIHdpbGwgb25seSB3b3JrIGlmXG4gICAgICAvLyBzZWFyY2ggbWFya2VycyBkb24ndCBwb2ludCB0byBkZWxldGVkIGl0ZW1zIGZvciBmb3JtYXRzLlxuICAgICAgLy8gSXRlcmF0ZSBtYXJrZXIgdG8gcHJldiB1bmRlbGV0ZWQgY291bnRhYmxlIHBvc2l0aW9uIHNvIHdlIGtub3cgd2hhdCB0byBkbyB3aGVuIHVwZGF0aW5nIGEgcG9zaXRpb25cbiAgICAgIHdoaWxlIChwICYmIChwLmRlbGV0ZWQgfHwgIXAuY291bnRhYmxlKSkge1xuICAgICAgICBwID0gcC5sZWZ0XG4gICAgICAgIGlmIChwICYmICFwLmRlbGV0ZWQgJiYgcC5jb3VudGFibGUpIHtcbiAgICAgICAgICAvLyBhZGp1c3QgcG9zaXRpb24uIHRoZSBsb29wIHNob3VsZCBicmVhayBub3dcbiAgICAgICAgICBtLmluZGV4IC09IHAubGVuZ3RoXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwID09PSBudWxsIHx8IHAubWFya2VyID09PSB0cnVlKSB7XG4gICAgICAgIC8vIHJlbW92ZSBzZWFyY2ggbWFya2VyIGlmIHVwZGF0ZWQgcG9zaXRpb24gaXMgbnVsbCBvciBpZiBwb3NpdGlvbiBpcyBhbHJlYWR5IG1hcmtlZFxuICAgICAgICBzZWFyY2hNYXJrZXIuc3BsaWNlKGksIDEpXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG4gICAgICBtLnAgPSBwXG4gICAgICBwLm1hcmtlciA9IHRydWVcbiAgICB9XG4gICAgaWYgKGluZGV4IDwgbS5pbmRleCB8fCAobGVuID4gMCAmJiBpbmRleCA9PT0gbS5pbmRleCkpIHsgLy8gYSBzaW1wbGUgaW5kZXggPD0gbS5pbmRleCBjaGVjayB3b3VsZCBhY3R1YWxseSBzdWZmaWNlXG4gICAgICBtLmluZGV4ID0gbWF0aC5tYXgoaW5kZXgsIG0uaW5kZXggKyBsZW4pXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQWNjdW11bGF0ZSBhbGwgKGxpc3QpIGNoaWxkcmVuIG9mIGEgdHlwZSBhbmQgcmV0dXJuIHRoZW0gYXMgYW4gQXJyYXkuXG4gKlxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0gdFxuICogQHJldHVybiB7QXJyYXk8SXRlbT59XG4gKi9cbmV4cG9ydCBjb25zdCBnZXRUeXBlQ2hpbGRyZW4gPSB0ID0+IHtcbiAgbGV0IHMgPSB0Ll9zdGFydFxuICBjb25zdCBhcnIgPSBbXVxuICB3aGlsZSAocykge1xuICAgIGFyci5wdXNoKHMpXG4gICAgcyA9IHMucmlnaHRcbiAgfVxuICByZXR1cm4gYXJyXG59XG5cbi8qKlxuICogQ2FsbCBldmVudCBsaXN0ZW5lcnMgd2l0aCBhbiBldmVudC4gVGhpcyB3aWxsIGFsc28gYWRkIGFuIGV2ZW50IHRvIGFsbFxuICogcGFyZW50cyAoZm9yIGAub2JzZXJ2ZURlZXBgIGhhbmRsZXJzKS5cbiAqXG4gKiBAdGVtcGxhdGUgRXZlbnRUeXBlXG4gKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxFdmVudFR5cGU+fSB0eXBlXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtFdmVudFR5cGV9IGV2ZW50XG4gKi9cbmV4cG9ydCBjb25zdCBjYWxsVHlwZU9ic2VydmVycyA9ICh0eXBlLCB0cmFuc2FjdGlvbiwgZXZlbnQpID0+IHtcbiAgY29uc3QgY2hhbmdlZFR5cGUgPSB0eXBlXG4gIGNvbnN0IGNoYW5nZWRQYXJlbnRUeXBlcyA9IHRyYW5zYWN0aW9uLmNoYW5nZWRQYXJlbnRUeXBlc1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBtYXAuc2V0SWZVbmRlZmluZWQoY2hhbmdlZFBhcmVudFR5cGVzLCB0eXBlLCAoKSA9PiBbXSkucHVzaChldmVudClcbiAgICBpZiAodHlwZS5faXRlbSA9PT0gbnVsbCkge1xuICAgICAgYnJlYWtcbiAgICB9XG4gICAgdHlwZSA9IC8qKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT59ICovICh0eXBlLl9pdGVtLnBhcmVudClcbiAgfVxuICBjYWxsRXZlbnRIYW5kbGVyTGlzdGVuZXJzKGNoYW5nZWRUeXBlLl9lSCwgZXZlbnQsIHRyYW5zYWN0aW9uKVxufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBFdmVudFR5cGVcbiAqIEFic3RyYWN0IFlqcyBUeXBlIGNsYXNzXG4gKi9cbmV4cG9ydCBjbGFzcyBBYnN0cmFjdFR5cGUge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge0l0ZW18bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLl9pdGVtID0gbnVsbFxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtNYXA8c3RyaW5nLEl0ZW0+fVxuICAgICAqL1xuICAgIHRoaXMuX21hcCA9IG5ldyBNYXAoKVxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtJdGVtfG51bGx9XG4gICAgICovXG4gICAgdGhpcy5fc3RhcnQgPSBudWxsXG4gICAgLyoqXG4gICAgICogQHR5cGUge0RvY3xudWxsfVxuICAgICAqL1xuICAgIHRoaXMuZG9jID0gbnVsbFxuICAgIHRoaXMuX2xlbmd0aCA9IDBcbiAgICAvKipcbiAgICAgKiBFdmVudCBoYW5kbGVyc1xuICAgICAqIEB0eXBlIHtFdmVudEhhbmRsZXI8RXZlbnRUeXBlLFRyYW5zYWN0aW9uPn1cbiAgICAgKi9cbiAgICB0aGlzLl9lSCA9IGNyZWF0ZUV2ZW50SGFuZGxlcigpXG4gICAgLyoqXG4gICAgICogRGVlcCBldmVudCBoYW5kbGVyc1xuICAgICAqIEB0eXBlIHtFdmVudEhhbmRsZXI8QXJyYXk8WUV2ZW50PGFueT4+LFRyYW5zYWN0aW9uPn1cbiAgICAgKi9cbiAgICB0aGlzLl9kRUggPSBjcmVhdGVFdmVudEhhbmRsZXIoKVxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudWxsIHwgQXJyYXk8QXJyYXlTZWFyY2hNYXJrZXI+fVxuICAgICAqL1xuICAgIHRoaXMuX3NlYXJjaE1hcmtlciA9IG51bGxcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtBYnN0cmFjdFR5cGU8YW55PnxudWxsfVxuICAgKi9cbiAgZ2V0IHBhcmVudCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2l0ZW0gPyAvKiogQHR5cGUge0Fic3RyYWN0VHlwZTxhbnk+fSAqLyAodGhpcy5faXRlbS5wYXJlbnQpIDogbnVsbFxuICB9XG5cbiAgLyoqXG4gICAqIEludGVncmF0ZSB0aGlzIHR5cGUgaW50byB0aGUgWWpzIGluc3RhbmNlLlxuICAgKlxuICAgKiAqIFNhdmUgdGhpcyBzdHJ1Y3QgaW4gdGhlIG9zXG4gICAqICogVGhpcyB0eXBlIGlzIHNlbnQgdG8gb3RoZXIgY2xpZW50XG4gICAqICogT2JzZXJ2ZXIgZnVuY3Rpb25zIGFyZSBmaXJlZFxuICAgKlxuICAgKiBAcGFyYW0ge0RvY30geSBUaGUgWWpzIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7SXRlbXxudWxsfSBpdGVtXG4gICAqL1xuICBfaW50ZWdyYXRlICh5LCBpdGVtKSB7XG4gICAgdGhpcy5kb2MgPSB5XG4gICAgdGhpcy5faXRlbSA9IGl0ZW1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtBYnN0cmFjdFR5cGU8RXZlbnRUeXBlPn1cbiAgICovXG4gIF9jb3B5ICgpIHtcbiAgICB0aHJvdyBlcnJvci5tZXRob2RVbmltcGxlbWVudGVkKClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtBYnN0cmFjdFR5cGU8RXZlbnRUeXBlPn1cbiAgICovXG4gIGNsb25lICgpIHtcbiAgICB0aHJvdyBlcnJvci5tZXRob2RVbmltcGxlbWVudGVkKClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1VwZGF0ZUVuY29kZXJWMSB8IFVwZGF0ZUVuY29kZXJWMn0gX2VuY29kZXJcbiAgICovXG4gIF93cml0ZSAoX2VuY29kZXIpIHsgfVxuXG4gIC8qKlxuICAgKiBUaGUgZmlyc3Qgbm9uLWRlbGV0ZWQgaXRlbVxuICAgKi9cbiAgZ2V0IF9maXJzdCAoKSB7XG4gICAgbGV0IG4gPSB0aGlzLl9zdGFydFxuICAgIHdoaWxlIChuICE9PSBudWxsICYmIG4uZGVsZXRlZCkge1xuICAgICAgbiA9IG4ucmlnaHRcbiAgICB9XG4gICAgcmV0dXJuIG5cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIFlFdmVudCBhbmQgY2FsbHMgYWxsIHR5cGUgb2JzZXJ2ZXJzLlxuICAgKiBNdXN0IGJlIGltcGxlbWVudGVkIGJ5IGVhY2ggdHlwZS5cbiAgICpcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtTZXQ8bnVsbHxzdHJpbmc+fSBfcGFyZW50U3VicyBLZXlzIGNoYW5nZWQgb24gdGhpcyB0eXBlLiBgbnVsbGAgaWYgbGlzdCB3YXMgbW9kaWZpZWQuXG4gICAqL1xuICBfY2FsbE9ic2VydmVyICh0cmFuc2FjdGlvbiwgX3BhcmVudFN1YnMpIHtcbiAgICBpZiAoIXRyYW5zYWN0aW9uLmxvY2FsICYmIHRoaXMuX3NlYXJjaE1hcmtlcikge1xuICAgICAgdGhpcy5fc2VhcmNoTWFya2VyLmxlbmd0aCA9IDBcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogT2JzZXJ2ZSBhbGwgZXZlbnRzIHRoYXQgYXJlIGNyZWF0ZWQgb24gdGhpcyB0eXBlLlxuICAgKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKEV2ZW50VHlwZSwgVHJhbnNhY3Rpb24pOnZvaWR9IGYgT2JzZXJ2ZXIgZnVuY3Rpb25cbiAgICovXG4gIG9ic2VydmUgKGYpIHtcbiAgICBhZGRFdmVudEhhbmRsZXJMaXN0ZW5lcih0aGlzLl9lSCwgZilcbiAgfVxuXG4gIC8qKlxuICAgKiBPYnNlcnZlIGFsbCBldmVudHMgdGhhdCBhcmUgY3JlYXRlZCBieSB0aGlzIHR5cGUgYW5kIGl0cyBjaGlsZHJlbi5cbiAgICpcbiAgICogQHBhcmFtIHtmdW5jdGlvbihBcnJheTxZRXZlbnQ8YW55Pj4sVHJhbnNhY3Rpb24pOnZvaWR9IGYgT2JzZXJ2ZXIgZnVuY3Rpb25cbiAgICovXG4gIG9ic2VydmVEZWVwIChmKSB7XG4gICAgYWRkRXZlbnRIYW5kbGVyTGlzdGVuZXIodGhpcy5fZEVILCBmKVxuICB9XG5cbiAgLyoqXG4gICAqIFVucmVnaXN0ZXIgYW4gb2JzZXJ2ZXIgZnVuY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oRXZlbnRUeXBlLFRyYW5zYWN0aW9uKTp2b2lkfSBmIE9ic2VydmVyIGZ1bmN0aW9uXG4gICAqL1xuICB1bm9ic2VydmUgKGYpIHtcbiAgICByZW1vdmVFdmVudEhhbmRsZXJMaXN0ZW5lcih0aGlzLl9lSCwgZilcbiAgfVxuXG4gIC8qKlxuICAgKiBVbnJlZ2lzdGVyIGFuIG9ic2VydmVyIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKEFycmF5PFlFdmVudDxhbnk+PixUcmFuc2FjdGlvbik6dm9pZH0gZiBPYnNlcnZlciBmdW5jdGlvblxuICAgKi9cbiAgdW5vYnNlcnZlRGVlcCAoZikge1xuICAgIHJlbW92ZUV2ZW50SGFuZGxlckxpc3RlbmVyKHRoaXMuX2RFSCwgZilcbiAgfVxuXG4gIC8qKlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHJldHVybiB7YW55fVxuICAgKi9cbiAgdG9KU09OICgpIHt9XG59XG5cbi8qKlxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0gdHlwZVxuICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0XG4gKiBAcGFyYW0ge251bWJlcn0gZW5kXG4gKiBAcmV0dXJuIHtBcnJheTxhbnk+fVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IHR5cGVMaXN0U2xpY2UgPSAodHlwZSwgc3RhcnQsIGVuZCkgPT4ge1xuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSB0eXBlLl9sZW5ndGggKyBzdGFydFxuICB9XG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kID0gdHlwZS5fbGVuZ3RoICsgZW5kXG4gIH1cbiAgbGV0IGxlbiA9IGVuZCAtIHN0YXJ0XG4gIGNvbnN0IGNzID0gW11cbiAgbGV0IG4gPSB0eXBlLl9zdGFydFxuICB3aGlsZSAobiAhPT0gbnVsbCAmJiBsZW4gPiAwKSB7XG4gICAgaWYgKG4uY291bnRhYmxlICYmICFuLmRlbGV0ZWQpIHtcbiAgICAgIGNvbnN0IGMgPSBuLmNvbnRlbnQuZ2V0Q29udGVudCgpXG4gICAgICBpZiAoYy5sZW5ndGggPD0gc3RhcnQpIHtcbiAgICAgICAgc3RhcnQgLT0gYy5sZW5ndGhcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGMubGVuZ3RoICYmIGxlbiA+IDA7IGkrKykge1xuICAgICAgICAgIGNzLnB1c2goY1tpXSlcbiAgICAgICAgICBsZW4tLVxuICAgICAgICB9XG4gICAgICAgIHN0YXJ0ID0gMFxuICAgICAgfVxuICAgIH1cbiAgICBuID0gbi5yaWdodFxuICB9XG4gIHJldHVybiBjc1xufVxuXG4vKipcbiAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPGFueT59IHR5cGVcbiAqIEByZXR1cm4ge0FycmF5PGFueT59XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgdHlwZUxpc3RUb0FycmF5ID0gdHlwZSA9PiB7XG4gIGNvbnN0IGNzID0gW11cbiAgbGV0IG4gPSB0eXBlLl9zdGFydFxuICB3aGlsZSAobiAhPT0gbnVsbCkge1xuICAgIGlmIChuLmNvdW50YWJsZSAmJiAhbi5kZWxldGVkKSB7XG4gICAgICBjb25zdCBjID0gbi5jb250ZW50LmdldENvbnRlbnQoKVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNzLnB1c2goY1tpXSlcbiAgICAgIH1cbiAgICB9XG4gICAgbiA9IG4ucmlnaHRcbiAgfVxuICByZXR1cm4gY3Ncbn1cblxuLyoqXG4gKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxhbnk+fSB0eXBlXG4gKiBAcGFyYW0ge1NuYXBzaG90fSBzbmFwc2hvdFxuICogQHJldHVybiB7QXJyYXk8YW55Pn1cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCB0eXBlTGlzdFRvQXJyYXlTbmFwc2hvdCA9ICh0eXBlLCBzbmFwc2hvdCkgPT4ge1xuICBjb25zdCBjcyA9IFtdXG4gIGxldCBuID0gdHlwZS5fc3RhcnRcbiAgd2hpbGUgKG4gIT09IG51bGwpIHtcbiAgICBpZiAobi5jb3VudGFibGUgJiYgaXNWaXNpYmxlKG4sIHNuYXBzaG90KSkge1xuICAgICAgY29uc3QgYyA9IG4uY29udGVudC5nZXRDb250ZW50KClcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjcy5wdXNoKGNbaV0pXG4gICAgICB9XG4gICAgfVxuICAgIG4gPSBuLnJpZ2h0XG4gIH1cbiAgcmV0dXJuIGNzXG59XG5cbi8qKlxuICogRXhlY3V0ZXMgYSBwcm92aWRlZCBmdW5jdGlvbiBvbiBvbmNlIG9uIG92ZXJ5IGVsZW1lbnQgb2YgdGhpcyBZQXJyYXkuXG4gKlxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0gdHlwZVxuICogQHBhcmFtIHtmdW5jdGlvbihhbnksbnVtYmVyLGFueSk6dm9pZH0gZiBBIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgb24gZXZlcnkgZWxlbWVudCBvZiB0aGlzIFlBcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCB0eXBlTGlzdEZvckVhY2ggPSAodHlwZSwgZikgPT4ge1xuICBsZXQgaW5kZXggPSAwXG4gIGxldCBuID0gdHlwZS5fc3RhcnRcbiAgd2hpbGUgKG4gIT09IG51bGwpIHtcbiAgICBpZiAobi5jb3VudGFibGUgJiYgIW4uZGVsZXRlZCkge1xuICAgICAgY29uc3QgYyA9IG4uY29udGVudC5nZXRDb250ZW50KClcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYy5sZW5ndGg7IGkrKykge1xuICAgICAgICBmKGNbaV0sIGluZGV4KyssIHR5cGUpXG4gICAgICB9XG4gICAgfVxuICAgIG4gPSBuLnJpZ2h0XG4gIH1cbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgQyxSXG4gKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxhbnk+fSB0eXBlXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKEMsbnVtYmVyLEFic3RyYWN0VHlwZTxhbnk+KTpSfSBmXG4gKiBAcmV0dXJuIHtBcnJheTxSPn1cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCB0eXBlTGlzdE1hcCA9ICh0eXBlLCBmKSA9PiB7XG4gIC8qKlxuICAgKiBAdHlwZSB7QXJyYXk8YW55Pn1cbiAgICovXG4gIGNvbnN0IHJlc3VsdCA9IFtdXG4gIHR5cGVMaXN0Rm9yRWFjaCh0eXBlLCAoYywgaSkgPT4ge1xuICAgIHJlc3VsdC5wdXNoKGYoYywgaSwgdHlwZSkpXG4gIH0pXG4gIHJldHVybiByZXN1bHRcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxhbnk+fSB0eXBlXG4gKiBAcmV0dXJuIHtJdGVyYWJsZUl0ZXJhdG9yPGFueT59XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgdHlwZUxpc3RDcmVhdGVJdGVyYXRvciA9IHR5cGUgPT4ge1xuICBsZXQgbiA9IHR5cGUuX3N0YXJ0XG4gIC8qKlxuICAgKiBAdHlwZSB7QXJyYXk8YW55PnxudWxsfVxuICAgKi9cbiAgbGV0IGN1cnJlbnRDb250ZW50ID0gbnVsbFxuICBsZXQgY3VycmVudENvbnRlbnRJbmRleCA9IDBcbiAgcmV0dXJuIHtcbiAgICBbU3ltYm9sLml0ZXJhdG9yXSAoKSB7XG4gICAgICByZXR1cm4gdGhpc1xuICAgIH0sXG4gICAgbmV4dDogKCkgPT4ge1xuICAgICAgLy8gZmluZCBzb21lIGNvbnRlbnRcbiAgICAgIGlmIChjdXJyZW50Q29udGVudCA9PT0gbnVsbCkge1xuICAgICAgICB3aGlsZSAobiAhPT0gbnVsbCAmJiBuLmRlbGV0ZWQpIHtcbiAgICAgICAgICBuID0gbi5yaWdodFxuICAgICAgICB9XG4gICAgICAgIC8vIGNoZWNrIGlmIHdlIHJlYWNoZWQgdGhlIGVuZCwgbm8gbmVlZCB0byBjaGVjayBjdXJyZW50Q29udGVudCwgYmVjYXVzZSBpdCBkb2VzIG5vdCBleGlzdFxuICAgICAgICBpZiAobiA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkb25lOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHVuZGVmaW5lZFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyB3ZSBmb3VuZCBuLCBzbyB3ZSBjYW4gc2V0IGN1cnJlbnRDb250ZW50XG4gICAgICAgIGN1cnJlbnRDb250ZW50ID0gbi5jb250ZW50LmdldENvbnRlbnQoKVxuICAgICAgICBjdXJyZW50Q29udGVudEluZGV4ID0gMFxuICAgICAgICBuID0gbi5yaWdodCAvLyB3ZSB1c2VkIHRoZSBjb250ZW50IG9mIG4sIG5vdyBpdGVyYXRlIHRvIG5leHRcbiAgICAgIH1cbiAgICAgIGNvbnN0IHZhbHVlID0gY3VycmVudENvbnRlbnRbY3VycmVudENvbnRlbnRJbmRleCsrXVxuICAgICAgLy8gY2hlY2sgaWYgd2UgbmVlZCB0byBlbXB0eSBjdXJyZW50Q29udGVudFxuICAgICAgaWYgKGN1cnJlbnRDb250ZW50Lmxlbmd0aCA8PSBjdXJyZW50Q29udGVudEluZGV4KSB7XG4gICAgICAgIGN1cnJlbnRDb250ZW50ID0gbnVsbFxuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZG9uZTogZmFsc2UsXG4gICAgICAgIHZhbHVlXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogRXhlY3V0ZXMgYSBwcm92aWRlZCBmdW5jdGlvbiBvbiBvbmNlIG9uIG92ZXJ5IGVsZW1lbnQgb2YgdGhpcyBZQXJyYXkuXG4gKiBPcGVyYXRlcyBvbiBhIHNuYXBzaG90dGVkIHN0YXRlIG9mIHRoZSBkb2N1bWVudC5cbiAqXG4gKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxhbnk+fSB0eXBlXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKGFueSxudW1iZXIsQWJzdHJhY3RUeXBlPGFueT4pOnZvaWR9IGYgQSBmdW5jdGlvbiB0byBleGVjdXRlIG9uIGV2ZXJ5IGVsZW1lbnQgb2YgdGhpcyBZQXJyYXkuXG4gKiBAcGFyYW0ge1NuYXBzaG90fSBzbmFwc2hvdFxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IHR5cGVMaXN0Rm9yRWFjaFNuYXBzaG90ID0gKHR5cGUsIGYsIHNuYXBzaG90KSA9PiB7XG4gIGxldCBpbmRleCA9IDBcbiAgbGV0IG4gPSB0eXBlLl9zdGFydFxuICB3aGlsZSAobiAhPT0gbnVsbCkge1xuICAgIGlmIChuLmNvdW50YWJsZSAmJiBpc1Zpc2libGUobiwgc25hcHNob3QpKSB7XG4gICAgICBjb25zdCBjID0gbi5jb250ZW50LmdldENvbnRlbnQoKVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGYoY1tpXSwgaW5kZXgrKywgdHlwZSlcbiAgICAgIH1cbiAgICB9XG4gICAgbiA9IG4ucmlnaHRcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPGFueT59IHR5cGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICogQHJldHVybiB7YW55fVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IHR5cGVMaXN0R2V0ID0gKHR5cGUsIGluZGV4KSA9PiB7XG4gIGNvbnN0IG1hcmtlciA9IGZpbmRNYXJrZXIodHlwZSwgaW5kZXgpXG4gIGxldCBuID0gdHlwZS5fc3RhcnRcbiAgaWYgKG1hcmtlciAhPT0gbnVsbCkge1xuICAgIG4gPSBtYXJrZXIucFxuICAgIGluZGV4IC09IG1hcmtlci5pbmRleFxuICB9XG4gIGZvciAoOyBuICE9PSBudWxsOyBuID0gbi5yaWdodCkge1xuICAgIGlmICghbi5kZWxldGVkICYmIG4uY291bnRhYmxlKSB7XG4gICAgICBpZiAoaW5kZXggPCBuLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbi5jb250ZW50LmdldENvbnRlbnQoKVtpbmRleF1cbiAgICAgIH1cbiAgICAgIGluZGV4IC09IG4ubGVuZ3RoXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPGFueT59IHBhcmVudFxuICogQHBhcmFtIHtJdGVtP30gcmVmZXJlbmNlSXRlbVxuICogQHBhcmFtIHtBcnJheTxPYmplY3Q8c3RyaW5nLGFueT58QXJyYXk8YW55Pnxib29sZWFufG51bWJlcnxudWxsfHN0cmluZ3xVaW50OEFycmF5Pn0gY29udGVudFxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IHR5cGVMaXN0SW5zZXJ0R2VuZXJpY3NBZnRlciA9ICh0cmFuc2FjdGlvbiwgcGFyZW50LCByZWZlcmVuY2VJdGVtLCBjb250ZW50KSA9PiB7XG4gIGxldCBsZWZ0ID0gcmVmZXJlbmNlSXRlbVxuICBjb25zdCBkb2MgPSB0cmFuc2FjdGlvbi5kb2NcbiAgY29uc3Qgb3duQ2xpZW50SWQgPSBkb2MuY2xpZW50SURcbiAgY29uc3Qgc3RvcmUgPSBkb2Muc3RvcmVcbiAgY29uc3QgcmlnaHQgPSByZWZlcmVuY2VJdGVtID09PSBudWxsID8gcGFyZW50Ll9zdGFydCA6IHJlZmVyZW5jZUl0ZW0ucmlnaHRcbiAgLyoqXG4gICAqIEB0eXBlIHtBcnJheTxPYmplY3R8QXJyYXk8YW55PnxudW1iZXJ8bnVsbD59XG4gICAqL1xuICBsZXQganNvbkNvbnRlbnQgPSBbXVxuICBjb25zdCBwYWNrSnNvbkNvbnRlbnQgPSAoKSA9PiB7XG4gICAgaWYgKGpzb25Db250ZW50Lmxlbmd0aCA+IDApIHtcbiAgICAgIGxlZnQgPSBuZXcgSXRlbShjcmVhdGVJRChvd25DbGllbnRJZCwgZ2V0U3RhdGUoc3RvcmUsIG93bkNsaWVudElkKSksIGxlZnQsIGxlZnQgJiYgbGVmdC5sYXN0SWQsIHJpZ2h0LCByaWdodCAmJiByaWdodC5pZCwgcGFyZW50LCBudWxsLCBuZXcgQ29udGVudEFueShqc29uQ29udGVudCkpXG4gICAgICBsZWZ0LmludGVncmF0ZSh0cmFuc2FjdGlvbiwgMClcbiAgICAgIGpzb25Db250ZW50ID0gW11cbiAgICB9XG4gIH1cbiAgY29udGVudC5mb3JFYWNoKGMgPT4ge1xuICAgIGlmIChjID09PSBudWxsKSB7XG4gICAgICBqc29uQ29udGVudC5wdXNoKGMpXG4gICAgfSBlbHNlIHtcbiAgICAgIHN3aXRjaCAoYy5jb25zdHJ1Y3Rvcikge1xuICAgICAgICBjYXNlIE51bWJlcjpcbiAgICAgICAgY2FzZSBPYmplY3Q6XG4gICAgICAgIGNhc2UgQm9vbGVhbjpcbiAgICAgICAgY2FzZSBBcnJheTpcbiAgICAgICAgY2FzZSBTdHJpbmc6XG4gICAgICAgICAganNvbkNvbnRlbnQucHVzaChjKVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcGFja0pzb25Db250ZW50KClcbiAgICAgICAgICBzd2l0Y2ggKGMuY29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgIGNhc2UgVWludDhBcnJheTpcbiAgICAgICAgICAgIGNhc2UgQXJyYXlCdWZmZXI6XG4gICAgICAgICAgICAgIGxlZnQgPSBuZXcgSXRlbShjcmVhdGVJRChvd25DbGllbnRJZCwgZ2V0U3RhdGUoc3RvcmUsIG93bkNsaWVudElkKSksIGxlZnQsIGxlZnQgJiYgbGVmdC5sYXN0SWQsIHJpZ2h0LCByaWdodCAmJiByaWdodC5pZCwgcGFyZW50LCBudWxsLCBuZXcgQ29udGVudEJpbmFyeShuZXcgVWludDhBcnJheSgvKiogQHR5cGUge1VpbnQ4QXJyYXl9ICovIChjKSkpKVxuICAgICAgICAgICAgICBsZWZ0LmludGVncmF0ZSh0cmFuc2FjdGlvbiwgMClcbiAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIGNhc2UgRG9jOlxuICAgICAgICAgICAgICBsZWZ0ID0gbmV3IEl0ZW0oY3JlYXRlSUQob3duQ2xpZW50SWQsIGdldFN0YXRlKHN0b3JlLCBvd25DbGllbnRJZCkpLCBsZWZ0LCBsZWZ0ICYmIGxlZnQubGFzdElkLCByaWdodCwgcmlnaHQgJiYgcmlnaHQuaWQsIHBhcmVudCwgbnVsbCwgbmV3IENvbnRlbnREb2MoLyoqIEB0eXBlIHtEb2N9ICovIChjKSkpXG4gICAgICAgICAgICAgIGxlZnQuaW50ZWdyYXRlKHRyYW5zYWN0aW9uLCAwKVxuICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgaWYgKGMgaW5zdGFuY2VvZiBBYnN0cmFjdFR5cGUpIHtcbiAgICAgICAgICAgICAgICBsZWZ0ID0gbmV3IEl0ZW0oY3JlYXRlSUQob3duQ2xpZW50SWQsIGdldFN0YXRlKHN0b3JlLCBvd25DbGllbnRJZCkpLCBsZWZ0LCBsZWZ0ICYmIGxlZnQubGFzdElkLCByaWdodCwgcmlnaHQgJiYgcmlnaHQuaWQsIHBhcmVudCwgbnVsbCwgbmV3IENvbnRlbnRUeXBlKGMpKVxuICAgICAgICAgICAgICAgIGxlZnQuaW50ZWdyYXRlKHRyYW5zYWN0aW9uLCAwKVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBjb250ZW50IHR5cGUgaW4gaW5zZXJ0IG9wZXJhdGlvbicpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KVxuICBwYWNrSnNvbkNvbnRlbnQoKVxufVxuXG5jb25zdCBsZW5ndGhFeGNlZWRlZCA9ICgpID0+IGVycm9yLmNyZWF0ZSgnTGVuZ3RoIGV4Y2VlZGVkIScpXG5cbi8qKlxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPGFueT59IHBhcmVudFxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gKiBAcGFyYW0ge0FycmF5PE9iamVjdDxzdHJpbmcsYW55PnxBcnJheTxhbnk+fG51bWJlcnxudWxsfHN0cmluZ3xVaW50OEFycmF5Pn0gY29udGVudFxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IHR5cGVMaXN0SW5zZXJ0R2VuZXJpY3MgPSAodHJhbnNhY3Rpb24sIHBhcmVudCwgaW5kZXgsIGNvbnRlbnQpID0+IHtcbiAgaWYgKGluZGV4ID4gcGFyZW50Ll9sZW5ndGgpIHtcbiAgICB0aHJvdyBsZW5ndGhFeGNlZWRlZCgpXG4gIH1cbiAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgaWYgKHBhcmVudC5fc2VhcmNoTWFya2VyKSB7XG4gICAgICB1cGRhdGVNYXJrZXJDaGFuZ2VzKHBhcmVudC5fc2VhcmNoTWFya2VyLCBpbmRleCwgY29udGVudC5sZW5ndGgpXG4gICAgfVxuICAgIHJldHVybiB0eXBlTGlzdEluc2VydEdlbmVyaWNzQWZ0ZXIodHJhbnNhY3Rpb24sIHBhcmVudCwgbnVsbCwgY29udGVudClcbiAgfVxuICBjb25zdCBzdGFydEluZGV4ID0gaW5kZXhcbiAgY29uc3QgbWFya2VyID0gZmluZE1hcmtlcihwYXJlbnQsIGluZGV4KVxuICBsZXQgbiA9IHBhcmVudC5fc3RhcnRcbiAgaWYgKG1hcmtlciAhPT0gbnVsbCkge1xuICAgIG4gPSBtYXJrZXIucFxuICAgIGluZGV4IC09IG1hcmtlci5pbmRleFxuICAgIC8vIHdlIG5lZWQgdG8gaXRlcmF0ZSBvbmUgdG8gdGhlIGxlZnQgc28gdGhhdCB0aGUgYWxnb3JpdGhtIHdvcmtzXG4gICAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICAvLyBAdG9kbyByZWZhY3RvciB0aGlzIGFzIGl0IGFjdHVhbGx5IGRvZXNuJ3QgY29uc2lkZXIgZm9ybWF0c1xuICAgICAgbiA9IG4ucHJldiAvLyBpbXBvcnRhbnQhIGdldCB0aGUgbGVmdCB1bmRlbGV0ZWQgaXRlbSBzbyB0aGF0IHdlIGNhbiBhY3R1YWxseSBkZWNyZWFzZSBpbmRleFxuICAgICAgaW5kZXggKz0gKG4gJiYgbi5jb3VudGFibGUgJiYgIW4uZGVsZXRlZCkgPyBuLmxlbmd0aCA6IDBcbiAgICB9XG4gIH1cbiAgZm9yICg7IG4gIT09IG51bGw7IG4gPSBuLnJpZ2h0KSB7XG4gICAgaWYgKCFuLmRlbGV0ZWQgJiYgbi5jb3VudGFibGUpIHtcbiAgICAgIGlmIChpbmRleCA8PSBuLmxlbmd0aCkge1xuICAgICAgICBpZiAoaW5kZXggPCBuLmxlbmd0aCkge1xuICAgICAgICAgIC8vIGluc2VydCBpbi1iZXR3ZWVuXG4gICAgICAgICAgZ2V0SXRlbUNsZWFuU3RhcnQodHJhbnNhY3Rpb24sIGNyZWF0ZUlEKG4uaWQuY2xpZW50LCBuLmlkLmNsb2NrICsgaW5kZXgpKVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBpbmRleCAtPSBuLmxlbmd0aFxuICAgIH1cbiAgfVxuICBpZiAocGFyZW50Ll9zZWFyY2hNYXJrZXIpIHtcbiAgICB1cGRhdGVNYXJrZXJDaGFuZ2VzKHBhcmVudC5fc2VhcmNoTWFya2VyLCBzdGFydEluZGV4LCBjb250ZW50Lmxlbmd0aClcbiAgfVxuICByZXR1cm4gdHlwZUxpc3RJbnNlcnRHZW5lcmljc0FmdGVyKHRyYW5zYWN0aW9uLCBwYXJlbnQsIG4sIGNvbnRlbnQpXG59XG5cbi8qKlxuICogUHVzaGluZyBjb250ZW50IGlzIHNwZWNpYWwgYXMgd2UgZ2VuZXJhbGx5IHdhbnQgdG8gcHVzaCBhZnRlciB0aGUgbGFzdCBpdGVtLiBTbyB3ZSBkb24ndCBoYXZlIHRvIHVwZGF0ZVxuICogdGhlIHNlcmFjaCBtYXJrZXIuXG4gKlxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPGFueT59IHBhcmVudFxuICogQHBhcmFtIHtBcnJheTxPYmplY3Q8c3RyaW5nLGFueT58QXJyYXk8YW55PnxudW1iZXJ8bnVsbHxzdHJpbmd8VWludDhBcnJheT59IGNvbnRlbnRcbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCB0eXBlTGlzdFB1c2hHZW5lcmljcyA9ICh0cmFuc2FjdGlvbiwgcGFyZW50LCBjb250ZW50KSA9PiB7XG4gIC8vIFVzZSB0aGUgbWFya2VyIHdpdGggdGhlIGhpZ2hlc3QgaW5kZXggYW5kIGl0ZXJhdGUgdG8gdGhlIHJpZ2h0LlxuICBjb25zdCBtYXJrZXIgPSAocGFyZW50Ll9zZWFyY2hNYXJrZXIgfHwgW10pLnJlZHVjZSgobWF4TWFya2VyLCBjdXJyTWFya2VyKSA9PiBjdXJyTWFya2VyLmluZGV4ID4gbWF4TWFya2VyLmluZGV4ID8gY3Vyck1hcmtlciA6IG1heE1hcmtlciwgeyBpbmRleDogMCwgcDogcGFyZW50Ll9zdGFydCB9KVxuICBsZXQgbiA9IG1hcmtlci5wXG4gIGlmIChuKSB7XG4gICAgd2hpbGUgKG4ucmlnaHQpIHtcbiAgICAgIG4gPSBuLnJpZ2h0XG4gICAgfVxuICB9XG4gIHJldHVybiB0eXBlTGlzdEluc2VydEdlbmVyaWNzQWZ0ZXIodHJhbnNhY3Rpb24sIHBhcmVudCwgbiwgY29udGVudClcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0gcGFyZW50XG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGhcbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCB0eXBlTGlzdERlbGV0ZSA9ICh0cmFuc2FjdGlvbiwgcGFyZW50LCBpbmRleCwgbGVuZ3RoKSA9PiB7XG4gIGlmIChsZW5ndGggPT09IDApIHsgcmV0dXJuIH1cbiAgY29uc3Qgc3RhcnRJbmRleCA9IGluZGV4XG4gIGNvbnN0IHN0YXJ0TGVuZ3RoID0gbGVuZ3RoXG4gIGNvbnN0IG1hcmtlciA9IGZpbmRNYXJrZXIocGFyZW50LCBpbmRleClcbiAgbGV0IG4gPSBwYXJlbnQuX3N0YXJ0XG4gIGlmIChtYXJrZXIgIT09IG51bGwpIHtcbiAgICBuID0gbWFya2VyLnBcbiAgICBpbmRleCAtPSBtYXJrZXIuaW5kZXhcbiAgfVxuICAvLyBjb21wdXRlIHRoZSBmaXJzdCBpdGVtIHRvIGJlIGRlbGV0ZWRcbiAgZm9yICg7IG4gIT09IG51bGwgJiYgaW5kZXggPiAwOyBuID0gbi5yaWdodCkge1xuICAgIGlmICghbi5kZWxldGVkICYmIG4uY291bnRhYmxlKSB7XG4gICAgICBpZiAoaW5kZXggPCBuLmxlbmd0aCkge1xuICAgICAgICBnZXRJdGVtQ2xlYW5TdGFydCh0cmFuc2FjdGlvbiwgY3JlYXRlSUQobi5pZC5jbGllbnQsIG4uaWQuY2xvY2sgKyBpbmRleCkpXG4gICAgICB9XG4gICAgICBpbmRleCAtPSBuLmxlbmd0aFxuICAgIH1cbiAgfVxuICAvLyBkZWxldGUgYWxsIGl0ZW1zIHVudGlsIGRvbmVcbiAgd2hpbGUgKGxlbmd0aCA+IDAgJiYgbiAhPT0gbnVsbCkge1xuICAgIGlmICghbi5kZWxldGVkKSB7XG4gICAgICBpZiAobGVuZ3RoIDwgbi5sZW5ndGgpIHtcbiAgICAgICAgZ2V0SXRlbUNsZWFuU3RhcnQodHJhbnNhY3Rpb24sIGNyZWF0ZUlEKG4uaWQuY2xpZW50LCBuLmlkLmNsb2NrICsgbGVuZ3RoKSlcbiAgICAgIH1cbiAgICAgIG4uZGVsZXRlKHRyYW5zYWN0aW9uKVxuICAgICAgbGVuZ3RoIC09IG4ubGVuZ3RoXG4gICAgfVxuICAgIG4gPSBuLnJpZ2h0XG4gIH1cbiAgaWYgKGxlbmd0aCA+IDApIHtcbiAgICB0aHJvdyBsZW5ndGhFeGNlZWRlZCgpXG4gIH1cbiAgaWYgKHBhcmVudC5fc2VhcmNoTWFya2VyKSB7XG4gICAgdXBkYXRlTWFya2VyQ2hhbmdlcyhwYXJlbnQuX3NlYXJjaE1hcmtlciwgc3RhcnRJbmRleCwgLXN0YXJ0TGVuZ3RoICsgbGVuZ3RoIC8qIGluIGNhc2Ugd2UgcmVtb3ZlIHRoZSBhYm92ZSBleGNlcHRpb24gKi8pXG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0gcGFyZW50XG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgdHlwZU1hcERlbGV0ZSA9ICh0cmFuc2FjdGlvbiwgcGFyZW50LCBrZXkpID0+IHtcbiAgY29uc3QgYyA9IHBhcmVudC5fbWFwLmdldChrZXkpXG4gIGlmIChjICE9PSB1bmRlZmluZWQpIHtcbiAgICBjLmRlbGV0ZSh0cmFuc2FjdGlvbilcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxhbnk+fSBwYXJlbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7T2JqZWN0fG51bWJlcnxudWxsfEFycmF5PGFueT58c3RyaW5nfFVpbnQ4QXJyYXl8QWJzdHJhY3RUeXBlPGFueT59IHZhbHVlXG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgdHlwZU1hcFNldCA9ICh0cmFuc2FjdGlvbiwgcGFyZW50LCBrZXksIHZhbHVlKSA9PiB7XG4gIGNvbnN0IGxlZnQgPSBwYXJlbnQuX21hcC5nZXQoa2V5KSB8fCBudWxsXG4gIGNvbnN0IGRvYyA9IHRyYW5zYWN0aW9uLmRvY1xuICBjb25zdCBvd25DbGllbnRJZCA9IGRvYy5jbGllbnRJRFxuICBsZXQgY29udGVudFxuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIGNvbnRlbnQgPSBuZXcgQ29udGVudEFueShbdmFsdWVdKVxuICB9IGVsc2Uge1xuICAgIHN3aXRjaCAodmFsdWUuY29uc3RydWN0b3IpIHtcbiAgICAgIGNhc2UgTnVtYmVyOlxuICAgICAgY2FzZSBPYmplY3Q6XG4gICAgICBjYXNlIEJvb2xlYW46XG4gICAgICBjYXNlIEFycmF5OlxuICAgICAgY2FzZSBTdHJpbmc6XG4gICAgICAgIGNvbnRlbnQgPSBuZXcgQ29udGVudEFueShbdmFsdWVdKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSBVaW50OEFycmF5OlxuICAgICAgICBjb250ZW50ID0gbmV3IENvbnRlbnRCaW5hcnkoLyoqIEB0eXBlIHtVaW50OEFycmF5fSAqLyAodmFsdWUpKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSBEb2M6XG4gICAgICAgIGNvbnRlbnQgPSBuZXcgQ29udGVudERvYygvKiogQHR5cGUge0RvY30gKi8gKHZhbHVlKSlcbiAgICAgICAgYnJlYWtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFic3RyYWN0VHlwZSkge1xuICAgICAgICAgIGNvbnRlbnQgPSBuZXcgQ29udGVudFR5cGUodmFsdWUpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIGNvbnRlbnQgdHlwZScpXG4gICAgICAgIH1cbiAgICB9XG4gIH1cbiAgbmV3IEl0ZW0oY3JlYXRlSUQob3duQ2xpZW50SWQsIGdldFN0YXRlKGRvYy5zdG9yZSwgb3duQ2xpZW50SWQpKSwgbGVmdCwgbGVmdCAmJiBsZWZ0Lmxhc3RJZCwgbnVsbCwgbnVsbCwgcGFyZW50LCBrZXksIGNvbnRlbnQpLmludGVncmF0ZSh0cmFuc2FjdGlvbiwgMClcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxhbnk+fSBwYXJlbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqIEByZXR1cm4ge09iamVjdDxzdHJpbmcsYW55PnxudW1iZXJ8bnVsbHxBcnJheTxhbnk+fHN0cmluZ3xVaW50OEFycmF5fEFic3RyYWN0VHlwZTxhbnk+fHVuZGVmaW5lZH1cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCB0eXBlTWFwR2V0ID0gKHBhcmVudCwga2V5KSA9PiB7XG4gIGNvbnN0IHZhbCA9IHBhcmVudC5fbWFwLmdldChrZXkpXG4gIHJldHVybiB2YWwgIT09IHVuZGVmaW5lZCAmJiAhdmFsLmRlbGV0ZWQgPyB2YWwuY29udGVudC5nZXRDb250ZW50KClbdmFsLmxlbmd0aCAtIDFdIDogdW5kZWZpbmVkXG59XG5cbi8qKlxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0gcGFyZW50XG4gKiBAcmV0dXJuIHtPYmplY3Q8c3RyaW5nLE9iamVjdDxzdHJpbmcsYW55PnxudW1iZXJ8bnVsbHxBcnJheTxhbnk+fHN0cmluZ3xVaW50OEFycmF5fEFic3RyYWN0VHlwZTxhbnk+fHVuZGVmaW5lZD59XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgdHlwZU1hcEdldEFsbCA9IChwYXJlbnQpID0+IHtcbiAgLyoqXG4gICAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLGFueT59XG4gICAqL1xuICBjb25zdCByZXMgPSB7fVxuICBwYXJlbnQuX21hcC5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgaWYgKCF2YWx1ZS5kZWxldGVkKSB7XG4gICAgICByZXNba2V5XSA9IHZhbHVlLmNvbnRlbnQuZ2V0Q29udGVudCgpW3ZhbHVlLmxlbmd0aCAtIDFdXG4gICAgfVxuICB9KVxuICByZXR1cm4gcmVzXG59XG5cbi8qKlxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0gcGFyZW50XG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IHR5cGVNYXBIYXMgPSAocGFyZW50LCBrZXkpID0+IHtcbiAgY29uc3QgdmFsID0gcGFyZW50Ll9tYXAuZ2V0KGtleSlcbiAgcmV0dXJuIHZhbCAhPT0gdW5kZWZpbmVkICYmICF2YWwuZGVsZXRlZFxufVxuXG4vKipcbiAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPGFueT59IHBhcmVudFxuICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICogQHBhcmFtIHtTbmFwc2hvdH0gc25hcHNob3RcbiAqIEByZXR1cm4ge09iamVjdDxzdHJpbmcsYW55PnxudW1iZXJ8bnVsbHxBcnJheTxhbnk+fHN0cmluZ3xVaW50OEFycmF5fEFic3RyYWN0VHlwZTxhbnk+fHVuZGVmaW5lZH1cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCB0eXBlTWFwR2V0U25hcHNob3QgPSAocGFyZW50LCBrZXksIHNuYXBzaG90KSA9PiB7XG4gIGxldCB2ID0gcGFyZW50Ll9tYXAuZ2V0KGtleSkgfHwgbnVsbFxuICB3aGlsZSAodiAhPT0gbnVsbCAmJiAoIXNuYXBzaG90LnN2Lmhhcyh2LmlkLmNsaWVudCkgfHwgdi5pZC5jbG9jayA+PSAoc25hcHNob3Quc3YuZ2V0KHYuaWQuY2xpZW50KSB8fCAwKSkpIHtcbiAgICB2ID0gdi5sZWZ0XG4gIH1cbiAgcmV0dXJuIHYgIT09IG51bGwgJiYgaXNWaXNpYmxlKHYsIHNuYXBzaG90KSA/IHYuY29udGVudC5nZXRDb250ZW50KClbdi5sZW5ndGggLSAxXSA6IHVuZGVmaW5lZFxufVxuXG4vKipcbiAqIEBwYXJhbSB7TWFwPHN0cmluZyxJdGVtPn0gbWFwXG4gKiBAcmV0dXJuIHtJdGVyYWJsZUl0ZXJhdG9yPEFycmF5PGFueT4+fVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZU1hcEl0ZXJhdG9yID0gbWFwID0+IGl0ZXJhdG9yLml0ZXJhdG9yRmlsdGVyKG1hcC5lbnRyaWVzKCksIC8qKiBAcGFyYW0ge2FueX0gZW50cnkgKi8gZW50cnkgPT4gIWVudHJ5WzFdLmRlbGV0ZWQpXG4iLCAiLyoqXG4gKiBAbW9kdWxlIFlBcnJheVxuICovXG5cbmltcG9ydCB7XG4gIFlFdmVudCxcbiAgQWJzdHJhY3RUeXBlLFxuICB0eXBlTGlzdEdldCxcbiAgdHlwZUxpc3RUb0FycmF5LFxuICB0eXBlTGlzdEZvckVhY2gsXG4gIHR5cGVMaXN0Q3JlYXRlSXRlcmF0b3IsXG4gIHR5cGVMaXN0SW5zZXJ0R2VuZXJpY3MsXG4gIHR5cGVMaXN0UHVzaEdlbmVyaWNzLFxuICB0eXBlTGlzdERlbGV0ZSxcbiAgdHlwZUxpc3RNYXAsXG4gIFlBcnJheVJlZklELFxuICBjYWxsVHlwZU9ic2VydmVycyxcbiAgdHJhbnNhY3QsXG4gIEFycmF5U2VhcmNoTWFya2VyLCBVcGRhdGVEZWNvZGVyVjEsIFVwZGF0ZURlY29kZXJWMiwgVXBkYXRlRW5jb2RlclYxLCBVcGRhdGVFbmNvZGVyVjIsIERvYywgVHJhbnNhY3Rpb24sIEl0ZW0gLy8gZXNsaW50LWRpc2FibGUtbGluZVxufSBmcm9tICcuLi9pbnRlcm5hbHMuanMnXG5pbXBvcnQgeyB0eXBlTGlzdFNsaWNlIH0gZnJvbSAnLi9BYnN0cmFjdFR5cGUuanMnXG5cbi8qKlxuICogRXZlbnQgdGhhdCBkZXNjcmliZXMgdGhlIGNoYW5nZXMgb24gYSBZQXJyYXlcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAZXh0ZW5kcyBZRXZlbnQ8WUFycmF5PFQ+PlxuICovXG5leHBvcnQgY2xhc3MgWUFycmF5RXZlbnQgZXh0ZW5kcyBZRXZlbnQge1xuICAvKipcbiAgICogQHBhcmFtIHtZQXJyYXk8VD59IHlhcnJheSBUaGUgY2hhbmdlZCB0eXBlXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uIFRoZSB0cmFuc2FjdGlvbiBvYmplY3RcbiAgICovXG4gIGNvbnN0cnVjdG9yICh5YXJyYXksIHRyYW5zYWN0aW9uKSB7XG4gICAgc3VwZXIoeWFycmF5LCB0cmFuc2FjdGlvbilcbiAgICB0aGlzLl90cmFuc2FjdGlvbiA9IHRyYW5zYWN0aW9uXG4gIH1cbn1cblxuLyoqXG4gKiBBIHNoYXJlZCBBcnJheSBpbXBsZW1lbnRhdGlvbi5cbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAZXh0ZW5kcyBBYnN0cmFjdFR5cGU8WUFycmF5RXZlbnQ8VD4+XG4gKiBAaW1wbGVtZW50cyB7SXRlcmFibGU8VD59XG4gKi9cbmV4cG9ydCBjbGFzcyBZQXJyYXkgZXh0ZW5kcyBBYnN0cmFjdFR5cGUge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgc3VwZXIoKVxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBcnJheTxhbnk+P31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX3ByZWxpbUNvbnRlbnQgPSBbXVxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBcnJheTxBcnJheVNlYXJjaE1hcmtlcj59XG4gICAgICovXG4gICAgdGhpcy5fc2VhcmNoTWFya2VyID0gW11cbiAgfVxuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgWUFycmF5IGNvbnRhaW5pbmcgdGhlIHNwZWNpZmllZCBpdGVtcy5cbiAgICogQHRlbXBsYXRlIHtPYmplY3Q8c3RyaW5nLGFueT58QXJyYXk8YW55PnxudW1iZXJ8bnVsbHxzdHJpbmd8VWludDhBcnJheX0gVFxuICAgKiBAcGFyYW0ge0FycmF5PFQ+fSBpdGVtc1xuICAgKiBAcmV0dXJuIHtZQXJyYXk8VD59XG4gICAqL1xuICBzdGF0aWMgZnJvbSAoaXRlbXMpIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7WUFycmF5PFQ+fVxuICAgICAqL1xuICAgIGNvbnN0IGEgPSBuZXcgWUFycmF5KClcbiAgICBhLnB1c2goaXRlbXMpXG4gICAgcmV0dXJuIGFcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnRlZ3JhdGUgdGhpcyB0eXBlIGludG8gdGhlIFlqcyBpbnN0YW5jZS5cbiAgICpcbiAgICogKiBTYXZlIHRoaXMgc3RydWN0IGluIHRoZSBvc1xuICAgKiAqIFRoaXMgdHlwZSBpcyBzZW50IHRvIG90aGVyIGNsaWVudFxuICAgKiAqIE9ic2VydmVyIGZ1bmN0aW9ucyBhcmUgZmlyZWRcbiAgICpcbiAgICogQHBhcmFtIHtEb2N9IHkgVGhlIFlqcyBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge0l0ZW19IGl0ZW1cbiAgICovXG4gIF9pbnRlZ3JhdGUgKHksIGl0ZW0pIHtcbiAgICBzdXBlci5faW50ZWdyYXRlKHksIGl0ZW0pXG4gICAgdGhpcy5pbnNlcnQoMCwgLyoqIEB0eXBlIHtBcnJheTxhbnk+fSAqLyAodGhpcy5fcHJlbGltQ29udGVudCkpXG4gICAgdGhpcy5fcHJlbGltQ29udGVudCA9IG51bGxcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtZQXJyYXk8VD59XG4gICAqL1xuICBfY29weSAoKSB7XG4gICAgcmV0dXJuIG5ldyBZQXJyYXkoKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge1lBcnJheTxUPn1cbiAgICovXG4gIGNsb25lICgpIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7WUFycmF5PFQ+fVxuICAgICAqL1xuICAgIGNvbnN0IGFyciA9IG5ldyBZQXJyYXkoKVxuICAgIGFyci5pbnNlcnQoMCwgdGhpcy50b0FycmF5KCkubWFwKGVsID0+XG4gICAgICBlbCBpbnN0YW5jZW9mIEFic3RyYWN0VHlwZSA/IC8qKiBAdHlwZSB7dHlwZW9mIGVsfSAqLyAoZWwuY2xvbmUoKSkgOiBlbFxuICAgICkpXG4gICAgcmV0dXJuIGFyclxuICB9XG5cbiAgZ2V0IGxlbmd0aCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ByZWxpbUNvbnRlbnQgPT09IG51bGwgPyB0aGlzLl9sZW5ndGggOiB0aGlzLl9wcmVsaW1Db250ZW50Lmxlbmd0aFxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgWUFycmF5RXZlbnQgYW5kIGNhbGxzIG9ic2VydmVycy5cbiAgICpcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtTZXQ8bnVsbHxzdHJpbmc+fSBwYXJlbnRTdWJzIEtleXMgY2hhbmdlZCBvbiB0aGlzIHR5cGUuIGBudWxsYCBpZiBsaXN0IHdhcyBtb2RpZmllZC5cbiAgICovXG4gIF9jYWxsT2JzZXJ2ZXIgKHRyYW5zYWN0aW9uLCBwYXJlbnRTdWJzKSB7XG4gICAgc3VwZXIuX2NhbGxPYnNlcnZlcih0cmFuc2FjdGlvbiwgcGFyZW50U3VicylcbiAgICBjYWxsVHlwZU9ic2VydmVycyh0aGlzLCB0cmFuc2FjdGlvbiwgbmV3IFlBcnJheUV2ZW50KHRoaXMsIHRyYW5zYWN0aW9uKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnNlcnRzIG5ldyBjb250ZW50IGF0IGFuIGluZGV4LlxuICAgKlxuICAgKiBJbXBvcnRhbnQ6IFRoaXMgZnVuY3Rpb24gZXhwZWN0cyBhbiBhcnJheSBvZiBjb250ZW50LiBOb3QganVzdCBhIGNvbnRlbnRcbiAgICogb2JqZWN0LiBUaGUgcmVhc29uIGZvciB0aGlzIFwid2VpcmRuZXNzXCIgaXMgdGhhdCBpbnNlcnRpbmcgc2V2ZXJhbCBlbGVtZW50c1xuICAgKiBpcyB2ZXJ5IGVmZmljaWVudCB3aGVuIGl0IGlzIGRvbmUgYXMgYSBzaW5nbGUgb3BlcmF0aW9uLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAgLy8gSW5zZXJ0IGNoYXJhY3RlciAnYScgYXQgcG9zaXRpb24gMFxuICAgKiAgeWFycmF5Lmluc2VydCgwLCBbJ2EnXSlcbiAgICogIC8vIEluc2VydCBudW1iZXJzIDEsIDIgYXQgcG9zaXRpb24gMVxuICAgKiAgeWFycmF5Lmluc2VydCgxLCBbMSwgMl0pXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgaW5kZXggdG8gaW5zZXJ0IGNvbnRlbnQgYXQuXG4gICAqIEBwYXJhbSB7QXJyYXk8VD59IGNvbnRlbnQgVGhlIGFycmF5IG9mIGNvbnRlbnRcbiAgICovXG4gIGluc2VydCAoaW5kZXgsIGNvbnRlbnQpIHtcbiAgICBpZiAodGhpcy5kb2MgIT09IG51bGwpIHtcbiAgICAgIHRyYW5zYWN0KHRoaXMuZG9jLCB0cmFuc2FjdGlvbiA9PiB7XG4gICAgICAgIHR5cGVMaXN0SW5zZXJ0R2VuZXJpY3ModHJhbnNhY3Rpb24sIHRoaXMsIGluZGV4LCAvKiogQHR5cGUge2FueX0gKi8gKGNvbnRlbnQpKVxuICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgLyoqIEB0eXBlIHtBcnJheTxhbnk+fSAqLyAodGhpcy5fcHJlbGltQ29udGVudCkuc3BsaWNlKGluZGV4LCAwLCAuLi5jb250ZW50KVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBlbmRzIGNvbnRlbnQgdG8gdGhpcyBZQXJyYXkuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXk8VD59IGNvbnRlbnQgQXJyYXkgb2YgY29udGVudCB0byBhcHBlbmQuXG4gICAqXG4gICAqIEB0b2RvIFVzZSB0aGUgZm9sbG93aW5nIGltcGxlbWVudGF0aW9uIGluIGFsbCB0eXBlcy5cbiAgICovXG4gIHB1c2ggKGNvbnRlbnQpIHtcbiAgICBpZiAodGhpcy5kb2MgIT09IG51bGwpIHtcbiAgICAgIHRyYW5zYWN0KHRoaXMuZG9jLCB0cmFuc2FjdGlvbiA9PiB7XG4gICAgICAgIHR5cGVMaXN0UHVzaEdlbmVyaWNzKHRyYW5zYWN0aW9uLCB0aGlzLCAvKiogQHR5cGUge2FueX0gKi8gKGNvbnRlbnQpKVxuICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgLyoqIEB0eXBlIHtBcnJheTxhbnk+fSAqLyAodGhpcy5fcHJlbGltQ29udGVudCkucHVzaCguLi5jb250ZW50KVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQcmVwcGVuZHMgY29udGVudCB0byB0aGlzIFlBcnJheS5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheTxUPn0gY29udGVudCBBcnJheSBvZiBjb250ZW50IHRvIHByZXBwZW5kLlxuICAgKi9cbiAgdW5zaGlmdCAoY29udGVudCkge1xuICAgIHRoaXMuaW5zZXJ0KDAsIGNvbnRlbnQpXG4gIH1cblxuICAvKipcbiAgICogRGVsZXRlcyBlbGVtZW50cyBzdGFydGluZyBmcm9tIGFuIGluZGV4LlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggSW5kZXggYXQgd2hpY2ggdG8gc3RhcnQgZGVsZXRpbmcgZWxlbWVudHNcbiAgICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aCBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIHJlbW92ZS4gRGVmYXVsdHMgdG8gMS5cbiAgICovXG4gIGRlbGV0ZSAoaW5kZXgsIGxlbmd0aCA9IDEpIHtcbiAgICBpZiAodGhpcy5kb2MgIT09IG51bGwpIHtcbiAgICAgIHRyYW5zYWN0KHRoaXMuZG9jLCB0cmFuc2FjdGlvbiA9PiB7XG4gICAgICAgIHR5cGVMaXN0RGVsZXRlKHRyYW5zYWN0aW9uLCB0aGlzLCBpbmRleCwgbGVuZ3RoKVxuICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgLyoqIEB0eXBlIHtBcnJheTxhbnk+fSAqLyAodGhpcy5fcHJlbGltQ29udGVudCkuc3BsaWNlKGluZGV4LCBsZW5ndGgpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGktdGggZWxlbWVudCBmcm9tIGEgWUFycmF5LlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSBlbGVtZW50IHRvIHJldHVybiBmcm9tIHRoZSBZQXJyYXlcbiAgICogQHJldHVybiB7VH1cbiAgICovXG4gIGdldCAoaW5kZXgpIHtcbiAgICByZXR1cm4gdHlwZUxpc3RHZXQodGhpcywgaW5kZXgpXG4gIH1cblxuICAvKipcbiAgICogVHJhbnNmb3JtcyB0aGlzIFlBcnJheSB0byBhIEphdmFTY3JpcHQgQXJyYXkuXG4gICAqXG4gICAqIEByZXR1cm4ge0FycmF5PFQ+fVxuICAgKi9cbiAgdG9BcnJheSAoKSB7XG4gICAgcmV0dXJuIHR5cGVMaXN0VG9BcnJheSh0aGlzKVxuICB9XG5cbiAgLyoqXG4gICAqIFRyYW5zZm9ybXMgdGhpcyBZQXJyYXkgdG8gYSBKYXZhU2NyaXB0IEFycmF5LlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0XVxuICAgKiBAcGFyYW0ge251bWJlcn0gW2VuZF1cbiAgICogQHJldHVybiB7QXJyYXk8VD59XG4gICAqL1xuICBzbGljZSAoc3RhcnQgPSAwLCBlbmQgPSB0aGlzLmxlbmd0aCkge1xuICAgIHJldHVybiB0eXBlTGlzdFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG4gIH1cblxuICAvKipcbiAgICogVHJhbnNmb3JtcyB0aGlzIFNoYXJlZCBUeXBlIHRvIGEgSlNPTiBvYmplY3QuXG4gICAqXG4gICAqIEByZXR1cm4ge0FycmF5PGFueT59XG4gICAqL1xuICB0b0pTT04gKCkge1xuICAgIHJldHVybiB0aGlzLm1hcChjID0+IGMgaW5zdGFuY2VvZiBBYnN0cmFjdFR5cGUgPyBjLnRvSlNPTigpIDogYylcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIEFycmF5IHdpdGggdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGEgcHJvdmlkZWQgZnVuY3Rpb24gb24gZXZlcnlcbiAgICogZWxlbWVudCBvZiB0aGlzIFlBcnJheS5cbiAgICpcbiAgICogQHRlbXBsYXRlIE1cbiAgICogQHBhcmFtIHtmdW5jdGlvbihULG51bWJlcixZQXJyYXk8VD4pOk19IGYgRnVuY3Rpb24gdGhhdCBwcm9kdWNlcyBhbiBlbGVtZW50IG9mIHRoZSBuZXcgQXJyYXlcbiAgICogQHJldHVybiB7QXJyYXk8TT59IEEgbmV3IGFycmF5IHdpdGggZWFjaCBlbGVtZW50IGJlaW5nIHRoZSByZXN1bHQgb2YgdGhlXG4gICAqICAgICAgICAgICAgICAgICBjYWxsYmFjayBmdW5jdGlvblxuICAgKi9cbiAgbWFwIChmKSB7XG4gICAgcmV0dXJuIHR5cGVMaXN0TWFwKHRoaXMsIC8qKiBAdHlwZSB7YW55fSAqLyAoZikpXG4gIH1cblxuICAvKipcbiAgICogRXhlY3V0ZXMgYSBwcm92aWRlZCBmdW5jdGlvbiBvbmNlIG9uIG92ZXJ5IGVsZW1lbnQgb2YgdGhpcyBZQXJyYXkuXG4gICAqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oVCxudW1iZXIsWUFycmF5PFQ+KTp2b2lkfSBmIEEgZnVuY3Rpb24gdG8gZXhlY3V0ZSBvbiBldmVyeSBlbGVtZW50IG9mIHRoaXMgWUFycmF5LlxuICAgKi9cbiAgZm9yRWFjaCAoZikge1xuICAgIHR5cGVMaXN0Rm9yRWFjaCh0aGlzLCBmKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0l0ZXJhYmxlSXRlcmF0b3I8VD59XG4gICAqL1xuICBbU3ltYm9sLml0ZXJhdG9yXSAoKSB7XG4gICAgcmV0dXJuIHR5cGVMaXN0Q3JlYXRlSXRlcmF0b3IodGhpcylcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1VwZGF0ZUVuY29kZXJWMSB8IFVwZGF0ZUVuY29kZXJWMn0gZW5jb2RlclxuICAgKi9cbiAgX3dyaXRlIChlbmNvZGVyKSB7XG4gICAgZW5jb2Rlci53cml0ZVR5cGVSZWYoWUFycmF5UmVmSUQpXG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1VwZGF0ZURlY29kZXJWMSB8IFVwZGF0ZURlY29kZXJWMn0gX2RlY29kZXJcbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCByZWFkWUFycmF5ID0gX2RlY29kZXIgPT4gbmV3IFlBcnJheSgpXG4iLCAiXG4vKipcbiAqIEBtb2R1bGUgWU1hcFxuICovXG5cbmltcG9ydCB7XG4gIFlFdmVudCxcbiAgQWJzdHJhY3RUeXBlLFxuICB0eXBlTWFwRGVsZXRlLFxuICB0eXBlTWFwU2V0LFxuICB0eXBlTWFwR2V0LFxuICB0eXBlTWFwSGFzLFxuICBjcmVhdGVNYXBJdGVyYXRvcixcbiAgWU1hcFJlZklELFxuICBjYWxsVHlwZU9ic2VydmVycyxcbiAgdHJhbnNhY3QsXG4gIFVwZGF0ZURlY29kZXJWMSwgVXBkYXRlRGVjb2RlclYyLCBVcGRhdGVFbmNvZGVyVjEsIFVwZGF0ZUVuY29kZXJWMiwgRG9jLCBUcmFuc2FjdGlvbiwgSXRlbSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG59IGZyb20gJy4uL2ludGVybmFscy5qcydcblxuaW1wb3J0ICogYXMgaXRlcmF0b3IgZnJvbSAnbGliMC9pdGVyYXRvcidcblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQGV4dGVuZHMgWUV2ZW50PFlNYXA8VD4+XG4gKiBFdmVudCB0aGF0IGRlc2NyaWJlcyB0aGUgY2hhbmdlcyBvbiBhIFlNYXAuXG4gKi9cbmV4cG9ydCBjbGFzcyBZTWFwRXZlbnQgZXh0ZW5kcyBZRXZlbnQge1xuICAvKipcbiAgICogQHBhcmFtIHtZTWFwPFQ+fSB5bWFwIFRoZSBZQXJyYXkgdGhhdCBjaGFuZ2VkLlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge1NldDxhbnk+fSBzdWJzIFRoZSBrZXlzIHRoYXQgY2hhbmdlZC5cbiAgICovXG4gIGNvbnN0cnVjdG9yICh5bWFwLCB0cmFuc2FjdGlvbiwgc3Vicykge1xuICAgIHN1cGVyKHltYXAsIHRyYW5zYWN0aW9uKVxuICAgIHRoaXMua2V5c0NoYW5nZWQgPSBzdWJzXG4gIH1cbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgTWFwVHlwZVxuICogQSBzaGFyZWQgTWFwIGltcGxlbWVudGF0aW9uLlxuICpcbiAqIEBleHRlbmRzIEFic3RyYWN0VHlwZTxZTWFwRXZlbnQ8TWFwVHlwZT4+XG4gKiBAaW1wbGVtZW50cyB7SXRlcmFibGU8TWFwVHlwZT59XG4gKi9cbmV4cG9ydCBjbGFzcyBZTWFwIGV4dGVuZHMgQWJzdHJhY3RUeXBlIHtcbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7SXRlcmFibGU8cmVhZG9ubHkgW3N0cmluZywgYW55XT49fSBlbnRyaWVzIC0gYW4gb3B0aW9uYWwgaXRlcmFibGUgdG8gaW5pdGlhbGl6ZSB0aGUgWU1hcFxuICAgKi9cbiAgY29uc3RydWN0b3IgKGVudHJpZXMpIHtcbiAgICBzdXBlcigpXG4gICAgLyoqXG4gICAgICogQHR5cGUge01hcDxzdHJpbmcsYW55Pj99XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9wcmVsaW1Db250ZW50ID0gbnVsbFxuXG4gICAgaWYgKGVudHJpZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5fcHJlbGltQ29udGVudCA9IG5ldyBNYXAoKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9wcmVsaW1Db250ZW50ID0gbmV3IE1hcChlbnRyaWVzKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbnRlZ3JhdGUgdGhpcyB0eXBlIGludG8gdGhlIFlqcyBpbnN0YW5jZS5cbiAgICpcbiAgICogKiBTYXZlIHRoaXMgc3RydWN0IGluIHRoZSBvc1xuICAgKiAqIFRoaXMgdHlwZSBpcyBzZW50IHRvIG90aGVyIGNsaWVudFxuICAgKiAqIE9ic2VydmVyIGZ1bmN0aW9ucyBhcmUgZmlyZWRcbiAgICpcbiAgICogQHBhcmFtIHtEb2N9IHkgVGhlIFlqcyBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge0l0ZW19IGl0ZW1cbiAgICovXG4gIF9pbnRlZ3JhdGUgKHksIGl0ZW0pIHtcbiAgICBzdXBlci5faW50ZWdyYXRlKHksIGl0ZW0pXG4gICAgOy8qKiBAdHlwZSB7TWFwPHN0cmluZywgYW55Pn0gKi8gKHRoaXMuX3ByZWxpbUNvbnRlbnQpLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgIHRoaXMuc2V0KGtleSwgdmFsdWUpXG4gICAgfSlcbiAgICB0aGlzLl9wcmVsaW1Db250ZW50ID0gbnVsbFxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge1lNYXA8TWFwVHlwZT59XG4gICAqL1xuICBfY29weSAoKSB7XG4gICAgcmV0dXJuIG5ldyBZTWFwKClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtZTWFwPE1hcFR5cGU+fVxuICAgKi9cbiAgY2xvbmUgKCkge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtZTWFwPE1hcFR5cGU+fVxuICAgICAqL1xuICAgIGNvbnN0IG1hcCA9IG5ldyBZTWFwKClcbiAgICB0aGlzLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgIG1hcC5zZXQoa2V5LCB2YWx1ZSBpbnN0YW5jZW9mIEFic3RyYWN0VHlwZSA/IC8qKiBAdHlwZSB7dHlwZW9mIHZhbHVlfSAqLyAodmFsdWUuY2xvbmUoKSkgOiB2YWx1ZSlcbiAgICB9KVxuICAgIHJldHVybiBtYXBcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIFlNYXBFdmVudCBhbmQgY2FsbHMgb2JzZXJ2ZXJzLlxuICAgKlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge1NldDxudWxsfHN0cmluZz59IHBhcmVudFN1YnMgS2V5cyBjaGFuZ2VkIG9uIHRoaXMgdHlwZS4gYG51bGxgIGlmIGxpc3Qgd2FzIG1vZGlmaWVkLlxuICAgKi9cbiAgX2NhbGxPYnNlcnZlciAodHJhbnNhY3Rpb24sIHBhcmVudFN1YnMpIHtcbiAgICBjYWxsVHlwZU9ic2VydmVycyh0aGlzLCB0cmFuc2FjdGlvbiwgbmV3IFlNYXBFdmVudCh0aGlzLCB0cmFuc2FjdGlvbiwgcGFyZW50U3VicykpXG4gIH1cblxuICAvKipcbiAgICogVHJhbnNmb3JtcyB0aGlzIFNoYXJlZCBUeXBlIHRvIGEgSlNPTiBvYmplY3QuXG4gICAqXG4gICAqIEByZXR1cm4ge09iamVjdDxzdHJpbmcsYW55Pn1cbiAgICovXG4gIHRvSlNPTiAoKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge09iamVjdDxzdHJpbmcsTWFwVHlwZT59XG4gICAgICovXG4gICAgY29uc3QgbWFwID0ge31cbiAgICB0aGlzLl9tYXAuZm9yRWFjaCgoaXRlbSwga2V5KSA9PiB7XG4gICAgICBpZiAoIWl0ZW0uZGVsZXRlZCkge1xuICAgICAgICBjb25zdCB2ID0gaXRlbS5jb250ZW50LmdldENvbnRlbnQoKVtpdGVtLmxlbmd0aCAtIDFdXG4gICAgICAgIG1hcFtrZXldID0gdiBpbnN0YW5jZW9mIEFic3RyYWN0VHlwZSA/IHYudG9KU09OKCkgOiB2XG4gICAgICB9XG4gICAgfSlcbiAgICByZXR1cm4gbWFwXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc2l6ZSBvZiB0aGUgWU1hcCAoY291bnQgb2Yga2V5L3ZhbHVlIHBhaXJzKVxuICAgKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgc2l6ZSAoKSB7XG4gICAgcmV0dXJuIFsuLi5jcmVhdGVNYXBJdGVyYXRvcih0aGlzLl9tYXApXS5sZW5ndGhcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBrZXlzIGZvciBlYWNoIGVsZW1lbnQgaW4gdGhlIFlNYXAgVHlwZS5cbiAgICpcbiAgICogQHJldHVybiB7SXRlcmFibGVJdGVyYXRvcjxzdHJpbmc+fVxuICAgKi9cbiAga2V5cyAoKSB7XG4gICAgcmV0dXJuIGl0ZXJhdG9yLml0ZXJhdG9yTWFwKGNyZWF0ZU1hcEl0ZXJhdG9yKHRoaXMuX21hcCksIC8qKiBAcGFyYW0ge2FueX0gdiAqLyB2ID0+IHZbMF0pXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdmFsdWVzIGZvciBlYWNoIGVsZW1lbnQgaW4gdGhlIFlNYXAgVHlwZS5cbiAgICpcbiAgICogQHJldHVybiB7SXRlcmFibGVJdGVyYXRvcjxhbnk+fVxuICAgKi9cbiAgdmFsdWVzICgpIHtcbiAgICByZXR1cm4gaXRlcmF0b3IuaXRlcmF0b3JNYXAoY3JlYXRlTWFwSXRlcmF0b3IodGhpcy5fbWFwKSwgLyoqIEBwYXJhbSB7YW55fSB2ICovIHYgPT4gdlsxXS5jb250ZW50LmdldENvbnRlbnQoKVt2WzFdLmxlbmd0aCAtIDFdKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gSXRlcmF0b3Igb2YgW2tleSwgdmFsdWVdIHBhaXJzXG4gICAqXG4gICAqIEByZXR1cm4ge0l0ZXJhYmxlSXRlcmF0b3I8YW55Pn1cbiAgICovXG4gIGVudHJpZXMgKCkge1xuICAgIHJldHVybiBpdGVyYXRvci5pdGVyYXRvck1hcChjcmVhdGVNYXBJdGVyYXRvcih0aGlzLl9tYXApLCAvKiogQHBhcmFtIHthbnl9IHYgKi8gdiA9PiBbdlswXSwgdlsxXS5jb250ZW50LmdldENvbnRlbnQoKVt2WzFdLmxlbmd0aCAtIDFdXSlcbiAgfVxuXG4gIC8qKlxuICAgKiBFeGVjdXRlcyBhIHByb3ZpZGVkIGZ1bmN0aW9uIG9uIG9uY2Ugb24gZXZlcnkga2V5LXZhbHVlIHBhaXIuXG4gICAqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oTWFwVHlwZSxzdHJpbmcsWU1hcDxNYXBUeXBlPik6dm9pZH0gZiBBIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgb24gZXZlcnkgZWxlbWVudCBvZiB0aGlzIFlBcnJheS5cbiAgICovXG4gIGZvckVhY2ggKGYpIHtcbiAgICB0aGlzLl9tYXAuZm9yRWFjaCgoaXRlbSwga2V5KSA9PiB7XG4gICAgICBpZiAoIWl0ZW0uZGVsZXRlZCkge1xuICAgICAgICBmKGl0ZW0uY29udGVudC5nZXRDb250ZW50KClbaXRlbS5sZW5ndGggLSAxXSwga2V5LCB0aGlzKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBJdGVyYXRvciBvZiBba2V5LCB2YWx1ZV0gcGFpcnNcbiAgICpcbiAgICogQHJldHVybiB7SXRlcmFibGVJdGVyYXRvcjxhbnk+fVxuICAgKi9cbiAgW1N5bWJvbC5pdGVyYXRvcl0gKCkge1xuICAgIHJldHVybiB0aGlzLmVudHJpZXMoKVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhIHNwZWNpZmllZCBlbGVtZW50IGZyb20gdGhpcyBZTWFwLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVsZW1lbnQgdG8gcmVtb3ZlLlxuICAgKi9cbiAgZGVsZXRlIChrZXkpIHtcbiAgICBpZiAodGhpcy5kb2MgIT09IG51bGwpIHtcbiAgICAgIHRyYW5zYWN0KHRoaXMuZG9jLCB0cmFuc2FjdGlvbiA9PiB7XG4gICAgICAgIHR5cGVNYXBEZWxldGUodHJhbnNhY3Rpb24sIHRoaXMsIGtleSlcbiAgICAgIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIC8qKiBAdHlwZSB7TWFwPHN0cmluZywgYW55Pn0gKi8gKHRoaXMuX3ByZWxpbUNvbnRlbnQpLmRlbGV0ZShrZXkpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgb3IgdXBkYXRlcyBhbiBlbGVtZW50IHdpdGggYSBzcGVjaWZpZWQga2V5IGFuZCB2YWx1ZS5cbiAgICogQHRlbXBsYXRlIHtNYXBUeXBlfSBWQUxcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbGVtZW50IHRvIGFkZCB0byB0aGlzIFlNYXBcbiAgICogQHBhcmFtIHtWQUx9IHZhbHVlIFRoZSB2YWx1ZSBvZiB0aGUgZWxlbWVudCB0byBhZGRcbiAgICogQHJldHVybiB7VkFMfVxuICAgKi9cbiAgc2V0IChrZXksIHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuZG9jICE9PSBudWxsKSB7XG4gICAgICB0cmFuc2FjdCh0aGlzLmRvYywgdHJhbnNhY3Rpb24gPT4ge1xuICAgICAgICB0eXBlTWFwU2V0KHRyYW5zYWN0aW9uLCB0aGlzLCBrZXksIC8qKiBAdHlwZSB7YW55fSAqLyAodmFsdWUpKVxuICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgLyoqIEB0eXBlIHtNYXA8c3RyaW5nLCBhbnk+fSAqLyAodGhpcy5fcHJlbGltQ29udGVudCkuc2V0KGtleSwgdmFsdWUpXG4gICAgfVxuICAgIHJldHVybiB2YWx1ZVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzcGVjaWZpZWQgZWxlbWVudCBmcm9tIHRoaXMgWU1hcC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgKiBAcmV0dXJuIHtNYXBUeXBlfHVuZGVmaW5lZH1cbiAgICovXG4gIGdldCAoa2V5KSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7YW55fSAqLyAodHlwZU1hcEdldCh0aGlzLCBrZXkpKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgc3BlY2lmaWVkIGtleSBleGlzdHMgb3Igbm90LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgdG8gdGVzdC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGhhcyAoa2V5KSB7XG4gICAgcmV0dXJuIHR5cGVNYXBIYXModGhpcywga2V5KVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYWxsIGVsZW1lbnRzIGZyb20gdGhpcyBZTWFwLlxuICAgKi9cbiAgY2xlYXIgKCkge1xuICAgIGlmICh0aGlzLmRvYyAhPT0gbnVsbCkge1xuICAgICAgdHJhbnNhY3QodGhpcy5kb2MsIHRyYW5zYWN0aW9uID0+IHtcbiAgICAgICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uIChfdmFsdWUsIGtleSwgbWFwKSB7XG4gICAgICAgICAgdHlwZU1hcERlbGV0ZSh0cmFuc2FjdGlvbiwgbWFwLCBrZXkpXG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH0gZWxzZSB7XG4gICAgICAvKiogQHR5cGUge01hcDxzdHJpbmcsIGFueT59ICovICh0aGlzLl9wcmVsaW1Db250ZW50KS5jbGVhcigpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VXBkYXRlRW5jb2RlclYxIHwgVXBkYXRlRW5jb2RlclYyfSBlbmNvZGVyXG4gICAqL1xuICBfd3JpdGUgKGVuY29kZXIpIHtcbiAgICBlbmNvZGVyLndyaXRlVHlwZVJlZihZTWFwUmVmSUQpXG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1VwZGF0ZURlY29kZXJWMSB8IFVwZGF0ZURlY29kZXJWMn0gX2RlY29kZXJcbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCByZWFkWU1hcCA9IF9kZWNvZGVyID0+IG5ldyBZTWFwKClcbiIsICJcbi8qKlxuICogQG1vZHVsZSBZVGV4dFxuICovXG5cbmltcG9ydCB7XG4gIFlFdmVudCxcbiAgQWJzdHJhY3RUeXBlLFxuICBnZXRJdGVtQ2xlYW5TdGFydCxcbiAgZ2V0U3RhdGUsXG4gIGlzVmlzaWJsZSxcbiAgY3JlYXRlSUQsXG4gIFlUZXh0UmVmSUQsXG4gIGNhbGxUeXBlT2JzZXJ2ZXJzLFxuICB0cmFuc2FjdCxcbiAgQ29udGVudEVtYmVkLFxuICBHQyxcbiAgQ29udGVudEZvcm1hdCxcbiAgQ29udGVudFN0cmluZyxcbiAgc3BsaXRTbmFwc2hvdEFmZmVjdGVkU3RydWN0cyxcbiAgaXRlcmF0ZURlbGV0ZWRTdHJ1Y3RzLFxuICBpdGVyYXRlU3RydWN0cyxcbiAgZmluZE1hcmtlcixcbiAgdHlwZU1hcERlbGV0ZSxcbiAgdHlwZU1hcFNldCxcbiAgdHlwZU1hcEdldCxcbiAgdHlwZU1hcEdldEFsbCxcbiAgdXBkYXRlTWFya2VyQ2hhbmdlcyxcbiAgQ29udGVudFR5cGUsXG4gIEFycmF5U2VhcmNoTWFya2VyLCBVcGRhdGVEZWNvZGVyVjEsIFVwZGF0ZURlY29kZXJWMiwgVXBkYXRlRW5jb2RlclYxLCBVcGRhdGVFbmNvZGVyVjIsIElELCBEb2MsIEl0ZW0sIFNuYXBzaG90LCBUcmFuc2FjdGlvbiAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG59IGZyb20gJy4uL2ludGVybmFscy5qcydcblxuaW1wb3J0ICogYXMgb2JqZWN0IGZyb20gJ2xpYjAvb2JqZWN0J1xuaW1wb3J0ICogYXMgbWFwIGZyb20gJ2xpYjAvbWFwJ1xuaW1wb3J0ICogYXMgZXJyb3IgZnJvbSAnbGliMC9lcnJvcidcblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gYVxuICogQHBhcmFtIHthbnl9IGJcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmNvbnN0IGVxdWFsQXR0cnMgPSAoYSwgYikgPT4gYSA9PT0gYiB8fCAodHlwZW9mIGEgPT09ICdvYmplY3QnICYmIHR5cGVvZiBiID09PSAnb2JqZWN0JyAmJiBhICYmIGIgJiYgb2JqZWN0LmVxdWFsRmxhdChhLCBiKSlcblxuZXhwb3J0IGNsYXNzIEl0ZW1UZXh0TGlzdFBvc2l0aW9uIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7SXRlbXxudWxsfSBsZWZ0XG4gICAqIEBwYXJhbSB7SXRlbXxudWxsfSByaWdodFxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAgICogQHBhcmFtIHtNYXA8c3RyaW5nLGFueT59IGN1cnJlbnRBdHRyaWJ1dGVzXG4gICAqL1xuICBjb25zdHJ1Y3RvciAobGVmdCwgcmlnaHQsIGluZGV4LCBjdXJyZW50QXR0cmlidXRlcykge1xuICAgIHRoaXMubGVmdCA9IGxlZnRcbiAgICB0aGlzLnJpZ2h0ID0gcmlnaHRcbiAgICB0aGlzLmluZGV4ID0gaW5kZXhcbiAgICB0aGlzLmN1cnJlbnRBdHRyaWJ1dGVzID0gY3VycmVudEF0dHJpYnV0ZXNcbiAgfVxuXG4gIC8qKlxuICAgKiBPbmx5IGNhbGwgdGhpcyBpZiB5b3Uga25vdyB0aGF0IHRoaXMucmlnaHQgaXMgZGVmaW5lZFxuICAgKi9cbiAgZm9yd2FyZCAoKSB7XG4gICAgaWYgKHRoaXMucmlnaHQgPT09IG51bGwpIHtcbiAgICAgIGVycm9yLnVuZXhwZWN0ZWRDYXNlKClcbiAgICB9XG4gICAgc3dpdGNoICh0aGlzLnJpZ2h0LmNvbnRlbnQuY29uc3RydWN0b3IpIHtcbiAgICAgIGNhc2UgQ29udGVudEZvcm1hdDpcbiAgICAgICAgaWYgKCF0aGlzLnJpZ2h0LmRlbGV0ZWQpIHtcbiAgICAgICAgICB1cGRhdGVDdXJyZW50QXR0cmlidXRlcyh0aGlzLmN1cnJlbnRBdHRyaWJ1dGVzLCAvKiogQHR5cGUge0NvbnRlbnRGb3JtYXR9ICovICh0aGlzLnJpZ2h0LmNvbnRlbnQpKVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAoIXRoaXMucmlnaHQuZGVsZXRlZCkge1xuICAgICAgICAgIHRoaXMuaW5kZXggKz0gdGhpcy5yaWdodC5sZW5ndGhcbiAgICAgICAgfVxuICAgICAgICBicmVha1xuICAgIH1cbiAgICB0aGlzLmxlZnQgPSB0aGlzLnJpZ2h0XG4gICAgdGhpcy5yaWdodCA9IHRoaXMucmlnaHQucmlnaHRcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge0l0ZW1UZXh0TGlzdFBvc2l0aW9ufSBwb3NcbiAqIEBwYXJhbSB7bnVtYmVyfSBjb3VudCBzdGVwcyB0byBtb3ZlIGZvcndhcmRcbiAqIEByZXR1cm4ge0l0ZW1UZXh0TGlzdFBvc2l0aW9ufVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgZmluZE5leHRQb3NpdGlvbiA9ICh0cmFuc2FjdGlvbiwgcG9zLCBjb3VudCkgPT4ge1xuICB3aGlsZSAocG9zLnJpZ2h0ICE9PSBudWxsICYmIGNvdW50ID4gMCkge1xuICAgIHN3aXRjaCAocG9zLnJpZ2h0LmNvbnRlbnQuY29uc3RydWN0b3IpIHtcbiAgICAgIGNhc2UgQ29udGVudEZvcm1hdDpcbiAgICAgICAgaWYgKCFwb3MucmlnaHQuZGVsZXRlZCkge1xuICAgICAgICAgIHVwZGF0ZUN1cnJlbnRBdHRyaWJ1dGVzKHBvcy5jdXJyZW50QXR0cmlidXRlcywgLyoqIEB0eXBlIHtDb250ZW50Rm9ybWF0fSAqLyAocG9zLnJpZ2h0LmNvbnRlbnQpKVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAoIXBvcy5yaWdodC5kZWxldGVkKSB7XG4gICAgICAgICAgaWYgKGNvdW50IDwgcG9zLnJpZ2h0Lmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gc3BsaXQgcmlnaHRcbiAgICAgICAgICAgIGdldEl0ZW1DbGVhblN0YXJ0KHRyYW5zYWN0aW9uLCBjcmVhdGVJRChwb3MucmlnaHQuaWQuY2xpZW50LCBwb3MucmlnaHQuaWQuY2xvY2sgKyBjb3VudCkpXG4gICAgICAgICAgfVxuICAgICAgICAgIHBvcy5pbmRleCArPSBwb3MucmlnaHQubGVuZ3RoXG4gICAgICAgICAgY291bnQgLT0gcG9zLnJpZ2h0Lmxlbmd0aFxuICAgICAgICB9XG4gICAgICAgIGJyZWFrXG4gICAgfVxuICAgIHBvcy5sZWZ0ID0gcG9zLnJpZ2h0XG4gICAgcG9zLnJpZ2h0ID0gcG9zLnJpZ2h0LnJpZ2h0XG4gICAgLy8gcG9zLmZvcndhcmQoKSAtIHdlIGRvbid0IGZvcndhcmQgYmVjYXVzZSB0aGF0IHdvdWxkIGhhbHZlIHRoZSBwZXJmb3JtYW5jZSBiZWNhdXNlIHdlIGFscmVhZHkgZG8gdGhlIGNoZWNrcyBhYm92ZVxuICB9XG4gIHJldHVybiBwb3Ncbn1cblxuLyoqXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0gcGFyZW50XG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAqIEByZXR1cm4ge0l0ZW1UZXh0TGlzdFBvc2l0aW9ufVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgZmluZFBvc2l0aW9uID0gKHRyYW5zYWN0aW9uLCBwYXJlbnQsIGluZGV4KSA9PiB7XG4gIGNvbnN0IGN1cnJlbnRBdHRyaWJ1dGVzID0gbmV3IE1hcCgpXG4gIGNvbnN0IG1hcmtlciA9IGZpbmRNYXJrZXIocGFyZW50LCBpbmRleClcbiAgaWYgKG1hcmtlcikge1xuICAgIGNvbnN0IHBvcyA9IG5ldyBJdGVtVGV4dExpc3RQb3NpdGlvbihtYXJrZXIucC5sZWZ0LCBtYXJrZXIucCwgbWFya2VyLmluZGV4LCBjdXJyZW50QXR0cmlidXRlcylcbiAgICByZXR1cm4gZmluZE5leHRQb3NpdGlvbih0cmFuc2FjdGlvbiwgcG9zLCBpbmRleCAtIG1hcmtlci5pbmRleClcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBwb3MgPSBuZXcgSXRlbVRleHRMaXN0UG9zaXRpb24obnVsbCwgcGFyZW50Ll9zdGFydCwgMCwgY3VycmVudEF0dHJpYnV0ZXMpXG4gICAgcmV0dXJuIGZpbmROZXh0UG9zaXRpb24odHJhbnNhY3Rpb24sIHBvcywgaW5kZXgpXG4gIH1cbn1cblxuLyoqXG4gKiBOZWdhdGUgYXBwbGllZCBmb3JtYXRzXG4gKlxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPGFueT59IHBhcmVudFxuICogQHBhcmFtIHtJdGVtVGV4dExpc3RQb3NpdGlvbn0gY3VyclBvc1xuICogQHBhcmFtIHtNYXA8c3RyaW5nLGFueT59IG5lZ2F0ZWRBdHRyaWJ1dGVzXG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBpbnNlcnROZWdhdGVkQXR0cmlidXRlcyA9ICh0cmFuc2FjdGlvbiwgcGFyZW50LCBjdXJyUG9zLCBuZWdhdGVkQXR0cmlidXRlcykgPT4ge1xuICAvLyBjaGVjayBpZiB3ZSByZWFsbHkgbmVlZCB0byByZW1vdmUgYXR0cmlidXRlc1xuICB3aGlsZSAoXG4gICAgY3VyclBvcy5yaWdodCAhPT0gbnVsbCAmJiAoXG4gICAgICBjdXJyUG9zLnJpZ2h0LmRlbGV0ZWQgPT09IHRydWUgfHwgKFxuICAgICAgICBjdXJyUG9zLnJpZ2h0LmNvbnRlbnQuY29uc3RydWN0b3IgPT09IENvbnRlbnRGb3JtYXQgJiZcbiAgICAgICAgZXF1YWxBdHRycyhuZWdhdGVkQXR0cmlidXRlcy5nZXQoLyoqIEB0eXBlIHtDb250ZW50Rm9ybWF0fSAqLyAoY3VyclBvcy5yaWdodC5jb250ZW50KS5rZXkpLCAvKiogQHR5cGUge0NvbnRlbnRGb3JtYXR9ICovIChjdXJyUG9zLnJpZ2h0LmNvbnRlbnQpLnZhbHVlKVxuICAgICAgKVxuICAgIClcbiAgKSB7XG4gICAgaWYgKCFjdXJyUG9zLnJpZ2h0LmRlbGV0ZWQpIHtcbiAgICAgIG5lZ2F0ZWRBdHRyaWJ1dGVzLmRlbGV0ZSgvKiogQHR5cGUge0NvbnRlbnRGb3JtYXR9ICovIChjdXJyUG9zLnJpZ2h0LmNvbnRlbnQpLmtleSlcbiAgICB9XG4gICAgY3VyclBvcy5mb3J3YXJkKClcbiAgfVxuICBjb25zdCBkb2MgPSB0cmFuc2FjdGlvbi5kb2NcbiAgY29uc3Qgb3duQ2xpZW50SWQgPSBkb2MuY2xpZW50SURcbiAgbmVnYXRlZEF0dHJpYnV0ZXMuZm9yRWFjaCgodmFsLCBrZXkpID0+IHtcbiAgICBjb25zdCBsZWZ0ID0gY3VyclBvcy5sZWZ0XG4gICAgY29uc3QgcmlnaHQgPSBjdXJyUG9zLnJpZ2h0XG4gICAgY29uc3QgbmV4dEZvcm1hdCA9IG5ldyBJdGVtKGNyZWF0ZUlEKG93bkNsaWVudElkLCBnZXRTdGF0ZShkb2Muc3RvcmUsIG93bkNsaWVudElkKSksIGxlZnQsIGxlZnQgJiYgbGVmdC5sYXN0SWQsIHJpZ2h0LCByaWdodCAmJiByaWdodC5pZCwgcGFyZW50LCBudWxsLCBuZXcgQ29udGVudEZvcm1hdChrZXksIHZhbCkpXG4gICAgbmV4dEZvcm1hdC5pbnRlZ3JhdGUodHJhbnNhY3Rpb24sIDApXG4gICAgY3VyclBvcy5yaWdodCA9IG5leHRGb3JtYXRcbiAgICBjdXJyUG9zLmZvcndhcmQoKVxuICB9KVxufVxuXG4vKipcbiAqIEBwYXJhbSB7TWFwPHN0cmluZyxhbnk+fSBjdXJyZW50QXR0cmlidXRlc1xuICogQHBhcmFtIHtDb250ZW50Rm9ybWF0fSBmb3JtYXRcbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IHVwZGF0ZUN1cnJlbnRBdHRyaWJ1dGVzID0gKGN1cnJlbnRBdHRyaWJ1dGVzLCBmb3JtYXQpID0+IHtcbiAgY29uc3QgeyBrZXksIHZhbHVlIH0gPSBmb3JtYXRcbiAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgY3VycmVudEF0dHJpYnV0ZXMuZGVsZXRlKGtleSlcbiAgfSBlbHNlIHtcbiAgICBjdXJyZW50QXR0cmlidXRlcy5zZXQoa2V5LCB2YWx1ZSlcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7SXRlbVRleHRMaXN0UG9zaXRpb259IGN1cnJQb3NcbiAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZyxhbnk+fSBhdHRyaWJ1dGVzXG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBtaW5pbWl6ZUF0dHJpYnV0ZUNoYW5nZXMgPSAoY3VyclBvcywgYXR0cmlidXRlcykgPT4ge1xuICAvLyBnbyByaWdodCB3aGlsZSBhdHRyaWJ1dGVzW3JpZ2h0LmtleV0gPT09IHJpZ2h0LnZhbHVlIChvciByaWdodCBpcyBkZWxldGVkKVxuICB3aGlsZSAodHJ1ZSkge1xuICAgIGlmIChjdXJyUG9zLnJpZ2h0ID09PSBudWxsKSB7XG4gICAgICBicmVha1xuICAgIH0gZWxzZSBpZiAoY3VyclBvcy5yaWdodC5kZWxldGVkIHx8IChjdXJyUG9zLnJpZ2h0LmNvbnRlbnQuY29uc3RydWN0b3IgPT09IENvbnRlbnRGb3JtYXQgJiYgZXF1YWxBdHRycyhhdHRyaWJ1dGVzWygvKiogQHR5cGUge0NvbnRlbnRGb3JtYXR9ICovIChjdXJyUG9zLnJpZ2h0LmNvbnRlbnQpKS5rZXldIHx8IG51bGwsIC8qKiBAdHlwZSB7Q29udGVudEZvcm1hdH0gKi8gKGN1cnJQb3MucmlnaHQuY29udGVudCkudmFsdWUpKSkge1xuICAgICAgLy9cbiAgICB9IGVsc2Uge1xuICAgICAgYnJlYWtcbiAgICB9XG4gICAgY3VyclBvcy5mb3J3YXJkKClcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxhbnk+fSBwYXJlbnRcbiAqIEBwYXJhbSB7SXRlbVRleHRMaXN0UG9zaXRpb259IGN1cnJQb3NcbiAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZyxhbnk+fSBhdHRyaWJ1dGVzXG4gKiBAcmV0dXJuIHtNYXA8c3RyaW5nLGFueT59XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICoqL1xuY29uc3QgaW5zZXJ0QXR0cmlidXRlcyA9ICh0cmFuc2FjdGlvbiwgcGFyZW50LCBjdXJyUG9zLCBhdHRyaWJ1dGVzKSA9PiB7XG4gIGNvbnN0IGRvYyA9IHRyYW5zYWN0aW9uLmRvY1xuICBjb25zdCBvd25DbGllbnRJZCA9IGRvYy5jbGllbnRJRFxuICBjb25zdCBuZWdhdGVkQXR0cmlidXRlcyA9IG5ldyBNYXAoKVxuICAvLyBpbnNlcnQgZm9ybWF0LXN0YXJ0IGl0ZW1zXG4gIGZvciAoY29uc3Qga2V5IGluIGF0dHJpYnV0ZXMpIHtcbiAgICBjb25zdCB2YWwgPSBhdHRyaWJ1dGVzW2tleV1cbiAgICBjb25zdCBjdXJyZW50VmFsID0gY3VyclBvcy5jdXJyZW50QXR0cmlidXRlcy5nZXQoa2V5KSB8fCBudWxsXG4gICAgaWYgKCFlcXVhbEF0dHJzKGN1cnJlbnRWYWwsIHZhbCkpIHtcbiAgICAgIC8vIHNhdmUgbmVnYXRlZCBhdHRyaWJ1dGUgKHNldCBudWxsIGlmIGN1cnJlbnRWYWwgdW5kZWZpbmVkKVxuICAgICAgbmVnYXRlZEF0dHJpYnV0ZXMuc2V0KGtleSwgY3VycmVudFZhbClcbiAgICAgIGNvbnN0IHsgbGVmdCwgcmlnaHQgfSA9IGN1cnJQb3NcbiAgICAgIGN1cnJQb3MucmlnaHQgPSBuZXcgSXRlbShjcmVhdGVJRChvd25DbGllbnRJZCwgZ2V0U3RhdGUoZG9jLnN0b3JlLCBvd25DbGllbnRJZCkpLCBsZWZ0LCBsZWZ0ICYmIGxlZnQubGFzdElkLCByaWdodCwgcmlnaHQgJiYgcmlnaHQuaWQsIHBhcmVudCwgbnVsbCwgbmV3IENvbnRlbnRGb3JtYXQoa2V5LCB2YWwpKVxuICAgICAgY3VyclBvcy5yaWdodC5pbnRlZ3JhdGUodHJhbnNhY3Rpb24sIDApXG4gICAgICBjdXJyUG9zLmZvcndhcmQoKVxuICAgIH1cbiAgfVxuICByZXR1cm4gbmVnYXRlZEF0dHJpYnV0ZXNcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0gcGFyZW50XG4gKiBAcGFyYW0ge0l0ZW1UZXh0TGlzdFBvc2l0aW9ufSBjdXJyUG9zXG4gKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R8QWJzdHJhY3RUeXBlPGFueT59IHRleHRcbiAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZyxhbnk+fSBhdHRyaWJ1dGVzXG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICoqL1xuY29uc3QgaW5zZXJ0VGV4dCA9ICh0cmFuc2FjdGlvbiwgcGFyZW50LCBjdXJyUG9zLCB0ZXh0LCBhdHRyaWJ1dGVzKSA9PiB7XG4gIGN1cnJQb3MuY3VycmVudEF0dHJpYnV0ZXMuZm9yRWFjaCgoX3ZhbCwga2V5KSA9PiB7XG4gICAgaWYgKGF0dHJpYnV0ZXNba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBhdHRyaWJ1dGVzW2tleV0gPSBudWxsXG4gICAgfVxuICB9KVxuICBjb25zdCBkb2MgPSB0cmFuc2FjdGlvbi5kb2NcbiAgY29uc3Qgb3duQ2xpZW50SWQgPSBkb2MuY2xpZW50SURcbiAgbWluaW1pemVBdHRyaWJ1dGVDaGFuZ2VzKGN1cnJQb3MsIGF0dHJpYnV0ZXMpXG4gIGNvbnN0IG5lZ2F0ZWRBdHRyaWJ1dGVzID0gaW5zZXJ0QXR0cmlidXRlcyh0cmFuc2FjdGlvbiwgcGFyZW50LCBjdXJyUG9zLCBhdHRyaWJ1dGVzKVxuICAvLyBpbnNlcnQgY29udGVudFxuICBjb25zdCBjb250ZW50ID0gdGV4dC5jb25zdHJ1Y3RvciA9PT0gU3RyaW5nID8gbmV3IENvbnRlbnRTdHJpbmcoLyoqIEB0eXBlIHtzdHJpbmd9ICovICh0ZXh0KSkgOiAodGV4dCBpbnN0YW5jZW9mIEFic3RyYWN0VHlwZSA/IG5ldyBDb250ZW50VHlwZSh0ZXh0KSA6IG5ldyBDb250ZW50RW1iZWQodGV4dCkpXG4gIGxldCB7IGxlZnQsIHJpZ2h0LCBpbmRleCB9ID0gY3VyclBvc1xuICBpZiAocGFyZW50Ll9zZWFyY2hNYXJrZXIpIHtcbiAgICB1cGRhdGVNYXJrZXJDaGFuZ2VzKHBhcmVudC5fc2VhcmNoTWFya2VyLCBjdXJyUG9zLmluZGV4LCBjb250ZW50LmdldExlbmd0aCgpKVxuICB9XG4gIHJpZ2h0ID0gbmV3IEl0ZW0oY3JlYXRlSUQob3duQ2xpZW50SWQsIGdldFN0YXRlKGRvYy5zdG9yZSwgb3duQ2xpZW50SWQpKSwgbGVmdCwgbGVmdCAmJiBsZWZ0Lmxhc3RJZCwgcmlnaHQsIHJpZ2h0ICYmIHJpZ2h0LmlkLCBwYXJlbnQsIG51bGwsIGNvbnRlbnQpXG4gIHJpZ2h0LmludGVncmF0ZSh0cmFuc2FjdGlvbiwgMClcbiAgY3VyclBvcy5yaWdodCA9IHJpZ2h0XG4gIGN1cnJQb3MuaW5kZXggPSBpbmRleFxuICBjdXJyUG9zLmZvcndhcmQoKVxuICBpbnNlcnROZWdhdGVkQXR0cmlidXRlcyh0cmFuc2FjdGlvbiwgcGFyZW50LCBjdXJyUG9zLCBuZWdhdGVkQXR0cmlidXRlcylcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0gcGFyZW50XG4gKiBAcGFyYW0ge0l0ZW1UZXh0TGlzdFBvc2l0aW9ufSBjdXJyUG9zXG4gKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoXG4gKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsYW55Pn0gYXR0cmlidXRlc1xuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgZm9ybWF0VGV4dCA9ICh0cmFuc2FjdGlvbiwgcGFyZW50LCBjdXJyUG9zLCBsZW5ndGgsIGF0dHJpYnV0ZXMpID0+IHtcbiAgY29uc3QgZG9jID0gdHJhbnNhY3Rpb24uZG9jXG4gIGNvbnN0IG93bkNsaWVudElkID0gZG9jLmNsaWVudElEXG4gIG1pbmltaXplQXR0cmlidXRlQ2hhbmdlcyhjdXJyUG9zLCBhdHRyaWJ1dGVzKVxuICBjb25zdCBuZWdhdGVkQXR0cmlidXRlcyA9IGluc2VydEF0dHJpYnV0ZXModHJhbnNhY3Rpb24sIHBhcmVudCwgY3VyclBvcywgYXR0cmlidXRlcylcbiAgLy8gaXRlcmF0ZSB1bnRpbCBmaXJzdCBub24tZm9ybWF0IG9yIG51bGwgaXMgZm91bmRcbiAgLy8gZGVsZXRlIGFsbCBmb3JtYXRzIHdpdGggYXR0cmlidXRlc1tmb3JtYXQua2V5XSAhPSBudWxsXG4gIC8vIGFsc28gY2hlY2sgdGhlIGF0dHJpYnV0ZXMgYWZ0ZXIgdGhlIGZpcnN0IG5vbi1mb3JtYXQgYXMgd2UgZG8gbm90IHdhbnQgdG8gaW5zZXJ0IHJlZHVuZGFudCBuZWdhdGVkIGF0dHJpYnV0ZXMgdGhlcmVcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWxhYmVsc1xuICBpdGVyYXRpb25Mb29wOiB3aGlsZSAoXG4gICAgY3VyclBvcy5yaWdodCAhPT0gbnVsbCAmJlxuICAgIChsZW5ndGggPiAwIHx8XG4gICAgICAoXG4gICAgICAgIG5lZ2F0ZWRBdHRyaWJ1dGVzLnNpemUgPiAwICYmXG4gICAgICAgIChjdXJyUG9zLnJpZ2h0LmRlbGV0ZWQgfHwgY3VyclBvcy5yaWdodC5jb250ZW50LmNvbnN0cnVjdG9yID09PSBDb250ZW50Rm9ybWF0KVxuICAgICAgKVxuICAgIClcbiAgKSB7XG4gICAgaWYgKCFjdXJyUG9zLnJpZ2h0LmRlbGV0ZWQpIHtcbiAgICAgIHN3aXRjaCAoY3VyclBvcy5yaWdodC5jb250ZW50LmNvbnN0cnVjdG9yKSB7XG4gICAgICAgIGNhc2UgQ29udGVudEZvcm1hdDoge1xuICAgICAgICAgIGNvbnN0IHsga2V5LCB2YWx1ZSB9ID0gLyoqIEB0eXBlIHtDb250ZW50Rm9ybWF0fSAqLyAoY3VyclBvcy5yaWdodC5jb250ZW50KVxuICAgICAgICAgIGNvbnN0IGF0dHIgPSBhdHRyaWJ1dGVzW2tleV1cbiAgICAgICAgICBpZiAoYXR0ciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoZXF1YWxBdHRycyhhdHRyLCB2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgbmVnYXRlZEF0dHJpYnV0ZXMuZGVsZXRlKGtleSlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChsZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBubyBuZWVkIHRvIGZ1cnRoZXIgZXh0ZW5kIG5lZ2F0ZWRBdHRyaWJ1dGVzXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWxhYmVsc1xuICAgICAgICAgICAgICAgIGJyZWFrIGl0ZXJhdGlvbkxvb3BcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBuZWdhdGVkQXR0cmlidXRlcy5zZXQoa2V5LCB2YWx1ZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJQb3MucmlnaHQuZGVsZXRlKHRyYW5zYWN0aW9uKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjdXJyUG9zLmN1cnJlbnRBdHRyaWJ1dGVzLnNldChrZXksIHZhbHVlKVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaWYgKGxlbmd0aCA8IGN1cnJQb3MucmlnaHQubGVuZ3RoKSB7XG4gICAgICAgICAgICBnZXRJdGVtQ2xlYW5TdGFydCh0cmFuc2FjdGlvbiwgY3JlYXRlSUQoY3VyclBvcy5yaWdodC5pZC5jbGllbnQsIGN1cnJQb3MucmlnaHQuaWQuY2xvY2sgKyBsZW5ndGgpKVxuICAgICAgICAgIH1cbiAgICAgICAgICBsZW5ndGggLT0gY3VyclBvcy5yaWdodC5sZW5ndGhcbiAgICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgICBjdXJyUG9zLmZvcndhcmQoKVxuICB9XG4gIC8vIFF1aWxsIGp1c3QgYXNzdW1lcyB0aGF0IHRoZSBlZGl0b3Igc3RhcnRzIHdpdGggYSBuZXdsaW5lIGFuZCB0aGF0IGl0IGFsd2F5c1xuICAvLyBlbmRzIHdpdGggYSBuZXdsaW5lLiBXZSBvbmx5IGluc2VydCB0aGF0IG5ld2xpbmUgd2hlbiBhIG5ldyBuZXdsaW5lIGlzXG4gIC8vIGluc2VydGVkIC0gaS5lIHdoZW4gbGVuZ3RoIGlzIGJpZ2dlciB0aGFuIHR5cGUubGVuZ3RoXG4gIGlmIChsZW5ndGggPiAwKSB7XG4gICAgbGV0IG5ld2xpbmVzID0gJydcbiAgICBmb3IgKDsgbGVuZ3RoID4gMDsgbGVuZ3RoLS0pIHtcbiAgICAgIG5ld2xpbmVzICs9ICdcXG4nXG4gICAgfVxuICAgIGN1cnJQb3MucmlnaHQgPSBuZXcgSXRlbShjcmVhdGVJRChvd25DbGllbnRJZCwgZ2V0U3RhdGUoZG9jLnN0b3JlLCBvd25DbGllbnRJZCkpLCBjdXJyUG9zLmxlZnQsIGN1cnJQb3MubGVmdCAmJiBjdXJyUG9zLmxlZnQubGFzdElkLCBjdXJyUG9zLnJpZ2h0LCBjdXJyUG9zLnJpZ2h0ICYmIGN1cnJQb3MucmlnaHQuaWQsIHBhcmVudCwgbnVsbCwgbmV3IENvbnRlbnRTdHJpbmcobmV3bGluZXMpKVxuICAgIGN1cnJQb3MucmlnaHQuaW50ZWdyYXRlKHRyYW5zYWN0aW9uLCAwKVxuICAgIGN1cnJQb3MuZm9yd2FyZCgpXG4gIH1cbiAgaW5zZXJ0TmVnYXRlZEF0dHJpYnV0ZXModHJhbnNhY3Rpb24sIHBhcmVudCwgY3VyclBvcywgbmVnYXRlZEF0dHJpYnV0ZXMpXG59XG5cbi8qKlxuICogQ2FsbCB0aGlzIGZ1bmN0aW9uIGFmdGVyIHN0cmluZyBjb250ZW50IGhhcyBiZWVuIGRlbGV0ZWQgaW4gb3JkZXIgdG9cbiAqIGNsZWFuIHVwIGZvcm1hdHRpbmcgSXRlbXMuXG4gKlxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7SXRlbX0gc3RhcnRcbiAqIEBwYXJhbSB7SXRlbXxudWxsfSBjdXJyIGV4Y2x1c2l2ZSBlbmQsIGF1dG9tYXRpY2FsbHkgaXRlcmF0ZXMgdG8gdGhlIG5leHQgQ29udGVudCBJdGVtXG4gKiBAcGFyYW0ge01hcDxzdHJpbmcsYW55Pn0gc3RhcnRBdHRyaWJ1dGVzXG4gKiBAcGFyYW0ge01hcDxzdHJpbmcsYW55Pn0gY3VyckF0dHJpYnV0ZXNcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIGFtb3VudCBvZiBmb3JtYXR0aW5nIEl0ZW1zIGRlbGV0ZWQuXG4gKlxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IGNsZWFudXBGb3JtYXR0aW5nR2FwID0gKHRyYW5zYWN0aW9uLCBzdGFydCwgY3Vyciwgc3RhcnRBdHRyaWJ1dGVzLCBjdXJyQXR0cmlidXRlcykgPT4ge1xuICAvKipcbiAgICogQHR5cGUge0l0ZW18bnVsbH1cbiAgICovXG4gIGxldCBlbmQgPSBzdGFydFxuICAvKipcbiAgICogQHR5cGUge01hcDxzdHJpbmcsQ29udGVudEZvcm1hdD59XG4gICAqL1xuICBjb25zdCBlbmRGb3JtYXRzID0gbWFwLmNyZWF0ZSgpXG4gIHdoaWxlIChlbmQgJiYgKCFlbmQuY291bnRhYmxlIHx8IGVuZC5kZWxldGVkKSkge1xuICAgIGlmICghZW5kLmRlbGV0ZWQgJiYgZW5kLmNvbnRlbnQuY29uc3RydWN0b3IgPT09IENvbnRlbnRGb3JtYXQpIHtcbiAgICAgIGNvbnN0IGNmID0gLyoqIEB0eXBlIHtDb250ZW50Rm9ybWF0fSAqLyAoZW5kLmNvbnRlbnQpXG4gICAgICBlbmRGb3JtYXRzLnNldChjZi5rZXksIGNmKVxuICAgIH1cbiAgICBlbmQgPSBlbmQucmlnaHRcbiAgfVxuICBsZXQgY2xlYW51cHMgPSAwXG4gIGxldCByZWFjaGVkQ3VyciA9IGZhbHNlXG4gIHdoaWxlIChzdGFydCAhPT0gZW5kKSB7XG4gICAgaWYgKGN1cnIgPT09IHN0YXJ0KSB7XG4gICAgICByZWFjaGVkQ3VyciA9IHRydWVcbiAgICB9XG4gICAgaWYgKCFzdGFydC5kZWxldGVkKSB7XG4gICAgICBjb25zdCBjb250ZW50ID0gc3RhcnQuY29udGVudFxuICAgICAgc3dpdGNoIChjb250ZW50LmNvbnN0cnVjdG9yKSB7XG4gICAgICAgIGNhc2UgQ29udGVudEZvcm1hdDoge1xuICAgICAgICAgIGNvbnN0IHsga2V5LCB2YWx1ZSB9ID0gLyoqIEB0eXBlIHtDb250ZW50Rm9ybWF0fSAqLyAoY29udGVudClcbiAgICAgICAgICBjb25zdCBzdGFydEF0dHJWYWx1ZSA9IHN0YXJ0QXR0cmlidXRlcy5nZXQoa2V5KSB8fCBudWxsXG4gICAgICAgICAgaWYgKGVuZEZvcm1hdHMuZ2V0KGtleSkgIT09IGNvbnRlbnQgfHwgc3RhcnRBdHRyVmFsdWUgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAvLyBFaXRoZXIgdGhpcyBmb3JtYXQgaXMgb3ZlcndyaXR0ZW4gb3IgaXQgaXMgbm90IG5lY2Vzc2FyeSBiZWNhdXNlIHRoZSBhdHRyaWJ1dGUgYWxyZWFkeSBleGlzdGVkLlxuICAgICAgICAgICAgc3RhcnQuZGVsZXRlKHRyYW5zYWN0aW9uKVxuICAgICAgICAgICAgY2xlYW51cHMrK1xuICAgICAgICAgICAgaWYgKCFyZWFjaGVkQ3VyciAmJiAoY3VyckF0dHJpYnV0ZXMuZ2V0KGtleSkgfHwgbnVsbCkgPT09IHZhbHVlICYmIHN0YXJ0QXR0clZhbHVlICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgICBpZiAoc3RhcnRBdHRyVmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjdXJyQXR0cmlidXRlcy5kZWxldGUoa2V5KVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGN1cnJBdHRyaWJ1dGVzLnNldChrZXksIHN0YXJ0QXR0clZhbHVlKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghcmVhY2hlZEN1cnIgJiYgIXN0YXJ0LmRlbGV0ZWQpIHtcbiAgICAgICAgICAgIHVwZGF0ZUN1cnJlbnRBdHRyaWJ1dGVzKGN1cnJBdHRyaWJ1dGVzLCAvKiogQHR5cGUge0NvbnRlbnRGb3JtYXR9ICovIChjb250ZW50KSlcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBzdGFydCA9IC8qKiBAdHlwZSB7SXRlbX0gKi8gKHN0YXJ0LnJpZ2h0KVxuICB9XG4gIHJldHVybiBjbGVhbnVwc1xufVxuXG4vKipcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge0l0ZW0gfCBudWxsfSBpdGVtXG4gKi9cbmNvbnN0IGNsZWFudXBDb250ZXh0bGVzc0Zvcm1hdHRpbmdHYXAgPSAodHJhbnNhY3Rpb24sIGl0ZW0pID0+IHtcbiAgLy8gaXRlcmF0ZSB1bnRpbCBpdGVtLnJpZ2h0IGlzIG51bGwgb3IgY29udGVudFxuICB3aGlsZSAoaXRlbSAmJiBpdGVtLnJpZ2h0ICYmIChpdGVtLnJpZ2h0LmRlbGV0ZWQgfHwgIWl0ZW0ucmlnaHQuY291bnRhYmxlKSkge1xuICAgIGl0ZW0gPSBpdGVtLnJpZ2h0XG4gIH1cbiAgY29uc3QgYXR0cnMgPSBuZXcgU2V0KClcbiAgLy8gaXRlcmF0ZSBiYWNrIHVudGlsIGEgY29udGVudCBpdGVtIGlzIGZvdW5kXG4gIHdoaWxlIChpdGVtICYmIChpdGVtLmRlbGV0ZWQgfHwgIWl0ZW0uY291bnRhYmxlKSkge1xuICAgIGlmICghaXRlbS5kZWxldGVkICYmIGl0ZW0uY29udGVudC5jb25zdHJ1Y3RvciA9PT0gQ29udGVudEZvcm1hdCkge1xuICAgICAgY29uc3Qga2V5ID0gLyoqIEB0eXBlIHtDb250ZW50Rm9ybWF0fSAqLyAoaXRlbS5jb250ZW50KS5rZXlcbiAgICAgIGlmIChhdHRycy5oYXMoa2V5KSkge1xuICAgICAgICBpdGVtLmRlbGV0ZSh0cmFuc2FjdGlvbilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGF0dHJzLmFkZChrZXkpXG4gICAgICB9XG4gICAgfVxuICAgIGl0ZW0gPSBpdGVtLmxlZnRcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgZXhwZXJpbWVudGFsIGFuZCBzdWJqZWN0IHRvIGNoYW5nZSAvIGJlIHJlbW92ZWQuXG4gKlxuICogSWRlYWxseSwgd2UgZG9uJ3QgbmVlZCB0aGlzIGZ1bmN0aW9uIGF0IGFsbC4gRm9ybWF0dGluZyBhdHRyaWJ1dGVzIHNob3VsZCBiZSBjbGVhbmVkIHVwXG4gKiBhdXRvbWF0aWNhbGx5IGFmdGVyIGVhY2ggY2hhbmdlLiBUaGlzIGZ1bmN0aW9uIGl0ZXJhdGVzIHR3aWNlIG92ZXIgdGhlIGNvbXBsZXRlIFlUZXh0IHR5cGVcbiAqIGFuZCByZW1vdmVzIHVubmVjZXNzYXJ5IGZvcm1hdHRpbmcgYXR0cmlidXRlcy4gVGhpcyBpcyBhbHNvIGhlbHBmdWwgZm9yIHRlc3RpbmcuXG4gKlxuICogVGhpcyBmdW5jdGlvbiB3b24ndCBiZSBleHBvcnRlZCBhbnltb3JlIGFzIHNvb24gYXMgdGhlcmUgaXMgY29uZmlkZW5jZSB0aGF0IHRoZSBZVGV4dCB0eXBlIHdvcmtzIGFzIGludGVuZGVkLlxuICpcbiAqIEBwYXJhbSB7WVRleHR9IHR5cGVcbiAqIEByZXR1cm4ge251bWJlcn0gSG93IG1hbnkgZm9ybWF0dGluZyBhdHRyaWJ1dGVzIGhhdmUgYmVlbiBjbGVhbmVkIHVwLlxuICovXG5leHBvcnQgY29uc3QgY2xlYW51cFlUZXh0Rm9ybWF0dGluZyA9IHR5cGUgPT4ge1xuICBsZXQgcmVzID0gMFxuICB0cmFuc2FjdCgvKiogQHR5cGUge0RvY30gKi8gKHR5cGUuZG9jKSwgdHJhbnNhY3Rpb24gPT4ge1xuICAgIGxldCBzdGFydCA9IC8qKiBAdHlwZSB7SXRlbX0gKi8gKHR5cGUuX3N0YXJ0KVxuICAgIGxldCBlbmQgPSB0eXBlLl9zdGFydFxuICAgIGxldCBzdGFydEF0dHJpYnV0ZXMgPSBtYXAuY3JlYXRlKClcbiAgICBjb25zdCBjdXJyZW50QXR0cmlidXRlcyA9IG1hcC5jb3B5KHN0YXJ0QXR0cmlidXRlcylcbiAgICB3aGlsZSAoZW5kKSB7XG4gICAgICBpZiAoZW5kLmRlbGV0ZWQgPT09IGZhbHNlKSB7XG4gICAgICAgIHN3aXRjaCAoZW5kLmNvbnRlbnQuY29uc3RydWN0b3IpIHtcbiAgICAgICAgICBjYXNlIENvbnRlbnRGb3JtYXQ6XG4gICAgICAgICAgICB1cGRhdGVDdXJyZW50QXR0cmlidXRlcyhjdXJyZW50QXR0cmlidXRlcywgLyoqIEB0eXBlIHtDb250ZW50Rm9ybWF0fSAqLyAoZW5kLmNvbnRlbnQpKVxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmVzICs9IGNsZWFudXBGb3JtYXR0aW5nR2FwKHRyYW5zYWN0aW9uLCBzdGFydCwgZW5kLCBzdGFydEF0dHJpYnV0ZXMsIGN1cnJlbnRBdHRyaWJ1dGVzKVxuICAgICAgICAgICAgc3RhcnRBdHRyaWJ1dGVzID0gbWFwLmNvcHkoY3VycmVudEF0dHJpYnV0ZXMpXG4gICAgICAgICAgICBzdGFydCA9IGVuZFxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZW5kID0gZW5kLnJpZ2h0XG4gICAgfVxuICB9KVxuICByZXR1cm4gcmVzXG59XG5cbi8qKlxuICogVGhpcyB3aWxsIGJlIGNhbGxlZCBieSB0aGUgdHJhbnNjdGlvbiBvbmNlIHRoZSBldmVudCBoYW5kbGVycyBhcmUgY2FsbGVkIHRvIHBvdGVudGlhbGx5IGNsZWFudXBcbiAqIGZvcm1hdHRpbmcgYXR0cmlidXRlcy5cbiAqXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICovXG5leHBvcnQgY29uc3QgY2xlYW51cFlUZXh0QWZ0ZXJUcmFuc2FjdGlvbiA9IHRyYW5zYWN0aW9uID0+IHtcbiAgLyoqXG4gICAqIEB0eXBlIHtTZXQ8WVRleHQ+fVxuICAgKi9cbiAgY29uc3QgbmVlZEZ1bGxDbGVhbnVwID0gbmV3IFNldCgpXG4gIC8vIGNoZWNrIGlmIGFub3RoZXIgZm9ybWF0dGluZyBpdGVtIHdhcyBpbnNlcnRlZFxuICBjb25zdCBkb2MgPSB0cmFuc2FjdGlvbi5kb2NcbiAgZm9yIChjb25zdCBbY2xpZW50LCBhZnRlckNsb2NrXSBvZiB0cmFuc2FjdGlvbi5hZnRlclN0YXRlLmVudHJpZXMoKSkge1xuICAgIGNvbnN0IGNsb2NrID0gdHJhbnNhY3Rpb24uYmVmb3JlU3RhdGUuZ2V0KGNsaWVudCkgfHwgMFxuICAgIGlmIChhZnRlckNsb2NrID09PSBjbG9jaykge1xuICAgICAgY29udGludWVcbiAgICB9XG4gICAgaXRlcmF0ZVN0cnVjdHModHJhbnNhY3Rpb24sIC8qKiBAdHlwZSB7QXJyYXk8SXRlbXxHQz59ICovIChkb2Muc3RvcmUuY2xpZW50cy5nZXQoY2xpZW50KSksIGNsb2NrLCBhZnRlckNsb2NrLCBpdGVtID0+IHtcbiAgICAgIGlmIChcbiAgICAgICAgIWl0ZW0uZGVsZXRlZCAmJiAvKiogQHR5cGUge0l0ZW19ICovIChpdGVtKS5jb250ZW50LmNvbnN0cnVjdG9yID09PSBDb250ZW50Rm9ybWF0ICYmIGl0ZW0uY29uc3RydWN0b3IgIT09IEdDXG4gICAgICApIHtcbiAgICAgICAgbmVlZEZ1bGxDbGVhbnVwLmFkZCgvKiogQHR5cGUge2FueX0gKi8gKGl0ZW0pLnBhcmVudClcbiAgICAgIH1cbiAgICB9KVxuICB9XG4gIC8vIGNsZWFudXAgaW4gYSBuZXcgdHJhbnNhY3Rpb25cbiAgdHJhbnNhY3QoZG9jLCAodCkgPT4ge1xuICAgIGl0ZXJhdGVEZWxldGVkU3RydWN0cyh0cmFuc2FjdGlvbiwgdHJhbnNhY3Rpb24uZGVsZXRlU2V0LCBpdGVtID0+IHtcbiAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgR0MgfHwgISgvKiogQHR5cGUge1lUZXh0fSAqLyAoaXRlbS5wYXJlbnQpLl9oYXNGb3JtYXR0aW5nKSB8fCBuZWVkRnVsbENsZWFudXAuaGFzKC8qKiBAdHlwZSB7WVRleHR9ICovIChpdGVtLnBhcmVudCkpKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgY29uc3QgcGFyZW50ID0gLyoqIEB0eXBlIHtZVGV4dH0gKi8gKGl0ZW0ucGFyZW50KVxuICAgICAgaWYgKGl0ZW0uY29udGVudC5jb25zdHJ1Y3RvciA9PT0gQ29udGVudEZvcm1hdCkge1xuICAgICAgICBuZWVkRnVsbENsZWFudXAuYWRkKHBhcmVudClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIElmIG5vIGZvcm1hdHRpbmcgYXR0cmlidXRlIHdhcyBpbnNlcnRlZCBvciBkZWxldGVkLCB3ZSBjYW4gbWFrZSBkdWUgd2l0aCBjb250ZXh0bGVzc1xuICAgICAgICAvLyBmb3JtYXR0aW5nIGNsZWFudXBzLlxuICAgICAgICAvLyBDb250ZXh0bGVzczogaXQgaXMgbm90IG5lY2Vzc2FyeSB0byBjb21wdXRlIGN1cnJlbnRBdHRyaWJ1dGVzIGZvciB0aGUgYWZmZWN0ZWQgcG9zaXRpb24uXG4gICAgICAgIGNsZWFudXBDb250ZXh0bGVzc0Zvcm1hdHRpbmdHYXAodCwgaXRlbSlcbiAgICAgIH1cbiAgICB9KVxuICAgIC8vIElmIGEgZm9ybWF0dGluZyBpdGVtIHdhcyBpbnNlcnRlZCwgd2Ugc2ltcGx5IGNsZWFuIHRoZSB3aG9sZSB0eXBlLlxuICAgIC8vIFdlIG5lZWQgdG8gY29tcHV0ZSBjdXJyZW50QXR0cmlidXRlcyBmb3IgdGhlIGN1cnJlbnQgcG9zaXRpb24gYW55d2F5LlxuICAgIGZvciAoY29uc3QgeVRleHQgb2YgbmVlZEZ1bGxDbGVhbnVwKSB7XG4gICAgICBjbGVhbnVwWVRleHRGb3JtYXR0aW5nKHlUZXh0KVxuICAgIH1cbiAgfSlcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtJdGVtVGV4dExpc3RQb3NpdGlvbn0gY3VyclBvc1xuICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aFxuICogQHJldHVybiB7SXRlbVRleHRMaXN0UG9zaXRpb259XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBkZWxldGVUZXh0ID0gKHRyYW5zYWN0aW9uLCBjdXJyUG9zLCBsZW5ndGgpID0+IHtcbiAgY29uc3Qgc3RhcnRMZW5ndGggPSBsZW5ndGhcbiAgY29uc3Qgc3RhcnRBdHRycyA9IG1hcC5jb3B5KGN1cnJQb3MuY3VycmVudEF0dHJpYnV0ZXMpXG4gIGNvbnN0IHN0YXJ0ID0gY3VyclBvcy5yaWdodFxuICB3aGlsZSAobGVuZ3RoID4gMCAmJiBjdXJyUG9zLnJpZ2h0ICE9PSBudWxsKSB7XG4gICAgaWYgKGN1cnJQb3MucmlnaHQuZGVsZXRlZCA9PT0gZmFsc2UpIHtcbiAgICAgIHN3aXRjaCAoY3VyclBvcy5yaWdodC5jb250ZW50LmNvbnN0cnVjdG9yKSB7XG4gICAgICAgIGNhc2UgQ29udGVudFR5cGU6XG4gICAgICAgIGNhc2UgQ29udGVudEVtYmVkOlxuICAgICAgICBjYXNlIENvbnRlbnRTdHJpbmc6XG4gICAgICAgICAgaWYgKGxlbmd0aCA8IGN1cnJQb3MucmlnaHQubGVuZ3RoKSB7XG4gICAgICAgICAgICBnZXRJdGVtQ2xlYW5TdGFydCh0cmFuc2FjdGlvbiwgY3JlYXRlSUQoY3VyclBvcy5yaWdodC5pZC5jbGllbnQsIGN1cnJQb3MucmlnaHQuaWQuY2xvY2sgKyBsZW5ndGgpKVxuICAgICAgICAgIH1cbiAgICAgICAgICBsZW5ndGggLT0gY3VyclBvcy5yaWdodC5sZW5ndGhcbiAgICAgICAgICBjdXJyUG9zLnJpZ2h0LmRlbGV0ZSh0cmFuc2FjdGlvbilcbiAgICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgICBjdXJyUG9zLmZvcndhcmQoKVxuICB9XG4gIGlmIChzdGFydCkge1xuICAgIGNsZWFudXBGb3JtYXR0aW5nR2FwKHRyYW5zYWN0aW9uLCBzdGFydCwgY3VyclBvcy5yaWdodCwgc3RhcnRBdHRycywgY3VyclBvcy5jdXJyZW50QXR0cmlidXRlcylcbiAgfVxuICBjb25zdCBwYXJlbnQgPSAvKiogQHR5cGUge0Fic3RyYWN0VHlwZTxhbnk+fSAqLyAoLyoqIEB0eXBlIHtJdGVtfSAqLyAoY3VyclBvcy5sZWZ0IHx8IGN1cnJQb3MucmlnaHQpLnBhcmVudClcbiAgaWYgKHBhcmVudC5fc2VhcmNoTWFya2VyKSB7XG4gICAgdXBkYXRlTWFya2VyQ2hhbmdlcyhwYXJlbnQuX3NlYXJjaE1hcmtlciwgY3VyclBvcy5pbmRleCwgLXN0YXJ0TGVuZ3RoICsgbGVuZ3RoKVxuICB9XG4gIHJldHVybiBjdXJyUG9zXG59XG5cbi8qKlxuICogVGhlIFF1aWxsIERlbHRhIGZvcm1hdCByZXByZXNlbnRzIGNoYW5nZXMgb24gYSB0ZXh0IGRvY3VtZW50IHdpdGhcbiAqIGZvcm1hdHRpbmcgaW5mb3JtYXRpb24uIEZvciBtb3IgaW5mb3JtYXRpb24gdmlzaXQge0BsaW5rIGh0dHBzOi8vcXVpbGxqcy5jb20vZG9jcy9kZWx0YS98UXVpbGwgRGVsdGF9XG4gKlxuICogQGV4YW1wbGVcbiAqICAge1xuICogICAgIG9wczogW1xuICogICAgICAgeyBpbnNlcnQ6ICdHYW5kYWxmJywgYXR0cmlidXRlczogeyBib2xkOiB0cnVlIH0gfSxcbiAqICAgICAgIHsgaW5zZXJ0OiAnIHRoZSAnIH0sXG4gKiAgICAgICB7IGluc2VydDogJ0dyZXknLCBhdHRyaWJ1dGVzOiB7IGNvbG9yOiAnI2NjY2NjYycgfSB9XG4gKiAgICAgXVxuICogICB9XG4gKlxuICovXG5cbi8qKlxuICAqIEF0dHJpYnV0ZXMgdGhhdCBjYW4gYmUgYXNzaWduZWQgdG8gYSBzZWxlY3Rpb24gb2YgdGV4dC5cbiAgKlxuICAqIEBleGFtcGxlXG4gICogICB7XG4gICogICAgIGJvbGQ6IHRydWUsXG4gICogICAgIGZvbnQtc2l6ZTogJzQwcHgnXG4gICogICB9XG4gICpcbiAgKiBAdHlwZWRlZiB7T2JqZWN0fSBUZXh0QXR0cmlidXRlc1xuICAqL1xuXG4vKipcbiAqIEBleHRlbmRzIFlFdmVudDxZVGV4dD5cbiAqIEV2ZW50IHRoYXQgZGVzY3JpYmVzIHRoZSBjaGFuZ2VzIG9uIGEgWVRleHQgdHlwZS5cbiAqL1xuZXhwb3J0IGNsYXNzIFlUZXh0RXZlbnQgZXh0ZW5kcyBZRXZlbnQge1xuICAvKipcbiAgICogQHBhcmFtIHtZVGV4dH0geXRleHRcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtTZXQ8YW55Pn0gc3VicyBUaGUga2V5cyB0aGF0IGNoYW5nZWRcbiAgICovXG4gIGNvbnN0cnVjdG9yICh5dGV4dCwgdHJhbnNhY3Rpb24sIHN1YnMpIHtcbiAgICBzdXBlcih5dGV4dCwgdHJhbnNhY3Rpb24pXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgY2hpbGRyZW4gY2hhbmdlZC5cbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuY2hpbGRMaXN0Q2hhbmdlZCA9IGZhbHNlXG4gICAgLyoqXG4gICAgICogU2V0IG9mIGFsbCBjaGFuZ2VkIGF0dHJpYnV0ZXMuXG4gICAgICogQHR5cGUge1NldDxzdHJpbmc+fVxuICAgICAqL1xuICAgIHRoaXMua2V5c0NoYW5nZWQgPSBuZXcgU2V0KClcbiAgICBzdWJzLmZvckVhY2goKHN1YikgPT4ge1xuICAgICAgaWYgKHN1YiA9PT0gbnVsbCkge1xuICAgICAgICB0aGlzLmNoaWxkTGlzdENoYW5nZWQgPSB0cnVlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmtleXNDaGFuZ2VkLmFkZChzdWIpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7e2FkZGVkOlNldDxJdGVtPixkZWxldGVkOlNldDxJdGVtPixrZXlzOk1hcDxzdHJpbmcse2FjdGlvbjonYWRkJ3wndXBkYXRlJ3wnZGVsZXRlJyxvbGRWYWx1ZTphbnl9PixkZWx0YTpBcnJheTx7aW5zZXJ0PzpBcnJheTxhbnk+fHN0cmluZywgZGVsZXRlPzpudW1iZXIsIHJldGFpbj86bnVtYmVyfT59fVxuICAgKi9cbiAgZ2V0IGNoYW5nZXMgKCkge1xuICAgIGlmICh0aGlzLl9jaGFuZ2VzID09PSBudWxsKSB7XG4gICAgICAvKipcbiAgICAgICAqIEB0eXBlIHt7YWRkZWQ6U2V0PEl0ZW0+LGRlbGV0ZWQ6U2V0PEl0ZW0+LGtleXM6TWFwPHN0cmluZyx7YWN0aW9uOidhZGQnfCd1cGRhdGUnfCdkZWxldGUnLG9sZFZhbHVlOmFueX0+LGRlbHRhOkFycmF5PHtpbnNlcnQ/OkFycmF5PGFueT58c3RyaW5nfEFic3RyYWN0VHlwZTxhbnk+fG9iamVjdCwgZGVsZXRlPzpudW1iZXIsIHJldGFpbj86bnVtYmVyfT59fVxuICAgICAgICovXG4gICAgICBjb25zdCBjaGFuZ2VzID0ge1xuICAgICAgICBrZXlzOiB0aGlzLmtleXMsXG4gICAgICAgIGRlbHRhOiB0aGlzLmRlbHRhLFxuICAgICAgICBhZGRlZDogbmV3IFNldCgpLFxuICAgICAgICBkZWxldGVkOiBuZXcgU2V0KClcbiAgICAgIH1cbiAgICAgIHRoaXMuX2NoYW5nZXMgPSBjaGFuZ2VzXG4gICAgfVxuICAgIHJldHVybiAvKiogQHR5cGUge2FueX0gKi8gKHRoaXMuX2NoYW5nZXMpXG4gIH1cblxuICAvKipcbiAgICogQ29tcHV0ZSB0aGUgY2hhbmdlcyBpbiB0aGUgZGVsdGEgZm9ybWF0LlxuICAgKiBBIHtAbGluayBodHRwczovL3F1aWxsanMuY29tL2RvY3MvZGVsdGEvfFF1aWxsIERlbHRhfSkgdGhhdCByZXByZXNlbnRzIHRoZSBjaGFuZ2VzIG9uIHRoZSBkb2N1bWVudC5cbiAgICpcbiAgICogQHR5cGUge0FycmF5PHtpbnNlcnQ/OnN0cmluZ3xvYmplY3R8QWJzdHJhY3RUeXBlPGFueT4sIGRlbGV0ZT86bnVtYmVyLCByZXRhaW4/Om51bWJlciwgYXR0cmlidXRlcz86IE9iamVjdDxzdHJpbmcsYW55Pn0+fVxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBnZXQgZGVsdGEgKCkge1xuICAgIGlmICh0aGlzLl9kZWx0YSA9PT0gbnVsbCkge1xuICAgICAgY29uc3QgeSA9IC8qKiBAdHlwZSB7RG9jfSAqLyAodGhpcy50YXJnZXQuZG9jKVxuICAgICAgLyoqXG4gICAgICAgKiBAdHlwZSB7QXJyYXk8e2luc2VydD86c3RyaW5nfG9iamVjdHxBYnN0cmFjdFR5cGU8YW55PiwgZGVsZXRlPzpudW1iZXIsIHJldGFpbj86bnVtYmVyLCBhdHRyaWJ1dGVzPzogT2JqZWN0PHN0cmluZyxhbnk+fT59XG4gICAgICAgKi9cbiAgICAgIGNvbnN0IGRlbHRhID0gW11cbiAgICAgIHRyYW5zYWN0KHksIHRyYW5zYWN0aW9uID0+IHtcbiAgICAgICAgY29uc3QgY3VycmVudEF0dHJpYnV0ZXMgPSBuZXcgTWFwKCkgLy8gc2F2ZXMgYWxsIGN1cnJlbnQgYXR0cmlidXRlcyBmb3IgaW5zZXJ0XG4gICAgICAgIGNvbnN0IG9sZEF0dHJpYnV0ZXMgPSBuZXcgTWFwKClcbiAgICAgICAgbGV0IGl0ZW0gPSB0aGlzLnRhcmdldC5fc3RhcnRcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmc/fVxuICAgICAgICAgKi9cbiAgICAgICAgbGV0IGFjdGlvbiA9IG51bGxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLGFueT59XG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBhdHRyaWJ1dGVzID0ge30gLy8gY291bnRzIGFkZGVkIG9yIHJlbW92ZWQgbmV3IGF0dHJpYnV0ZXMgZm9yIHJldGFpblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge3N0cmluZ3xvYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICBsZXQgaW5zZXJ0ID0gJydcbiAgICAgICAgbGV0IHJldGFpbiA9IDBcbiAgICAgICAgbGV0IGRlbGV0ZUxlbiA9IDBcbiAgICAgICAgY29uc3QgYWRkT3AgPSAoKSA9PiB7XG4gICAgICAgICAgaWYgKGFjdGlvbiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAdHlwZSB7YW55fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBsZXQgb3AgPSBudWxsXG4gICAgICAgICAgICBzd2l0Y2ggKGFjdGlvbikge1xuICAgICAgICAgICAgICBjYXNlICdkZWxldGUnOlxuICAgICAgICAgICAgICAgIGlmIChkZWxldGVMZW4gPiAwKSB7XG4gICAgICAgICAgICAgICAgICBvcCA9IHsgZGVsZXRlOiBkZWxldGVMZW4gfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWxldGVMZW4gPSAwXG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgY2FzZSAnaW5zZXJ0JzpcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGluc2VydCA9PT0gJ29iamVjdCcgfHwgaW5zZXJ0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgIG9wID0geyBpbnNlcnQgfVxuICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRBdHRyaWJ1dGVzLnNpemUgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wLmF0dHJpYnV0ZXMgPSB7fVxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50QXR0cmlidXRlcy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcC5hdHRyaWJ1dGVzW2tleV0gPSB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaW5zZXJ0ID0gJydcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICBjYXNlICdyZXRhaW4nOlxuICAgICAgICAgICAgICAgIGlmIChyZXRhaW4gPiAwKSB7XG4gICAgICAgICAgICAgICAgICBvcCA9IHsgcmV0YWluIH1cbiAgICAgICAgICAgICAgICAgIGlmICghb2JqZWN0LmlzRW1wdHkoYXR0cmlidXRlcykpIHtcbiAgICAgICAgICAgICAgICAgICAgb3AuYXR0cmlidXRlcyA9IG9iamVjdC5hc3NpZ24oe30sIGF0dHJpYnV0ZXMpXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldGFpbiA9IDBcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wKSBkZWx0YS5wdXNoKG9wKVxuICAgICAgICAgICAgYWN0aW9uID0gbnVsbFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoaXRlbSAhPT0gbnVsbCkge1xuICAgICAgICAgIHN3aXRjaCAoaXRlbS5jb250ZW50LmNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICBjYXNlIENvbnRlbnRUeXBlOlxuICAgICAgICAgICAgY2FzZSBDb250ZW50RW1iZWQ6XG4gICAgICAgICAgICAgIGlmICh0aGlzLmFkZHMoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuZGVsZXRlcyhpdGVtKSkge1xuICAgICAgICAgICAgICAgICAgYWRkT3AoKVxuICAgICAgICAgICAgICAgICAgYWN0aW9uID0gJ2luc2VydCdcbiAgICAgICAgICAgICAgICAgIGluc2VydCA9IGl0ZW0uY29udGVudC5nZXRDb250ZW50KClbMF1cbiAgICAgICAgICAgICAgICAgIGFkZE9wKClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5kZWxldGVzKGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFjdGlvbiAhPT0gJ2RlbGV0ZScpIHtcbiAgICAgICAgICAgICAgICAgIGFkZE9wKClcbiAgICAgICAgICAgICAgICAgIGFjdGlvbiA9ICdkZWxldGUnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlbGV0ZUxlbiArPSAxXG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoIWl0ZW0uZGVsZXRlZCkge1xuICAgICAgICAgICAgICAgIGlmIChhY3Rpb24gIT09ICdyZXRhaW4nKSB7XG4gICAgICAgICAgICAgICAgICBhZGRPcCgpXG4gICAgICAgICAgICAgICAgICBhY3Rpb24gPSAncmV0YWluJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXRhaW4gKz0gMVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICBjYXNlIENvbnRlbnRTdHJpbmc6XG4gICAgICAgICAgICAgIGlmICh0aGlzLmFkZHMoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuZGVsZXRlcyhpdGVtKSkge1xuICAgICAgICAgICAgICAgICAgaWYgKGFjdGlvbiAhPT0gJ2luc2VydCcpIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkT3AoKVxuICAgICAgICAgICAgICAgICAgICBhY3Rpb24gPSAnaW5zZXJ0J1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaW5zZXJ0ICs9IC8qKiBAdHlwZSB7Q29udGVudFN0cmluZ30gKi8gKGl0ZW0uY29udGVudCkuc3RyXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZGVsZXRlcyhpdGVtKSkge1xuICAgICAgICAgICAgICAgIGlmIChhY3Rpb24gIT09ICdkZWxldGUnKSB7XG4gICAgICAgICAgICAgICAgICBhZGRPcCgpXG4gICAgICAgICAgICAgICAgICBhY3Rpb24gPSAnZGVsZXRlJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWxldGVMZW4gKz0gaXRlbS5sZW5ndGhcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICghaXRlbS5kZWxldGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFjdGlvbiAhPT0gJ3JldGFpbicpIHtcbiAgICAgICAgICAgICAgICAgIGFkZE9wKClcbiAgICAgICAgICAgICAgICAgIGFjdGlvbiA9ICdyZXRhaW4nXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldGFpbiArPSBpdGVtLmxlbmd0aFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICBjYXNlIENvbnRlbnRGb3JtYXQ6IHtcbiAgICAgICAgICAgICAgY29uc3QgeyBrZXksIHZhbHVlIH0gPSAvKiogQHR5cGUge0NvbnRlbnRGb3JtYXR9ICovIChpdGVtLmNvbnRlbnQpXG4gICAgICAgICAgICAgIGlmICh0aGlzLmFkZHMoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuZGVsZXRlcyhpdGVtKSkge1xuICAgICAgICAgICAgICAgICAgY29uc3QgY3VyVmFsID0gY3VycmVudEF0dHJpYnV0ZXMuZ2V0KGtleSkgfHwgbnVsbFxuICAgICAgICAgICAgICAgICAgaWYgKCFlcXVhbEF0dHJzKGN1clZhbCwgdmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhY3Rpb24gPT09ICdyZXRhaW4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgYWRkT3AoKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcXVhbEF0dHJzKHZhbHVlLCAob2xkQXR0cmlidXRlcy5nZXQoa2V5KSB8fCBudWxsKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgYXR0cmlidXRlc1trZXldXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlc1trZXldID0gdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBpdGVtLmRlbGV0ZSh0cmFuc2FjdGlvbilcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5kZWxldGVzKGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgb2xkQXR0cmlidXRlcy5zZXQoa2V5LCB2YWx1ZSlcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJWYWwgPSBjdXJyZW50QXR0cmlidXRlcy5nZXQoa2V5KSB8fCBudWxsXG4gICAgICAgICAgICAgICAgaWYgKCFlcXVhbEF0dHJzKGN1clZhbCwgdmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoYWN0aW9uID09PSAncmV0YWluJykge1xuICAgICAgICAgICAgICAgICAgICBhZGRPcCgpXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzW2tleV0gPSBjdXJWYWxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoIWl0ZW0uZGVsZXRlZCkge1xuICAgICAgICAgICAgICAgIG9sZEF0dHJpYnV0ZXMuc2V0KGtleSwgdmFsdWUpXG4gICAgICAgICAgICAgICAgY29uc3QgYXR0ciA9IGF0dHJpYnV0ZXNba2V5XVxuICAgICAgICAgICAgICAgIGlmIChhdHRyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgIGlmICghZXF1YWxBdHRycyhhdHRyLCB2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFjdGlvbiA9PT0gJ3JldGFpbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICBhZGRPcCgpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGF0dHJpYnV0ZXNba2V5XVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXNba2V5XSA9IHZhbHVlXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYXR0ciAhPT0gbnVsbCkgeyAvLyB0aGlzIHdpbGwgYmUgY2xlYW5lZCB1cCBhdXRvbWF0aWNhbGx5IGJ5IHRoZSBjb250ZXh0bGVzcyBjbGVhbnVwIGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uZGVsZXRlKHRyYW5zYWN0aW9uKVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoIWl0ZW0uZGVsZXRlZCkge1xuICAgICAgICAgICAgICAgIGlmIChhY3Rpb24gPT09ICdpbnNlcnQnKSB7XG4gICAgICAgICAgICAgICAgICBhZGRPcCgpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHVwZGF0ZUN1cnJlbnRBdHRyaWJ1dGVzKGN1cnJlbnRBdHRyaWJ1dGVzLCAvKiogQHR5cGUge0NvbnRlbnRGb3JtYXR9ICovIChpdGVtLmNvbnRlbnQpKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGl0ZW0gPSBpdGVtLnJpZ2h0XG4gICAgICAgIH1cbiAgICAgICAgYWRkT3AoKVxuICAgICAgICB3aGlsZSAoZGVsdGEubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGNvbnN0IGxhc3RPcCA9IGRlbHRhW2RlbHRhLmxlbmd0aCAtIDFdXG4gICAgICAgICAgaWYgKGxhc3RPcC5yZXRhaW4gIT09IHVuZGVmaW5lZCAmJiBsYXN0T3AuYXR0cmlidXRlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyByZXRhaW4gZGVsdGEncyBpZiB0aGV5IGRvbid0IGFzc2lnbiBhdHRyaWJ1dGVzXG4gICAgICAgICAgICBkZWx0YS5wb3AoKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIHRoaXMuX2RlbHRhID0gZGVsdGFcbiAgICB9XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7YW55fSAqLyAodGhpcy5fZGVsdGEpXG4gIH1cbn1cblxuLyoqXG4gKiBUeXBlIHRoYXQgcmVwcmVzZW50cyB0ZXh0IHdpdGggZm9ybWF0dGluZyBpbmZvcm1hdGlvbi5cbiAqXG4gKiBUaGlzIHR5cGUgcmVwbGFjZXMgeS1yaWNodGV4dCBhcyB0aGlzIGltcGxlbWVudGF0aW9uIGlzIGFibGUgdG8gaGFuZGxlXG4gKiBibG9jayBmb3JtYXRzIChmb3JtYXQgaW5mb3JtYXRpb24gb24gYSBwYXJhZ3JhcGgpLCBlbWJlZHMgKGNvbXBsZXggZWxlbWVudHNcbiAqIGxpa2UgcGljdHVyZXMgYW5kIHZpZGVvcyksIGFuZCB0ZXh0IGZvcm1hdHMgKCoqYm9sZCoqLCAqaXRhbGljKikuXG4gKlxuICogQGV4dGVuZHMgQWJzdHJhY3RUeXBlPFlUZXh0RXZlbnQ+XG4gKi9cbmV4cG9ydCBjbGFzcyBZVGV4dCBleHRlbmRzIEFic3RyYWN0VHlwZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gW3N0cmluZ10gVGhlIGluaXRpYWwgdmFsdWUgb2YgdGhlIFlUZXh0LlxuICAgKi9cbiAgY29uc3RydWN0b3IgKHN0cmluZykge1xuICAgIHN1cGVyKClcbiAgICAvKipcbiAgICAgKiBBcnJheSBvZiBwZW5kaW5nIG9wZXJhdGlvbnMgb24gdGhpcyB0eXBlXG4gICAgICogQHR5cGUge0FycmF5PGZ1bmN0aW9uKCk6dm9pZD4/fVxuICAgICAqL1xuICAgIHRoaXMuX3BlbmRpbmcgPSBzdHJpbmcgIT09IHVuZGVmaW5lZCA/IFsoKSA9PiB0aGlzLmluc2VydCgwLCBzdHJpbmcpXSA6IFtdXG4gICAgLyoqXG4gICAgICogQHR5cGUge0FycmF5PEFycmF5U2VhcmNoTWFya2VyPnxudWxsfVxuICAgICAqL1xuICAgIHRoaXMuX3NlYXJjaE1hcmtlciA9IFtdXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGlzIFlUZXh0IGNvbnRhaW5zIGZvcm1hdHRpbmcgYXR0cmlidXRlcy5cbiAgICAgKiBUaGlzIGZsYWcgaXMgdXBkYXRlZCB3aGVuIGEgZm9ybWF0dGluZyBpdGVtIGlzIGludGVncmF0ZWQgKHNlZSBDb250ZW50Rm9ybWF0LmludGVncmF0ZSlcbiAgICAgKi9cbiAgICB0aGlzLl9oYXNGb3JtYXR0aW5nID0gZmFsc2VcbiAgfVxuXG4gIC8qKlxuICAgKiBOdW1iZXIgb2YgY2hhcmFjdGVycyBvZiB0aGlzIHRleHQgdHlwZS5cbiAgICpcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBsZW5ndGggKCkge1xuICAgIHJldHVybiB0aGlzLl9sZW5ndGhcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0RvY30geVxuICAgKiBAcGFyYW0ge0l0ZW19IGl0ZW1cbiAgICovXG4gIF9pbnRlZ3JhdGUgKHksIGl0ZW0pIHtcbiAgICBzdXBlci5faW50ZWdyYXRlKHksIGl0ZW0pXG4gICAgdHJ5IHtcbiAgICAgIC8qKiBAdHlwZSB7QXJyYXk8ZnVuY3Rpb24+fSAqLyAodGhpcy5fcGVuZGluZykuZm9yRWFjaChmID0+IGYoKSlcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGUpXG4gICAgfVxuICAgIHRoaXMuX3BlbmRpbmcgPSBudWxsXG4gIH1cblxuICBfY29weSAoKSB7XG4gICAgcmV0dXJuIG5ldyBZVGV4dCgpXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7WVRleHR9XG4gICAqL1xuICBjbG9uZSAoKSB7XG4gICAgY29uc3QgdGV4dCA9IG5ldyBZVGV4dCgpXG4gICAgdGV4dC5hcHBseURlbHRhKHRoaXMudG9EZWx0YSgpKVxuICAgIHJldHVybiB0ZXh0XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBZVGV4dEV2ZW50IGFuZCBjYWxscyBvYnNlcnZlcnMuXG4gICAqXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7U2V0PG51bGx8c3RyaW5nPn0gcGFyZW50U3VicyBLZXlzIGNoYW5nZWQgb24gdGhpcyB0eXBlLiBgbnVsbGAgaWYgbGlzdCB3YXMgbW9kaWZpZWQuXG4gICAqL1xuICBfY2FsbE9ic2VydmVyICh0cmFuc2FjdGlvbiwgcGFyZW50U3Vicykge1xuICAgIHN1cGVyLl9jYWxsT2JzZXJ2ZXIodHJhbnNhY3Rpb24sIHBhcmVudFN1YnMpXG4gICAgY29uc3QgZXZlbnQgPSBuZXcgWVRleHRFdmVudCh0aGlzLCB0cmFuc2FjdGlvbiwgcGFyZW50U3VicylcbiAgICBjYWxsVHlwZU9ic2VydmVycyh0aGlzLCB0cmFuc2FjdGlvbiwgZXZlbnQpXG4gICAgLy8gSWYgYSByZW1vdGUgY2hhbmdlIGhhcHBlbmVkLCB3ZSB0cnkgdG8gY2xlYW51cCBwb3RlbnRpYWwgZm9ybWF0dGluZyBkdXBsaWNhdGVzLlxuICAgIGlmICghdHJhbnNhY3Rpb24ubG9jYWwgJiYgdGhpcy5faGFzRm9ybWF0dGluZykge1xuICAgICAgdHJhbnNhY3Rpb24uX25lZWRGb3JtYXR0aW5nQ2xlYW51cCA9IHRydWVcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdW5mb3JtYXR0ZWQgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgWVRleHQgdHlwZS5cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgdG9TdHJpbmcgKCkge1xuICAgIGxldCBzdHIgPSAnJ1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtJdGVtfG51bGx9XG4gICAgICovXG4gICAgbGV0IG4gPSB0aGlzLl9zdGFydFxuICAgIHdoaWxlIChuICE9PSBudWxsKSB7XG4gICAgICBpZiAoIW4uZGVsZXRlZCAmJiBuLmNvdW50YWJsZSAmJiBuLmNvbnRlbnQuY29uc3RydWN0b3IgPT09IENvbnRlbnRTdHJpbmcpIHtcbiAgICAgICAgc3RyICs9IC8qKiBAdHlwZSB7Q29udGVudFN0cmluZ30gKi8gKG4uY29udGVudCkuc3RyXG4gICAgICB9XG4gICAgICBuID0gbi5yaWdodFxuICAgIH1cbiAgICByZXR1cm4gc3RyXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdW5mb3JtYXR0ZWQgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgWVRleHQgdHlwZS5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiBAcHVibGljXG4gICAqL1xuICB0b0pTT04gKCkge1xuICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKClcbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBseSBhIHtAbGluayBEZWx0YX0gb24gdGhpcyBzaGFyZWQgWVRleHQgdHlwZS5cbiAgICpcbiAgICogQHBhcmFtIHthbnl9IGRlbHRhIFRoZSBjaGFuZ2VzIHRvIGFwcGx5IG9uIHRoaXMgZWxlbWVudC5cbiAgICogQHBhcmFtIHtvYmplY3R9ICBvcHRzXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuc2FuaXRpemVdIFNhbml0aXplIGlucHV0IGRlbHRhLiBSZW1vdmVzIGVuZGluZyBuZXdsaW5lcyBpZiBzZXQgdG8gdHJ1ZS5cbiAgICpcbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgYXBwbHlEZWx0YSAoZGVsdGEsIHsgc2FuaXRpemUgPSB0cnVlIH0gPSB7fSkge1xuICAgIGlmICh0aGlzLmRvYyAhPT0gbnVsbCkge1xuICAgICAgdHJhbnNhY3QodGhpcy5kb2MsIHRyYW5zYWN0aW9uID0+IHtcbiAgICAgICAgY29uc3QgY3VyclBvcyA9IG5ldyBJdGVtVGV4dExpc3RQb3NpdGlvbihudWxsLCB0aGlzLl9zdGFydCwgMCwgbmV3IE1hcCgpKVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlbHRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3Qgb3AgPSBkZWx0YVtpXVxuICAgICAgICAgIGlmIChvcC5pbnNlcnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gUXVpbGwgYXNzdW1lcyB0aGF0IHRoZSBjb250ZW50IHN0YXJ0cyB3aXRoIGFuIGVtcHR5IHBhcmFncmFwaC5cbiAgICAgICAgICAgIC8vIFlqcy9ZLlRleHQgYXNzdW1lcyB0aGF0IGl0IHN0YXJ0cyBlbXB0eS4gV2UgYWx3YXlzIGhpZGUgdGhhdFxuICAgICAgICAgICAgLy8gdGhlcmUgaXMgYSBuZXdsaW5lIGF0IHRoZSBlbmQgb2YgdGhlIGNvbnRlbnQuXG4gICAgICAgICAgICAvLyBJZiB3ZSBvbWl0IHRoaXMgc3RlcCwgY2xpZW50cyB3aWxsIHNlZSBhIGRpZmZlcmVudCBudW1iZXIgb2ZcbiAgICAgICAgICAgIC8vIHBhcmFncmFwaHMsIGJ1dCBub3RoaW5nIGJhZCB3aWxsIGhhcHBlbi5cbiAgICAgICAgICAgIGNvbnN0IGlucyA9ICghc2FuaXRpemUgJiYgdHlwZW9mIG9wLmluc2VydCA9PT0gJ3N0cmluZycgJiYgaSA9PT0gZGVsdGEubGVuZ3RoIC0gMSAmJiBjdXJyUG9zLnJpZ2h0ID09PSBudWxsICYmIG9wLmluc2VydC5zbGljZSgtMSkgPT09ICdcXG4nKSA/IG9wLmluc2VydC5zbGljZSgwLCAtMSkgOiBvcC5pbnNlcnRcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW5zICE9PSAnc3RyaW5nJyB8fCBpbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICBpbnNlcnRUZXh0KHRyYW5zYWN0aW9uLCB0aGlzLCBjdXJyUG9zLCBpbnMsIG9wLmF0dHJpYnV0ZXMgfHwge30pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChvcC5yZXRhaW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZm9ybWF0VGV4dCh0cmFuc2FjdGlvbiwgdGhpcywgY3VyclBvcywgb3AucmV0YWluLCBvcC5hdHRyaWJ1dGVzIHx8IHt9KVxuICAgICAgICAgIH0gZWxzZSBpZiAob3AuZGVsZXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGRlbGV0ZVRleHQodHJhbnNhY3Rpb24sIGN1cnJQb3MsIG9wLmRlbGV0ZSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIC8qKiBAdHlwZSB7QXJyYXk8ZnVuY3Rpb24+fSAqLyAodGhpcy5fcGVuZGluZykucHVzaCgoKSA9PiB0aGlzLmFwcGx5RGVsdGEoZGVsdGEpKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBEZWx0YSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIFlUZXh0IHR5cGUuXG4gICAqXG4gICAqIEBwYXJhbSB7U25hcHNob3R9IFtzbmFwc2hvdF1cbiAgICogQHBhcmFtIHtTbmFwc2hvdH0gW3ByZXZTbmFwc2hvdF1cbiAgICogQHBhcmFtIHtmdW5jdGlvbigncmVtb3ZlZCcgfCAnYWRkZWQnLCBJRCk6YW55fSBbY29tcHV0ZVlDaGFuZ2VdXG4gICAqIEByZXR1cm4ge2FueX0gVGhlIERlbHRhIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgdHlwZS5cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgdG9EZWx0YSAoc25hcHNob3QsIHByZXZTbmFwc2hvdCwgY29tcHV0ZVlDaGFuZ2UpIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZXtBcnJheTxhbnk+fVxuICAgICAqL1xuICAgIGNvbnN0IG9wcyA9IFtdXG4gICAgY29uc3QgY3VycmVudEF0dHJpYnV0ZXMgPSBuZXcgTWFwKClcbiAgICBjb25zdCBkb2MgPSAvKiogQHR5cGUge0RvY30gKi8gKHRoaXMuZG9jKVxuICAgIGxldCBzdHIgPSAnJ1xuICAgIGxldCBuID0gdGhpcy5fc3RhcnRcbiAgICBmdW5jdGlvbiBwYWNrU3RyICgpIHtcbiAgICAgIGlmIChzdHIubGVuZ3RoID4gMCkge1xuICAgICAgICAvLyBwYWNrIHN0ciB3aXRoIGF0dHJpYnV0ZXMgdG8gb3BzXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0PHN0cmluZyxhbnk+fVxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgYXR0cmlidXRlcyA9IHt9XG4gICAgICAgIGxldCBhZGRBdHRyaWJ1dGVzID0gZmFsc2VcbiAgICAgICAgY3VycmVudEF0dHJpYnV0ZXMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICAgIGFkZEF0dHJpYnV0ZXMgPSB0cnVlXG4gICAgICAgICAgYXR0cmlidXRlc1trZXldID0gdmFsdWVcbiAgICAgICAgfSlcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLGFueT59XG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBvcCA9IHsgaW5zZXJ0OiBzdHIgfVxuICAgICAgICBpZiAoYWRkQXR0cmlidXRlcykge1xuICAgICAgICAgIG9wLmF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzXG4gICAgICAgIH1cbiAgICAgICAgb3BzLnB1c2gob3ApXG4gICAgICAgIHN0ciA9ICcnXG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGNvbXB1dGVEZWx0YSA9ICgpID0+IHtcbiAgICAgIHdoaWxlIChuICE9PSBudWxsKSB7XG4gICAgICAgIGlmIChpc1Zpc2libGUobiwgc25hcHNob3QpIHx8IChwcmV2U25hcHNob3QgIT09IHVuZGVmaW5lZCAmJiBpc1Zpc2libGUobiwgcHJldlNuYXBzaG90KSkpIHtcbiAgICAgICAgICBzd2l0Y2ggKG4uY29udGVudC5jb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgY2FzZSBDb250ZW50U3RyaW5nOiB7XG4gICAgICAgICAgICAgIGNvbnN0IGN1ciA9IGN1cnJlbnRBdHRyaWJ1dGVzLmdldCgneWNoYW5nZScpXG4gICAgICAgICAgICAgIGlmIChzbmFwc2hvdCAhPT0gdW5kZWZpbmVkICYmICFpc1Zpc2libGUobiwgc25hcHNob3QpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGN1ciA9PT0gdW5kZWZpbmVkIHx8IGN1ci51c2VyICE9PSBuLmlkLmNsaWVudCB8fCBjdXIudHlwZSAhPT0gJ3JlbW92ZWQnKSB7XG4gICAgICAgICAgICAgICAgICBwYWNrU3RyKClcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnRBdHRyaWJ1dGVzLnNldCgneWNoYW5nZScsIGNvbXB1dGVZQ2hhbmdlID8gY29tcHV0ZVlDaGFuZ2UoJ3JlbW92ZWQnLCBuLmlkKSA6IHsgdHlwZTogJ3JlbW92ZWQnIH0pXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHByZXZTbmFwc2hvdCAhPT0gdW5kZWZpbmVkICYmICFpc1Zpc2libGUobiwgcHJldlNuYXBzaG90KSkge1xuICAgICAgICAgICAgICAgIGlmIChjdXIgPT09IHVuZGVmaW5lZCB8fCBjdXIudXNlciAhPT0gbi5pZC5jbGllbnQgfHwgY3VyLnR5cGUgIT09ICdhZGRlZCcpIHtcbiAgICAgICAgICAgICAgICAgIHBhY2tTdHIoKVxuICAgICAgICAgICAgICAgICAgY3VycmVudEF0dHJpYnV0ZXMuc2V0KCd5Y2hhbmdlJywgY29tcHV0ZVlDaGFuZ2UgPyBjb21wdXRlWUNoYW5nZSgnYWRkZWQnLCBuLmlkKSA6IHsgdHlwZTogJ2FkZGVkJyB9KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChjdXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHBhY2tTdHIoKVxuICAgICAgICAgICAgICAgIGN1cnJlbnRBdHRyaWJ1dGVzLmRlbGV0ZSgneWNoYW5nZScpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc3RyICs9IC8qKiBAdHlwZSB7Q29udGVudFN0cmluZ30gKi8gKG4uY29udGVudCkuc3RyXG4gICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIENvbnRlbnRUeXBlOlxuICAgICAgICAgICAgY2FzZSBDb250ZW50RW1iZWQ6IHtcbiAgICAgICAgICAgICAgcGFja1N0cigpXG4gICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgKiBAdHlwZSB7T2JqZWN0PHN0cmluZyxhbnk+fVxuICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgY29uc3Qgb3AgPSB7XG4gICAgICAgICAgICAgICAgaW5zZXJ0OiBuLmNvbnRlbnQuZ2V0Q29udGVudCgpWzBdXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGN1cnJlbnRBdHRyaWJ1dGVzLnNpemUgPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYXR0cnMgPSAvKiogQHR5cGUge09iamVjdDxzdHJpbmcsYW55Pn0gKi8gKHt9KVxuICAgICAgICAgICAgICAgIG9wLmF0dHJpYnV0ZXMgPSBhdHRyc1xuICAgICAgICAgICAgICAgIGN1cnJlbnRBdHRyaWJ1dGVzLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgICAgICAgICAgIGF0dHJzW2tleV0gPSB2YWx1ZVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgb3BzLnB1c2gob3ApXG4gICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIENvbnRlbnRGb3JtYXQ6XG4gICAgICAgICAgICAgIGlmIChpc1Zpc2libGUobiwgc25hcHNob3QpKSB7XG4gICAgICAgICAgICAgICAgcGFja1N0cigpXG4gICAgICAgICAgICAgICAgdXBkYXRlQ3VycmVudEF0dHJpYnV0ZXMoY3VycmVudEF0dHJpYnV0ZXMsIC8qKiBAdHlwZSB7Q29udGVudEZvcm1hdH0gKi8gKG4uY29udGVudCkpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbiA9IG4ucmlnaHRcbiAgICAgIH1cbiAgICAgIHBhY2tTdHIoKVxuICAgIH1cbiAgICBpZiAoc25hcHNob3QgfHwgcHJldlNuYXBzaG90KSB7XG4gICAgICAvLyBzbmFwc2hvdHMgYXJlIG1lcmdlZCBhZ2FpbiBhZnRlciB0aGUgdHJhbnNhY3Rpb24sIHNvIHdlIG5lZWQgdG8ga2VlcCB0aGVcbiAgICAgIC8vIHRyYW5zYWN0aW9uIGFsaXZlIHVudGlsIHdlIGFyZSBkb25lXG4gICAgICB0cmFuc2FjdChkb2MsIHRyYW5zYWN0aW9uID0+IHtcbiAgICAgICAgaWYgKHNuYXBzaG90KSB7XG4gICAgICAgICAgc3BsaXRTbmFwc2hvdEFmZmVjdGVkU3RydWN0cyh0cmFuc2FjdGlvbiwgc25hcHNob3QpXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByZXZTbmFwc2hvdCkge1xuICAgICAgICAgIHNwbGl0U25hcHNob3RBZmZlY3RlZFN0cnVjdHModHJhbnNhY3Rpb24sIHByZXZTbmFwc2hvdClcbiAgICAgICAgfVxuICAgICAgICBjb21wdXRlRGVsdGEoKVxuICAgICAgfSwgJ2NsZWFudXAnKVxuICAgIH0gZWxzZSB7XG4gICAgICBjb21wdXRlRGVsdGEoKVxuICAgIH1cbiAgICByZXR1cm4gb3BzXG4gIH1cblxuICAvKipcbiAgICogSW5zZXJ0IHRleHQgYXQgYSBnaXZlbiBpbmRleC5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBpbmRleCBhdCB3aGljaCB0byBzdGFydCBpbnNlcnRpbmcuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0IFRoZSB0ZXh0IHRvIGluc2VydCBhdCB0aGUgc3BlY2lmaWVkIHBvc2l0aW9uLlxuICAgKiBAcGFyYW0ge1RleHRBdHRyaWJ1dGVzfSBbYXR0cmlidXRlc10gT3B0aW9uYWxseSBkZWZpbmUgc29tZSBmb3JtYXR0aW5nXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5mb3JtYXRpb24gdG8gYXBwbHkgb24gdGhlIGluc2VydGVkXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVGV4dC5cbiAgICogQHB1YmxpY1xuICAgKi9cbiAgaW5zZXJ0IChpbmRleCwgdGV4dCwgYXR0cmlidXRlcykge1xuICAgIGlmICh0ZXh0Lmxlbmd0aCA8PSAwKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgY29uc3QgeSA9IHRoaXMuZG9jXG4gICAgaWYgKHkgIT09IG51bGwpIHtcbiAgICAgIHRyYW5zYWN0KHksIHRyYW5zYWN0aW9uID0+IHtcbiAgICAgICAgY29uc3QgcG9zID0gZmluZFBvc2l0aW9uKHRyYW5zYWN0aW9uLCB0aGlzLCBpbmRleClcbiAgICAgICAgaWYgKCFhdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgYXR0cmlidXRlcyA9IHt9XG4gICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgIHBvcy5jdXJyZW50QXR0cmlidXRlcy5mb3JFYWNoKCh2LCBrKSA9PiB7IGF0dHJpYnV0ZXNba10gPSB2IH0pXG4gICAgICAgIH1cbiAgICAgICAgaW5zZXJ0VGV4dCh0cmFuc2FjdGlvbiwgdGhpcywgcG9zLCB0ZXh0LCBhdHRyaWJ1dGVzKVxuICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgLyoqIEB0eXBlIHtBcnJheTxmdW5jdGlvbj59ICovICh0aGlzLl9wZW5kaW5nKS5wdXNoKCgpID0+IHRoaXMuaW5zZXJ0KGluZGV4LCB0ZXh0LCBhdHRyaWJ1dGVzKSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSW5zZXJ0cyBhbiBlbWJlZCBhdCBhIGluZGV4LlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGluZGV4IHRvIGluc2VydCB0aGUgZW1iZWQgYXQuXG4gICAqIEBwYXJhbSB7T2JqZWN0IHwgQWJzdHJhY3RUeXBlPGFueT59IGVtYmVkIFRoZSBPYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSBlbWJlZC5cbiAgICogQHBhcmFtIHtUZXh0QXR0cmlidXRlc30gYXR0cmlidXRlcyBBdHRyaWJ1dGUgaW5mb3JtYXRpb24gdG8gYXBwbHkgb24gdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW1iZWRcbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgaW5zZXJ0RW1iZWQgKGluZGV4LCBlbWJlZCwgYXR0cmlidXRlcyA9IHt9KSB7XG4gICAgY29uc3QgeSA9IHRoaXMuZG9jXG4gICAgaWYgKHkgIT09IG51bGwpIHtcbiAgICAgIHRyYW5zYWN0KHksIHRyYW5zYWN0aW9uID0+IHtcbiAgICAgICAgY29uc3QgcG9zID0gZmluZFBvc2l0aW9uKHRyYW5zYWN0aW9uLCB0aGlzLCBpbmRleClcbiAgICAgICAgaW5zZXJ0VGV4dCh0cmFuc2FjdGlvbiwgdGhpcywgcG9zLCBlbWJlZCwgYXR0cmlidXRlcylcbiAgICAgIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIC8qKiBAdHlwZSB7QXJyYXk8ZnVuY3Rpb24+fSAqLyAodGhpcy5fcGVuZGluZykucHVzaCgoKSA9PiB0aGlzLmluc2VydEVtYmVkKGluZGV4LCBlbWJlZCwgYXR0cmlidXRlcykpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERlbGV0ZXMgdGV4dCBzdGFydGluZyBmcm9tIGFuIGluZGV4LlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggSW5kZXggYXQgd2hpY2ggdG8gc3RhcnQgZGVsZXRpbmcuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGggVGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzIHRvIHJlbW92ZS4gRGVmYXVsdHMgdG8gMS5cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgZGVsZXRlIChpbmRleCwgbGVuZ3RoKSB7XG4gICAgaWYgKGxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGNvbnN0IHkgPSB0aGlzLmRvY1xuICAgIGlmICh5ICE9PSBudWxsKSB7XG4gICAgICB0cmFuc2FjdCh5LCB0cmFuc2FjdGlvbiA9PiB7XG4gICAgICAgIGRlbGV0ZVRleHQodHJhbnNhY3Rpb24sIGZpbmRQb3NpdGlvbih0cmFuc2FjdGlvbiwgdGhpcywgaW5kZXgpLCBsZW5ndGgpXG4gICAgICB9KVxuICAgIH0gZWxzZSB7XG4gICAgICAvKiogQHR5cGUge0FycmF5PGZ1bmN0aW9uPn0gKi8gKHRoaXMuX3BlbmRpbmcpLnB1c2goKCkgPT4gdGhpcy5kZWxldGUoaW5kZXgsIGxlbmd0aCkpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFzc2lnbnMgcHJvcGVydGllcyB0byBhIHJhbmdlIG9mIHRleHQuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgcG9zaXRpb24gd2hlcmUgdG8gc3RhcnQgZm9ybWF0dGluZy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aCBUaGUgYW1vdW50IG9mIGNoYXJhY3RlcnMgdG8gYXNzaWduIHByb3BlcnRpZXMgdG8uXG4gICAqIEBwYXJhbSB7VGV4dEF0dHJpYnV0ZXN9IGF0dHJpYnV0ZXMgQXR0cmlidXRlIGluZm9ybWF0aW9uIHRvIGFwcGx5IG9uIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQuXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGZvcm1hdCAoaW5kZXgsIGxlbmd0aCwgYXR0cmlidXRlcykge1xuICAgIGlmIChsZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBjb25zdCB5ID0gdGhpcy5kb2NcbiAgICBpZiAoeSAhPT0gbnVsbCkge1xuICAgICAgdHJhbnNhY3QoeSwgdHJhbnNhY3Rpb24gPT4ge1xuICAgICAgICBjb25zdCBwb3MgPSBmaW5kUG9zaXRpb24odHJhbnNhY3Rpb24sIHRoaXMsIGluZGV4KVxuICAgICAgICBpZiAocG9zLnJpZ2h0ID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgZm9ybWF0VGV4dCh0cmFuc2FjdGlvbiwgdGhpcywgcG9zLCBsZW5ndGgsIGF0dHJpYnV0ZXMpXG4gICAgICB9KVxuICAgIH0gZWxzZSB7XG4gICAgICAvKiogQHR5cGUge0FycmF5PGZ1bmN0aW9uPn0gKi8gKHRoaXMuX3BlbmRpbmcpLnB1c2goKCkgPT4gdGhpcy5mb3JtYXQoaW5kZXgsIGxlbmd0aCwgYXR0cmlidXRlcykpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYW4gYXR0cmlidXRlLlxuICAgKlxuICAgKiBAbm90ZSBYbWwtVGV4dCBub2RlcyBkb24ndCBoYXZlIGF0dHJpYnV0ZXMuIFlvdSBjYW4gdXNlIHRoaXMgZmVhdHVyZSB0byBhc3NpZ24gcHJvcGVydGllcyB0byBjb21wbGV0ZSB0ZXh0LWJsb2Nrcy5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGF0dHJpYnV0ZU5hbWUgVGhlIGF0dHJpYnV0ZSBuYW1lIHRoYXQgaXMgdG8gYmUgcmVtb3ZlZC5cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgcmVtb3ZlQXR0cmlidXRlIChhdHRyaWJ1dGVOYW1lKSB7XG4gICAgaWYgKHRoaXMuZG9jICE9PSBudWxsKSB7XG4gICAgICB0cmFuc2FjdCh0aGlzLmRvYywgdHJhbnNhY3Rpb24gPT4ge1xuICAgICAgICB0eXBlTWFwRGVsZXRlKHRyYW5zYWN0aW9uLCB0aGlzLCBhdHRyaWJ1dGVOYW1lKVxuICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgLyoqIEB0eXBlIHtBcnJheTxmdW5jdGlvbj59ICovICh0aGlzLl9wZW5kaW5nKS5wdXNoKCgpID0+IHRoaXMucmVtb3ZlQXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIG9yIHVwZGF0ZXMgYW4gYXR0cmlidXRlLlxuICAgKlxuICAgKiBAbm90ZSBYbWwtVGV4dCBub2RlcyBkb24ndCBoYXZlIGF0dHJpYnV0ZXMuIFlvdSBjYW4gdXNlIHRoaXMgZmVhdHVyZSB0byBhc3NpZ24gcHJvcGVydGllcyB0byBjb21wbGV0ZSB0ZXh0LWJsb2Nrcy5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGF0dHJpYnV0ZU5hbWUgVGhlIGF0dHJpYnV0ZSBuYW1lIHRoYXQgaXMgdG8gYmUgc2V0LlxuICAgKiBAcGFyYW0ge2FueX0gYXR0cmlidXRlVmFsdWUgVGhlIGF0dHJpYnV0ZSB2YWx1ZSB0aGF0IGlzIHRvIGJlIHNldC5cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgc2V0QXR0cmlidXRlIChhdHRyaWJ1dGVOYW1lLCBhdHRyaWJ1dGVWYWx1ZSkge1xuICAgIGlmICh0aGlzLmRvYyAhPT0gbnVsbCkge1xuICAgICAgdHJhbnNhY3QodGhpcy5kb2MsIHRyYW5zYWN0aW9uID0+IHtcbiAgICAgICAgdHlwZU1hcFNldCh0cmFuc2FjdGlvbiwgdGhpcywgYXR0cmlidXRlTmFtZSwgYXR0cmlidXRlVmFsdWUpXG4gICAgICB9KVxuICAgIH0gZWxzZSB7XG4gICAgICAvKiogQHR5cGUge0FycmF5PGZ1bmN0aW9uPn0gKi8gKHRoaXMuX3BlbmRpbmcpLnB1c2goKCkgPT4gdGhpcy5zZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSwgYXR0cmlidXRlVmFsdWUpKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGF0dHJpYnV0ZSB2YWx1ZSB0aGF0IGJlbG9uZ3MgdG8gdGhlIGF0dHJpYnV0ZSBuYW1lLlxuICAgKlxuICAgKiBAbm90ZSBYbWwtVGV4dCBub2RlcyBkb24ndCBoYXZlIGF0dHJpYnV0ZXMuIFlvdSBjYW4gdXNlIHRoaXMgZmVhdHVyZSB0byBhc3NpZ24gcHJvcGVydGllcyB0byBjb21wbGV0ZSB0ZXh0LWJsb2Nrcy5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGF0dHJpYnV0ZU5hbWUgVGhlIGF0dHJpYnV0ZSBuYW1lIHRoYXQgaWRlbnRpZmllcyB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcmllZCB2YWx1ZS5cbiAgICogQHJldHVybiB7YW55fSBUaGUgcXVlcmllZCBhdHRyaWJ1dGUgdmFsdWUuXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGdldEF0dHJpYnV0ZSAoYXR0cmlidXRlTmFtZSkge1xuICAgIHJldHVybiAvKiogQHR5cGUge2FueX0gKi8gKHR5cGVNYXBHZXQodGhpcywgYXR0cmlidXRlTmFtZSkpXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbGwgYXR0cmlidXRlIG5hbWUvdmFsdWUgcGFpcnMgaW4gYSBKU09OIE9iamVjdC5cbiAgICpcbiAgICogQG5vdGUgWG1sLVRleHQgbm9kZXMgZG9uJ3QgaGF2ZSBhdHRyaWJ1dGVzLiBZb3UgY2FuIHVzZSB0aGlzIGZlYXR1cmUgdG8gYXNzaWduIHByb3BlcnRpZXMgdG8gY29tcGxldGUgdGV4dC1ibG9ja3MuXG4gICAqXG4gICAqIEByZXR1cm4ge09iamVjdDxzdHJpbmcsIGFueT59IEEgSlNPTiBPYmplY3QgdGhhdCBkZXNjcmliZXMgdGhlIGF0dHJpYnV0ZXMuXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGdldEF0dHJpYnV0ZXMgKCkge1xuICAgIHJldHVybiB0eXBlTWFwR2V0QWxsKHRoaXMpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtVcGRhdGVFbmNvZGVyVjEgfCBVcGRhdGVFbmNvZGVyVjJ9IGVuY29kZXJcbiAgICovXG4gIF93cml0ZSAoZW5jb2Rlcikge1xuICAgIGVuY29kZXIud3JpdGVUeXBlUmVmKFlUZXh0UmVmSUQpXG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1VwZGF0ZURlY29kZXJWMSB8IFVwZGF0ZURlY29kZXJWMn0gX2RlY29kZXJcbiAqIEByZXR1cm4ge1lUZXh0fVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IHJlYWRZVGV4dCA9IF9kZWNvZGVyID0+IG5ldyBZVGV4dCgpXG4iLCAiLyoqXG4gKiBAbW9kdWxlIFlYbWxcbiAqL1xuXG5pbXBvcnQge1xuICBZWG1sRXZlbnQsXG4gIFlYbWxFbGVtZW50LFxuICBBYnN0cmFjdFR5cGUsXG4gIHR5cGVMaXN0TWFwLFxuICB0eXBlTGlzdEZvckVhY2gsXG4gIHR5cGVMaXN0SW5zZXJ0R2VuZXJpY3MsXG4gIHR5cGVMaXN0SW5zZXJ0R2VuZXJpY3NBZnRlcixcbiAgdHlwZUxpc3REZWxldGUsXG4gIHR5cGVMaXN0VG9BcnJheSxcbiAgWVhtbEZyYWdtZW50UmVmSUQsXG4gIGNhbGxUeXBlT2JzZXJ2ZXJzLFxuICB0cmFuc2FjdCxcbiAgdHlwZUxpc3RHZXQsXG4gIHR5cGVMaXN0U2xpY2UsXG4gIFVwZGF0ZURlY29kZXJWMSwgVXBkYXRlRGVjb2RlclYyLCBVcGRhdGVFbmNvZGVyVjEsIFVwZGF0ZUVuY29kZXJWMiwgRG9jLCBDb250ZW50VHlwZSwgVHJhbnNhY3Rpb24sIEl0ZW0sIFlYbWxUZXh0LCBZWG1sSG9vayAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG59IGZyb20gJy4uL2ludGVybmFscy5qcydcblxuaW1wb3J0ICogYXMgZXJyb3IgZnJvbSAnbGliMC9lcnJvcidcbmltcG9ydCAqIGFzIGFycmF5IGZyb20gJ2xpYjAvYXJyYXknXG5cbi8qKlxuICogRGVmaW5lIHRoZSBlbGVtZW50cyB0byB3aGljaCBhIHNldCBvZiBDU1MgcXVlcmllcyBhcHBseS5cbiAqIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvQ1NTX1NlbGVjdG9yc3xDU1NfU2VsZWN0b3JzfVxuICpcbiAqIEBleGFtcGxlXG4gKiAgIHF1ZXJ5ID0gJy5jbGFzc1NlbGVjdG9yJ1xuICogICBxdWVyeSA9ICdub2RlU2VsZWN0b3InXG4gKiAgIHF1ZXJ5ID0gJyNpZFNlbGVjdG9yJ1xuICpcbiAqIEB0eXBlZGVmIHtzdHJpbmd9IENTU19TZWxlY3RvclxuICovXG5cbi8qKlxuICogRG9tIGZpbHRlciBmdW5jdGlvbi5cbiAqXG4gKiBAY2FsbGJhY2sgZG9tRmlsdGVyXG4gKiBAcGFyYW0ge3N0cmluZ30gbm9kZU5hbWUgVGhlIG5vZGVOYW1lIG9mIHRoZSBlbGVtZW50XG4gKiBAcGFyYW0ge01hcH0gYXR0cmlidXRlcyBUaGUgbWFwIG9mIGF0dHJpYnV0ZXMuXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRvIGluY2x1ZGUgdGhlIERvbSBub2RlIGluIHRoZSBZWG1sRWxlbWVudC5cbiAqL1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBzdWJzZXQgb2YgdGhlIG5vZGVzIG9mIGEgWVhtbEVsZW1lbnQgLyBZWG1sRnJhZ21lbnQgYW5kIGFcbiAqIHBvc2l0aW9uIHdpdGhpbiB0aGVtLlxuICpcbiAqIENhbiBiZSBjcmVhdGVkIHdpdGgge0BsaW5rIFlYbWxGcmFnbWVudCNjcmVhdGVUcmVlV2Fsa2VyfVxuICpcbiAqIEBwdWJsaWNcbiAqIEBpbXBsZW1lbnRzIHtJdGVyYWJsZTxZWG1sRWxlbWVudHxZWG1sVGV4dHxZWG1sRWxlbWVudHxZWG1sSG9vaz59XG4gKi9cbmV4cG9ydCBjbGFzcyBZWG1sVHJlZVdhbGtlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1lYbWxGcmFnbWVudCB8IFlYbWxFbGVtZW50fSByb290XG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oQWJzdHJhY3RUeXBlPGFueT4pOmJvb2xlYW59IFtmXVxuICAgKi9cbiAgY29uc3RydWN0b3IgKHJvb3QsIGYgPSAoKSA9PiB0cnVlKSB7XG4gICAgdGhpcy5fZmlsdGVyID0gZlxuICAgIHRoaXMuX3Jvb3QgPSByb290XG4gICAgLyoqXG4gICAgICogQHR5cGUge0l0ZW19XG4gICAgICovXG4gICAgdGhpcy5fY3VycmVudE5vZGUgPSAvKiogQHR5cGUge0l0ZW19ICovIChyb290Ll9zdGFydClcbiAgICB0aGlzLl9maXJzdENhbGwgPSB0cnVlXG4gIH1cblxuICBbU3ltYm9sLml0ZXJhdG9yXSAoKSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG5leHQgbm9kZS5cbiAgICpcbiAgICogQHJldHVybiB7SXRlcmF0b3JSZXN1bHQ8WVhtbEVsZW1lbnR8WVhtbFRleHR8WVhtbEhvb2s+fSBUaGUgbmV4dCBub2RlLlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBuZXh0ICgpIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7SXRlbXxudWxsfVxuICAgICAqL1xuICAgIGxldCBuID0gdGhpcy5fY3VycmVudE5vZGVcbiAgICBsZXQgdHlwZSA9IG4gJiYgbi5jb250ZW50ICYmIC8qKiBAdHlwZSB7YW55fSAqLyAobi5jb250ZW50KS50eXBlXG4gICAgaWYgKG4gIT09IG51bGwgJiYgKCF0aGlzLl9maXJzdENhbGwgfHwgbi5kZWxldGVkIHx8ICF0aGlzLl9maWx0ZXIodHlwZSkpKSB7IC8vIGlmIGZpcnN0IGNhbGwsIHdlIGNoZWNrIGlmIHdlIGNhbiB1c2UgdGhlIGZpcnN0IGl0ZW1cbiAgICAgIGRvIHtcbiAgICAgICAgdHlwZSA9IC8qKiBAdHlwZSB7YW55fSAqLyAobi5jb250ZW50KS50eXBlXG4gICAgICAgIGlmICghbi5kZWxldGVkICYmICh0eXBlLmNvbnN0cnVjdG9yID09PSBZWG1sRWxlbWVudCB8fCB0eXBlLmNvbnN0cnVjdG9yID09PSBZWG1sRnJhZ21lbnQpICYmIHR5cGUuX3N0YXJ0ICE9PSBudWxsKSB7XG4gICAgICAgICAgLy8gd2FsayBkb3duIGluIHRoZSB0cmVlXG4gICAgICAgICAgbiA9IHR5cGUuX3N0YXJ0XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gd2FsayByaWdodCBvciB1cCBpbiB0aGUgdHJlZVxuICAgICAgICAgIHdoaWxlIChuICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAobi5yaWdodCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICBuID0gbi5yaWdodFxuICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfSBlbHNlIGlmIChuLnBhcmVudCA9PT0gdGhpcy5fcm9vdCkge1xuICAgICAgICAgICAgICBuID0gbnVsbFxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbiA9IC8qKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT59ICovIChuLnBhcmVudCkuX2l0ZW1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gd2hpbGUgKG4gIT09IG51bGwgJiYgKG4uZGVsZXRlZCB8fCAhdGhpcy5fZmlsdGVyKC8qKiBAdHlwZSB7Q29udGVudFR5cGV9ICovIChuLmNvbnRlbnQpLnR5cGUpKSlcbiAgICB9XG4gICAgdGhpcy5fZmlyc3RDYWxsID0gZmFsc2VcbiAgICBpZiAobiA9PT0gbnVsbCkge1xuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9XG4gICAgfVxuICAgIHRoaXMuX2N1cnJlbnROb2RlID0gblxuICAgIHJldHVybiB7IHZhbHVlOiAvKiogQHR5cGUge2FueX0gKi8gKG4uY29udGVudCkudHlwZSwgZG9uZTogZmFsc2UgfVxuICB9XG59XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIGxpc3Qgb2Yge0BsaW5rIFlYbWxFbGVtZW50fS5hbmQge0BsaW5rIFlYbWxUZXh0fSB0eXBlcy5cbiAqIEEgWXhtbEZyYWdtZW50IGlzIHNpbWlsYXIgdG8gYSB7QGxpbmsgWVhtbEVsZW1lbnR9LCBidXQgaXQgZG9lcyBub3QgaGF2ZSBhXG4gKiBub2RlTmFtZSBhbmQgaXQgZG9lcyBub3QgaGF2ZSBhdHRyaWJ1dGVzLiBUaG91Z2ggaXQgY2FuIGJlIGJvdW5kIHRvIGEgRE9NXG4gKiBlbGVtZW50IC0gaW4gdGhpcyBjYXNlIHRoZSBhdHRyaWJ1dGVzIGFuZCB0aGUgbm9kZU5hbWUgYXJlIG5vdCBzaGFyZWQuXG4gKlxuICogQHB1YmxpY1xuICogQGV4dGVuZHMgQWJzdHJhY3RUeXBlPFlYbWxFdmVudD5cbiAqL1xuZXhwb3J0IGNsYXNzIFlYbWxGcmFnbWVudCBleHRlbmRzIEFic3RyYWN0VHlwZSB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICBzdXBlcigpXG4gICAgLyoqXG4gICAgICogQHR5cGUge0FycmF5PGFueT58bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLl9wcmVsaW1Db250ZW50ID0gW11cbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7WVhtbEVsZW1lbnR8WVhtbFRleHR8bnVsbH1cbiAgICovXG4gIGdldCBmaXJzdENoaWxkICgpIHtcbiAgICBjb25zdCBmaXJzdCA9IHRoaXMuX2ZpcnN0XG4gICAgcmV0dXJuIGZpcnN0ID8gZmlyc3QuY29udGVudC5nZXRDb250ZW50KClbMF0gOiBudWxsXG4gIH1cblxuICAvKipcbiAgICogSW50ZWdyYXRlIHRoaXMgdHlwZSBpbnRvIHRoZSBZanMgaW5zdGFuY2UuXG4gICAqXG4gICAqICogU2F2ZSB0aGlzIHN0cnVjdCBpbiB0aGUgb3NcbiAgICogKiBUaGlzIHR5cGUgaXMgc2VudCB0byBvdGhlciBjbGllbnRcbiAgICogKiBPYnNlcnZlciBmdW5jdGlvbnMgYXJlIGZpcmVkXG4gICAqXG4gICAqIEBwYXJhbSB7RG9jfSB5IFRoZSBZanMgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtJdGVtfSBpdGVtXG4gICAqL1xuICBfaW50ZWdyYXRlICh5LCBpdGVtKSB7XG4gICAgc3VwZXIuX2ludGVncmF0ZSh5LCBpdGVtKVxuICAgIHRoaXMuaW5zZXJ0KDAsIC8qKiBAdHlwZSB7QXJyYXk8YW55Pn0gKi8gKHRoaXMuX3ByZWxpbUNvbnRlbnQpKVxuICAgIHRoaXMuX3ByZWxpbUNvbnRlbnQgPSBudWxsXG4gIH1cblxuICBfY29weSAoKSB7XG4gICAgcmV0dXJuIG5ldyBZWG1sRnJhZ21lbnQoKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge1lYbWxGcmFnbWVudH1cbiAgICovXG4gIGNsb25lICgpIHtcbiAgICBjb25zdCBlbCA9IG5ldyBZWG1sRnJhZ21lbnQoKVxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBlbC5pbnNlcnQoMCwgdGhpcy50b0FycmF5KCkubWFwKGl0ZW0gPT4gaXRlbSBpbnN0YW5jZW9mIEFic3RyYWN0VHlwZSA/IGl0ZW0uY2xvbmUoKSA6IGl0ZW0pKVxuICAgIHJldHVybiBlbFxuICB9XG5cbiAgZ2V0IGxlbmd0aCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ByZWxpbUNvbnRlbnQgPT09IG51bGwgPyB0aGlzLl9sZW5ndGggOiB0aGlzLl9wcmVsaW1Db250ZW50Lmxlbmd0aFxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHN1YnRyZWUgb2YgY2hpbGROb2Rlcy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogY29uc3Qgd2Fsa2VyID0gZWxlbS5jcmVhdGVUcmVlV2Fsa2VyKGRvbSA9PiBkb20ubm9kZU5hbWUgPT09ICdkaXYnKVxuICAgKiBmb3IgKGxldCBub2RlIGluIHdhbGtlcikge1xuICAgKiAgIC8vIGBub2RlYCBpcyBhIGRpdiBub2RlXG4gICAqICAgbm9wKG5vZGUpXG4gICAqIH1cbiAgICpcbiAgICogQHBhcmFtIHtmdW5jdGlvbihBYnN0cmFjdFR5cGU8YW55Pik6Ym9vbGVhbn0gZmlsdGVyIEZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIG9uIGVhY2ggY2hpbGQgZWxlbWVudCBhbmRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybnMgYSBCb29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgY2hpbGRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIGlzIHRvIGJlIGluY2x1ZGVkIGluIHRoZSBzdWJ0cmVlLlxuICAgKiBAcmV0dXJuIHtZWG1sVHJlZVdhbGtlcn0gQSBzdWJ0cmVlIGFuZCBhIHBvc2l0aW9uIHdpdGhpbiBpdC5cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgY3JlYXRlVHJlZVdhbGtlciAoZmlsdGVyKSB7XG4gICAgcmV0dXJuIG5ldyBZWG1sVHJlZVdhbGtlcih0aGlzLCBmaWx0ZXIpXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZmlyc3QgWVhtbEVsZW1lbnQgdGhhdCBtYXRjaGVzIHRoZSBxdWVyeS5cbiAgICogU2ltaWxhciB0byBET00ncyB7QGxpbmsgcXVlcnlTZWxlY3Rvcn0uXG4gICAqXG4gICAqIFF1ZXJ5IHN1cHBvcnQ6XG4gICAqICAgLSB0YWduYW1lXG4gICAqIFRPRE86XG4gICAqICAgLSBpZFxuICAgKiAgIC0gYXR0cmlidXRlXG4gICAqXG4gICAqIEBwYXJhbSB7Q1NTX1NlbGVjdG9yfSBxdWVyeSBUaGUgcXVlcnkgb24gdGhlIGNoaWxkcmVuLlxuICAgKiBAcmV0dXJuIHtZWG1sRWxlbWVudHxZWG1sVGV4dHxZWG1sSG9va3xudWxsfSBUaGUgZmlyc3QgZWxlbWVudCB0aGF0IG1hdGNoZXMgdGhlIHF1ZXJ5IG9yIG51bGwuXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHF1ZXJ5U2VsZWN0b3IgKHF1ZXJ5KSB7XG4gICAgcXVlcnkgPSBxdWVyeS50b1VwcGVyQ2FzZSgpXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGNvbnN0IGl0ZXJhdG9yID0gbmV3IFlYbWxUcmVlV2Fsa2VyKHRoaXMsIGVsZW1lbnQgPT4gZWxlbWVudC5ub2RlTmFtZSAmJiBlbGVtZW50Lm5vZGVOYW1lLnRvVXBwZXJDYXNlKCkgPT09IHF1ZXJ5KVxuICAgIGNvbnN0IG5leHQgPSBpdGVyYXRvci5uZXh0KClcbiAgICBpZiAobmV4dC5kb25lKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV4dC52YWx1ZVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFsbCBZWG1sRWxlbWVudHMgdGhhdCBtYXRjaCB0aGUgcXVlcnkuXG4gICAqIFNpbWlsYXIgdG8gRG9tJ3Mge0BsaW5rIHF1ZXJ5U2VsZWN0b3JBbGx9LlxuICAgKlxuICAgKiBAdG9kbyBEb2VzIG5vdCB5ZXQgc3VwcG9ydCBhbGwgcXVlcmllcy4gQ3VycmVudGx5IG9ubHkgcXVlcnkgYnkgdGFnTmFtZS5cbiAgICpcbiAgICogQHBhcmFtIHtDU1NfU2VsZWN0b3J9IHF1ZXJ5IFRoZSBxdWVyeSBvbiB0aGUgY2hpbGRyZW5cbiAgICogQHJldHVybiB7QXJyYXk8WVhtbEVsZW1lbnR8WVhtbFRleHR8WVhtbEhvb2t8bnVsbD59IFRoZSBlbGVtZW50cyB0aGF0IG1hdGNoIHRoaXMgcXVlcnkuXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHF1ZXJ5U2VsZWN0b3JBbGwgKHF1ZXJ5KSB7XG4gICAgcXVlcnkgPSBxdWVyeS50b1VwcGVyQ2FzZSgpXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHJldHVybiBhcnJheS5mcm9tKG5ldyBZWG1sVHJlZVdhbGtlcih0aGlzLCBlbGVtZW50ID0+IGVsZW1lbnQubm9kZU5hbWUgJiYgZWxlbWVudC5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpID09PSBxdWVyeSkpXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBZWG1sRXZlbnQgYW5kIGNhbGxzIG9ic2VydmVycy5cbiAgICpcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtTZXQ8bnVsbHxzdHJpbmc+fSBwYXJlbnRTdWJzIEtleXMgY2hhbmdlZCBvbiB0aGlzIHR5cGUuIGBudWxsYCBpZiBsaXN0IHdhcyBtb2RpZmllZC5cbiAgICovXG4gIF9jYWxsT2JzZXJ2ZXIgKHRyYW5zYWN0aW9uLCBwYXJlbnRTdWJzKSB7XG4gICAgY2FsbFR5cGVPYnNlcnZlcnModGhpcywgdHJhbnNhY3Rpb24sIG5ldyBZWG1sRXZlbnQodGhpcywgcGFyZW50U3VicywgdHJhbnNhY3Rpb24pKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGFsbCB0aGUgY2hpbGRyZW4gb2YgdGhpcyBZWG1sRnJhZ21lbnQuXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhbGwgY2hpbGRyZW4uXG4gICAqL1xuICB0b1N0cmluZyAoKSB7XG4gICAgcmV0dXJuIHR5cGVMaXN0TWFwKHRoaXMsIHhtbCA9PiB4bWwudG9TdHJpbmcoKSkuam9pbignJylcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b0pTT04gKCkge1xuICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKClcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgRG9tIEVsZW1lbnQgdGhhdCBtaXJyb3JzIHRoaXMgWVhtbEVsZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7RG9jdW1lbnR9IFtfZG9jdW1lbnQ9ZG9jdW1lbnRdIFRoZSBkb2N1bWVudCBvYmplY3QgKHlvdSBtdXN0IGRlZmluZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzIHdoZW4gY2FsbGluZyB0aGlzIG1ldGhvZCBpblxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlanMpXG4gICAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZywgYW55Pn0gW2hvb2tzPXt9XSBPcHRpb25hbCBwcm9wZXJ0eSB0byBjdXN0b21pemUgaG93IGhvb2tzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJlIHByZXNlbnRlZCBpbiB0aGUgRE9NXG4gICAqIEBwYXJhbSB7YW55fSBbYmluZGluZ10gWW91IHNob3VsZCBub3Qgc2V0IHRoaXMgcHJvcGVydHkuIFRoaXMgaXNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlZCBpZiBEb21CaW5kaW5nIHdhbnRzIHRvIGNyZWF0ZSBhXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc29jaWF0aW9uIHRvIHRoZSBjcmVhdGVkIERPTSB0eXBlLlxuICAgKiBAcmV0dXJuIHtOb2RlfSBUaGUge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FbGVtZW50fERvbSBFbGVtZW50fVxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICB0b0RPTSAoX2RvY3VtZW50ID0gZG9jdW1lbnQsIGhvb2tzID0ge30sIGJpbmRpbmcpIHtcbiAgICBjb25zdCBmcmFnbWVudCA9IF9kb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KClcbiAgICBpZiAoYmluZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBiaW5kaW5nLl9jcmVhdGVBc3NvY2lhdGlvbihmcmFnbWVudCwgdGhpcylcbiAgICB9XG4gICAgdHlwZUxpc3RGb3JFYWNoKHRoaXMsIHhtbFR5cGUgPT4ge1xuICAgICAgZnJhZ21lbnQuaW5zZXJ0QmVmb3JlKHhtbFR5cGUudG9ET00oX2RvY3VtZW50LCBob29rcywgYmluZGluZyksIG51bGwpXG4gICAgfSlcbiAgICByZXR1cm4gZnJhZ21lbnRcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnNlcnRzIG5ldyBjb250ZW50IGF0IGFuIGluZGV4LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAgLy8gSW5zZXJ0IGNoYXJhY3RlciAnYScgYXQgcG9zaXRpb24gMFxuICAgKiAgeG1sLmluc2VydCgwLCBbbmV3IFkuWG1sVGV4dCgndGV4dCcpXSlcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBpbmRleCB0byBpbnNlcnQgY29udGVudCBhdFxuICAgKiBAcGFyYW0ge0FycmF5PFlYbWxFbGVtZW50fFlYbWxUZXh0Pn0gY29udGVudCBUaGUgYXJyYXkgb2YgY29udGVudFxuICAgKi9cbiAgaW5zZXJ0IChpbmRleCwgY29udGVudCkge1xuICAgIGlmICh0aGlzLmRvYyAhPT0gbnVsbCkge1xuICAgICAgdHJhbnNhY3QodGhpcy5kb2MsIHRyYW5zYWN0aW9uID0+IHtcbiAgICAgICAgdHlwZUxpc3RJbnNlcnRHZW5lcmljcyh0cmFuc2FjdGlvbiwgdGhpcywgaW5kZXgsIGNvbnRlbnQpXG4gICAgICB9KVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBAdHMtaWdub3JlIF9wcmVsaW1Db250ZW50IGlzIGRlZmluZWQgYmVjYXVzZSB0aGlzIGlzIG5vdCB5ZXQgaW50ZWdyYXRlZFxuICAgICAgdGhpcy5fcHJlbGltQ29udGVudC5zcGxpY2UoaW5kZXgsIDAsIC4uLmNvbnRlbnQpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEluc2VydHMgbmV3IGNvbnRlbnQgYXQgYW4gaW5kZXguXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqICAvLyBJbnNlcnQgY2hhcmFjdGVyICdhJyBhdCBwb3NpdGlvbiAwXG4gICAqICB4bWwuaW5zZXJ0KDAsIFtuZXcgWS5YbWxUZXh0KCd0ZXh0JyldKVxuICAgKlxuICAgKiBAcGFyYW0ge251bGx8SXRlbXxZWG1sRWxlbWVudHxZWG1sVGV4dH0gcmVmIFRoZSBpbmRleCB0byBpbnNlcnQgY29udGVudCBhdFxuICAgKiBAcGFyYW0ge0FycmF5PFlYbWxFbGVtZW50fFlYbWxUZXh0Pn0gY29udGVudCBUaGUgYXJyYXkgb2YgY29udGVudFxuICAgKi9cbiAgaW5zZXJ0QWZ0ZXIgKHJlZiwgY29udGVudCkge1xuICAgIGlmICh0aGlzLmRvYyAhPT0gbnVsbCkge1xuICAgICAgdHJhbnNhY3QodGhpcy5kb2MsIHRyYW5zYWN0aW9uID0+IHtcbiAgICAgICAgY29uc3QgcmVmSXRlbSA9IChyZWYgJiYgcmVmIGluc3RhbmNlb2YgQWJzdHJhY3RUeXBlKSA/IHJlZi5faXRlbSA6IHJlZlxuICAgICAgICB0eXBlTGlzdEluc2VydEdlbmVyaWNzQWZ0ZXIodHJhbnNhY3Rpb24sIHRoaXMsIHJlZkl0ZW0sIGNvbnRlbnQpXG4gICAgICB9KVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBwYyA9IC8qKiBAdHlwZSB7QXJyYXk8YW55Pn0gKi8gKHRoaXMuX3ByZWxpbUNvbnRlbnQpXG4gICAgICBjb25zdCBpbmRleCA9IHJlZiA9PT0gbnVsbCA/IDAgOiBwYy5maW5kSW5kZXgoZWwgPT4gZWwgPT09IHJlZikgKyAxXG4gICAgICBpZiAoaW5kZXggPT09IDAgJiYgcmVmICE9PSBudWxsKSB7XG4gICAgICAgIHRocm93IGVycm9yLmNyZWF0ZSgnUmVmZXJlbmNlIGl0ZW0gbm90IGZvdW5kJylcbiAgICAgIH1cbiAgICAgIHBjLnNwbGljZShpbmRleCwgMCwgLi4uY29udGVudClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGVsZXRlcyBlbGVtZW50cyBzdGFydGluZyBmcm9tIGFuIGluZGV4LlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggSW5kZXggYXQgd2hpY2ggdG8gc3RhcnQgZGVsZXRpbmcgZWxlbWVudHNcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9MV0gVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byByZW1vdmUuIERlZmF1bHRzIHRvIDEuXG4gICAqL1xuICBkZWxldGUgKGluZGV4LCBsZW5ndGggPSAxKSB7XG4gICAgaWYgKHRoaXMuZG9jICE9PSBudWxsKSB7XG4gICAgICB0cmFuc2FjdCh0aGlzLmRvYywgdHJhbnNhY3Rpb24gPT4ge1xuICAgICAgICB0eXBlTGlzdERlbGV0ZSh0cmFuc2FjdGlvbiwgdGhpcywgaW5kZXgsIGxlbmd0aClcbiAgICAgIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEB0cy1pZ25vcmUgX3ByZWxpbUNvbnRlbnQgaXMgZGVmaW5lZCBiZWNhdXNlIHRoaXMgaXMgbm90IHlldCBpbnRlZ3JhdGVkXG4gICAgICB0aGlzLl9wcmVsaW1Db250ZW50LnNwbGljZShpbmRleCwgbGVuZ3RoKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUcmFuc2Zvcm1zIHRoaXMgWUFycmF5IHRvIGEgSmF2YVNjcmlwdCBBcnJheS5cbiAgICpcbiAgICogQHJldHVybiB7QXJyYXk8WVhtbEVsZW1lbnR8WVhtbFRleHR8WVhtbEhvb2s+fVxuICAgKi9cbiAgdG9BcnJheSAoKSB7XG4gICAgcmV0dXJuIHR5cGVMaXN0VG9BcnJheSh0aGlzKVxuICB9XG5cbiAgLyoqXG4gICAqIEFwcGVuZHMgY29udGVudCB0byB0aGlzIFlBcnJheS5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheTxZWG1sRWxlbWVudHxZWG1sVGV4dD59IGNvbnRlbnQgQXJyYXkgb2YgY29udGVudCB0byBhcHBlbmQuXG4gICAqL1xuICBwdXNoIChjb250ZW50KSB7XG4gICAgdGhpcy5pbnNlcnQodGhpcy5sZW5ndGgsIGNvbnRlbnQpXG4gIH1cblxuICAvKipcbiAgICogUHJlcHBlbmRzIGNvbnRlbnQgdG8gdGhpcyBZQXJyYXkuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXk8WVhtbEVsZW1lbnR8WVhtbFRleHQ+fSBjb250ZW50IEFycmF5IG9mIGNvbnRlbnQgdG8gcHJlcHBlbmQuXG4gICAqL1xuICB1bnNoaWZ0IChjb250ZW50KSB7XG4gICAgdGhpcy5pbnNlcnQoMCwgY29udGVudClcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpLXRoIGVsZW1lbnQgZnJvbSBhIFlBcnJheS5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBpbmRleCBvZiB0aGUgZWxlbWVudCB0byByZXR1cm4gZnJvbSB0aGUgWUFycmF5XG4gICAqIEByZXR1cm4ge1lYbWxFbGVtZW50fFlYbWxUZXh0fVxuICAgKi9cbiAgZ2V0IChpbmRleCkge1xuICAgIHJldHVybiB0eXBlTGlzdEdldCh0aGlzLCBpbmRleClcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmFuc2Zvcm1zIHRoaXMgWUFycmF5IHRvIGEgSmF2YVNjcmlwdCBBcnJheS5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydF1cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtlbmRdXG4gICAqIEByZXR1cm4ge0FycmF5PFlYbWxFbGVtZW50fFlYbWxUZXh0Pn1cbiAgICovXG4gIHNsaWNlIChzdGFydCA9IDAsIGVuZCA9IHRoaXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHR5cGVMaXN0U2xpY2UodGhpcywgc3RhcnQsIGVuZClcbiAgfVxuXG4gIC8qKlxuICAgKiBFeGVjdXRlcyBhIHByb3ZpZGVkIGZ1bmN0aW9uIG9uIG9uY2Ugb24gb3ZlcnkgY2hpbGQgZWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtmdW5jdGlvbihZWG1sRWxlbWVudHxZWG1sVGV4dCxudW1iZXIsIHR5cGVvZiBzZWxmKTp2b2lkfSBmIEEgZnVuY3Rpb24gdG8gZXhlY3V0ZSBvbiBldmVyeSBlbGVtZW50IG9mIHRoaXMgWUFycmF5LlxuICAgKi9cbiAgZm9yRWFjaCAoZikge1xuICAgIHR5cGVMaXN0Rm9yRWFjaCh0aGlzLCBmKVxuICB9XG5cbiAgLyoqXG4gICAqIFRyYW5zZm9ybSB0aGUgcHJvcGVydGllcyBvZiB0aGlzIHR5cGUgdG8gYmluYXJ5IGFuZCB3cml0ZSBpdCB0byBhblxuICAgKiBCaW5hcnlFbmNvZGVyLlxuICAgKlxuICAgKiBUaGlzIGlzIGNhbGxlZCB3aGVuIHRoaXMgSXRlbSBpcyBzZW50IHRvIGEgcmVtb3RlIHBlZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7VXBkYXRlRW5jb2RlclYxIHwgVXBkYXRlRW5jb2RlclYyfSBlbmNvZGVyIFRoZSBlbmNvZGVyIHRvIHdyaXRlIGRhdGEgdG8uXG4gICAqL1xuICBfd3JpdGUgKGVuY29kZXIpIHtcbiAgICBlbmNvZGVyLndyaXRlVHlwZVJlZihZWG1sRnJhZ21lbnRSZWZJRClcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7VXBkYXRlRGVjb2RlclYxIHwgVXBkYXRlRGVjb2RlclYyfSBfZGVjb2RlclxuICogQHJldHVybiB7WVhtbEZyYWdtZW50fVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IHJlYWRZWG1sRnJhZ21lbnQgPSBfZGVjb2RlciA9PiBuZXcgWVhtbEZyYWdtZW50KClcbiIsICJpbXBvcnQgKiBhcyBvYmplY3QgZnJvbSAnbGliMC9vYmplY3QnXG5cbmltcG9ydCB7XG4gIFlYbWxGcmFnbWVudCxcbiAgdHJhbnNhY3QsXG4gIHR5cGVNYXBEZWxldGUsXG4gIHR5cGVNYXBIYXMsXG4gIHR5cGVNYXBTZXQsXG4gIHR5cGVNYXBHZXQsXG4gIHR5cGVNYXBHZXRBbGwsXG4gIHR5cGVMaXN0Rm9yRWFjaCxcbiAgWVhtbEVsZW1lbnRSZWZJRCxcbiAgWVhtbFRleHQsIENvbnRlbnRUeXBlLCBBYnN0cmFjdFR5cGUsIFVwZGF0ZURlY29kZXJWMSwgVXBkYXRlRGVjb2RlclYyLCBVcGRhdGVFbmNvZGVyVjEsIFVwZGF0ZUVuY29kZXJWMiwgRG9jLCBJdGVtIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbn0gZnJvbSAnLi4vaW50ZXJuYWxzLmpzJ1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R8bnVtYmVyfG51bGx8QXJyYXk8YW55PnxzdHJpbmd8VWludDhBcnJheXxBYnN0cmFjdFR5cGU8YW55Pn0gVmFsdWVUeXBlc1xuICovXG5cbi8qKlxuICogQW4gWVhtbEVsZW1lbnQgaW1pdGF0ZXMgdGhlIGJlaGF2aW9yIG9mIGFcbiAqIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRWxlbWVudHxEb20gRWxlbWVudH0uXG4gKlxuICogKiBBbiBZWG1sRWxlbWVudCBoYXMgYXR0cmlidXRlcyAoa2V5IHZhbHVlIHBhaXJzKVxuICogKiBBbiBZWG1sRWxlbWVudCBoYXMgY2hpbGRFbGVtZW50cyB0aGF0IG11c3QgaW5oZXJpdCBmcm9tIFlYbWxFbGVtZW50XG4gKlxuICogQHRlbXBsYXRlIHt7IFtrZXk6IHN0cmluZ106IFZhbHVlVHlwZXMgfX0gW0tWPXsgW2tleTogc3RyaW5nXTogc3RyaW5nIH1dXG4gKi9cbmV4cG9ydCBjbGFzcyBZWG1sRWxlbWVudCBleHRlbmRzIFlYbWxGcmFnbWVudCB7XG4gIGNvbnN0cnVjdG9yIChub2RlTmFtZSA9ICdVTkRFRklORUQnKSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMubm9kZU5hbWUgPSBub2RlTmFtZVxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtNYXA8c3RyaW5nLCBhbnk+fG51bGx9XG4gICAgICovXG4gICAgdGhpcy5fcHJlbGltQXR0cnMgPSBuZXcgTWFwKClcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7WVhtbEVsZW1lbnR8WVhtbFRleHR8bnVsbH1cbiAgICovXG4gIGdldCBuZXh0U2libGluZyAoKSB7XG4gICAgY29uc3QgbiA9IHRoaXMuX2l0ZW0gPyB0aGlzLl9pdGVtLm5leHQgOiBudWxsXG4gICAgcmV0dXJuIG4gPyAvKiogQHR5cGUge1lYbWxFbGVtZW50fFlYbWxUZXh0fSAqLyAoLyoqIEB0eXBlIHtDb250ZW50VHlwZX0gKi8gKG4uY29udGVudCkudHlwZSkgOiBudWxsXG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge1lYbWxFbGVtZW50fFlYbWxUZXh0fG51bGx9XG4gICAqL1xuICBnZXQgcHJldlNpYmxpbmcgKCkge1xuICAgIGNvbnN0IG4gPSB0aGlzLl9pdGVtID8gdGhpcy5faXRlbS5wcmV2IDogbnVsbFxuICAgIHJldHVybiBuID8gLyoqIEB0eXBlIHtZWG1sRWxlbWVudHxZWG1sVGV4dH0gKi8gKC8qKiBAdHlwZSB7Q29udGVudFR5cGV9ICovIChuLmNvbnRlbnQpLnR5cGUpIDogbnVsbFxuICB9XG5cbiAgLyoqXG4gICAqIEludGVncmF0ZSB0aGlzIHR5cGUgaW50byB0aGUgWWpzIGluc3RhbmNlLlxuICAgKlxuICAgKiAqIFNhdmUgdGhpcyBzdHJ1Y3QgaW4gdGhlIG9zXG4gICAqICogVGhpcyB0eXBlIGlzIHNlbnQgdG8gb3RoZXIgY2xpZW50XG4gICAqICogT2JzZXJ2ZXIgZnVuY3Rpb25zIGFyZSBmaXJlZFxuICAgKlxuICAgKiBAcGFyYW0ge0RvY30geSBUaGUgWWpzIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7SXRlbX0gaXRlbVxuICAgKi9cbiAgX2ludGVncmF0ZSAoeSwgaXRlbSkge1xuICAgIHN1cGVyLl9pbnRlZ3JhdGUoeSwgaXRlbSlcbiAgICA7KC8qKiBAdHlwZSB7TWFwPHN0cmluZywgYW55Pn0gKi8gKHRoaXMuX3ByZWxpbUF0dHJzKSkuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSlcbiAgICB9KVxuICAgIHRoaXMuX3ByZWxpbUF0dHJzID0gbnVsbFxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gSXRlbSB3aXRoIHRoZSBzYW1lIGVmZmVjdCBhcyB0aGlzIEl0ZW0gKHdpdGhvdXQgcG9zaXRpb24gZWZmZWN0KVxuICAgKlxuICAgKiBAcmV0dXJuIHtZWG1sRWxlbWVudH1cbiAgICovXG4gIF9jb3B5ICgpIHtcbiAgICByZXR1cm4gbmV3IFlYbWxFbGVtZW50KHRoaXMubm9kZU5hbWUpXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7WVhtbEVsZW1lbnQ8S1Y+fVxuICAgKi9cbiAgY2xvbmUgKCkge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtZWG1sRWxlbWVudDxLVj59XG4gICAgICovXG4gICAgY29uc3QgZWwgPSBuZXcgWVhtbEVsZW1lbnQodGhpcy5ub2RlTmFtZSlcbiAgICBjb25zdCBhdHRycyA9IHRoaXMuZ2V0QXR0cmlidXRlcygpXG4gICAgb2JqZWN0LmZvckVhY2goYXR0cnMsICh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSlcbiAgICAgIH1cbiAgICB9KVxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBlbC5pbnNlcnQoMCwgdGhpcy50b0FycmF5KCkubWFwKGl0ZW0gPT4gaXRlbSBpbnN0YW5jZW9mIEFic3RyYWN0VHlwZSA/IGl0ZW0uY2xvbmUoKSA6IGl0ZW0pKVxuICAgIHJldHVybiBlbFxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIFhNTCBzZXJpYWxpemF0aW9uIG9mIHRoaXMgWVhtbEVsZW1lbnQuXG4gICAqIFRoZSBhdHRyaWJ1dGVzIGFyZSBvcmRlcmVkIGJ5IGF0dHJpYnV0ZS1uYW1lLCBzbyB5b3UgY2FuIGVhc2lseSB1c2UgdGhpc1xuICAgKiBtZXRob2QgdG8gY29tcGFyZSBZWG1sRWxlbWVudHNcbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgdHlwZS5cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgdG9TdHJpbmcgKCkge1xuICAgIGNvbnN0IGF0dHJzID0gdGhpcy5nZXRBdHRyaWJ1dGVzKClcbiAgICBjb25zdCBzdHJpbmdCdWlsZGVyID0gW11cbiAgICBjb25zdCBrZXlzID0gW11cbiAgICBmb3IgKGNvbnN0IGtleSBpbiBhdHRycykge1xuICAgICAga2V5cy5wdXNoKGtleSlcbiAgICB9XG4gICAga2V5cy5zb3J0KClcbiAgICBjb25zdCBrZXlzTGVuID0ga2V5cy5sZW5ndGhcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXNMZW47IGkrKykge1xuICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXVxuICAgICAgc3RyaW5nQnVpbGRlci5wdXNoKGtleSArICc9XCInICsgYXR0cnNba2V5XSArICdcIicpXG4gICAgfVxuICAgIGNvbnN0IG5vZGVOYW1lID0gdGhpcy5ub2RlTmFtZS50b0xvY2FsZUxvd2VyQ2FzZSgpXG4gICAgY29uc3QgYXR0cnNTdHJpbmcgPSBzdHJpbmdCdWlsZGVyLmxlbmd0aCA+IDAgPyAnICcgKyBzdHJpbmdCdWlsZGVyLmpvaW4oJyAnKSA6ICcnXG4gICAgcmV0dXJuIGA8JHtub2RlTmFtZX0ke2F0dHJzU3RyaW5nfT4ke3N1cGVyLnRvU3RyaW5nKCl9PC8ke25vZGVOYW1lfT5gXG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBhbiBhdHRyaWJ1dGUgZnJvbSB0aGlzIFlYbWxFbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlTmFtZSBUaGUgYXR0cmlidXRlIG5hbWUgdGhhdCBpcyB0byBiZSByZW1vdmVkLlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICByZW1vdmVBdHRyaWJ1dGUgKGF0dHJpYnV0ZU5hbWUpIHtcbiAgICBpZiAodGhpcy5kb2MgIT09IG51bGwpIHtcbiAgICAgIHRyYW5zYWN0KHRoaXMuZG9jLCB0cmFuc2FjdGlvbiA9PiB7XG4gICAgICAgIHR5cGVNYXBEZWxldGUodHJhbnNhY3Rpb24sIHRoaXMsIGF0dHJpYnV0ZU5hbWUpXG4gICAgICB9KVxuICAgIH0gZWxzZSB7XG4gICAgICAvKiogQHR5cGUge01hcDxzdHJpbmcsYW55Pn0gKi8gKHRoaXMuX3ByZWxpbUF0dHJzKS5kZWxldGUoYXR0cmlidXRlTmFtZSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2V0cyBvciB1cGRhdGVzIGFuIGF0dHJpYnV0ZS5cbiAgICpcbiAgICogQHRlbXBsYXRlIHtrZXlvZiBLViAmIHN0cmluZ30gS0VZXG4gICAqXG4gICAqIEBwYXJhbSB7S0VZfSBhdHRyaWJ1dGVOYW1lIFRoZSBhdHRyaWJ1dGUgbmFtZSB0aGF0IGlzIHRvIGJlIHNldC5cbiAgICogQHBhcmFtIHtLVltLRVldfSBhdHRyaWJ1dGVWYWx1ZSBUaGUgYXR0cmlidXRlIHZhbHVlIHRoYXQgaXMgdG8gYmUgc2V0LlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBzZXRBdHRyaWJ1dGUgKGF0dHJpYnV0ZU5hbWUsIGF0dHJpYnV0ZVZhbHVlKSB7XG4gICAgaWYgKHRoaXMuZG9jICE9PSBudWxsKSB7XG4gICAgICB0cmFuc2FjdCh0aGlzLmRvYywgdHJhbnNhY3Rpb24gPT4ge1xuICAgICAgICB0eXBlTWFwU2V0KHRyYW5zYWN0aW9uLCB0aGlzLCBhdHRyaWJ1dGVOYW1lLCBhdHRyaWJ1dGVWYWx1ZSlcbiAgICAgIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIC8qKiBAdHlwZSB7TWFwPHN0cmluZywgYW55Pn0gKi8gKHRoaXMuX3ByZWxpbUF0dHJzKS5zZXQoYXR0cmlidXRlTmFtZSwgYXR0cmlidXRlVmFsdWUpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gYXR0cmlidXRlIHZhbHVlIHRoYXQgYmVsb25ncyB0byB0aGUgYXR0cmlidXRlIG5hbWUuXG4gICAqXG4gICAqIEB0ZW1wbGF0ZSB7a2V5b2YgS1YgJiBzdHJpbmd9IEtFWVxuICAgKlxuICAgKiBAcGFyYW0ge0tFWX0gYXR0cmlidXRlTmFtZSBUaGUgYXR0cmlidXRlIG5hbWUgdGhhdCBpZGVudGlmaWVzIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyaWVkIHZhbHVlLlxuICAgKiBAcmV0dXJuIHtLVltLRVldfHVuZGVmaW5lZH0gVGhlIHF1ZXJpZWQgYXR0cmlidXRlIHZhbHVlLlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBnZXRBdHRyaWJ1dGUgKGF0dHJpYnV0ZU5hbWUpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHthbnl9ICovICh0eXBlTWFwR2V0KHRoaXMsIGF0dHJpYnV0ZU5hbWUpKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciBhbiBhdHRyaWJ1dGUgZXhpc3RzXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyaWJ1dGVOYW1lIFRoZSBhdHRyaWJ1dGUgbmFtZSB0byBjaGVjayBmb3IgZXhpc3RlbmNlLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSB3aGV0aGVyIHRoZSBhdHRyaWJ1dGUgZXhpc3RzLlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBoYXNBdHRyaWJ1dGUgKGF0dHJpYnV0ZU5hbWUpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHthbnl9ICovICh0eXBlTWFwSGFzKHRoaXMsIGF0dHJpYnV0ZU5hbWUpKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYWxsIGF0dHJpYnV0ZSBuYW1lL3ZhbHVlIHBhaXJzIGluIGEgSlNPTiBPYmplY3QuXG4gICAqXG4gICAqIEByZXR1cm4ge3sgW0tleSBpbiBFeHRyYWN0PGtleW9mIEtWLHN0cmluZz5dPzogS1ZbS2V5XX19IEEgSlNPTiBPYmplY3QgdGhhdCBkZXNjcmliZXMgdGhlIGF0dHJpYnV0ZXMuXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGdldEF0dHJpYnV0ZXMgKCkge1xuICAgIHJldHVybiAvKiogQHR5cGUge2FueX0gKi8gKHR5cGVNYXBHZXRBbGwodGhpcykpXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIERvbSBFbGVtZW50IHRoYXQgbWlycm9ycyB0aGlzIFlYbWxFbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge0RvY3VtZW50fSBbX2RvY3VtZW50PWRvY3VtZW50XSBUaGUgZG9jdW1lbnQgb2JqZWN0ICh5b3UgbXVzdCBkZWZpbmVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcyB3aGVuIGNhbGxpbmcgdGhpcyBtZXRob2QgaW5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZWpzKVxuICAgKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsIGFueT59IFtob29rcz17fV0gT3B0aW9uYWwgcHJvcGVydHkgdG8gY3VzdG9taXplIGhvdyBob29rc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZSBwcmVzZW50ZWQgaW4gdGhlIERPTVxuICAgKiBAcGFyYW0ge2FueX0gW2JpbmRpbmddIFlvdSBzaG91bGQgbm90IHNldCB0aGlzIHByb3BlcnR5LiBUaGlzIGlzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZWQgaWYgRG9tQmluZGluZyB3YW50cyB0byBjcmVhdGUgYVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NvY2lhdGlvbiB0byB0aGUgY3JlYXRlZCBET00gdHlwZS5cbiAgICogQHJldHVybiB7Tm9kZX0gVGhlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRWxlbWVudHxEb20gRWxlbWVudH1cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgdG9ET00gKF9kb2N1bWVudCA9IGRvY3VtZW50LCBob29rcyA9IHt9LCBiaW5kaW5nKSB7XG4gICAgY29uc3QgZG9tID0gX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGhpcy5ub2RlTmFtZSlcbiAgICBjb25zdCBhdHRycyA9IHRoaXMuZ2V0QXR0cmlidXRlcygpXG4gICAgZm9yIChjb25zdCBrZXkgaW4gYXR0cnMpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gYXR0cnNba2V5XVxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZG9tLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKVxuICAgICAgfVxuICAgIH1cbiAgICB0eXBlTGlzdEZvckVhY2godGhpcywgeXhtbCA9PiB7XG4gICAgICBkb20uYXBwZW5kQ2hpbGQoeXhtbC50b0RPTShfZG9jdW1lbnQsIGhvb2tzLCBiaW5kaW5nKSlcbiAgICB9KVxuICAgIGlmIChiaW5kaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGJpbmRpbmcuX2NyZWF0ZUFzc29jaWF0aW9uKGRvbSwgdGhpcylcbiAgICB9XG4gICAgcmV0dXJuIGRvbVxuICB9XG5cbiAgLyoqXG4gICAqIFRyYW5zZm9ybSB0aGUgcHJvcGVydGllcyBvZiB0aGlzIHR5cGUgdG8gYmluYXJ5IGFuZCB3cml0ZSBpdCB0byBhblxuICAgKiBCaW5hcnlFbmNvZGVyLlxuICAgKlxuICAgKiBUaGlzIGlzIGNhbGxlZCB3aGVuIHRoaXMgSXRlbSBpcyBzZW50IHRvIGEgcmVtb3RlIHBlZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7VXBkYXRlRW5jb2RlclYxIHwgVXBkYXRlRW5jb2RlclYyfSBlbmNvZGVyIFRoZSBlbmNvZGVyIHRvIHdyaXRlIGRhdGEgdG8uXG4gICAqL1xuICBfd3JpdGUgKGVuY29kZXIpIHtcbiAgICBlbmNvZGVyLndyaXRlVHlwZVJlZihZWG1sRWxlbWVudFJlZklEKVxuICAgIGVuY29kZXIud3JpdGVLZXkodGhpcy5ub2RlTmFtZSlcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7VXBkYXRlRGVjb2RlclYxIHwgVXBkYXRlRGVjb2RlclYyfSBkZWNvZGVyXG4gKiBAcmV0dXJuIHtZWG1sRWxlbWVudH1cbiAqXG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IHJlYWRZWG1sRWxlbWVudCA9IGRlY29kZXIgPT4gbmV3IFlYbWxFbGVtZW50KGRlY29kZXIucmVhZEtleSgpKVxuIiwgIlxuaW1wb3J0IHtcbiAgWUV2ZW50LFxuICBZWG1sVGV4dCwgWVhtbEVsZW1lbnQsIFlYbWxGcmFnbWVudCwgVHJhbnNhY3Rpb24gLy8gZXNsaW50LWRpc2FibGUtbGluZVxufSBmcm9tICcuLi9pbnRlcm5hbHMuanMnXG5cbi8qKlxuICogQGV4dGVuZHMgWUV2ZW50PFlYbWxFbGVtZW50fFlYbWxUZXh0fFlYbWxGcmFnbWVudD5cbiAqIEFuIEV2ZW50IHRoYXQgZGVzY3JpYmVzIGNoYW5nZXMgb24gYSBZWG1sIEVsZW1lbnQgb3IgWXhtbCBGcmFnbWVudFxuICovXG5leHBvcnQgY2xhc3MgWVhtbEV2ZW50IGV4dGVuZHMgWUV2ZW50IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7WVhtbEVsZW1lbnR8WVhtbFRleHR8WVhtbEZyYWdtZW50fSB0YXJnZXQgVGhlIHRhcmdldCBvbiB3aGljaCB0aGUgZXZlbnQgaXMgY3JlYXRlZC5cbiAgICogQHBhcmFtIHtTZXQ8c3RyaW5nfG51bGw+fSBzdWJzIFRoZSBzZXQgb2YgY2hhbmdlZCBhdHRyaWJ1dGVzLiBgbnVsbGAgaXMgaW5jbHVkZWQgaWYgdGhlXG4gICAqICAgICAgICAgICAgICAgICAgIGNoaWxkIGxpc3QgY2hhbmdlZC5cbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb24gVGhlIHRyYW5zYWN0aW9uIGluc3RhbmNlIHdpdGggd2ljaCB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlIHdhcyBjcmVhdGVkLlxuICAgKi9cbiAgY29uc3RydWN0b3IgKHRhcmdldCwgc3VicywgdHJhbnNhY3Rpb24pIHtcbiAgICBzdXBlcih0YXJnZXQsIHRyYW5zYWN0aW9uKVxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlIGNoaWxkcmVuIGNoYW5nZWQuXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmNoaWxkTGlzdENoYW5nZWQgPSBmYWxzZVxuICAgIC8qKlxuICAgICAqIFNldCBvZiBhbGwgY2hhbmdlZCBhdHRyaWJ1dGVzLlxuICAgICAqIEB0eXBlIHtTZXQ8c3RyaW5nPn1cbiAgICAgKi9cbiAgICB0aGlzLmF0dHJpYnV0ZXNDaGFuZ2VkID0gbmV3IFNldCgpXG4gICAgc3Vicy5mb3JFYWNoKChzdWIpID0+IHtcbiAgICAgIGlmIChzdWIgPT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5jaGlsZExpc3RDaGFuZ2VkID0gdHJ1ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5hdHRyaWJ1dGVzQ2hhbmdlZC5hZGQoc3ViKVxuICAgICAgfVxuICAgIH0pXG4gIH1cbn1cbiIsICJcbmltcG9ydCB7XG4gIFlNYXAsXG4gIFlYbWxIb29rUmVmSUQsXG4gIFVwZGF0ZURlY29kZXJWMSwgVXBkYXRlRGVjb2RlclYyLCBVcGRhdGVFbmNvZGVyVjEsIFVwZGF0ZUVuY29kZXJWMiAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG59IGZyb20gJy4uL2ludGVybmFscy5qcydcblxuLyoqXG4gKiBZb3UgY2FuIG1hbmFnZSBiaW5kaW5nIHRvIGEgY3VzdG9tIHR5cGUgd2l0aCBZWG1sSG9vay5cbiAqXG4gKiBAZXh0ZW5kcyB7WU1hcDxhbnk+fVxuICovXG5leHBvcnQgY2xhc3MgWVhtbEhvb2sgZXh0ZW5kcyBZTWFwIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBob29rTmFtZSBub2RlTmFtZSBvZiB0aGUgRG9tIE5vZGUuXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoaG9va05hbWUpIHtcbiAgICBzdXBlcigpXG4gICAgLyoqXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmhvb2tOYW1lID0gaG9va05hbWVcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIEl0ZW0gd2l0aCB0aGUgc2FtZSBlZmZlY3QgYXMgdGhpcyBJdGVtICh3aXRob3V0IHBvc2l0aW9uIGVmZmVjdClcbiAgICovXG4gIF9jb3B5ICgpIHtcbiAgICByZXR1cm4gbmV3IFlYbWxIb29rKHRoaXMuaG9va05hbWUpXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7WVhtbEhvb2t9XG4gICAqL1xuICBjbG9uZSAoKSB7XG4gICAgY29uc3QgZWwgPSBuZXcgWVhtbEhvb2sodGhpcy5ob29rTmFtZSlcbiAgICB0aGlzLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgIGVsLnNldChrZXksIHZhbHVlKVxuICAgIH0pXG4gICAgcmV0dXJuIGVsXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIERvbSBFbGVtZW50IHRoYXQgbWlycm9ycyB0aGlzIFlYbWxFbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge0RvY3VtZW50fSBbX2RvY3VtZW50PWRvY3VtZW50XSBUaGUgZG9jdW1lbnQgb2JqZWN0ICh5b3UgbXVzdCBkZWZpbmVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcyB3aGVuIGNhbGxpbmcgdGhpcyBtZXRob2QgaW5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZWpzKVxuICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCBhbnk+fSBbaG9va3NdIE9wdGlvbmFsIHByb3BlcnR5IHRvIGN1c3RvbWl6ZSBob3cgaG9va3NcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmUgcHJlc2VudGVkIGluIHRoZSBET01cbiAgICogQHBhcmFtIHthbnl9IFtiaW5kaW5nXSBZb3Ugc2hvdWxkIG5vdCBzZXQgdGhpcyBwcm9wZXJ0eS4gVGhpcyBpc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VkIGlmIERvbUJpbmRpbmcgd2FudHMgdG8gY3JlYXRlIGFcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzb2NpYXRpb24gdG8gdGhlIGNyZWF0ZWQgRE9NIHR5cGVcbiAgICogQHJldHVybiB7RWxlbWVudH0gVGhlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRWxlbWVudHxEb20gRWxlbWVudH1cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgdG9ET00gKF9kb2N1bWVudCA9IGRvY3VtZW50LCBob29rcyA9IHt9LCBiaW5kaW5nKSB7XG4gICAgY29uc3QgaG9vayA9IGhvb2tzW3RoaXMuaG9va05hbWVdXG4gICAgbGV0IGRvbVxuICAgIGlmIChob29rICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGRvbSA9IGhvb2suY3JlYXRlRG9tKHRoaXMpXG4gICAgfSBlbHNlIHtcbiAgICAgIGRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGhpcy5ob29rTmFtZSlcbiAgICB9XG4gICAgZG9tLnNldEF0dHJpYnV0ZSgnZGF0YS15anMtaG9vaycsIHRoaXMuaG9va05hbWUpXG4gICAgaWYgKGJpbmRpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgYmluZGluZy5fY3JlYXRlQXNzb2NpYXRpb24oZG9tLCB0aGlzKVxuICAgIH1cbiAgICByZXR1cm4gZG9tXG4gIH1cblxuICAvKipcbiAgICogVHJhbnNmb3JtIHRoZSBwcm9wZXJ0aWVzIG9mIHRoaXMgdHlwZSB0byBiaW5hcnkgYW5kIHdyaXRlIGl0IHRvIGFuXG4gICAqIEJpbmFyeUVuY29kZXIuXG4gICAqXG4gICAqIFRoaXMgaXMgY2FsbGVkIHdoZW4gdGhpcyBJdGVtIGlzIHNlbnQgdG8gYSByZW1vdGUgcGVlci5cbiAgICpcbiAgICogQHBhcmFtIHtVcGRhdGVFbmNvZGVyVjEgfCBVcGRhdGVFbmNvZGVyVjJ9IGVuY29kZXIgVGhlIGVuY29kZXIgdG8gd3JpdGUgZGF0YSB0by5cbiAgICovXG4gIF93cml0ZSAoZW5jb2Rlcikge1xuICAgIGVuY29kZXIud3JpdGVUeXBlUmVmKFlYbWxIb29rUmVmSUQpXG4gICAgZW5jb2Rlci53cml0ZUtleSh0aGlzLmhvb2tOYW1lKVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtVcGRhdGVEZWNvZGVyVjEgfCBVcGRhdGVEZWNvZGVyVjJ9IGRlY29kZXJcbiAqIEByZXR1cm4ge1lYbWxIb29rfVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IHJlYWRZWG1sSG9vayA9IGRlY29kZXIgPT5cbiAgbmV3IFlYbWxIb29rKGRlY29kZXIucmVhZEtleSgpKVxuIiwgIlxuaW1wb3J0IHtcbiAgWVRleHQsXG4gIFlYbWxUZXh0UmVmSUQsXG4gIENvbnRlbnRUeXBlLCBZWG1sRWxlbWVudCwgVXBkYXRlRGVjb2RlclYxLCBVcGRhdGVEZWNvZGVyVjIsIFVwZGF0ZUVuY29kZXJWMSwgVXBkYXRlRW5jb2RlclYyLCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG59IGZyb20gJy4uL2ludGVybmFscy5qcydcblxuLyoqXG4gKiBSZXByZXNlbnRzIHRleHQgaW4gYSBEb20gRWxlbWVudC4gSW4gdGhlIGZ1dHVyZSB0aGlzIHR5cGUgd2lsbCBhbHNvIGhhbmRsZVxuICogc2ltcGxlIGZvcm1hdHRpbmcgaW5mb3JtYXRpb24gbGlrZSBib2xkIGFuZCBpdGFsaWMuXG4gKi9cbmV4cG9ydCBjbGFzcyBZWG1sVGV4dCBleHRlbmRzIFlUZXh0IHtcbiAgLyoqXG4gICAqIEB0eXBlIHtZWG1sRWxlbWVudHxZWG1sVGV4dHxudWxsfVxuICAgKi9cbiAgZ2V0IG5leHRTaWJsaW5nICgpIHtcbiAgICBjb25zdCBuID0gdGhpcy5faXRlbSA/IHRoaXMuX2l0ZW0ubmV4dCA6IG51bGxcbiAgICByZXR1cm4gbiA/IC8qKiBAdHlwZSB7WVhtbEVsZW1lbnR8WVhtbFRleHR9ICovICgvKiogQHR5cGUge0NvbnRlbnRUeXBlfSAqLyAobi5jb250ZW50KS50eXBlKSA6IG51bGxcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7WVhtbEVsZW1lbnR8WVhtbFRleHR8bnVsbH1cbiAgICovXG4gIGdldCBwcmV2U2libGluZyAoKSB7XG4gICAgY29uc3QgbiA9IHRoaXMuX2l0ZW0gPyB0aGlzLl9pdGVtLnByZXYgOiBudWxsXG4gICAgcmV0dXJuIG4gPyAvKiogQHR5cGUge1lYbWxFbGVtZW50fFlYbWxUZXh0fSAqLyAoLyoqIEB0eXBlIHtDb250ZW50VHlwZX0gKi8gKG4uY29udGVudCkudHlwZSkgOiBudWxsXG4gIH1cblxuICBfY29weSAoKSB7XG4gICAgcmV0dXJuIG5ldyBZWG1sVGV4dCgpXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7WVhtbFRleHR9XG4gICAqL1xuICBjbG9uZSAoKSB7XG4gICAgY29uc3QgdGV4dCA9IG5ldyBZWG1sVGV4dCgpXG4gICAgdGV4dC5hcHBseURlbHRhKHRoaXMudG9EZWx0YSgpKVxuICAgIHJldHVybiB0ZXh0XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIERvbSBFbGVtZW50IHRoYXQgbWlycm9ycyB0aGlzIFlYbWxUZXh0LlxuICAgKlxuICAgKiBAcGFyYW0ge0RvY3VtZW50fSBbX2RvY3VtZW50PWRvY3VtZW50XSBUaGUgZG9jdW1lbnQgb2JqZWN0ICh5b3UgbXVzdCBkZWZpbmVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcyB3aGVuIGNhbGxpbmcgdGhpcyBtZXRob2QgaW5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZWpzKVxuICAgKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsIGFueT59IFtob29rc10gT3B0aW9uYWwgcHJvcGVydHkgdG8gY3VzdG9taXplIGhvdyBob29rc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZSBwcmVzZW50ZWQgaW4gdGhlIERPTVxuICAgKiBAcGFyYW0ge2FueX0gW2JpbmRpbmddIFlvdSBzaG91bGQgbm90IHNldCB0aGlzIHByb3BlcnR5LiBUaGlzIGlzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZWQgaWYgRG9tQmluZGluZyB3YW50cyB0byBjcmVhdGUgYVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NvY2lhdGlvbiB0byB0aGUgY3JlYXRlZCBET00gdHlwZS5cbiAgICogQHJldHVybiB7VGV4dH0gVGhlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRWxlbWVudHxEb20gRWxlbWVudH1cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgdG9ET00gKF9kb2N1bWVudCA9IGRvY3VtZW50LCBob29rcywgYmluZGluZykge1xuICAgIGNvbnN0IGRvbSA9IF9kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0aGlzLnRvU3RyaW5nKCkpXG4gICAgaWYgKGJpbmRpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgYmluZGluZy5fY3JlYXRlQXNzb2NpYXRpb24oZG9tLCB0aGlzKVxuICAgIH1cbiAgICByZXR1cm4gZG9tXG4gIH1cblxuICB0b1N0cmluZyAoKSB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHJldHVybiB0aGlzLnRvRGVsdGEoKS5tYXAoZGVsdGEgPT4ge1xuICAgICAgY29uc3QgbmVzdGVkTm9kZXMgPSBbXVxuICAgICAgZm9yIChjb25zdCBub2RlTmFtZSBpbiBkZWx0YS5hdHRyaWJ1dGVzKSB7XG4gICAgICAgIGNvbnN0IGF0dHJzID0gW11cbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gZGVsdGEuYXR0cmlidXRlc1tub2RlTmFtZV0pIHtcbiAgICAgICAgICBhdHRycy5wdXNoKHsga2V5LCB2YWx1ZTogZGVsdGEuYXR0cmlidXRlc1tub2RlTmFtZV1ba2V5XSB9KVxuICAgICAgICB9XG4gICAgICAgIC8vIHNvcnQgYXR0cmlidXRlcyB0byBnZXQgYSB1bmlxdWUgb3JkZXJcbiAgICAgICAgYXR0cnMuc29ydCgoYSwgYikgPT4gYS5rZXkgPCBiLmtleSA/IC0xIDogMSlcbiAgICAgICAgbmVzdGVkTm9kZXMucHVzaCh7IG5vZGVOYW1lLCBhdHRycyB9KVxuICAgICAgfVxuICAgICAgLy8gc29ydCBub2RlIG9yZGVyIHRvIGdldCBhIHVuaXF1ZSBvcmRlclxuICAgICAgbmVzdGVkTm9kZXMuc29ydCgoYSwgYikgPT4gYS5ub2RlTmFtZSA8IGIubm9kZU5hbWUgPyAtMSA6IDEpXG4gICAgICAvLyBub3cgY29udmVydCB0byBkb20gc3RyaW5nXG4gICAgICBsZXQgc3RyID0gJydcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmVzdGVkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IG5lc3RlZE5vZGVzW2ldXG4gICAgICAgIHN0ciArPSBgPCR7bm9kZS5ub2RlTmFtZX1gXG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbm9kZS5hdHRycy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGNvbnN0IGF0dHIgPSBub2RlLmF0dHJzW2pdXG4gICAgICAgICAgc3RyICs9IGAgJHthdHRyLmtleX09XCIke2F0dHIudmFsdWV9XCJgXG4gICAgICAgIH1cbiAgICAgICAgc3RyICs9ICc+J1xuICAgICAgfVxuICAgICAgc3RyICs9IGRlbHRhLmluc2VydFxuICAgICAgZm9yIChsZXQgaSA9IG5lc3RlZE5vZGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHN0ciArPSBgPC8ke25lc3RlZE5vZGVzW2ldLm5vZGVOYW1lfT5gXG4gICAgICB9XG4gICAgICByZXR1cm4gc3RyXG4gICAgfSkuam9pbignJylcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b0pTT04gKCkge1xuICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1VwZGF0ZUVuY29kZXJWMSB8IFVwZGF0ZUVuY29kZXJWMn0gZW5jb2RlclxuICAgKi9cbiAgX3dyaXRlIChlbmNvZGVyKSB7XG4gICAgZW5jb2Rlci53cml0ZVR5cGVSZWYoWVhtbFRleHRSZWZJRClcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7VXBkYXRlRGVjb2RlclYxIHwgVXBkYXRlRGVjb2RlclYyfSBkZWNvZGVyXG4gKiBAcmV0dXJuIHtZWG1sVGV4dH1cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCByZWFkWVhtbFRleHQgPSBkZWNvZGVyID0+IG5ldyBZWG1sVGV4dCgpXG4iLCAiXG5pbXBvcnQge1xuICBVcGRhdGVFbmNvZGVyVjEsIFVwZGF0ZUVuY29kZXJWMiwgSUQsIFRyYW5zYWN0aW9uIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbn0gZnJvbSAnLi4vaW50ZXJuYWxzLmpzJ1xuXG5pbXBvcnQgKiBhcyBlcnJvciBmcm9tICdsaWIwL2Vycm9yJ1xuXG5leHBvcnQgY2xhc3MgQWJzdHJhY3RTdHJ1Y3Qge1xuICAvKipcbiAgICogQHBhcmFtIHtJRH0gaWRcbiAgICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aFxuICAgKi9cbiAgY29uc3RydWN0b3IgKGlkLCBsZW5ndGgpIHtcbiAgICB0aGlzLmlkID0gaWRcbiAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aFxuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgZ2V0IGRlbGV0ZWQgKCkge1xuICAgIHRocm93IGVycm9yLm1ldGhvZFVuaW1wbGVtZW50ZWQoKVxuICB9XG5cbiAgLyoqXG4gICAqIE1lcmdlIHRoaXMgc3RydWN0IHdpdGggdGhlIGl0ZW0gdG8gdGhlIHJpZ2h0LlxuICAgKiBUaGlzIG1ldGhvZCBpcyBhbHJlYWR5IGFzc3VtaW5nIHRoYXQgYHRoaXMuaWQuY2xvY2sgKyB0aGlzLmxlbmd0aCA9PT0gdGhpcy5pZC5jbG9ja2AuXG4gICAqIEFsc28gdGhpcyBtZXRob2QgZG9lcyAqbm90KiByZW1vdmUgcmlnaHQgZnJvbSBTdHJ1Y3RTdG9yZSFcbiAgICogQHBhcmFtIHtBYnN0cmFjdFN0cnVjdH0gcmlnaHRcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gd2V0aGVyIHRoaXMgbWVyZ2VkIHdpdGggcmlnaHRcbiAgICovXG4gIG1lcmdlV2l0aCAocmlnaHQpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1VwZGF0ZUVuY29kZXJWMSB8IFVwZGF0ZUVuY29kZXJWMn0gZW5jb2RlciBUaGUgZW5jb2RlciB0byB3cml0ZSBkYXRhIHRvLlxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBlbmNvZGluZ1JlZlxuICAgKi9cbiAgd3JpdGUgKGVuY29kZXIsIG9mZnNldCwgZW5jb2RpbmdSZWYpIHtcbiAgICB0aHJvdyBlcnJvci5tZXRob2RVbmltcGxlbWVudGVkKClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gICAqL1xuICBpbnRlZ3JhdGUgKHRyYW5zYWN0aW9uLCBvZmZzZXQpIHtcbiAgICB0aHJvdyBlcnJvci5tZXRob2RVbmltcGxlbWVudGVkKClcbiAgfVxufVxuIiwgIlxuaW1wb3J0IHtcbiAgQWJzdHJhY3RTdHJ1Y3QsXG4gIGFkZFN0cnVjdCxcbiAgVXBkYXRlRGVjb2RlclYxLCBVcGRhdGVEZWNvZGVyVjIsIFVwZGF0ZUVuY29kZXJWMSwgVXBkYXRlRW5jb2RlclYyLCBTdHJ1Y3RTdG9yZSwgVHJhbnNhY3Rpb24sIElEIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbn0gZnJvbSAnLi4vaW50ZXJuYWxzLmpzJ1xuXG5leHBvcnQgY29uc3Qgc3RydWN0R0NSZWZOdW1iZXIgPSAwXG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNsYXNzIEdDIGV4dGVuZHMgQWJzdHJhY3RTdHJ1Y3Qge1xuICBnZXQgZGVsZXRlZCAoKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGRlbGV0ZSAoKSB7fVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0dDfSByaWdodFxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgbWVyZ2VXaXRoIChyaWdodCkge1xuICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yICE9PSByaWdodC5jb25zdHJ1Y3Rvcikge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIHRoaXMubGVuZ3RoICs9IHJpZ2h0Lmxlbmd0aFxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICAgKi9cbiAgaW50ZWdyYXRlICh0cmFuc2FjdGlvbiwgb2Zmc2V0KSB7XG4gICAgaWYgKG9mZnNldCA+IDApIHtcbiAgICAgIHRoaXMuaWQuY2xvY2sgKz0gb2Zmc2V0XG4gICAgICB0aGlzLmxlbmd0aCAtPSBvZmZzZXRcbiAgICB9XG4gICAgYWRkU3RydWN0KHRyYW5zYWN0aW9uLmRvYy5zdG9yZSwgdGhpcylcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1VwZGF0ZUVuY29kZXJWMSB8IFVwZGF0ZUVuY29kZXJWMn0gZW5jb2RlclxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gICAqL1xuICB3cml0ZSAoZW5jb2Rlciwgb2Zmc2V0KSB7XG4gICAgZW5jb2Rlci53cml0ZUluZm8oc3RydWN0R0NSZWZOdW1iZXIpXG4gICAgZW5jb2Rlci53cml0ZUxlbih0aGlzLmxlbmd0aCAtIG9mZnNldClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge1N0cnVjdFN0b3JlfSBzdG9yZVxuICAgKiBAcmV0dXJuIHtudWxsIHwgbnVtYmVyfVxuICAgKi9cbiAgZ2V0TWlzc2luZyAodHJhbnNhY3Rpb24sIHN0b3JlKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxufVxuIiwgImltcG9ydCB7XG4gIFVwZGF0ZURlY29kZXJWMSwgVXBkYXRlRGVjb2RlclYyLCBVcGRhdGVFbmNvZGVyVjEsIFVwZGF0ZUVuY29kZXJWMiwgU3RydWN0U3RvcmUsIEl0ZW0sIFRyYW5zYWN0aW9uIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbn0gZnJvbSAnLi4vaW50ZXJuYWxzLmpzJ1xuXG5pbXBvcnQgKiBhcyBlcnJvciBmcm9tICdsaWIwL2Vycm9yJ1xuXG5leHBvcnQgY2xhc3MgQ29udGVudEJpbmFyeSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGNvbnRlbnRcbiAgICovXG4gIGNvbnN0cnVjdG9yIChjb250ZW50KSB7XG4gICAgdGhpcy5jb250ZW50ID0gY29udGVudFxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldExlbmd0aCAoKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtBcnJheTxhbnk+fVxuICAgKi9cbiAgZ2V0Q29udGVudCAoKSB7XG4gICAgcmV0dXJuIFt0aGlzLmNvbnRlbnRdXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGlzQ291bnRhYmxlICgpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0NvbnRlbnRCaW5hcnl9XG4gICAqL1xuICBjb3B5ICgpIHtcbiAgICByZXR1cm4gbmV3IENvbnRlbnRCaW5hcnkodGhpcy5jb250ZW50KVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAgICogQHJldHVybiB7Q29udGVudEJpbmFyeX1cbiAgICovXG4gIHNwbGljZSAob2Zmc2V0KSB7XG4gICAgdGhyb3cgZXJyb3IubWV0aG9kVW5pbXBsZW1lbnRlZCgpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtDb250ZW50QmluYXJ5fSByaWdodFxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgbWVyZ2VXaXRoIChyaWdodCkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7SXRlbX0gaXRlbVxuICAgKi9cbiAgaW50ZWdyYXRlICh0cmFuc2FjdGlvbiwgaXRlbSkge31cbiAgLyoqXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqL1xuICBkZWxldGUgKHRyYW5zYWN0aW9uKSB7fVxuICAvKipcbiAgICogQHBhcmFtIHtTdHJ1Y3RTdG9yZX0gc3RvcmVcbiAgICovXG4gIGdjIChzdG9yZSkge31cbiAgLyoqXG4gICAqIEBwYXJhbSB7VXBkYXRlRW5jb2RlclYxIHwgVXBkYXRlRW5jb2RlclYyfSBlbmNvZGVyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAgICovXG4gIHdyaXRlIChlbmNvZGVyLCBvZmZzZXQpIHtcbiAgICBlbmNvZGVyLndyaXRlQnVmKHRoaXMuY29udGVudClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRSZWYgKCkge1xuICAgIHJldHVybiAzXG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1VwZGF0ZURlY29kZXJWMSB8IFVwZGF0ZURlY29kZXJWMiB9IGRlY29kZXJcbiAqIEByZXR1cm4ge0NvbnRlbnRCaW5hcnl9XG4gKi9cbmV4cG9ydCBjb25zdCByZWFkQ29udGVudEJpbmFyeSA9IGRlY29kZXIgPT4gbmV3IENvbnRlbnRCaW5hcnkoZGVjb2Rlci5yZWFkQnVmKCkpXG4iLCAiXG5pbXBvcnQge1xuICBhZGRUb0RlbGV0ZVNldCxcbiAgVXBkYXRlRGVjb2RlclYxLCBVcGRhdGVEZWNvZGVyVjIsIFVwZGF0ZUVuY29kZXJWMSwgVXBkYXRlRW5jb2RlclYyLCBTdHJ1Y3RTdG9yZSwgSXRlbSwgVHJhbnNhY3Rpb24gLy8gZXNsaW50LWRpc2FibGUtbGluZVxufSBmcm9tICcuLi9pbnRlcm5hbHMuanMnXG5cbmV4cG9ydCBjbGFzcyBDb250ZW50RGVsZXRlZCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gbGVuXG4gICAqL1xuICBjb25zdHJ1Y3RvciAobGVuKSB7XG4gICAgdGhpcy5sZW4gPSBsZW5cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRMZW5ndGggKCkge1xuICAgIHJldHVybiB0aGlzLmxlblxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0FycmF5PGFueT59XG4gICAqL1xuICBnZXRDb250ZW50ICgpIHtcbiAgICByZXR1cm4gW11cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaXNDb3VudGFibGUgKCkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0NvbnRlbnREZWxldGVkfVxuICAgKi9cbiAgY29weSAoKSB7XG4gICAgcmV0dXJuIG5ldyBDb250ZW50RGVsZXRlZCh0aGlzLmxlbilcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gICAqIEByZXR1cm4ge0NvbnRlbnREZWxldGVkfVxuICAgKi9cbiAgc3BsaWNlIChvZmZzZXQpIHtcbiAgICBjb25zdCByaWdodCA9IG5ldyBDb250ZW50RGVsZXRlZCh0aGlzLmxlbiAtIG9mZnNldClcbiAgICB0aGlzLmxlbiA9IG9mZnNldFxuICAgIHJldHVybiByaWdodFxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Q29udGVudERlbGV0ZWR9IHJpZ2h0XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBtZXJnZVdpdGggKHJpZ2h0KSB7XG4gICAgdGhpcy5sZW4gKz0gcmlnaHQubGVuXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge0l0ZW19IGl0ZW1cbiAgICovXG4gIGludGVncmF0ZSAodHJhbnNhY3Rpb24sIGl0ZW0pIHtcbiAgICBhZGRUb0RlbGV0ZVNldCh0cmFuc2FjdGlvbi5kZWxldGVTZXQsIGl0ZW0uaWQuY2xpZW50LCBpdGVtLmlkLmNsb2NrLCB0aGlzLmxlbilcbiAgICBpdGVtLm1hcmtEZWxldGVkKClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKi9cbiAgZGVsZXRlICh0cmFuc2FjdGlvbikge31cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RydWN0U3RvcmV9IHN0b3JlXG4gICAqL1xuICBnYyAoc3RvcmUpIHt9XG4gIC8qKlxuICAgKiBAcGFyYW0ge1VwZGF0ZUVuY29kZXJWMSB8IFVwZGF0ZUVuY29kZXJWMn0gZW5jb2RlclxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gICAqL1xuICB3cml0ZSAoZW5jb2Rlciwgb2Zmc2V0KSB7XG4gICAgZW5jb2Rlci53cml0ZUxlbih0aGlzLmxlbiAtIG9mZnNldClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRSZWYgKCkge1xuICAgIHJldHVybiAxXG4gIH1cbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICpcbiAqIEBwYXJhbSB7VXBkYXRlRGVjb2RlclYxIHwgVXBkYXRlRGVjb2RlclYyIH0gZGVjb2RlclxuICogQHJldHVybiB7Q29udGVudERlbGV0ZWR9XG4gKi9cbmV4cG9ydCBjb25zdCByZWFkQ29udGVudERlbGV0ZWQgPSBkZWNvZGVyID0+IG5ldyBDb250ZW50RGVsZXRlZChkZWNvZGVyLnJlYWRMZW4oKSlcbiIsICJcbmltcG9ydCB7XG4gIERvYywgVXBkYXRlRGVjb2RlclYxLCBVcGRhdGVEZWNvZGVyVjIsIFVwZGF0ZUVuY29kZXJWMSwgVXBkYXRlRW5jb2RlclYyLCBTdHJ1Y3RTdG9yZSwgVHJhbnNhY3Rpb24sIEl0ZW0gLy8gZXNsaW50LWRpc2FibGUtbGluZVxufSBmcm9tICcuLi9pbnRlcm5hbHMuanMnXG5cbmltcG9ydCAqIGFzIGVycm9yIGZyb20gJ2xpYjAvZXJyb3InXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGd1aWRcbiAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZywgYW55Pn0gb3B0c1xuICovXG5jb25zdCBjcmVhdGVEb2NGcm9tT3B0cyA9IChndWlkLCBvcHRzKSA9PiBuZXcgRG9jKHsgZ3VpZCwgLi4ub3B0cywgc2hvdWxkTG9hZDogb3B0cy5zaG91bGRMb2FkIHx8IG9wdHMuYXV0b0xvYWQgfHwgZmFsc2UgfSlcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY2xhc3MgQ29udGVudERvYyB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0RvY30gZG9jXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoZG9jKSB7XG4gICAgaWYgKGRvYy5faXRlbSkge1xuICAgICAgY29uc29sZS5lcnJvcignVGhpcyBkb2N1bWVudCB3YXMgYWxyZWFkeSBpbnRlZ3JhdGVkIGFzIGEgc3ViLWRvY3VtZW50LiBZb3Ugc2hvdWxkIGNyZWF0ZSBhIHNlY29uZCBpbnN0YW5jZSBpbnN0ZWFkIHdpdGggdGhlIHNhbWUgZ3VpZC4nKVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7RG9jfVxuICAgICAqL1xuICAgIHRoaXMuZG9jID0gZG9jXG4gICAgLyoqXG4gICAgICogQHR5cGUge2FueX1cbiAgICAgKi9cbiAgICBjb25zdCBvcHRzID0ge31cbiAgICB0aGlzLm9wdHMgPSBvcHRzXG4gICAgaWYgKCFkb2MuZ2MpIHtcbiAgICAgIG9wdHMuZ2MgPSBmYWxzZVxuICAgIH1cbiAgICBpZiAoZG9jLmF1dG9Mb2FkKSB7XG4gICAgICBvcHRzLmF1dG9Mb2FkID0gdHJ1ZVxuICAgIH1cbiAgICBpZiAoZG9jLm1ldGEgIT09IG51bGwpIHtcbiAgICAgIG9wdHMubWV0YSA9IGRvYy5tZXRhXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldExlbmd0aCAoKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtBcnJheTxhbnk+fVxuICAgKi9cbiAgZ2V0Q29udGVudCAoKSB7XG4gICAgcmV0dXJuIFt0aGlzLmRvY11cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaXNDb3VudGFibGUgKCkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Q29udGVudERvY31cbiAgICovXG4gIGNvcHkgKCkge1xuICAgIHJldHVybiBuZXcgQ29udGVudERvYyhjcmVhdGVEb2NGcm9tT3B0cyh0aGlzLmRvYy5ndWlkLCB0aGlzLm9wdHMpKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAgICogQHJldHVybiB7Q29udGVudERvY31cbiAgICovXG4gIHNwbGljZSAob2Zmc2V0KSB7XG4gICAgdGhyb3cgZXJyb3IubWV0aG9kVW5pbXBsZW1lbnRlZCgpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtDb250ZW50RG9jfSByaWdodFxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgbWVyZ2VXaXRoIChyaWdodCkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7SXRlbX0gaXRlbVxuICAgKi9cbiAgaW50ZWdyYXRlICh0cmFuc2FjdGlvbiwgaXRlbSkge1xuICAgIC8vIHRoaXMgbmVlZHMgdG8gYmUgcmVmbGVjdGVkIGluIGRvYy5kZXN0cm95IGFzIHdlbGxcbiAgICB0aGlzLmRvYy5faXRlbSA9IGl0ZW1cbiAgICB0cmFuc2FjdGlvbi5zdWJkb2NzQWRkZWQuYWRkKHRoaXMuZG9jKVxuICAgIGlmICh0aGlzLmRvYy5zaG91bGRMb2FkKSB7XG4gICAgICB0cmFuc2FjdGlvbi5zdWJkb2NzTG9hZGVkLmFkZCh0aGlzLmRvYylcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICovXG4gIGRlbGV0ZSAodHJhbnNhY3Rpb24pIHtcbiAgICBpZiAodHJhbnNhY3Rpb24uc3ViZG9jc0FkZGVkLmhhcyh0aGlzLmRvYykpIHtcbiAgICAgIHRyYW5zYWN0aW9uLnN1YmRvY3NBZGRlZC5kZWxldGUodGhpcy5kb2MpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRyYW5zYWN0aW9uLnN1YmRvY3NSZW1vdmVkLmFkZCh0aGlzLmRvYylcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtTdHJ1Y3RTdG9yZX0gc3RvcmVcbiAgICovXG4gIGdjIChzdG9yZSkgeyB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VXBkYXRlRW5jb2RlclYxIHwgVXBkYXRlRW5jb2RlclYyfSBlbmNvZGVyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAgICovXG4gIHdyaXRlIChlbmNvZGVyLCBvZmZzZXQpIHtcbiAgICBlbmNvZGVyLndyaXRlU3RyaW5nKHRoaXMuZG9jLmd1aWQpXG4gICAgZW5jb2Rlci53cml0ZUFueSh0aGlzLm9wdHMpXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0UmVmICgpIHtcbiAgICByZXR1cm4gOVxuICB9XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqXG4gKiBAcGFyYW0ge1VwZGF0ZURlY29kZXJWMSB8IFVwZGF0ZURlY29kZXJWMn0gZGVjb2RlclxuICogQHJldHVybiB7Q29udGVudERvY31cbiAqL1xuZXhwb3J0IGNvbnN0IHJlYWRDb250ZW50RG9jID0gZGVjb2RlciA9PiBuZXcgQ29udGVudERvYyhjcmVhdGVEb2NGcm9tT3B0cyhkZWNvZGVyLnJlYWRTdHJpbmcoKSwgZGVjb2Rlci5yZWFkQW55KCkpKVxuIiwgIlxuaW1wb3J0IHtcbiAgVXBkYXRlRGVjb2RlclYxLCBVcGRhdGVEZWNvZGVyVjIsIFVwZGF0ZUVuY29kZXJWMSwgVXBkYXRlRW5jb2RlclYyLCBTdHJ1Y3RTdG9yZSwgSXRlbSwgVHJhbnNhY3Rpb24gLy8gZXNsaW50LWRpc2FibGUtbGluZVxufSBmcm9tICcuLi9pbnRlcm5hbHMuanMnXG5cbmltcG9ydCAqIGFzIGVycm9yIGZyb20gJ2xpYjAvZXJyb3InXG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNsYXNzIENvbnRlbnRFbWJlZCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZW1iZWRcbiAgICovXG4gIGNvbnN0cnVjdG9yIChlbWJlZCkge1xuICAgIHRoaXMuZW1iZWQgPSBlbWJlZFxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldExlbmd0aCAoKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtBcnJheTxhbnk+fVxuICAgKi9cbiAgZ2V0Q29udGVudCAoKSB7XG4gICAgcmV0dXJuIFt0aGlzLmVtYmVkXVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBpc0NvdW50YWJsZSAoKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtDb250ZW50RW1iZWR9XG4gICAqL1xuICBjb3B5ICgpIHtcbiAgICByZXR1cm4gbmV3IENvbnRlbnRFbWJlZCh0aGlzLmVtYmVkKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAgICogQHJldHVybiB7Q29udGVudEVtYmVkfVxuICAgKi9cbiAgc3BsaWNlIChvZmZzZXQpIHtcbiAgICB0aHJvdyBlcnJvci5tZXRob2RVbmltcGxlbWVudGVkKClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0NvbnRlbnRFbWJlZH0gcmlnaHRcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIG1lcmdlV2l0aCAocmlnaHQpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge0l0ZW19IGl0ZW1cbiAgICovXG4gIGludGVncmF0ZSAodHJhbnNhY3Rpb24sIGl0ZW0pIHt9XG4gIC8qKlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKi9cbiAgZGVsZXRlICh0cmFuc2FjdGlvbikge31cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RydWN0U3RvcmV9IHN0b3JlXG4gICAqL1xuICBnYyAoc3RvcmUpIHt9XG4gIC8qKlxuICAgKiBAcGFyYW0ge1VwZGF0ZUVuY29kZXJWMSB8IFVwZGF0ZUVuY29kZXJWMn0gZW5jb2RlclxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gICAqL1xuICB3cml0ZSAoZW5jb2Rlciwgb2Zmc2V0KSB7XG4gICAgZW5jb2Rlci53cml0ZUpTT04odGhpcy5lbWJlZClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRSZWYgKCkge1xuICAgIHJldHVybiA1XG4gIH1cbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICpcbiAqIEBwYXJhbSB7VXBkYXRlRGVjb2RlclYxIHwgVXBkYXRlRGVjb2RlclYyfSBkZWNvZGVyXG4gKiBAcmV0dXJuIHtDb250ZW50RW1iZWR9XG4gKi9cbmV4cG9ydCBjb25zdCByZWFkQ29udGVudEVtYmVkID0gZGVjb2RlciA9PiBuZXcgQ29udGVudEVtYmVkKGRlY29kZXIucmVhZEpTT04oKSlcbiIsICJcbmltcG9ydCB7XG4gIFlUZXh0LCBVcGRhdGVEZWNvZGVyVjEsIFVwZGF0ZURlY29kZXJWMiwgVXBkYXRlRW5jb2RlclYxLCBVcGRhdGVFbmNvZGVyVjIsIEl0ZW0sIFN0cnVjdFN0b3JlLCBUcmFuc2FjdGlvbiAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG59IGZyb20gJy4uL2ludGVybmFscy5qcydcblxuaW1wb3J0ICogYXMgZXJyb3IgZnJvbSAnbGliMC9lcnJvcidcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY2xhc3MgQ29udGVudEZvcm1hdCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZVxuICAgKi9cbiAgY29uc3RydWN0b3IgKGtleSwgdmFsdWUpIHtcbiAgICB0aGlzLmtleSA9IGtleVxuICAgIHRoaXMudmFsdWUgPSB2YWx1ZVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldExlbmd0aCAoKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtBcnJheTxhbnk+fVxuICAgKi9cbiAgZ2V0Q29udGVudCAoKSB7XG4gICAgcmV0dXJuIFtdXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGlzQ291bnRhYmxlICgpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtDb250ZW50Rm9ybWF0fVxuICAgKi9cbiAgY29weSAoKSB7XG4gICAgcmV0dXJuIG5ldyBDb250ZW50Rm9ybWF0KHRoaXMua2V5LCB0aGlzLnZhbHVlKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBfb2Zmc2V0XG4gICAqIEByZXR1cm4ge0NvbnRlbnRGb3JtYXR9XG4gICAqL1xuICBzcGxpY2UgKF9vZmZzZXQpIHtcbiAgICB0aHJvdyBlcnJvci5tZXRob2RVbmltcGxlbWVudGVkKClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0NvbnRlbnRGb3JtYXR9IF9yaWdodFxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgbWVyZ2VXaXRoIChfcmlnaHQpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSBfdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtJdGVtfSBpdGVtXG4gICAqL1xuICBpbnRlZ3JhdGUgKF90cmFuc2FjdGlvbiwgaXRlbSkge1xuICAgIC8vIEB0b2RvIHNlYXJjaG1hcmtlciBhcmUgY3VycmVudGx5IHVuc3VwcG9ydGVkIGZvciByaWNoIHRleHQgZG9jdW1lbnRzXG4gICAgY29uc3QgcCA9IC8qKiBAdHlwZSB7WVRleHR9ICovIChpdGVtLnBhcmVudClcbiAgICBwLl9zZWFyY2hNYXJrZXIgPSBudWxsXG4gICAgcC5faGFzRm9ybWF0dGluZyA9IHRydWVcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKi9cbiAgZGVsZXRlICh0cmFuc2FjdGlvbikge31cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RydWN0U3RvcmV9IHN0b3JlXG4gICAqL1xuICBnYyAoc3RvcmUpIHt9XG4gIC8qKlxuICAgKiBAcGFyYW0ge1VwZGF0ZUVuY29kZXJWMSB8IFVwZGF0ZUVuY29kZXJWMn0gZW5jb2RlclxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gICAqL1xuICB3cml0ZSAoZW5jb2Rlciwgb2Zmc2V0KSB7XG4gICAgZW5jb2Rlci53cml0ZUtleSh0aGlzLmtleSlcbiAgICBlbmNvZGVyLndyaXRlSlNPTih0aGlzLnZhbHVlKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldFJlZiAoKSB7XG4gICAgcmV0dXJuIDZcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7VXBkYXRlRGVjb2RlclYxIHwgVXBkYXRlRGVjb2RlclYyfSBkZWNvZGVyXG4gKiBAcmV0dXJuIHtDb250ZW50Rm9ybWF0fVxuICovXG5leHBvcnQgY29uc3QgcmVhZENvbnRlbnRGb3JtYXQgPSBkZWNvZGVyID0+IG5ldyBDb250ZW50Rm9ybWF0KGRlY29kZXIucmVhZEtleSgpLCBkZWNvZGVyLnJlYWRKU09OKCkpXG4iLCAiaW1wb3J0IHtcbiAgVXBkYXRlRGVjb2RlclYxLCBVcGRhdGVEZWNvZGVyVjIsIFVwZGF0ZUVuY29kZXJWMSwgVXBkYXRlRW5jb2RlclYyLCBUcmFuc2FjdGlvbiwgSXRlbSwgU3RydWN0U3RvcmUgLy8gZXNsaW50LWRpc2FibGUtbGluZVxufSBmcm9tICcuLi9pbnRlcm5hbHMuanMnXG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNsYXNzIENvbnRlbnRKU09OIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7QXJyYXk8YW55Pn0gYXJyXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoYXJyKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge0FycmF5PGFueT59XG4gICAgICovXG4gICAgdGhpcy5hcnIgPSBhcnJcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRMZW5ndGggKCkge1xuICAgIHJldHVybiB0aGlzLmFyci5sZW5ndGhcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtBcnJheTxhbnk+fVxuICAgKi9cbiAgZ2V0Q29udGVudCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXJyXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGlzQ291bnRhYmxlICgpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0NvbnRlbnRKU09OfVxuICAgKi9cbiAgY29weSAoKSB7XG4gICAgcmV0dXJuIG5ldyBDb250ZW50SlNPTih0aGlzLmFycilcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gICAqIEByZXR1cm4ge0NvbnRlbnRKU09OfVxuICAgKi9cbiAgc3BsaWNlIChvZmZzZXQpIHtcbiAgICBjb25zdCByaWdodCA9IG5ldyBDb250ZW50SlNPTih0aGlzLmFyci5zbGljZShvZmZzZXQpKVxuICAgIHRoaXMuYXJyID0gdGhpcy5hcnIuc2xpY2UoMCwgb2Zmc2V0KVxuICAgIHJldHVybiByaWdodFxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Q29udGVudEpTT059IHJpZ2h0XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBtZXJnZVdpdGggKHJpZ2h0KSB7XG4gICAgdGhpcy5hcnIgPSB0aGlzLmFyci5jb25jYXQocmlnaHQuYXJyKVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtJdGVtfSBpdGVtXG4gICAqL1xuICBpbnRlZ3JhdGUgKHRyYW5zYWN0aW9uLCBpdGVtKSB7fVxuICAvKipcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICovXG4gIGRlbGV0ZSAodHJhbnNhY3Rpb24pIHt9XG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cnVjdFN0b3JlfSBzdG9yZVxuICAgKi9cbiAgZ2MgKHN0b3JlKSB7fVxuICAvKipcbiAgICogQHBhcmFtIHtVcGRhdGVFbmNvZGVyVjEgfCBVcGRhdGVFbmNvZGVyVjJ9IGVuY29kZXJcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICAgKi9cbiAgd3JpdGUgKGVuY29kZXIsIG9mZnNldCkge1xuICAgIGNvbnN0IGxlbiA9IHRoaXMuYXJyLmxlbmd0aFxuICAgIGVuY29kZXIud3JpdGVMZW4obGVuIC0gb2Zmc2V0KVxuICAgIGZvciAobGV0IGkgPSBvZmZzZXQ7IGkgPCBsZW47IGkrKykge1xuICAgICAgY29uc3QgYyA9IHRoaXMuYXJyW2ldXG4gICAgICBlbmNvZGVyLndyaXRlU3RyaW5nKGMgPT09IHVuZGVmaW5lZCA/ICd1bmRlZmluZWQnIDogSlNPTi5zdHJpbmdpZnkoYykpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldFJlZiAoKSB7XG4gICAgcmV0dXJuIDJcbiAgfVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKlxuICogQHBhcmFtIHtVcGRhdGVEZWNvZGVyVjEgfCBVcGRhdGVEZWNvZGVyVjJ9IGRlY29kZXJcbiAqIEByZXR1cm4ge0NvbnRlbnRKU09OfVxuICovXG5leHBvcnQgY29uc3QgcmVhZENvbnRlbnRKU09OID0gZGVjb2RlciA9PiB7XG4gIGNvbnN0IGxlbiA9IGRlY29kZXIucmVhZExlbigpXG4gIGNvbnN0IGNzID0gW11cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGNvbnN0IGMgPSBkZWNvZGVyLnJlYWRTdHJpbmcoKVxuICAgIGlmIChjID09PSAndW5kZWZpbmVkJykge1xuICAgICAgY3MucHVzaCh1bmRlZmluZWQpXG4gICAgfSBlbHNlIHtcbiAgICAgIGNzLnB1c2goSlNPTi5wYXJzZShjKSlcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5ldyBDb250ZW50SlNPTihjcylcbn1cbiIsICJpbXBvcnQge1xuICBVcGRhdGVFbmNvZGVyVjEsIFVwZGF0ZUVuY29kZXJWMiwgVXBkYXRlRGVjb2RlclYxLCBVcGRhdGVEZWNvZGVyVjIsIFRyYW5zYWN0aW9uLCBJdGVtLCBTdHJ1Y3RTdG9yZSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG59IGZyb20gJy4uL2ludGVybmFscy5qcydcblxuZXhwb3J0IGNsYXNzIENvbnRlbnRBbnkge1xuICAvKipcbiAgICogQHBhcmFtIHtBcnJheTxhbnk+fSBhcnJcbiAgICovXG4gIGNvbnN0cnVjdG9yIChhcnIpIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QXJyYXk8YW55Pn1cbiAgICAgKi9cbiAgICB0aGlzLmFyciA9IGFyclxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldExlbmd0aCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXJyLmxlbmd0aFxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0FycmF5PGFueT59XG4gICAqL1xuICBnZXRDb250ZW50ICgpIHtcbiAgICByZXR1cm4gdGhpcy5hcnJcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaXNDb3VudGFibGUgKCkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Q29udGVudEFueX1cbiAgICovXG4gIGNvcHkgKCkge1xuICAgIHJldHVybiBuZXcgQ29udGVudEFueSh0aGlzLmFycilcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gICAqIEByZXR1cm4ge0NvbnRlbnRBbnl9XG4gICAqL1xuICBzcGxpY2UgKG9mZnNldCkge1xuICAgIGNvbnN0IHJpZ2h0ID0gbmV3IENvbnRlbnRBbnkodGhpcy5hcnIuc2xpY2Uob2Zmc2V0KSlcbiAgICB0aGlzLmFyciA9IHRoaXMuYXJyLnNsaWNlKDAsIG9mZnNldClcbiAgICByZXR1cm4gcmlnaHRcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0NvbnRlbnRBbnl9IHJpZ2h0XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBtZXJnZVdpdGggKHJpZ2h0KSB7XG4gICAgdGhpcy5hcnIgPSB0aGlzLmFyci5jb25jYXQocmlnaHQuYXJyKVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtJdGVtfSBpdGVtXG4gICAqL1xuICBpbnRlZ3JhdGUgKHRyYW5zYWN0aW9uLCBpdGVtKSB7fVxuICAvKipcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICovXG4gIGRlbGV0ZSAodHJhbnNhY3Rpb24pIHt9XG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cnVjdFN0b3JlfSBzdG9yZVxuICAgKi9cbiAgZ2MgKHN0b3JlKSB7fVxuICAvKipcbiAgICogQHBhcmFtIHtVcGRhdGVFbmNvZGVyVjEgfCBVcGRhdGVFbmNvZGVyVjJ9IGVuY29kZXJcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICAgKi9cbiAgd3JpdGUgKGVuY29kZXIsIG9mZnNldCkge1xuICAgIGNvbnN0IGxlbiA9IHRoaXMuYXJyLmxlbmd0aFxuICAgIGVuY29kZXIud3JpdGVMZW4obGVuIC0gb2Zmc2V0KVxuICAgIGZvciAobGV0IGkgPSBvZmZzZXQ7IGkgPCBsZW47IGkrKykge1xuICAgICAgY29uc3QgYyA9IHRoaXMuYXJyW2ldXG4gICAgICBlbmNvZGVyLndyaXRlQW55KGMpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldFJlZiAoKSB7XG4gICAgcmV0dXJuIDhcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7VXBkYXRlRGVjb2RlclYxIHwgVXBkYXRlRGVjb2RlclYyfSBkZWNvZGVyXG4gKiBAcmV0dXJuIHtDb250ZW50QW55fVxuICovXG5leHBvcnQgY29uc3QgcmVhZENvbnRlbnRBbnkgPSBkZWNvZGVyID0+IHtcbiAgY29uc3QgbGVuID0gZGVjb2Rlci5yZWFkTGVuKClcbiAgY29uc3QgY3MgPSBbXVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgY3MucHVzaChkZWNvZGVyLnJlYWRBbnkoKSlcbiAgfVxuICByZXR1cm4gbmV3IENvbnRlbnRBbnkoY3MpXG59XG4iLCAiaW1wb3J0IHtcbiAgVXBkYXRlRGVjb2RlclYxLCBVcGRhdGVEZWNvZGVyVjIsIFVwZGF0ZUVuY29kZXJWMSwgVXBkYXRlRW5jb2RlclYyLCBUcmFuc2FjdGlvbiwgSXRlbSwgU3RydWN0U3RvcmUgLy8gZXNsaW50LWRpc2FibGUtbGluZVxufSBmcm9tICcuLi9pbnRlcm5hbHMuanMnXG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNsYXNzIENvbnRlbnRTdHJpbmcge1xuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICAgKi9cbiAgY29uc3RydWN0b3IgKHN0cikge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5zdHIgPSBzdHJcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRMZW5ndGggKCkge1xuICAgIHJldHVybiB0aGlzLnN0ci5sZW5ndGhcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtBcnJheTxhbnk+fVxuICAgKi9cbiAgZ2V0Q29udGVudCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RyLnNwbGl0KCcnKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBpc0NvdW50YWJsZSAoKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtDb250ZW50U3RyaW5nfVxuICAgKi9cbiAgY29weSAoKSB7XG4gICAgcmV0dXJuIG5ldyBDb250ZW50U3RyaW5nKHRoaXMuc3RyKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAgICogQHJldHVybiB7Q29udGVudFN0cmluZ31cbiAgICovXG4gIHNwbGljZSAob2Zmc2V0KSB7XG4gICAgY29uc3QgcmlnaHQgPSBuZXcgQ29udGVudFN0cmluZyh0aGlzLnN0ci5zbGljZShvZmZzZXQpKVxuICAgIHRoaXMuc3RyID0gdGhpcy5zdHIuc2xpY2UoMCwgb2Zmc2V0KVxuXG4gICAgLy8gUHJldmVudCBlbmNvZGluZyBpbnZhbGlkIGRvY3VtZW50cyBiZWNhdXNlIG9mIHNwbGl0dGluZyBvZiBzdXJyb2dhdGUgcGFpcnM6IGh0dHBzOi8vZ2l0aHViLmNvbS95anMveWpzL2lzc3Vlcy8yNDhcbiAgICBjb25zdCBmaXJzdENoYXJDb2RlID0gdGhpcy5zdHIuY2hhckNvZGVBdChvZmZzZXQgLSAxKVxuICAgIGlmIChmaXJzdENoYXJDb2RlID49IDB4RDgwMCAmJiBmaXJzdENoYXJDb2RlIDw9IDB4REJGRikge1xuICAgICAgLy8gTGFzdCBjaGFyYWN0ZXIgb2YgdGhlIGxlZnQgc3BsaXQgaXMgdGhlIHN0YXJ0IG9mIGEgc3Vycm9nYXRlIHV0ZjE2L3VjczIgcGFpci5cbiAgICAgIC8vIFdlIGRvbid0IHN1cHBvcnQgc3BsaXR0aW5nIG9mIHN1cnJvZ2F0ZSBwYWlycyBiZWNhdXNlIHRoaXMgbWF5IGxlYWQgdG8gaW52YWxpZCBkb2N1bWVudHMuXG4gICAgICAvLyBSZXBsYWNlIHRoZSBpbnZhbGlkIGNoYXJhY3RlciB3aXRoIGEgdW5pY29kZSByZXBsYWNlbWVudCBjaGFyYWN0ZXIgKO+/vSAvIFUrRkZGRClcbiAgICAgIHRoaXMuc3RyID0gdGhpcy5zdHIuc2xpY2UoMCwgb2Zmc2V0IC0gMSkgKyAn77+9J1xuICAgICAgLy8gcmVwbGFjZSByaWdodCBhcyB3ZWxsXG4gICAgICByaWdodC5zdHIgPSAn77+9JyArIHJpZ2h0LnN0ci5zbGljZSgxKVxuICAgIH1cbiAgICByZXR1cm4gcmlnaHRcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0NvbnRlbnRTdHJpbmd9IHJpZ2h0XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBtZXJnZVdpdGggKHJpZ2h0KSB7XG4gICAgdGhpcy5zdHIgKz0gcmlnaHQuc3RyXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge0l0ZW19IGl0ZW1cbiAgICovXG4gIGludGVncmF0ZSAodHJhbnNhY3Rpb24sIGl0ZW0pIHt9XG4gIC8qKlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKi9cbiAgZGVsZXRlICh0cmFuc2FjdGlvbikge31cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RydWN0U3RvcmV9IHN0b3JlXG4gICAqL1xuICBnYyAoc3RvcmUpIHt9XG4gIC8qKlxuICAgKiBAcGFyYW0ge1VwZGF0ZUVuY29kZXJWMSB8IFVwZGF0ZUVuY29kZXJWMn0gZW5jb2RlclxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gICAqL1xuICB3cml0ZSAoZW5jb2Rlciwgb2Zmc2V0KSB7XG4gICAgZW5jb2Rlci53cml0ZVN0cmluZyhvZmZzZXQgPT09IDAgPyB0aGlzLnN0ciA6IHRoaXMuc3RyLnNsaWNlKG9mZnNldCkpXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0UmVmICgpIHtcbiAgICByZXR1cm4gNFxuICB9XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqXG4gKiBAcGFyYW0ge1VwZGF0ZURlY29kZXJWMSB8IFVwZGF0ZURlY29kZXJWMn0gZGVjb2RlclxuICogQHJldHVybiB7Q29udGVudFN0cmluZ31cbiAqL1xuZXhwb3J0IGNvbnN0IHJlYWRDb250ZW50U3RyaW5nID0gZGVjb2RlciA9PiBuZXcgQ29udGVudFN0cmluZyhkZWNvZGVyLnJlYWRTdHJpbmcoKSlcbiIsICJcbmltcG9ydCB7XG4gIHJlYWRZQXJyYXksXG4gIHJlYWRZTWFwLFxuICByZWFkWVRleHQsXG4gIHJlYWRZWG1sRWxlbWVudCxcbiAgcmVhZFlYbWxGcmFnbWVudCxcbiAgcmVhZFlYbWxIb29rLFxuICByZWFkWVhtbFRleHQsXG4gIFVwZGF0ZURlY29kZXJWMSwgVXBkYXRlRGVjb2RlclYyLCBVcGRhdGVFbmNvZGVyVjEsIFVwZGF0ZUVuY29kZXJWMiwgU3RydWN0U3RvcmUsIFRyYW5zYWN0aW9uLCBJdGVtLCBZRXZlbnQsIEFic3RyYWN0VHlwZSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG59IGZyb20gJy4uL2ludGVybmFscy5qcydcblxuaW1wb3J0ICogYXMgZXJyb3IgZnJvbSAnbGliMC9lcnJvcidcblxuLyoqXG4gKiBAdHlwZSB7QXJyYXk8ZnVuY3Rpb24oVXBkYXRlRGVjb2RlclYxIHwgVXBkYXRlRGVjb2RlclYyKTpBYnN0cmFjdFR5cGU8YW55Pj59XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY29uc3QgdHlwZVJlZnMgPSBbXG4gIHJlYWRZQXJyYXksXG4gIHJlYWRZTWFwLFxuICByZWFkWVRleHQsXG4gIHJlYWRZWG1sRWxlbWVudCxcbiAgcmVhZFlYbWxGcmFnbWVudCxcbiAgcmVhZFlYbWxIb29rLFxuICByZWFkWVhtbFRleHRcbl1cblxuZXhwb3J0IGNvbnN0IFlBcnJheVJlZklEID0gMFxuZXhwb3J0IGNvbnN0IFlNYXBSZWZJRCA9IDFcbmV4cG9ydCBjb25zdCBZVGV4dFJlZklEID0gMlxuZXhwb3J0IGNvbnN0IFlYbWxFbGVtZW50UmVmSUQgPSAzXG5leHBvcnQgY29uc3QgWVhtbEZyYWdtZW50UmVmSUQgPSA0XG5leHBvcnQgY29uc3QgWVhtbEhvb2tSZWZJRCA9IDVcbmV4cG9ydCBjb25zdCBZWG1sVGV4dFJlZklEID0gNlxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBjbGFzcyBDb250ZW50VHlwZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxhbnk+fSB0eXBlXG4gICAqL1xuICBjb25zdHJ1Y3RvciAodHlwZSkge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55Pn1cbiAgICAgKi9cbiAgICB0aGlzLnR5cGUgPSB0eXBlXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0TGVuZ3RoICgpIHtcbiAgICByZXR1cm4gMVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0FycmF5PGFueT59XG4gICAqL1xuICBnZXRDb250ZW50ICgpIHtcbiAgICByZXR1cm4gW3RoaXMudHlwZV1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaXNDb3VudGFibGUgKCkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Q29udGVudFR5cGV9XG4gICAqL1xuICBjb3B5ICgpIHtcbiAgICByZXR1cm4gbmV3IENvbnRlbnRUeXBlKHRoaXMudHlwZS5fY29weSgpKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAgICogQHJldHVybiB7Q29udGVudFR5cGV9XG4gICAqL1xuICBzcGxpY2UgKG9mZnNldCkge1xuICAgIHRocm93IGVycm9yLm1ldGhvZFVuaW1wbGVtZW50ZWQoKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Q29udGVudFR5cGV9IHJpZ2h0XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBtZXJnZVdpdGggKHJpZ2h0KSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtJdGVtfSBpdGVtXG4gICAqL1xuICBpbnRlZ3JhdGUgKHRyYW5zYWN0aW9uLCBpdGVtKSB7XG4gICAgdGhpcy50eXBlLl9pbnRlZ3JhdGUodHJhbnNhY3Rpb24uZG9jLCBpdGVtKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqL1xuICBkZWxldGUgKHRyYW5zYWN0aW9uKSB7XG4gICAgbGV0IGl0ZW0gPSB0aGlzLnR5cGUuX3N0YXJ0XG4gICAgd2hpbGUgKGl0ZW0gIT09IG51bGwpIHtcbiAgICAgIGlmICghaXRlbS5kZWxldGVkKSB7XG4gICAgICAgIGl0ZW0uZGVsZXRlKHRyYW5zYWN0aW9uKVxuICAgICAgfSBlbHNlIGlmIChpdGVtLmlkLmNsb2NrIDwgKHRyYW5zYWN0aW9uLmJlZm9yZVN0YXRlLmdldChpdGVtLmlkLmNsaWVudCkgfHwgMCkpIHtcbiAgICAgICAgLy8gVGhpcyB3aWxsIGJlIGdjJ2QgbGF0ZXIgYW5kIHdlIHdhbnQgdG8gbWVyZ2UgaXQgaWYgcG9zc2libGVcbiAgICAgICAgLy8gV2UgdHJ5IHRvIG1lcmdlIGFsbCBkZWxldGVkIGl0ZW1zIGFmdGVyIGVhY2ggdHJhbnNhY3Rpb24sXG4gICAgICAgIC8vIGJ1dCB3ZSBoYXZlIG5vIGtub3dsZWRnZSBhYm91dCB0aGF0IHRoaXMgbmVlZHMgdG8gYmUgbWVyZ2VkXG4gICAgICAgIC8vIHNpbmNlIGl0IGlzIG5vdCBpbiB0cmFuc2FjdGlvbi5kcy4gSGVuY2Ugd2UgYWRkIGl0IHRvIHRyYW5zYWN0aW9uLl9tZXJnZVN0cnVjdHNcbiAgICAgICAgdHJhbnNhY3Rpb24uX21lcmdlU3RydWN0cy5wdXNoKGl0ZW0pXG4gICAgICB9XG4gICAgICBpdGVtID0gaXRlbS5yaWdodFxuICAgIH1cbiAgICB0aGlzLnR5cGUuX21hcC5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgaWYgKCFpdGVtLmRlbGV0ZWQpIHtcbiAgICAgICAgaXRlbS5kZWxldGUodHJhbnNhY3Rpb24pXG4gICAgICB9IGVsc2UgaWYgKGl0ZW0uaWQuY2xvY2sgPCAodHJhbnNhY3Rpb24uYmVmb3JlU3RhdGUuZ2V0KGl0ZW0uaWQuY2xpZW50KSB8fCAwKSkge1xuICAgICAgICAvLyBzYW1lIGFzIGFib3ZlXG4gICAgICAgIHRyYW5zYWN0aW9uLl9tZXJnZVN0cnVjdHMucHVzaChpdGVtKVxuICAgICAgfVxuICAgIH0pXG4gICAgdHJhbnNhY3Rpb24uY2hhbmdlZC5kZWxldGUodGhpcy50eXBlKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RydWN0U3RvcmV9IHN0b3JlXG4gICAqL1xuICBnYyAoc3RvcmUpIHtcbiAgICBsZXQgaXRlbSA9IHRoaXMudHlwZS5fc3RhcnRcbiAgICB3aGlsZSAoaXRlbSAhPT0gbnVsbCkge1xuICAgICAgaXRlbS5nYyhzdG9yZSwgdHJ1ZSlcbiAgICAgIGl0ZW0gPSBpdGVtLnJpZ2h0XG4gICAgfVxuICAgIHRoaXMudHlwZS5fc3RhcnQgPSBudWxsXG4gICAgdGhpcy50eXBlLl9tYXAuZm9yRWFjaCgvKiogQHBhcmFtIHtJdGVtIHwgbnVsbH0gaXRlbSAqLyAoaXRlbSkgPT4ge1xuICAgICAgd2hpbGUgKGl0ZW0gIT09IG51bGwpIHtcbiAgICAgICAgaXRlbS5nYyhzdG9yZSwgdHJ1ZSlcbiAgICAgICAgaXRlbSA9IGl0ZW0ubGVmdFxuICAgICAgfVxuICAgIH0pXG4gICAgdGhpcy50eXBlLl9tYXAgPSBuZXcgTWFwKClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1VwZGF0ZUVuY29kZXJWMSB8IFVwZGF0ZUVuY29kZXJWMn0gZW5jb2RlclxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gICAqL1xuICB3cml0ZSAoZW5jb2Rlciwgb2Zmc2V0KSB7XG4gICAgdGhpcy50eXBlLl93cml0ZShlbmNvZGVyKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldFJlZiAoKSB7XG4gICAgcmV0dXJuIDdcbiAgfVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKlxuICogQHBhcmFtIHtVcGRhdGVEZWNvZGVyVjEgfCBVcGRhdGVEZWNvZGVyVjJ9IGRlY29kZXJcbiAqIEByZXR1cm4ge0NvbnRlbnRUeXBlfVxuICovXG5leHBvcnQgY29uc3QgcmVhZENvbnRlbnRUeXBlID0gZGVjb2RlciA9PiBuZXcgQ29udGVudFR5cGUodHlwZVJlZnNbZGVjb2Rlci5yZWFkVHlwZVJlZigpXShkZWNvZGVyKSlcbiIsICJcbmltcG9ydCB7XG4gIEdDLFxuICBnZXRTdGF0ZSxcbiAgQWJzdHJhY3RTdHJ1Y3QsXG4gIHJlcGxhY2VTdHJ1Y3QsXG4gIGFkZFN0cnVjdCxcbiAgYWRkVG9EZWxldGVTZXQsXG4gIGZpbmRSb290VHlwZUtleSxcbiAgY29tcGFyZUlEcyxcbiAgZ2V0SXRlbSxcbiAgZ2V0SXRlbUNsZWFuRW5kLFxuICBnZXRJdGVtQ2xlYW5TdGFydCxcbiAgcmVhZENvbnRlbnREZWxldGVkLFxuICByZWFkQ29udGVudEJpbmFyeSxcbiAgcmVhZENvbnRlbnRKU09OLFxuICByZWFkQ29udGVudEFueSxcbiAgcmVhZENvbnRlbnRTdHJpbmcsXG4gIHJlYWRDb250ZW50RW1iZWQsXG4gIHJlYWRDb250ZW50RG9jLFxuICBjcmVhdGVJRCxcbiAgcmVhZENvbnRlbnRGb3JtYXQsXG4gIHJlYWRDb250ZW50VHlwZSxcbiAgYWRkQ2hhbmdlZFR5cGVUb1RyYW5zYWN0aW9uLFxuICBpc0RlbGV0ZWQsXG4gIFN0YWNrSXRlbSwgRGVsZXRlU2V0LCBVcGRhdGVEZWNvZGVyVjEsIFVwZGF0ZURlY29kZXJWMiwgVXBkYXRlRW5jb2RlclYxLCBVcGRhdGVFbmNvZGVyVjIsIENvbnRlbnRUeXBlLCBDb250ZW50RGVsZXRlZCwgU3RydWN0U3RvcmUsIElELCBBYnN0cmFjdFR5cGUsIFRyYW5zYWN0aW9uIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbn0gZnJvbSAnLi4vaW50ZXJuYWxzLmpzJ1xuXG5pbXBvcnQgKiBhcyBlcnJvciBmcm9tICdsaWIwL2Vycm9yJ1xuaW1wb3J0ICogYXMgYmluYXJ5IGZyb20gJ2xpYjAvYmluYXJ5J1xuaW1wb3J0ICogYXMgYXJyYXkgZnJvbSAnbGliMC9hcnJheSdcblxuLyoqXG4gKiBAdG9kbyBUaGlzIHNob3VsZCByZXR1cm4gc2V2ZXJhbCBpdGVtc1xuICpcbiAqIEBwYXJhbSB7U3RydWN0U3RvcmV9IHN0b3JlXG4gKiBAcGFyYW0ge0lEfSBpZFxuICogQHJldHVybiB7e2l0ZW06SXRlbSwgZGlmZjpudW1iZXJ9fVxuICovXG5leHBvcnQgY29uc3QgZm9sbG93UmVkb25lID0gKHN0b3JlLCBpZCkgPT4ge1xuICAvKipcbiAgICogQHR5cGUge0lEfG51bGx9XG4gICAqL1xuICBsZXQgbmV4dElEID0gaWRcbiAgbGV0IGRpZmYgPSAwXG4gIGxldCBpdGVtXG4gIGRvIHtcbiAgICBpZiAoZGlmZiA+IDApIHtcbiAgICAgIG5leHRJRCA9IGNyZWF0ZUlEKG5leHRJRC5jbGllbnQsIG5leHRJRC5jbG9jayArIGRpZmYpXG4gICAgfVxuICAgIGl0ZW0gPSBnZXRJdGVtKHN0b3JlLCBuZXh0SUQpXG4gICAgZGlmZiA9IG5leHRJRC5jbG9jayAtIGl0ZW0uaWQuY2xvY2tcbiAgICBuZXh0SUQgPSBpdGVtLnJlZG9uZVxuICB9IHdoaWxlIChuZXh0SUQgIT09IG51bGwgJiYgaXRlbSBpbnN0YW5jZW9mIEl0ZW0pXG4gIHJldHVybiB7XG4gICAgaXRlbSwgZGlmZlxuICB9XG59XG5cbi8qKlxuICogTWFrZSBzdXJlIHRoYXQgbmVpdGhlciBpdGVtIG5vciBhbnkgb2YgaXRzIHBhcmVudHMgaXMgZXZlciBkZWxldGVkLlxuICpcbiAqIFRoaXMgcHJvcGVydHkgZG9lcyBub3QgcGVyc2lzdCB3aGVuIHN0b3JpbmcgaXQgaW50byBhIGRhdGFiYXNlIG9yIHdoZW5cbiAqIHNlbmRpbmcgaXQgdG8gb3RoZXIgcGVlcnNcbiAqXG4gKiBAcGFyYW0ge0l0ZW18bnVsbH0gaXRlbVxuICogQHBhcmFtIHtib29sZWFufSBrZWVwXG4gKi9cbmV4cG9ydCBjb25zdCBrZWVwSXRlbSA9IChpdGVtLCBrZWVwKSA9PiB7XG4gIHdoaWxlIChpdGVtICE9PSBudWxsICYmIGl0ZW0ua2VlcCAhPT0ga2VlcCkge1xuICAgIGl0ZW0ua2VlcCA9IGtlZXBcbiAgICBpdGVtID0gLyoqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55Pn0gKi8gKGl0ZW0ucGFyZW50KS5faXRlbVxuICB9XG59XG5cbi8qKlxuICogU3BsaXQgbGVmdEl0ZW0gaW50byB0d28gaXRlbXNcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge0l0ZW19IGxlZnRJdGVtXG4gKiBAcGFyYW0ge251bWJlcn0gZGlmZlxuICogQHJldHVybiB7SXRlbX1cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBjb25zdCBzcGxpdEl0ZW0gPSAodHJhbnNhY3Rpb24sIGxlZnRJdGVtLCBkaWZmKSA9PiB7XG4gIC8vIGNyZWF0ZSByaWdodEl0ZW1cbiAgY29uc3QgeyBjbGllbnQsIGNsb2NrIH0gPSBsZWZ0SXRlbS5pZFxuICBjb25zdCByaWdodEl0ZW0gPSBuZXcgSXRlbShcbiAgICBjcmVhdGVJRChjbGllbnQsIGNsb2NrICsgZGlmZiksXG4gICAgbGVmdEl0ZW0sXG4gICAgY3JlYXRlSUQoY2xpZW50LCBjbG9jayArIGRpZmYgLSAxKSxcbiAgICBsZWZ0SXRlbS5yaWdodCxcbiAgICBsZWZ0SXRlbS5yaWdodE9yaWdpbixcbiAgICBsZWZ0SXRlbS5wYXJlbnQsXG4gICAgbGVmdEl0ZW0ucGFyZW50U3ViLFxuICAgIGxlZnRJdGVtLmNvbnRlbnQuc3BsaWNlKGRpZmYpXG4gIClcbiAgaWYgKGxlZnRJdGVtLmRlbGV0ZWQpIHtcbiAgICByaWdodEl0ZW0ubWFya0RlbGV0ZWQoKVxuICB9XG4gIGlmIChsZWZ0SXRlbS5rZWVwKSB7XG4gICAgcmlnaHRJdGVtLmtlZXAgPSB0cnVlXG4gIH1cbiAgaWYgKGxlZnRJdGVtLnJlZG9uZSAhPT0gbnVsbCkge1xuICAgIHJpZ2h0SXRlbS5yZWRvbmUgPSBjcmVhdGVJRChsZWZ0SXRlbS5yZWRvbmUuY2xpZW50LCBsZWZ0SXRlbS5yZWRvbmUuY2xvY2sgKyBkaWZmKVxuICB9XG4gIC8vIHVwZGF0ZSBsZWZ0IChkbyBub3Qgc2V0IGxlZnRJdGVtLnJpZ2h0T3JpZ2luIGFzIGl0IHdpbGwgbGVhZCB0byBwcm9ibGVtcyB3aGVuIHN5bmNpbmcpXG4gIGxlZnRJdGVtLnJpZ2h0ID0gcmlnaHRJdGVtXG4gIC8vIHVwZGF0ZSByaWdodFxuICBpZiAocmlnaHRJdGVtLnJpZ2h0ICE9PSBudWxsKSB7XG4gICAgcmlnaHRJdGVtLnJpZ2h0LmxlZnQgPSByaWdodEl0ZW1cbiAgfVxuICAvLyByaWdodCBpcyBtb3JlIHNwZWNpZmljLlxuICB0cmFuc2FjdGlvbi5fbWVyZ2VTdHJ1Y3RzLnB1c2gocmlnaHRJdGVtKVxuICAvLyB1cGRhdGUgcGFyZW50Ll9tYXBcbiAgaWYgKHJpZ2h0SXRlbS5wYXJlbnRTdWIgIT09IG51bGwgJiYgcmlnaHRJdGVtLnJpZ2h0ID09PSBudWxsKSB7XG4gICAgLyoqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55Pn0gKi8gKHJpZ2h0SXRlbS5wYXJlbnQpLl9tYXAuc2V0KHJpZ2h0SXRlbS5wYXJlbnRTdWIsIHJpZ2h0SXRlbSlcbiAgfVxuICBsZWZ0SXRlbS5sZW5ndGggPSBkaWZmXG4gIHJldHVybiByaWdodEl0ZW1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PFN0YWNrSXRlbT59IHN0YWNrXG4gKiBAcGFyYW0ge0lEfSBpZFxuICovXG5jb25zdCBpc0RlbGV0ZWRCeVVuZG9TdGFjayA9IChzdGFjaywgaWQpID0+IGFycmF5LnNvbWUoc3RhY2ssIC8qKiBAcGFyYW0ge1N0YWNrSXRlbX0gcyAqLyBzID0+IGlzRGVsZXRlZChzLmRlbGV0aW9ucywgaWQpKVxuXG4vKipcbiAqIFJlZG9lcyB0aGUgZWZmZWN0IG9mIHRoaXMgb3BlcmF0aW9uLlxuICpcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uIFRoZSBZanMgaW5zdGFuY2UuXG4gKiBAcGFyYW0ge0l0ZW19IGl0ZW1cbiAqIEBwYXJhbSB7U2V0PEl0ZW0+fSByZWRvaXRlbXNcbiAqIEBwYXJhbSB7RGVsZXRlU2V0fSBpdGVtc1RvRGVsZXRlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlnbm9yZVJlbW90ZU1hcENoYW5nZXNcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi91dGlscy9VbmRvTWFuYWdlci5qcycpLlVuZG9NYW5hZ2VyfSB1bVxuICpcbiAqIEByZXR1cm4ge0l0ZW18bnVsbH1cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY29uc3QgcmVkb0l0ZW0gPSAodHJhbnNhY3Rpb24sIGl0ZW0sIHJlZG9pdGVtcywgaXRlbXNUb0RlbGV0ZSwgaWdub3JlUmVtb3RlTWFwQ2hhbmdlcywgdW0pID0+IHtcbiAgY29uc3QgZG9jID0gdHJhbnNhY3Rpb24uZG9jXG4gIGNvbnN0IHN0b3JlID0gZG9jLnN0b3JlXG4gIGNvbnN0IG93bkNsaWVudElEID0gZG9jLmNsaWVudElEXG4gIGNvbnN0IHJlZG9uZSA9IGl0ZW0ucmVkb25lXG4gIGlmIChyZWRvbmUgIT09IG51bGwpIHtcbiAgICByZXR1cm4gZ2V0SXRlbUNsZWFuU3RhcnQodHJhbnNhY3Rpb24sIHJlZG9uZSlcbiAgfVxuICBsZXQgcGFyZW50SXRlbSA9IC8qKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT59ICovIChpdGVtLnBhcmVudCkuX2l0ZW1cbiAgLyoqXG4gICAqIEB0eXBlIHtJdGVtfG51bGx9XG4gICAqL1xuICBsZXQgbGVmdCA9IG51bGxcbiAgLyoqXG4gICAqIEB0eXBlIHtJdGVtfG51bGx9XG4gICAqL1xuICBsZXQgcmlnaHRcbiAgLy8gbWFrZSBzdXJlIHRoYXQgcGFyZW50IGlzIHJlZG9uZVxuICBpZiAocGFyZW50SXRlbSAhPT0gbnVsbCAmJiBwYXJlbnRJdGVtLmRlbGV0ZWQgPT09IHRydWUpIHtcbiAgICAvLyB0cnkgdG8gdW5kbyBwYXJlbnQgaWYgaXQgd2lsbCBiZSB1bmRvbmUgYW55d2F5XG4gICAgaWYgKHBhcmVudEl0ZW0ucmVkb25lID09PSBudWxsICYmICghcmVkb2l0ZW1zLmhhcyhwYXJlbnRJdGVtKSB8fCByZWRvSXRlbSh0cmFuc2FjdGlvbiwgcGFyZW50SXRlbSwgcmVkb2l0ZW1zLCBpdGVtc1RvRGVsZXRlLCBpZ25vcmVSZW1vdGVNYXBDaGFuZ2VzLCB1bSkgPT09IG51bGwpKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgICB3aGlsZSAocGFyZW50SXRlbS5yZWRvbmUgIT09IG51bGwpIHtcbiAgICAgIHBhcmVudEl0ZW0gPSBnZXRJdGVtQ2xlYW5TdGFydCh0cmFuc2FjdGlvbiwgcGFyZW50SXRlbS5yZWRvbmUpXG4gICAgfVxuICB9XG4gIGNvbnN0IHBhcmVudFR5cGUgPSBwYXJlbnRJdGVtID09PSBudWxsID8gLyoqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55Pn0gKi8gKGl0ZW0ucGFyZW50KSA6IC8qKiBAdHlwZSB7Q29udGVudFR5cGV9ICovIChwYXJlbnRJdGVtLmNvbnRlbnQpLnR5cGVcblxuICBpZiAoaXRlbS5wYXJlbnRTdWIgPT09IG51bGwpIHtcbiAgICAvLyBJcyBhbiBhcnJheSBpdGVtLiBJbnNlcnQgYXQgdGhlIG9sZCBwb3NpdGlvblxuICAgIGxlZnQgPSBpdGVtLmxlZnRcbiAgICByaWdodCA9IGl0ZW1cbiAgICAvLyBmaW5kIG5leHQgY2xvbmVkX3JlZG8gaXRlbXNcbiAgICB3aGlsZSAobGVmdCAhPT0gbnVsbCkge1xuICAgICAgLyoqXG4gICAgICAgKiBAdHlwZSB7SXRlbXxudWxsfVxuICAgICAgICovXG4gICAgICBsZXQgbGVmdFRyYWNlID0gbGVmdFxuICAgICAgLy8gdHJhY2UgcmVkb25lIHVudGlsIHBhcmVudCBtYXRjaGVzXG4gICAgICB3aGlsZSAobGVmdFRyYWNlICE9PSBudWxsICYmIC8qKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT59ICovIChsZWZ0VHJhY2UucGFyZW50KS5faXRlbSAhPT0gcGFyZW50SXRlbSkge1xuICAgICAgICBsZWZ0VHJhY2UgPSBsZWZ0VHJhY2UucmVkb25lID09PSBudWxsID8gbnVsbCA6IGdldEl0ZW1DbGVhblN0YXJ0KHRyYW5zYWN0aW9uLCBsZWZ0VHJhY2UucmVkb25lKVxuICAgICAgfVxuICAgICAgaWYgKGxlZnRUcmFjZSAhPT0gbnVsbCAmJiAvKiogQHR5cGUge0Fic3RyYWN0VHlwZTxhbnk+fSAqLyAobGVmdFRyYWNlLnBhcmVudCkuX2l0ZW0gPT09IHBhcmVudEl0ZW0pIHtcbiAgICAgICAgbGVmdCA9IGxlZnRUcmFjZVxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgbGVmdCA9IGxlZnQubGVmdFxuICAgIH1cbiAgICB3aGlsZSAocmlnaHQgIT09IG51bGwpIHtcbiAgICAgIC8qKlxuICAgICAgICogQHR5cGUge0l0ZW18bnVsbH1cbiAgICAgICAqL1xuICAgICAgbGV0IHJpZ2h0VHJhY2UgPSByaWdodFxuICAgICAgLy8gdHJhY2UgcmVkb25lIHVudGlsIHBhcmVudCBtYXRjaGVzXG4gICAgICB3aGlsZSAocmlnaHRUcmFjZSAhPT0gbnVsbCAmJiAvKiogQHR5cGUge0Fic3RyYWN0VHlwZTxhbnk+fSAqLyAocmlnaHRUcmFjZS5wYXJlbnQpLl9pdGVtICE9PSBwYXJlbnRJdGVtKSB7XG4gICAgICAgIHJpZ2h0VHJhY2UgPSByaWdodFRyYWNlLnJlZG9uZSA9PT0gbnVsbCA/IG51bGwgOiBnZXRJdGVtQ2xlYW5TdGFydCh0cmFuc2FjdGlvbiwgcmlnaHRUcmFjZS5yZWRvbmUpXG4gICAgICB9XG4gICAgICBpZiAocmlnaHRUcmFjZSAhPT0gbnVsbCAmJiAvKiogQHR5cGUge0Fic3RyYWN0VHlwZTxhbnk+fSAqLyAocmlnaHRUcmFjZS5wYXJlbnQpLl9pdGVtID09PSBwYXJlbnRJdGVtKSB7XG4gICAgICAgIHJpZ2h0ID0gcmlnaHRUcmFjZVxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgcmlnaHQgPSByaWdodC5yaWdodFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByaWdodCA9IG51bGxcbiAgICBpZiAoaXRlbS5yaWdodCAmJiAhaWdub3JlUmVtb3RlTWFwQ2hhbmdlcykge1xuICAgICAgbGVmdCA9IGl0ZW1cbiAgICAgIC8vIEl0ZXJhdGUgcmlnaHQgd2hpbGUgcmlnaHQgaXMgaW4gaXRlbXNUb0RlbGV0ZVxuICAgICAgLy8gSWYgaXQgaXMgaW50ZW5kZWQgdG8gZGVsZXRlIHJpZ2h0IHdoaWxlIGl0ZW0gaXMgcmVkb25lLCB3ZSBjYW4gZXhwZWN0IHRoYXQgaXRlbSBzaG91bGQgcmVwbGFjZSByaWdodC5cbiAgICAgIHdoaWxlIChsZWZ0ICE9PSBudWxsICYmIGxlZnQucmlnaHQgIT09IG51bGwgJiYgKGxlZnQucmlnaHQucmVkb25lIHx8IGlzRGVsZXRlZChpdGVtc1RvRGVsZXRlLCBsZWZ0LnJpZ2h0LmlkKSB8fCBpc0RlbGV0ZWRCeVVuZG9TdGFjayh1bS51bmRvU3RhY2ssIGxlZnQucmlnaHQuaWQpIHx8IGlzRGVsZXRlZEJ5VW5kb1N0YWNrKHVtLnJlZG9TdGFjaywgbGVmdC5yaWdodC5pZCkpKSB7XG4gICAgICAgIGxlZnQgPSBsZWZ0LnJpZ2h0XG4gICAgICAgIC8vIGZvbGxvdyByZWRvbmVcbiAgICAgICAgd2hpbGUgKGxlZnQucmVkb25lKSBsZWZ0ID0gZ2V0SXRlbUNsZWFuU3RhcnQodHJhbnNhY3Rpb24sIGxlZnQucmVkb25lKVxuICAgICAgfVxuICAgICAgaWYgKGxlZnQgJiYgbGVmdC5yaWdodCAhPT0gbnVsbCkge1xuICAgICAgICAvLyBJdCBpcyBub3QgcG9zc2libGUgdG8gcmVkbyB0aGlzIGl0ZW0gYmVjYXVzZSBpdCBjb25mbGljdHMgd2l0aCBhXG4gICAgICAgIC8vIGNoYW5nZSBmcm9tIGFub3RoZXIgY2xpZW50XG4gICAgICAgIHJldHVybiBudWxsXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxlZnQgPSBwYXJlbnRUeXBlLl9tYXAuZ2V0KGl0ZW0ucGFyZW50U3ViKSB8fCBudWxsXG4gICAgfVxuICB9XG4gIGNvbnN0IG5leHRDbG9jayA9IGdldFN0YXRlKHN0b3JlLCBvd25DbGllbnRJRClcbiAgY29uc3QgbmV4dElkID0gY3JlYXRlSUQob3duQ2xpZW50SUQsIG5leHRDbG9jaylcbiAgY29uc3QgcmVkb25lSXRlbSA9IG5ldyBJdGVtKFxuICAgIG5leHRJZCxcbiAgICBsZWZ0LCBsZWZ0ICYmIGxlZnQubGFzdElkLFxuICAgIHJpZ2h0LCByaWdodCAmJiByaWdodC5pZCxcbiAgICBwYXJlbnRUeXBlLFxuICAgIGl0ZW0ucGFyZW50U3ViLFxuICAgIGl0ZW0uY29udGVudC5jb3B5KClcbiAgKVxuICBpdGVtLnJlZG9uZSA9IG5leHRJZFxuICBrZWVwSXRlbShyZWRvbmVJdGVtLCB0cnVlKVxuICByZWRvbmVJdGVtLmludGVncmF0ZSh0cmFuc2FjdGlvbiwgMClcbiAgcmV0dXJuIHJlZG9uZUl0ZW1cbn1cblxuLyoqXG4gKiBBYnN0cmFjdCBjbGFzcyB0aGF0IHJlcHJlc2VudHMgYW55IGNvbnRlbnQuXG4gKi9cbmV4cG9ydCBjbGFzcyBJdGVtIGV4dGVuZHMgQWJzdHJhY3RTdHJ1Y3Qge1xuICAvKipcbiAgICogQHBhcmFtIHtJRH0gaWRcbiAgICogQHBhcmFtIHtJdGVtIHwgbnVsbH0gbGVmdFxuICAgKiBAcGFyYW0ge0lEIHwgbnVsbH0gb3JpZ2luXG4gICAqIEBwYXJhbSB7SXRlbSB8IG51bGx9IHJpZ2h0XG4gICAqIEBwYXJhbSB7SUQgfCBudWxsfSByaWdodE9yaWdpblxuICAgKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxhbnk+fElEfG51bGx9IHBhcmVudCBJcyBhIHR5cGUgaWYgaW50ZWdyYXRlZCwgaXMgbnVsbCBpZiBpdCBpcyBwb3NzaWJsZSB0byBjb3B5IHBhcmVudCBmcm9tIGxlZnQgb3IgcmlnaHQsIGlzIElEIGJlZm9yZSBpbnRlZ3JhdGlvbiB0byBzZWFyY2ggZm9yIGl0LlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IG51bGx9IHBhcmVudFN1YlxuICAgKiBAcGFyYW0ge0Fic3RyYWN0Q29udGVudH0gY29udGVudFxuICAgKi9cbiAgY29uc3RydWN0b3IgKGlkLCBsZWZ0LCBvcmlnaW4sIHJpZ2h0LCByaWdodE9yaWdpbiwgcGFyZW50LCBwYXJlbnRTdWIsIGNvbnRlbnQpIHtcbiAgICBzdXBlcihpZCwgY29udGVudC5nZXRMZW5ndGgoKSlcbiAgICAvKipcbiAgICAgKiBUaGUgaXRlbSB0aGF0IHdhcyBvcmlnaW5hbGx5IHRvIHRoZSBsZWZ0IG9mIHRoaXMgaXRlbS5cbiAgICAgKiBAdHlwZSB7SUQgfCBudWxsfVxuICAgICAqL1xuICAgIHRoaXMub3JpZ2luID0gb3JpZ2luXG4gICAgLyoqXG4gICAgICogVGhlIGl0ZW0gdGhhdCBpcyBjdXJyZW50bHkgdG8gdGhlIGxlZnQgb2YgdGhpcyBpdGVtLlxuICAgICAqIEB0eXBlIHtJdGVtIHwgbnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLmxlZnQgPSBsZWZ0XG4gICAgLyoqXG4gICAgICogVGhlIGl0ZW0gdGhhdCBpcyBjdXJyZW50bHkgdG8gdGhlIHJpZ2h0IG9mIHRoaXMgaXRlbS5cbiAgICAgKiBAdHlwZSB7SXRlbSB8IG51bGx9XG4gICAgICovXG4gICAgdGhpcy5yaWdodCA9IHJpZ2h0XG4gICAgLyoqXG4gICAgICogVGhlIGl0ZW0gdGhhdCB3YXMgb3JpZ2luYWxseSB0byB0aGUgcmlnaHQgb2YgdGhpcyBpdGVtLlxuICAgICAqIEB0eXBlIHtJRCB8IG51bGx9XG4gICAgICovXG4gICAgdGhpcy5yaWdodE9yaWdpbiA9IHJpZ2h0T3JpZ2luXG4gICAgLyoqXG4gICAgICogQHR5cGUge0Fic3RyYWN0VHlwZTxhbnk+fElEfG51bGx9XG4gICAgICovXG4gICAgdGhpcy5wYXJlbnQgPSBwYXJlbnRcbiAgICAvKipcbiAgICAgKiBJZiB0aGUgcGFyZW50IHJlZmVycyB0byB0aGlzIGl0ZW0gd2l0aCBzb21lIGtpbmQgb2Yga2V5IChlLmcuIFlNYXAsIHRoZVxuICAgICAqIGtleSBpcyBzcGVjaWZpZWQgaGVyZS4gVGhlIGtleSBpcyB0aGVuIHVzZWQgdG8gcmVmZXIgdG8gdGhlIGxpc3QgaW4gd2hpY2hcbiAgICAgKiB0byBpbnNlcnQgdGhpcyBpdGVtLiBJZiBgcGFyZW50U3ViID0gbnVsbGAgdHlwZS5fc3RhcnQgaXMgdGhlIGxpc3QgaW5cbiAgICAgKiB3aGljaCB0byBpbnNlcnQgdG8uIE90aGVyd2lzZSBpdCBpcyBgcGFyZW50Ll9tYXBgLlxuICAgICAqIEB0eXBlIHtTdHJpbmcgfCBudWxsfVxuICAgICAqL1xuICAgIHRoaXMucGFyZW50U3ViID0gcGFyZW50U3ViXG4gICAgLyoqXG4gICAgICogSWYgdGhpcyB0eXBlJ3MgZWZmZWN0IGlzIHJlZG9uZSB0aGlzIHR5cGUgcmVmZXJzIHRvIHRoZSB0eXBlIHRoYXQgdW5kaWRcbiAgICAgKiB0aGlzIG9wZXJhdGlvbi5cbiAgICAgKiBAdHlwZSB7SUQgfCBudWxsfVxuICAgICAqL1xuICAgIHRoaXMucmVkb25lID0gbnVsbFxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBYnN0cmFjdENvbnRlbnR9XG4gICAgICovXG4gICAgdGhpcy5jb250ZW50ID0gY29udGVudFxuICAgIC8qKlxuICAgICAqIGJpdDE6IGtlZXBcbiAgICAgKiBiaXQyOiBjb3VudGFibGVcbiAgICAgKiBiaXQzOiBkZWxldGVkXG4gICAgICogYml0NDogbWFyayAtIG1hcmsgbm9kZSBhcyBmYXN0LXNlYXJjaC1tYXJrZXJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfSBieXRlXG4gICAgICovXG4gICAgdGhpcy5pbmZvID0gdGhpcy5jb250ZW50LmlzQ291bnRhYmxlKCkgPyBiaW5hcnkuQklUMiA6IDBcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGlzIHVzZWQgdG8gbWFyayB0aGUgaXRlbSBhcyBhbiBpbmRleGVkIGZhc3Qtc2VhcmNoIG1hcmtlclxuICAgKlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIHNldCBtYXJrZXIgKGlzTWFya2VkKSB7XG4gICAgaWYgKCgodGhpcy5pbmZvICYgYmluYXJ5LkJJVDQpID4gMCkgIT09IGlzTWFya2VkKSB7XG4gICAgICB0aGlzLmluZm8gXj0gYmluYXJ5LkJJVDRcbiAgICB9XG4gIH1cblxuICBnZXQgbWFya2VyICgpIHtcbiAgICByZXR1cm4gKHRoaXMuaW5mbyAmIGJpbmFyeS5CSVQ0KSA+IDBcbiAgfVxuXG4gIC8qKlxuICAgKiBJZiB0cnVlLCBkbyBub3QgZ2FyYmFnZSBjb2xsZWN0IHRoaXMgSXRlbS5cbiAgICovXG4gIGdldCBrZWVwICgpIHtcbiAgICByZXR1cm4gKHRoaXMuaW5mbyAmIGJpbmFyeS5CSVQxKSA+IDBcbiAgfVxuXG4gIHNldCBrZWVwIChkb0tlZXApIHtcbiAgICBpZiAodGhpcy5rZWVwICE9PSBkb0tlZXApIHtcbiAgICAgIHRoaXMuaW5mbyBePSBiaW5hcnkuQklUMVxuICAgIH1cbiAgfVxuXG4gIGdldCBjb3VudGFibGUgKCkge1xuICAgIHJldHVybiAodGhpcy5pbmZvICYgYmluYXJ5LkJJVDIpID4gMFxuICB9XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhpcyBpdGVtIHdhcyBkZWxldGVkIG9yIG5vdC5cbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqL1xuICBnZXQgZGVsZXRlZCAoKSB7XG4gICAgcmV0dXJuICh0aGlzLmluZm8gJiBiaW5hcnkuQklUMykgPiAwXG4gIH1cblxuICBzZXQgZGVsZXRlZCAoZG9EZWxldGUpIHtcbiAgICBpZiAodGhpcy5kZWxldGVkICE9PSBkb0RlbGV0ZSkge1xuICAgICAgdGhpcy5pbmZvIF49IGJpbmFyeS5CSVQzXG4gICAgfVxuICB9XG5cbiAgbWFya0RlbGV0ZWQgKCkge1xuICAgIHRoaXMuaW5mbyB8PSBiaW5hcnkuQklUM1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgY3JlYXRvciBjbGllbnRJRCBvZiB0aGUgbWlzc2luZyBvcCBvciBkZWZpbmUgbWlzc2luZyBpdGVtcyBhbmQgcmV0dXJuIG51bGwuXG4gICAqXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7U3RydWN0U3RvcmV9IHN0b3JlXG4gICAqIEByZXR1cm4ge251bGwgfCBudW1iZXJ9XG4gICAqL1xuICBnZXRNaXNzaW5nICh0cmFuc2FjdGlvbiwgc3RvcmUpIHtcbiAgICBpZiAodGhpcy5vcmlnaW4gJiYgdGhpcy5vcmlnaW4uY2xpZW50ICE9PSB0aGlzLmlkLmNsaWVudCAmJiB0aGlzLm9yaWdpbi5jbG9jayA+PSBnZXRTdGF0ZShzdG9yZSwgdGhpcy5vcmlnaW4uY2xpZW50KSkge1xuICAgICAgcmV0dXJuIHRoaXMub3JpZ2luLmNsaWVudFxuICAgIH1cbiAgICBpZiAodGhpcy5yaWdodE9yaWdpbiAmJiB0aGlzLnJpZ2h0T3JpZ2luLmNsaWVudCAhPT0gdGhpcy5pZC5jbGllbnQgJiYgdGhpcy5yaWdodE9yaWdpbi5jbG9jayA+PSBnZXRTdGF0ZShzdG9yZSwgdGhpcy5yaWdodE9yaWdpbi5jbGllbnQpKSB7XG4gICAgICByZXR1cm4gdGhpcy5yaWdodE9yaWdpbi5jbGllbnRcbiAgICB9XG4gICAgaWYgKHRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50LmNvbnN0cnVjdG9yID09PSBJRCAmJiB0aGlzLmlkLmNsaWVudCAhPT0gdGhpcy5wYXJlbnQuY2xpZW50ICYmIHRoaXMucGFyZW50LmNsb2NrID49IGdldFN0YXRlKHN0b3JlLCB0aGlzLnBhcmVudC5jbGllbnQpKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJlbnQuY2xpZW50XG4gICAgfVxuXG4gICAgLy8gV2UgaGF2ZSBhbGwgbWlzc2luZyBpZHMsIG5vdyBmaW5kIHRoZSBpdGVtc1xuXG4gICAgaWYgKHRoaXMub3JpZ2luKSB7XG4gICAgICB0aGlzLmxlZnQgPSBnZXRJdGVtQ2xlYW5FbmQodHJhbnNhY3Rpb24sIHN0b3JlLCB0aGlzLm9yaWdpbilcbiAgICAgIHRoaXMub3JpZ2luID0gdGhpcy5sZWZ0Lmxhc3RJZFxuICAgIH1cbiAgICBpZiAodGhpcy5yaWdodE9yaWdpbikge1xuICAgICAgdGhpcy5yaWdodCA9IGdldEl0ZW1DbGVhblN0YXJ0KHRyYW5zYWN0aW9uLCB0aGlzLnJpZ2h0T3JpZ2luKVxuICAgICAgdGhpcy5yaWdodE9yaWdpbiA9IHRoaXMucmlnaHQuaWRcbiAgICB9XG4gICAgaWYgKCh0aGlzLmxlZnQgJiYgdGhpcy5sZWZ0LmNvbnN0cnVjdG9yID09PSBHQykgfHwgKHRoaXMucmlnaHQgJiYgdGhpcy5yaWdodC5jb25zdHJ1Y3RvciA9PT0gR0MpKSB7XG4gICAgICB0aGlzLnBhcmVudCA9IG51bGxcbiAgICB9IGVsc2UgaWYgKCF0aGlzLnBhcmVudCkge1xuICAgICAgLy8gb25seSBzZXQgcGFyZW50IGlmIHRoaXMgc2hvdWxkbid0IGJlIGdhcmJhZ2UgY29sbGVjdGVkXG4gICAgICBpZiAodGhpcy5sZWZ0ICYmIHRoaXMubGVmdC5jb25zdHJ1Y3RvciA9PT0gSXRlbSkge1xuICAgICAgICB0aGlzLnBhcmVudCA9IHRoaXMubGVmdC5wYXJlbnRcbiAgICAgICAgdGhpcy5wYXJlbnRTdWIgPSB0aGlzLmxlZnQucGFyZW50U3ViXG4gICAgICB9XG4gICAgICBpZiAodGhpcy5yaWdodCAmJiB0aGlzLnJpZ2h0LmNvbnN0cnVjdG9yID09PSBJdGVtKSB7XG4gICAgICAgIHRoaXMucGFyZW50ID0gdGhpcy5yaWdodC5wYXJlbnRcbiAgICAgICAgdGhpcy5wYXJlbnRTdWIgPSB0aGlzLnJpZ2h0LnBhcmVudFN1YlxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5wYXJlbnQuY29uc3RydWN0b3IgPT09IElEKSB7XG4gICAgICBjb25zdCBwYXJlbnRJdGVtID0gZ2V0SXRlbShzdG9yZSwgdGhpcy5wYXJlbnQpXG4gICAgICBpZiAocGFyZW50SXRlbS5jb25zdHJ1Y3RvciA9PT0gR0MpIHtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBudWxsXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnBhcmVudCA9IC8qKiBAdHlwZSB7Q29udGVudFR5cGV9ICovIChwYXJlbnRJdGVtLmNvbnRlbnQpLnR5cGVcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gICAqL1xuICBpbnRlZ3JhdGUgKHRyYW5zYWN0aW9uLCBvZmZzZXQpIHtcbiAgICBpZiAob2Zmc2V0ID4gMCkge1xuICAgICAgdGhpcy5pZC5jbG9jayArPSBvZmZzZXRcbiAgICAgIHRoaXMubGVmdCA9IGdldEl0ZW1DbGVhbkVuZCh0cmFuc2FjdGlvbiwgdHJhbnNhY3Rpb24uZG9jLnN0b3JlLCBjcmVhdGVJRCh0aGlzLmlkLmNsaWVudCwgdGhpcy5pZC5jbG9jayAtIDEpKVxuICAgICAgdGhpcy5vcmlnaW4gPSB0aGlzLmxlZnQubGFzdElkXG4gICAgICB0aGlzLmNvbnRlbnQgPSB0aGlzLmNvbnRlbnQuc3BsaWNlKG9mZnNldClcbiAgICAgIHRoaXMubGVuZ3RoIC09IG9mZnNldFxuICAgIH1cblxuICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgaWYgKCghdGhpcy5sZWZ0ICYmICghdGhpcy5yaWdodCB8fCB0aGlzLnJpZ2h0LmxlZnQgIT09IG51bGwpKSB8fCAodGhpcy5sZWZ0ICYmIHRoaXMubGVmdC5yaWdodCAhPT0gdGhpcy5yaWdodCkpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtJdGVtfG51bGx9XG4gICAgICAgICAqL1xuICAgICAgICBsZXQgbGVmdCA9IHRoaXMubGVmdFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7SXRlbXxudWxsfVxuICAgICAgICAgKi9cbiAgICAgICAgbGV0IG9cbiAgICAgICAgLy8gc2V0IG8gdG8gdGhlIGZpcnN0IGNvbmZsaWN0aW5nIGl0ZW1cbiAgICAgICAgaWYgKGxlZnQgIT09IG51bGwpIHtcbiAgICAgICAgICBvID0gbGVmdC5yaWdodFxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMucGFyZW50U3ViICE9PSBudWxsKSB7XG4gICAgICAgICAgbyA9IC8qKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT59ICovICh0aGlzLnBhcmVudCkuX21hcC5nZXQodGhpcy5wYXJlbnRTdWIpIHx8IG51bGxcbiAgICAgICAgICB3aGlsZSAobyAhPT0gbnVsbCAmJiBvLmxlZnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG8gPSBvLmxlZnRcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbyA9IC8qKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT59ICovICh0aGlzLnBhcmVudCkuX3N0YXJ0XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETzogdXNlIHNvbWV0aGluZyBsaWtlIERlbGV0ZVNldCBoZXJlIChhIHRyZWUgaW1wbGVtZW50YXRpb24gd291bGQgYmUgYmVzdClcbiAgICAgICAgLy8gQHRvZG8gdXNlIGdsb2JhbCBzZXQgZGVmaW5pdGlvbnNcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtTZXQ8SXRlbT59XG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBjb25mbGljdGluZ0l0ZW1zID0gbmV3IFNldCgpXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7U2V0PEl0ZW0+fVxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgaXRlbXNCZWZvcmVPcmlnaW4gPSBuZXcgU2V0KClcbiAgICAgICAgLy8gTGV0IGMgaW4gY29uZmxpY3RpbmdJdGVtcywgYiBpbiBpdGVtc0JlZm9yZU9yaWdpblxuICAgICAgICAvLyAqKip7b3JpZ2lufWJiYmJ7dGhpc317YyxifXtjLGJ9e299KioqXG4gICAgICAgIC8vIE5vdGUgdGhhdCBjb25mbGljdGluZ0l0ZW1zIGlzIGEgc3Vic2V0IG9mIGl0ZW1zQmVmb3JlT3JpZ2luXG4gICAgICAgIHdoaWxlIChvICE9PSBudWxsICYmIG8gIT09IHRoaXMucmlnaHQpIHtcbiAgICAgICAgICBpdGVtc0JlZm9yZU9yaWdpbi5hZGQobylcbiAgICAgICAgICBjb25mbGljdGluZ0l0ZW1zLmFkZChvKVxuICAgICAgICAgIGlmIChjb21wYXJlSURzKHRoaXMub3JpZ2luLCBvLm9yaWdpbikpIHtcbiAgICAgICAgICAgIC8vIGNhc2UgMVxuICAgICAgICAgICAgaWYgKG8uaWQuY2xpZW50IDwgdGhpcy5pZC5jbGllbnQpIHtcbiAgICAgICAgICAgICAgbGVmdCA9IG9cbiAgICAgICAgICAgICAgY29uZmxpY3RpbmdJdGVtcy5jbGVhcigpXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNvbXBhcmVJRHModGhpcy5yaWdodE9yaWdpbiwgby5yaWdodE9yaWdpbikpIHtcbiAgICAgICAgICAgICAgLy8gdGhpcyBhbmQgbyBhcmUgY29uZmxpY3RpbmcgYW5kIHBvaW50IHRvIHRoZSBzYW1lIGludGVncmF0aW9uIHBvaW50cy4gVGhlIGlkIGRlY2lkZXMgd2hpY2ggaXRlbSBjb21lcyBmaXJzdC5cbiAgICAgICAgICAgICAgLy8gU2luY2UgdGhpcyBpcyB0byB0aGUgbGVmdCBvZiBvLCB3ZSBjYW4gYnJlYWsgaGVyZVxuICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfSAvLyBlbHNlLCBvIG1pZ2h0IGJlIGludGVncmF0ZWQgYmVmb3JlIGFuIGl0ZW0gdGhhdCB0aGlzIGNvbmZsaWN0cyB3aXRoLiBJZiBzbywgd2Ugd2lsbCBmaW5kIGl0IGluIHRoZSBuZXh0IGl0ZXJhdGlvbnNcbiAgICAgICAgICB9IGVsc2UgaWYgKG8ub3JpZ2luICE9PSBudWxsICYmIGl0ZW1zQmVmb3JlT3JpZ2luLmhhcyhnZXRJdGVtKHRyYW5zYWN0aW9uLmRvYy5zdG9yZSwgby5vcmlnaW4pKSkgeyAvLyB1c2UgZ2V0SXRlbSBpbnN0ZWFkIG9mIGdldEl0ZW1DbGVhbkVuZCBiZWNhdXNlIHdlIGRvbid0IHdhbnQgLyBuZWVkIHRvIHNwbGl0IGl0ZW1zLlxuICAgICAgICAgICAgLy8gY2FzZSAyXG4gICAgICAgICAgICBpZiAoIWNvbmZsaWN0aW5nSXRlbXMuaGFzKGdldEl0ZW0odHJhbnNhY3Rpb24uZG9jLnN0b3JlLCBvLm9yaWdpbikpKSB7XG4gICAgICAgICAgICAgIGxlZnQgPSBvXG4gICAgICAgICAgICAgIGNvbmZsaWN0aW5nSXRlbXMuY2xlYXIoKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgICBvID0gby5yaWdodFxuICAgICAgICB9XG4gICAgICAgIHRoaXMubGVmdCA9IGxlZnRcbiAgICAgIH1cbiAgICAgIC8vIHJlY29ubmVjdCBsZWZ0L3JpZ2h0ICsgdXBkYXRlIHBhcmVudCBtYXAvc3RhcnQgaWYgbmVjZXNzYXJ5XG4gICAgICBpZiAodGhpcy5sZWZ0ICE9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IHJpZ2h0ID0gdGhpcy5sZWZ0LnJpZ2h0XG4gICAgICAgIHRoaXMucmlnaHQgPSByaWdodFxuICAgICAgICB0aGlzLmxlZnQucmlnaHQgPSB0aGlzXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgclxuICAgICAgICBpZiAodGhpcy5wYXJlbnRTdWIgIT09IG51bGwpIHtcbiAgICAgICAgICByID0gLyoqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55Pn0gKi8gKHRoaXMucGFyZW50KS5fbWFwLmdldCh0aGlzLnBhcmVudFN1YikgfHwgbnVsbFxuICAgICAgICAgIHdoaWxlIChyICE9PSBudWxsICYmIHIubGVmdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgciA9IHIubGVmdFxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByID0gLyoqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55Pn0gKi8gKHRoaXMucGFyZW50KS5fc3RhcnRcbiAgICAgICAgICA7LyoqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55Pn0gKi8gKHRoaXMucGFyZW50KS5fc3RhcnQgPSB0aGlzXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yaWdodCA9IHJcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnJpZ2h0ICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMucmlnaHQubGVmdCA9IHRoaXNcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5wYXJlbnRTdWIgIT09IG51bGwpIHtcbiAgICAgICAgLy8gc2V0IGFzIGN1cnJlbnQgcGFyZW50IHZhbHVlIGlmIHJpZ2h0ID09PSBudWxsIGFuZCB0aGlzIGlzIHBhcmVudFN1YlxuICAgICAgICAvKiogQHR5cGUge0Fic3RyYWN0VHlwZTxhbnk+fSAqLyAodGhpcy5wYXJlbnQpLl9tYXAuc2V0KHRoaXMucGFyZW50U3ViLCB0aGlzKVxuICAgICAgICBpZiAodGhpcy5sZWZ0ICE9PSBudWxsKSB7XG4gICAgICAgICAgLy8gdGhpcyBpcyB0aGUgY3VycmVudCBhdHRyaWJ1dGUgdmFsdWUgb2YgcGFyZW50LiBkZWxldGUgcmlnaHRcbiAgICAgICAgICB0aGlzLmxlZnQuZGVsZXRlKHRyYW5zYWN0aW9uKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBhZGp1c3QgbGVuZ3RoIG9mIHBhcmVudFxuICAgICAgaWYgKHRoaXMucGFyZW50U3ViID09PSBudWxsICYmIHRoaXMuY291bnRhYmxlICYmICF0aGlzLmRlbGV0ZWQpIHtcbiAgICAgICAgLyoqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55Pn0gKi8gKHRoaXMucGFyZW50KS5fbGVuZ3RoICs9IHRoaXMubGVuZ3RoXG4gICAgICB9XG4gICAgICBhZGRTdHJ1Y3QodHJhbnNhY3Rpb24uZG9jLnN0b3JlLCB0aGlzKVxuICAgICAgdGhpcy5jb250ZW50LmludGVncmF0ZSh0cmFuc2FjdGlvbiwgdGhpcylcbiAgICAgIC8vIGFkZCBwYXJlbnQgdG8gdHJhbnNhY3Rpb24uY2hhbmdlZFxuICAgICAgYWRkQ2hhbmdlZFR5cGVUb1RyYW5zYWN0aW9uKHRyYW5zYWN0aW9uLCAvKiogQHR5cGUge0Fic3RyYWN0VHlwZTxhbnk+fSAqLyAodGhpcy5wYXJlbnQpLCB0aGlzLnBhcmVudFN1YilcbiAgICAgIGlmICgoLyoqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55Pn0gKi8gKHRoaXMucGFyZW50KS5faXRlbSAhPT0gbnVsbCAmJiAvKiogQHR5cGUge0Fic3RyYWN0VHlwZTxhbnk+fSAqLyAodGhpcy5wYXJlbnQpLl9pdGVtLmRlbGV0ZWQpIHx8ICh0aGlzLnBhcmVudFN1YiAhPT0gbnVsbCAmJiB0aGlzLnJpZ2h0ICE9PSBudWxsKSkge1xuICAgICAgICAvLyBkZWxldGUgaWYgcGFyZW50IGlzIGRlbGV0ZWQgb3IgaWYgdGhpcyBpcyBub3QgdGhlIGN1cnJlbnQgYXR0cmlidXRlIHZhbHVlIG9mIHBhcmVudFxuICAgICAgICB0aGlzLmRlbGV0ZSh0cmFuc2FjdGlvbilcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcGFyZW50IGlzIG5vdCBkZWZpbmVkLiBJbnRlZ3JhdGUgR0Mgc3RydWN0IGluc3RlYWRcbiAgICAgIG5ldyBHQyh0aGlzLmlkLCB0aGlzLmxlbmd0aCkuaW50ZWdyYXRlKHRyYW5zYWN0aW9uLCAwKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBuZXh0IG5vbi1kZWxldGVkIGl0ZW1cbiAgICovXG4gIGdldCBuZXh0ICgpIHtcbiAgICBsZXQgbiA9IHRoaXMucmlnaHRcbiAgICB3aGlsZSAobiAhPT0gbnVsbCAmJiBuLmRlbGV0ZWQpIHtcbiAgICAgIG4gPSBuLnJpZ2h0XG4gICAgfVxuICAgIHJldHVybiBuXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcHJldmlvdXMgbm9uLWRlbGV0ZWQgaXRlbVxuICAgKi9cbiAgZ2V0IHByZXYgKCkge1xuICAgIGxldCBuID0gdGhpcy5sZWZ0XG4gICAgd2hpbGUgKG4gIT09IG51bGwgJiYgbi5kZWxldGVkKSB7XG4gICAgICBuID0gbi5sZWZ0XG4gICAgfVxuICAgIHJldHVybiBuXG4gIH1cblxuICAvKipcbiAgICogQ29tcHV0ZXMgdGhlIGxhc3QgY29udGVudCBhZGRyZXNzIG9mIHRoaXMgSXRlbS5cbiAgICovXG4gIGdldCBsYXN0SWQgKCkge1xuICAgIC8vIGFsbG9jYXRpbmcgaWRzIGlzIHByZXR0eSBjb3N0bHkgYmVjYXVzZSBvZiB0aGUgYW1vdW50IG9mIGlkcyBjcmVhdGVkLCBzbyB3ZSB0cnkgdG8gcmV1c2Ugd2hlbmV2ZXIgcG9zc2libGVcbiAgICByZXR1cm4gdGhpcy5sZW5ndGggPT09IDEgPyB0aGlzLmlkIDogY3JlYXRlSUQodGhpcy5pZC5jbGllbnQsIHRoaXMuaWQuY2xvY2sgKyB0aGlzLmxlbmd0aCAtIDEpXG4gIH1cblxuICAvKipcbiAgICogVHJ5IHRvIG1lcmdlIHR3byBpdGVtc1xuICAgKlxuICAgKiBAcGFyYW0ge0l0ZW19IHJpZ2h0XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBtZXJnZVdpdGggKHJpZ2h0KSB7XG4gICAgaWYgKFxuICAgICAgdGhpcy5jb25zdHJ1Y3RvciA9PT0gcmlnaHQuY29uc3RydWN0b3IgJiZcbiAgICAgIGNvbXBhcmVJRHMocmlnaHQub3JpZ2luLCB0aGlzLmxhc3RJZCkgJiZcbiAgICAgIHRoaXMucmlnaHQgPT09IHJpZ2h0ICYmXG4gICAgICBjb21wYXJlSURzKHRoaXMucmlnaHRPcmlnaW4sIHJpZ2h0LnJpZ2h0T3JpZ2luKSAmJlxuICAgICAgdGhpcy5pZC5jbGllbnQgPT09IHJpZ2h0LmlkLmNsaWVudCAmJlxuICAgICAgdGhpcy5pZC5jbG9jayArIHRoaXMubGVuZ3RoID09PSByaWdodC5pZC5jbG9jayAmJlxuICAgICAgdGhpcy5kZWxldGVkID09PSByaWdodC5kZWxldGVkICYmXG4gICAgICB0aGlzLnJlZG9uZSA9PT0gbnVsbCAmJlxuICAgICAgcmlnaHQucmVkb25lID09PSBudWxsICYmXG4gICAgICB0aGlzLmNvbnRlbnQuY29uc3RydWN0b3IgPT09IHJpZ2h0LmNvbnRlbnQuY29uc3RydWN0b3IgJiZcbiAgICAgIHRoaXMuY29udGVudC5tZXJnZVdpdGgocmlnaHQuY29udGVudClcbiAgICApIHtcbiAgICAgIGNvbnN0IHNlYXJjaE1hcmtlciA9IC8qKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT59ICovICh0aGlzLnBhcmVudCkuX3NlYXJjaE1hcmtlclxuICAgICAgaWYgKHNlYXJjaE1hcmtlcikge1xuICAgICAgICBzZWFyY2hNYXJrZXIuZm9yRWFjaChtYXJrZXIgPT4ge1xuICAgICAgICAgIGlmIChtYXJrZXIucCA9PT0gcmlnaHQpIHtcbiAgICAgICAgICAgIC8vIHJpZ2h0IGlzIGdvaW5nIHRvIGJlIFwiZm9yZ290dGVuXCIgc28gd2UgbmVlZCB0byB1cGRhdGUgdGhlIG1hcmtlclxuICAgICAgICAgICAgbWFya2VyLnAgPSB0aGlzXG4gICAgICAgICAgICAvLyBhZGp1c3QgbWFya2VyIGluZGV4XG4gICAgICAgICAgICBpZiAoIXRoaXMuZGVsZXRlZCAmJiB0aGlzLmNvdW50YWJsZSkge1xuICAgICAgICAgICAgICBtYXJrZXIuaW5kZXggLT0gdGhpcy5sZW5ndGhcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgICBpZiAocmlnaHQua2VlcCkge1xuICAgICAgICB0aGlzLmtlZXAgPSB0cnVlXG4gICAgICB9XG4gICAgICB0aGlzLnJpZ2h0ID0gcmlnaHQucmlnaHRcbiAgICAgIGlmICh0aGlzLnJpZ2h0ICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMucmlnaHQubGVmdCA9IHRoaXNcbiAgICAgIH1cbiAgICAgIHRoaXMubGVuZ3RoICs9IHJpZ2h0Lmxlbmd0aFxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvKipcbiAgICogTWFyayB0aGlzIEl0ZW0gYXMgZGVsZXRlZC5cbiAgICpcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICovXG4gIGRlbGV0ZSAodHJhbnNhY3Rpb24pIHtcbiAgICBpZiAoIXRoaXMuZGVsZXRlZCkge1xuICAgICAgY29uc3QgcGFyZW50ID0gLyoqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55Pn0gKi8gKHRoaXMucGFyZW50KVxuICAgICAgLy8gYWRqdXN0IHRoZSBsZW5ndGggb2YgcGFyZW50XG4gICAgICBpZiAodGhpcy5jb3VudGFibGUgJiYgdGhpcy5wYXJlbnRTdWIgPT09IG51bGwpIHtcbiAgICAgICAgcGFyZW50Ll9sZW5ndGggLT0gdGhpcy5sZW5ndGhcbiAgICAgIH1cbiAgICAgIHRoaXMubWFya0RlbGV0ZWQoKVxuICAgICAgYWRkVG9EZWxldGVTZXQodHJhbnNhY3Rpb24uZGVsZXRlU2V0LCB0aGlzLmlkLmNsaWVudCwgdGhpcy5pZC5jbG9jaywgdGhpcy5sZW5ndGgpXG4gICAgICBhZGRDaGFuZ2VkVHlwZVRvVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24sIHBhcmVudCwgdGhpcy5wYXJlbnRTdWIpXG4gICAgICB0aGlzLmNvbnRlbnQuZGVsZXRlKHRyYW5zYWN0aW9uKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cnVjdFN0b3JlfSBzdG9yZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHBhcmVudEdDZFxuICAgKi9cbiAgZ2MgKHN0b3JlLCBwYXJlbnRHQ2QpIHtcbiAgICBpZiAoIXRoaXMuZGVsZXRlZCkge1xuICAgICAgdGhyb3cgZXJyb3IudW5leHBlY3RlZENhc2UoKVxuICAgIH1cbiAgICB0aGlzLmNvbnRlbnQuZ2Moc3RvcmUpXG4gICAgaWYgKHBhcmVudEdDZCkge1xuICAgICAgcmVwbGFjZVN0cnVjdChzdG9yZSwgdGhpcywgbmV3IEdDKHRoaXMuaWQsIHRoaXMubGVuZ3RoKSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jb250ZW50ID0gbmV3IENvbnRlbnREZWxldGVkKHRoaXMubGVuZ3RoKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUcmFuc2Zvcm0gdGhlIHByb3BlcnRpZXMgb2YgdGhpcyB0eXBlIHRvIGJpbmFyeSBhbmQgd3JpdGUgaXQgdG8gYW5cbiAgICogQmluYXJ5RW5jb2Rlci5cbiAgICpcbiAgICogVGhpcyBpcyBjYWxsZWQgd2hlbiB0aGlzIEl0ZW0gaXMgc2VudCB0byBhIHJlbW90ZSBwZWVyLlxuICAgKlxuICAgKiBAcGFyYW0ge1VwZGF0ZUVuY29kZXJWMSB8IFVwZGF0ZUVuY29kZXJWMn0gZW5jb2RlciBUaGUgZW5jb2RlciB0byB3cml0ZSBkYXRhIHRvLlxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gICAqL1xuICB3cml0ZSAoZW5jb2Rlciwgb2Zmc2V0KSB7XG4gICAgY29uc3Qgb3JpZ2luID0gb2Zmc2V0ID4gMCA/IGNyZWF0ZUlEKHRoaXMuaWQuY2xpZW50LCB0aGlzLmlkLmNsb2NrICsgb2Zmc2V0IC0gMSkgOiB0aGlzLm9yaWdpblxuICAgIGNvbnN0IHJpZ2h0T3JpZ2luID0gdGhpcy5yaWdodE9yaWdpblxuICAgIGNvbnN0IHBhcmVudFN1YiA9IHRoaXMucGFyZW50U3ViXG4gICAgY29uc3QgaW5mbyA9ICh0aGlzLmNvbnRlbnQuZ2V0UmVmKCkgJiBiaW5hcnkuQklUUzUpIHxcbiAgICAgIChvcmlnaW4gPT09IG51bGwgPyAwIDogYmluYXJ5LkJJVDgpIHwgLy8gb3JpZ2luIGlzIGRlZmluZWRcbiAgICAgIChyaWdodE9yaWdpbiA9PT0gbnVsbCA/IDAgOiBiaW5hcnkuQklUNykgfCAvLyByaWdodCBvcmlnaW4gaXMgZGVmaW5lZFxuICAgICAgKHBhcmVudFN1YiA9PT0gbnVsbCA/IDAgOiBiaW5hcnkuQklUNikgLy8gcGFyZW50U3ViIGlzIG5vbi1udWxsXG4gICAgZW5jb2Rlci53cml0ZUluZm8oaW5mbylcbiAgICBpZiAob3JpZ2luICE9PSBudWxsKSB7XG4gICAgICBlbmNvZGVyLndyaXRlTGVmdElEKG9yaWdpbilcbiAgICB9XG4gICAgaWYgKHJpZ2h0T3JpZ2luICE9PSBudWxsKSB7XG4gICAgICBlbmNvZGVyLndyaXRlUmlnaHRJRChyaWdodE9yaWdpbilcbiAgICB9XG4gICAgaWYgKG9yaWdpbiA9PT0gbnVsbCAmJiByaWdodE9yaWdpbiA9PT0gbnVsbCkge1xuICAgICAgY29uc3QgcGFyZW50ID0gLyoqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55Pn0gKi8gKHRoaXMucGFyZW50KVxuICAgICAgaWYgKHBhcmVudC5faXRlbSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IHBhcmVudEl0ZW0gPSBwYXJlbnQuX2l0ZW1cbiAgICAgICAgaWYgKHBhcmVudEl0ZW0gPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBwYXJlbnQgdHlwZSBvbiB5Ll9tYXBcbiAgICAgICAgICAvLyBmaW5kIHRoZSBjb3JyZWN0IGtleVxuICAgICAgICAgIGNvbnN0IHlrZXkgPSBmaW5kUm9vdFR5cGVLZXkocGFyZW50KVxuICAgICAgICAgIGVuY29kZXIud3JpdGVQYXJlbnRJbmZvKHRydWUpIC8vIHdyaXRlIHBhcmVudFlLZXlcbiAgICAgICAgICBlbmNvZGVyLndyaXRlU3RyaW5nKHlrZXkpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZW5jb2Rlci53cml0ZVBhcmVudEluZm8oZmFsc2UpIC8vIHdyaXRlIHBhcmVudCBpZFxuICAgICAgICAgIGVuY29kZXIud3JpdGVMZWZ0SUQocGFyZW50SXRlbS5pZClcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChwYXJlbnQuY29uc3RydWN0b3IgPT09IFN0cmluZykgeyAvLyB0aGlzIGVkZ2UgY2FzZSB3YXMgYWRkZWQgYnkgZGlmZmVyZW50aWFsIHVwZGF0ZXNcbiAgICAgICAgZW5jb2Rlci53cml0ZVBhcmVudEluZm8odHJ1ZSkgLy8gd3JpdGUgcGFyZW50WUtleVxuICAgICAgICBlbmNvZGVyLndyaXRlU3RyaW5nKHBhcmVudClcbiAgICAgIH0gZWxzZSBpZiAocGFyZW50LmNvbnN0cnVjdG9yID09PSBJRCkge1xuICAgICAgICBlbmNvZGVyLndyaXRlUGFyZW50SW5mbyhmYWxzZSkgLy8gd3JpdGUgcGFyZW50IGlkXG4gICAgICAgIGVuY29kZXIud3JpdGVMZWZ0SUQocGFyZW50KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXJyb3IudW5leHBlY3RlZENhc2UoKVxuICAgICAgfVxuICAgICAgaWYgKHBhcmVudFN1YiAhPT0gbnVsbCkge1xuICAgICAgICBlbmNvZGVyLndyaXRlU3RyaW5nKHBhcmVudFN1YilcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5jb250ZW50LndyaXRlKGVuY29kZXIsIG9mZnNldClcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7VXBkYXRlRGVjb2RlclYxIHwgVXBkYXRlRGVjb2RlclYyfSBkZWNvZGVyXG4gKiBAcGFyYW0ge251bWJlcn0gaW5mb1xuICovXG5leHBvcnQgY29uc3QgcmVhZEl0ZW1Db250ZW50ID0gKGRlY29kZXIsIGluZm8pID0+IGNvbnRlbnRSZWZzW2luZm8gJiBiaW5hcnkuQklUUzVdKGRlY29kZXIpXG5cbi8qKlxuICogQSBsb29rdXAgbWFwIGZvciByZWFkaW5nIEl0ZW0gY29udGVudC5cbiAqXG4gKiBAdHlwZSB7QXJyYXk8ZnVuY3Rpb24oVXBkYXRlRGVjb2RlclYxIHwgVXBkYXRlRGVjb2RlclYyKTpBYnN0cmFjdENvbnRlbnQ+fVxuICovXG5leHBvcnQgY29uc3QgY29udGVudFJlZnMgPSBbXG4gICgpID0+IHsgZXJyb3IudW5leHBlY3RlZENhc2UoKSB9LCAvLyBHQyBpcyBub3QgSXRlbUNvbnRlbnRcbiAgcmVhZENvbnRlbnREZWxldGVkLCAvLyAxXG4gIHJlYWRDb250ZW50SlNPTiwgLy8gMlxuICByZWFkQ29udGVudEJpbmFyeSwgLy8gM1xuICByZWFkQ29udGVudFN0cmluZywgLy8gNFxuICByZWFkQ29udGVudEVtYmVkLCAvLyA1XG4gIHJlYWRDb250ZW50Rm9ybWF0LCAvLyA2XG4gIHJlYWRDb250ZW50VHlwZSwgLy8gN1xuICByZWFkQ29udGVudEFueSwgLy8gOFxuICByZWFkQ29udGVudERvYywgLy8gOVxuICAoKSA9PiB7IGVycm9yLnVuZXhwZWN0ZWRDYXNlKCkgfSAvLyAxMCAtIFNraXAgaXMgbm90IEl0ZW1Db250ZW50XG5dXG5cbi8qKlxuICogRG8gbm90IGltcGxlbWVudCB0aGlzIGNsYXNzIVxuICovXG5leHBvcnQgY2xhc3MgQWJzdHJhY3RDb250ZW50IHtcbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldExlbmd0aCAoKSB7XG4gICAgdGhyb3cgZXJyb3IubWV0aG9kVW5pbXBsZW1lbnRlZCgpXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7QXJyYXk8YW55Pn1cbiAgICovXG4gIGdldENvbnRlbnQgKCkge1xuICAgIHRocm93IGVycm9yLm1ldGhvZFVuaW1wbGVtZW50ZWQoKVxuICB9XG5cbiAgLyoqXG4gICAqIFNob3VsZCByZXR1cm4gZmFsc2UgaWYgdGhpcyBJdGVtIGlzIHNvbWUga2luZCBvZiBtZXRhIGluZm9ybWF0aW9uXG4gICAqIChlLmcuIGZvcm1hdCBpbmZvcm1hdGlvbikuXG4gICAqXG4gICAqICogV2hldGhlciB0aGlzIEl0ZW0gc2hvdWxkIGJlIGFkZHJlc3NhYmxlIHZpYSBgeWFycmF5LmdldChpKWBcbiAgICogKiBXaGV0aGVyIHRoaXMgSXRlbSBzaG91bGQgYmUgY291bnRlZCB3aGVuIGNvbXB1dGluZyB5YXJyYXkubGVuZ3RoXG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBpc0NvdW50YWJsZSAoKSB7XG4gICAgdGhyb3cgZXJyb3IubWV0aG9kVW5pbXBsZW1lbnRlZCgpXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7QWJzdHJhY3RDb250ZW50fVxuICAgKi9cbiAgY29weSAoKSB7XG4gICAgdGhyb3cgZXJyb3IubWV0aG9kVW5pbXBsZW1lbnRlZCgpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IF9vZmZzZXRcbiAgICogQHJldHVybiB7QWJzdHJhY3RDb250ZW50fVxuICAgKi9cbiAgc3BsaWNlIChfb2Zmc2V0KSB7XG4gICAgdGhyb3cgZXJyb3IubWV0aG9kVW5pbXBsZW1lbnRlZCgpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtBYnN0cmFjdENvbnRlbnR9IF9yaWdodFxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgbWVyZ2VXaXRoIChfcmlnaHQpIHtcbiAgICB0aHJvdyBlcnJvci5tZXRob2RVbmltcGxlbWVudGVkKClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSBfdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtJdGVtfSBfaXRlbVxuICAgKi9cbiAgaW50ZWdyYXRlIChfdHJhbnNhY3Rpb24sIF9pdGVtKSB7XG4gICAgdGhyb3cgZXJyb3IubWV0aG9kVW5pbXBsZW1lbnRlZCgpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gX3RyYW5zYWN0aW9uXG4gICAqL1xuICBkZWxldGUgKF90cmFuc2FjdGlvbikge1xuICAgIHRocm93IGVycm9yLm1ldGhvZFVuaW1wbGVtZW50ZWQoKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RydWN0U3RvcmV9IF9zdG9yZVxuICAgKi9cbiAgZ2MgKF9zdG9yZSkge1xuICAgIHRocm93IGVycm9yLm1ldGhvZFVuaW1wbGVtZW50ZWQoKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VXBkYXRlRW5jb2RlclYxIHwgVXBkYXRlRW5jb2RlclYyfSBfZW5jb2RlclxuICAgKiBAcGFyYW0ge251bWJlcn0gX29mZnNldFxuICAgKi9cbiAgd3JpdGUgKF9lbmNvZGVyLCBfb2Zmc2V0KSB7XG4gICAgdGhyb3cgZXJyb3IubWV0aG9kVW5pbXBsZW1lbnRlZCgpXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0UmVmICgpIHtcbiAgICB0aHJvdyBlcnJvci5tZXRob2RVbmltcGxlbWVudGVkKClcbiAgfVxufVxuIiwgIlxuaW1wb3J0IHtcbiAgQWJzdHJhY3RTdHJ1Y3QsXG4gIFVwZGF0ZUVuY29kZXJWMSwgVXBkYXRlRW5jb2RlclYyLCBTdHJ1Y3RTdG9yZSwgVHJhbnNhY3Rpb24sIElEIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbn0gZnJvbSAnLi4vaW50ZXJuYWxzLmpzJ1xuaW1wb3J0ICogYXMgZXJyb3IgZnJvbSAnbGliMC9lcnJvcidcbmltcG9ydCAqIGFzIGVuY29kaW5nIGZyb20gJ2xpYjAvZW5jb2RpbmcnXG5cbmV4cG9ydCBjb25zdCBzdHJ1Y3RTa2lwUmVmTnVtYmVyID0gMTBcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY2xhc3MgU2tpcCBleHRlbmRzIEFic3RyYWN0U3RydWN0IHtcbiAgZ2V0IGRlbGV0ZWQgKCkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBkZWxldGUgKCkge31cblxuICAvKipcbiAgICogQHBhcmFtIHtTa2lwfSByaWdodFxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgbWVyZ2VXaXRoIChyaWdodCkge1xuICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yICE9PSByaWdodC5jb25zdHJ1Y3Rvcikge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIHRoaXMubGVuZ3RoICs9IHJpZ2h0Lmxlbmd0aFxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICAgKi9cbiAgaW50ZWdyYXRlICh0cmFuc2FjdGlvbiwgb2Zmc2V0KSB7XG4gICAgLy8gc2tpcCBzdHJ1Y3RzIGNhbm5vdCBiZSBpbnRlZ3JhdGVkXG4gICAgZXJyb3IudW5leHBlY3RlZENhc2UoKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VXBkYXRlRW5jb2RlclYxIHwgVXBkYXRlRW5jb2RlclYyfSBlbmNvZGVyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAgICovXG4gIHdyaXRlIChlbmNvZGVyLCBvZmZzZXQpIHtcbiAgICBlbmNvZGVyLndyaXRlSW5mbyhzdHJ1Y3RTa2lwUmVmTnVtYmVyKVxuICAgIC8vIHdyaXRlIGFzIFZhclVpbnQgYmVjYXVzZSBTa2lwcyBjYW4ndCBtYWtlIHVzZSBvZiBwcmVkaWN0YWJsZSBsZW5ndGgtZW5jb2RpbmdcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2Rlci5yZXN0RW5jb2RlciwgdGhpcy5sZW5ndGggLSBvZmZzZXQpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtTdHJ1Y3RTdG9yZX0gc3RvcmVcbiAgICogQHJldHVybiB7bnVsbCB8IG51bWJlcn1cbiAgICovXG4gIGdldE1pc3NpbmcgKHRyYW5zYWN0aW9uLCBzdG9yZSkge1xuICAgIHJldHVybiBudWxsXG4gIH1cbn1cbiIsICIvKiogZXNsaW50LWVudiBicm93c2VyICovXG5cbmV4cG9ydCB7XG4gIERvYyxcbiAgVHJhbnNhY3Rpb24sXG4gIFlBcnJheSBhcyBBcnJheSxcbiAgWU1hcCBhcyBNYXAsXG4gIFlUZXh0IGFzIFRleHQsXG4gIFlYbWxUZXh0IGFzIFhtbFRleHQsXG4gIFlYbWxIb29rIGFzIFhtbEhvb2ssXG4gIFlYbWxFbGVtZW50IGFzIFhtbEVsZW1lbnQsXG4gIFlYbWxGcmFnbWVudCBhcyBYbWxGcmFnbWVudCxcbiAgWVhtbEV2ZW50LFxuICBZTWFwRXZlbnQsXG4gIFlBcnJheUV2ZW50LFxuICBZVGV4dEV2ZW50LFxuICBZRXZlbnQsXG4gIEl0ZW0sXG4gIEFic3RyYWN0U3RydWN0LFxuICBHQyxcbiAgQ29udGVudEJpbmFyeSxcbiAgQ29udGVudERlbGV0ZWQsXG4gIENvbnRlbnRFbWJlZCxcbiAgQ29udGVudEZvcm1hdCxcbiAgQ29udGVudEpTT04sXG4gIENvbnRlbnRBbnksXG4gIENvbnRlbnRTdHJpbmcsXG4gIENvbnRlbnRUeXBlLFxuICBBYnN0cmFjdFR5cGUsXG4gIGdldFR5cGVDaGlsZHJlbixcbiAgY3JlYXRlUmVsYXRpdmVQb3NpdGlvbkZyb21UeXBlSW5kZXgsXG4gIGNyZWF0ZVJlbGF0aXZlUG9zaXRpb25Gcm9tSlNPTixcbiAgY3JlYXRlQWJzb2x1dGVQb3NpdGlvbkZyb21SZWxhdGl2ZVBvc2l0aW9uLFxuICBjb21wYXJlUmVsYXRpdmVQb3NpdGlvbnMsXG4gIEFic29sdXRlUG9zaXRpb24sXG4gIFJlbGF0aXZlUG9zaXRpb24sXG4gIElELFxuICBjcmVhdGVJRCxcbiAgY29tcGFyZUlEcyxcbiAgZ2V0U3RhdGUsXG4gIFNuYXBzaG90LFxuICBjcmVhdGVTbmFwc2hvdCxcbiAgY3JlYXRlRGVsZXRlU2V0LFxuICBjcmVhdGVEZWxldGVTZXRGcm9tU3RydWN0U3RvcmUsXG4gIGNsZWFudXBZVGV4dEZvcm1hdHRpbmcsXG4gIHNuYXBzaG90LFxuICBlbXB0eVNuYXBzaG90LFxuICBmaW5kUm9vdFR5cGVLZXksXG4gIGZpbmRJbmRleFNTLFxuICBnZXRJdGVtLFxuICB0eXBlTGlzdFRvQXJyYXlTbmFwc2hvdCxcbiAgdHlwZU1hcEdldFNuYXBzaG90LFxuICBjcmVhdGVEb2NGcm9tU25hcHNob3QsXG4gIGl0ZXJhdGVEZWxldGVkU3RydWN0cyxcbiAgYXBwbHlVcGRhdGUsXG4gIGFwcGx5VXBkYXRlVjIsXG4gIHJlYWRVcGRhdGUsXG4gIHJlYWRVcGRhdGVWMixcbiAgZW5jb2RlU3RhdGVBc1VwZGF0ZSxcbiAgZW5jb2RlU3RhdGVBc1VwZGF0ZVYyLFxuICBlbmNvZGVTdGF0ZVZlY3RvcixcbiAgVW5kb01hbmFnZXIsXG4gIGRlY29kZVNuYXBzaG90LFxuICBlbmNvZGVTbmFwc2hvdCxcbiAgZGVjb2RlU25hcHNob3RWMixcbiAgZW5jb2RlU25hcHNob3RWMixcbiAgZGVjb2RlU3RhdGVWZWN0b3IsXG4gIGxvZ1VwZGF0ZSxcbiAgbG9nVXBkYXRlVjIsXG4gIGRlY29kZVVwZGF0ZSxcbiAgZGVjb2RlVXBkYXRlVjIsXG4gIHJlbGF0aXZlUG9zaXRpb25Ub0pTT04sXG4gIGlzRGVsZXRlZCxcbiAgaXNQYXJlbnRPZixcbiAgZXF1YWxTbmFwc2hvdHMsXG4gIFBlcm1hbmVudFVzZXJEYXRhLCAvLyBAVE9ETyBleHBlcmltZW50YWxcbiAgdHJ5R2MsXG4gIHRyYW5zYWN0LFxuICBBYnN0cmFjdENvbm5lY3RvcixcbiAgbG9nVHlwZSxcbiAgbWVyZ2VVcGRhdGVzLFxuICBtZXJnZVVwZGF0ZXNWMixcbiAgcGFyc2VVcGRhdGVNZXRhLFxuICBwYXJzZVVwZGF0ZU1ldGFWMixcbiAgZW5jb2RlU3RhdGVWZWN0b3JGcm9tVXBkYXRlLFxuICBlbmNvZGVTdGF0ZVZlY3RvckZyb21VcGRhdGVWMixcbiAgZW5jb2RlUmVsYXRpdmVQb3NpdGlvbixcbiAgZGVjb2RlUmVsYXRpdmVQb3NpdGlvbixcbiAgZGlmZlVwZGF0ZSxcbiAgZGlmZlVwZGF0ZVYyLFxuICBjb252ZXJ0VXBkYXRlRm9ybWF0VjFUb1YyLFxuICBjb252ZXJ0VXBkYXRlRm9ybWF0VjJUb1YxLFxuICBvYmZ1c2NhdGVVcGRhdGUsXG4gIG9iZnVzY2F0ZVVwZGF0ZVYyLFxuICBVcGRhdGVFbmNvZGVyVjEsXG4gIGVxdWFsRGVsZXRlU2V0cyxcbiAgc25hcHNob3RDb250YWluc1VwZGF0ZVxufSBmcm9tICcuL2ludGVybmFscy5qcydcblxuY29uc3QgZ2xvID0gLyoqIEB0eXBlIHthbnl9ICovICh0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCdcbiAgPyBnbG9iYWxUaGlzXG4gIDogdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCdcbiAgICA/IHdpbmRvd1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICA6IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDoge30pXG5cbmNvbnN0IGltcG9ydElkZW50aWZpZXIgPSAnX18gJFlKUyQgX18nXG5cbmlmIChnbG9baW1wb3J0SWRlbnRpZmllcl0gPT09IHRydWUpIHtcbiAgLyoqXG4gICAqIERlYXIgcmVhZGVyIG9mIHRoaXMgbWVzc2FnZS4gUGxlYXNlIHRha2UgdGhpcyBzZXJpb3VzbHkuXG4gICAqXG4gICAqIElmIHlvdSBzZWUgdGhpcyBtZXNzYWdlLCBtYWtlIHN1cmUgdGhhdCB5b3Ugb25seSBpbXBvcnQgb25lIHZlcnNpb24gb2YgWWpzLiBJbiBtYW55IGNhc2VzLFxuICAgKiB5b3VyIHBhY2thZ2UgbWFuYWdlciBpbnN0YWxscyB0d28gdmVyc2lvbnMgb2YgWWpzIHRoYXQgYXJlIHVzZWQgYnkgZGlmZmVyZW50IHBhY2thZ2VzIHdpdGhpbiB5b3VyIHByb2plY3QuXG4gICAqIEFub3RoZXIgcmVhc29uIGZvciB0aGlzIG1lc3NhZ2UgaXMgdGhhdCBzb21lIHBhcnRzIG9mIHlvdXIgcHJvamVjdCB1c2UgdGhlIGNvbW1vbmpzIHZlcnNpb24gb2YgWWpzXG4gICAqIGFuZCBvdGhlcnMgdXNlIHRoZSBFY21hU2NyaXB0IHZlcnNpb24gb2YgWWpzLlxuICAgKlxuICAgKiBUaGlzIG9mdGVuIGxlYWRzIHRvIGlzc3VlcyB0aGF0IGFyZSBoYXJkIHRvIGRlYnVnLiBXZSBvZnRlbiBuZWVkIHRvIHBlcmZvcm0gY29uc3RydWN0b3IgY2hlY2tzLFxuICAgKiBlLmcuIGBzdHJ1Y3QgaW5zdGFuY2VvZiBHQ2AuIElmIHlvdSBpbXBvcnRlZCBkaWZmZXJlbnQgdmVyc2lvbnMgb2YgWWpzLCBpdCBpcyBpbXBvc3NpYmxlIGZvciB1cyB0b1xuICAgKiBkbyB0aGUgY29uc3RydWN0b3IgY2hlY2tzIGFueW1vcmUgLSB3aGljaCBtaWdodCBicmVhayB0aGUgQ1JEVCBhbGdvcml0aG0uXG4gICAqXG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS95anMveWpzL2lzc3Vlcy80MzhcbiAgICovXG4gIGNvbnNvbGUuZXJyb3IoJ1lqcyB3YXMgYWxyZWFkeSBpbXBvcnRlZC4gVGhpcyBicmVha3MgY29uc3RydWN0b3IgY2hlY2tzIGFuZCB3aWxsIGxlYWQgdG8gaXNzdWVzISAtIGh0dHBzOi8vZ2l0aHViLmNvbS95anMveWpzL2lzc3Vlcy80MzgnKVxufVxuZ2xvW2ltcG9ydElkZW50aWZpZXJdID0gdHJ1ZVxuIiwgImltcG9ydCAqIGFzIFhYSCBmcm9tICd4eGhhc2hqcydcblxuXG5leHBvcnQgY29uc3QgY3JlYXRlUmFuZG9tSWQgPSAoKTogc3RyaW5nID0+IHtcbiAgcmV0dXJuIHdpbmRvdy5jcnlwdG8ucmFuZG9tVVVJRCgpXG59XG5cbmV4cG9ydCBjb25zdCByYW5kb21VaW50MzIgPSAoKTogbnVtYmVyID0+IHtcbiAgcmV0dXJuIHdpbmRvdy5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50MzJBcnJheSgxKSlbMF07XG59XG5cbmV4cG9ydCBjb25zdCBnZW5lcmF0ZVJhbmRvbVN0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMjApLnN1YnN0cmluZygyLCA4KVxufVxuXG5leHBvcnQgY29uc3QgY2FsY3VsYXRlSGFzaCA9ICh0ZXh0OiBzdHJpbmcpID0+IHsgcmV0dXJuIFhYSC5oMzIodGV4dCwgMHhBQkNEKS50b1N0cmluZygxNikgfVxuXG5leHBvcnQgY29uc3Qgc2VyaWFsaXplID0gKG9iajogYW55KTogc3RyaW5nID0+IHtcbiAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgIHJldHVybiBgWyR7b2JqLm1hcChlbCA9PiBzZXJpYWxpemUoZWwpKS5qb2luKCcsJyl9XWBcbiAgfSBlbHNlIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiBvYmogIT09IG51bGwpIHtcbiAgICBsZXQgYWNjID0gJydcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob2JqKS5zb3J0KClcbiAgICBhY2MgKz0gYHske0pTT04uc3RyaW5naWZ5KGtleXMpfWBcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFjYyArPSBgJHtzZXJpYWxpemUob2JqW2tleXNbaV1dKX0sYFxuICAgIH1cbiAgICByZXR1cm4gYCR7YWNjfX1gXG4gIH1cbiAgcmV0dXJuIGAke0pTT04uc3RyaW5naWZ5KG9iail9YFxufSIsICJpbXBvcnQgeyBBcHAsIE1vZGFsLCBOb3RpY2UsIFNldHRpbmcsIFRGaWxlLCBXb3Jrc3BhY2UsIFdvcmtzcGFjZUxlYWYgfSBmcm9tIFwib2JzaWRpYW5cIjtcblxuY2xhc3MgU2hvd1RleHRNb2RhbCBleHRlbmRzIE1vZGFsIHtcblxuXHRtZXNzYWdlOiBzdHJpbmdcbiAgdGl0bGU6IHN0cmluZ1xuXG5cdGNvbnN0cnVjdG9yKGFwcDogQXBwLCB0aXRsZTogc3RyaW5nLCBtZXNzYWdlOiBzdHJpbmcpIHtcblx0XHRzdXBlcihhcHApO1xuXHRcdHRoaXMubWVzc2FnZSA9IG1lc3NhZ2VcbiAgICB0aGlzLnRpdGxlID0gdGl0bGVcblx0fVxuXG5cdG9uT3BlbigpIHtcblx0XHR0aGlzLnRpdGxlRWwuc2V0VGV4dCh0aGlzLnRpdGxlKVxuXHRcdHRoaXMuY29udGVudEVsLnNldFRleHQodGhpcy5tZXNzYWdlKVxuXHR9XG5cblx0b25DbG9zZSgpIHtcblx0XHR0aGlzLmNvbnRhaW5lckVsLmVtcHR5KClcblx0fVxufVxuXG5leHBvcnQgY29uc3Qgc2hvd1RleHRNb2RhbCA9IChhcHA6IEFwcCwgdGl0bGU6IHN0cmluZywgdGV4dDogc3RyaW5nKSA9PiB7XG4gIG5ldyBTaG93VGV4dE1vZGFsKGFwcCwgdGl0bGUsIHRleHQpLm9wZW4oKVxufVxuXG5leHBvcnQgY29uc3Qgc2hvd05vdGljZSA9ICh0ZXh0OiBzdHJpbmcsIGR1cmF0aW9uPzogbnVtYmVyIHwgdW5kZWZpbmVkKSA9PiB7XG5cdG5ldyBOb3RpY2UodGV4dCwgZHVyYXRpb24pXG59XG5cblxuY2xhc3MgRW50ZXJUZXh0TW9kYWwgZXh0ZW5kcyBNb2RhbCB7XG5cbiAgaW5wdXREZXNjcmlwdGlvbnM6IEFycmF5PHtuYW1lOiBzdHJpbmcsIGRlc2NyaXB0aW9uOiBzdHJpbmd9PlxuICBjYjogKHJlc3VsdDogQXJyYXk8e25hbWU6IHN0cmluZywgdmFsdWU6IHN0cmluZ30+KSA9PiBhbnlcbiAgcmVzdWx0OiBBcnJheTx7bmFtZTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nfT5cblxuICBjb25zdHJ1Y3RvcihhcHA6IEFwcCwgaW5wdXREZXNjcmlwdGlvbnM6IEFycmF5PHtuYW1lOiBzdHJpbmcsIGRlc2NyaXB0aW9uOiBzdHJpbmd9PiwgY2I6IChyZXN1bHQ6IEFycmF5PHtuYW1lOiBzdHJpbmcsIHZhbHVlOiBzdHJpbmd9PikgPT4gYW55KSB7XG4gICAgc3VwZXIoYXBwKVxuICAgIHRoaXMuaW5wdXREZXNjcmlwdGlvbnMgPSBpbnB1dERlc2NyaXB0aW9uc1xuICAgIHRoaXMuY2IgPSBjYlxuICAgIHRoaXMucmVzdWx0ID0gaW5wdXREZXNjcmlwdGlvbnMubWFwKGRlc2NyaXB0aW9uID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6IGRlc2NyaXB0aW9uLm5hbWUsXG4gICAgICAgIHZhbHVlOiBcIlwiXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIGFzeW5jIG9uT3BlbigpIHtcbiAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgdGhpcy5pbnB1dERlc2NyaXB0aW9ucy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gdGhpcy5pbnB1dERlc2NyaXB0aW9uc1tpbmRleF07XG4gICAgICBjb25zdCBzZXR0aW5nID0gbmV3IFNldHRpbmcodGhpcy5jb250ZW50RWwpXG4gICAgICBzZXR0aW5nLnNldE5hbWUoZGVzY3JpcHRpb24ubmFtZSlcbiAgICAgIHNldHRpbmcuc2V0RGVzYyhkZXNjcmlwdGlvbi5kZXNjcmlwdGlvbilcbiAgICAgIHNldHRpbmcuYWRkVGV4dCh0ZXh0ID0+IHtcbiAgICAgICAgdGV4dC5vbkNoYW5nZSh2YWx1ZSA9PiB7XG4gICAgICAgICAgdGhpcy5yZXN1bHRbaW5kZXhdLnZhbHVlID0gdmFsdWVcbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgY29uc3QgYnV0dG9ucyA9IG5ldyBTZXR0aW5nKHRoaXMuY29udGVudEVsKVxuICAgIGJ1dHRvbnMuYWRkQnV0dG9uKGJ1dHRvbiA9PiB7XG4gICAgICBidXR0b24uc2V0QnV0dG9uVGV4dChcIkNhbmNlbFwiKVxuICAgICAgYnV0dG9uLm9uQ2xpY2soKCkgPT4ge1xuICAgICAgICB0aGlzLmNsb3NlKClcbiAgICAgICAgdGhpcy5jYih0aGlzLnJlc3VsdClcbiAgICAgIH0pXG4gICAgfSlcblxuICAgIGJ1dHRvbnMuYWRkQnV0dG9uKGJ1dHRvbiA9PiB7XG4gICAgICBidXR0b24uc2V0QnV0dG9uVGV4dChcIkdvXCIpXG4gICAgICBidXR0b24uc2V0Q3RhKClcbiAgICAgIGJ1dHRvbi5vbkNsaWNrKCgpID0+IHtcbiAgICAgICAgdGhpcy5jbG9zZSgpXG4gICAgICAgIHRoaXMuY2IodGhpcy5yZXN1bHQpXG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICBvbkNsb3NlKCk6IHZvaWQge1xuICAgIHRoaXMuY2IodGhpcy5yZXN1bHQpXG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHByb21wdEZvck11bHRpcGxlVGV4dElucHV0cyA9IGFzeW5jIChhcHA6IEFwcCwgaW5wdXREZXNjcmlwdGlvbnM6IEFycmF5PHsgbmFtZTogc3RyaW5nLCBkZXNjcmlwdGlvbjogc3RyaW5nIH0+KSA9PiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZTxBcnJheTx7IG5hbWU6IHN0cmluZywgdmFsdWU6IHN0cmluZyB9PiB8IHZvaWQ+KChyZXNvbHZlKSA9PiB7XG4gICAgbmV3IEVudGVyVGV4dE1vZGFsKGFwcCwgaW5wdXREZXNjcmlwdGlvbnMsIChyZXN1bHQpID0+IHtcbiAgICAgIHJlc29sdmUocmVzdWx0KVxuICAgIH0pLm9wZW4oKVxuICB9KVxufVxuXG5leHBvcnQgY29uc3Qgb3BlbkZpbGVJbk5ld1RhYiA9IGFzeW5jIChmaWxlOiBURmlsZSwgd29ya3NwYWNlOiBXb3Jrc3BhY2UpID0+IHtcbiAgY29uc3QgbGVhZiA9IHdvcmtzcGFjZS5nZXRMZWFmKCd0YWInKVxuICBhd2FpdCBsZWFmLm9wZW5GaWxlKGZpbGUpXG4gIHJldHVybiBsZWFmXG59XG5cblxuXG5leHBvcnQgY29uc3QgcGluTGVhZiA9IChsZWFmOiBXb3Jrc3BhY2VMZWFmKSA9PiB7XG4gIGxlYWYuc2V0UGlubmVkKHRydWUpXG4gIHNob3dOb3RpY2UoYGF1dG8tcGlubmVkIFwiJHtsZWFmLmdldERpc3BsYXlUZXh0KCl9XCJgKVxufVxuXG5leHBvcnQgY29uc3QgdXNlcmNvbG9ycyA9IFtcbiAgeyBkYXJrOiAnIzMwYmNlZCcsIGxpZ2h0OiAnIzMwYmNlZDMzJyB9LFxuICB7IGRhcms6ICcjNmVlYjgzJywgbGlnaHQ6ICcjNmVlYjgzMzMnIH0sXG4gIHsgZGFyazogJyNmZmJjNDInLCBsaWdodDogJyNmZmJjNDIzMycgfSxcbiAgeyBkYXJrOiAnI2VjZDQ0NCcsIGxpZ2h0OiAnI2VjZDQ0NDMzJyB9LFxuICB7IGRhcms6ICcjZWU2MzUyJywgbGlnaHQ6ICcjZWU2MzUyMzMnIH0sXG4gIHsgZGFyazogJyM5YWMyYzknLCBsaWdodDogJyM5YWMyYzkzMycgfSxcbiAgeyBkYXJrOiAnIzhhY2I4OCcsIGxpZ2h0OiAnIzhhY2I4ODMzJyB9LFxuICB7IGRhcms6ICcjMWJlN2ZmJywgbGlnaHQ6ICcjMWJlN2ZmMzMnIH1cbl0iLCAiXG5pbXBvcnQgKiBhcyBZIGZyb20gJ3lqcycgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuaW1wb3J0ICogYXMgY21WaWV3IGZyb20gJ0Bjb2RlbWlycm9yL3ZpZXcnXG5pbXBvcnQgKiBhcyBjbVN0YXRlIGZyb20gJ0Bjb2RlbWlycm9yL3N0YXRlJyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbmltcG9ydCB7IHlTeW5jLCB5U3luY0ZhY2V0LCBZU3luY0NvbmZpZyB9IGZyb20gJy4veS1zeW5jLmpzJ1xuaW1wb3J0IHsgeVJlbW90ZVNlbGVjdGlvbnMsIHlSZW1vdGVTZWxlY3Rpb25zVGhlbWUgfSBmcm9tICcuL3ktcmVtb3RlLXNlbGVjdGlvbnMuanMnXG5pbXBvcnQgeyB5VW5kb01hbmFnZXIsIHlVbmRvTWFuYWdlckZhY2V0LCBZVW5kb01hbmFnZXJDb25maWcsIHVuZG8sIHJlZG8sIHlVbmRvTWFuYWdlcktleW1hcCB9IGZyb20gJy4veS11bmRvbWFuYWdlci5qcydcblxuZXhwb3J0IHsgeVJlbW90ZVNlbGVjdGlvbnMsIHlSZW1vdGVTZWxlY3Rpb25zVGhlbWUsIHlTeW5jLCB5U3luY0ZhY2V0LCBZU3luY0NvbmZpZywgeVVuZG9NYW5hZ2VyS2V5bWFwIH1cblxuLyoqXG4gKiBAcGFyYW0ge1kuVGV4dH0geXRleHRcbiAqIEBwYXJhbSB7YW55fSBhd2FyZW5lc3NcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0c11cbiAqIEBwYXJhbSB7WS5VbmRvTWFuYWdlciB8IGZhbHNlfSBbb3B0cy51bmRvTWFuYWdlcl0gU2V0IHVuZG9NYW5hZ2VyIHRvIGZhbHNlIHRvIGRpc2FibGUgdGhlIHVuZG8tcmVkbyBwbHVnaW5cbiAqIEByZXR1cm4ge2NtU3RhdGUuRXh0ZW5zaW9ufVxuICovXG5leHBvcnQgY29uc3QgeUNvbGxhYiA9ICh5dGV4dCwgYXdhcmVuZXNzLCB7IHVuZG9NYW5hZ2VyID0gbmV3IFkuVW5kb01hbmFnZXIoeXRleHQpIH0gPSB7fSkgPT4ge1xuICBjb25zdCB5U3luY0NvbmZpZyA9IG5ldyBZU3luY0NvbmZpZyh5dGV4dCwgYXdhcmVuZXNzKVxuICBjb25zdCBwbHVnaW5zID0gW1xuICAgIHlTeW5jRmFjZXQub2YoeVN5bmNDb25maWcpLFxuICAgIHlTeW5jXG4gIF1cbiAgaWYgKGF3YXJlbmVzcykge1xuICAgIHBsdWdpbnMucHVzaChcbiAgICAgIHlSZW1vdGVTZWxlY3Rpb25zVGhlbWUsXG4gICAgICB5UmVtb3RlU2VsZWN0aW9uc1xuICAgIClcbiAgfVxuICBpZiAodW5kb01hbmFnZXIgIT09IGZhbHNlKSB7XG4gICAgLy8gQnkgZGVmYXVsdCwgb25seSB0cmFjayBjaGFuZ2VzIHRoYXQgYXJlIHByb2R1Y2VkIGJ5IHRoZSBzeW5jIHBsdWdpbiAobG9jYWwgZWRpdHMpXG4gICAgcGx1Z2lucy5wdXNoKFxuICAgICAgeVVuZG9NYW5hZ2VyRmFjZXQub2YobmV3IFlVbmRvTWFuYWdlckNvbmZpZyh1bmRvTWFuYWdlcikpLFxuICAgICAgeVVuZG9NYW5hZ2VyLFxuICAgICAgY21WaWV3LkVkaXRvclZpZXcuZG9tRXZlbnRIYW5kbGVycyh7XG4gICAgICAgIGJlZm9yZWlucHV0IChlLCB2aWV3KSB7XG4gICAgICAgICAgaWYgKGUuaW5wdXRUeXBlID09PSAnaGlzdG9yeVVuZG8nKSByZXR1cm4gdW5kbyh2aWV3KVxuICAgICAgICAgIGlmIChlLmlucHV0VHlwZSA9PT0gJ2hpc3RvcnlSZWRvJykgcmV0dXJuIHJlZG8odmlldylcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICApXG4gIH1cbiAgcmV0dXJuIHBsdWdpbnNcbn1cbiIsICJcbmltcG9ydCAqIGFzIFkgZnJvbSAneWpzJ1xuaW1wb3J0ICogYXMgY21TdGF0ZSBmcm9tICdAY29kZW1pcnJvci9zdGF0ZScgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuaW1wb3J0ICogYXMgY21WaWV3IGZyb20gJ0Bjb2RlbWlycm9yL3ZpZXcnIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbmltcG9ydCB7IFlSYW5nZSB9IGZyb20gJy4veS1yYW5nZS5qcydcblxuZXhwb3J0IGNsYXNzIFlTeW5jQ29uZmlnIHtcbiAgY29uc3RydWN0b3IgKHl0ZXh0LCBhd2FyZW5lc3MpIHtcbiAgICB0aGlzLnl0ZXh0ID0geXRleHRcbiAgICB0aGlzLmF3YXJlbmVzcyA9IGF3YXJlbmVzc1xuICAgIHRoaXMudW5kb01hbmFnZXIgPSBuZXcgWS5VbmRvTWFuYWdlcih5dGV4dClcbiAgfVxuXG4gIC8qKlxuICAgKiBIZWxwZXIgZnVuY3Rpb24gdG8gdHJhbnNmb3JtIGFuIGFic29sdXRlIGluZGV4IHBvc2l0aW9uIHRvIGEgWWpzLWJhc2VkIHJlbGF0aXZlIHBvc2l0aW9uXG4gICAqIChodHRwczovL2RvY3MueWpzLmRldi9hcGkvcmVsYXRpdmUtcG9zaXRpb25zKS5cbiAgICpcbiAgICogQSByZWxhdGl2ZSBwb3NpdGlvbiBjYW4gYmUgdHJhbnNmb3JtZWQgYmFjayB0byBhbiBhYnNvbHV0ZSBwb3NpdGlvbiBldmVuIGFmdGVyIHRoZSBkb2N1bWVudCBoYXMgY2hhbmdlZC4gVGhlIHBvc2l0aW9uIGlzXG4gICAqIGF1dG9tYXRpY2FsbHkgYWRhcHRlZC4gVGhpcyBkb2VzIG5vdCByZXF1aXJlIGFueSBwb3NpdGlvbiB0cmFuc2Zvcm1hdGlvbnMuIFJlbGF0aXZlIHBvc2l0aW9ucyBhcmUgY29tcHV0ZWQgYmFzZWQgb25cbiAgICogdGhlIGludGVybmFsIFlqcyBkb2N1bWVudCBtb2RlbC4gUGVlcnMgdGhhdCBzaGFyZSBjb250ZW50IHRocm91Z2ggWWpzIGFyZSBndWFyYW50ZWVkIHRoYXQgdGhlaXIgcG9zaXRpb25zIHdpbGwgYWx3YXlzXG4gICAqIHN5bmNlZCB1cCB3aGVuIHVzaW5nIHJlbGF0dmUgcG9zaXRpb25zLlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiBpbXBvcnQgeyB5U3luY0ZhY2V0IH0gZnJvbSAneS1jb2RlbWlycm9yJ1xuICAgKlxuICAgKiAuLlxuICAgKiBjb25zdCB5c3luYyA9IHZpZXcuc3RhdGUuZmFjZXQoeVN5bmNGYWNldClcbiAgICogLy8gdHJhbnNmb3JtIGFuIGFic29sdXRlIGluZGV4IHBvc2l0aW9uIHRvIGEgeXBvc1xuICAgKiBjb25zdCB5cG9zID0geXN5bmMuZ2V0WVBvcygzKVxuICAgKiAvLyB0cmFuc2Zvcm0gdGhlIHlwb3MgYmFjayB0byBhbiBhYnNvbHV0ZSBwb3NpdGlvblxuICAgKiB5c3luYy5mcm9tWVBvcyh5cG9zKSAvLyA9PiAzXG4gICAqIGBgYFxuICAgKlxuICAgKiBJdCBjYW5ub3QgYmUgZ3VhcmFudGVlZCB0aGF0IGFic29sdXRlIGluZGV4IHBvc2l0aW9ucyBjYW4gYmUgc3luY2VkIHVwIGJldHdlZW4gcGVlcnMuXG4gICAqIFRoaXMgbWlnaHQgbGVhZCB0byB1bmRlc2lyZWQgYmVoYXZpb3Igd2hlbiBpbXBsZW1lbnRpbmcgZmVhdHVyZXMgdGhhdCByZXF1aXJlIHRoYXQgYWxsIHBlZXJzIHNlZSB0aGVcbiAgICogc2FtZSBtYXJrZWQgcmFuZ2UgKGUuZy4gYSBjb21tZW50IHBsdWdpbikuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwb3NcbiAgICogQHBhcmFtIHtudW1iZXJ9IFthc3NvY11cbiAgICovXG4gIHRvWVBvcyAocG9zLCBhc3NvYyA9IDApIHtcbiAgICByZXR1cm4gWS5jcmVhdGVSZWxhdGl2ZVBvc2l0aW9uRnJvbVR5cGVJbmRleCh0aGlzLnl0ZXh0LCBwb3MsIGFzc29jKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7WS5SZWxhdGl2ZVBvc2l0aW9uIHwgT2JqZWN0fSBycG9zXG4gICAqL1xuICBmcm9tWVBvcyAocnBvcykge1xuICAgIGNvbnN0IHBvcyA9IFkuY3JlYXRlQWJzb2x1dGVQb3NpdGlvbkZyb21SZWxhdGl2ZVBvc2l0aW9uKFkuY3JlYXRlUmVsYXRpdmVQb3NpdGlvbkZyb21KU09OKHJwb3MpLCB0aGlzLnl0ZXh0LmRvYylcbiAgICBpZiAocG9zID09IG51bGwgfHwgcG9zLnR5cGUgIT09IHRoaXMueXRleHQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignW3ktY29kZW1pcnJvcl0gVGhlIHBvc2l0aW9uIHlvdSB3YW50IHRvIHJldHJpZXZlIHdhcyBjcmVhdGVkIGJ5IGEgZGlmZmVyZW50IGRvY3VtZW50JylcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHBvczogcG9zLmluZGV4LFxuICAgICAgYXNzb2M6IHBvcy5hc3NvY1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2NtU3RhdGUuU2VsZWN0aW9uUmFuZ2V9IHJhbmdlXG4gICAqIEByZXR1cm4ge1lSYW5nZX1cbiAgICovXG4gIHRvWVJhbmdlIChyYW5nZSkge1xuICAgIGNvbnN0IGFzc29jID0gcmFuZ2UuYXNzb2NcbiAgICBjb25zdCB5YW5jaG9yID0gdGhpcy50b1lQb3MocmFuZ2UuYW5jaG9yLCBhc3NvYylcbiAgICBjb25zdCB5aGVhZCA9IHRoaXMudG9ZUG9zKHJhbmdlLmhlYWQsIGFzc29jKVxuICAgIHJldHVybiBuZXcgWVJhbmdlKHlhbmNob3IsIHloZWFkKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7WVJhbmdlfSB5cmFuZ2VcbiAgICovXG4gIGZyb21ZUmFuZ2UgKHlyYW5nZSkge1xuICAgIGNvbnN0IGFuY2hvciA9IHRoaXMuZnJvbVlQb3MoeXJhbmdlLnlhbmNob3IpXG4gICAgY29uc3QgaGVhZCA9IHRoaXMuZnJvbVlQb3MoeXJhbmdlLnloZWFkKVxuICAgIGlmIChhbmNob3IucG9zID09PSBoZWFkLnBvcykge1xuICAgICAgcmV0dXJuIGNtU3RhdGUuRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihoZWFkLnBvcywgaGVhZC5hc3NvYylcbiAgICB9XG4gICAgcmV0dXJuIGNtU3RhdGUuRWRpdG9yU2VsZWN0aW9uLnJhbmdlKGFuY2hvci5wb3MsIGhlYWQucG9zKVxuICB9XG59XG5cbi8qKlxuICogQHR5cGUge2NtU3RhdGUuRmFjZXQ8WVN5bmNDb25maWcsIFlTeW5jQ29uZmlnPn1cbiAqL1xuZXhwb3J0IGNvbnN0IHlTeW5jRmFjZXQgPSBjbVN0YXRlLkZhY2V0LmRlZmluZSh7XG4gIGNvbWJpbmUgKGlucHV0cykge1xuICAgIHJldHVybiBpbnB1dHNbaW5wdXRzLmxlbmd0aCAtIDFdXG4gIH1cbn0pXG5cbi8qKlxuICogQHR5cGUge2NtU3RhdGUuQW5ub3RhdGlvblR5cGU8WVN5bmNDb25maWc+fVxuICovXG5leHBvcnQgY29uc3QgeVN5bmNBbm5vdGF0aW9uID0gY21TdGF0ZS5Bbm5vdGF0aW9uLmRlZmluZSgpXG5cbi8qKlxuICogQGV4dGVuZHMge1BsdWdpblZhbHVlfVxuICovXG5jbGFzcyBZU3luY1BsdWdpblZhbHVlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7Y21WaWV3LkVkaXRvclZpZXd9IHZpZXdcbiAgICovXG4gIGNvbnN0cnVjdG9yICh2aWV3KSB7XG4gICAgdGhpcy52aWV3ID0gdmlld1xuICAgIHRoaXMuY29uZiA9IHZpZXcuc3RhdGUuZmFjZXQoeVN5bmNGYWNldClcbiAgICB0aGlzLl9vYnNlcnZlciA9IChldmVudCwgdHIpID0+IHtcbiAgICAgIGlmICh0ci5vcmlnaW4gIT09IHRoaXMuY29uZikge1xuICAgICAgICBjb25zdCBkZWx0YSA9IGV2ZW50LmRlbHRhXG4gICAgICAgIGNvbnN0IGNoYW5nZXMgPSBbXVxuICAgICAgICBsZXQgcG9zID0gMFxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlbHRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgZCA9IGRlbHRhW2ldXG4gICAgICAgICAgaWYgKGQuaW5zZXJ0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNoYW5nZXMucHVzaCh7IGZyb206IHBvcywgdG86IHBvcywgaW5zZXJ0OiBkLmluc2VydCB9KVxuICAgICAgICAgIH0gZWxzZSBpZiAoZC5kZWxldGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgY2hhbmdlcy5wdXNoKHsgZnJvbTogcG9zLCB0bzogcG9zICsgZC5kZWxldGUsIGluc2VydDogJycgfSlcbiAgICAgICAgICAgIHBvcyArPSBkLmRlbGV0ZVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwb3MgKz0gZC5yZXRhaW5cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmlldy5kaXNwYXRjaCh7IGNoYW5nZXMsIGFubm90YXRpb25zOiBbeVN5bmNBbm5vdGF0aW9uLm9mKHRoaXMuY29uZildIH0pXG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX3l0ZXh0ID0gdGhpcy5jb25mLnl0ZXh0XG4gICAgdGhpcy5feXRleHQub2JzZXJ2ZSh0aGlzLl9vYnNlcnZlcilcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2NtVmlldy5WaWV3VXBkYXRlfSB1cGRhdGVcbiAgICovXG4gIHVwZGF0ZSAodXBkYXRlKSB7XG4gICAgaWYgKCF1cGRhdGUuZG9jQ2hhbmdlZCB8fCAodXBkYXRlLnRyYW5zYWN0aW9ucy5sZW5ndGggPiAwICYmIHVwZGF0ZS50cmFuc2FjdGlvbnNbMF0uYW5ub3RhdGlvbih5U3luY0Fubm90YXRpb24pID09PSB0aGlzLmNvbmYpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgY29uc3QgeXRleHQgPSB0aGlzLmNvbmYueXRleHRcbiAgICB5dGV4dC5kb2MudHJhbnNhY3QoKCkgPT4ge1xuICAgICAgLyoqXG4gICAgICAgKiBUaGlzIHZhcmlhYmxlIGFkanVzdHMgdGhlIGZyb21BIHBvc2l0aW9uIHRvIHRoZSBjdXJyZW50IHBvc2l0aW9uIGluIHRoZSBZLlRleHQgdHlwZS5cbiAgICAgICAqL1xuICAgICAgbGV0IGFkaiA9IDBcbiAgICAgIHVwZGF0ZS5jaGFuZ2VzLml0ZXJDaGFuZ2VzKChmcm9tQSwgdG9BLCBmcm9tQiwgdG9CLCBpbnNlcnQpID0+IHtcbiAgICAgICAgY29uc3QgaW5zZXJ0VGV4dCA9IGluc2VydC5zbGljZVN0cmluZygwLCBpbnNlcnQubGVuZ3RoLCAnXFxuJylcbiAgICAgICAgaWYgKGZyb21BICE9PSB0b0EpIHtcbiAgICAgICAgICB5dGV4dC5kZWxldGUoZnJvbUEgKyBhZGosIHRvQSAtIGZyb21BKVxuICAgICAgICB9XG4gICAgICAgIGlmIChpbnNlcnRUZXh0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB5dGV4dC5pbnNlcnQoZnJvbUEgKyBhZGosIGluc2VydFRleHQpXG4gICAgICAgIH1cbiAgICAgICAgYWRqICs9IGluc2VydFRleHQubGVuZ3RoIC0gKHRvQSAtIGZyb21BKVxuICAgICAgfSlcbiAgICB9LCB0aGlzLmNvbmYpXG4gIH1cblxuICBkZXN0cm95ICgpIHtcbiAgICB0aGlzLl95dGV4dC51bm9ic2VydmUodGhpcy5fb2JzZXJ2ZXIpXG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHlTeW5jID0gY21WaWV3LlZpZXdQbHVnaW4uZnJvbUNsYXNzKFlTeW5jUGx1Z2luVmFsdWUpXG4iLCAiaW1wb3J0ICogYXMgWSBmcm9tICd5anMnXG5cbi8qKlxuICogRGVmaW5lcyBhIHJhbmdlIG9uIHRleHQgdXNpbmcgcmVsYXRpdmUgcG9zaXRpb25zIHRoYXQgY2FuIGJlIHRyYW5zZm9ybWVkIGJhY2sgdG9cbiAqIGFic29sdXRlIHBvc2l0aW9ucy4gKGh0dHBzOi8vZG9jcy55anMuZGV2L2FwaS9yZWxhdGl2ZS1wb3NpdGlvbnMpXG4gKi9cbmV4cG9ydCBjbGFzcyBZUmFuZ2Uge1xuICAvKipcbiAgICogQHBhcmFtIHtZLlJlbGF0aXZlUG9zaXRpb259IHlhbmNob3JcbiAgICogQHBhcmFtIHtZLlJlbGF0aXZlUG9zaXRpb259IHloZWFkXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoeWFuY2hvciwgeWhlYWQpIHtcbiAgICB0aGlzLnlhbmNob3IgPSB5YW5jaG9yXG4gICAgdGhpcy55aGVhZCA9IHloZWFkXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMge2FueX1cbiAgICovXG4gIHRvSlNPTiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHlhbmNob3I6IFkucmVsYXRpdmVQb3NpdGlvblRvSlNPTih0aGlzLnlhbmNob3IpLFxuICAgICAgeWhlYWQ6IFkucmVsYXRpdmVQb3NpdGlvblRvSlNPTih0aGlzLnloZWFkKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2FueX0ganNvblxuICAgKiBAcmV0dXJuIHtZUmFuZ2V9XG4gICAqL1xuICBzdGF0aWMgZnJvbUpTT04gKGpzb24pIHtcbiAgICByZXR1cm4gbmV3IFlSYW5nZShZLmNyZWF0ZVJlbGF0aXZlUG9zaXRpb25Gcm9tSlNPTihqc29uLnlhbmNob3IpLCBZLmNyZWF0ZVJlbGF0aXZlUG9zaXRpb25Gcm9tSlNPTihqc29uLnloZWFkKSlcbiAgfVxufVxuIiwgIlxuaW1wb3J0ICogYXMgY21WaWV3IGZyb20gJ0Bjb2RlbWlycm9yL3ZpZXcnXG5cbmltcG9ydCAqIGFzIGNtU3RhdGUgZnJvbSAnQGNvZGVtaXJyb3Ivc3RhdGUnXG5pbXBvcnQgKiBhcyBkb20gZnJvbSAnbGliMC9kb20nXG5pbXBvcnQgKiBhcyBwYWlyIGZyb20gJ2xpYjAvcGFpcidcbmltcG9ydCAqIGFzIG1hdGggZnJvbSAnbGliMC9tYXRoJ1xuXG5pbXBvcnQgKiBhcyBZIGZyb20gJ3lqcydcbmltcG9ydCB7IHlTeW5jRmFjZXQgfSBmcm9tICcuL3ktc3luYy5qcydcblxuZXhwb3J0IGNvbnN0IHlSZW1vdGVTZWxlY3Rpb25zVGhlbWUgPSBjbVZpZXcuRWRpdG9yVmlldy5iYXNlVGhlbWUoe1xuICAnLmNtLXlTZWxlY3Rpb24nOiB7XG4gIH0sXG4gICcuY20teUxpbmVTZWxlY3Rpb24nOiB7XG4gICAgcGFkZGluZzogMCxcbiAgICBtYXJnaW46ICcwcHggMnB4IDBweCA0cHgnXG4gIH0sXG4gICcuY20teVNlbGVjdGlvbkNhcmV0Jzoge1xuICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgIGJvcmRlckxlZnQ6ICcxcHggc29saWQgYmxhY2snLFxuICAgIGJvcmRlclJpZ2h0OiAnMXB4IHNvbGlkIGJsYWNrJyxcbiAgICBtYXJnaW5MZWZ0OiAnLTFweCcsXG4gICAgbWFyZ2luUmlnaHQ6ICctMXB4JyxcbiAgICBib3hTaXppbmc6ICdib3JkZXItYm94JyxcbiAgICBkaXNwbGF5OiAnaW5saW5lJ1xuICB9LFxuICAnLmNtLXlTZWxlY3Rpb25DYXJldERvdCc6IHtcbiAgICBib3JkZXJSYWRpdXM6ICc1MCUnLFxuICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgIHdpZHRoOiAnLjRlbScsXG4gICAgaGVpZ2h0OiAnLjRlbScsXG4gICAgdG9wOiAnLS4yZW0nLFxuICAgIGxlZnQ6ICctLjJlbScsXG4gICAgYmFja2dyb3VuZENvbG9yOiAnaW5oZXJpdCcsXG4gICAgdHJhbnNpdGlvbjogJ3RyYW5zZm9ybSAuM3MgZWFzZS1pbi1vdXQnLFxuICAgIGJveFNpemluZzogJ2JvcmRlci1ib3gnXG4gIH0sXG4gICcuY20teVNlbGVjdGlvbkNhcmV0OmhvdmVyID4gLmNtLXlTZWxlY3Rpb25DYXJldERvdCc6IHtcbiAgICB0cmFuc2Zvcm1PcmlnaW46ICdib3R0b20gY2VudGVyJyxcbiAgICB0cmFuc2Zvcm06ICdzY2FsZSgwKSdcbiAgfSxcbiAgJy5jbS15U2VsZWN0aW9uSW5mbyc6IHtcbiAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICB0b3A6ICctMS4wNWVtJyxcbiAgICBsZWZ0OiAnLTFweCcsXG4gICAgZm9udFNpemU6ICcuNzVlbScsXG4gICAgZm9udEZhbWlseTogJ3NlcmlmJyxcbiAgICBmb250U3R5bGU6ICdub3JtYWwnLFxuICAgIGZvbnRXZWlnaHQ6ICdub3JtYWwnLFxuICAgIGxpbmVIZWlnaHQ6ICdub3JtYWwnLFxuICAgIHVzZXJTZWxlY3Q6ICdub25lJyxcbiAgICBjb2xvcjogJ3doaXRlJyxcbiAgICBwYWRkaW5nTGVmdDogJzJweCcsXG4gICAgcGFkZGluZ1JpZ2h0OiAnMnB4JyxcbiAgICB6SW5kZXg6IDEwMSxcbiAgICB0cmFuc2l0aW9uOiAnb3BhY2l0eSAuM3MgZWFzZS1pbi1vdXQnLFxuICAgIGJhY2tncm91bmRDb2xvcjogJ2luaGVyaXQnLFxuICAgIC8vIHRoZXNlIHNob3VsZCBiZSBzZXBhcmF0ZVxuICAgIG9wYWNpdHk6IDAsXG4gICAgdHJhbnNpdGlvbkRlbGF5OiAnMHMnLFxuICAgIHdoaXRlU3BhY2U6ICdub3dyYXAnXG4gIH0sXG4gICcuY20teVNlbGVjdGlvbkNhcmV0OmhvdmVyID4gLmNtLXlTZWxlY3Rpb25JbmZvJzoge1xuICAgIG9wYWNpdHk6IDEsXG4gICAgdHJhbnNpdGlvbkRlbGF5OiAnMHMnXG4gIH1cbn0pXG5cbi8qKlxuICogQHRvZG8gc3BlY2lmeSB0aGUgdXNlcnMgdGhhdCBhY3R1YWxseSBjaGFuZ2VkLiBDdXJyZW50bHksIHdlIHJlY2FsY3VsYXRlIHBvc2l0aW9ucyBmb3IgZXZlcnkgdXNlci5cbiAqIEB0eXBlIHtjbVN0YXRlLkFubm90YXRpb25UeXBlPEFycmF5PG51bWJlcj4+fVxuICovXG5jb25zdCB5UmVtb3RlU2VsZWN0aW9uc0Fubm90YXRpb24gPSBjbVN0YXRlLkFubm90YXRpb24uZGVmaW5lKClcblxuY2xhc3MgWVJlbW90ZUNhcmV0V2lkZ2V0IGV4dGVuZHMgY21WaWV3LldpZGdldFR5cGUge1xuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoY29sb3IsIG5hbWUpIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy5jb2xvciA9IGNvbG9yXG4gICAgdGhpcy5uYW1lID0gbmFtZVxuICB9XG5cbiAgdG9ET00gKCkge1xuICAgIHJldHVybiAvKiogQHR5cGUge0hUTUxFbGVtZW50fSAqLyAoZG9tLmVsZW1lbnQoJ3NwYW4nLCBbcGFpci5jcmVhdGUoJ2NsYXNzJywgJ2NtLXlTZWxlY3Rpb25DYXJldCcpLCBwYWlyLmNyZWF0ZSgnc3R5bGUnLCBgYmFja2dyb3VuZC1jb2xvcjogJHt0aGlzLmNvbG9yfTsgYm9yZGVyLWNvbG9yOiAke3RoaXMuY29sb3J9YCldLCBbXG4gICAgICBkb20udGV4dCgnXFx1MjA2MCcpLFxuICAgICAgZG9tLmVsZW1lbnQoJ2RpdicsIFtcbiAgICAgICAgcGFpci5jcmVhdGUoJ2NsYXNzJywgJ2NtLXlTZWxlY3Rpb25DYXJldERvdCcpXG4gICAgICBdKSxcbiAgICAgIGRvbS50ZXh0KCdcXHUyMDYwJyksXG4gICAgICBkb20uZWxlbWVudCgnZGl2JywgW1xuICAgICAgICBwYWlyLmNyZWF0ZSgnY2xhc3MnLCAnY20teVNlbGVjdGlvbkluZm8nKVxuICAgICAgXSwgW1xuICAgICAgICBkb20udGV4dCh0aGlzLm5hbWUpXG4gICAgICBdKSxcbiAgICAgIGRvbS50ZXh0KCdcXHUyMDYwJylcbiAgICBdKSlcbiAgfVxuXG4gIGVxICh3aWRnZXQpIHtcbiAgICByZXR1cm4gd2lkZ2V0LmNvbG9yID09PSB0aGlzLmNvbG9yXG4gIH1cblxuICBjb21wYXJlICh3aWRnZXQpIHtcbiAgICByZXR1cm4gd2lkZ2V0LmNvbG9yID09PSB0aGlzLmNvbG9yXG4gIH1cblxuICB1cGRhdGVET00gKCkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgZ2V0IGVzdGltYXRlZEhlaWdodCAoKSB7IHJldHVybiAtMSB9XG5cbiAgaWdub3JlRXZlbnQgKCkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFlSZW1vdGVTZWxlY3Rpb25zUGx1Z2luVmFsdWUge1xuICAvKipcbiAgICogQHBhcmFtIHtjbVZpZXcuRWRpdG9yVmlld30gdmlld1xuICAgKi9cbiAgY29uc3RydWN0b3IgKHZpZXcpIHtcbiAgICB0aGlzLmNvbmYgPSB2aWV3LnN0YXRlLmZhY2V0KHlTeW5jRmFjZXQpXG4gICAgdGhpcy5fbGlzdGVuZXIgPSAoeyBhZGRlZCwgdXBkYXRlZCwgcmVtb3ZlZCB9LCBzLCB0KSA9PiB7XG4gICAgICBjb25zdCBjbGllbnRzID0gYWRkZWQuY29uY2F0KHVwZGF0ZWQpLmNvbmNhdChyZW1vdmVkKVxuICAgICAgaWYgKGNsaWVudHMuZmluZEluZGV4KGlkID0+IGlkICE9PSB0aGlzLmNvbmYuYXdhcmVuZXNzLmRvYy5jbGllbnRJRCkgPj0gMCkge1xuICAgICAgICB2aWV3LmRpc3BhdGNoKHsgYW5ub3RhdGlvbnM6IFt5UmVtb3RlU2VsZWN0aW9uc0Fubm90YXRpb24ub2YoW10pXSB9KVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9hd2FyZW5lc3MgPSB0aGlzLmNvbmYuYXdhcmVuZXNzXG4gICAgdGhpcy5fYXdhcmVuZXNzLm9uKCdjaGFuZ2UnLCB0aGlzLl9saXN0ZW5lcilcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7Y21WaWV3LkRlY29yYXRpb25TZXR9XG4gICAgICovXG4gICAgdGhpcy5kZWNvcmF0aW9ucyA9IGNtU3RhdGUuUmFuZ2VTZXQub2YoW10pXG4gIH1cblxuICBkZXN0cm95ICgpIHtcbiAgICB0aGlzLl9hd2FyZW5lc3Mub2ZmKCdjaGFuZ2UnLCB0aGlzLl9saXN0ZW5lcilcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2NtVmlldy5WaWV3VXBkYXRlfSB1cGRhdGVcbiAgICovXG4gIHVwZGF0ZSAodXBkYXRlKSB7XG4gICAgY29uc3QgeXRleHQgPSB0aGlzLmNvbmYueXRleHRcbiAgICBjb25zdCB5ZG9jID0gLyoqIEB0eXBlIHtZLkRvY30gKi8gKHl0ZXh0LmRvYylcbiAgICBjb25zdCBhd2FyZW5lc3MgPSB0aGlzLmNvbmYuYXdhcmVuZXNzXG4gICAgLyoqXG4gICAgICogQHR5cGUge0FycmF5PGNtU3RhdGUuUmFuZ2U8Y21WaWV3LkRlY29yYXRpb24+Pn1cbiAgICAgKi9cbiAgICBjb25zdCBkZWNvcmF0aW9ucyA9IFtdXG4gICAgY29uc3QgbG9jYWxBd2FyZW5lc3NTdGF0ZSA9IHRoaXMuY29uZi5hd2FyZW5lc3MuZ2V0TG9jYWxTdGF0ZSgpXG5cbiAgICAvLyBzZXQgbG9jYWwgYXdhcmVuZXNzIHN0YXRlICh1cGRhdGUgY3Vyc29ycylcbiAgICBpZiAobG9jYWxBd2FyZW5lc3NTdGF0ZSAhPSBudWxsKSB7XG4gICAgICBjb25zdCBoYXNGb2N1cyA9IHVwZGF0ZS52aWV3Lmhhc0ZvY3VzICYmIHVwZGF0ZS52aWV3LmRvbS5vd25lckRvY3VtZW50Lmhhc0ZvY3VzKClcbiAgICAgIGNvbnN0IHNlbCA9IGhhc0ZvY3VzID8gdXBkYXRlLnN0YXRlLnNlbGVjdGlvbi5tYWluIDogbnVsbFxuICAgICAgY29uc3QgY3VycmVudEFuY2hvciA9IGxvY2FsQXdhcmVuZXNzU3RhdGUuY3Vyc29yID09IG51bGwgPyBudWxsIDogWS5jcmVhdGVSZWxhdGl2ZVBvc2l0aW9uRnJvbUpTT04obG9jYWxBd2FyZW5lc3NTdGF0ZS5jdXJzb3IuYW5jaG9yKVxuICAgICAgY29uc3QgY3VycmVudEhlYWQgPSBsb2NhbEF3YXJlbmVzc1N0YXRlLmN1cnNvciA9PSBudWxsID8gbnVsbCA6IFkuY3JlYXRlUmVsYXRpdmVQb3NpdGlvbkZyb21KU09OKGxvY2FsQXdhcmVuZXNzU3RhdGUuY3Vyc29yLmhlYWQpXG5cbiAgICAgIGlmIChzZWwgIT0gbnVsbCkge1xuICAgICAgICBjb25zdCBhbmNob3IgPSBZLmNyZWF0ZVJlbGF0aXZlUG9zaXRpb25Gcm9tVHlwZUluZGV4KHl0ZXh0LCBzZWwuYW5jaG9yKVxuICAgICAgICBjb25zdCBoZWFkID0gWS5jcmVhdGVSZWxhdGl2ZVBvc2l0aW9uRnJvbVR5cGVJbmRleCh5dGV4dCwgc2VsLmhlYWQpXG4gICAgICAgIGlmIChsb2NhbEF3YXJlbmVzc1N0YXRlLmN1cnNvciA9PSBudWxsIHx8ICFZLmNvbXBhcmVSZWxhdGl2ZVBvc2l0aW9ucyhjdXJyZW50QW5jaG9yLCBhbmNob3IpIHx8ICFZLmNvbXBhcmVSZWxhdGl2ZVBvc2l0aW9ucyhjdXJyZW50SGVhZCwgaGVhZCkpIHtcbiAgICAgICAgICBhd2FyZW5lc3Muc2V0TG9jYWxTdGF0ZUZpZWxkKCdjdXJzb3InLCB7XG4gICAgICAgICAgICBhbmNob3IsXG4gICAgICAgICAgICBoZWFkXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChsb2NhbEF3YXJlbmVzc1N0YXRlLmN1cnNvciAhPSBudWxsICYmIGhhc0ZvY3VzKSB7XG4gICAgICAgIGF3YXJlbmVzcy5zZXRMb2NhbFN0YXRlRmllbGQoJ2N1cnNvcicsIG51bGwpXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gdXBkYXRlIGRlY29yYXRpb25zIChyZW1vdGUgc2VsZWN0aW9ucylcbiAgICBhd2FyZW5lc3MuZ2V0U3RhdGVzKCkuZm9yRWFjaCgoc3RhdGUsIGNsaWVudGlkKSA9PiB7XG4gICAgICBpZiAoY2xpZW50aWQgPT09IGF3YXJlbmVzcy5kb2MuY2xpZW50SUQpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBjb25zdCBjdXJzb3IgPSBzdGF0ZS5jdXJzb3JcbiAgICAgIGlmIChjdXJzb3IgPT0gbnVsbCB8fCBjdXJzb3IuYW5jaG9yID09IG51bGwgfHwgY3Vyc29yLmhlYWQgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIGNvbnN0IGFuY2hvciA9IFkuY3JlYXRlQWJzb2x1dGVQb3NpdGlvbkZyb21SZWxhdGl2ZVBvc2l0aW9uKGN1cnNvci5hbmNob3IsIHlkb2MpXG4gICAgICBjb25zdCBoZWFkID0gWS5jcmVhdGVBYnNvbHV0ZVBvc2l0aW9uRnJvbVJlbGF0aXZlUG9zaXRpb24oY3Vyc29yLmhlYWQsIHlkb2MpXG4gICAgICBpZiAoYW5jaG9yID09IG51bGwgfHwgaGVhZCA9PSBudWxsIHx8IGFuY2hvci50eXBlICE9PSB5dGV4dCB8fCBoZWFkLnR5cGUgIT09IHl0ZXh0KSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgY29uc3QgeyBjb2xvciA9ICcjMzBiY2VkJywgbmFtZSA9ICdBbm9ueW1vdXMnIH0gPSBzdGF0ZS51c2VyIHx8IHt9XG4gICAgICBjb25zdCBjb2xvckxpZ2h0ID0gKHN0YXRlLnVzZXIgJiYgc3RhdGUudXNlci5jb2xvckxpZ2h0KSB8fCBjb2xvciArICczMydcbiAgICAgIGNvbnN0IHN0YXJ0ID0gbWF0aC5taW4oYW5jaG9yLmluZGV4LCBoZWFkLmluZGV4KVxuICAgICAgY29uc3QgZW5kID0gbWF0aC5tYXgoYW5jaG9yLmluZGV4LCBoZWFkLmluZGV4KVxuICAgICAgY29uc3Qgc3RhcnRMaW5lID0gdXBkYXRlLnZpZXcuc3RhdGUuZG9jLmxpbmVBdChzdGFydClcbiAgICAgIGNvbnN0IGVuZExpbmUgPSB1cGRhdGUudmlldy5zdGF0ZS5kb2MubGluZUF0KGVuZClcbiAgICAgIGlmIChzdGFydExpbmUubnVtYmVyID09PSBlbmRMaW5lLm51bWJlcikge1xuICAgICAgICAvLyBzZWxlY3RlZCBjb250ZW50IGluIGEgc2luZ2xlIGxpbmUuXG4gICAgICAgIGRlY29yYXRpb25zLnB1c2goe1xuICAgICAgICAgIGZyb206IHN0YXJ0LFxuICAgICAgICAgIHRvOiBlbmQsXG4gICAgICAgICAgdmFsdWU6IGNtVmlldy5EZWNvcmF0aW9uLm1hcmsoe1xuICAgICAgICAgICAgYXR0cmlidXRlczogeyBzdHlsZTogYGJhY2tncm91bmQtY29sb3I6ICR7Y29sb3JMaWdodH1gIH0sXG4gICAgICAgICAgICBjbGFzczogJ2NtLXlTZWxlY3Rpb24nXG4gICAgICAgICAgfSlcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHNlbGVjdGVkIGNvbnRlbnQgaW4gbXVsdGlwbGUgbGluZXNcbiAgICAgICAgLy8gZmlyc3QsIHJlbmRlciB0ZXh0LXNlbGVjdGlvbiBpbiB0aGUgZmlyc3QgbGluZVxuICAgICAgICBkZWNvcmF0aW9ucy5wdXNoKHtcbiAgICAgICAgICBmcm9tOiBzdGFydCxcbiAgICAgICAgICB0bzogc3RhcnRMaW5lLmZyb20gKyBzdGFydExpbmUubGVuZ3RoLFxuICAgICAgICAgIHZhbHVlOiBjbVZpZXcuRGVjb3JhdGlvbi5tYXJrKHtcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHsgc3R5bGU6IGBiYWNrZ3JvdW5kLWNvbG9yOiAke2NvbG9yTGlnaHR9YCB9LFxuICAgICAgICAgICAgY2xhc3M6ICdjbS15U2VsZWN0aW9uJ1xuICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgICAgIC8vIHJlbmRlciB0ZXh0LXNlbGVjdGlvbiBpbiB0aGUgbGFzdCBsaW5lXG4gICAgICAgIGRlY29yYXRpb25zLnB1c2goe1xuICAgICAgICAgIGZyb206IGVuZExpbmUuZnJvbSxcbiAgICAgICAgICB0bzogZW5kLFxuICAgICAgICAgIHZhbHVlOiBjbVZpZXcuRGVjb3JhdGlvbi5tYXJrKHtcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHsgc3R5bGU6IGBiYWNrZ3JvdW5kLWNvbG9yOiAke2NvbG9yTGlnaHR9YCB9LFxuICAgICAgICAgICAgY2xhc3M6ICdjbS15U2VsZWN0aW9uJ1xuICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydExpbmUubnVtYmVyICsgMTsgaSA8IGVuZExpbmUubnVtYmVyOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBsaW5lUG9zID0gdXBkYXRlLnZpZXcuc3RhdGUuZG9jLmxpbmUoaSkuZnJvbVxuICAgICAgICAgIGRlY29yYXRpb25zLnB1c2goe1xuICAgICAgICAgICAgZnJvbTogbGluZVBvcyxcbiAgICAgICAgICAgIHRvOiBsaW5lUG9zLFxuICAgICAgICAgICAgdmFsdWU6IGNtVmlldy5EZWNvcmF0aW9uLmxpbmUoe1xuICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7IHN0eWxlOiBgYmFja2dyb3VuZC1jb2xvcjogJHtjb2xvckxpZ2h0fWAsIGNsYXNzOiAnY20teUxpbmVTZWxlY3Rpb24nIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZGVjb3JhdGlvbnMucHVzaCh7XG4gICAgICAgIGZyb206IGhlYWQuaW5kZXgsXG4gICAgICAgIHRvOiBoZWFkLmluZGV4LFxuICAgICAgICB2YWx1ZTogY21WaWV3LkRlY29yYXRpb24ud2lkZ2V0KHtcbiAgICAgICAgICBzaWRlOiBoZWFkLmluZGV4IC0gYW5jaG9yLmluZGV4ID4gMCA/IC0xIDogMSwgLy8gdGhlIGxvY2FsIGN1cnNvciBzaG91bGQgYmUgcmVuZGVyZWQgb3V0c2lkZSB0aGUgcmVtb3RlIHNlbGVjdGlvblxuICAgICAgICAgIGJsb2NrOiBmYWxzZSxcbiAgICAgICAgICB3aWRnZXQ6IG5ldyBZUmVtb3RlQ2FyZXRXaWRnZXQoY29sb3IsIG5hbWUpXG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH0pXG4gICAgdGhpcy5kZWNvcmF0aW9ucyA9IGNtVmlldy5EZWNvcmF0aW9uLnNldChkZWNvcmF0aW9ucywgdHJ1ZSlcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgeVJlbW90ZVNlbGVjdGlvbnMgPSBjbVZpZXcuVmlld1BsdWdpbi5mcm9tQ2xhc3MoWVJlbW90ZVNlbGVjdGlvbnNQbHVnaW5WYWx1ZSwge1xuICBkZWNvcmF0aW9uczogdiA9PiB2LmRlY29yYXRpb25zXG59KVxuIiwgImltcG9ydCAqIGFzIFkgZnJvbSAneWpzJyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5pbXBvcnQgKiBhcyBjbVN0YXRlIGZyb20gJ0Bjb2RlbWlycm9yL3N0YXRlJ1xuXG5pbXBvcnQgKiBhcyBjbVZpZXcgZnJvbSAnQGNvZGVtaXJyb3IvdmlldydcbmltcG9ydCB7IHlTeW5jRmFjZXQsIHlTeW5jQW5ub3RhdGlvbiB9IGZyb20gJy4veS1zeW5jLmpzJ1xuaW1wb3J0IHsgWVJhbmdlIH0gZnJvbSAnLi95LXJhbmdlLmpzJyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5pbXBvcnQgeyBjcmVhdGVNdXRleCB9IGZyb20gJ2xpYjAvbXV0ZXgnXG5cbmV4cG9ydCBjbGFzcyBZVW5kb01hbmFnZXJDb25maWcge1xuICAvKipcbiAgICogQHBhcmFtIHtZLlVuZG9NYW5hZ2VyfSB1bmRvTWFuYWdlclxuICAgKi9cbiAgY29uc3RydWN0b3IgKHVuZG9NYW5hZ2VyKSB7XG4gICAgdGhpcy51bmRvTWFuYWdlciA9IHVuZG9NYW5hZ2VyXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHthbnl9IG9yaWdpblxuICAgKi9cbiAgYWRkVHJhY2tlZE9yaWdpbiAob3JpZ2luKSB7XG4gICAgdGhpcy51bmRvTWFuYWdlci5hZGRUcmFja2VkT3JpZ2luKG9yaWdpbilcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2FueX0gb3JpZ2luXG4gICAqL1xuICByZW1vdmVUcmFja2VkT3JpZ2luIChvcmlnaW4pIHtcbiAgICB0aGlzLnVuZG9NYW5hZ2VyLnJlbW92ZVRyYWNrZWRPcmlnaW4ob3JpZ2luKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgYSBjaGFuZ2Ugd2FzIHVuZG9uZS5cbiAgICovXG4gIHVuZG8gKCkge1xuICAgIHJldHVybiB0aGlzLnVuZG9NYW5hZ2VyLnVuZG8oKSAhPSBudWxsXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciBhIGNoYW5nZSB3YXMgcmVkb25lLlxuICAgKi9cbiAgcmVkbyAoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5kb01hbmFnZXIucmVkbygpICE9IG51bGxcbiAgfVxufVxuXG4vKipcbiAqIEB0eXBlIHtjbVN0YXRlLkZhY2V0PFlVbmRvTWFuYWdlckNvbmZpZywgWVVuZG9NYW5hZ2VyQ29uZmlnPn1cbiAqL1xuZXhwb3J0IGNvbnN0IHlVbmRvTWFuYWdlckZhY2V0ID0gY21TdGF0ZS5GYWNldC5kZWZpbmUoe1xuICBjb21iaW5lIChpbnB1dHMpIHtcbiAgICByZXR1cm4gaW5wdXRzW2lucHV0cy5sZW5ndGggLSAxXVxuICB9XG59KVxuXG4vKipcbiAqIEB0eXBlIHtjbVN0YXRlLkFubm90YXRpb25UeXBlPFlVbmRvTWFuYWdlckNvbmZpZz59XG4gKi9cbmV4cG9ydCBjb25zdCB5VW5kb01hbmFnZXJBbm5vdGF0aW9uID0gY21TdGF0ZS5Bbm5vdGF0aW9uLmRlZmluZSgpXG5cbi8qKlxuICogQGV4dGVuZHMge1BsdWdpblZhbHVlfVxuICovXG5jbGFzcyBZVW5kb01hbmFnZXJQbHVnaW5WYWx1ZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge2NtVmlldy5FZGl0b3JWaWV3fSB2aWV3XG4gICAqL1xuICBjb25zdHJ1Y3RvciAodmlldykge1xuICAgIHRoaXMudmlldyA9IHZpZXdcbiAgICB0aGlzLmNvbmYgPSB2aWV3LnN0YXRlLmZhY2V0KHlVbmRvTWFuYWdlckZhY2V0KVxuICAgIHRoaXMuX3VuZG9NYW5hZ2VyID0gdGhpcy5jb25mLnVuZG9NYW5hZ2VyXG4gICAgdGhpcy5zeW5jQ29uZiA9IHZpZXcuc3RhdGUuZmFjZXQoeVN5bmNGYWNldClcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVsbCB8IFlSYW5nZX1cbiAgICAgKi9cbiAgICB0aGlzLl9iZWZvcmVDaGFuZ2VTZWxlY3Rpb24gPSBudWxsXG4gICAgdGhpcy5fbXV4ID0gY3JlYXRlTXV0ZXgoKVxuXG4gICAgdGhpcy5fb25TdGFja0l0ZW1BZGRlZCA9ICh7IHN0YWNrSXRlbSwgY2hhbmdlZFBhcmVudFR5cGVzIH0pID0+IHtcbiAgICAgIC8vIG9ubHkgc3RvcmUgbWV0YWRhdGEgaWYgdGhpcyB0eXBlIHdhcyBhZmZlY3RlZFxuICAgICAgaWYgKGNoYW5nZWRQYXJlbnRUeXBlcy5oYXModGhpcy5zeW5jQ29uZi55dGV4dCkgJiYgdGhpcy5fYmVmb3JlQ2hhbmdlU2VsZWN0aW9uICYmICFzdGFja0l0ZW0ubWV0YS5oYXModGhpcykpIHsgLy8gZG8gbm90IG92ZXJ3cml0ZSBwcmV2aW91cyBzdG9yZWQgc2VsZWN0aW9uXG4gICAgICAgIHN0YWNrSXRlbS5tZXRhLnNldCh0aGlzLCB0aGlzLl9iZWZvcmVDaGFuZ2VTZWxlY3Rpb24pXG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX29uU3RhY2tJdGVtUG9wcGVkID0gKHsgc3RhY2tJdGVtIH0pID0+IHtcbiAgICAgIGNvbnN0IHNlbCA9IHN0YWNrSXRlbS5tZXRhLmdldCh0aGlzKVxuICAgICAgaWYgKHNlbCkge1xuICAgICAgICBjb25zdCBzZWxlY3Rpb24gPSB0aGlzLnN5bmNDb25mLmZyb21ZUmFuZ2Uoc2VsKVxuICAgICAgICB2aWV3LmRpc3BhdGNoKHZpZXcuc3RhdGUudXBkYXRlKHsgc2VsZWN0aW9uIH0pKVxuICAgICAgICB0aGlzLl9zdG9yZVNlbGVjdGlvbigpXG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERvIHRoaXMgd2l0aG91dCBtdXRleCwgc2ltcGx5IHVzZSB0aGUgc3luYyBhbm5vdGF0aW9uXG4gICAgICovXG4gICAgdGhpcy5fc3RvcmVTZWxlY3Rpb24gPSAoKSA9PiB7XG4gICAgICAvLyBzdG9yZSB0aGUgc2VsZWN0aW9uIGJlZm9yZSB0aGUgY2hhbmdlIGlzIGFwcGxpZWQgc28gd2UgY2FuIHJlc3RvcmUgaXQgd2l0aCB0aGUgdW5kbyBtYW5hZ2VyLlxuICAgICAgdGhpcy5fYmVmb3JlQ2hhbmdlU2VsZWN0aW9uID0gdGhpcy5zeW5jQ29uZi50b1lSYW5nZSh0aGlzLnZpZXcuc3RhdGUuc2VsZWN0aW9uLm1haW4pXG4gICAgfVxuICAgIHRoaXMuX3VuZG9NYW5hZ2VyLm9uKCdzdGFjay1pdGVtLWFkZGVkJywgdGhpcy5fb25TdGFja0l0ZW1BZGRlZClcbiAgICB0aGlzLl91bmRvTWFuYWdlci5vbignc3RhY2staXRlbS1wb3BwZWQnLCB0aGlzLl9vblN0YWNrSXRlbVBvcHBlZClcbiAgICB0aGlzLl91bmRvTWFuYWdlci5hZGRUcmFja2VkT3JpZ2luKHRoaXMuc3luY0NvbmYpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtjbVZpZXcuVmlld1VwZGF0ZX0gdXBkYXRlXG4gICAqL1xuICB1cGRhdGUgKHVwZGF0ZSkge1xuICAgIGlmICh1cGRhdGUuc2VsZWN0aW9uU2V0ICYmICh1cGRhdGUudHJhbnNhY3Rpb25zLmxlbmd0aCA9PT0gMCB8fCB1cGRhdGUudHJhbnNhY3Rpb25zWzBdLmFubm90YXRpb24oeVN5bmNBbm5vdGF0aW9uKSAhPT0gdGhpcy5zeW5jQ29uZikpIHtcbiAgICAgIC8vIFRoaXMgb25seSB3b3JrcyB3aGVuIFlVbmRvTWFuYWdlclBsdWdpbiBpcyBpbmNsdWRlZCBiZWZvcmUgdGhlIHN5bmMgcGx1Z2luXG4gICAgICB0aGlzLl9zdG9yZVNlbGVjdGlvbigpXG4gICAgfVxuICB9XG5cbiAgZGVzdHJveSAoKSB7XG4gICAgdGhpcy5fdW5kb01hbmFnZXIub2ZmKCdzdGFjay1pdGVtLWFkZGVkJywgdGhpcy5fb25TdGFja0l0ZW1BZGRlZClcbiAgICB0aGlzLl91bmRvTWFuYWdlci5vZmYoJ3N0YWNrLWl0ZW0tcG9wcGVkJywgdGhpcy5fb25TdGFja0l0ZW1Qb3BwZWQpXG4gICAgdGhpcy5fdW5kb01hbmFnZXIucmVtb3ZlVHJhY2tlZE9yaWdpbih0aGlzLnN5bmNDb25mKVxuICB9XG59XG5leHBvcnQgY29uc3QgeVVuZG9NYW5hZ2VyID0gY21WaWV3LlZpZXdQbHVnaW4uZnJvbUNsYXNzKFlVbmRvTWFuYWdlclBsdWdpblZhbHVlKVxuXG4vKipcbiAqIEB0eXBlIHtjbVN0YXRlLlN0YXRlQ29tbWFuZH1cbiAqL1xuZXhwb3J0IGNvbnN0IHVuZG8gPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT5cbiAgc3RhdGUuZmFjZXQoeVVuZG9NYW5hZ2VyRmFjZXQpLnVuZG8oKSB8fCB0cnVlXG5cbi8qKlxuICogQHR5cGUge2NtU3RhdGUuU3RhdGVDb21tYW5kfVxuICovXG5leHBvcnQgY29uc3QgcmVkbyA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PlxuICBzdGF0ZS5mYWNldCh5VW5kb01hbmFnZXJGYWNldCkucmVkbygpIHx8IHRydWVcblxuLyoqXG4gKiBAcGFyYW0ge2NtU3RhdGUuRWRpdG9yU3RhdGV9IHN0YXRlXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCB1bmRvRGVwdGggPSBzdGF0ZSA9PiBzdGF0ZS5mYWNldCh5VW5kb01hbmFnZXJGYWNldCkudW5kb01hbmFnZXIudW5kb1N0YWNrLmxlbmd0aFxuXG4vKipcbiAqIEBwYXJhbSB7Y21TdGF0ZS5FZGl0b3JTdGF0ZX0gc3RhdGVcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IHJlZG9EZXB0aCA9IHN0YXRlID0+IHN0YXRlLmZhY2V0KHlVbmRvTWFuYWdlckZhY2V0KS51bmRvTWFuYWdlci5yZWRvU3RhY2subGVuZ3RoXG5cbi8qKlxuICogRGVmYXVsdCBrZXkgYmluZGlncyBmb3IgdGhlIHVuZG8gbWFuYWdlci5cbiAqIEB0eXBlIHtBcnJheTxjbVZpZXcuS2V5QmluZGluZz59XG4gKi9cbmV4cG9ydCBjb25zdCB5VW5kb01hbmFnZXJLZXltYXAgPSBbXG4gIHsga2V5OiAnTW9kLXonLCBydW46IHVuZG8sIHByZXZlbnREZWZhdWx0OiB0cnVlIH0sXG4gIHsga2V5OiAnTW9kLXknLCBtYWM6ICdNb2QtU2hpZnQteicsIHJ1bjogcmVkbywgcHJldmVudERlZmF1bHQ6IHRydWUgfSxcbiAgeyBrZXk6ICdNb2QtU2hpZnQteicsIHJ1bjogcmVkbywgcHJldmVudERlZmF1bHQ6IHRydWUgfVxuXVxuIiwgIi8qKlxuICogTXV0dWFsIGV4Y2x1ZGUgZm9yIEphdmFTY3JpcHQuXG4gKlxuICogQG1vZHVsZSBtdXRleFxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIG11dGV4XG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCk6dm9pZH0gY2IgT25seSBleGVjdXRlZCB3aGVuIHRoaXMgbXV0ZXggaXMgbm90IGluIHRoZSBjdXJyZW50IHN0YWNrXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCk6dm9pZH0gW2Vsc2VDYl0gRXhlY3V0ZWQgd2hlbiB0aGlzIG11dGV4IGlzIGluIHRoZSBjdXJyZW50IHN0YWNrXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIGEgbXV0dWFsIGV4Y2x1ZGUgZnVuY3Rpb24gd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnR5OlxuICpcbiAqIGBgYGpzXG4gKiBjb25zdCBtdXRleCA9IGNyZWF0ZU11dGV4KClcbiAqIG11dGV4KCgpID0+IHtcbiAqICAgLy8gVGhpcyBmdW5jdGlvbiBpcyBpbW1lZGlhdGVseSBleGVjdXRlZFxuICogICBtdXRleCgoKSA9PiB7XG4gKiAgICAgLy8gVGhpcyBmdW5jdGlvbiBpcyBub3QgZXhlY3V0ZWQsIGFzIHRoZSBtdXRleCBpcyBhbHJlYWR5IGFjdGl2ZS5cbiAqICAgfSlcbiAqIH0pXG4gKiBgYGBcbiAqXG4gKiBAcmV0dXJuIHttdXRleH0gQSBtdXR1YWwgZXhjbHVkZSBmdW5jdGlvblxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgY3JlYXRlTXV0ZXggPSAoKSA9PiB7XG4gIGxldCB0b2tlbiA9IHRydWVcbiAgcmV0dXJuIChmLCBnKSA9PiB7XG4gICAgaWYgKHRva2VuKSB7XG4gICAgICB0b2tlbiA9IGZhbHNlXG4gICAgICB0cnkge1xuICAgICAgICBmKClcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRva2VuID0gdHJ1ZVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBnKClcbiAgICB9XG4gIH1cbn1cbiIsICJpbXBvcnQgKiBhcyBvYnNlcnZhYmxlIGZyb20gJ2xpYjAvb2JzZXJ2YWJsZSdcblxudHlwZSBFdmVudHM8VmFsdWU+ID0ge1xuICBhZGQ6IChrZXk6IHN0cmluZywgdmFsdWU6IFZhbHVlKSA9PiB2b2lkLFxuICB1cGRhdGU6IChrZXk6IHN0cmluZywgb2xkVmFsdWU6IFZhbHVlLCBuZXdWYWx1ZTogVmFsdWUpID0+IHZvaWQsXG4gIGRlbGV0ZTogKGtleTogc3RyaW5nLCBvbGRWYWx1ZTogVmFsdWUpID0+IHZvaWRcbn1cblxuZXhwb3J0IGNsYXNzIFBlZXJkcmFmdFJlY29yZDxWYWx1ZT4gZXh0ZW5kcyBvYnNlcnZhYmxlLk9ic2VydmFibGVWMjxFdmVudHM8VmFsdWU+PiB7XG4gIHByaXZhdGUgcmVjb3JkOiBSZWNvcmQ8c3RyaW5nLCBWYWx1ZT4gPSB7fVxuXG4gIHB1YmxpYyBzZXQoa2V5OiBzdHJpbmcsIHZhbHVlOiBWYWx1ZSkge1xuICAgIGNvbnN0IG9sZFZhbHVlID0gdGhpcy5yZWNvcmRba2V5XVxuICAgIHRoaXMucmVjb3JkW2tleV0gPSB2YWx1ZVxuICAgIGlmIChvbGRWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmVtaXQoJ2FkZCcsIFtrZXksIHZhbHVlXSlcbiAgICB9IGVsc2UgaWYgKG9sZFZhbHVlICE9IHZhbHVlKSB7XG4gICAgICB0aGlzLmVtaXQoJ3VwZGF0ZScsIFtrZXksIG9sZFZhbHVlLCB2YWx1ZV0pXG4gICAgfVxuICB9XG5cbiAgcHVibGljIGdldChrZXk6IHN0cmluZykge1xuICAgIHJldHVybiB0aGlzLnJlY29yZFtrZXldXG4gIH1cblxuICBwdWJsaWMgZGVsZXRlKGtleTogc3RyaW5nKSB7XG4gICAgY29uc3Qgb2xkVmFsdWUgPSB0aGlzLnJlY29yZFtrZXldXG4gICAgZGVsZXRlIHRoaXMucmVjb3JkW2tleV1cbiAgICB0aGlzLmVtaXQoJ2RlbGV0ZScsIFtrZXksIG9sZFZhbHVlXSlcbiAgfVxuXG4gIHB1YmxpYyBnZXQgc2l6ZSgpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5yZWNvcmQpLmxlbmd0aFxuICB9XG5cbiAgcHVibGljIGdldCBrZXlzKCkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLnJlY29yZClcbiAgfVxufSIsICJpbXBvcnQgKiBhcyBvYnNlcnZhYmxlIGZyb20gJ2xpYjAvb2JzZXJ2YWJsZSdcblxudHlwZSBFdmVudHMgPSB7XG4gIGNoYW5nZUlzUHJldmlldzogKG9sZE1vZGU6IGJvb2xlYW4sIG5ld01vZGU6IGJvb2xlYW4pID0+IHZvaWQsXG4gIGNoYW5nZVBhdGg6IChvbGRQYXRoOiBzdHJpbmcsIG5ld1BhdGg6IHN0cmluZykgPT4gdm9pZFxufVxuXG5leHBvcnQgY2xhc3MgUGVlcmRyYWZ0TGVhZiBleHRlbmRzIG9ic2VydmFibGUuT2JzZXJ2YWJsZVYyPEV2ZW50cz4ge1xuICBwcml2YXRlIF9pc1ByZXZpZXc6IGJvb2xlYW5cbiAgcHJpdmF0ZSBfcGF0aDogc3RyaW5nXG5cbiAgY29uc3RydWN0b3IocGF0aDogc3RyaW5nLCBpc1ByZXZpZXc6IGJvb2xlYW4pIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy5faXNQcmV2aWV3ID0gaXNQcmV2aWV3LFxuICAgIHRoaXMuX3BhdGggPSBwYXRoXG4gIH1cblxuICBnZXQgaXNQcmV2aWV3ICgpIHtcbiAgICByZXR1cm4gdGhpcy5faXNQcmV2aWV3XG4gIH1cblxuICBzZXQgaXNQcmV2aWV3ICh2YWx1ZTogYm9vbGVhbikge1xuICAgIGNvbnN0IG9sZCA9IHRoaXMuX2lzUHJldmlld1xuICAgIHRoaXMuX2lzUHJldmlldyA9IHZhbHVlXG4gICAgaWYgKHZhbHVlICE9IG9sZCkge1xuICAgICAgdGhpcy5lbWl0KCdjaGFuZ2VJc1ByZXZpZXcnLCBbb2xkLCB2YWx1ZV0pXG4gICAgfVxuICB9XG5cbiAgZ2V0IHBhdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhdGhcbiAgfVxuXG4gIHNldCBwYXRoICh2YWx1ZTogc3RyaW5nKSB7XG4gICAgY29uc3Qgb2xkID0gdGhpcy5fcGF0aFxuICAgIHRoaXMuX3BhdGggPSB2YWx1ZVxuICAgIGlmICh2YWx1ZSAhPSBvbGQpIHtcbiAgICAgIHRoaXMuZW1pdCgnY2hhbmdlUGF0aCcsIFtvbGQsIHZhbHVlXSlcbiAgICB9XG4gIH1cblxufSIsICJpbXBvcnQgeyBQZWVyZHJhZnRSZWNvcmQgfSBmcm9tIFwic3JjL3V0aWxzL3BlZXJkcmFmdFJlY29yZFwiO1xuaW1wb3J0IHsgUGVlcmRyYWZ0TGVhZiB9IGZyb20gXCIuL3BlZXJkcmFmdExlYWZcIjtcbmltcG9ydCB7IE1hcmtkb3duVmlldywgV29ya3NwYWNlLCBub3JtYWxpemVQYXRoIH0gZnJvbSBcIm9ic2lkaWFuXCI7XG5cbmV4cG9ydCBjb25zdCB1cGRhdGVQZWVyZHJhZnRXb3Jrc3BhY2UgPSAod3M6IFdvcmtzcGFjZSwgcHdzOiBQZWVyZHJhZnRSZWNvcmQ8UGVlcmRyYWZ0TGVhZj4pID0+IHtcbiAgY29uc3QgbGVhZnMgPSB3cy5nZXRMZWF2ZXNPZlR5cGUoXCJtYXJrZG93blwiKVxuICBcbiAgY29uc3Qgb2xkTGVhZklkcyA9IHB3cy5rZXlzXG4gIGNvbnN0IGV4aXN0aW5nTGVhZklkcyA9IGxlYWZzLm1hcChsZWFmID0+IHtcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgcmV0dXJuIGxlYWYuaWQgYXMgc3RyaW5nXG4gIH0pXG5cbiAgZm9yIChjb25zdCBsZWFmIG9mIGxlYWZzKSB7XG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgIGNvbnN0IGxlYWZJZCA9IGxlYWYuaWQgYXMgc3RyaW5nXG5cbiAgICBjb25zdCBpc1ByZXZpZXcgPSBsZWFmLnZpZXcuY29udGFpbmVyRWwuZ2V0QXR0cmlidXRlKFwiZGF0YS1tb2RlXCIpID09PSBcInByZXZpZXdcIlxuICAgIGNvbnN0IHBhdGggPSAobGVhZi52aWV3IGFzIChNYXJrZG93blZpZXcpKS5maWxlPy5wYXRoID8/ICcnXG5cbiAgICBsZXQgcGxlYWYgPSBwd3MuZ2V0KGxlYWZJZClcbiAgICBpZiAocGxlYWYpIHtcbiAgICAgIHBsZWFmLmlzUHJldmlldyA9IGlzUHJldmlld1xuICAgICAgcGxlYWYucGF0aCA9IHBhdGhcbiAgICB9IGVsc2Uge1xuICAgICAgcGxlYWYgPSBuZXcgUGVlcmRyYWZ0TGVhZihwYXRoLCBpc1ByZXZpZXcpXG4gICAgICBwd3Muc2V0KGxlYWZJZCwgcGxlYWYpXG4gICAgfVxuICB9XG5cbiAgZm9yIChjb25zdCBvbGRMZWFmSWQgb2Ygb2xkTGVhZklkcykgeyBcbiAgICBpZighZXhpc3RpbmdMZWFmSWRzLmNvbnRhaW5zKG9sZExlYWZJZCkpIHtcbiAgICAgIHB3cy5kZWxldGUob2xkTGVhZklkKVxuICAgIH1cbiAgfVxuXG59XG5cbmV4cG9ydCBjb25zdCBnZXRMZWFmc0J5UGF0aCA9IChwYXRoOiBzdHJpbmcsIHB3czogUGVlcmRyYWZ0UmVjb3JkPFBlZXJkcmFmdExlYWY+KSA9PiB7XG4gIHJldHVybiBwd3Mua2V5cy5tYXAoKGtleSkgPT4ge1xuICAgIHJldHVybiBwd3MuZ2V0KGtleSlcbiAgfSkuZmlsdGVyKChsZWFmKSA9PiB7XG4gICAgcmV0dXJuIGxlYWYucGF0aCA9PT0gcGF0aFxuICB9KVxufVxuXG5leHBvcnQgY29uc3QgZ2V0TGVhZklkc0J5UGF0aCA9IChwYXRoOiBzdHJpbmcsIHB3czogUGVlcmRyYWZ0UmVjb3JkPFBlZXJkcmFmdExlYWY+KSA9PiB7XG4gIGNvbnN0IG5vcm1hbGl6ZWRQYXRoID0gbm9ybWFsaXplUGF0aChwYXRoKVxuICByZXR1cm4gcHdzLmtleXMuZmlsdGVyKChrZXkpID0+IHtcbiAgICByZXR1cm4gbm9ybWFsaXplUGF0aChwd3MuZ2V0KGtleSkucGF0aCkgPT09IG5vcm1hbGl6ZWRQYXRoXG4gIH0pXG59IiwgIi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuXG4vKipcbiAqIFRpbnkgd2Vic29ja2V0IGNvbm5lY3Rpb24gaGFuZGxlci5cbiAqXG4gKiBJbXBsZW1lbnRzIGV4cG9uZW50aWFsIGJhY2tvZmYgcmVjb25uZWN0cywgcGluZy9wb25nLCBhbmQgYSBuaWNlIGV2ZW50IHN5c3RlbSB1c2luZyBbbGliMC9vYnNlcnZhYmxlXS5cbiAqXG4gKiBAbW9kdWxlIHdlYnNvY2tldFxuICovXG5cbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICcuL29ic2VydmFibGUuanMnXG5pbXBvcnQgKiBhcyB0aW1lIGZyb20gJy4vdGltZS5qcydcbmltcG9ydCAqIGFzIG1hdGggZnJvbSAnLi9tYXRoLmpzJ1xuXG5jb25zdCByZWNvbm5lY3RUaW1lb3V0QmFzZSA9IDEyMDBcbmNvbnN0IG1heFJlY29ubmVjdFRpbWVvdXQgPSAyNTAwXG4vLyBAdG9kbyAtIHRoaXMgc2hvdWxkIGRlcGVuZCBvbiBhd2FyZW5lc3Mub3V0ZGF0ZWRUaW1lXG5jb25zdCBtZXNzYWdlUmVjb25uZWN0VGltZW91dCA9IDMwMDAwXG5cbi8qKlxuICogQHBhcmFtIHtXZWJzb2NrZXRDbGllbnR9IHdzY2xpZW50XG4gKi9cbmNvbnN0IHNldHVwV1MgPSAod3NjbGllbnQpID0+IHtcbiAgaWYgKHdzY2xpZW50LnNob3VsZENvbm5lY3QgJiYgd3NjbGllbnQud3MgPT09IG51bGwpIHtcbiAgICBjb25zdCB3ZWJzb2NrZXQgPSBuZXcgV2ViU29ja2V0KHdzY2xpZW50LnVybClcbiAgICBjb25zdCBiaW5hcnlUeXBlID0gd3NjbGllbnQuYmluYXJ5VHlwZVxuICAgIC8qKlxuICAgICAqIEB0eXBlIHthbnl9XG4gICAgICovXG4gICAgbGV0IHBpbmdUaW1lb3V0ID0gbnVsbFxuICAgIGlmIChiaW5hcnlUeXBlKSB7XG4gICAgICB3ZWJzb2NrZXQuYmluYXJ5VHlwZSA9IGJpbmFyeVR5cGVcbiAgICB9XG4gICAgd3NjbGllbnQud3MgPSB3ZWJzb2NrZXRcbiAgICB3c2NsaWVudC5jb25uZWN0aW5nID0gdHJ1ZVxuICAgIHdzY2xpZW50LmNvbm5lY3RlZCA9IGZhbHNlXG4gICAgd2Vic29ja2V0Lm9ubWVzc2FnZSA9IGV2ZW50ID0+IHtcbiAgICAgIHdzY2xpZW50Lmxhc3RNZXNzYWdlUmVjZWl2ZWQgPSB0aW1lLmdldFVuaXhUaW1lKClcbiAgICAgIGNvbnN0IGRhdGEgPSBldmVudC5kYXRhXG4gICAgICBjb25zdCBtZXNzYWdlID0gdHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnID8gSlNPTi5wYXJzZShkYXRhKSA6IGRhdGFcbiAgICAgIGlmIChtZXNzYWdlICYmIG1lc3NhZ2UudHlwZSA9PT0gJ3BvbmcnKSB7XG4gICAgICAgIGNsZWFyVGltZW91dChwaW5nVGltZW91dClcbiAgICAgICAgcGluZ1RpbWVvdXQgPSBzZXRUaW1lb3V0KHNlbmRQaW5nLCBtZXNzYWdlUmVjb25uZWN0VGltZW91dCAvIDIpXG4gICAgICB9XG4gICAgICB3c2NsaWVudC5lbWl0KCdtZXNzYWdlJywgW21lc3NhZ2UsIHdzY2xpZW50XSlcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHthbnl9IGVycm9yXG4gICAgICovXG4gICAgY29uc3Qgb25jbG9zZSA9IGVycm9yID0+IHtcbiAgICAgIGlmICh3c2NsaWVudC53cyAhPT0gbnVsbCkge1xuICAgICAgICB3c2NsaWVudC53cyA9IG51bGxcbiAgICAgICAgd3NjbGllbnQuY29ubmVjdGluZyA9IGZhbHNlXG4gICAgICAgIGlmICh3c2NsaWVudC5jb25uZWN0ZWQpIHtcbiAgICAgICAgICB3c2NsaWVudC5jb25uZWN0ZWQgPSBmYWxzZVxuICAgICAgICAgIHdzY2xpZW50LmVtaXQoJ2Rpc2Nvbm5lY3QnLCBbeyB0eXBlOiAnZGlzY29ubmVjdCcsIGVycm9yIH0sIHdzY2xpZW50XSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3c2NsaWVudC51bnN1Y2Nlc3NmdWxSZWNvbm5lY3RzKytcbiAgICAgICAgfVxuICAgICAgICAvLyBTdGFydCB3aXRoIG5vIHJlY29ubmVjdCB0aW1lb3V0IGFuZCBpbmNyZWFzZSB0aW1lb3V0IGJ5XG4gICAgICAgIC8vIGxvZzEwKHdzVW5zdWNjZXNzZnVsUmVjb25uZWN0cykuXG4gICAgICAgIC8vIFRoZSBpZGVhIGlzIHRvIGluY3JlYXNlIHJlY29ubmVjdCB0aW1lb3V0IHNsb3dseSBhbmQgaGF2ZSBubyByZWNvbm5lY3RcbiAgICAgICAgLy8gdGltZW91dCBhdCB0aGUgYmVnaW5uaW5nIChsb2coMSkgPSAwKVxuICAgICAgICBzZXRUaW1lb3V0KHNldHVwV1MsIG1hdGgubWluKG1hdGgubG9nMTAod3NjbGllbnQudW5zdWNjZXNzZnVsUmVjb25uZWN0cyArIDEpICogcmVjb25uZWN0VGltZW91dEJhc2UsIG1heFJlY29ubmVjdFRpbWVvdXQpLCB3c2NsaWVudClcbiAgICAgIH1cbiAgICAgIGNsZWFyVGltZW91dChwaW5nVGltZW91dClcbiAgICB9XG4gICAgY29uc3Qgc2VuZFBpbmcgPSAoKSA9PiB7XG4gICAgICBpZiAod3NjbGllbnQud3MgPT09IHdlYnNvY2tldCkge1xuICAgICAgICB3c2NsaWVudC5zZW5kKHtcbiAgICAgICAgICB0eXBlOiAncGluZydcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9XG4gICAgd2Vic29ja2V0Lm9uY2xvc2UgPSAoKSA9PiBvbmNsb3NlKG51bGwpXG4gICAgd2Vic29ja2V0Lm9uZXJyb3IgPSBlcnJvciA9PiBvbmNsb3NlKGVycm9yKVxuICAgIHdlYnNvY2tldC5vbm9wZW4gPSAoKSA9PiB7XG4gICAgICB3c2NsaWVudC5sYXN0TWVzc2FnZVJlY2VpdmVkID0gdGltZS5nZXRVbml4VGltZSgpXG4gICAgICB3c2NsaWVudC5jb25uZWN0aW5nID0gZmFsc2VcbiAgICAgIHdzY2xpZW50LmNvbm5lY3RlZCA9IHRydWVcbiAgICAgIHdzY2xpZW50LnVuc3VjY2Vzc2Z1bFJlY29ubmVjdHMgPSAwXG4gICAgICB3c2NsaWVudC5lbWl0KCdjb25uZWN0JywgW3sgdHlwZTogJ2Nvbm5lY3QnIH0sIHdzY2xpZW50XSlcbiAgICAgIC8vIHNldCBwaW5nXG4gICAgICBwaW5nVGltZW91dCA9IHNldFRpbWVvdXQoc2VuZFBpbmcsIG1lc3NhZ2VSZWNvbm5lY3RUaW1lb3V0IC8gMilcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAZGVwcmVjYXRlZFxuICogQGV4dGVuZHMgT2JzZXJ2YWJsZTxzdHJpbmc+XG4gKi9cbmV4cG9ydCBjbGFzcyBXZWJzb2NrZXRDbGllbnQgZXh0ZW5kcyBPYnNlcnZhYmxlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdHNcbiAgICogQHBhcmFtIHsnYXJyYXlidWZmZXInIHwgJ2Jsb2InIHwgbnVsbH0gW29wdHMuYmluYXJ5VHlwZV0gU2V0IGB3cy5iaW5hcnlUeXBlYFxuICAgKi9cbiAgY29uc3RydWN0b3IgKHVybCwgeyBiaW5hcnlUeXBlIH0gPSB7fSkge1xuICAgIHN1cGVyKClcbiAgICB0aGlzLnVybCA9IHVybFxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtXZWJTb2NrZXQ/fVxuICAgICAqL1xuICAgIHRoaXMud3MgPSBudWxsXG4gICAgdGhpcy5iaW5hcnlUeXBlID0gYmluYXJ5VHlwZSB8fCBudWxsXG4gICAgdGhpcy5jb25uZWN0ZWQgPSBmYWxzZVxuICAgIHRoaXMuY29ubmVjdGluZyA9IGZhbHNlXG4gICAgdGhpcy51bnN1Y2Nlc3NmdWxSZWNvbm5lY3RzID0gMFxuICAgIHRoaXMubGFzdE1lc3NhZ2VSZWNlaXZlZCA9IDBcbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRvIGNvbm5lY3QgdG8gb3RoZXIgcGVlcnMgb3Igbm90XG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5zaG91bGRDb25uZWN0ID0gdHJ1ZVxuICAgIHRoaXMuX2NoZWNrSW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICBpZiAodGhpcy5jb25uZWN0ZWQgJiYgbWVzc2FnZVJlY29ubmVjdFRpbWVvdXQgPCB0aW1lLmdldFVuaXhUaW1lKCkgLSB0aGlzLmxhc3RNZXNzYWdlUmVjZWl2ZWQpIHtcbiAgICAgICAgLy8gbm8gbWVzc2FnZSByZWNlaXZlZCBpbiBhIGxvbmcgdGltZSAtIG5vdCBldmVuIHlvdXIgb3duIGF3YXJlbmVzc1xuICAgICAgICAvLyB1cGRhdGVzICh3aGljaCBhcmUgdXBkYXRlZCBldmVyeSAxNSBzZWNvbmRzKVxuICAgICAgICAvKiogQHR5cGUge1dlYlNvY2tldH0gKi8gKHRoaXMud3MpLmNsb3NlKClcbiAgICAgIH1cbiAgICB9LCBtZXNzYWdlUmVjb25uZWN0VGltZW91dCAvIDIpXG4gICAgc2V0dXBXUyh0aGlzKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7YW55fSBtZXNzYWdlXG4gICAqL1xuICBzZW5kIChtZXNzYWdlKSB7XG4gICAgaWYgKHRoaXMud3MpIHtcbiAgICAgIHRoaXMud3Muc2VuZChKU09OLnN0cmluZ2lmeShtZXNzYWdlKSlcbiAgICB9XG4gIH1cblxuICBkZXN0cm95ICgpIHtcbiAgICBjbGVhckludGVydmFsKHRoaXMuX2NoZWNrSW50ZXJ2YWwpXG4gICAgdGhpcy5kaXNjb25uZWN0KClcbiAgICBzdXBlci5kZXN0cm95KClcbiAgfVxuXG4gIGRpc2Nvbm5lY3QgKCkge1xuICAgIHRoaXMuc2hvdWxkQ29ubmVjdCA9IGZhbHNlXG4gICAgaWYgKHRoaXMud3MgIT09IG51bGwpIHtcbiAgICAgIHRoaXMud3MuY2xvc2UoKVxuICAgIH1cbiAgfVxuXG4gIGNvbm5lY3QgKCkge1xuICAgIHRoaXMuc2hvdWxkQ29ubmVjdCA9IHRydWVcbiAgICBpZiAoIXRoaXMuY29ubmVjdGVkICYmIHRoaXMud3MgPT09IG51bGwpIHtcbiAgICAgIHNldHVwV1ModGhpcylcbiAgICB9XG4gIH1cbn1cbiIsICIvKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cblxuLyoqXG4gKiBIZWxwZXJzIGZvciBjcm9zcy10YWIgY29tbXVuaWNhdGlvbiB1c2luZyBicm9hZGNhc3RjaGFubmVsIHdpdGggTG9jYWxTdG9yYWdlIGZhbGxiYWNrLlxuICpcbiAqIGBgYGpzXG4gKiAvLyBJbiBicm93c2VyIHdpbmRvdyBBOlxuICogYnJvYWRjYXN0Y2hhbm5lbC5zdWJzY3JpYmUoJ215IGV2ZW50cycsIGRhdGEgPT4gY29uc29sZS5sb2coZGF0YSkpXG4gKiBicm9hZGNhc3RjaGFubmVsLnB1Ymxpc2goJ215IGV2ZW50cycsICdIZWxsbyB3b3JsZCEnKSAvLyA9PiBBOiAnSGVsbG8gd29ybGQhJyBmaXJlcyBzeW5jaHJvbm91c2x5IGluIHNhbWUgdGFiXG4gKlxuICogLy8gSW4gYnJvd3NlciB3aW5kb3cgQjpcbiAqIGJyb2FkY2FzdGNoYW5uZWwucHVibGlzaCgnbXkgZXZlbnRzJywgJ2hlbGxvIGZyb20gdGFiIEInKSAvLyA9PiBBOiAnaGVsbG8gZnJvbSB0YWIgQidcbiAqIGBgYFxuICpcbiAqIEBtb2R1bGUgYnJvYWRjYXN0Y2hhbm5lbFxuICovXG5cbi8vIEB0b2RvIGJlZm9yZSBuZXh0IG1ham9yOiB1c2UgVWludDhBcnJheSBpbnN0ZWFkIGFzIGJ1ZmZlciBvYmplY3RcblxuaW1wb3J0ICogYXMgbWFwIGZyb20gJy4vbWFwLmpzJ1xuaW1wb3J0ICogYXMgc2V0IGZyb20gJy4vc2V0LmpzJ1xuaW1wb3J0ICogYXMgYnVmZmVyIGZyb20gJy4vYnVmZmVyLmpzJ1xuaW1wb3J0ICogYXMgc3RvcmFnZSBmcm9tICcuL3N0b3JhZ2UuanMnXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gQ2hhbm5lbFxuICogQHByb3BlcnR5IHtTZXQ8ZnVuY3Rpb24oYW55LCBhbnkpOmFueT59IENoYW5uZWwuc3Vic1xuICogQHByb3BlcnR5IHthbnl9IENoYW5uZWwuYmNcbiAqL1xuXG4vKipcbiAqIEB0eXBlIHtNYXA8c3RyaW5nLCBDaGFubmVsPn1cbiAqL1xuY29uc3QgY2hhbm5lbHMgPSBuZXcgTWFwKClcblxuLyogYzggaWdub3JlIHN0YXJ0ICovXG5jbGFzcyBMb2NhbFN0b3JhZ2VQb2x5ZmlsbCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcm9vbVxuICAgKi9cbiAgY29uc3RydWN0b3IgKHJvb20pIHtcbiAgICB0aGlzLnJvb20gPSByb29tXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bGx8ZnVuY3Rpb24oe2RhdGE6QXJyYXlCdWZmZXJ9KTp2b2lkfVxuICAgICAqL1xuICAgIHRoaXMub25tZXNzYWdlID0gbnVsbFxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7YW55fSBlXG4gICAgICovXG4gICAgdGhpcy5fb25DaGFuZ2UgPSBlID0+IGUua2V5ID09PSByb29tICYmIHRoaXMub25tZXNzYWdlICE9PSBudWxsICYmIHRoaXMub25tZXNzYWdlKHsgZGF0YTogYnVmZmVyLmZyb21CYXNlNjQoZS5uZXdWYWx1ZSB8fCAnJykgfSlcbiAgICBzdG9yYWdlLm9uQ2hhbmdlKHRoaXMuX29uQ2hhbmdlKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGJ1ZlxuICAgKi9cbiAgcG9zdE1lc3NhZ2UgKGJ1Zikge1xuICAgIHN0b3JhZ2UudmFyU3RvcmFnZS5zZXRJdGVtKHRoaXMucm9vbSwgYnVmZmVyLnRvQmFzZTY0KGJ1ZmZlci5jcmVhdGVVaW50OEFycmF5RnJvbUFycmF5QnVmZmVyKGJ1ZikpKVxuICB9XG5cbiAgY2xvc2UgKCkge1xuICAgIHN0b3JhZ2Uub2ZmQ2hhbmdlKHRoaXMuX29uQ2hhbmdlKVxuICB9XG59XG4vKiBjOCBpZ25vcmUgc3RvcCAqL1xuXG4vLyBVc2UgQnJvYWRjYXN0Q2hhbm5lbCBvciBQb2x5ZmlsbFxuLyogYzggaWdub3JlIG5leHQgKi9cbmNvbnN0IEJDID0gdHlwZW9mIEJyb2FkY2FzdENoYW5uZWwgPT09ICd1bmRlZmluZWQnID8gTG9jYWxTdG9yYWdlUG9seWZpbGwgOiBCcm9hZGNhc3RDaGFubmVsXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHJvb21cbiAqIEByZXR1cm4ge0NoYW5uZWx9XG4gKi9cbmNvbnN0IGdldENoYW5uZWwgPSByb29tID0+XG4gIG1hcC5zZXRJZlVuZGVmaW5lZChjaGFubmVscywgcm9vbSwgKCkgPT4ge1xuICAgIGNvbnN0IHN1YnMgPSBzZXQuY3JlYXRlKClcbiAgICBjb25zdCBiYyA9IG5ldyBCQyhyb29tKVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7e2RhdGE6QXJyYXlCdWZmZXJ9fSBlXG4gICAgICovXG4gICAgLyogYzggaWdub3JlIG5leHQgKi9cbiAgICBiYy5vbm1lc3NhZ2UgPSBlID0+IHN1YnMuZm9yRWFjaChzdWIgPT4gc3ViKGUuZGF0YSwgJ2Jyb2FkY2FzdGNoYW5uZWwnKSlcbiAgICByZXR1cm4ge1xuICAgICAgYmMsIHN1YnNcbiAgICB9XG4gIH0pXG5cbi8qKlxuICogU3Vic2NyaWJlIHRvIGdsb2JhbCBgcHVibGlzaGAgZXZlbnRzLlxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IHJvb21cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oYW55LCBhbnkpOmFueX0gZlxuICovXG5leHBvcnQgY29uc3Qgc3Vic2NyaWJlID0gKHJvb20sIGYpID0+IHtcbiAgZ2V0Q2hhbm5lbChyb29tKS5zdWJzLmFkZChmKVxuICByZXR1cm4gZlxufVxuXG4vKipcbiAqIFVuc3Vic2NyaWJlIGZyb20gYHB1Ymxpc2hgIGdsb2JhbCBldmVudHMuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gcm9vbVxuICogQHBhcmFtIHtmdW5jdGlvbihhbnksIGFueSk6YW55fSBmXG4gKi9cbmV4cG9ydCBjb25zdCB1bnN1YnNjcmliZSA9IChyb29tLCBmKSA9PiB7XG4gIGNvbnN0IGNoYW5uZWwgPSBnZXRDaGFubmVsKHJvb20pXG4gIGNvbnN0IHVuc3Vic2NyaWJlZCA9IGNoYW5uZWwuc3Vicy5kZWxldGUoZilcbiAgaWYgKHVuc3Vic2NyaWJlZCAmJiBjaGFubmVsLnN1YnMuc2l6ZSA9PT0gMCkge1xuICAgIGNoYW5uZWwuYmMuY2xvc2UoKVxuICAgIGNoYW5uZWxzLmRlbGV0ZShyb29tKVxuICB9XG4gIHJldHVybiB1bnN1YnNjcmliZWRcbn1cblxuLyoqXG4gKiBQdWJsaXNoIGRhdGEgdG8gYWxsIHN1YnNjcmliZXJzIChpbmNsdWRpbmcgc3Vic2NyaWJlcnMgb24gdGhpcyB0YWIpXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gcm9vbVxuICogQHBhcmFtIHthbnl9IGRhdGFcbiAqIEBwYXJhbSB7YW55fSBbb3JpZ2luXVxuICovXG5leHBvcnQgY29uc3QgcHVibGlzaCA9IChyb29tLCBkYXRhLCBvcmlnaW4gPSBudWxsKSA9PiB7XG4gIGNvbnN0IGMgPSBnZXRDaGFubmVsKHJvb20pXG4gIGMuYmMucG9zdE1lc3NhZ2UoZGF0YSlcbiAgYy5zdWJzLmZvckVhY2goc3ViID0+IHN1YihkYXRhLCBvcmlnaW4pKVxufVxuIiwgImltcG9ydCAqIGFzIHdzIGZyb20gJ2xpYjAvd2Vic29ja2V0J1xuaW1wb3J0ICogYXMgbWFwIGZyb20gJ2xpYjAvbWFwJ1xuaW1wb3J0ICogYXMgZXJyb3IgZnJvbSAnbGliMC9lcnJvcidcbmltcG9ydCAqIGFzIHJhbmRvbSBmcm9tICdsaWIwL3JhbmRvbSdcbmltcG9ydCAqIGFzIGVuY29kaW5nIGZyb20gJ2xpYjAvZW5jb2RpbmcnXG5pbXBvcnQgKiBhcyBkZWNvZGluZyBmcm9tICdsaWIwL2RlY29kaW5nJ1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ2xpYjAvb2JzZXJ2YWJsZSdcbmltcG9ydCAqIGFzIGxvZ2dpbmcgZnJvbSAnbGliMC9sb2dnaW5nJ1xuaW1wb3J0ICogYXMgcHJvbWlzZSBmcm9tICdsaWIwL3Byb21pc2UnXG5pbXBvcnQgKiBhcyBiYyBmcm9tICdsaWIwL2Jyb2FkY2FzdGNoYW5uZWwnXG5pbXBvcnQgKiBhcyBidWZmZXIgZnJvbSAnbGliMC9idWZmZXInXG5pbXBvcnQgKiBhcyBtYXRoIGZyb20gJ2xpYjAvbWF0aCdcbmltcG9ydCB7IGNyZWF0ZU11dGV4IH0gZnJvbSAnbGliMC9tdXRleCdcblxuaW1wb3J0ICogYXMgWSBmcm9tICd5anMnIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbmltcG9ydCBQZWVyIGZyb20gJ3NpbXBsZS1wZWVyL3NpbXBsZXBlZXIubWluLmpzJ1xuXG5pbXBvcnQgKiBhcyBzeW5jUHJvdG9jb2wgZnJvbSAneS1wcm90b2NvbHMvc3luYydcbmltcG9ydCAqIGFzIGF3YXJlbmVzc1Byb3RvY29sIGZyb20gJ3ktcHJvdG9jb2xzL2F3YXJlbmVzcydcblxuaW1wb3J0ICogYXMgY3J5cHRvdXRpbHMgZnJvbSAnLi9jcnlwdG8uanMnXG5cbmNvbnN0IGxvZyA9IGxvZ2dpbmcuY3JlYXRlTW9kdWxlTG9nZ2VyKCd5LXdlYnJ0YycpXG5cbmNvbnN0IG1lc3NhZ2VTeW5jID0gMFxuY29uc3QgbWVzc2FnZVF1ZXJ5QXdhcmVuZXNzID0gM1xuY29uc3QgbWVzc2FnZUF3YXJlbmVzcyA9IDFcbmNvbnN0IG1lc3NhZ2VCY1BlZXJJZCA9IDRcblxuLyoqXG4gKiBAdHlwZSB7TWFwPHN0cmluZywgU2lnbmFsaW5nQ29ubj59XG4gKi9cbmNvbnN0IHNpZ25hbGluZ0Nvbm5zID0gbmV3IE1hcCgpXG5cbi8qKlxuICogQHR5cGUge01hcDxzdHJpbmcsUm9vbT59XG4gKi9cbmNvbnN0IHJvb21zID0gbmV3IE1hcCgpXG5cbi8qKlxuICogQHBhcmFtIHtSb29tfSByb29tXG4gKi9cbmNvbnN0IGNoZWNrSXNTeW5jZWQgPSByb29tID0+IHtcbiAgbGV0IHN5bmNlZCA9IHRydWVcbiAgcm9vbS53ZWJydGNDb25ucy5mb3JFYWNoKHBlZXIgPT4ge1xuICAgIGlmICghcGVlci5zeW5jZWQpIHtcbiAgICAgIHN5bmNlZCA9IGZhbHNlXG4gICAgfVxuICB9KVxuICBpZiAoKCFzeW5jZWQgJiYgcm9vbS5zeW5jZWQpIHx8IChzeW5jZWQgJiYgIXJvb20uc3luY2VkKSkge1xuICAgIHJvb20uc3luY2VkID0gc3luY2VkXG4gICAgcm9vbS5wcm92aWRlci5lbWl0KCdzeW5jZWQnLCBbeyBzeW5jZWQgfV0pXG4gICAgbG9nKCdzeW5jZWQgJywgbG9nZ2luZy5CT0xELCByb29tLm5hbWUsIGxvZ2dpbmcuVU5CT0xELCAnIHdpdGggYWxsIHBlZXJzJylcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7Um9vbX0gcm9vbVxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWZcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHN5bmNlZENhbGxiYWNrXG4gKiBAcmV0dXJuIHtlbmNvZGluZy5FbmNvZGVyP31cbiAqL1xuY29uc3QgcmVhZE1lc3NhZ2UgPSAocm9vbSwgYnVmLCBzeW5jZWRDYWxsYmFjaykgPT4ge1xuICBjb25zdCBkZWNvZGVyID0gZGVjb2RpbmcuY3JlYXRlRGVjb2RlcihidWYpXG4gIGNvbnN0IGVuY29kZXIgPSBlbmNvZGluZy5jcmVhdGVFbmNvZGVyKClcbiAgY29uc3QgbWVzc2FnZVR5cGUgPSBkZWNvZGluZy5yZWFkVmFyVWludChkZWNvZGVyKVxuICBpZiAocm9vbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuICBjb25zdCBhd2FyZW5lc3MgPSByb29tLmF3YXJlbmVzc1xuICBjb25zdCBkb2MgPSByb29tLmRvY1xuICBsZXQgc2VuZFJlcGx5ID0gZmFsc2VcbiAgc3dpdGNoIChtZXNzYWdlVHlwZSkge1xuICAgIGNhc2UgbWVzc2FnZVN5bmM6IHtcbiAgICAgIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyLCBtZXNzYWdlU3luYylcbiAgICAgIGNvbnN0IHN5bmNNZXNzYWdlVHlwZSA9IHN5bmNQcm90b2NvbC5yZWFkU3luY01lc3NhZ2UoZGVjb2RlciwgZW5jb2RlciwgZG9jLCByb29tKVxuICAgICAgaWYgKHN5bmNNZXNzYWdlVHlwZSA9PT0gc3luY1Byb3RvY29sLm1lc3NhZ2VZanNTeW5jU3RlcDIgJiYgIXJvb20uc3luY2VkKSB7XG4gICAgICAgIHN5bmNlZENhbGxiYWNrKClcbiAgICAgIH1cbiAgICAgIGlmIChzeW5jTWVzc2FnZVR5cGUgPT09IHN5bmNQcm90b2NvbC5tZXNzYWdlWWpzU3luY1N0ZXAxKSB7XG4gICAgICAgIHNlbmRSZXBseSA9IHRydWVcbiAgICAgIH1cbiAgICAgIGJyZWFrXG4gICAgfVxuICAgIGNhc2UgbWVzc2FnZVF1ZXJ5QXdhcmVuZXNzOlxuICAgICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIsIG1lc3NhZ2VBd2FyZW5lc3MpXG4gICAgICBlbmNvZGluZy53cml0ZVZhclVpbnQ4QXJyYXkoZW5jb2RlciwgYXdhcmVuZXNzUHJvdG9jb2wuZW5jb2RlQXdhcmVuZXNzVXBkYXRlKGF3YXJlbmVzcywgQXJyYXkuZnJvbShhd2FyZW5lc3MuZ2V0U3RhdGVzKCkua2V5cygpKSkpXG4gICAgICBzZW5kUmVwbHkgPSB0cnVlXG4gICAgICBicmVha1xuICAgIGNhc2UgbWVzc2FnZUF3YXJlbmVzczpcbiAgICAgIGF3YXJlbmVzc1Byb3RvY29sLmFwcGx5QXdhcmVuZXNzVXBkYXRlKGF3YXJlbmVzcywgZGVjb2RpbmcucmVhZFZhclVpbnQ4QXJyYXkoZGVjb2RlciksIHJvb20pXG4gICAgICBicmVha1xuICAgIGNhc2UgbWVzc2FnZUJjUGVlcklkOiB7XG4gICAgICBjb25zdCBhZGQgPSBkZWNvZGluZy5yZWFkVWludDgoZGVjb2RlcikgPT09IDFcbiAgICAgIGNvbnN0IHBlZXJOYW1lID0gZGVjb2RpbmcucmVhZFZhclN0cmluZyhkZWNvZGVyKVxuICAgICAgaWYgKHBlZXJOYW1lICE9PSByb29tLnBlZXJJZCAmJiAoKHJvb20uYmNDb25ucy5oYXMocGVlck5hbWUpICYmICFhZGQpIHx8ICghcm9vbS5iY0Nvbm5zLmhhcyhwZWVyTmFtZSkgJiYgYWRkKSkpIHtcbiAgICAgICAgY29uc3QgcmVtb3ZlZCA9IFtdXG4gICAgICAgIGNvbnN0IGFkZGVkID0gW11cbiAgICAgICAgaWYgKGFkZCkge1xuICAgICAgICAgIHJvb20uYmNDb25ucy5hZGQocGVlck5hbWUpXG4gICAgICAgICAgYWRkZWQucHVzaChwZWVyTmFtZSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByb29tLmJjQ29ubnMuZGVsZXRlKHBlZXJOYW1lKVxuICAgICAgICAgIHJlbW92ZWQucHVzaChwZWVyTmFtZSlcbiAgICAgICAgfVxuICAgICAgICByb29tLnByb3ZpZGVyLmVtaXQoJ3BlZXJzJywgW3tcbiAgICAgICAgICBhZGRlZCxcbiAgICAgICAgICByZW1vdmVkLFxuICAgICAgICAgIHdlYnJ0Y1BlZXJzOiBBcnJheS5mcm9tKHJvb20ud2VicnRjQ29ubnMua2V5cygpKSxcbiAgICAgICAgICBiY1BlZXJzOiBBcnJheS5mcm9tKHJvb20uYmNDb25ucylcbiAgICAgICAgfV0pXG4gICAgICAgIGJyb2FkY2FzdEJjUGVlcklkKHJvb20pXG4gICAgICB9XG4gICAgICBicmVha1xuICAgIH1cbiAgICBkZWZhdWx0OlxuICAgICAgY29uc29sZS5lcnJvcignVW5hYmxlIHRvIGNvbXB1dGUgbWVzc2FnZScpXG4gICAgICByZXR1cm4gZW5jb2RlclxuICB9XG4gIGlmICghc2VuZFJlcGx5KSB7XG4gICAgLy8gbm90aGluZyBoYXMgYmVlbiB3cml0dGVuLCBubyBhbnN3ZXIgY3JlYXRlZFxuICAgIHJldHVybiBudWxsXG4gIH1cbiAgcmV0dXJuIGVuY29kZXJcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1dlYnJ0Y0Nvbm59IHBlZXJDb25uXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZlxuICogQHJldHVybiB7ZW5jb2RpbmcuRW5jb2Rlcj99XG4gKi9cbmNvbnN0IHJlYWRQZWVyTWVzc2FnZSA9IChwZWVyQ29ubiwgYnVmKSA9PiB7XG4gIGNvbnN0IHJvb20gPSBwZWVyQ29ubi5yb29tXG4gIGxvZygncmVjZWl2ZWQgbWVzc2FnZSBmcm9tICcsIGxvZ2dpbmcuQk9MRCwgcGVlckNvbm4ucmVtb3RlUGVlcklkLCBsb2dnaW5nLkdSRVksICcgKCcsIHJvb20ubmFtZSwgJyknLCBsb2dnaW5nLlVOQk9MRCwgbG9nZ2luZy5VTkNPTE9SKVxuICByZXR1cm4gcmVhZE1lc3NhZ2Uocm9vbSwgYnVmLCAoKSA9PiB7XG4gICAgcGVlckNvbm4uc3luY2VkID0gdHJ1ZVxuICAgIGxvZygnc3luY2VkICcsIGxvZ2dpbmcuQk9MRCwgcm9vbS5uYW1lLCBsb2dnaW5nLlVOQk9MRCwgJyB3aXRoICcsIGxvZ2dpbmcuQk9MRCwgcGVlckNvbm4ucmVtb3RlUGVlcklkKVxuICAgIGNoZWNrSXNTeW5jZWQocm9vbSlcbiAgfSlcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1dlYnJ0Y0Nvbm59IHdlYnJ0Y0Nvbm5cbiAqIEBwYXJhbSB7ZW5jb2RpbmcuRW5jb2Rlcn0gZW5jb2RlclxuICovXG5jb25zdCBzZW5kV2VicnRjQ29ubiA9ICh3ZWJydGNDb25uLCBlbmNvZGVyKSA9PiB7XG4gIGxvZygnc2VuZCBtZXNzYWdlIHRvICcsIGxvZ2dpbmcuQk9MRCwgd2VicnRjQ29ubi5yZW1vdGVQZWVySWQsIGxvZ2dpbmcuVU5CT0xELCBsb2dnaW5nLkdSRVksICcgKCcsIHdlYnJ0Y0Nvbm4ucm9vbS5uYW1lLCAnKScsIGxvZ2dpbmcuVU5DT0xPUilcbiAgdHJ5IHtcbiAgICB3ZWJydGNDb25uLnBlZXIuc2VuZChlbmNvZGluZy50b1VpbnQ4QXJyYXkoZW5jb2RlcikpXG4gIH0gY2F0Y2ggKGUpIHt9XG59XG5cbi8qKlxuICogQHBhcmFtIHtSb29tfSByb29tXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IG1cbiAqL1xuY29uc3QgYnJvYWRjYXN0V2VicnRjQ29ubiA9IChyb29tLCBtKSA9PiB7XG4gIGxvZygnYnJvYWRjYXN0IG1lc3NhZ2UgaW4gJywgbG9nZ2luZy5CT0xELCByb29tLm5hbWUsIGxvZ2dpbmcuVU5CT0xEKVxuICByb29tLndlYnJ0Y0Nvbm5zLmZvckVhY2goY29ubiA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbm4ucGVlci5zZW5kKG0pXG4gICAgfSBjYXRjaCAoZSkge31cbiAgfSlcbn1cblxuZXhwb3J0IGNsYXNzIFdlYnJ0Y0Nvbm4ge1xuICAvKipcbiAgICogQHBhcmFtIHtTaWduYWxpbmdDb25ufSBzaWduYWxpbmdDb25uXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5pdGlhdG9yXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZW1vdGVQZWVySWRcbiAgICogQHBhcmFtIHtSb29tfSByb29tXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoc2lnbmFsaW5nQ29ubiwgaW5pdGlhdG9yLCByZW1vdGVQZWVySWQsIHJvb20pIHtcbiAgICBsb2coJ2VzdGFibGlzaGluZyBjb25uZWN0aW9uIHRvICcsIGxvZ2dpbmcuQk9MRCwgcmVtb3RlUGVlcklkKVxuICAgIHRoaXMucm9vbSA9IHJvb21cbiAgICB0aGlzLnJlbW90ZVBlZXJJZCA9IHJlbW90ZVBlZXJJZFxuICAgIHRoaXMuZ2xhcmVUb2tlbiA9IHVuZGVmaW5lZFxuICAgIHRoaXMuY2xvc2VkID0gZmFsc2VcbiAgICB0aGlzLmNvbm5lY3RlZCA9IGZhbHNlXG4gICAgdGhpcy5zeW5jZWQgPSBmYWxzZVxuICAgIC8qKlxuICAgICAqIEB0eXBlIHthbnl9XG4gICAgICovXG4gICAgdGhpcy5wZWVyID0gbmV3IFBlZXIoeyBpbml0aWF0b3IsIC4uLnJvb20ucHJvdmlkZXIucGVlck9wdHMgfSlcbiAgICB0aGlzLnBlZXIub24oJ3NpZ25hbCcsIHNpZ25hbCA9PiB7XG4gICAgICBpZiAodGhpcy5nbGFyZVRva2VuID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gYWRkIHNvbWUgcmFuZG9tbmVzcyB0byB0aGUgdGltZXN0YW1wIG9mIHRoZSBvZmZlclxuICAgICAgICB0aGlzLmdsYXJlVG9rZW4gPSBEYXRlLm5vdygpICsgTWF0aC5yYW5kb20oKVxuICAgICAgfVxuICAgICAgcHVibGlzaFNpZ25hbGluZ01lc3NhZ2Uoc2lnbmFsaW5nQ29ubiwgcm9vbSwgeyB0bzogcmVtb3RlUGVlcklkLCBmcm9tOiByb29tLnBlZXJJZCwgdHlwZTogJ3NpZ25hbCcsIHRva2VuOiB0aGlzLmdsYXJlVG9rZW4sIHNpZ25hbCB9KVxuICAgIH0pXG4gICAgdGhpcy5wZWVyLm9uKCdjb25uZWN0JywgKCkgPT4ge1xuICAgICAgbG9nKCdjb25uZWN0ZWQgdG8gJywgbG9nZ2luZy5CT0xELCByZW1vdGVQZWVySWQpXG4gICAgICB0aGlzLmNvbm5lY3RlZCA9IHRydWVcbiAgICAgIC8vIHNlbmQgc3luYyBzdGVwIDFcbiAgICAgIGNvbnN0IHByb3ZpZGVyID0gcm9vbS5wcm92aWRlclxuICAgICAgY29uc3QgZG9jID0gcHJvdmlkZXIuZG9jXG4gICAgICBjb25zdCBhd2FyZW5lc3MgPSByb29tLmF3YXJlbmVzc1xuICAgICAgY29uc3QgZW5jb2RlciA9IGVuY29kaW5nLmNyZWF0ZUVuY29kZXIoKVxuICAgICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIsIG1lc3NhZ2VTeW5jKVxuICAgICAgc3luY1Byb3RvY29sLndyaXRlU3luY1N0ZXAxKGVuY29kZXIsIGRvYylcbiAgICAgIHNlbmRXZWJydGNDb25uKHRoaXMsIGVuY29kZXIpXG4gICAgICBjb25zdCBhd2FyZW5lc3NTdGF0ZXMgPSBhd2FyZW5lc3MuZ2V0U3RhdGVzKClcbiAgICAgIGlmIChhd2FyZW5lc3NTdGF0ZXMuc2l6ZSA+IDApIHtcbiAgICAgICAgY29uc3QgZW5jb2RlciA9IGVuY29kaW5nLmNyZWF0ZUVuY29kZXIoKVxuICAgICAgICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2RlciwgbWVzc2FnZUF3YXJlbmVzcylcbiAgICAgICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50OEFycmF5KGVuY29kZXIsIGF3YXJlbmVzc1Byb3RvY29sLmVuY29kZUF3YXJlbmVzc1VwZGF0ZShhd2FyZW5lc3MsIEFycmF5LmZyb20oYXdhcmVuZXNzU3RhdGVzLmtleXMoKSkpKVxuICAgICAgICBzZW5kV2VicnRjQ29ubih0aGlzLCBlbmNvZGVyKVxuICAgICAgfVxuICAgIH0pXG4gICAgdGhpcy5wZWVyLm9uKCdjbG9zZScsICgpID0+IHtcbiAgICAgIHRoaXMuY29ubmVjdGVkID0gZmFsc2VcbiAgICAgIHRoaXMuY2xvc2VkID0gdHJ1ZVxuICAgICAgaWYgKHJvb20ud2VicnRjQ29ubnMuaGFzKHRoaXMucmVtb3RlUGVlcklkKSkge1xuICAgICAgICByb29tLndlYnJ0Y0Nvbm5zLmRlbGV0ZSh0aGlzLnJlbW90ZVBlZXJJZClcbiAgICAgICAgcm9vbS5wcm92aWRlci5lbWl0KCdwZWVycycsIFt7XG4gICAgICAgICAgcmVtb3ZlZDogW3RoaXMucmVtb3RlUGVlcklkXSxcbiAgICAgICAgICBhZGRlZDogW10sXG4gICAgICAgICAgd2VicnRjUGVlcnM6IEFycmF5LmZyb20ocm9vbS53ZWJydGNDb25ucy5rZXlzKCkpLFxuICAgICAgICAgIGJjUGVlcnM6IEFycmF5LmZyb20ocm9vbS5iY0Nvbm5zKVxuICAgICAgICB9XSlcbiAgICAgIH1cbiAgICAgIGNoZWNrSXNTeW5jZWQocm9vbSlcbiAgICAgIHRoaXMucGVlci5kZXN0cm95KClcbiAgICAgIGxvZygnY2xvc2VkIGNvbm5lY3Rpb24gdG8gJywgbG9nZ2luZy5CT0xELCByZW1vdGVQZWVySWQpXG4gICAgICBhbm5vdW5jZVNpZ25hbGluZ0luZm8ocm9vbSlcbiAgICB9KVxuICAgIHRoaXMucGVlci5vbignZXJyb3InLCBlcnIgPT4ge1xuICAgICAgbG9nKCdFcnJvciBpbiBjb25uZWN0aW9uIHRvICcsIGxvZ2dpbmcuQk9MRCwgcmVtb3RlUGVlcklkLCAnOiAnLCBlcnIpXG4gICAgICBhbm5vdW5jZVNpZ25hbGluZ0luZm8ocm9vbSlcbiAgICB9KVxuICAgIHRoaXMucGVlci5vbignZGF0YScsIGRhdGEgPT4ge1xuICAgICAgY29uc3QgYW5zd2VyID0gcmVhZFBlZXJNZXNzYWdlKHRoaXMsIGRhdGEpXG4gICAgICBpZiAoYW5zd2VyICE9PSBudWxsKSB7XG4gICAgICAgIHNlbmRXZWJydGNDb25uKHRoaXMsIGFuc3dlcilcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgZGVzdHJveSAoKSB7XG4gICAgdGhpcy5wZWVyLmRlc3Ryb3koKVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtSb29tfSByb29tXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IG1cbiAqL1xuY29uc3QgYnJvYWRjYXN0QmNNZXNzYWdlID0gKHJvb20sIG0pID0+IGNyeXB0b3V0aWxzLmVuY3J5cHQobSwgcm9vbS5rZXkpLnRoZW4oZGF0YSA9PlxuICByb29tLm11eCgoKSA9PlxuICAgIGJjLnB1Ymxpc2gocm9vbS5uYW1lLCBkYXRhKVxuICApXG4pXG5cbi8qKlxuICogQHBhcmFtIHtSb29tfSByb29tXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IG1cbiAqL1xuY29uc3QgYnJvYWRjYXN0Um9vbU1lc3NhZ2UgPSAocm9vbSwgbSkgPT4ge1xuICBpZiAocm9vbS5iY2Nvbm5lY3RlZCkge1xuICAgIGJyb2FkY2FzdEJjTWVzc2FnZShyb29tLCBtKVxuICB9XG4gIGJyb2FkY2FzdFdlYnJ0Y0Nvbm4ocm9vbSwgbSlcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1Jvb219IHJvb21cbiAqL1xuY29uc3QgYW5ub3VuY2VTaWduYWxpbmdJbmZvID0gcm9vbSA9PiB7XG4gIHNpZ25hbGluZ0Nvbm5zLmZvckVhY2goY29ubiA9PiB7XG4gICAgLy8gb25seSBzdWJzY3JpYmUgaWYgY29ubmVjdGlvbiBpcyBlc3RhYmxpc2hlZCwgb3RoZXJ3aXNlIHRoZSBjb25uIGF1dG9tYXRpY2FsbHkgc3Vic2NyaWJlcyB0byBhbGwgcm9vbXNcbiAgICBpZiAoY29ubi5jb25uZWN0ZWQpIHtcbiAgICAgIGNvbm4uc2VuZCh7IHR5cGU6ICdzdWJzY3JpYmUnLCB0b3BpY3M6IFtyb29tLm5hbWVdIH0pXG4gICAgICBpZiAocm9vbS53ZWJydGNDb25ucy5zaXplIDwgcm9vbS5wcm92aWRlci5tYXhDb25ucykge1xuICAgICAgICBwdWJsaXNoU2lnbmFsaW5nTWVzc2FnZShjb25uLCByb29tLCB7IHR5cGU6ICdhbm5vdW5jZScsIGZyb206IHJvb20ucGVlcklkIH0pXG4gICAgICB9XG4gICAgfVxuICB9KVxufVxuXG4vKipcbiAqIEBwYXJhbSB7Um9vbX0gcm9vbVxuICovXG5jb25zdCBicm9hZGNhc3RCY1BlZXJJZCA9IHJvb20gPT4ge1xuICBpZiAocm9vbS5wcm92aWRlci5maWx0ZXJCY0Nvbm5zKSB7XG4gICAgLy8gYnJvYWRjYXN0IHBlZXJJZCB2aWEgYnJvYWRjYXN0Y2hhbm5lbFxuICAgIGNvbnN0IGVuY29kZXJQZWVySWRCYyA9IGVuY29kaW5nLmNyZWF0ZUVuY29kZXIoKVxuICAgIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyUGVlcklkQmMsIG1lc3NhZ2VCY1BlZXJJZClcbiAgICBlbmNvZGluZy53cml0ZVVpbnQ4KGVuY29kZXJQZWVySWRCYywgMSlcbiAgICBlbmNvZGluZy53cml0ZVZhclN0cmluZyhlbmNvZGVyUGVlcklkQmMsIHJvb20ucGVlcklkKVxuICAgIGJyb2FkY2FzdEJjTWVzc2FnZShyb29tLCBlbmNvZGluZy50b1VpbnQ4QXJyYXkoZW5jb2RlclBlZXJJZEJjKSlcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgUm9vbSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1kuRG9jfSBkb2NcbiAgICogQHBhcmFtIHtXZWJydGNQcm92aWRlcn0gcHJvdmlkZXJcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHtDcnlwdG9LZXl8bnVsbH0ga2V5XG4gICAqL1xuICBjb25zdHJ1Y3RvciAoZG9jLCBwcm92aWRlciwgbmFtZSwga2V5KSB7XG4gICAgLyoqXG4gICAgICogRG8gbm90IGFzc3VtZSB0aGF0IHBlZXJJZCBpcyB1bmlxdWUuIFRoaXMgaXMgb25seSBtZWFudCBmb3Igc2VuZGluZyBzaWduYWxpbmcgbWVzc2FnZXMuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMucGVlcklkID0gcmFuZG9tLnV1aWR2NCgpXG4gICAgdGhpcy5kb2MgPSBkb2NcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7YXdhcmVuZXNzUHJvdG9jb2wuQXdhcmVuZXNzfVxuICAgICAqL1xuICAgIHRoaXMuYXdhcmVuZXNzID0gcHJvdmlkZXIuYXdhcmVuZXNzXG4gICAgdGhpcy5wcm92aWRlciA9IHByb3ZpZGVyXG4gICAgdGhpcy5zeW5jZWQgPSBmYWxzZVxuICAgIHRoaXMubmFtZSA9IG5hbWVcbiAgICAvLyBAdG9kbyBtYWtlIGtleSBzZWNyZXQgYnkgc2NvcGluZ1xuICAgIHRoaXMua2V5ID0ga2V5XG4gICAgLyoqXG4gICAgICogQHR5cGUge01hcDxzdHJpbmcsIFdlYnJ0Y0Nvbm4+fVxuICAgICAqL1xuICAgIHRoaXMud2VicnRjQ29ubnMgPSBuZXcgTWFwKClcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7U2V0PHN0cmluZz59XG4gICAgICovXG4gICAgdGhpcy5iY0Nvbm5zID0gbmV3IFNldCgpXG4gICAgdGhpcy5tdXggPSBjcmVhdGVNdXRleCgpXG4gICAgdGhpcy5iY2Nvbm5lY3RlZCA9IGZhbHNlXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gZGF0YVxuICAgICAqL1xuICAgIHRoaXMuX2JjU3Vic2NyaWJlciA9IGRhdGEgPT5cbiAgICAgIGNyeXB0b3V0aWxzLmRlY3J5cHQobmV3IFVpbnQ4QXJyYXkoZGF0YSksIGtleSkudGhlbihtID0+XG4gICAgICAgIHRoaXMubXV4KCgpID0+IHtcbiAgICAgICAgICBjb25zdCByZXBseSA9IHJlYWRNZXNzYWdlKHRoaXMsIG0sICgpID0+IHt9KVxuICAgICAgICAgIGlmIChyZXBseSkge1xuICAgICAgICAgICAgYnJvYWRjYXN0QmNNZXNzYWdlKHRoaXMsIGVuY29kaW5nLnRvVWludDhBcnJheShyZXBseSkpXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgKVxuICAgIC8qKlxuICAgICAqIExpc3RlbnMgdG8gWWpzIHVwZGF0ZXMgYW5kIHNlbmRzIHRoZW0gdG8gcmVtb3RlIHBlZXJzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHVwZGF0ZVxuICAgICAqIEBwYXJhbSB7YW55fSBvcmlnaW5cbiAgICAgKi9cbiAgICB0aGlzLl9kb2NVcGRhdGVIYW5kbGVyID0gKHVwZGF0ZSwgb3JpZ2luKSA9PiB7XG4gICAgICBjb25zdCBlbmNvZGVyID0gZW5jb2RpbmcuY3JlYXRlRW5jb2RlcigpXG4gICAgICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2RlciwgbWVzc2FnZVN5bmMpXG4gICAgICBzeW5jUHJvdG9jb2wud3JpdGVVcGRhdGUoZW5jb2RlciwgdXBkYXRlKVxuICAgICAgYnJvYWRjYXN0Um9vbU1lc3NhZ2UodGhpcywgZW5jb2RpbmcudG9VaW50OEFycmF5KGVuY29kZXIpKVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBMaXN0ZW5zIHRvIEF3YXJlbmVzcyB1cGRhdGVzIGFuZCBzZW5kcyB0aGVtIHRvIHJlbW90ZSBwZWVyc1xuICAgICAqXG4gICAgICogQHBhcmFtIHthbnl9IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge2FueX0gb3JpZ2luXG4gICAgICovXG4gICAgdGhpcy5fYXdhcmVuZXNzVXBkYXRlSGFuZGxlciA9ICh7IGFkZGVkLCB1cGRhdGVkLCByZW1vdmVkIH0sIG9yaWdpbikgPT4ge1xuICAgICAgY29uc3QgY2hhbmdlZENsaWVudHMgPSBhZGRlZC5jb25jYXQodXBkYXRlZCkuY29uY2F0KHJlbW92ZWQpXG4gICAgICBjb25zdCBlbmNvZGVyQXdhcmVuZXNzID0gZW5jb2RpbmcuY3JlYXRlRW5jb2RlcigpXG4gICAgICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2RlckF3YXJlbmVzcywgbWVzc2FnZUF3YXJlbmVzcylcbiAgICAgIGVuY29kaW5nLndyaXRlVmFyVWludDhBcnJheShlbmNvZGVyQXdhcmVuZXNzLCBhd2FyZW5lc3NQcm90b2NvbC5lbmNvZGVBd2FyZW5lc3NVcGRhdGUodGhpcy5hd2FyZW5lc3MsIGNoYW5nZWRDbGllbnRzKSlcbiAgICAgIGJyb2FkY2FzdFJvb21NZXNzYWdlKHRoaXMsIGVuY29kaW5nLnRvVWludDhBcnJheShlbmNvZGVyQXdhcmVuZXNzKSlcbiAgICB9XG5cbiAgICB0aGlzLl9iZWZvcmVVbmxvYWRIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgYXdhcmVuZXNzUHJvdG9jb2wucmVtb3ZlQXdhcmVuZXNzU3RhdGVzKHRoaXMuYXdhcmVuZXNzLCBbZG9jLmNsaWVudElEXSwgJ3dpbmRvdyB1bmxvYWQnKVxuICAgICAgcm9vbXMuZm9yRWFjaChyb29tID0+IHtcbiAgICAgICAgcm9vbS5kaXNjb25uZWN0KClcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignYmVmb3JldW5sb2FkJywgdGhpcy5fYmVmb3JlVW5sb2FkSGFuZGxlcilcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcHJvY2Vzcy5vbignZXhpdCcsIHRoaXMuX2JlZm9yZVVubG9hZEhhbmRsZXIpXG4gICAgfVxuICB9XG5cbiAgY29ubmVjdCAoKSB7XG4gICAgdGhpcy5kb2Mub24oJ3VwZGF0ZScsIHRoaXMuX2RvY1VwZGF0ZUhhbmRsZXIpXG4gICAgdGhpcy5hd2FyZW5lc3Mub24oJ3VwZGF0ZScsIHRoaXMuX2F3YXJlbmVzc1VwZGF0ZUhhbmRsZXIpXG4gICAgLy8gc2lnbmFsIHRocm91Z2ggYWxsIGF2YWlsYWJsZSBzaWduYWxpbmcgY29ubmVjdGlvbnNcbiAgICBhbm5vdW5jZVNpZ25hbGluZ0luZm8odGhpcylcbiAgICBjb25zdCByb29tTmFtZSA9IHRoaXMubmFtZVxuICAgIGJjLnN1YnNjcmliZShyb29tTmFtZSwgdGhpcy5fYmNTdWJzY3JpYmVyKVxuICAgIHRoaXMuYmNjb25uZWN0ZWQgPSB0cnVlXG4gICAgLy8gYnJvYWRjYXN0IHBlZXJJZCB2aWEgYnJvYWRjYXN0Y2hhbm5lbFxuICAgIGJyb2FkY2FzdEJjUGVlcklkKHRoaXMpXG4gICAgLy8gd3JpdGUgc3luYyBzdGVwIDFcbiAgICBjb25zdCBlbmNvZGVyU3luYyA9IGVuY29kaW5nLmNyZWF0ZUVuY29kZXIoKVxuICAgIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyU3luYywgbWVzc2FnZVN5bmMpXG4gICAgc3luY1Byb3RvY29sLndyaXRlU3luY1N0ZXAxKGVuY29kZXJTeW5jLCB0aGlzLmRvYylcbiAgICBicm9hZGNhc3RCY01lc3NhZ2UodGhpcywgZW5jb2RpbmcudG9VaW50OEFycmF5KGVuY29kZXJTeW5jKSlcbiAgICAvLyBicm9hZGNhc3QgbG9jYWwgc3RhdGVcbiAgICBjb25zdCBlbmNvZGVyU3RhdGUgPSBlbmNvZGluZy5jcmVhdGVFbmNvZGVyKClcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2RlclN0YXRlLCBtZXNzYWdlU3luYylcbiAgICBzeW5jUHJvdG9jb2wud3JpdGVTeW5jU3RlcDIoZW5jb2RlclN0YXRlLCB0aGlzLmRvYylcbiAgICBicm9hZGNhc3RCY01lc3NhZ2UodGhpcywgZW5jb2RpbmcudG9VaW50OEFycmF5KGVuY29kZXJTdGF0ZSkpXG4gICAgLy8gd3JpdGUgcXVlcnlBd2FyZW5lc3NcbiAgICBjb25zdCBlbmNvZGVyQXdhcmVuZXNzUXVlcnkgPSBlbmNvZGluZy5jcmVhdGVFbmNvZGVyKClcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2RlckF3YXJlbmVzc1F1ZXJ5LCBtZXNzYWdlUXVlcnlBd2FyZW5lc3MpXG4gICAgYnJvYWRjYXN0QmNNZXNzYWdlKHRoaXMsIGVuY29kaW5nLnRvVWludDhBcnJheShlbmNvZGVyQXdhcmVuZXNzUXVlcnkpKVxuICAgIC8vIGJyb2FkY2FzdCBsb2NhbCBhd2FyZW5lc3Mgc3RhdGVcbiAgICBjb25zdCBlbmNvZGVyQXdhcmVuZXNzU3RhdGUgPSBlbmNvZGluZy5jcmVhdGVFbmNvZGVyKClcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2RlckF3YXJlbmVzc1N0YXRlLCBtZXNzYWdlQXdhcmVuZXNzKVxuICAgIGVuY29kaW5nLndyaXRlVmFyVWludDhBcnJheShlbmNvZGVyQXdhcmVuZXNzU3RhdGUsIGF3YXJlbmVzc1Byb3RvY29sLmVuY29kZUF3YXJlbmVzc1VwZGF0ZSh0aGlzLmF3YXJlbmVzcywgW3RoaXMuZG9jLmNsaWVudElEXSkpXG4gICAgYnJvYWRjYXN0QmNNZXNzYWdlKHRoaXMsIGVuY29kaW5nLnRvVWludDhBcnJheShlbmNvZGVyQXdhcmVuZXNzU3RhdGUpKVxuICB9XG5cbiAgZGlzY29ubmVjdCAoKSB7XG4gICAgLy8gc2lnbmFsIHRocm91Z2ggYWxsIGF2YWlsYWJsZSBzaWduYWxpbmcgY29ubmVjdGlvbnNcbiAgICBzaWduYWxpbmdDb25ucy5mb3JFYWNoKGNvbm4gPT4ge1xuICAgICAgaWYgKGNvbm4uY29ubmVjdGVkKSB7XG4gICAgICAgIGNvbm4uc2VuZCh7IHR5cGU6ICd1bnN1YnNjcmliZScsIHRvcGljczogW3RoaXMubmFtZV0gfSlcbiAgICAgIH1cbiAgICB9KVxuICAgIGF3YXJlbmVzc1Byb3RvY29sLnJlbW92ZUF3YXJlbmVzc1N0YXRlcyh0aGlzLmF3YXJlbmVzcywgW3RoaXMuZG9jLmNsaWVudElEXSwgJ2Rpc2Nvbm5lY3QnKVxuICAgIC8vIGJyb2FkY2FzdCBwZWVySWQgcmVtb3ZhbCB2aWEgYnJvYWRjYXN0Y2hhbm5lbFxuICAgIGNvbnN0IGVuY29kZXJQZWVySWRCYyA9IGVuY29kaW5nLmNyZWF0ZUVuY29kZXIoKVxuICAgIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyUGVlcklkQmMsIG1lc3NhZ2VCY1BlZXJJZClcbiAgICBlbmNvZGluZy53cml0ZVVpbnQ4KGVuY29kZXJQZWVySWRCYywgMCkgLy8gcmVtb3ZlIHBlZXJJZCBmcm9tIG90aGVyIGJjIHBlZXJzXG4gICAgZW5jb2Rpbmcud3JpdGVWYXJTdHJpbmcoZW5jb2RlclBlZXJJZEJjLCB0aGlzLnBlZXJJZClcbiAgICBicm9hZGNhc3RCY01lc3NhZ2UodGhpcywgZW5jb2RpbmcudG9VaW50OEFycmF5KGVuY29kZXJQZWVySWRCYykpXG5cbiAgICBiYy51bnN1YnNjcmliZSh0aGlzLm5hbWUsIHRoaXMuX2JjU3Vic2NyaWJlcilcbiAgICB0aGlzLmJjY29ubmVjdGVkID0gZmFsc2VcbiAgICB0aGlzLmRvYy5vZmYoJ3VwZGF0ZScsIHRoaXMuX2RvY1VwZGF0ZUhhbmRsZXIpXG4gICAgdGhpcy5hd2FyZW5lc3Mub2ZmKCd1cGRhdGUnLCB0aGlzLl9hd2FyZW5lc3NVcGRhdGVIYW5kbGVyKVxuICAgIHRoaXMud2VicnRjQ29ubnMuZm9yRWFjaChjb25uID0+IGNvbm4uZGVzdHJveSgpKVxuICB9XG5cbiAgZGVzdHJveSAoKSB7XG4gICAgdGhpcy5kaXNjb25uZWN0KClcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdiZWZvcmV1bmxvYWQnLCB0aGlzLl9iZWZvcmVVbmxvYWRIYW5kbGVyKVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBwcm9jZXNzLm9mZignZXhpdCcsIHRoaXMuX2JlZm9yZVVubG9hZEhhbmRsZXIpXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtZLkRvY30gZG9jXG4gKiBAcGFyYW0ge1dlYnJ0Y1Byb3ZpZGVyfSBwcm92aWRlclxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7Q3J5cHRvS2V5fG51bGx9IGtleVxuICogQHJldHVybiB7Um9vbX1cbiAqL1xuY29uc3Qgb3BlblJvb20gPSAoZG9jLCBwcm92aWRlciwgbmFtZSwga2V5KSA9PiB7XG4gIC8vIHRoZXJlIG11c3Qgb25seSBiZSBvbmUgcm9vbVxuICBpZiAocm9vbXMuaGFzKG5hbWUpKSB7XG4gICAgdGhyb3cgZXJyb3IuY3JlYXRlKGBBIFlqcyBEb2MgY29ubmVjdGVkIHRvIHJvb20gXCIke25hbWV9XCIgYWxyZWFkeSBleGlzdHMhYClcbiAgfVxuICBjb25zdCByb29tID0gbmV3IFJvb20oZG9jLCBwcm92aWRlciwgbmFtZSwga2V5KVxuICByb29tcy5zZXQobmFtZSwgLyoqIEB0eXBlIHtSb29tfSAqLyAocm9vbSkpXG4gIHJldHVybiByb29tXG59XG5cbi8qKlxuICogQHBhcmFtIHtTaWduYWxpbmdDb25ufSBjb25uXG4gKiBAcGFyYW0ge1Jvb219IHJvb21cbiAqIEBwYXJhbSB7YW55fSBkYXRhXG4gKi9cbmNvbnN0IHB1Ymxpc2hTaWduYWxpbmdNZXNzYWdlID0gKGNvbm4sIHJvb20sIGRhdGEpID0+IHtcbiAgaWYgKHJvb20ua2V5KSB7XG4gICAgY3J5cHRvdXRpbHMuZW5jcnlwdEpzb24oZGF0YSwgcm9vbS5rZXkpLnRoZW4oZGF0YSA9PiB7XG4gICAgICBjb25uLnNlbmQoeyB0eXBlOiAncHVibGlzaCcsIHRvcGljOiByb29tLm5hbWUsIGRhdGE6IGJ1ZmZlci50b0Jhc2U2NChkYXRhKSB9KVxuICAgIH0pXG4gIH0gZWxzZSB7XG4gICAgY29ubi5zZW5kKHsgdHlwZTogJ3B1Ymxpc2gnLCB0b3BpYzogcm9vbS5uYW1lLCBkYXRhIH0pXG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFNpZ25hbGluZ0Nvbm4gZXh0ZW5kcyB3cy5XZWJzb2NrZXRDbGllbnQge1xuICBjb25zdHJ1Y3RvciAodXJsKSB7XG4gICAgc3VwZXIodXJsKVxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtTZXQ8V2VicnRjUHJvdmlkZXI+fVxuICAgICAqL1xuICAgIHRoaXMucHJvdmlkZXJzID0gbmV3IFNldCgpXG4gICAgdGhpcy5vbignY29ubmVjdCcsICgpID0+IHtcbiAgICAgIGxvZyhgY29ubmVjdGVkICgke3VybH0pYClcbiAgICAgIGNvbnN0IHRvcGljcyA9IEFycmF5LmZyb20ocm9vbXMua2V5cygpKVxuICAgICAgdGhpcy5zZW5kKHsgdHlwZTogJ3N1YnNjcmliZScsIHRvcGljcyB9KVxuICAgICAgcm9vbXMuZm9yRWFjaChyb29tID0+XG4gICAgICAgIHB1Ymxpc2hTaWduYWxpbmdNZXNzYWdlKHRoaXMsIHJvb20sIHsgdHlwZTogJ2Fubm91bmNlJywgZnJvbTogcm9vbS5wZWVySWQgfSlcbiAgICAgIClcbiAgICB9KVxuICAgIHRoaXMub24oJ21lc3NhZ2UnLCBtID0+IHtcbiAgICAgIHN3aXRjaCAobS50eXBlKSB7XG4gICAgICAgIGNhc2UgJ3B1Ymxpc2gnOiB7XG4gICAgICAgICAgY29uc3Qgcm9vbU5hbWUgPSBtLnRvcGljXG4gICAgICAgICAgY29uc3Qgcm9vbSA9IHJvb21zLmdldChyb29tTmFtZSlcbiAgICAgICAgICBpZiAocm9vbSA9PSBudWxsIHx8IHR5cGVvZiByb29tTmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBleGVjTWVzc2FnZSA9IGRhdGEgPT4ge1xuICAgICAgICAgICAgY29uc3Qgd2VicnRjQ29ubnMgPSByb29tLndlYnJ0Y0Nvbm5zXG4gICAgICAgICAgICBjb25zdCBwZWVySWQgPSByb29tLnBlZXJJZFxuICAgICAgICAgICAgaWYgKGRhdGEgPT0gbnVsbCB8fCBkYXRhLmZyb20gPT09IHBlZXJJZCB8fCAoZGF0YS50byAhPT0gdW5kZWZpbmVkICYmIGRhdGEudG8gIT09IHBlZXJJZCkgfHwgcm9vbS5iY0Nvbm5zLmhhcyhkYXRhLmZyb20pKSB7XG4gICAgICAgICAgICAgIC8vIGlnbm9yZSBtZXNzYWdlcyB0aGF0IGFyZSBub3QgYWRkcmVzc2VkIHRvIHRoaXMgY29ubiwgb3IgZnJvbSBjbGllbnRzIHRoYXQgYXJlIGNvbm5lY3RlZCB2aWEgYnJvYWRjYXN0Y2hhbm5lbFxuICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGVtaXRQZWVyQ2hhbmdlID0gd2VicnRjQ29ubnMuaGFzKGRhdGEuZnJvbSlcbiAgICAgICAgICAgICAgPyAoKSA9PiB7fVxuICAgICAgICAgICAgICA6ICgpID0+XG4gICAgICAgICAgICAgICAgcm9vbS5wcm92aWRlci5lbWl0KCdwZWVycycsIFt7XG4gICAgICAgICAgICAgICAgICByZW1vdmVkOiBbXSxcbiAgICAgICAgICAgICAgICAgIGFkZGVkOiBbZGF0YS5mcm9tXSxcbiAgICAgICAgICAgICAgICAgIHdlYnJ0Y1BlZXJzOiBBcnJheS5mcm9tKHJvb20ud2VicnRjQ29ubnMua2V5cygpKSxcbiAgICAgICAgICAgICAgICAgIGJjUGVlcnM6IEFycmF5LmZyb20ocm9vbS5iY0Nvbm5zKVxuICAgICAgICAgICAgICAgIH1dKVxuICAgICAgICAgICAgc3dpdGNoIChkYXRhLnR5cGUpIHtcbiAgICAgICAgICAgICAgY2FzZSAnYW5ub3VuY2UnOlxuICAgICAgICAgICAgICAgIGlmICh3ZWJydGNDb25ucy5zaXplIDwgcm9vbS5wcm92aWRlci5tYXhDb25ucykge1xuICAgICAgICAgICAgICAgICAgbWFwLnNldElmVW5kZWZpbmVkKHdlYnJ0Y0Nvbm5zLCBkYXRhLmZyb20sICgpID0+IG5ldyBXZWJydGNDb25uKHRoaXMsIHRydWUsIGRhdGEuZnJvbSwgcm9vbSkpXG4gICAgICAgICAgICAgICAgICBlbWl0UGVlckNoYW5nZSgpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgIGNhc2UgJ3NpZ25hbCc6XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEuc2lnbmFsLnR5cGUgPT09ICdvZmZlcicpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nQ29ubiA9IHdlYnJ0Y0Nvbm5zLmdldChkYXRhLmZyb20pXG4gICAgICAgICAgICAgICAgICBpZiAoZXhpc3RpbmdDb25uKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlbW90ZVRva2VuID0gZGF0YS50b2tlblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2NhbFRva2VuID0gZXhpc3RpbmdDb25uLmdsYXJlVG9rZW5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGxvY2FsVG9rZW4gJiYgbG9jYWxUb2tlbiA+IHJlbW90ZVRva2VuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgbG9nKCdvZmZlciByZWplY3RlZDogJywgZGF0YS5mcm9tKVxuICAgICAgICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHdlIGRvbid0IHJlamVjdCB0aGUgb2ZmZXIsIHdlIHdpbGwgYmUgYWNjZXB0aW5nIGl0IGFuZCBhbnN3ZXJpbmcgaXRcbiAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmdDb25uLmdsYXJlVG9rZW4gPSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEuc2lnbmFsLnR5cGUgPT09ICdhbnN3ZXInKSB7XG4gICAgICAgICAgICAgICAgICBsb2coJ29mZmVyIGFuc3dlcmVkIGJ5OiAnLCBkYXRhLmZyb20pXG4gICAgICAgICAgICAgICAgICBjb25zdCBleGlzdGluZ0Nvbm4gPSB3ZWJydGNDb25ucy5nZXQoZGF0YS5mcm9tKVxuICAgICAgICAgICAgICAgICAgZXhpc3RpbmdDb25uLmdsYXJlVG9rZW4gPSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEudG8gPT09IHBlZXJJZCkge1xuICAgICAgICAgICAgICAgICAgbWFwLnNldElmVW5kZWZpbmVkKHdlYnJ0Y0Nvbm5zLCBkYXRhLmZyb20sICgpID0+IG5ldyBXZWJydGNDb25uKHRoaXMsIGZhbHNlLCBkYXRhLmZyb20sIHJvb20pKS5wZWVyLnNpZ25hbChkYXRhLnNpZ25hbClcbiAgICAgICAgICAgICAgICAgIGVtaXRQZWVyQ2hhbmdlKClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJvb20ua2V5KSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG0uZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgY3J5cHRvdXRpbHMuZGVjcnlwdEpzb24oYnVmZmVyLmZyb21CYXNlNjQobS5kYXRhKSwgcm9vbS5rZXkpLnRoZW4oZXhlY01lc3NhZ2UpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGV4ZWNNZXNzYWdlKG0uZGF0YSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KVxuICAgIHRoaXMub24oJ2Rpc2Nvbm5lY3QnLCAoKSA9PiBsb2coYGRpc2Nvbm5lY3QgKCR7dXJsfSlgKSlcbiAgfVxufVxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFByb3ZpZGVyT3B0aW9uc1xuICogQHByb3BlcnR5IHtBcnJheTxzdHJpbmc+fSBbc2lnbmFsaW5nXVxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtwYXNzd29yZF1cbiAqIEBwcm9wZXJ0eSB7YXdhcmVuZXNzUHJvdG9jb2wuQXdhcmVuZXNzfSBbYXdhcmVuZXNzXVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttYXhDb25uc11cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2ZpbHRlckJjQ29ubnNdXG4gKiBAcHJvcGVydHkge2FueX0gW3BlZXJPcHRzXVxuICovXG5cbi8qKlxuICogQGV4dGVuZHMgT2JzZXJ2YWJsZTxzdHJpbmc+XG4gKi9cbmV4cG9ydCBjbGFzcyBXZWJydGNQcm92aWRlciBleHRlbmRzIE9ic2VydmFibGUge1xuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJvb21OYW1lXG4gICAqIEBwYXJhbSB7WS5Eb2N9IGRvY1xuICAgKiBAcGFyYW0ge1Byb3ZpZGVyT3B0aW9ucz99IG9wdHNcbiAgICovXG4gIGNvbnN0cnVjdG9yIChcbiAgICByb29tTmFtZSxcbiAgICBkb2MsXG4gICAge1xuICAgICAgc2lnbmFsaW5nID0gWyd3c3M6Ly95LXdlYnJ0Yy1ldS5mbHkuZGV2J10sXG4gICAgICBwYXNzd29yZCA9IG51bGwsXG4gICAgICBhd2FyZW5lc3MgPSBuZXcgYXdhcmVuZXNzUHJvdG9jb2wuQXdhcmVuZXNzKGRvYyksXG4gICAgICBtYXhDb25ucyA9IDIwICsgbWF0aC5mbG9vcihyYW5kb20ucmFuZCgpICogMTUpLCAvLyB0aGUgcmFuZG9tIGZhY3RvciByZWR1Y2VzIHRoZSBjaGFuY2UgdGhhdCBuIGNsaWVudHMgZm9ybSBhIGNsdXN0ZXJcbiAgICAgIGZpbHRlckJjQ29ubnMgPSB0cnVlLFxuICAgICAgcGVlck9wdHMgPSB7fSAvLyBzaW1wbGUtcGVlciBvcHRpb25zLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9zaW1wbGUtcGVlciNwZWVyLS1uZXctcGVlcm9wdHNcbiAgICB9ID0ge31cbiAgKSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMucm9vbU5hbWUgPSByb29tTmFtZVxuICAgIHRoaXMuZG9jID0gZG9jXG4gICAgdGhpcy5maWx0ZXJCY0Nvbm5zID0gZmlsdGVyQmNDb25uc1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHthd2FyZW5lc3NQcm90b2NvbC5Bd2FyZW5lc3N9XG4gICAgICovXG4gICAgdGhpcy5hd2FyZW5lc3MgPSBhd2FyZW5lc3NcbiAgICB0aGlzLnNob3VsZENvbm5lY3QgPSBmYWxzZVxuICAgIHRoaXMuc2lnbmFsaW5nVXJscyA9IHNpZ25hbGluZ1xuICAgIHRoaXMuc2lnbmFsaW5nQ29ubnMgPSBbXVxuICAgIHRoaXMubWF4Q29ubnMgPSBtYXhDb25uc1xuICAgIHRoaXMucGVlck9wdHMgPSBwZWVyT3B0c1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtQcm9taXNlTGlrZTxDcnlwdG9LZXkgfCBudWxsPn1cbiAgICAgKi9cbiAgICB0aGlzLmtleSA9IHBhc3N3b3JkID8gY3J5cHRvdXRpbHMuZGVyaXZlS2V5KHBhc3N3b3JkLCByb29tTmFtZSkgOiAvKiogQHR5cGUge1Byb21pc2VMaWtlPG51bGw+fSAqLyAocHJvbWlzZS5yZXNvbHZlKG51bGwpKVxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtSb29tfG51bGx9XG4gICAgICovXG4gICAgdGhpcy5yb29tID0gbnVsbFxuICAgIHRoaXMua2V5LnRoZW4oa2V5ID0+IHtcbiAgICAgIHRoaXMucm9vbSA9IG9wZW5Sb29tKGRvYywgdGhpcywgcm9vbU5hbWUsIGtleSlcbiAgICAgIGlmICh0aGlzLnNob3VsZENvbm5lY3QpIHtcbiAgICAgICAgdGhpcy5yb29tLmNvbm5lY3QoKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5yb29tLmRpc2Nvbm5lY3QoKVxuICAgICAgfVxuICAgIH0pXG4gICAgdGhpcy5jb25uZWN0KClcbiAgICB0aGlzLmRlc3Ryb3kgPSB0aGlzLmRlc3Ryb3kuYmluZCh0aGlzKVxuICAgIGRvYy5vbignZGVzdHJveScsIHRoaXMuZGVzdHJveSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIGdldCBjb25uZWN0ZWQgKCkge1xuICAgIHJldHVybiB0aGlzLnJvb20gIT09IG51bGwgJiYgdGhpcy5zaG91bGRDb25uZWN0XG4gIH1cblxuICBjb25uZWN0ICgpIHtcbiAgICB0aGlzLnNob3VsZENvbm5lY3QgPSB0cnVlXG4gICAgdGhpcy5zaWduYWxpbmdVcmxzLmZvckVhY2godXJsID0+IHtcbiAgICAgIGNvbnN0IHNpZ25hbGluZ0Nvbm4gPSBtYXAuc2V0SWZVbmRlZmluZWQoc2lnbmFsaW5nQ29ubnMsIHVybCwgKCkgPT4gbmV3IFNpZ25hbGluZ0Nvbm4odXJsKSlcbiAgICAgIHRoaXMuc2lnbmFsaW5nQ29ubnMucHVzaChzaWduYWxpbmdDb25uKVxuICAgICAgc2lnbmFsaW5nQ29ubi5wcm92aWRlcnMuYWRkKHRoaXMpXG4gICAgfSlcbiAgICBpZiAodGhpcy5yb29tKSB7XG4gICAgICB0aGlzLnJvb20uY29ubmVjdCgpXG4gICAgfVxuICB9XG5cbiAgZGlzY29ubmVjdCAoKSB7XG4gICAgdGhpcy5zaG91bGRDb25uZWN0ID0gZmFsc2VcbiAgICB0aGlzLnNpZ25hbGluZ0Nvbm5zLmZvckVhY2goY29ubiA9PiB7XG4gICAgICBjb25uLnByb3ZpZGVycy5kZWxldGUodGhpcylcbiAgICAgIGlmIChjb25uLnByb3ZpZGVycy5zaXplID09PSAwKSB7XG4gICAgICAgIGNvbm4uZGVzdHJveSgpXG4gICAgICAgIHNpZ25hbGluZ0Nvbm5zLmRlbGV0ZShjb25uLnVybClcbiAgICAgIH1cbiAgICB9KVxuICAgIGlmICh0aGlzLnJvb20pIHtcbiAgICAgIHRoaXMucm9vbS5kaXNjb25uZWN0KClcbiAgICB9XG4gIH1cblxuICBkZXN0cm95ICgpIHtcbiAgICB0aGlzLmRvYy5vZmYoJ2Rlc3Ryb3knLCB0aGlzLmRlc3Ryb3kpXG4gICAgLy8gbmVlZCB0byB3YWl0IGZvciBrZXkgYmVmb3JlIGRlbGV0aW5nIHJvb21cbiAgICB0aGlzLmtleS50aGVuKCgpID0+IHtcbiAgICAgIC8qKiBAdHlwZSB7Um9vbX0gKi8gKHRoaXMucm9vbSkuZGVzdHJveSgpXG4gICAgICByb29tcy5kZWxldGUodGhpcy5yb29tTmFtZSlcbiAgICB9KVxuICAgIHN1cGVyLmRlc3Ryb3koKVxuICB9XG59XG4iLCAiLyoqXG4gKiBAbW9kdWxlIHN5bmMtcHJvdG9jb2xcbiAqL1xuXG5pbXBvcnQgKiBhcyBlbmNvZGluZyBmcm9tICdsaWIwL2VuY29kaW5nJ1xuaW1wb3J0ICogYXMgZGVjb2RpbmcgZnJvbSAnbGliMC9kZWNvZGluZydcbmltcG9ydCAqIGFzIFkgZnJvbSAneWpzJ1xuXG4vKipcbiAqIEB0eXBlZGVmIHtNYXA8bnVtYmVyLCBudW1iZXI+fSBTdGF0ZU1hcFxuICovXG5cbi8qKlxuICogQ29yZSBZanMgZGVmaW5lcyB0d28gbWVzc2FnZSB0eXBlczpcbiAqIFx1MjAyMiBZanNTeW5jU3RlcDE6IEluY2x1ZGVzIHRoZSBTdGF0ZSBTZXQgb2YgdGhlIHNlbmRpbmcgY2xpZW50LiBXaGVuIHJlY2VpdmVkLCB0aGUgY2xpZW50IHNob3VsZCByZXBseSB3aXRoIFlqc1N5bmNTdGVwMi5cbiAqIFx1MjAyMiBZanNTeW5jU3RlcDI6IEluY2x1ZGVzIGFsbCBtaXNzaW5nIHN0cnVjdHMgYW5kIHRoZSBjb21wbGV0ZSBkZWxldGUgc2V0LiBXaGVuIHJlY2VpdmVkLCB0aGUgY2xpZW50IGlzIGFzc3VyZWQgdGhhdCBpdFxuICogICByZWNlaXZlZCBhbGwgaW5mb3JtYXRpb24gZnJvbSB0aGUgcmVtb3RlIGNsaWVudC5cbiAqXG4gKiBJbiBhIHBlZXItdG8tcGVlciBuZXR3b3JrLCB5b3UgbWF5IHdhbnQgdG8gaW50cm9kdWNlIGEgU3luY0RvbmUgbWVzc2FnZSB0eXBlLiBCb3RoIHBhcnRpZXMgc2hvdWxkIGluaXRpYXRlIHRoZSBjb25uZWN0aW9uXG4gKiB3aXRoIFN5bmNTdGVwMS4gV2hlbiBhIGNsaWVudCByZWNlaXZlZCBTeW5jU3RlcDIsIGl0IHNob3VsZCByZXBseSB3aXRoIFN5bmNEb25lLiBXaGVuIHRoZSBsb2NhbCBjbGllbnQgcmVjZWl2ZWQgYm90aFxuICogU3luY1N0ZXAyIGFuZCBTeW5jRG9uZSwgaXQgaXMgYXNzdXJlZCB0aGF0IGl0IGlzIHN5bmNlZCB0byB0aGUgcmVtb3RlIGNsaWVudC5cbiAqXG4gKiBJbiBhIGNsaWVudC1zZXJ2ZXIgbW9kZWwsIHlvdSB3YW50IHRvIGhhbmRsZSB0aGlzIGRpZmZlcmVudGx5OiBUaGUgY2xpZW50IHNob3VsZCBpbml0aWF0ZSB0aGUgY29ubmVjdGlvbiB3aXRoIFN5bmNTdGVwMS5cbiAqIFdoZW4gdGhlIHNlcnZlciByZWNlaXZlcyBTeW5jU3RlcDEsIGl0IHNob3VsZCByZXBseSB3aXRoIFN5bmNTdGVwMiBpbW1lZGlhdGVseSBmb2xsb3dlZCBieSBTeW5jU3RlcDEuIFRoZSBjbGllbnQgcmVwbGllc1xuICogd2l0aCBTeW5jU3RlcDIgd2hlbiBpdCByZWNlaXZlcyBTeW5jU3RlcDEuIE9wdGlvbmFsbHkgdGhlIHNlcnZlciBtYXkgc2VuZCBhIFN5bmNEb25lIGFmdGVyIGl0IHJlY2VpdmVkIFN5bmNTdGVwMiwgc28gdGhlXG4gKiBjbGllbnQga25vd3MgdGhhdCB0aGUgc3luYyBpcyBmaW5pc2hlZC4gIFRoZXJlIGFyZSB0d28gcmVhc29ucyBmb3IgdGhpcyBtb3JlIGVsYWJvcmF0ZWQgc3luYyBtb2RlbDogMS4gVGhpcyBwcm90b2NvbCBjYW5cbiAqIGVhc2lseSBiZSBpbXBsZW1lbnRlZCBvbiB0b3Agb2YgaHR0cCBhbmQgd2Vic29ja2V0cy4gMi4gVGhlIHNlcnZlciBzaG91bGQgb25seSByZXBseSB0byByZXF1ZXN0cywgYW5kIG5vdCBpbml0aWF0ZSB0aGVtLlxuICogVGhlcmVmb3JlIGl0IGlzIG5lY2Vzc2FyeSB0aGF0IHRoZSBjbGllbnQgaW5pdGlhdGVzIHRoZSBzeW5jLlxuICpcbiAqIENvbnN0cnVjdGlvbiBvZiBhIG1lc3NhZ2U6XG4gKiBbbWVzc2FnZVR5cGUgOiB2YXJVaW50LCBtZXNzYWdlIGRlZmluaXRpb24uLl1cbiAqXG4gKiBOb3RlOiBBIG1lc3NhZ2UgZG9lcyBub3QgaW5jbHVkZSBpbmZvcm1hdGlvbiBhYm91dCB0aGUgcm9vbSBuYW1lLiBUaGlzIG11c3QgdG8gYmUgaGFuZGxlZCBieSB0aGUgdXBwZXIgbGF5ZXIgcHJvdG9jb2whXG4gKlxuICogc3RyaW5naWZ5W21lc3NhZ2VUeXBlXSBzdHJpbmdpZmllcyBhIG1lc3NhZ2UgZGVmaW5pdGlvbiAobWVzc2FnZVR5cGUgaXMgYWxyZWFkeSByZWFkIGZyb20gdGhlIGJ1ZmZmZXIpXG4gKi9cblxuZXhwb3J0IGNvbnN0IG1lc3NhZ2VZanNTeW5jU3RlcDEgPSAwXG5leHBvcnQgY29uc3QgbWVzc2FnZVlqc1N5bmNTdGVwMiA9IDFcbmV4cG9ydCBjb25zdCBtZXNzYWdlWWpzVXBkYXRlID0gMlxuXG4vKipcbiAqIENyZWF0ZSBhIHN5bmMgc3RlcCAxIG1lc3NhZ2UgYmFzZWQgb24gdGhlIHN0YXRlIG9mIHRoZSBjdXJyZW50IHNoYXJlZCBkb2N1bWVudC5cbiAqXG4gKiBAcGFyYW0ge2VuY29kaW5nLkVuY29kZXJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7WS5Eb2N9IGRvY1xuICovXG5leHBvcnQgY29uc3Qgd3JpdGVTeW5jU3RlcDEgPSAoZW5jb2RlciwgZG9jKSA9PiB7XG4gIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyLCBtZXNzYWdlWWpzU3luY1N0ZXAxKVxuICBjb25zdCBzdiA9IFkuZW5jb2RlU3RhdGVWZWN0b3IoZG9jKVxuICBlbmNvZGluZy53cml0ZVZhclVpbnQ4QXJyYXkoZW5jb2Rlciwgc3YpXG59XG5cbi8qKlxuICogQHBhcmFtIHtlbmNvZGluZy5FbmNvZGVyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge1kuRG9jfSBkb2NcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gW2VuY29kZWRTdGF0ZVZlY3Rvcl1cbiAqL1xuZXhwb3J0IGNvbnN0IHdyaXRlU3luY1N0ZXAyID0gKGVuY29kZXIsIGRvYywgZW5jb2RlZFN0YXRlVmVjdG9yKSA9PiB7XG4gIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyLCBtZXNzYWdlWWpzU3luY1N0ZXAyKVxuICBlbmNvZGluZy53cml0ZVZhclVpbnQ4QXJyYXkoZW5jb2RlciwgWS5lbmNvZGVTdGF0ZUFzVXBkYXRlKGRvYywgZW5jb2RlZFN0YXRlVmVjdG9yKSlcbn1cblxuLyoqXG4gKiBSZWFkIFN5bmNTdGVwMSBtZXNzYWdlIGFuZCByZXBseSB3aXRoIFN5bmNTdGVwMi5cbiAqXG4gKiBAcGFyYW0ge2RlY29kaW5nLkRlY29kZXJ9IGRlY29kZXIgVGhlIHJlcGx5IHRvIHRoZSByZWNlaXZlZCBtZXNzYWdlXG4gKiBAcGFyYW0ge2VuY29kaW5nLkVuY29kZXJ9IGVuY29kZXIgVGhlIHJlY2VpdmVkIG1lc3NhZ2VcbiAqIEBwYXJhbSB7WS5Eb2N9IGRvY1xuICovXG5leHBvcnQgY29uc3QgcmVhZFN5bmNTdGVwMSA9IChkZWNvZGVyLCBlbmNvZGVyLCBkb2MpID0+XG4gIHdyaXRlU3luY1N0ZXAyKGVuY29kZXIsIGRvYywgZGVjb2RpbmcucmVhZFZhclVpbnQ4QXJyYXkoZGVjb2RlcikpXG5cbi8qKlxuICogUmVhZCBhbmQgYXBwbHkgU3RydWN0cyBhbmQgdGhlbiBEZWxldGVTdG9yZSB0byBhIHkgaW5zdGFuY2UuXG4gKlxuICogQHBhcmFtIHtkZWNvZGluZy5EZWNvZGVyfSBkZWNvZGVyXG4gKiBAcGFyYW0ge1kuRG9jfSBkb2NcbiAqIEBwYXJhbSB7YW55fSB0cmFuc2FjdGlvbk9yaWdpblxuICovXG5leHBvcnQgY29uc3QgcmVhZFN5bmNTdGVwMiA9IChkZWNvZGVyLCBkb2MsIHRyYW5zYWN0aW9uT3JpZ2luKSA9PiB7XG4gIHRyeSB7XG4gICAgWS5hcHBseVVwZGF0ZShkb2MsIGRlY29kaW5nLnJlYWRWYXJVaW50OEFycmF5KGRlY29kZXIpLCB0cmFuc2FjdGlvbk9yaWdpbilcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAvLyBUaGlzIGNhdGNoZXMgZXJyb3JzIHRoYXQgYXJlIHRocm93biBieSBldmVudCBoYW5kbGVyc1xuICAgIGNvbnNvbGUuZXJyb3IoJ0NhdWdodCBlcnJvciB3aGlsZSBoYW5kbGluZyBhIFlqcyB1cGRhdGUnLCBlcnJvcilcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7ZW5jb2RpbmcuRW5jb2Rlcn0gZW5jb2RlclxuICogQHBhcmFtIHtVaW50OEFycmF5fSB1cGRhdGVcbiAqL1xuZXhwb3J0IGNvbnN0IHdyaXRlVXBkYXRlID0gKGVuY29kZXIsIHVwZGF0ZSkgPT4ge1xuICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2RlciwgbWVzc2FnZVlqc1VwZGF0ZSlcbiAgZW5jb2Rpbmcud3JpdGVWYXJVaW50OEFycmF5KGVuY29kZXIsIHVwZGF0ZSlcbn1cblxuLyoqXG4gKiBSZWFkIGFuZCBhcHBseSBTdHJ1Y3RzIGFuZCB0aGVuIERlbGV0ZVN0b3JlIHRvIGEgeSBpbnN0YW5jZS5cbiAqXG4gKiBAcGFyYW0ge2RlY29kaW5nLkRlY29kZXJ9IGRlY29kZXJcbiAqIEBwYXJhbSB7WS5Eb2N9IGRvY1xuICogQHBhcmFtIHthbnl9IHRyYW5zYWN0aW9uT3JpZ2luXG4gKi9cbmV4cG9ydCBjb25zdCByZWFkVXBkYXRlID0gcmVhZFN5bmNTdGVwMlxuXG4vKipcbiAqIEBwYXJhbSB7ZGVjb2RpbmcuRGVjb2Rlcn0gZGVjb2RlciBBIG1lc3NhZ2UgcmVjZWl2ZWQgZnJvbSBhbm90aGVyIGNsaWVudFxuICogQHBhcmFtIHtlbmNvZGluZy5FbmNvZGVyfSBlbmNvZGVyIFRoZSByZXBseSBtZXNzYWdlLiBEb2VzIG5vdCBuZWVkIHRvIGJlIHNlbnQgaWYgZW1wdHkuXG4gKiBAcGFyYW0ge1kuRG9jfSBkb2NcbiAqIEBwYXJhbSB7YW55fSB0cmFuc2FjdGlvbk9yaWdpblxuICovXG5leHBvcnQgY29uc3QgcmVhZFN5bmNNZXNzYWdlID0gKGRlY29kZXIsIGVuY29kZXIsIGRvYywgdHJhbnNhY3Rpb25PcmlnaW4pID0+IHtcbiAgY29uc3QgbWVzc2FnZVR5cGUgPSBkZWNvZGluZy5yZWFkVmFyVWludChkZWNvZGVyKVxuICBzd2l0Y2ggKG1lc3NhZ2VUeXBlKSB7XG4gICAgY2FzZSBtZXNzYWdlWWpzU3luY1N0ZXAxOlxuICAgICAgcmVhZFN5bmNTdGVwMShkZWNvZGVyLCBlbmNvZGVyLCBkb2MpXG4gICAgICBicmVha1xuICAgIGNhc2UgbWVzc2FnZVlqc1N5bmNTdGVwMjpcbiAgICAgIHJlYWRTeW5jU3RlcDIoZGVjb2RlciwgZG9jLCB0cmFuc2FjdGlvbk9yaWdpbilcbiAgICAgIGJyZWFrXG4gICAgY2FzZSBtZXNzYWdlWWpzVXBkYXRlOlxuICAgICAgcmVhZFVwZGF0ZShkZWNvZGVyLCBkb2MsIHRyYW5zYWN0aW9uT3JpZ2luKVxuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIG1lc3NhZ2UgdHlwZScpXG4gIH1cbiAgcmV0dXJuIG1lc3NhZ2VUeXBlXG59XG4iLCAiLyoqXG4gKiBAbW9kdWxlIGF3YXJlbmVzcy1wcm90b2NvbFxuICovXG5cbmltcG9ydCAqIGFzIGVuY29kaW5nIGZyb20gJ2xpYjAvZW5jb2RpbmcnXG5pbXBvcnQgKiBhcyBkZWNvZGluZyBmcm9tICdsaWIwL2RlY29kaW5nJ1xuaW1wb3J0ICogYXMgdGltZSBmcm9tICdsaWIwL3RpbWUnXG5pbXBvcnQgKiBhcyBtYXRoIGZyb20gJ2xpYjAvbWF0aCdcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdsaWIwL29ic2VydmFibGUnXG5pbXBvcnQgKiBhcyBmIGZyb20gJ2xpYjAvZnVuY3Rpb24nXG5pbXBvcnQgKiBhcyBZIGZyb20gJ3lqcycgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG5leHBvcnQgY29uc3Qgb3V0ZGF0ZWRUaW1lb3V0ID0gMzAwMDBcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBNZXRhQ2xpZW50U3RhdGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBNZXRhQ2xpZW50U3RhdGUuY2xvY2tcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBNZXRhQ2xpZW50U3RhdGUubGFzdFVwZGF0ZWQgdW5peCB0aW1lc3RhbXBcbiAqL1xuXG4vKipcbiAqIFRoZSBBd2FyZW5lc3MgY2xhc3MgaW1wbGVtZW50cyBhIHNpbXBsZSBzaGFyZWQgc3RhdGUgcHJvdG9jb2wgdGhhdCBjYW4gYmUgdXNlZCBmb3Igbm9uLXBlcnNpc3RlbnQgZGF0YSBsaWtlIGF3YXJlbmVzcyBpbmZvcm1hdGlvblxuICogKGN1cnNvciwgdXNlcm5hbWUsIHN0YXR1cywgLi4pLiBFYWNoIGNsaWVudCBjYW4gdXBkYXRlIGl0cyBvd24gbG9jYWwgc3RhdGUgYW5kIGxpc3RlbiB0byBzdGF0ZSBjaGFuZ2VzIG9mXG4gKiByZW1vdGUgY2xpZW50cy4gRXZlcnkgY2xpZW50IG1heSBzZXQgYSBzdGF0ZSBvZiBhIHJlbW90ZSBwZWVyIHRvIGBudWxsYCB0byBtYXJrIHRoZSBjbGllbnQgYXMgb2ZmbGluZS5cbiAqXG4gKiBFYWNoIGNsaWVudCBpcyBpZGVudGlmaWVkIGJ5IGEgdW5pcXVlIGNsaWVudCBpZCAoc29tZXRoaW5nIHdlIGJvcnJvdyBmcm9tIGBkb2MuY2xpZW50SURgKS4gQSBjbGllbnQgY2FuIG92ZXJyaWRlXG4gKiBpdHMgb3duIHN0YXRlIGJ5IHByb3BhZ2F0aW5nIGEgbWVzc2FnZSB3aXRoIGFuIGluY3JlYXNpbmcgdGltZXN0YW1wIChgY2xvY2tgKS4gSWYgc3VjaCBhIG1lc3NhZ2UgaXMgcmVjZWl2ZWQsIGl0IGlzXG4gKiBhcHBsaWVkIGlmIHRoZSBrbm93biBzdGF0ZSBvZiB0aGF0IGNsaWVudCBpcyBvbGRlciB0aGFuIHRoZSBuZXcgc3RhdGUgKGBjbG9jayA8IG5ld0Nsb2NrYCkuIElmIGEgY2xpZW50IHRoaW5rcyB0aGF0XG4gKiBhIHJlbW90ZSBjbGllbnQgaXMgb2ZmbGluZSwgaXQgbWF5IHByb3BhZ2F0ZSBhIG1lc3NhZ2Ugd2l0aFxuICogYHsgY2xvY2s6IGN1cnJlbnRDbGllbnRDbG9jaywgc3RhdGU6IG51bGwsIGNsaWVudDogcmVtb3RlQ2xpZW50IH1gLiBJZiBzdWNoIGFcbiAqIG1lc3NhZ2UgaXMgcmVjZWl2ZWQsIGFuZCB0aGUga25vd24gY2xvY2sgb2YgdGhhdCBjbGllbnQgZXF1YWxzIHRoZSByZWNlaXZlZCBjbG9jaywgaXQgd2lsbCBvdmVycmlkZSB0aGUgc3RhdGUgd2l0aCBgbnVsbGAuXG4gKlxuICogQmVmb3JlIGEgY2xpZW50IGRpc2Nvbm5lY3RzLCBpdCBzaG91bGQgcHJvcGFnYXRlIGEgYG51bGxgIHN0YXRlIHdpdGggYW4gdXBkYXRlZCBjbG9jay5cbiAqXG4gKiBBd2FyZW5lc3Mgc3RhdGVzIG11c3QgYmUgdXBkYXRlZCBldmVyeSAzMCBzZWNvbmRzLiBPdGhlcndpc2UgdGhlIEF3YXJlbmVzcyBpbnN0YW5jZSB3aWxsIGRlbGV0ZSB0aGUgY2xpZW50IHN0YXRlLlxuICpcbiAqIEBleHRlbmRzIHtPYnNlcnZhYmxlPHN0cmluZz59XG4gKi9cbmV4cG9ydCBjbGFzcyBBd2FyZW5lc3MgZXh0ZW5kcyBPYnNlcnZhYmxlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7WS5Eb2N9IGRvY1xuICAgKi9cbiAgY29uc3RydWN0b3IgKGRvYykge1xuICAgIHN1cGVyKClcbiAgICB0aGlzLmRvYyA9IGRvY1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5jbGllbnRJRCA9IGRvYy5jbGllbnRJRFxuICAgIC8qKlxuICAgICAqIE1hcHMgZnJvbSBjbGllbnQgaWQgdG8gY2xpZW50IHN0YXRlXG4gICAgICogQHR5cGUge01hcDxudW1iZXIsIE9iamVjdDxzdHJpbmcsIGFueT4+fVxuICAgICAqL1xuICAgIHRoaXMuc3RhdGVzID0gbmV3IE1hcCgpXG4gICAgLyoqXG4gICAgICogQHR5cGUge01hcDxudW1iZXIsIE1ldGFDbGllbnRTdGF0ZT59XG4gICAgICovXG4gICAgdGhpcy5tZXRhID0gbmV3IE1hcCgpXG4gICAgdGhpcy5fY2hlY2tJbnRlcnZhbCA9IC8qKiBAdHlwZSB7YW55fSAqLyAoc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgY29uc3Qgbm93ID0gdGltZS5nZXRVbml4VGltZSgpXG4gICAgICBpZiAodGhpcy5nZXRMb2NhbFN0YXRlKCkgIT09IG51bGwgJiYgKG91dGRhdGVkVGltZW91dCAvIDIgPD0gbm93IC0gLyoqIEB0eXBlIHt7bGFzdFVwZGF0ZWQ6bnVtYmVyfX0gKi8gKHRoaXMubWV0YS5nZXQodGhpcy5jbGllbnRJRCkpLmxhc3RVcGRhdGVkKSkge1xuICAgICAgICAvLyByZW5ldyBsb2NhbCBjbG9ja1xuICAgICAgICB0aGlzLnNldExvY2FsU3RhdGUodGhpcy5nZXRMb2NhbFN0YXRlKCkpXG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIEB0eXBlIHtBcnJheTxudW1iZXI+fVxuICAgICAgICovXG4gICAgICBjb25zdCByZW1vdmUgPSBbXVxuICAgICAgdGhpcy5tZXRhLmZvckVhY2goKG1ldGEsIGNsaWVudGlkKSA9PiB7XG4gICAgICAgIGlmIChjbGllbnRpZCAhPT0gdGhpcy5jbGllbnRJRCAmJiBvdXRkYXRlZFRpbWVvdXQgPD0gbm93IC0gbWV0YS5sYXN0VXBkYXRlZCAmJiB0aGlzLnN0YXRlcy5oYXMoY2xpZW50aWQpKSB7XG4gICAgICAgICAgcmVtb3ZlLnB1c2goY2xpZW50aWQpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICBpZiAocmVtb3ZlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmVtb3ZlQXdhcmVuZXNzU3RhdGVzKHRoaXMsIHJlbW92ZSwgJ3RpbWVvdXQnKVxuICAgICAgfVxuICAgIH0sIG1hdGguZmxvb3Iob3V0ZGF0ZWRUaW1lb3V0IC8gMTApKSlcbiAgICBkb2Mub24oJ2Rlc3Ryb3knLCAoKSA9PiB7XG4gICAgICB0aGlzLmRlc3Ryb3koKVxuICAgIH0pXG4gICAgdGhpcy5zZXRMb2NhbFN0YXRlKHt9KVxuICB9XG5cbiAgZGVzdHJveSAoKSB7XG4gICAgdGhpcy5lbWl0KCdkZXN0cm95JywgW3RoaXNdKVxuICAgIHRoaXMuc2V0TG9jYWxTdGF0ZShudWxsKVxuICAgIHN1cGVyLmRlc3Ryb3koKVxuICAgIGNsZWFySW50ZXJ2YWwodGhpcy5fY2hlY2tJbnRlcnZhbClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtPYmplY3Q8c3RyaW5nLGFueT58bnVsbH1cbiAgICovXG4gIGdldExvY2FsU3RhdGUgKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlcy5nZXQodGhpcy5jbGllbnRJRCkgfHwgbnVsbFxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZyxhbnk+fG51bGx9IHN0YXRlXG4gICAqL1xuICBzZXRMb2NhbFN0YXRlIChzdGF0ZSkge1xuICAgIGNvbnN0IGNsaWVudElEID0gdGhpcy5jbGllbnRJRFxuICAgIGNvbnN0IGN1cnJMb2NhbE1ldGEgPSB0aGlzLm1ldGEuZ2V0KGNsaWVudElEKVxuICAgIGNvbnN0IGNsb2NrID0gY3VyckxvY2FsTWV0YSA9PT0gdW5kZWZpbmVkID8gMCA6IGN1cnJMb2NhbE1ldGEuY2xvY2sgKyAxXG4gICAgY29uc3QgcHJldlN0YXRlID0gdGhpcy5zdGF0ZXMuZ2V0KGNsaWVudElEKVxuICAgIGlmIChzdGF0ZSA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5zdGF0ZXMuZGVsZXRlKGNsaWVudElEKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN0YXRlcy5zZXQoY2xpZW50SUQsIHN0YXRlKVxuICAgIH1cbiAgICB0aGlzLm1ldGEuc2V0KGNsaWVudElELCB7XG4gICAgICBjbG9jayxcbiAgICAgIGxhc3RVcGRhdGVkOiB0aW1lLmdldFVuaXhUaW1lKClcbiAgICB9KVxuICAgIGNvbnN0IGFkZGVkID0gW11cbiAgICBjb25zdCB1cGRhdGVkID0gW11cbiAgICBjb25zdCBmaWx0ZXJlZFVwZGF0ZWQgPSBbXVxuICAgIGNvbnN0IHJlbW92ZWQgPSBbXVxuICAgIGlmIChzdGF0ZSA9PT0gbnVsbCkge1xuICAgICAgcmVtb3ZlZC5wdXNoKGNsaWVudElEKVxuICAgIH0gZWxzZSBpZiAocHJldlN0YXRlID09IG51bGwpIHtcbiAgICAgIGlmIChzdGF0ZSAhPSBudWxsKSB7XG4gICAgICAgIGFkZGVkLnB1c2goY2xpZW50SUQpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHVwZGF0ZWQucHVzaChjbGllbnRJRClcbiAgICAgIGlmICghZi5lcXVhbGl0eURlZXAocHJldlN0YXRlLCBzdGF0ZSkpIHtcbiAgICAgICAgZmlsdGVyZWRVcGRhdGVkLnB1c2goY2xpZW50SUQpXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChhZGRlZC5sZW5ndGggPiAwIHx8IGZpbHRlcmVkVXBkYXRlZC5sZW5ndGggPiAwIHx8IHJlbW92ZWQubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5lbWl0KCdjaGFuZ2UnLCBbeyBhZGRlZCwgdXBkYXRlZDogZmlsdGVyZWRVcGRhdGVkLCByZW1vdmVkIH0sICdsb2NhbCddKVxuICAgIH1cbiAgICB0aGlzLmVtaXQoJ3VwZGF0ZScsIFt7IGFkZGVkLCB1cGRhdGVkLCByZW1vdmVkIH0sICdsb2NhbCddKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZFxuICAgKiBAcGFyYW0ge2FueX0gdmFsdWVcbiAgICovXG4gIHNldExvY2FsU3RhdGVGaWVsZCAoZmllbGQsIHZhbHVlKSB7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLmdldExvY2FsU3RhdGUoKVxuICAgIGlmIChzdGF0ZSAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5zZXRMb2NhbFN0YXRlKHtcbiAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgIFtmaWVsZF06IHZhbHVlXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtNYXA8bnVtYmVyLE9iamVjdDxzdHJpbmcsYW55Pj59XG4gICAqL1xuICBnZXRTdGF0ZXMgKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlc1xuICB9XG59XG5cbi8qKlxuICogTWFyayAocmVtb3RlKSBjbGllbnRzIGFzIGluYWN0aXZlIGFuZCByZW1vdmUgdGhlbSBmcm9tIHRoZSBsaXN0IG9mIGFjdGl2ZSBwZWVycy5cbiAqIFRoaXMgY2hhbmdlIHdpbGwgYmUgcHJvcGFnYXRlZCB0byByZW1vdGUgY2xpZW50cy5cbiAqXG4gKiBAcGFyYW0ge0F3YXJlbmVzc30gYXdhcmVuZXNzXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGNsaWVudHNcbiAqIEBwYXJhbSB7YW55fSBvcmlnaW5cbiAqL1xuZXhwb3J0IGNvbnN0IHJlbW92ZUF3YXJlbmVzc1N0YXRlcyA9IChhd2FyZW5lc3MsIGNsaWVudHMsIG9yaWdpbikgPT4ge1xuICBjb25zdCByZW1vdmVkID0gW11cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjbGllbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY2xpZW50SUQgPSBjbGllbnRzW2ldXG4gICAgaWYgKGF3YXJlbmVzcy5zdGF0ZXMuaGFzKGNsaWVudElEKSkge1xuICAgICAgYXdhcmVuZXNzLnN0YXRlcy5kZWxldGUoY2xpZW50SUQpXG4gICAgICBpZiAoY2xpZW50SUQgPT09IGF3YXJlbmVzcy5jbGllbnRJRCkge1xuICAgICAgICBjb25zdCBjdXJNZXRhID0gLyoqIEB0eXBlIHtNZXRhQ2xpZW50U3RhdGV9ICovIChhd2FyZW5lc3MubWV0YS5nZXQoY2xpZW50SUQpKVxuICAgICAgICBhd2FyZW5lc3MubWV0YS5zZXQoY2xpZW50SUQsIHtcbiAgICAgICAgICBjbG9jazogY3VyTWV0YS5jbG9jayArIDEsXG4gICAgICAgICAgbGFzdFVwZGF0ZWQ6IHRpbWUuZ2V0VW5peFRpbWUoKVxuICAgICAgICB9KVxuICAgICAgfVxuICAgICAgcmVtb3ZlZC5wdXNoKGNsaWVudElEKVxuICAgIH1cbiAgfVxuICBpZiAocmVtb3ZlZC5sZW5ndGggPiAwKSB7XG4gICAgYXdhcmVuZXNzLmVtaXQoJ2NoYW5nZScsIFt7IGFkZGVkOiBbXSwgdXBkYXRlZDogW10sIHJlbW92ZWQgfSwgb3JpZ2luXSlcbiAgICBhd2FyZW5lc3MuZW1pdCgndXBkYXRlJywgW3sgYWRkZWQ6IFtdLCB1cGRhdGVkOiBbXSwgcmVtb3ZlZCB9LCBvcmlnaW5dKVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtBd2FyZW5lc3N9IGF3YXJlbmVzc1xuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBjbGllbnRzXG4gKiBAcmV0dXJuIHtVaW50OEFycmF5fVxuICovXG5leHBvcnQgY29uc3QgZW5jb2RlQXdhcmVuZXNzVXBkYXRlID0gKGF3YXJlbmVzcywgY2xpZW50cywgc3RhdGVzID0gYXdhcmVuZXNzLnN0YXRlcykgPT4ge1xuICBjb25zdCBsZW4gPSBjbGllbnRzLmxlbmd0aFxuICBjb25zdCBlbmNvZGVyID0gZW5jb2RpbmcuY3JlYXRlRW5jb2RlcigpXG4gIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyLCBsZW4pXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBjb25zdCBjbGllbnRJRCA9IGNsaWVudHNbaV1cbiAgICBjb25zdCBzdGF0ZSA9IHN0YXRlcy5nZXQoY2xpZW50SUQpIHx8IG51bGxcbiAgICBjb25zdCBjbG9jayA9IC8qKiBAdHlwZSB7TWV0YUNsaWVudFN0YXRlfSAqLyAoYXdhcmVuZXNzLm1ldGEuZ2V0KGNsaWVudElEKSkuY2xvY2tcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2RlciwgY2xpZW50SUQpXG4gICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIsIGNsb2NrKVxuICAgIGVuY29kaW5nLndyaXRlVmFyU3RyaW5nKGVuY29kZXIsIEpTT04uc3RyaW5naWZ5KHN0YXRlKSlcbiAgfVxuICByZXR1cm4gZW5jb2RpbmcudG9VaW50OEFycmF5KGVuY29kZXIpXG59XG5cbi8qKlxuICogTW9kaWZ5IHRoZSBjb250ZW50IG9mIGFuIGF3YXJlbmVzcyB1cGRhdGUgYmVmb3JlIHJlLWVuY29kaW5nIGl0IHRvIGFuIGF3YXJlbmVzcyB1cGRhdGUuXG4gKlxuICogVGhpcyBtaWdodCBiZSB1c2VmdWwgd2hlbiB5b3UgaGF2ZSBhIGNlbnRyYWwgc2VydmVyIHRoYXQgd2FudHMgdG8gZW5zdXJlIHRoYXQgY2xpZW50c1xuICogY2FudCBoaWphY2sgc29tZWJvZHkgZWxzZXMgaWRlbnRpdHkuXG4gKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSB1cGRhdGVcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oYW55KTphbnl9IG1vZGlmeVxuICogQHJldHVybiB7VWludDhBcnJheX1cbiAqL1xuZXhwb3J0IGNvbnN0IG1vZGlmeUF3YXJlbmVzc1VwZGF0ZSA9ICh1cGRhdGUsIG1vZGlmeSkgPT4ge1xuICBjb25zdCBkZWNvZGVyID0gZGVjb2RpbmcuY3JlYXRlRGVjb2Rlcih1cGRhdGUpXG4gIGNvbnN0IGVuY29kZXIgPSBlbmNvZGluZy5jcmVhdGVFbmNvZGVyKClcbiAgY29uc3QgbGVuID0gZGVjb2RpbmcucmVhZFZhclVpbnQoZGVjb2RlcilcbiAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIsIGxlbilcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGNvbnN0IGNsaWVudElEID0gZGVjb2RpbmcucmVhZFZhclVpbnQoZGVjb2RlcilcbiAgICBjb25zdCBjbG9jayA9IGRlY29kaW5nLnJlYWRWYXJVaW50KGRlY29kZXIpXG4gICAgY29uc3Qgc3RhdGUgPSBKU09OLnBhcnNlKGRlY29kaW5nLnJlYWRWYXJTdHJpbmcoZGVjb2RlcikpXG4gICAgY29uc3QgbW9kaWZpZWRTdGF0ZSA9IG1vZGlmeShzdGF0ZSlcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2RlciwgY2xpZW50SUQpXG4gICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIsIGNsb2NrKVxuICAgIGVuY29kaW5nLndyaXRlVmFyU3RyaW5nKGVuY29kZXIsIEpTT04uc3RyaW5naWZ5KG1vZGlmaWVkU3RhdGUpKVxuICB9XG4gIHJldHVybiBlbmNvZGluZy50b1VpbnQ4QXJyYXkoZW5jb2Rlcilcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0F3YXJlbmVzc30gYXdhcmVuZXNzXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHVwZGF0ZVxuICogQHBhcmFtIHthbnl9IG9yaWdpbiBUaGlzIHdpbGwgYmUgYWRkZWQgdG8gdGhlIGVtaXR0ZWQgY2hhbmdlIGV2ZW50XG4gKi9cbmV4cG9ydCBjb25zdCBhcHBseUF3YXJlbmVzc1VwZGF0ZSA9IChhd2FyZW5lc3MsIHVwZGF0ZSwgb3JpZ2luKSA9PiB7XG4gIGNvbnN0IGRlY29kZXIgPSBkZWNvZGluZy5jcmVhdGVEZWNvZGVyKHVwZGF0ZSlcbiAgY29uc3QgdGltZXN0YW1wID0gdGltZS5nZXRVbml4VGltZSgpXG4gIGNvbnN0IGFkZGVkID0gW11cbiAgY29uc3QgdXBkYXRlZCA9IFtdXG4gIGNvbnN0IGZpbHRlcmVkVXBkYXRlZCA9IFtdXG4gIGNvbnN0IHJlbW92ZWQgPSBbXVxuICBjb25zdCBsZW4gPSBkZWNvZGluZy5yZWFkVmFyVWludChkZWNvZGVyKVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgY29uc3QgY2xpZW50SUQgPSBkZWNvZGluZy5yZWFkVmFyVWludChkZWNvZGVyKVxuICAgIGxldCBjbG9jayA9IGRlY29kaW5nLnJlYWRWYXJVaW50KGRlY29kZXIpXG4gICAgY29uc3Qgc3RhdGUgPSBKU09OLnBhcnNlKGRlY29kaW5nLnJlYWRWYXJTdHJpbmcoZGVjb2RlcikpXG4gICAgY29uc3QgY2xpZW50TWV0YSA9IGF3YXJlbmVzcy5tZXRhLmdldChjbGllbnRJRClcbiAgICBjb25zdCBwcmV2U3RhdGUgPSBhd2FyZW5lc3Muc3RhdGVzLmdldChjbGllbnRJRClcbiAgICBjb25zdCBjdXJyQ2xvY2sgPSBjbGllbnRNZXRhID09PSB1bmRlZmluZWQgPyAwIDogY2xpZW50TWV0YS5jbG9ja1xuICAgIGlmIChjdXJyQ2xvY2sgPCBjbG9jayB8fCAoY3VyckNsb2NrID09PSBjbG9jayAmJiBzdGF0ZSA9PT0gbnVsbCAmJiBhd2FyZW5lc3Muc3RhdGVzLmhhcyhjbGllbnRJRCkpKSB7XG4gICAgICBpZiAoc3RhdGUgPT09IG51bGwpIHtcbiAgICAgICAgLy8gbmV2ZXIgbGV0IGEgcmVtb3RlIGNsaWVudCByZW1vdmUgdGhpcyBsb2NhbCBzdGF0ZVxuICAgICAgICBpZiAoY2xpZW50SUQgPT09IGF3YXJlbmVzcy5jbGllbnRJRCAmJiBhd2FyZW5lc3MuZ2V0TG9jYWxTdGF0ZSgpICE9IG51bGwpIHtcbiAgICAgICAgICAvLyByZW1vdGUgY2xpZW50IHJlbW92ZWQgdGhlIGxvY2FsIHN0YXRlLiBEbyBub3QgcmVtb3RlIHN0YXRlLiBCcm9hZGNhc3QgYSBtZXNzYWdlIGluZGljYXRpbmdcbiAgICAgICAgICAvLyB0aGF0IHRoaXMgY2xpZW50IHN0aWxsIGV4aXN0cyBieSBpbmNyZWFzaW5nIHRoZSBjbG9ja1xuICAgICAgICAgIGNsb2NrKytcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhd2FyZW5lc3Muc3RhdGVzLmRlbGV0ZShjbGllbnRJRClcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXdhcmVuZXNzLnN0YXRlcy5zZXQoY2xpZW50SUQsIHN0YXRlKVxuICAgICAgfVxuICAgICAgYXdhcmVuZXNzLm1ldGEuc2V0KGNsaWVudElELCB7XG4gICAgICAgIGNsb2NrLFxuICAgICAgICBsYXN0VXBkYXRlZDogdGltZXN0YW1wXG4gICAgICB9KVxuICAgICAgaWYgKGNsaWVudE1ldGEgPT09IHVuZGVmaW5lZCAmJiBzdGF0ZSAhPT0gbnVsbCkge1xuICAgICAgICBhZGRlZC5wdXNoKGNsaWVudElEKVxuICAgICAgfSBlbHNlIGlmIChjbGllbnRNZXRhICE9PSB1bmRlZmluZWQgJiYgc3RhdGUgPT09IG51bGwpIHtcbiAgICAgICAgcmVtb3ZlZC5wdXNoKGNsaWVudElEKVxuICAgICAgfSBlbHNlIGlmIChzdGF0ZSAhPT0gbnVsbCkge1xuICAgICAgICBpZiAoIWYuZXF1YWxpdHlEZWVwKHN0YXRlLCBwcmV2U3RhdGUpKSB7XG4gICAgICAgICAgZmlsdGVyZWRVcGRhdGVkLnB1c2goY2xpZW50SUQpXG4gICAgICAgIH1cbiAgICAgICAgdXBkYXRlZC5wdXNoKGNsaWVudElEKVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoYWRkZWQubGVuZ3RoID4gMCB8fCBmaWx0ZXJlZFVwZGF0ZWQubGVuZ3RoID4gMCB8fCByZW1vdmVkLmxlbmd0aCA+IDApIHtcbiAgICBhd2FyZW5lc3MuZW1pdCgnY2hhbmdlJywgW3tcbiAgICAgIGFkZGVkLCB1cGRhdGVkOiBmaWx0ZXJlZFVwZGF0ZWQsIHJlbW92ZWRcbiAgICB9LCBvcmlnaW5dKVxuICB9XG4gIGlmIChhZGRlZC5sZW5ndGggPiAwIHx8IHVwZGF0ZWQubGVuZ3RoID4gMCB8fCByZW1vdmVkLmxlbmd0aCA+IDApIHtcbiAgICBhd2FyZW5lc3MuZW1pdCgndXBkYXRlJywgW3tcbiAgICAgIGFkZGVkLCB1cGRhdGVkLCByZW1vdmVkXG4gICAgfSwgb3JpZ2luXSlcbiAgfVxufVxuIiwgIi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuXG5pbXBvcnQgKiBhcyBlbmNvZGluZyBmcm9tICdsaWIwL2VuY29kaW5nJ1xuaW1wb3J0ICogYXMgZGVjb2RpbmcgZnJvbSAnbGliMC9kZWNvZGluZydcbmltcG9ydCAqIGFzIHByb21pc2UgZnJvbSAnbGliMC9wcm9taXNlJ1xuaW1wb3J0ICogYXMgZXJyb3IgZnJvbSAnbGliMC9lcnJvcidcbmltcG9ydCAqIGFzIHN0cmluZyBmcm9tICdsaWIwL3N0cmluZydcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gc2VjcmV0XG4gKiBAcGFyYW0ge3N0cmluZ30gcm9vbU5hbWVcbiAqIEByZXR1cm4ge1Byb21pc2VMaWtlPENyeXB0b0tleT59XG4gKi9cbmV4cG9ydCBjb25zdCBkZXJpdmVLZXkgPSAoc2VjcmV0LCByb29tTmFtZSkgPT4ge1xuICBjb25zdCBzZWNyZXRCdWZmZXIgPSBzdHJpbmcuZW5jb2RlVXRmOChzZWNyZXQpLmJ1ZmZlclxuICBjb25zdCBzYWx0ID0gc3RyaW5nLmVuY29kZVV0Zjgocm9vbU5hbWUpLmJ1ZmZlclxuICByZXR1cm4gY3J5cHRvLnN1YnRsZS5pbXBvcnRLZXkoXG4gICAgJ3JhdycsXG4gICAgc2VjcmV0QnVmZmVyLFxuICAgICdQQktERjInLFxuICAgIGZhbHNlLFxuICAgIFsnZGVyaXZlS2V5J11cbiAgKS50aGVuKGtleU1hdGVyaWFsID0+XG4gICAgY3J5cHRvLnN1YnRsZS5kZXJpdmVLZXkoXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdQQktERjInLFxuICAgICAgICBzYWx0LFxuICAgICAgICBpdGVyYXRpb25zOiAxMDAwMDAsXG4gICAgICAgIGhhc2g6ICdTSEEtMjU2J1xuICAgICAgfSxcbiAgICAgIGtleU1hdGVyaWFsLFxuICAgICAge1xuICAgICAgICBuYW1lOiAnQUVTLUdDTScsXG4gICAgICAgIGxlbmd0aDogMjU2XG4gICAgICB9LFxuICAgICAgdHJ1ZSxcbiAgICAgIFsnZW5jcnlwdCcsICdkZWNyeXB0J11cbiAgICApXG4gIClcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGRhdGEgZGF0YSB0byBiZSBlbmNyeXB0ZWRcbiAqIEBwYXJhbSB7Q3J5cHRvS2V5P30ga2V5XG4gKiBAcmV0dXJuIHtQcm9taXNlTGlrZTxVaW50OEFycmF5Pn0gZW5jcnlwdGVkLCBiYXNlNjQgZW5jb2RlZCBtZXNzYWdlXG4gKi9cbmV4cG9ydCBjb25zdCBlbmNyeXB0ID0gKGRhdGEsIGtleSkgPT4ge1xuICBpZiAoIWtleSkge1xuICAgIHJldHVybiAvKiogQHR5cGUge1Byb21pc2VMaWtlPFVpbnQ4QXJyYXk+fSAqLyAocHJvbWlzZS5yZXNvbHZlKGRhdGEpKVxuICB9XG4gIGNvbnN0IGl2ID0gY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDhBcnJheSgxMikpXG4gIHJldHVybiBjcnlwdG8uc3VidGxlLmVuY3J5cHQoXG4gICAge1xuICAgICAgbmFtZTogJ0FFUy1HQ00nLFxuICAgICAgaXZcbiAgICB9LFxuICAgIGtleSxcbiAgICBkYXRhXG4gICkudGhlbihjaXBoZXIgPT4ge1xuICAgIGNvbnN0IGVuY3J5cHRlZERhdGFFbmNvZGVyID0gZW5jb2RpbmcuY3JlYXRlRW5jb2RlcigpXG4gICAgZW5jb2Rpbmcud3JpdGVWYXJTdHJpbmcoZW5jcnlwdGVkRGF0YUVuY29kZXIsICdBRVMtR0NNJylcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQ4QXJyYXkoZW5jcnlwdGVkRGF0YUVuY29kZXIsIGl2KVxuICAgIGVuY29kaW5nLndyaXRlVmFyVWludDhBcnJheShlbmNyeXB0ZWREYXRhRW5jb2RlciwgbmV3IFVpbnQ4QXJyYXkoY2lwaGVyKSlcbiAgICByZXR1cm4gZW5jb2RpbmcudG9VaW50OEFycmF5KGVuY3J5cHRlZERhdGFFbmNvZGVyKVxuICB9KVxufVxuXG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIGRhdGEgdG8gYmUgZW5jcnlwdGVkXG4gKiBAcGFyYW0ge0NyeXB0b0tleT99IGtleVxuICogQHJldHVybiB7UHJvbWlzZUxpa2U8VWludDhBcnJheT59IGVuY3J5cHRlZCBkYXRhLCBpZiBrZXkgaXMgcHJvdmlkZWRcbiAqL1xuZXhwb3J0IGNvbnN0IGVuY3J5cHRKc29uID0gKGRhdGEsIGtleSkgPT4ge1xuICBjb25zdCBkYXRhRW5jb2RlciA9IGVuY29kaW5nLmNyZWF0ZUVuY29kZXIoKVxuICBlbmNvZGluZy53cml0ZUFueShkYXRhRW5jb2RlciwgZGF0YSlcbiAgcmV0dXJuIGVuY3J5cHQoZW5jb2RpbmcudG9VaW50OEFycmF5KGRhdGFFbmNvZGVyKSwga2V5KVxufVxuXG4vKipcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gZGF0YVxuICogQHBhcmFtIHtDcnlwdG9LZXk/fSBrZXlcbiAqIEByZXR1cm4ge1Byb21pc2VMaWtlPFVpbnQ4QXJyYXk+fSBkZWNyeXB0ZWQgYnVmZmVyXG4gKi9cbmV4cG9ydCBjb25zdCBkZWNyeXB0ID0gKGRhdGEsIGtleSkgPT4ge1xuICBpZiAoIWtleSkge1xuICAgIHJldHVybiAvKiogQHR5cGUge1Byb21pc2VMaWtlPFVpbnQ4QXJyYXk+fSAqLyAocHJvbWlzZS5yZXNvbHZlKGRhdGEpKVxuICB9XG4gIGNvbnN0IGRhdGFEZWNvZGVyID0gZGVjb2RpbmcuY3JlYXRlRGVjb2RlcihkYXRhKVxuICBjb25zdCBhbGdvcml0aG0gPSBkZWNvZGluZy5yZWFkVmFyU3RyaW5nKGRhdGFEZWNvZGVyKVxuICBpZiAoYWxnb3JpdGhtICE9PSAnQUVTLUdDTScpIHtcbiAgICBwcm9taXNlLnJlamVjdChlcnJvci5jcmVhdGUoJ1Vua25vd24gZW5jcnlwdGlvbiBhbGdvcml0aG0nKSlcbiAgfVxuICBjb25zdCBpdiA9IGRlY29kaW5nLnJlYWRWYXJVaW50OEFycmF5KGRhdGFEZWNvZGVyKVxuICBjb25zdCBjaXBoZXIgPSBkZWNvZGluZy5yZWFkVmFyVWludDhBcnJheShkYXRhRGVjb2RlcilcbiAgcmV0dXJuIGNyeXB0by5zdWJ0bGUuZGVjcnlwdChcbiAgICB7XG4gICAgICBuYW1lOiAnQUVTLUdDTScsXG4gICAgICBpdlxuICAgIH0sXG4gICAga2V5LFxuICAgIGNpcGhlclxuICApLnRoZW4oZGF0YSA9PiBuZXcgVWludDhBcnJheShkYXRhKSlcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGRhdGFcbiAqIEBwYXJhbSB7Q3J5cHRvS2V5P30ga2V5XG4gKiBAcmV0dXJuIHtQcm9taXNlTGlrZTxPYmplY3Q+fSBkZWNyeXB0ZWQgb2JqZWN0XG4gKi9cbmV4cG9ydCBjb25zdCBkZWNyeXB0SnNvbiA9IChkYXRhLCBrZXkpID0+XG4gIGRlY3J5cHQoZGF0YSwga2V5KS50aGVuKGRlY3J5cHRlZFZhbHVlID0+XG4gICAgZGVjb2RpbmcucmVhZEFueShkZWNvZGluZy5jcmVhdGVEZWNvZGVyKG5ldyBVaW50OEFycmF5KGRlY3J5cHRlZFZhbHVlKSkpXG4gIClcbiIsICJpbXBvcnQgUGVlckRyYWZ0UGx1Z2luIGZyb20gJ3NyYy9tYWluJ1xuaW1wb3J0IHsgV2VicnRjUHJvdmlkZXIgfSBmcm9tICd5LXdlYnJ0YydcbmltcG9ydCB7IEluZGV4ZWRkYlBlcnNpc3RlbmNlIH0gZnJvbSBcInktaW5kZXhlZGRiXCJcbmltcG9ydCAqIGFzIFkgZnJvbSAneWpzJ1xuaW1wb3J0IHsgY3JlYXRlUmFuZG9tSWQgfSBmcm9tICdzcmMvdG9vbHMnXG5pbXBvcnQgeyBub3JtYWxpemVQYXRoIH0gZnJvbSAnb2JzaWRpYW4nXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgU2hhcmVkRW50aXR5IHtcblxuICBzdGF0aWMgREJfUEVSU0lTVEVOQ0VfUFJFRklYID0gXCJwZWVyZHJhZnRfcGVyc2lzdGVuY2VfXCJcblxuICB5RG9jOiBZLkRvY1xuICBwcm90ZWN0ZWQgX3NoYXJlSWQ6IHN0cmluZ1xuXG4gIHByb3RlY3RlZCBfd2ViUlRDUHJvdmlkZXI/OiBXZWJydGNQcm92aWRlclxuICBwcm90ZWN0ZWQgX3dlYlJUQ1RpbWVvdXQ6IG51bWJlciB8IG51bGwgPSBudWxsXG5cbiAgcHJvdGVjdGVkIF9pbmRleGVkREJQcm92aWRlcj86IEluZGV4ZWRkYlBlcnNpc3RlbmNlXG5cbiAgcHJvdGVjdGVkIHN0YXRpYyBfc2hhcmVkRW50aXRlczogQXJyYXk8U2hhcmVkRW50aXR5PjtcblxuICBwcm90ZWN0ZWQgX3BhdGg6IHN0cmluZ1xuXG4gIGdldCBzaGFyZUlkKCkge1xuICAgIHJldHVybiB0aGlzLl9zaGFyZUlkXG4gIH1cblxuICBnZXQgcGF0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcGF0aFxuICB9XG5cbiAgZ2V0IGluZGV4ZWREQlByb3ZpZGVyKCkge1xuICAgIHJldHVybiB0aGlzLl9pbmRleGVkREJQcm92aWRlclxuICB9XG5cbiAgZ2V0IHdlYlJUQ1Byb3ZpZGVyKCl7XG4gICAgcmV0dXJuIHRoaXMuX3dlYlJUQ1Byb3ZpZGVyXG4gIH1cblxuICBzdGF0aWMgZmluZEJ5UGF0aChwYXRoOiBzdHJpbmcpIHtcbiAgICBjb25zdCBub3JtYWxpemVkUGF0aCA9IG5vcm1hbGl6ZVBhdGgocGF0aClcbiAgICBjb25zdCBkb2NzID0gdGhpcy5fc2hhcmVkRW50aXRlcy5maWx0ZXIoZG9jID0+IHtcbiAgICAgIHJldHVybiBkb2MucGF0aCA9PT0gbm9ybWFsaXplZFBhdGhcbiAgICB9KVxuICAgIGlmIChkb2NzLmxlbmd0aCA+PSAxKSB7XG4gICAgICByZXR1cm4gZG9jc1swXVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gIH1cblxuICBzdGF0aWMgZmluZEJ5SWQoaWQ6IHN0cmluZykge1xuICAgIGNvbnN0IGRvY3MgPSB0aGlzLl9zaGFyZWRFbnRpdGVzLmZpbHRlcihkb2MgPT4ge1xuICAgICAgcmV0dXJuIGRvYy5zaGFyZUlkID09PSBpZFxuICAgIH0pXG4gICAgaWYgKGRvY3MubGVuZ3RoID49IDEpIHtcbiAgICAgIHJldHVybiBkb2NzWzBdXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBnZXRBbGwoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oW10sIHRoaXMuX3NoYXJlZEVudGl0ZXMpIGFzIEFycmF5PFNoYXJlZEVudGl0eT5cbiAgfVxuXG4gIGNvbnN0cnVjdG9yKHByb3RlY3RlZCBwbHVnaW46IFBlZXJEcmFmdFBsdWdpbikge31cblxuICBhYnN0cmFjdCBjYWxjdWxhdGVIYXNoICgpOiBzdHJpbmdcblxuICBpbml0U2VydmVyWURvYygpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2U8c3RyaW5nPihyZXNvbHZlID0+IHtcbiAgICAgIGNvbnN0IHRlbXBJZCA9IGNyZWF0ZVJhbmRvbUlkKClcbiAgICAgIGNvbnN0IGhhbmRsZXIgPSAoc2VydmVyVGVtcElkOiBzdHJpbmcsIGlkOiBzdHJpbmcsIGNoZWNrc3VtOiBzdHJpbmcpID0+IHtcbiAgICAgICAgaWYgKHNlcnZlclRlbXBJZCA9PT0gdGVtcElkKSB7XG4gICAgICAgICAgdGhpcy5wbHVnaW4uc2VydmVyU3luYy5vZmYoJ25ldy1kb2MtY29uZmlybWVkJywgaGFuZGxlcilcbiAgICAgICAgICB0aGlzLl9zaGFyZUlkID0gaWRcbiAgICAgICAgICByZXNvbHZlKGNoZWNrc3VtKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLnBsdWdpbi5zZXJ2ZXJTeW5jLm9uKCduZXctZG9jLWNvbmZpcm1lZCcsIGhhbmRsZXIpXG4gICAgICB0aGlzLnBsdWdpbi5zZXJ2ZXJTeW5jLnNlbmROZXdEb2N1bWVudCh0aGlzLCB0ZW1wSWQpXG4gICAgfSlcbiAgfVxuXG4gIHN5bmNXaXRoU2VydmVyKCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZTxzdHJpbmc+KHJlc29sdmUgPT4ge1xuICAgICAgY29uc3QgaGFuZGxlciA9IGFzeW5jIChpZDogc3RyaW5nLCBoYXNoOiBzdHJpbmcpID0+IHtcbiAgICAgICAgaWYgKGlkID09PSB0aGlzLnNoYXJlSWQpIHtcbiAgICAgICAgICB0aGlzLnBsdWdpbi5zZXJ2ZXJTeW5jLm9mZignc3luY2VkJywgaGFuZGxlcilcbiAgICAgICAgICB0aGlzLnBsdWdpbi5sb2coXCJzeW5jZWQgXCIgKyB0aGlzLnBhdGgpXG4gICAgICAgICAgcmVzb2x2ZShoYXNoKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLnBsdWdpbi5zZXJ2ZXJTeW5jLm9uKCdzeW5jZWQnLCBoYW5kbGVyKVxuICAgICAgXG4gICAgICB0aGlzLnBsdWdpbi5zZXJ2ZXJTeW5jLnNlbmRTeW5jU3RlcDEodGhpcylcbiAgICAgIHRoaXMucGx1Z2luLmxvZyhcInN5bmNpbmcgXCIgKyB0aGlzLnBhdGgpXG4gICAgfSlcbiAgfVxuXG5cbiAgc3RhcnRXZWJSVENTeW5jKGluaXQ/OiAocHJvdmlkZXI6IFdlYnJ0Y1Byb3ZpZGVyKSA9PiBhbnkpIHtcbiAgICB0aGlzLnBsdWdpbi5sb2coYFdlYlJUQyBmb3IgJHt0aGlzLnBhdGh9OiBzdGFydGApXG4gICAgaWYgKCF0aGlzLnNoYXJlSWQpIHJldHVyblxuICAgIGlmICh0aGlzLl93ZWJSVENQcm92aWRlcikge1xuICAgICAgdGhpcy5fd2ViUlRDUHJvdmlkZXIuY29ubmVjdCgpXG4gICAgICByZXR1cm4gdGhpcy5fd2ViUlRDUHJvdmlkZXJcbiAgICB9XG4gICAgY29uc3Qgd2ViUlRDUHJvdmlkZXIgPSBuZXcgV2VicnRjUHJvdmlkZXIodGhpcy5fc2hhcmVJZCwgdGhpcy55RG9jLCB7IHNpZ25hbGluZzogW3RoaXMucGx1Z2luLnNldHRpbmdzLnNpZ25hbGluZ10sIHBlZXJPcHRzOiB7IGljZVNlcnZlcnM6IFt7IHVybHM6ICdzdHVuOmZyZWV0dXJuLm5ldDo1MzQ5JyB9LCB7IHVybHM6ICd0dXJuczpmcmVldHVybi5uZXQ6NTM0OScsIHVzZXJuYW1lOiAnZnJlZScsIGNyZWRlbnRpYWw6ICdmcmVlJyB9LCB7IHVybHM6ICdzdHVuOnN0dW4ubC5nb29nbGUuY29tOjE5MzAyJyB9LCB7IHVybHM6ICdzdHVuOmdsb2JhbC5zdHVuLnR3aWxpby5jb206MzQ3OD90cmFuc3BvcnQ9dWRwJyB9XSB9IH0pXG4gICAgdGhpcy5fd2ViUlRDUHJvdmlkZXIgPSB3ZWJSVENQcm92aWRlclxuICAgIGlmIChpbml0KSB7XG4gICAgICBpbml0KHdlYlJUQ1Byb3ZpZGVyKVxuICAgIH1cbiAgICByZXR1cm4gd2ViUlRDUHJvdmlkZXJcbiAgfVxuXG4gIHN0b3BXZWJSVENTeW5jKCkge1xuICAgIGlmICghdGhpcy5fd2ViUlRDUHJvdmlkZXIpIHJldHVyblxuICAgIHRoaXMucGx1Z2luLmxvZyhgV2ViUlRDIGZvciAke3RoaXMucGF0aH06IHN0b3BgKVxuICAgIHRoaXMuX3dlYlJUQ1Byb3ZpZGVyPy5hd2FyZW5lc3MuZGVzdHJveSgpXG4gICAgdGhpcy5fd2ViUlRDUHJvdmlkZXI/LmRpc2Nvbm5lY3QoKVxuICAgIHRoaXMuX3dlYlJUQ1Byb3ZpZGVyPy5kZXN0cm95KClcbiAgICB0aGlzLl93ZWJSVENQcm92aWRlciA9IHVuZGVmaW5lZFxuICB9XG5cbiAgYXN5bmMgc3RvcEluZGV4ZWREQlN5bmMoKSB7XG4gICAgaWYgKCF0aGlzLl9pbmRleGVkREJQcm92aWRlcikgcmV0dXJuXG4gICAgYXdhaXQgdGhpcy5faW5kZXhlZERCUHJvdmlkZXIuZGVzdHJveSgpXG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuc3RvcFdlYlJUQ1N5bmMoKVxuICB9XG5cbn0iLCAiLyogZXNsaW50LWVudiBicm93c2VyICovXG5cbi8qKlxuICogSGVscGVycyB0byB3b3JrIHdpdGggSW5kZXhlZERCLlxuICpcbiAqIEBtb2R1bGUgaW5kZXhlZGRiXG4gKi9cblxuaW1wb3J0ICogYXMgcHJvbWlzZSBmcm9tICcuL3Byb21pc2UuanMnXG5pbXBvcnQgKiBhcyBlcnJvciBmcm9tICcuL2Vycm9yLmpzJ1xuXG4vKiBjOCBpZ25vcmUgc3RhcnQgKi9cblxuLyoqXG4gKiBJREIgUmVxdWVzdCB0byBQcm9taXNlIHRyYW5zZm9ybWVyXG4gKlxuICogQHBhcmFtIHtJREJSZXF1ZXN0fSByZXF1ZXN0XG4gKiBAcmV0dXJuIHtQcm9taXNlPGFueT59XG4gKi9cbmV4cG9ydCBjb25zdCBydG9wID0gcmVxdWVzdCA9PiBwcm9taXNlLmNyZWF0ZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gIC8vIEB0cy1pZ25vcmVcbiAgcmVxdWVzdC5vbmVycm9yID0gZXZlbnQgPT4gcmVqZWN0KG5ldyBFcnJvcihldmVudC50YXJnZXQuZXJyb3IpKVxuICAvLyBAdHMtaWdub3JlXG4gIHJlcXVlc3Qub25zdWNjZXNzID0gZXZlbnQgPT4gcmVzb2x2ZShldmVudC50YXJnZXQucmVzdWx0KVxufSlcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtmdW5jdGlvbihJREJEYXRhYmFzZSk6YW55fSBpbml0REIgQ2FsbGVkIHdoZW4gdGhlIGRhdGFiYXNlIGlzIGZpcnN0IGNyZWF0ZWRcbiAqIEByZXR1cm4ge1Byb21pc2U8SURCRGF0YWJhc2U+fVxuICovXG5leHBvcnQgY29uc3Qgb3BlbkRCID0gKG5hbWUsIGluaXREQikgPT4gcHJvbWlzZS5jcmVhdGUoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICBjb25zdCByZXF1ZXN0ID0gaW5kZXhlZERCLm9wZW4obmFtZSlcbiAgLyoqXG4gICAqIEBwYXJhbSB7YW55fSBldmVudFxuICAgKi9cbiAgcmVxdWVzdC5vbnVwZ3JhZGVuZWVkZWQgPSBldmVudCA9PiBpbml0REIoZXZlbnQudGFyZ2V0LnJlc3VsdClcbiAgLyoqXG4gICAqIEBwYXJhbSB7YW55fSBldmVudFxuICAgKi9cbiAgcmVxdWVzdC5vbmVycm9yID0gZXZlbnQgPT4gcmVqZWN0KGVycm9yLmNyZWF0ZShldmVudC50YXJnZXQuZXJyb3IpKVxuICAvKipcbiAgICogQHBhcmFtIHthbnl9IGV2ZW50XG4gICAqL1xuICByZXF1ZXN0Lm9uc3VjY2VzcyA9IGV2ZW50ID0+IHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7SURCRGF0YWJhc2V9XG4gICAgICovXG4gICAgY29uc3QgZGIgPSBldmVudC50YXJnZXQucmVzdWx0XG4gICAgZGIub252ZXJzaW9uY2hhbmdlID0gKCkgPT4geyBkYi5jbG9zZSgpIH1cbiAgICByZXNvbHZlKGRiKVxuICB9XG59KVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKi9cbmV4cG9ydCBjb25zdCBkZWxldGVEQiA9IG5hbWUgPT4gcnRvcChpbmRleGVkREIuZGVsZXRlRGF0YWJhc2UobmFtZSkpXG5cbi8qKlxuICogQHBhcmFtIHtJREJEYXRhYmFzZX0gZGJcbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8c3RyaW5nPnxBcnJheTxzdHJpbmd8SURCT2JqZWN0U3RvcmVQYXJhbWV0ZXJzfHVuZGVmaW5lZD4+fSBkZWZpbml0aW9uc1xuICovXG5leHBvcnQgY29uc3QgY3JlYXRlU3RvcmVzID0gKGRiLCBkZWZpbml0aW9ucykgPT4gZGVmaW5pdGlvbnMuZm9yRWFjaChkID0+XG4gIC8vIEB0cy1pZ25vcmVcbiAgZGIuY3JlYXRlT2JqZWN0U3RvcmUuYXBwbHkoZGIsIGQpXG4pXG5cbi8qKlxuICogQHBhcmFtIHtJREJEYXRhYmFzZX0gZGJcbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gc3RvcmVzXG4gKiBAcGFyYW0ge1wicmVhZHdyaXRlXCJ8XCJyZWFkb25seVwifSBbYWNjZXNzXVxuICogQHJldHVybiB7QXJyYXk8SURCT2JqZWN0U3RvcmU+fVxuICovXG5leHBvcnQgY29uc3QgdHJhbnNhY3QgPSAoZGIsIHN0b3JlcywgYWNjZXNzID0gJ3JlYWR3cml0ZScpID0+IHtcbiAgY29uc3QgdHJhbnNhY3Rpb24gPSBkYi50cmFuc2FjdGlvbihzdG9yZXMsIGFjY2VzcylcbiAgcmV0dXJuIHN0b3Jlcy5tYXAoc3RvcmUgPT4gZ2V0U3RvcmUodHJhbnNhY3Rpb24sIHN0b3JlKSlcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0lEQk9iamVjdFN0b3JlfSBzdG9yZVxuICogQHBhcmFtIHtJREJLZXlSYW5nZX0gW3JhbmdlXVxuICogQHJldHVybiB7UHJvbWlzZTxudW1iZXI+fVxuICovXG5leHBvcnQgY29uc3QgY291bnQgPSAoc3RvcmUsIHJhbmdlKSA9PlxuICBydG9wKHN0b3JlLmNvdW50KHJhbmdlKSlcblxuLyoqXG4gKiBAcGFyYW0ge0lEQk9iamVjdFN0b3JlfSBzdG9yZVxuICogQHBhcmFtIHtTdHJpbmcgfCBudW1iZXIgfCBBcnJheUJ1ZmZlciB8IERhdGUgfCBBcnJheTxhbnk+IH0ga2V5XG4gKiBAcmV0dXJuIHtQcm9taXNlPFN0cmluZyB8IG51bWJlciB8IEFycmF5QnVmZmVyIHwgRGF0ZSB8IEFycmF5PGFueT4+fVxuICovXG5leHBvcnQgY29uc3QgZ2V0ID0gKHN0b3JlLCBrZXkpID0+XG4gIHJ0b3Aoc3RvcmUuZ2V0KGtleSkpXG5cbi8qKlxuICogQHBhcmFtIHtJREJPYmplY3RTdG9yZX0gc3RvcmVcbiAqIEBwYXJhbSB7U3RyaW5nIHwgbnVtYmVyIHwgQXJyYXlCdWZmZXIgfCBEYXRlIHwgSURCS2V5UmFuZ2UgfCBBcnJheTxhbnk+IH0ga2V5XG4gKi9cbmV4cG9ydCBjb25zdCBkZWwgPSAoc3RvcmUsIGtleSkgPT5cbiAgcnRvcChzdG9yZS5kZWxldGUoa2V5KSlcblxuLyoqXG4gKiBAcGFyYW0ge0lEQk9iamVjdFN0b3JlfSBzdG9yZVxuICogQHBhcmFtIHtTdHJpbmcgfCBudW1iZXIgfCBBcnJheUJ1ZmZlciB8IERhdGUgfCBib29sZWFufSBpdGVtXG4gKiBAcGFyYW0ge1N0cmluZyB8IG51bWJlciB8IEFycmF5QnVmZmVyIHwgRGF0ZSB8IEFycmF5PGFueT59IFtrZXldXG4gKi9cbmV4cG9ydCBjb25zdCBwdXQgPSAoc3RvcmUsIGl0ZW0sIGtleSkgPT5cbiAgcnRvcChzdG9yZS5wdXQoaXRlbSwga2V5KSlcblxuLyoqXG4gKiBAcGFyYW0ge0lEQk9iamVjdFN0b3JlfSBzdG9yZVxuICogQHBhcmFtIHtTdHJpbmcgfCBudW1iZXIgfCBBcnJheUJ1ZmZlciB8IERhdGUgfCBib29sZWFufSAgaXRlbVxuICogQHBhcmFtIHtTdHJpbmcgfCBudW1iZXIgfCBBcnJheUJ1ZmZlciB8IERhdGUgfCBBcnJheTxhbnk+fSAga2V5XG4gKiBAcmV0dXJuIHtQcm9taXNlPGFueT59XG4gKi9cbmV4cG9ydCBjb25zdCBhZGQgPSAoc3RvcmUsIGl0ZW0sIGtleSkgPT5cbiAgcnRvcChzdG9yZS5hZGQoaXRlbSwga2V5KSlcblxuLyoqXG4gKiBAcGFyYW0ge0lEQk9iamVjdFN0b3JlfSBzdG9yZVxuICogQHBhcmFtIHtTdHJpbmcgfCBudW1iZXIgfCBBcnJheUJ1ZmZlciB8IERhdGV9ICBpdGVtXG4gKiBAcmV0dXJuIHtQcm9taXNlPG51bWJlcj59IFJldHVybnMgdGhlIGdlbmVyYXRlZCBrZXlcbiAqL1xuZXhwb3J0IGNvbnN0IGFkZEF1dG9LZXkgPSAoc3RvcmUsIGl0ZW0pID0+XG4gIHJ0b3Aoc3RvcmUuYWRkKGl0ZW0pKVxuXG4vKipcbiAqIEBwYXJhbSB7SURCT2JqZWN0U3RvcmV9IHN0b3JlXG4gKiBAcGFyYW0ge0lEQktleVJhbmdlfSBbcmFuZ2VdXG4gKiBAcGFyYW0ge251bWJlcn0gW2xpbWl0XVxuICogQHJldHVybiB7UHJvbWlzZTxBcnJheTxhbnk+Pn1cbiAqL1xuZXhwb3J0IGNvbnN0IGdldEFsbCA9IChzdG9yZSwgcmFuZ2UsIGxpbWl0KSA9PlxuICBydG9wKHN0b3JlLmdldEFsbChyYW5nZSwgbGltaXQpKVxuXG4vKipcbiAqIEBwYXJhbSB7SURCT2JqZWN0U3RvcmV9IHN0b3JlXG4gKiBAcGFyYW0ge0lEQktleVJhbmdlfSBbcmFuZ2VdXG4gKiBAcGFyYW0ge251bWJlcn0gW2xpbWl0XVxuICogQHJldHVybiB7UHJvbWlzZTxBcnJheTxhbnk+Pn1cbiAqL1xuZXhwb3J0IGNvbnN0IGdldEFsbEtleXMgPSAoc3RvcmUsIHJhbmdlLCBsaW1pdCkgPT5cbiAgcnRvcChzdG9yZS5nZXRBbGxLZXlzKHJhbmdlLCBsaW1pdCkpXG5cbi8qKlxuICogQHBhcmFtIHtJREJPYmplY3RTdG9yZX0gc3RvcmVcbiAqIEBwYXJhbSB7SURCS2V5UmFuZ2V8bnVsbH0gcXVlcnlcbiAqIEBwYXJhbSB7J25leHQnfCdwcmV2J3wnbmV4dHVuaXF1ZSd8J3ByZXZ1bmlxdWUnfSBkaXJlY3Rpb25cbiAqIEByZXR1cm4ge1Byb21pc2U8YW55Pn1cbiAqL1xuZXhwb3J0IGNvbnN0IHF1ZXJ5Rmlyc3QgPSAoc3RvcmUsIHF1ZXJ5LCBkaXJlY3Rpb24pID0+IHtcbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBsZXQgZmlyc3QgPSBudWxsXG4gIHJldHVybiBpdGVyYXRlS2V5cyhzdG9yZSwgcXVlcnksIGtleSA9PiB7XG4gICAgZmlyc3QgPSBrZXlcbiAgICByZXR1cm4gZmFsc2VcbiAgfSwgZGlyZWN0aW9uKS50aGVuKCgpID0+IGZpcnN0KVxufVxuXG4vKipcbiAqIEBwYXJhbSB7SURCT2JqZWN0U3RvcmV9IHN0b3JlXG4gKiBAcGFyYW0ge0lEQktleVJhbmdlP30gW3JhbmdlXVxuICogQHJldHVybiB7UHJvbWlzZTxhbnk+fVxuICovXG5leHBvcnQgY29uc3QgZ2V0TGFzdEtleSA9IChzdG9yZSwgcmFuZ2UgPSBudWxsKSA9PiBxdWVyeUZpcnN0KHN0b3JlLCByYW5nZSwgJ3ByZXYnKVxuXG4vKipcbiAqIEBwYXJhbSB7SURCT2JqZWN0U3RvcmV9IHN0b3JlXG4gKiBAcGFyYW0ge0lEQktleVJhbmdlP30gW3JhbmdlXVxuICogQHJldHVybiB7UHJvbWlzZTxhbnk+fVxuICovXG5leHBvcnQgY29uc3QgZ2V0Rmlyc3RLZXkgPSAoc3RvcmUsIHJhbmdlID0gbnVsbCkgPT4gcXVlcnlGaXJzdChzdG9yZSwgcmFuZ2UsICduZXh0JylcblxuLyoqXG4gKiBAdHlwZWRlZiBLZXlWYWx1ZVBhaXJcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAcHJvcGVydHkge2FueX0gayBrZXlcbiAqIEBwcm9wZXJ0eSB7YW55fSB2IFZhbHVlXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge0lEQk9iamVjdFN0b3JlfSBzdG9yZVxuICogQHBhcmFtIHtJREJLZXlSYW5nZX0gW3JhbmdlXVxuICogQHBhcmFtIHtudW1iZXJ9IFtsaW1pdF1cbiAqIEByZXR1cm4ge1Byb21pc2U8QXJyYXk8S2V5VmFsdWVQYWlyPj59XG4gKi9cbmV4cG9ydCBjb25zdCBnZXRBbGxLZXlzVmFsdWVzID0gKHN0b3JlLCByYW5nZSwgbGltaXQpID0+XG4gIC8vIEB0cy1pZ25vcmVcbiAgcHJvbWlzZS5hbGwoW2dldEFsbEtleXMoc3RvcmUsIHJhbmdlLCBsaW1pdCksIGdldEFsbChzdG9yZSwgcmFuZ2UsIGxpbWl0KV0pLnRoZW4oKFtrcywgdnNdKSA9PiBrcy5tYXAoKGssIGkpID0+ICh7IGssIHY6IHZzW2ldIH0pKSlcblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gcmVxdWVzdFxuICogQHBhcmFtIHtmdW5jdGlvbihJREJDdXJzb3JXaXRoVmFsdWUpOnZvaWR8Ym9vbGVhbnxQcm9taXNlPHZvaWR8Ym9vbGVhbj59IGZcbiAqIEByZXR1cm4ge1Byb21pc2U8dm9pZD59XG4gKi9cbmNvbnN0IGl0ZXJhdGVPblJlcXVlc3QgPSAocmVxdWVzdCwgZikgPT4gcHJvbWlzZS5jcmVhdGUoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICByZXF1ZXN0Lm9uZXJyb3IgPSByZWplY3RcbiAgLyoqXG4gICAqIEBwYXJhbSB7YW55fSBldmVudFxuICAgKi9cbiAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSBhc3luYyBldmVudCA9PiB7XG4gICAgY29uc3QgY3Vyc29yID0gZXZlbnQudGFyZ2V0LnJlc3VsdFxuICAgIGlmIChjdXJzb3IgPT09IG51bGwgfHwgKGF3YWl0IGYoY3Vyc29yKSkgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZSgpXG4gICAgfVxuICAgIGN1cnNvci5jb250aW51ZSgpXG4gIH1cbn0pXG5cbi8qKlxuICogSXRlcmF0ZSBvbiBrZXlzIGFuZCB2YWx1ZXNcbiAqIEBwYXJhbSB7SURCT2JqZWN0U3RvcmV9IHN0b3JlXG4gKiBAcGFyYW0ge0lEQktleVJhbmdlfG51bGx9IGtleXJhbmdlXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKGFueSxhbnkpOnZvaWR8Ym9vbGVhbnxQcm9taXNlPHZvaWR8Ym9vbGVhbj59IGYgQ2FsbGJhY2sgdGhhdCByZWNlaXZlcyAodmFsdWUsIGtleSlcbiAqIEBwYXJhbSB7J25leHQnfCdwcmV2J3wnbmV4dHVuaXF1ZSd8J3ByZXZ1bmlxdWUnfSBkaXJlY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IGl0ZXJhdGUgPSAoc3RvcmUsIGtleXJhbmdlLCBmLCBkaXJlY3Rpb24gPSAnbmV4dCcpID0+XG4gIGl0ZXJhdGVPblJlcXVlc3Qoc3RvcmUub3BlbkN1cnNvcihrZXlyYW5nZSwgZGlyZWN0aW9uKSwgY3Vyc29yID0+IGYoY3Vyc29yLnZhbHVlLCBjdXJzb3Iua2V5KSlcblxuLyoqXG4gKiBJdGVyYXRlIG9uIHRoZSBrZXlzIChubyB2YWx1ZXMpXG4gKlxuICogQHBhcmFtIHtJREJPYmplY3RTdG9yZX0gc3RvcmVcbiAqIEBwYXJhbSB7SURCS2V5UmFuZ2V8bnVsbH0ga2V5cmFuZ2VcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oYW55KTp2b2lkfGJvb2xlYW58UHJvbWlzZTx2b2lkfGJvb2xlYW4+fSBmIGNhbGxiYWNrIHRoYXQgcmVjZWl2ZXMgdGhlIGtleVxuICogQHBhcmFtIHsnbmV4dCd8J3ByZXYnfCduZXh0dW5pcXVlJ3wncHJldnVuaXF1ZSd9IGRpcmVjdGlvblxuICovXG5leHBvcnQgY29uc3QgaXRlcmF0ZUtleXMgPSAoc3RvcmUsIGtleXJhbmdlLCBmLCBkaXJlY3Rpb24gPSAnbmV4dCcpID0+XG4gIGl0ZXJhdGVPblJlcXVlc3Qoc3RvcmUub3BlbktleUN1cnNvcihrZXlyYW5nZSwgZGlyZWN0aW9uKSwgY3Vyc29yID0+IGYoY3Vyc29yLmtleSkpXG5cbi8qKlxuICogT3BlbiBzdG9yZSBmcm9tIHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge0lEQlRyYW5zYWN0aW9ufSB0XG4gKiBAcGFyYW0ge1N0cmluZ30gc3RvcmVcbiAqIEByZXR1cm5zIHtJREJPYmplY3RTdG9yZX1cbiAqL1xuZXhwb3J0IGNvbnN0IGdldFN0b3JlID0gKHQsIHN0b3JlKSA9PiB0Lm9iamVjdFN0b3JlKHN0b3JlKVxuXG4vKipcbiAqIEBwYXJhbSB7YW55fSBsb3dlclxuICogQHBhcmFtIHthbnl9IHVwcGVyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGxvd2VyT3BlblxuICogQHBhcmFtIHtib29sZWFufSB1cHBlck9wZW5cbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZUlEQktleVJhbmdlQm91bmQgPSAobG93ZXIsIHVwcGVyLCBsb3dlck9wZW4sIHVwcGVyT3BlbikgPT4gSURCS2V5UmFuZ2UuYm91bmQobG93ZXIsIHVwcGVyLCBsb3dlck9wZW4sIHVwcGVyT3BlbilcblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gdXBwZXJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gdXBwZXJPcGVuXG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVJREJLZXlSYW5nZVVwcGVyQm91bmQgPSAodXBwZXIsIHVwcGVyT3BlbikgPT4gSURCS2V5UmFuZ2UudXBwZXJCb3VuZCh1cHBlciwgdXBwZXJPcGVuKVxuXG4vKipcbiAqIEBwYXJhbSB7YW55fSBsb3dlclxuICogQHBhcmFtIHtib29sZWFufSBsb3dlck9wZW5cbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZUlEQktleVJhbmdlTG93ZXJCb3VuZCA9IChsb3dlciwgbG93ZXJPcGVuKSA9PiBJREJLZXlSYW5nZS5sb3dlckJvdW5kKGxvd2VyLCBsb3dlck9wZW4pXG5cbi8qIGM4IGlnbm9yZSBzdG9wICovXG4iLCAiaW1wb3J0ICogYXMgWSBmcm9tICd5anMnXG5pbXBvcnQgKiBhcyBpZGIgZnJvbSAnbGliMC9pbmRleGVkZGInXG5pbXBvcnQgKiBhcyBwcm9taXNlIGZyb20gJ2xpYjAvcHJvbWlzZSdcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdsaWIwL29ic2VydmFibGUnXG5cbmNvbnN0IGN1c3RvbVN0b3JlTmFtZSA9ICdjdXN0b20nXG5jb25zdCB1cGRhdGVzU3RvcmVOYW1lID0gJ3VwZGF0ZXMnXG5cbmV4cG9ydCBjb25zdCBQUkVGRVJSRURfVFJJTV9TSVpFID0gNTAwXG5cbi8qKlxuICogQHBhcmFtIHtJbmRleGVkZGJQZXJzaXN0ZW5jZX0gaWRiUGVyc2lzdGVuY2VcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oSURCT2JqZWN0U3RvcmUpOnZvaWR9IFtiZWZvcmVBcHBseVVwZGF0ZXNDYWxsYmFja11cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oSURCT2JqZWN0U3RvcmUpOnZvaWR9IFthZnRlckFwcGx5VXBkYXRlc0NhbGxiYWNrXVxuICovXG5leHBvcnQgY29uc3QgZmV0Y2hVcGRhdGVzID0gKGlkYlBlcnNpc3RlbmNlLCBiZWZvcmVBcHBseVVwZGF0ZXNDYWxsYmFjayA9ICgpID0+IHt9LCBhZnRlckFwcGx5VXBkYXRlc0NhbGxiYWNrID0gKCkgPT4ge30pID0+IHtcbiAgY29uc3QgW3VwZGF0ZXNTdG9yZV0gPSBpZGIudHJhbnNhY3QoLyoqIEB0eXBlIHtJREJEYXRhYmFzZX0gKi8gKGlkYlBlcnNpc3RlbmNlLmRiKSwgW3VwZGF0ZXNTdG9yZU5hbWVdKSAvLyAsICdyZWFkb25seScpXG4gIHJldHVybiBpZGIuZ2V0QWxsKHVwZGF0ZXNTdG9yZSwgaWRiLmNyZWF0ZUlEQktleVJhbmdlTG93ZXJCb3VuZChpZGJQZXJzaXN0ZW5jZS5fZGJyZWYsIGZhbHNlKSkudGhlbih1cGRhdGVzID0+IHtcbiAgICBpZiAoIWlkYlBlcnNpc3RlbmNlLl9kZXN0cm95ZWQpIHtcbiAgICAgIGJlZm9yZUFwcGx5VXBkYXRlc0NhbGxiYWNrKHVwZGF0ZXNTdG9yZSlcbiAgICAgIFkudHJhbnNhY3QoaWRiUGVyc2lzdGVuY2UuZG9jLCAoKSA9PiB7XG4gICAgICAgIHVwZGF0ZXMuZm9yRWFjaCh2YWwgPT4gWS5hcHBseVVwZGF0ZShpZGJQZXJzaXN0ZW5jZS5kb2MsIHZhbCkpXG4gICAgICB9LCBpZGJQZXJzaXN0ZW5jZSwgZmFsc2UpXG4gICAgICBhZnRlckFwcGx5VXBkYXRlc0NhbGxiYWNrKHVwZGF0ZXNTdG9yZSlcbiAgICB9XG4gIH0pXG4gICAgLnRoZW4oKCkgPT4gaWRiLmdldExhc3RLZXkodXBkYXRlc1N0b3JlKS50aGVuKGxhc3RLZXkgPT4geyBpZGJQZXJzaXN0ZW5jZS5fZGJyZWYgPSBsYXN0S2V5ICsgMSB9KSlcbiAgICAudGhlbigoKSA9PiBpZGIuY291bnQodXBkYXRlc1N0b3JlKS50aGVuKGNudCA9PiB7IGlkYlBlcnNpc3RlbmNlLl9kYnNpemUgPSBjbnQgfSkpXG4gICAgLnRoZW4oKCkgPT4gdXBkYXRlc1N0b3JlKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7SW5kZXhlZGRiUGVyc2lzdGVuY2V9IGlkYlBlcnNpc3RlbmNlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGZvcmNlU3RvcmVcbiAqL1xuZXhwb3J0IGNvbnN0IHN0b3JlU3RhdGUgPSAoaWRiUGVyc2lzdGVuY2UsIGZvcmNlU3RvcmUgPSB0cnVlKSA9PlxuICBmZXRjaFVwZGF0ZXMoaWRiUGVyc2lzdGVuY2UpXG4gICAgLnRoZW4odXBkYXRlc1N0b3JlID0+IHtcbiAgICAgIGlmIChmb3JjZVN0b3JlIHx8IGlkYlBlcnNpc3RlbmNlLl9kYnNpemUgPj0gUFJFRkVSUkVEX1RSSU1fU0laRSkge1xuICAgICAgICBpZGIuYWRkQXV0b0tleSh1cGRhdGVzU3RvcmUsIFkuZW5jb2RlU3RhdGVBc1VwZGF0ZShpZGJQZXJzaXN0ZW5jZS5kb2MpKVxuICAgICAgICAgIC50aGVuKCgpID0+IGlkYi5kZWwodXBkYXRlc1N0b3JlLCBpZGIuY3JlYXRlSURCS2V5UmFuZ2VVcHBlckJvdW5kKGlkYlBlcnNpc3RlbmNlLl9kYnJlZiwgdHJ1ZSkpKVxuICAgICAgICAgIC50aGVuKCgpID0+IGlkYi5jb3VudCh1cGRhdGVzU3RvcmUpLnRoZW4oY250ID0+IHsgaWRiUGVyc2lzdGVuY2UuX2Ric2l6ZSA9IGNudCB9KSlcbiAgICAgIH1cbiAgICB9KVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKi9cbmV4cG9ydCBjb25zdCBjbGVhckRvY3VtZW50ID0gbmFtZSA9PiBpZGIuZGVsZXRlREIobmFtZSlcblxuLyoqXG4gKiBAZXh0ZW5kcyBPYnNlcnZhYmxlPHN0cmluZz5cbiAqL1xuZXhwb3J0IGNsYXNzIEluZGV4ZWRkYlBlcnNpc3RlbmNlIGV4dGVuZHMgT2JzZXJ2YWJsZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0ge1kuRG9jfSBkb2NcbiAgICovXG4gIGNvbnN0cnVjdG9yIChuYW1lLCBkb2MpIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy5kb2MgPSBkb2NcbiAgICB0aGlzLm5hbWUgPSBuYW1lXG4gICAgdGhpcy5fZGJyZWYgPSAwXG4gICAgdGhpcy5fZGJzaXplID0gMFxuICAgIHRoaXMuX2Rlc3Ryb3llZCA9IGZhbHNlXG4gICAgLyoqXG4gICAgICogQHR5cGUge0lEQkRhdGFiYXNlfG51bGx9XG4gICAgICovXG4gICAgdGhpcy5kYiA9IG51bGxcbiAgICB0aGlzLnN5bmNlZCA9IGZhbHNlXG4gICAgdGhpcy5fZGIgPSBpZGIub3BlbkRCKG5hbWUsIGRiID0+XG4gICAgICBpZGIuY3JlYXRlU3RvcmVzKGRiLCBbXG4gICAgICAgIFsndXBkYXRlcycsIHsgYXV0b0luY3JlbWVudDogdHJ1ZSB9XSxcbiAgICAgICAgWydjdXN0b20nXVxuICAgICAgXSlcbiAgICApXG4gICAgLyoqXG4gICAgICogQHR5cGUge1Byb21pc2U8SW5kZXhlZGRiUGVyc2lzdGVuY2U+fVxuICAgICAqL1xuICAgIHRoaXMud2hlblN5bmNlZCA9IHByb21pc2UuY3JlYXRlKHJlc29sdmUgPT4gdGhpcy5vbignc3luY2VkJywgKCkgPT4gcmVzb2x2ZSh0aGlzKSkpXG5cbiAgICB0aGlzLl9kYi50aGVuKGRiID0+IHtcbiAgICAgIHRoaXMuZGIgPSBkYlxuICAgICAgLyoqXG4gICAgICAgKiBAcGFyYW0ge0lEQk9iamVjdFN0b3JlfSB1cGRhdGVzU3RvcmVcbiAgICAgICAqL1xuICAgICAgY29uc3QgYmVmb3JlQXBwbHlVcGRhdGVzQ2FsbGJhY2sgPSAodXBkYXRlc1N0b3JlKSA9PiBpZGIuYWRkQXV0b0tleSh1cGRhdGVzU3RvcmUsIFkuZW5jb2RlU3RhdGVBc1VwZGF0ZShkb2MpKVxuICAgICAgY29uc3QgYWZ0ZXJBcHBseVVwZGF0ZXNDYWxsYmFjayA9ICgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuX2Rlc3Ryb3llZCkgcmV0dXJuIHRoaXNcbiAgICAgICAgdGhpcy5zeW5jZWQgPSB0cnVlXG4gICAgICAgIHRoaXMuZW1pdCgnc3luY2VkJywgW3RoaXNdKVxuICAgICAgfVxuICAgICAgZmV0Y2hVcGRhdGVzKHRoaXMsIGJlZm9yZUFwcGx5VXBkYXRlc0NhbGxiYWNrLCBhZnRlckFwcGx5VXBkYXRlc0NhbGxiYWNrKVxuICAgIH0pXG4gICAgLyoqXG4gICAgICogVGltZW91dCBpbiBtcyB1bnRpbGwgZGF0YSBpcyBtZXJnZWQgYW5kIHBlcnNpc3RlZCBpbiBpZGIuXG4gICAgICovXG4gICAgdGhpcy5fc3RvcmVUaW1lb3V0ID0gMTAwMFxuICAgIC8qKlxuICAgICAqIEB0eXBlIHthbnl9XG4gICAgICovXG4gICAgdGhpcy5fc3RvcmVUaW1lb3V0SWQgPSBudWxsXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtVaW50OEFycmF5fSB1cGRhdGVcbiAgICAgKiBAcGFyYW0ge2FueX0gb3JpZ2luXG4gICAgICovXG4gICAgdGhpcy5fc3RvcmVVcGRhdGUgPSAodXBkYXRlLCBvcmlnaW4pID0+IHtcbiAgICAgIGlmICh0aGlzLmRiICYmIG9yaWdpbiAhPT0gdGhpcykge1xuICAgICAgICBjb25zdCBbdXBkYXRlc1N0b3JlXSA9IGlkYi50cmFuc2FjdCgvKiogQHR5cGUge0lEQkRhdGFiYXNlfSAqLyAodGhpcy5kYiksIFt1cGRhdGVzU3RvcmVOYW1lXSlcbiAgICAgICAgaWRiLmFkZEF1dG9LZXkodXBkYXRlc1N0b3JlLCB1cGRhdGUpXG4gICAgICAgIGlmICgrK3RoaXMuX2Ric2l6ZSA+PSBQUkVGRVJSRURfVFJJTV9TSVpFKSB7XG4gICAgICAgICAgLy8gZGVib3VuY2Ugc3RvcmUgY2FsbFxuICAgICAgICAgIGlmICh0aGlzLl9zdG9yZVRpbWVvdXRJZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3N0b3JlVGltZW91dElkKVxuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9zdG9yZVRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgc3RvcmVTdGF0ZSh0aGlzLCBmYWxzZSlcbiAgICAgICAgICAgIHRoaXMuX3N0b3JlVGltZW91dElkID0gbnVsbFxuICAgICAgICAgIH0sIHRoaXMuX3N0b3JlVGltZW91dClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBkb2Mub24oJ3VwZGF0ZScsIHRoaXMuX3N0b3JlVXBkYXRlKVxuICAgIHRoaXMuZGVzdHJveSA9IHRoaXMuZGVzdHJveS5iaW5kKHRoaXMpXG4gICAgZG9jLm9uKCdkZXN0cm95JywgdGhpcy5kZXN0cm95KVxuICB9XG5cbiAgZGVzdHJveSAoKSB7XG4gICAgaWYgKHRoaXMuX3N0b3JlVGltZW91dElkKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5fc3RvcmVUaW1lb3V0SWQpXG4gICAgfVxuICAgIHRoaXMuZG9jLm9mZigndXBkYXRlJywgdGhpcy5fc3RvcmVVcGRhdGUpXG4gICAgdGhpcy5kb2Mub2ZmKCdkZXN0cm95JywgdGhpcy5kZXN0cm95KVxuICAgIHRoaXMuX2Rlc3Ryb3llZCA9IHRydWVcbiAgICByZXR1cm4gdGhpcy5fZGIudGhlbihkYiA9PiB7XG4gICAgICBkYi5jbG9zZSgpXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXN0cm95cyB0aGlzIGluc3RhbmNlIGFuZCByZW1vdmVzIGFsbCBkYXRhIGZyb20gaW5kZXhlZGRiLlxuICAgKlxuICAgKiBAcmV0dXJuIHtQcm9taXNlPHZvaWQ+fVxuICAgKi9cbiAgY2xlYXJEYXRhICgpIHtcbiAgICByZXR1cm4gdGhpcy5kZXN0cm95KCkudGhlbigoKSA9PiB7XG4gICAgICBpZGIuZGVsZXRlREIodGhpcy5uYW1lKVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtTdHJpbmcgfCBudW1iZXIgfCBBcnJheUJ1ZmZlciB8IERhdGV9IGtleVxuICAgKiBAcmV0dXJuIHtQcm9taXNlPFN0cmluZyB8IG51bWJlciB8IEFycmF5QnVmZmVyIHwgRGF0ZSB8IGFueT59XG4gICAqL1xuICBnZXQgKGtleSkge1xuICAgIHJldHVybiB0aGlzLl9kYi50aGVuKGRiID0+IHtcbiAgICAgIGNvbnN0IFtjdXN0b21dID0gaWRiLnRyYW5zYWN0KGRiLCBbY3VzdG9tU3RvcmVOYW1lXSwgJ3JlYWRvbmx5JylcbiAgICAgIHJldHVybiBpZGIuZ2V0KGN1c3RvbSwga2V5KVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtTdHJpbmcgfCBudW1iZXIgfCBBcnJheUJ1ZmZlciB8IERhdGV9IGtleVxuICAgKiBAcGFyYW0ge1N0cmluZyB8IG51bWJlciB8IEFycmF5QnVmZmVyIHwgRGF0ZX0gdmFsdWVcbiAgICogQHJldHVybiB7UHJvbWlzZTxTdHJpbmcgfCBudW1iZXIgfCBBcnJheUJ1ZmZlciB8IERhdGU+fVxuICAgKi9cbiAgc2V0IChrZXksIHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RiLnRoZW4oZGIgPT4ge1xuICAgICAgY29uc3QgW2N1c3RvbV0gPSBpZGIudHJhbnNhY3QoZGIsIFtjdXN0b21TdG9yZU5hbWVdKVxuICAgICAgcmV0dXJuIGlkYi5wdXQoY3VzdG9tLCB2YWx1ZSwga2V5KVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtTdHJpbmcgfCBudW1iZXIgfCBBcnJheUJ1ZmZlciB8IERhdGV9IGtleVxuICAgKiBAcmV0dXJuIHtQcm9taXNlPHVuZGVmaW5lZD59XG4gICAqL1xuICBkZWwgKGtleSkge1xuICAgIHJldHVybiB0aGlzLl9kYi50aGVuKGRiID0+IHtcbiAgICAgIGNvbnN0IFtjdXN0b21dID0gaWRiLnRyYW5zYWN0KGRiLCBbY3VzdG9tU3RvcmVOYW1lXSlcbiAgICAgIHJldHVybiBpZGIuZGVsKGN1c3RvbSwga2V5KVxuICAgIH0pXG4gIH1cbn1cbiIsICJpbXBvcnQgUGVlcmRyYWZ0UGx1Z2luIGZyb20gXCJzcmMvcGVlcmRyYWZ0UGx1Z2luXCJcblxuZXhwb3J0IGNvbnN0IGFkZElzU2hhcmVkQ2xhc3MgPSAocGF0aDogc3RyaW5nLCBwbHVnaW46IFBlZXJkcmFmdFBsdWdpbikgPT4ge1xuICBjb25zdCBmaWxlRXhwbG9yZXJzID0gcGx1Z2luLmFwcC53b3Jrc3BhY2UuZ2V0TGVhdmVzT2ZUeXBlKCdmaWxlLWV4cGxvcmVyJylcbiAgZmlsZUV4cGxvcmVycy5mb3JFYWNoKGZpbGVFeHBsb3JlciA9PiB7XG4gICAgLy9AdHMtZXhwZWN0LWVycm9yXG4gICAgY29uc3QgZmlsZUl0ZW0gPSBmaWxlRXhwbG9yZXIudmlldy5maWxlSXRlbXNbcGF0aF07XG4gICAgaWYgKCFmaWxlSXRlbSkgcmV0dXJuXG4gICAgY29uc3QgZWwgPSBmaWxlSXRlbS5pbm5lckVsIGFzIEhUTUxFbGVtZW50XG4gICAgZWwuYWRkQ2xhc3MoJ3BkLWV4cGxvcmVyLXNoYXJlZCcpXG4gIH0pXG59XG5cbmV4cG9ydCBjb25zdCByZW1vdmVJc1NoYXJlZENsYXNzID0gKHBhdGg6IHN0cmluZywgcGx1Z2luOiBQZWVyZHJhZnRQbHVnaW4pID0+IHtcbiAgY29uc3QgZmlsZUV4cGxvcmVycyA9IHBsdWdpbi5hcHAud29ya3NwYWNlLmdldExlYXZlc09mVHlwZSgnZmlsZS1leHBsb3JlcicpXG4gIGZpbGVFeHBsb3JlcnMuZm9yRWFjaChmaWxlRXhwbG9yZXIgPT4ge1xuICAgIC8vQHRzLWV4cGVjdC1lcnJvclxuICAgIGNvbnN0IGZpbGVJdGVtID0gZmlsZUV4cGxvcmVyLnZpZXcuZmlsZUl0ZW1zW3BhdGhdO1xuICAgIGlmICghZmlsZUl0ZW0pIHJldHVyblxuICAgIGNvbnN0IGVsID0gZmlsZUl0ZW0uaW5uZXJFbCBhcyBIVE1MRWxlbWVudFxuICAgIGVsLnJlbW92ZUNsYXNzKCdwZC1leHBsb3Jlci1zaGFyZWQnKVxuICB9KVxufSIsICJpbXBvcnQgeyBUQWJzdHJhY3RGaWxlLCBURmlsZSwgVEZvbGRlciwgbm9ybWFsaXplUGF0aCB9IGZyb20gXCJvYnNpZGlhblwiO1xuaW1wb3J0ICogYXMgcGF0aCBmcm9tICdwYXRoJ1xuaW1wb3J0ICogYXMgWSBmcm9tICd5anMnXG5pbXBvcnQgeyBzaG93Tm90aWNlIH0gZnJvbSBcIi4uL3VpXCI7XG5pbXBvcnQgeyBjYWxjdWxhdGVIYXNoLCBnZW5lcmF0ZVJhbmRvbVN0cmluZywgc2VyaWFsaXplIH0gZnJvbSBcIi4uL3Rvb2xzXCI7XG5pbXBvcnQgeyBTaGFyZWRFbnRpdHkgfSBmcm9tIFwiLi9zaGFyZWRFbnRpdHlcIjtcbmltcG9ydCBQZWVyRHJhZnRQbHVnaW4gZnJvbSBcInNyYy9tYWluXCI7XG5pbXBvcnQgeyBTaGFyZWREb2N1bWVudCB9IGZyb20gXCIuL3NoYXJlZERvY3VtZW50XCI7XG5pbXBvcnQgeyBQZXJtYW5lbnRTaGFyZUZvbGRlciB9IGZyb20gXCJzcmMvcGVybWFuZW50U2hhcmVTdG9yZVwiO1xuaW1wb3J0IHsgSW5kZXhlZGRiUGVyc2lzdGVuY2UgfSBmcm9tIFwieS1pbmRleGVkZGJcIjtcbmltcG9ydCB7IGFkZElzU2hhcmVkQ2xhc3MsIHJlbW92ZUlzU2hhcmVkQ2xhc3MgfSBmcm9tIFwic3JjL3dvcmtzcGFjZS9leHBsb3JlclZpZXdcIjtcbmltcG9ydCB7IGFkZCwgZ2V0Rm9sZGVyQnlQYXRoLCBtb3ZlRm9sZGVyLCByZW1vdmVGb2xkZXIgfSBmcm9tIFwic3JjL3Blcm1hbmVudFNoYXJlU3RvcmVGU1wiO1xuXG5jb25zdCBoYW5kbGVVcGRhdGUgPSAoZXY6IFkuWU1hcEV2ZW50PHVua25vd24+LCB0eDogWS5UcmFuc2FjdGlvbiwgZm9sZGVyOiBTaGFyZWRGb2xkZXIsIHBsdWdpbjogUGVlckRyYWZ0UGx1Z2luKSA9PiB7XG5cbiAgaWYgKCEoW3BsdWdpbi5zZXJ2ZXJTeW5jLCBmb2xkZXIud2ViUlRDUHJvdmlkZXI/LnJvb21dLmNvbnRhaW5zKHR4Lm9yaWdpbikpKSByZXR1cm5cblxuICBjb25zdCBjaGFuZ2VkS2V5cyA9IGV2LmNoYW5nZXMua2V5c1xuXG4gIGNoYW5nZWRLZXlzLmZvckVhY2goYXN5bmMgKGRhdGEsIGtleSkgPT4ge1xuICAgIHBsdWdpbi5sb2coXCJBY3Rpb246IFwiICsgZGF0YS5hY3Rpb24gKyBcImZvciBcIiArIGtleSArIFwiIC0tPiBcIiArIHR4LmRvYy5nZXRNYXAoXCJkb2N1bWVudHNcIikuZ2V0KGtleSkgYXMgc3RyaW5nKVxuXG4gICAgaWYgKGRhdGEuYWN0aW9uID09PSBcImFkZFwiKSB7XG4gICAgICBjb25zdCByZWxhdGl2ZVBhdGggPSB0eC5kb2MuZ2V0TWFwKFwiZG9jdW1lbnRzXCIpLmdldChrZXkpIGFzIHN0cmluZ1xuICAgICAgY29uc3QgYWJzb2x1dGVQYXRoID0gcGF0aC5qb2luKGZvbGRlci5wYXRoLCByZWxhdGl2ZVBhdGgpXG4gICAgICBjb25zdCBmaWxlID0gcGx1Z2luLmFwcC52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgoYWJzb2x1dGVQYXRoKVxuICAgICAgaWYgKGZpbGUpIHtcblxuICAgICAgICBzaG93Tm90aWNlKFwiRmlsZSBcIiArIGZpbGUucGF0aCArIFwiIGFscmVhZHkgZXhpc3RzLiBSZW5hbWluZy5cIilcblxuICAgICAgICBjb25zdCBhbHRlcmVkUGF0aCA9IHBhdGguam9pbihwYXRoLmRpcm5hbWUocmVsYXRpdmVQYXRoKSwgcGF0aC5iYXNlbmFtZShyZWxhdGl2ZVBhdGgsIHBhdGguZXh0bmFtZShyZWxhdGl2ZVBhdGgpKSArIFwiX1wiICsgZ2VuZXJhdGVSYW5kb21TdHJpbmcoKSArIHBhdGguZXh0bmFtZShyZWxhdGl2ZVBhdGgpKVxuICAgICAgICBjb25zdCBhbHRlcmVkQWJzb2x1dGVQYXRoID0gcGF0aC5qb2luKGZvbGRlci5yb290LnBhdGgsIGFsdGVyZWRQYXRoKVxuICAgICAgICBmb2xkZXIuZ2V0RG9jc0ZyYWdtZW50KCkuc2V0KGtleSwgYWx0ZXJlZFBhdGgpXG4gICAgICAgIFNoYXJlZERvY3VtZW50LmZyb21JZEFuZFBhdGgoa2V5LCBhbHRlcmVkQWJzb2x1dGVQYXRoLCBwbHVnaW4pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzaG93Tm90aWNlKFwiQ3JlYXRpbmcgbmV3IHNoYXJlZCBkb2N1bWVudDogXCIgKyBhYnNvbHV0ZVBhdGgpXG4gICAgICAgIGF3YWl0IFNoYXJlZEZvbGRlci5nZXRPckNyZWF0ZVBhdGgocGF0aC5wYXJzZShhYnNvbHV0ZVBhdGgpLmRpciwgcGx1Z2luKVxuICAgICAgICBhd2FpdCBTaGFyZWREb2N1bWVudC5mcm9tSWRBbmRQYXRoKGtleSwgYWJzb2x1dGVQYXRoLCBwbHVnaW4pXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChkYXRhLmFjdGlvbiA9PT0gXCJ1cGRhdGVcIikge1xuICAgICAgY29uc3QgbmV3UGF0aCA9IHR4LmRvYy5nZXRNYXAoXCJkb2N1bWVudHNcIikuZ2V0KGtleSkgYXMgc3RyaW5nXG4gICAgICBjb25zdCBkb2N1bWVudCA9IFNoYXJlZERvY3VtZW50LmZpbmRCeUlkKGtleSlcbiAgICAgIGlmICghZG9jdW1lbnQpIHJldHVyblxuICAgICAgcGx1Z2luLmxvZyhcIlVwZGF0ZSBcIiArIGRvY3VtZW50LnBhdGggKyBcIiAgIFwiICsga2V5KVxuICAgICAgY29uc3QgZm9sZGVyID0gU2hhcmVkRm9sZGVyLmdldFNoYXJlZEZvbGRlckZvclN1YlBhdGgoZG9jdW1lbnQucGF0aClcbiAgICAgIGlmICghZm9sZGVyKSByZXR1cm5cbiAgICAgIGxldCBuZXdBYnNvbHV0ZVBhdGggPSBwYXRoLmpvaW4oZm9sZGVyLnJvb3QucGF0aCwgbmV3UGF0aClcbiAgICAgIGF3YWl0IFNoYXJlZEZvbGRlci5nZXRPckNyZWF0ZVBhdGgocGF0aC5wYXJzZShuZXdBYnNvbHV0ZVBhdGgpLmRpciwgcGx1Z2luKVxuXG4gICAgICBjb25zdCBhbHJlYWR5RXhpc3RzID0gU2hhcmVkRG9jdW1lbnQuZmluZEJ5UGF0aChuZXdBYnNvbHV0ZVBhdGgpXG4gICAgICBpZiAoYWxyZWFkeUV4aXN0cykge1xuICAgICAgICBzaG93Tm90aWNlKFwiRmlsZSBcIiArIG5ld1BhdGggKyBcIiBhbHJlYWR5IGV4aXN0cy4gUmVuYW1pbmcuXCIpXG4gICAgICAgIGNvbnN0IGFsdGVyZWRQYXRoID0gcGF0aC5qb2luKHBhdGguZGlybmFtZShuZXdQYXRoKSwgcGF0aC5iYXNlbmFtZShuZXdQYXRoLCBwYXRoLmV4dG5hbWUobmV3UGF0aCkpICsgXCJfXCIgKyBnZW5lcmF0ZVJhbmRvbVN0cmluZygpICsgcGF0aC5leHRuYW1lKG5ld1BhdGgpKVxuICAgICAgICBjb25zdCBhbHRlcmVkQWJzb2x1dGVQYXRoID0gcGF0aC5qb2luKGZvbGRlci5yb290LnBhdGgsIGFsdGVyZWRQYXRoKVxuICAgICAgICBmb2xkZXIuZ2V0RG9jc0ZyYWdtZW50KCkuc2V0KGtleSwgYWx0ZXJlZFBhdGgpXG4gICAgICAgIFNoYXJlZERvY3VtZW50LmZyb21JZEFuZFBhdGgoa2V5LCBhbHRlcmVkQWJzb2x1dGVQYXRoLCBwbHVnaW4pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhd2FpdCBwbHVnaW4uYXBwLmZpbGVNYW5hZ2VyLnJlbmFtZUZpbGUoZG9jdW1lbnQuZmlsZSwgbmV3QWJzb2x1dGVQYXRoKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZGF0YS5hY3Rpb24gPT09IFwiZGVsZXRlXCIpIHtcbiAgICAgIGNvbnN0IGRvY3VtZW50ID0gU2hhcmVkRG9jdW1lbnQuZmluZEJ5SWQoa2V5KVxuICAgICAgaWYgKCFkb2N1bWVudCkgcmV0dXJuXG4gICAgICBwbHVnaW4ubG9nKFwiRGVsZXRlIFwiICsgZG9jdW1lbnQucGF0aCArIFwiICAgXCIgKyBrZXkpXG4gICAgICBjb25zdCBmaWxlID0gcGx1Z2luLmFwcC52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgoZG9jdW1lbnQucGF0aClcbiAgICAgIGlmICghZmlsZSkgcmV0dXJuXG4gICAgICBwbHVnaW4uYXBwLnZhdWx0LmRlbGV0ZShmaWxlKVxuICAgIH1cbiAgfSlcbn1cblxuZXhwb3J0IGNsYXNzIFNoYXJlZEZvbGRlciBleHRlbmRzIFNoYXJlZEVudGl0eSB7XG5cbiAgcm9vdDogVEZvbGRlclxuICBwcm90ZWN0ZWQgc3RhdGljIF9zaGFyZWRFbnRpdGVzOiBBcnJheTxTaGFyZWRGb2xkZXI+ID0gbmV3IEFycmF5PFNoYXJlZEZvbGRlcj4oKVxuXG4gIHN0YXRpYyBhc3luYyBmcm9tVEZvbGRlcihyb290OiBURm9sZGVyLCBwbHVnaW46IFBlZXJEcmFmdFBsdWdpbikge1xuICAgIHNob3dOb3RpY2UoYEluaXRpdGlhbGl6aW5nIHNoYXJlIGZvciAke3Jvb3QucGF0aH0uYClcbiAgICBjb25zdCBmaWxlcyA9IHRoaXMuZ2V0QWxsRmlsZXNJbkZvbGRlcihyb290KVxuXG4gICAgLy8gY2hlY2sgaWYgZG9jcyBmb3Igc29tZSBvZiB0aGVtIGFyZSBhbHJlYWR5IHRoZXJlXG4gICAgZm9yIChjb25zdCBmaWxlIG9mIGZpbGVzKSB7XG4gICAgICBpZiAoU2hhcmVkRG9jdW1lbnQuZmluZEJ5UGF0aChmaWxlLnBhdGgpKSB7XG4gICAgICAgIHNob3dOb3RpY2UoXCJZb3UgY2FuIG5vdCBzaGFyZSBhIGRpcmVjdG9yeSB0aGF0IGFscmVhZHkgaGFzIHNoYXJlZCBmaWxlcyBpbiBpdCAocmlnaHQgbm93KS5cIilcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgZG9jcyA9IGF3YWl0IFByb21pc2UuYWxsKGZpbGVzLm1hcCgoZmlsZSkgPT4ge1xuICAgICAgcmV0dXJuIFNoYXJlZERvY3VtZW50LmZyb21URmlsZShmaWxlLCB7XG4gICAgICAgIHBlcm1hbmVudDogdHJ1ZVxuICAgICAgfSwgcGx1Z2luKVxuICAgIH0pKVxuXG4gICAgY29uc3QgZm9sZGVyID0gbmV3IFNoYXJlZEZvbGRlcihyb290LCBwbHVnaW4pXG5cbiAgICBmb3IgKGNvbnN0IGRvYyBvZiBkb2NzKSB7XG4gICAgICBpZiAoZG9jKSB7XG4gICAgICAgIGZvbGRlci5hZGREb2N1bWVudChkb2MpXG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9sZGVyLnlEb2MuZ2V0VGV4dChcIm9yaWdpbmFsRm9sZGVybmFtZVwiKS5pbnNlcnQoMCwgcm9vdC5uYW1lKVxuXG4gICAgYXdhaXQgZm9sZGVyLmluaXRTZXJ2ZXJZRG9jKClcblxuICAgIGF3YWl0IGFkZChmb2xkZXIsIHBsdWdpbilcbiAgICBhd2FpdCBmb2xkZXIuc3RhcnRJbmRleGVkREJTeW5jKClcbiAgICBmb2xkZXIuc3RhcnRXZWJSVENTeW5jKClcblxuICAgIG5hdmlnYXRvci5jbGlwYm9hcmQud3JpdGVUZXh0KHBsdWdpbi5zZXR0aW5ncy5iYXNlUGF0aCArICcvdGVhbS8nICsgZm9sZGVyLnNoYXJlSWQpXG4gICAgc2hvd05vdGljZShgRm9sZGVyICR7Zm9sZGVyLnBhdGh9IHdpdGggJHtkb2NzLmxlbmd0aH0gZG9jdW1lbnRzIHNoYXJlZC4gVVJMIGNvcGllZCB0byB5b3VyIGNsaXBib2FyZC5gLCAwKVxuXG4gICAgcmV0dXJuIGZvbGRlclxuICB9XG5cbiAgc3RhdGljIGFzeW5jIHJlY3JlYXRlKGZvbGRlcjogU2hhcmVkRm9sZGVyLCBwbHVnaW46IFBlZXJEcmFmdFBsdWdpbikge1xuICAgIGNvbnN0IGxvY2F0aW9uID0gZm9sZGVyLnJvb3QucGF0aFxuICAgIGF3YWl0IGZvbGRlci51bnNoYXJlKClcbiAgICBhd2FpdCBwbHVnaW4uYXBwLnZhdWx0LmRlbGV0ZShmb2xkZXIucm9vdCwgdHJ1ZSlcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5mcm9tU2hhcmVVUkwocGx1Z2luLnNldHRpbmdzLmJhc2VQYXRoICsgJy90ZWFtLycgKyBmb2xkZXIuc2hhcmVJZCwgcGx1Z2luLCBsb2NhdGlvbilcbiAgfVxuXG4gIHN0YXRpYyBhc3luYyBmcm9tU2hhcmVVUkwodXJsOiBzdHJpbmcsIHBsdWdpbjogUGVlckRyYWZ0UGx1Z2luLCBsb2NhdGlvbj86IHN0cmluZyk6IFByb21pc2U8U2hhcmVkRm9sZGVyIHwgdm9pZD4ge1xuICAgIGNvbnN0IGlkID0gdXJsLnNwbGl0KCcvJykucG9wKClcbiAgICBpZiAoIWlkIHx8ICFpZC5tYXRjaCgnXlswLTlhLWZdezh9LVswLTlhLWZdezR9LVswLTlhLWZdezR9LVswLTlhLWZdezR9LVswLTlhLWZdezEyfSQnKSkge1xuICAgICAgc2hvd05vdGljZShcIk5vIHZhbGlkIHBlZXJkcmFmdCBsaW5rXCIpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBsZXQgZm9sZGVyUGF0aCA9IGxvY2F0aW9uXG4gICAgY29uc3QgcHJlRmV0Y2hlZERvYyA9IGF3YWl0IHBsdWdpbi5zZXJ2ZXJTeW5jLnJlcXVlc3REb2N1bWVudChpZClcblxuXG4gICAgaWYgKCFsb2NhdGlvbikge1xuICAgICAgbGV0IGluaXRpYWxSb290TmFtZSA9IGBfcGVlcmRyYWZ0X3RlYW1fZm9sZGVyXyR7Z2VuZXJhdGVSYW5kb21TdHJpbmcoKX1gXG4gICAgICBjb25zdCBkb2NGb2xkZXJuYW1lID0gcHJlRmV0Y2hlZERvYy5nZXRUZXh0KFwib3JpZ2luYWxGb2xkZXJuYW1lXCIpLnRvU3RyaW5nKClcbiAgICAgIGlmIChkb2NGb2xkZXJuYW1lICE9ICcnKSB7XG4gICAgICAgIGNvbnN0IGZvbGRlckV4aXN0cyA9IHBsdWdpbi5hcHAudmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKHBhdGguam9pbihwbHVnaW4uc2V0dGluZ3Mucm9vdCwgZG9jRm9sZGVybmFtZSkpXG4gICAgICAgIGlmICghZm9sZGVyRXhpc3RzKSB7XG4gICAgICAgICAgaW5pdGlhbFJvb3ROYW1lID0gZG9jRm9sZGVybmFtZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGluaXRpYWxSb290TmFtZSA9IGBfcGVlcmRyYWZ0XyR7Z2VuZXJhdGVSYW5kb21TdHJpbmcoKX1fJHtkb2NGb2xkZXJuYW1lfWBcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb2xkZXJQYXRoID0gcGF0aC5qb2luKHBsdWdpbi5zZXR0aW5ncy5yb290LCBpbml0aWFsUm9vdE5hbWUpXG4gICAgfVxuXG4gICAgY29uc3QgZm9sZGVyID0gYXdhaXQgU2hhcmVkRm9sZGVyLmdldE9yQ3JlYXRlUGF0aChmb2xkZXJQYXRoISwgcGx1Z2luKVxuXG4gICAgaWYgKCFmb2xkZXIpIHtcbiAgICAgIHJldHVybiBzaG93Tm90aWNlKFwiQ291bGQgbm90IGNyZWF0ZSBmb2xkZXIgXCIgKyBmb2xkZXJQYXRoKVxuICAgIH07XG5cbiAgICBjb25zdCBwYXRoczogQXJyYXk8c3RyaW5nPiA9IFtdXG4gICAgY29uc3QgZG9jdW1lbnRNYXAgPSBwcmVGZXRjaGVkRG9jLmdldE1hcChcImRvY3VtZW50c1wiKSBhcyBZLk1hcDxzdHJpbmc+XG5cbiAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGRvY3VtZW50TWFwLmVudHJpZXMoKSkge1xuICAgICAgbGV0IGRvY1BhdGggPSBlbnRyeVsxXVxuICAgICAgLy8gcmVwYWlyIGluY29uc2lzdGVudCBzZXJ2ZXIgdmVyc2lvblxuICAgICAgaWYgKHBhdGhzLmNvbnRhaW5zKG5vcm1hbGl6ZVBhdGgoZG9jUGF0aCkpKSB7XG4gICAgICAgIGRvY1BhdGggPSBub3JtYWxpemVQYXRoKHBhdGguam9pbihwYXRoLmRpcm5hbWUoZG9jUGF0aCksIHBhdGguYmFzZW5hbWUoZG9jUGF0aCwgcGF0aC5leHRuYW1lKGRvY1BhdGgpKSArIFwiX1wiICsgZ2VuZXJhdGVSYW5kb21TdHJpbmcoKSArIHBhdGguZXh0bmFtZShkb2NQYXRoKSkpXG4gICAgICAgIGRvY3VtZW50TWFwLnNldChlbnRyeVswXSwgZG9jUGF0aClcbiAgICAgIH1cbiAgICAgIGF3YWl0IFNoYXJlZERvY3VtZW50LmZyb21JZEFuZFBhdGgoZW50cnlbMF0sIHBhdGguam9pbihmb2xkZXJQYXRoISwgZG9jUGF0aCksIHBsdWdpbilcbiAgICAgIHBhdGhzLnB1c2gobm9ybWFsaXplUGF0aChkb2NQYXRoKSlcbiAgICB9XG5cbiAgICBjb25zdCBzRm9sZGVyID0gbmV3IFNoYXJlZEZvbGRlcihmb2xkZXIsIHBsdWdpbiwgcHJlRmV0Y2hlZERvYylcbiAgICBzRm9sZGVyLl9zaGFyZUlkID0gaWRcblxuICAgIGF3YWl0IGFkZChzRm9sZGVyLCBwbHVnaW4pXG4gICAgYXdhaXQgc0ZvbGRlci5zdGFydEluZGV4ZWREQlN5bmMoKVxuICAgIGlmIChzRm9sZGVyLmluZGV4ZWREQlByb3ZpZGVyKSB7XG4gICAgICBpZiAoIXNGb2xkZXIuaW5kZXhlZERCUHJvdmlkZXIuc3luY2VkKSBhd2FpdCBzRm9sZGVyLmluZGV4ZWREQlByb3ZpZGVyLndoZW5TeW5jZWRcbiAgICAgIHNGb2xkZXIuc3luY1dpdGhTZXJ2ZXIoKVxuICAgICAgc0ZvbGRlci5zdGFydFdlYlJUQ1N5bmMoKVxuICAgIH1cbiAgICByZXR1cm4gc0ZvbGRlclxuICB9XG5cbiAgc3RhdGljIGFzeW5jIGZyb21QZXJtYW5lbnRTaGFyZUZvbGRlcihwc2Y6IFBlcm1hbmVudFNoYXJlRm9sZGVyLCBwbHVnaW46IFBlZXJEcmFmdFBsdWdpbikge1xuICAgIGlmICh0aGlzLmZpbmRCeVBhdGgocHNmLnBhdGgpKSByZXR1cm5cbiAgICBsZXQgdEZvbGRlcjogdm9pZCB8IG51bGwgfCBUQWJzdHJhY3RGaWxlXG4gICAgdEZvbGRlciA9IHBsdWdpbi5hcHAudmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKHBzZi5wYXRoKVxuICAgIGlmICh0Rm9sZGVyIGluc3RhbmNlb2YgVEZpbGUpIHtcbiAgICAgIHNob3dOb3RpY2UoXCJFeHBlY3RlZCBcIiArIHBzZi5wYXRoICsgXCIgdG8gYmUgYSBmb2xkZXIsIGEgYnV0IGlzIGEgZmlsZT9cIilcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBpZiAoISh0Rm9sZGVyIGluc3RhbmNlb2YgVEZvbGRlcikpIHtcbiAgICAgIHNob3dOb3RpY2UoXCJTaGFyZWQgZm9sZGVyIFwiICsgcHNmLnBhdGggKyBcIiBub3QgZm91bmQuIENyZWF0aW5nIGl0IG5vdy5cIilcbiAgICAgIHRGb2xkZXIgPSBhd2FpdCB0aGlzLmdldE9yQ3JlYXRlUGF0aChwc2YucGF0aCwgcGx1Z2luKVxuICAgIH1cbiAgICBpZiAoISh0Rm9sZGVyIGluc3RhbmNlb2YgVEZvbGRlcikpIHtcbiAgICAgIHNob3dOb3RpY2UoXCJDb3VsZCBub3QgY3JlYXRlIGZvbGRlciBcIiArIHBzZi5wYXRoICsgXCIuXCIpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCBmb2xkZXIgPSBuZXcgU2hhcmVkRm9sZGVyKHRGb2xkZXIsIHBsdWdpbilcbiAgICBmb2xkZXIuX3NoYXJlSWQgPSBwc2Yuc2hhcmVJZFxuICAgIGNvbnN0IGxvY2FsID0gYXdhaXQgZm9sZGVyLnN0YXJ0SW5kZXhlZERCU3luYygpXG4gICAgaWYgKGxvY2FsKSB7XG4gICAgICBpZiAobG9jYWwuc3luY2VkIHx8IGF3YWl0IGxvY2FsLndoZW5TeW5jZWQpIHtcbiAgICAgICAgZm9sZGVyLnN5bmNXaXRoU2VydmVyKClcbiAgICAgICAgZm9sZGVyLnN0YXJ0V2ViUlRDU3luYygpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmb2xkZXJcbiAgfVxuXG4gIHN0YXRpYyBmaW5kQnlQYXRoKHBhdGg6IHN0cmluZykge1xuICAgIHJldHVybiBzdXBlci5maW5kQnlQYXRoKHBhdGgpIGFzIFNoYXJlZEZvbGRlciB8IHVuZGVmaW5lZFxuICB9XG5cbiAgc3RhdGljIGZpbmRCeUlkKGlkOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gc3VwZXIuZmluZEJ5SWQoaWQpIGFzIFNoYXJlZEZvbGRlciB8IHVuZGVmaW5lZFxuICB9XG5cblxuICBzdGF0aWMgZ2V0QWxsKCkge1xuICAgIHJldHVybiBzdXBlci5nZXRBbGwoKSBhcyBBcnJheTxTaGFyZWRGb2xkZXI+XG4gIH1cblxuICBzdGF0aWMgZ2V0U2hhcmVkRm9sZGVyRm9yU3ViUGF0aChkaXI6IHN0cmluZykge1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRQYXRoID0gbm9ybWFsaXplUGF0aChkaXIpXG4gICAgY29uc3QgZm9sZGVycyA9IHRoaXMuZ2V0QWxsKClcbiAgICBmb3IgKGNvbnN0IGZvbGRlciBvZiBmb2xkZXJzKSB7XG4gICAgICBpZiAoZm9sZGVyLnJvb3QucGF0aCA9PT0gbm9ybWFsaXplZFBhdGgpIHJldHVyblxuICAgICAgaWYgKGZvbGRlci5pc1BhdGhTdWJQYXRoKG5vcm1hbGl6ZWRQYXRoKSkgcmV0dXJuIGZvbGRlclxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgY29uc3RydWN0b3Iocm9vdDogVEZvbGRlciwgcGx1Z2luOiBQZWVyRHJhZnRQbHVnaW4sIHlkb2M/OiBZLkRvYykge1xuICAgIHN1cGVyKHBsdWdpbilcbiAgICB0aGlzLnJvb3QgPSByb290XG4gICAgdGhpcy5fcGF0aCA9IHJvb3QucGF0aFxuICAgIHRoaXMueURvYyA9IHlkb2MgPz8gbmV3IFkuRG9jKClcbiAgICB0aGlzLmdldERvY3NGcmFnbWVudCgpLm9ic2VydmUoKGV2LCB0eCkgPT4ge1xuICAgICAgaGFuZGxlVXBkYXRlKGV2LCB0eCwgdGhpcywgcGx1Z2luKVxuICAgIH0pXG4gICAgdGhpcy55RG9jLm9uKFwidXBkYXRlXCIsICh1cGRhdGU6IFVpbnQ4QXJyYXksIG9yaWdpbjogYW55LCB5RG9jOiBZLkRvYywgdHI6IFkuVHJhbnNhY3Rpb24pID0+IHtcbiAgICAgIGlmICh0ci5sb2NhbCAmJiB0aGlzLnNoYXJlSWQpIHtcbiAgICAgICAgcGx1Z2luLnNlcnZlclN5bmMuc2VuZFVwZGF0ZSh0aGlzLCB1cGRhdGUpXG4gICAgICB9XG4gICAgfSlcbiAgICBTaGFyZWRGb2xkZXIuX3NoYXJlZEVudGl0ZXMucHVzaCh0aGlzKVxuICAgIGFkZElzU2hhcmVkQ2xhc3ModGhpcy5wYXRoLCBwbHVnaW4pXG4gIH1cblxuICBnZXREb2NzRnJhZ21lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMueURvYy5nZXRNYXAoJ2RvY3VtZW50cycpXG4gIH1cblxuXG4gIGdldERvY0J5UmVsYXRpdmVQYXRoKGRpcjogc3RyaW5nKSB7XG4gICAgY29uc3Qgbm9ybWFsaXplZFBhdGggPSBub3JtYWxpemVQYXRoKGRpcilcbiAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIHRoaXMuZ2V0RG9jc0ZyYWdtZW50KCkuZW50cmllcygpIGFzIEl0ZXJhYmxlSXRlcmF0b3I8W2tleTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nXT4pIHtcbiAgICAgIGlmIChlbnRyeVsxXSA9PT0gbm9ybWFsaXplZFBhdGgpIHJldHVybiBlbnRyeVswXVxuICAgIH1cbiAgfVxuXG4gIHVwZGF0ZVBhdGgob2xkUGF0aDogc3RyaW5nLCBuZXdQYXRoOiBzdHJpbmcpIHtcbiAgICBjb25zdCBvbGRQYXRoUmVsYXRpdmUgPSBwYXRoLnJlbGF0aXZlKHRoaXMucm9vdC5wYXRoLCBvbGRQYXRoKVxuICAgIGNvbnN0IG5ld1BhdGhSZWxhdGl2ZSA9IHBhdGgucmVsYXRpdmUodGhpcy5yb290LnBhdGgsIG5ld1BhdGgpXG5cbiAgICBjb25zdCBpZCA9IHRoaXMuZ2V0RG9jQnlSZWxhdGl2ZVBhdGgob2xkUGF0aFJlbGF0aXZlKVxuICAgIGlmIChpZCkge1xuICAgICAgdGhpcy5nZXREb2NzRnJhZ21lbnQoKS5zZXQoaWQsIG5vcm1hbGl6ZVBhdGgobmV3UGF0aFJlbGF0aXZlKSlcbiAgICB9XG4gICAgcmV0dXJuIGlkXG4gIH1cblxuICBjYWxjdWxhdGVIYXNoKCk6IHN0cmluZyB7XG4gICAgY29uc3Qgc2VyaWFsaXplZCA9IHNlcmlhbGl6ZShBcnJheS5mcm9tKHRoaXMuZ2V0RG9jc0ZyYWdtZW50KCkpKVxuICAgIHJldHVybiBjYWxjdWxhdGVIYXNoKHNlcmlhbGl6ZWQpXG4gIH1cblxuICBhZGREb2N1bWVudChkb2M6IFNoYXJlZERvY3VtZW50KSB7XG4gICAgLy8gZG9lc24ndCBleGlzdCB5ZXRcbiAgICBpZiAodGhpcy5nZXREb2NzRnJhZ21lbnQoKS5nZXQoZG9jLnNoYXJlSWQpKSByZXR1cm5cbiAgICAvLyBjaGVjayBpZiBkb2MgaXMgdW5kZXIgcm9vdFxuICAgIGNvbnN0IHJlbGF0aXZlUGF0aCA9IHBhdGgucmVsYXRpdmUodGhpcy5yb290LnBhdGgsIGRvYy5wYXRoKVxuICAgIGlmIChyZWxhdGl2ZVBhdGguc3RhcnRzV2l0aCgnLi4nKSkgcmV0dXJuXG4gICAgdGhpcy5nZXREb2NzRnJhZ21lbnQoKS5zZXQoZG9jLnNoYXJlSWQsIHJlbGF0aXZlUGF0aClcbiAgfVxuXG4gIHJlbW92ZURvY3VtZW50KGRvYzogU2hhcmVkRG9jdW1lbnQpIHtcbiAgICB0aGlzLmdldERvY3NGcmFnbWVudCgpLmRlbGV0ZShkb2Muc2hhcmVJZClcbiAgfVxuXG4gIGlzUGF0aFN1YlBhdGgoZm9sZGVyOiBzdHJpbmcpIHtcbiAgICBjb25zdCByZWxhdGl2ZVBhdGggPSBwYXRoLnJlbGF0aXZlKHRoaXMucm9vdC5wYXRoLCBmb2xkZXIpXG4gICAgcmV0dXJuICEocmVsYXRpdmVQYXRoLnN0YXJ0c1dpdGgoJy4uJykpXG4gIH1cblxuICBwcml2YXRlIHN0YXRpYyBnZXRBbGxGaWxlc0luRm9sZGVyKGZvbGRlcjogVEZvbGRlcik6IEFycmF5PFRGaWxlPiB7XG4gICAgY29uc3QgZmlsZXMgPSBmb2xkZXIuY2hpbGRyZW4uZmxhdE1hcCgoY2hpbGQpID0+IHtcbiAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIFRGaWxlKSB7XG4gICAgICAgIGlmIChjaGlsZC5leHRlbnNpb24gPT09IFwibWRcIikge1xuICAgICAgICAgIHJldHVybiBjaGlsZFxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBURm9sZGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEFsbEZpbGVzSW5Gb2xkZXIoY2hpbGQpXG4gICAgICB9XG4gICAgICByZXR1cm4gW11cbiAgICB9KVxuICAgIHJldHVybiBmaWxlc1xuICB9XG5cbiAgYXN5bmMgc2V0TmV3Rm9sZGVyTG9jYXRpb24oZm9sZGVyOiBURm9sZGVyKSB7XG4gICAgY29uc3Qgb2xkUGF0aCA9IHRoaXMuX3BhdGhcbiAgICB0aGlzLnJvb3QgPSBmb2xkZXJcbiAgICB0aGlzLl9wYXRoID0gbm9ybWFsaXplUGF0aChmb2xkZXIucGF0aClcbiAgICBtb3ZlRm9sZGVyKG9sZFBhdGgsIGZvbGRlci5wYXRoLCB0aGlzLnBsdWdpbilcbiAgfVxuXG4gIGFzeW5jIGdldE9yQ3JlYXRlRmlsZShyZWxhdGl2ZVBhdGg6IHN0cmluZykge1xuICAgIGNvbnN0IGFic29sdXRlUGF0aCA9IHBhdGguam9pbih0aGlzLnJvb3QucGF0aCwgcmVsYXRpdmVQYXRoKVxuICAgIGxldCBmaWxlID0gdGhpcy5wbHVnaW4uYXBwLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChhYnNvbHV0ZVBhdGgpXG4gICAgaWYgKGZpbGUgJiYgZmlsZSBpbnN0YW5jZW9mIFRGaWxlKSByZXR1cm4gZmlsZVxuXG4gICAgY29uc3QgZm9sZGVyID0gYXdhaXQgU2hhcmVkRm9sZGVyLmdldE9yQ3JlYXRlUGF0aChwYXRoLnBhcnNlKGFic29sdXRlUGF0aCkuZGlyLCB0aGlzLnBsdWdpbilcbiAgICBpZiAoIWZvbGRlcikge1xuICAgICAgc2hvd05vdGljZShcIkVycm9yIGNyZWF0aW5nIHNoYXJlc1wiKVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHJldHVybiBhd2FpdCB0aGlzLnBsdWdpbi5hcHAudmF1bHQuY3JlYXRlKGFic29sdXRlUGF0aCwgJycpXG4gIH1cblxuICBzdGF0aWMgYXN5bmMgZ2V0T3JDcmVhdGVQYXRoKGFic29sdXRlUGF0aDogc3RyaW5nLCBwbHVnaW46IFBlZXJEcmFmdFBsdWdpbik6IFByb21pc2U8VEZvbGRlciB8IHZvaWQ+IHtcbiAgICBsZXQgZm9sZGVyID0gcGx1Z2luLmFwcC52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgobm9ybWFsaXplUGF0aChhYnNvbHV0ZVBhdGgpKVxuICAgIGlmIChmb2xkZXIgJiYgZm9sZGVyIGluc3RhbmNlb2YgVEZvbGRlcikgcmV0dXJuIGZvbGRlclxuICAgIGNvbnN0IHNlZ21lbnRzID0gYWJzb2x1dGVQYXRoLnNwbGl0KHBhdGguc2VwKVxuICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBzZWdtZW50cy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIGNvbnN0IHN1YlBhdGggPSBzZWdtZW50cy5zbGljZSgwLCBpbmRleCArIDEpLmpvaW4ocGF0aC5zZXApXG4gICAgICBmb2xkZXIgPSBwbHVnaW4uYXBwLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChub3JtYWxpemVQYXRoKHN1YlBhdGgpKVxuICAgICAgaWYgKCFmb2xkZXIpIHtcbiAgICAgICAgZm9sZGVyID0gYXdhaXQgcGx1Z2luLmFwcC52YXVsdC5jcmVhdGVGb2xkZXIobm9ybWFsaXplUGF0aChzdWJQYXRoKSlcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZvbGRlciBhcyBURm9sZGVyXG4gIH1cblxuICBpc0ZpbGVJblN5bmNPYmplY3QoZmlsZTogVEZpbGUpIHtcbiAgICBjb25zdCBub3JtYWxpemVkUGF0aCA9IG5vcm1hbGl6ZVBhdGgoZmlsZS5wYXRoKVxuICAgIGZvciAoY29uc3QgdmFsdWUgb2YgdGhpcy5nZXREb2NzRnJhZ21lbnQoKS52YWx1ZXMoKSkge1xuICAgICAgaWYgKG5vcm1hbGl6ZWRQYXRoID09PSBwYXRoLmpvaW4odGhpcy5yb290LnBhdGgsIHZhbHVlKSkgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBzdGFydFdlYlJUQ1N5bmMoKSB7XG4gICAgcmV0dXJuIHN1cGVyLnN0YXJ0V2ViUlRDU3luYygocHJvdmlkZXIpID0+IHtcblxuICAgICAgY29uc3QgaGFuZGxlVGltZW91dCA9ICgpID0+IHtcbiAgICAgICAgLy8gdGhpcy5zdG9wV2ViUlRDU3luYygpXG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3dlYlJUQ1RpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dChoYW5kbGVUaW1lb3V0LCA2MDAwMClcbiAgICAgIHByb3ZpZGVyLmRvYy5vbigndXBkYXRlJywgYXN5bmMgKHVwZGF0ZTogVWludDhBcnJheSwgb3JpZ2luOiBhbnksIGRvYzogWS5Eb2MsIHRyOiBZLlRyYW5zYWN0aW9uKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLl93ZWJSVENUaW1lb3V0ICE9IG51bGwpIHtcbiAgICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMuX3dlYlJUQ1RpbWVvdXQpXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fd2ViUlRDVGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KGhhbmRsZVRpbWVvdXQsIDYwMDAwKVxuICAgICAgfSlcbiAgICB9KVxuICB9XG5cbiAgYXN5bmMgc3RhcnRJbmRleGVkREJTeW5jKCkge1xuICAgIGlmICh0aGlzLl9pbmRleGVkREJQcm92aWRlcikgcmV0dXJuIHRoaXMuX2luZGV4ZWREQlByb3ZpZGVyXG4gICAgY29uc3QgaWQgPSBnZXRGb2xkZXJCeVBhdGgodGhpcy5wYXRoLCB0aGlzLnBsdWdpbik/LnBlcnNpc3RlbmNlSWRcbiAgICBpZiAoIWlkKSByZXR1cm5cbiAgICB0aGlzLl9pbmRleGVkREJQcm92aWRlciA9IG5ldyBJbmRleGVkZGJQZXJzaXN0ZW5jZShTaGFyZWRFbnRpdHkuREJfUEVSU0lTVEVOQ0VfUFJFRklYICsgaWQsIHRoaXMueURvYylcbiAgICByZXR1cm4gdGhpcy5faW5kZXhlZERCUHJvdmlkZXJcbiAgfVxuXG4gIGFzeW5jIHVuc2hhcmUoKSB7XG4gICAgY29uc3QgZGJFbnRyeSA9IGdldEZvbGRlckJ5UGF0aCh0aGlzLnBhdGgsIHRoaXMucGx1Z2luKVxuICAgIGlmIChkYkVudHJ5KSB7XG4gICAgICByZW1vdmVGb2xkZXIodGhpcy5wYXRoLCB0aGlzLnBsdWdpbilcbiAgICB9XG5cbiAgICBpZiAodGhpcy5faW5kZXhlZERCUHJvdmlkZXIpIHtcbiAgICAgIGF3YWl0IHRoaXMuX2luZGV4ZWREQlByb3ZpZGVyLmNsZWFyRGF0YSgpXG4gICAgICBhd2FpdCB0aGlzLl9pbmRleGVkREJQcm92aWRlci5kZXN0cm95KClcbiAgICB9XG5cblxuICAgIHRoaXMuZ2V0RG9jc0ZyYWdtZW50KCkuZm9yRWFjaCgocGF0aDogc3RyaW5nLCBzaGFyZUlkOiBzdHJpbmcpID0+IHtcbiAgICAgIFNoYXJlZERvY3VtZW50LmZpbmRCeUlkKHNoYXJlSWQpPy51bnNoYXJlKClcbiAgICB9KVxuXG4gICAgdGhpcy5kZXN0cm95KClcbiAgICByZW1vdmVJc1NoYXJlZENsYXNzKHRoaXMucGF0aCwgdGhpcy5wbHVnaW4pXG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIHN1cGVyLmRlc3Ryb3koKVxuICAgIFNoYXJlZEZvbGRlci5fc2hhcmVkRW50aXRlcy5zcGxpY2UoU2hhcmVkRm9sZGVyLl9zaGFyZWRFbnRpdGVzLmluZGV4T2YodGhpcyksIDEpXG4gIH1cblxufSIsICJpbXBvcnQgeyBNb2RhbCwgUGx1Z2luLCBQbHVnaW5TZXR0aW5nVGFiLCBTZXR0aW5nLCBkZWJvdW5jZSwgbm9ybWFsaXplUGF0aCwgcmVxdWVzdFVybCB9IGZyb20gXCJvYnNpZGlhblwiO1xuaW1wb3J0IHsgcmVmcmVzaFN1YnNjcmlwdGlvbkRhdGEgfSBmcm9tIFwiLi9zdWJzY3JpcHRpb25cIjtcbmltcG9ydCB7IHNob3dUZXh0TW9kYWwgfSBmcm9tIFwiLi91aVwiO1xuaW1wb3J0IFBlZXJkcmFmdFBsdWdpbiBmcm9tIFwiLi9wZWVyZHJhZnRQbHVnaW5cIjtcbmltcG9ydCB7IHByb21wdEZvckZvbGRlclNlbGVjdGlvbiB9IGZyb20gXCIuL3VpL3NlbGVjdEZvbGRlclwiO1xuaW1wb3J0IHsgUGVybWFuZW50U2hhcmVTdG9yZUluZGV4ZWREQiB9IGZyb20gXCIuL3Blcm1hbmVudFNoYXJlU3RvcmVcIjtcblxuZXhwb3J0IGludGVyZmFjZSBTZXR0aW5ncyB7XG4gIHNpZ25hbGluZzogc3RyaW5nLFxuICBzeW5jOiBzdHJpbmcsXG4gIHN1YnNjcmlwdGlvbkFQSTogc3RyaW5nLFxuICBjb25uZWN0QVBJOiBzdHJpbmcsXG4gIHNlc3Npb25BUEk6IHN0cmluZ1xuICBhY3RpdmVzOiBzdHJpbmcsXG4gIGJhc2VQYXRoOiBzdHJpbmcsXG4gIG5hbWU6IHN0cmluZyxcbiAgb2lkOiBzdHJpbmcsXG4gIHBsYW46IHtcbiAgICB0eXBlOiBcImhvYmJ5XCIgfCBcInByb2Zlc3Npb25hbFwiIHwgXCJ0ZWFtXCJcbiAgICBlbWFpbD86IHN0cmluZ1xuICB9LFxuICByb290OiBzdHJpbmcsXG4gIGR1cmF0aW9uOiBudW1iZXIsXG4gIGRlYnVnOiBib29sZWFuLFxuICB2ZXJzaW9uOiBzdHJpbmcsXG4gIHNlcnZlclNoYXJlczoge1xuICAgIGZvbGRlcnM6IE1hcDxzdHJpbmcsIHsgcGVyc2lzdGVuY2VJZDogc3RyaW5nLCBzaGFyZUlkOiBzdHJpbmcgfT5cbiAgICBmaWxlczogTWFwPHN0cmluZywgeyBwZXJzaXN0ZW5jZUlkOiBzdHJpbmcsIHNoYXJlSWQ6IHN0cmluZyB9PlxuICB9XG59XG5cbmNvbnN0IERFRkFVTFRfU0VUVElOR1M6IE9taXQ8U2V0dGluZ3MsIFwib2lkXCI+ID0ge1xuICBiYXNlUGF0aDogXCJodHRwczovL3d3dy5wZWVyZHJhZnQuYXBwXCIsXG4gIHN1YnNjcmlwdGlvbkFQSTogXCJodHRwczovL3d3dy5wZWVyZHJhZnQuYXBwL3N1YnNjcmlwdGlvblwiLFxuICBjb25uZWN0QVBJOiBcImh0dHBzOi8vd3d3LnBlZXJkcmFmdC5hcHAvc3Vic2NyaXB0aW9uL2Nvbm5lY3RcIixcbiAgc2Vzc2lvbkFQSTogXCJodHRwczovL3d3dy5wZWVyZHJhZnQuYXBwL3Nlc3Npb25cIixcbiAgc3luYzogXCJ3c3M6Ly93d3cucGVlcmRyYWZ0LmFwcC9zeW5jXCIsXG4gIHNpZ25hbGluZzogXCJ3c3M6Ly93d3cucGVlcmRyYWZ0LmFwcC9zaWduYWxcIixcbiAgYWN0aXZlczogXCJ3c3M6Ly93d3cucGVlcmRyYWZ0LmFwcC9hY3RpdmVzXCIsXG4gIG5hbWU6IFwiXCIsXG4gIHJvb3Q6IFwiXCIsXG4gIHBsYW46IHtcbiAgICB0eXBlOiBcImhvYmJ5XCIsXG4gICAgZW1haWw6IFwiXCJcbiAgfSxcbiAgZHVyYXRpb246IDAsXG4gIGRlYnVnOiBmYWxzZSxcbiAgdmVyc2lvbjogJycsXG4gIHNlcnZlclNoYXJlczoge1xuICAgIGZpbGVzOiBuZXcgTWFwPHN0cmluZywgeyBwZXJzaXN0ZW5jZUlkOiBzdHJpbmcsIHNoYXJlSWQ6IHN0cmluZyB9PigpLFxuICAgIGZvbGRlcnM6IG5ldyBNYXA8c3RyaW5nLCB7IHBlcnNpc3RlbmNlSWQ6IHN0cmluZywgc2hhcmVJZDogc3RyaW5nIH0+KClcbiAgfVxufVxuXG5jb25zdCBGT1JDRV9TRVRUSU5HUzogUGFydGlhbDxTZXR0aW5ncz4gPSB7XG4gIC8qXG4gIGJhc2VQYXRoOiBcImh0dHA6Ly9sb2NhbGhvc3Q6NTE3M1wiLFxuICBzdWJzY3JpcHRpb25BUEk6IFwiaHR0cDovL2xvY2FsaG9zdDo1MTczL3N1YnNjcmlwdGlvblwiLFxuICBjb25uZWN0QVBJOiBcImh0dHA6Ly9sb2NhbGhvc3Q6NTE3My9zdWJzY3JpcHRpb24vY29ubmVjdFwiLFxuICBzZXNzaW9uQVBJOiBcImh0dHA6Ly9sb2NhbGhvc3Q6NTE3My9zZXNzaW9uXCIsXG4gIHN5bmM6IFwid3M6Ly9sb2NhbGhvc3Q6NTE3My9zeW5jXCIsXG4gIHNpZ25hbGluZzogXCJ3czovL2xvY2FsaG9zdDo1MTczL3NpZ25hbFwiLFxuICBhY3RpdmVzOiBcIndzOi8vbG9jYWxob3N0OjUxNzMvYWN0aXZlc1wiXG4gICovXG4gIGJhc2VQYXRoOiBcImh0dHBzOi8vd3d3LnBlZXJkcmFmdC5hcHBcIixcbiAgc3Vic2NyaXB0aW9uQVBJOiBcImh0dHBzOi8vd3d3LnBlZXJkcmFmdC5hcHAvc3Vic2NyaXB0aW9uXCIsXG4gIGNvbm5lY3RBUEk6IFwiaHR0cHM6Ly93d3cucGVlcmRyYWZ0LmFwcC9zdWJzY3JpcHRpb24vY29ubmVjdFwiLFxuICBzZXNzaW9uQVBJOiBcImh0dHBzOi8vd3d3LnBlZXJkcmFmdC5hcHAvc2Vzc2lvblwiLFxuICBzeW5jOiBcIndzczovL3d3dy5wZWVyZHJhZnQuYXBwL3N5bmNcIixcbiAgc2lnbmFsaW5nOiBcIndzczovL3d3dy5wZWVyZHJhZnQuYXBwL3NpZ25hbFwiLFxuICBhY3RpdmVzOiBcIndzczovL3d3dy5wZWVyZHJhZnQuYXBwL2FjdGl2ZXNcIixcbn1cblxuZXhwb3J0IGNvbnN0IG1pZ3JhdGVTZXR0aW5ncyA9IGFzeW5jIChwbHVnaW46IFBlZXJkcmFmdFBsdWdpbikgPT4ge1xuICBjb25zdCBvbGRTZXR0aW5ncyA9IGF3YWl0IGdldFNldHRpbmdzKHBsdWdpbilcblxuICBjb25zdCBuZXdTZXR0aW5nczogU2V0dGluZ3MgPSBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX1NFVFRJTkdTLCBvbGRTZXR0aW5ncywgRk9SQ0VfU0VUVElOR1MsIHtcbiAgICB2ZXJzaW9uOiBwbHVnaW4ubWFuaWZlc3QudmVyc2lvblxuICB9KVxuICAvL0B0cy1leHBlY3QtZXJyb3JcbiAgbmV3U2V0dGluZ3Mub2lkID0gb2xkU2V0dGluZ3M/Lm9pZCA/PyBwbHVnaW4uYXBwLmFwcElkXG5cbiAgY29uc3QgZmlsZXMgPSBuZXdTZXR0aW5ncy5zZXJ2ZXJTaGFyZXMuZmlsZXNcbiAgZm9yIChjb25zdCBrZXkgb2YgZmlsZXMua2V5cygpKSB7XG4gICAgaWYoa2V5LmNvbnRhaW5zKCdcXFxcJykpIHtcbiAgICAgIGZpbGVzLnNldChub3JtYWxpemVQYXRoKGtleSksIGZpbGVzLmdldChrZXkpISlcbiAgICAgIGZpbGVzLmRlbGV0ZShrZXkpXG4gICAgfVxuICB9XG5cbiAgY29uc3QgZm9sZGVycyA9IG5ld1NldHRpbmdzLnNlcnZlclNoYXJlcy5mb2xkZXJzXG4gIGZvciAoY29uc3Qga2V5IG9mIGZvbGRlcnMua2V5cygpKSB7XG4gICAgaWYoa2V5LmNvbnRhaW5zKCdcXFxcJykpIHtcbiAgICAgIGZvbGRlcnMuc2V0KG5vcm1hbGl6ZVBhdGgoa2V5KSwgZm9sZGVycy5nZXQoa2V5KSEpXG4gICAgICBmb2xkZXJzLmRlbGV0ZShrZXkpXG4gICAgfVxuICB9XG5cbiAgaWYgKG9sZFNldHRpbmdzPy5vaWQgJiYgbmV3U2V0dGluZ3Muc2VydmVyU2hhcmVzLmZpbGVzLnNpemUgPT09IDAgJiYgbmV3U2V0dGluZ3Muc2VydmVyU2hhcmVzLmZvbGRlcnMuc2l6ZSA9PT0gMCkge1xuICAgIGNvbnN0IGRiID0gbmV3IFBlcm1hbmVudFNoYXJlU3RvcmVJbmRleGVkREIob2xkU2V0dGluZ3Mub2lkKVxuICAgIGNvbnN0IGRvY3MgPSBhd2FpdCBkYi5nZXRBbGxEb2NzKClcbiAgICBkb2NzLmZvckVhY2goZG9jID0+IHtcbiAgICAgIG5ld1NldHRpbmdzLnNlcnZlclNoYXJlcy5maWxlcy5zZXQobm9ybWFsaXplUGF0aChkb2MucGF0aCksIHsgcGVyc2lzdGVuY2VJZDogZG9jLnBlcnNpc3RlbmNlSWQsIHNoYXJlSWQ6IGRvYy5zaGFyZUlkIH0pXG4gICAgfSlcbiAgICBjb25zdCBmb2xkZXJzID0gYXdhaXQgZGIuZ2V0QWxsRm9sZGVycygpXG4gICAgZm9sZGVycy5mb3JFYWNoKGRvYyA9PiB7XG4gICAgICBuZXdTZXR0aW5ncy5zZXJ2ZXJTaGFyZXMuZm9sZGVycy5zZXQobm9ybWFsaXplUGF0aChkb2MucGF0aCksIHsgcGVyc2lzdGVuY2VJZDogZG9jLnBlcnNpc3RlbmNlSWQsIHNoYXJlSWQ6IGRvYy5zaGFyZUlkIH0pXG4gICAgfSlcbiAgICBzYXZlU2V0dGluZ3MobmV3U2V0dGluZ3MsIHBsdWdpbilcbiAgICBhd2FpdCBkYi5kZWxldGVEQigpXG4gIH1cblxuICBzYXZlU2V0dGluZ3MobmV3U2V0dGluZ3MsIHBsdWdpbilcblxuICBpZiAob2xkU2V0dGluZ3MgJiYgb2xkU2V0dGluZ3MudmVyc2lvbiAhPSBuZXdTZXR0aW5ncy52ZXJzaW9uKSB7XG4gICAgc2hvd1RleHRNb2RhbChwbHVnaW4uYXBwLCAnUGVlcmRyYWZ0IHVwZGF0ZWQnLCAnQSBuZXcgdmVyc2lvbiBvZiBQZWVyZHJhZnQgd2FzIGluc3RhbGxlZC4gUGxlYXNlIHJlc3RhcnQgT2JzaWRpYW4gYmVmb3JlIHlvdSB1c2UgUGVlcmRyYWZ0IGFnYWluLicpXG4gIH1cblxuICByZXR1cm4gbmV3U2V0dGluZ3NcblxufVxuXG5leHBvcnQgY29uc3QgZ2V0U2V0dGluZ3MgPSBhc3luYyAocGx1Z2luOiBQbHVnaW4pID0+IHtcbiAgY29uc3Qgc2V0dGluZ3MgPSBhd2FpdCBwbHVnaW4ubG9hZERhdGEoKSBhcyBTZXR0aW5nc1xuICBpZiAoc2V0dGluZ3MpIHtcbiAgICBzZXR0aW5ncy5zZXJ2ZXJTaGFyZXMgPSB7XG4gICAgICBmaWxlczogbmV3IE1hcChzZXR0aW5ncy5zZXJ2ZXJTaGFyZXM/LmZpbGVzKSxcbiAgICAgIGZvbGRlcnM6IG5ldyBNYXAoc2V0dGluZ3Muc2VydmVyU2hhcmVzPy5mb2xkZXJzKVxuICAgIH1cbiAgfVxuICByZXR1cm4gc2V0dGluZ3Ncbn1cblxuXG5leHBvcnQgY29uc3Qgc2F2ZVNldHRpbmdzID0gZGVib3VuY2UoYXN5bmMgKHNldHRpbmdzOiBTZXR0aW5ncywgcGx1Z2luOiBQZWVyZHJhZnRQbHVnaW4pID0+IHtcblxuICBjb25zdCBzZXJpYWxpemVkID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShzZXR0aW5ncykpXG5cbiAgc2VyaWFsaXplZC5zZXJ2ZXJTaGFyZXMgPSB7XG4gICAgZmlsZXM6IEFycmF5LmZyb20oc2V0dGluZ3Muc2VydmVyU2hhcmVzLmZpbGVzLmVudHJpZXMoKSksXG4gICAgZm9sZGVyczogQXJyYXkuZnJvbShzZXR0aW5ncy5zZXJ2ZXJTaGFyZXMuZm9sZGVycy5lbnRyaWVzKCkpXG4gIH1cblxuICBwbHVnaW4uc2F2ZURhdGEoc2VyaWFsaXplZClcbn0sIDEwMDAsIHRydWUpXG5cbmV4cG9ydCBjb25zdCByZW5kZXJTZXR0aW5ncyA9IGFzeW5jIChlbDogSFRNTEVsZW1lbnQsIHBsdWdpbjogUGVlcmRyYWZ0UGx1Z2luKSA9PiB7XG4gIGVsLmVtcHR5KCk7XG5cbiAgY29uc3Qgc2V0dGluZ3MgPSBhd2FpdCBnZXRTZXR0aW5ncyhwbHVnaW4pXG5cbiAgZWwuY3JlYXRlRWwoXCJoMVwiLCB7IHRleHQ6IFwiR2VuZXJhbFwiIH0pO1xuXG4gIG5ldyBTZXR0aW5nKGVsKVxuICAgIC5zZXROYW1lKFwiRGlzcGxheSBOYW1lXCIpXG4gICAgLnNldERlc2MoXCJUaGlzIG5hbWUgd2lsbCBiZSBzaG93biB0byB5b3VyIGNvbGxhYm9yYXRvcnNcIilcbiAgICAuYWRkVGV4dCgodGV4dCkgPT4ge1xuICAgICAgdGV4dC5zZXRWYWx1ZShzZXR0aW5ncy5uYW1lKVxuICAgICAgdGV4dC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgc2V0dGluZ3MubmFtZSA9IHZhbHVlXG4gICAgICAgIHNhdmVTZXR0aW5ncyhzZXR0aW5ncywgcGx1Z2luKTtcbiAgICAgIH0pXG4gICAgfSlcblxuICBjb25zdCBwYXRoU2V0dGluZyA9IG5ldyBTZXR0aW5nKGVsKVxuICBwYXRoU2V0dGluZy5zZXROYW1lKFwiUm9vdCBGb2xkZXJcIilcbiAgcGF0aFNldHRpbmcuc2V0RGVzYyhcIldoZW4geW91IGltcG9ydCBhIHNoYXJlIGZyb20gc29tZW9uZSBlbHNlIGl0IHdpbGwgYmUgY3JlYXRlZCBpbiB0aGlzIGZvbGRlci5cIilcbiAgcGF0aFNldHRpbmcuYWRkVGV4dCh0ZXh0ID0+IHtcbiAgICB0ZXh0LnNldFZhbHVlKHNldHRpbmdzLnJvb3QpXG4gICAgdGV4dC5vbkNoYW5nZShhc3luYyB2YWx1ZSA9PiB7XG4gICAgICBzZXR0aW5ncy5yb290ID0gdmFsdWVcbiAgICAgIHNhdmVTZXR0aW5ncyhzZXR0aW5ncywgcGx1Z2luKVxuICAgIH0pXG5cbiAgICBwYXRoU2V0dGluZy5hZGRFeHRyYUJ1dHRvbihidXR0b24gPT4ge1xuICAgICAgYnV0dG9uLnNldEljb24oJ3NlYXJjaCcpXG4gICAgICBidXR0b24ub25DbGljayhhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGZvbGRlciA9IGF3YWl0IHByb21wdEZvckZvbGRlclNlbGVjdGlvbihwbHVnaW4uYXBwKVxuICAgICAgICBpZiAoZm9sZGVyKSB7XG4gICAgICAgICAgdGV4dC5zZXRWYWx1ZShmb2xkZXIucGF0aClcbiAgICAgICAgICBzZXR0aW5ncy5yb290ID0gZm9sZGVyLnBhdGhcbiAgICAgICAgICBzYXZlU2V0dGluZ3Moc2V0dGluZ3MsIHBsdWdpbilcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9KVxuICB9KVxuXG5cbiAgZWwuY3JlYXRlRWwoXCJoMVwiLCB7IHRleHQ6IFwiWW91ciBzdWJzY3JpcHRpb25cIiB9KVxuICBpZiAoc2V0dGluZ3MucGxhbi50eXBlID09PSBcImhvYmJ5XCIpIHtcbiAgICBlbC5jcmVhdGVFbChcImRpdlwiLCB7IHRleHQ6IFwiWW91IGFyZSBvbiB0aGUgZnJlZSBIb2JieSBwbGFuLiBZb3UgY2FuIGNvbGxhYm9yYXRlIHdpdGggeW91ciBwZWVycyBmb3IgdXAgdG8gMi41IGhvdXJzIGEgbW9udGguIEZvciB1bmxpbWl0ZWQgY29sbGFib3JhdGlvbiB0aW1lLCBzaWduLXVwIGZvciB0aGUgUHJvZmVzc2lvbmFsIHBsYW4gYXQgMzAgVVNEL3llYXIuXCIgfSlcbiAgICBlbC5jcmVhdGVFbChcInBcIilcbiAgICBlbC5jcmVhdGVFbChcImRpdlwiLCB7IHRleHQ6IGBZb3UgaGF2ZSB1c2VkIFBlZXJkcmFmdCBmb3IgJHtzZXR0aW5ncy5kdXJhdGlvbn0gbWludXRlcyBzbyBmYXIuYCB9KVxuICAgIGVsLmNyZWF0ZUVsKFwicFwiKVxuXG4gICAgbmV3IFNldHRpbmcoZWwpXG4gICAgICAuc2V0TmFtZShcIlN1YnNjcmliZVwiKVxuICAgICAgLmFkZEJ1dHRvbihidXR0b24gPT4ge1xuICAgICAgICBidXR0b24uc2V0QnV0dG9uVGV4dChcIkJ1eSBwcm9mZXNzaW9uYWwgcGxhblwiKVxuICAgICAgICBidXR0b24uc2V0Q3RhKClcbiAgICAgICAgYnV0dG9uLm9uQ2xpY2soKGUpID0+IHtcbiAgICAgICAgICB3aW5kb3cub3BlbihgaHR0cHM6Ly9wZWVyZHJhZnQuYXBwL2NoZWNrb3V0P29pZD0ke3NldHRpbmdzLm9pZH1gKVxuICAgICAgICB9KVxuICAgICAgfSlcblxuICAgIGxldCBjb25uZWN0RW1haWwgPSBcIlwiXG4gICAgbmV3IFNldHRpbmcoZWwpXG4gICAgICAuc2V0TmFtZShcIlVzZSBleGlzdGluZyBzdWJzY3JpcHRpb25cIilcbiAgICAgIC5zZXREZXNjKFwiSWYgeW91IGFscmVhZHkgYm91Z2h0IGEgc3Vic2NyaXB0aW9uLCBlbnRlciB0aGUgZS1tYWlsIGFkZHJlc3MgYXNzb2NpYXRlZCB3aXRoIGl0IGFuZCBjbGljayBvbiBgQ29ubmVjdGAuXCIpXG4gICAgICAuYWRkVGV4dCgodGV4dCkgPT4ge1xuICAgICAgICB0ZXh0LnNldFBsYWNlaG9sZGVyKFwibWVAdGVzdC5jb21cIilcbiAgICAgICAgdGV4dC5vbkNoYW5nZSgodmFsdWUpID0+IHtcbiAgICAgICAgICBjb25uZWN0RW1haWwgPSB2YWx1ZVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICAgIC5hZGRCdXR0b24oYnV0dG9uID0+IHtcbiAgICAgICAgYnV0dG9uLnNldEJ1dHRvblRleHQoXCJDb25uZWN0XCIpXG4gICAgICAgIGJ1dHRvbi5vbkNsaWNrKGFzeW5jIChlKSA9PiB7XG4gICAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlcXVlc3RVcmwoe1xuICAgICAgICAgICAgdXJsOiBzZXR0aW5ncy5jb25uZWN0QVBJLFxuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICBjb250ZW50VHlwZTogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgIGVtYWlsOiBjb25uZWN0RW1haWwsXG4gICAgICAgICAgICAgIG9pZDogc2V0dGluZ3Mub2lkXG4gICAgICAgICAgICB9KVxuXG4gICAgICAgICAgfSkuanNvblxuICAgICAgICAgIGlmIChkYXRhICYmIGRhdGEucGxhbikge1xuICAgICAgICAgICAgc2V0dGluZ3MucGxhbiA9IGRhdGEucGxhblxuICAgICAgICAgICAgc2F2ZVNldHRpbmdzKHNldHRpbmdzLCBwbHVnaW4pLFxuICAgICAgICAgICAgICBhd2FpdCByZW5kZXJTZXR0aW5ncyhlbCwgcGx1Z2luKVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH0pXG5cbiAgfSBlbHNlIGlmIChzZXR0aW5ncy5wbGFuLnR5cGUgPT09IFwicHJvZmVzc2lvbmFsXCIpIHtcbiAgICBlbC5jcmVhdGVFbChcImRpdlwiLCB7IHRleHQ6IFwiWW91IGFyZSBvbiB0aGUgcHJvZmVzc2lvbmFsIHBsYW4gZm9yIHVubGltaXRlZCBjb2xsYWJvcmF0aW9uLiBIYXBweSBwZWVyZHJhZnRpbmcuXCIgfSlcbiAgICBlbC5jcmVhdGVFbChcInBcIilcbiAgICBlbC5jcmVhdGVFbChcImRpdlwiLCB7IHRleHQ6IGBZb3UgaGF2ZSB1c2VkIFBlZXJkcmFmdCBmb3IgJHtzZXR0aW5ncy5kdXJhdGlvbn0gbWludXRlcyBzbyBmYXIuYCB9KVxuICAgIGVsLmNyZWF0ZUVsKFwicFwiKVxuICB9XG5cbiAgbmV3IFNldHRpbmcoZWwpXG4gICAgLnNldE5hbWUoXCJSZWZyZXNoIHN1YnNjcmlwdGlvbiBkYXRhXCIpXG4gICAgLnNldERlc2MoXCJJZiB5b3UganVzdCBzdWJzY3JpYmVkIG9yIGNvbm5lY3RlZCB5b3VyIGxpY2Vuc2UsIGNsaWNrIGhlcmUgdG8gcmVmcmVzaCB5b3VyIHN1YnNjcmlwdGlvbiBpbmZvcm1hdGlvbi5cIilcbiAgICAuYWRkQnV0dG9uKChidXR0b24pID0+IHtcbiAgICAgIGJ1dHRvbi5zZXRCdXR0b25UZXh0KFwiUmVmcmVzaFwiKVxuICAgICAgYnV0dG9uLm9uQ2xpY2soYXN5bmMgKGUpID0+IHtcbiAgICAgICAgcmVmcmVzaFN1YnNjcmlwdGlvbkRhdGEocGx1Z2luKVxuICAgICAgICByZW5kZXJTZXR0aW5ncyhlbCwgcGx1Z2luKVxuICAgICAgfSlcbiAgICB9KVxuXG4gIGVsLmNyZWF0ZUVsKFwiaDFcIiwgeyB0ZXh0OiBcIkhlbHBcIiB9KVxuICBjb25zdCBkaXYgPSBlbC5jcmVhdGVEaXYoKVxuICBkaXYuY3JlYXRlU3Bhbih7IHRleHQ6IFwiSWYgeW91IG5lZWQgYW55IGhlbHAsIFwiIH0pXG4gIGRpdi5jcmVhdGVFbChcImFcIiwge1xuICAgIHRleHQ6IFwiZ2V0IGluIHRvdWNoXCIsXG4gICAgYXR0cjoge1xuICAgICAgaHJlZjogXCJtYWlsdG86ZG9taW5pa0BwZWVyZHJhZnQuYXBwXCJcbiAgICB9XG4gIH0pXG4gIGRpdi5jcmVhdGVTcGFuKHsgdGV4dDogJy4nIH0pXG5cbn1cblxuZXhwb3J0IGNvbnN0IGNyZWF0ZVNldHRpbmdzVGFiID0gKHBsdWdpbjogUGVlcmRyYWZ0UGx1Z2luKSA9PiB7XG4gIHJldHVybiBuZXcgY2xhc3MgZXh0ZW5kcyBQbHVnaW5TZXR0aW5nVGFiIHtcbiAgICBhc3luYyBkaXNwbGF5KCkge1xuICAgICAgYXdhaXQgcmVuZGVyU2V0dGluZ3ModGhpcy5jb250YWluZXJFbCwgcGx1Z2luKVxuICAgIH1cbiAgfShwbHVnaW4uYXBwLCBwbHVnaW4pXG59XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVTZXR0aW5nc01vZGFsID0gKHBsdWdpbjogUGVlcmRyYWZ0UGx1Z2luKSA9PiB7XG4gIHJldHVybiBuZXcgY2xhc3MgZXh0ZW5kcyBNb2RhbCB7XG5cbiAgICBhc3luYyBvbk9wZW4oKSB7XG4gICAgICBjb25zdCBlbCA9IHRoaXMuY29udGVudEVsXG4gICAgICBlbC5lbXB0eSgpO1xuXG4gICAgICBjb25zdCBzZXR0aW5ncyA9IGF3YWl0IGdldFNldHRpbmdzKHBsdWdpbilcblxuICAgICAgZWwuY3JlYXRlRWwoXCJoMVwiLCB7IHRleHQ6IFwiV2hhdCdzIHlvdXIgbmFtZT9cIiB9KTtcblxuICAgICAgY29uc3Qgc2V0dGluZyA9IG5ldyBTZXR0aW5nKGVsKVxuICAgICAgc2V0dGluZy5zZXROYW1lKFwiTmFtZVwiKVxuICAgICAgc2V0dGluZy5zZXREZXNjKFwiVGhpcyBuYW1lIHdpbGwgYmUgc2hvd24gdG8geW91ciBjb2xsYWJvcmF0b3JzXCIpXG4gICAgICBzZXR0aW5nLmFkZFRleHQoKHRleHQpID0+IHtcbiAgICAgICAgdGV4dC5zZXRWYWx1ZShzZXR0aW5ncy5uYW1lKVxuICAgICAgICB0ZXh0Lm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgIHNldHRpbmdzLm5hbWUgPSB2YWx1ZVxuICAgICAgICAgIGF3YWl0IHNhdmVTZXR0aW5ncyhzZXR0aW5ncywgcGx1Z2luKTtcbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgb25DbG9zZSgpIHtcbiAgICAgIHRoaXMuY29udGVudEVsLmVtcHR5KClcbiAgICB9XG5cbiAgfShwbHVnaW4uYXBwKVxufSIsICJpbXBvcnQgeyBQbHVnaW4sIHJlcXVlc3RVcmwgfSBmcm9tIFwib2JzaWRpYW5cIlxuaW1wb3J0IHsgZ2V0U2V0dGluZ3MsIHNhdmVTZXR0aW5ncyB9IGZyb20gXCIuL3NldHRpbmdzXCJcbmltcG9ydCBQZWVyZHJhZnRQbHVnaW4gZnJvbSBcIi4vbWFpblwiXG5cbmV4cG9ydCBjb25zdCByZWZyZXNoU3Vic2NyaXB0aW9uRGF0YSA9IGFzeW5jIChwbHVnaW46IFBlZXJkcmFmdFBsdWdpbikgPT4ge1xuICBjb25zdCBzZXR0aW5ncyA9IGF3YWl0IGdldFNldHRpbmdzKHBsdWdpbilcbiAgY29uc3QgdXJsID0gbmV3IFVSTChzZXR0aW5ncy5zdWJzY3JpcHRpb25BUEkpXG4gIHVybC5zZWFyY2hQYXJhbXMuc2V0KCdvaWQnLCBzZXR0aW5ncy5vaWQpXG4gIGNvbnN0IGRhdGEgPSBhd2FpdCByZXF1ZXN0VXJsKHVybC50b1N0cmluZygpKS5qc29uXG4gIGlmIChkYXRhKSB7XG4gICAgaWYoZGF0YS5wbGFuKSB7XG4gICAgICBzZXR0aW5ncy5wbGFuID0gZGF0YS5wbGFuXG4gICAgfVxuICAgIGlmKGRhdGEudXNhZ2UpIHtcbiAgICAgIHNldHRpbmdzLmR1cmF0aW9uID0gZGF0YS51c2FnZVxuICAgIH1cbiAgICBhd2FpdCBzYXZlU2V0dGluZ3Moc2V0dGluZ3MsIHBsdWdpbilcbiAgfVxufVxuXG4iLCAiaW1wb3J0IHsgQXBwLCBTdWdnZXN0TW9kYWwsIFRGaWxlLCBURm9sZGVyLCBWYXVsdCB9IGZyb20gXCJvYnNpZGlhblwiO1xuaW1wb3J0ICogYXMgcGF0aCBmcm9tIFwicGF0aFwiO1xuXG5leHBvcnQgY2xhc3MgU2VsZWN0Rm9sZGVyTW9kYWwgZXh0ZW5kcyBTdWdnZXN0TW9kYWw8VEZvbGRlcj4ge1xuXG4gIGZvbGRlcnM6IEFycmF5PFRGb2xkZXI+XG4gIGNiOiAoZm9sZGVyOiBURm9sZGVyKSA9PiBhbnlcbiAgc2VsZWN0ZWRGb2xkZXI6IFRGb2xkZXJcblxuICBjb25zdHJ1Y3RvcihhcHA6IEFwcCwgY2I6IChmaWxlOiBURm9sZGVyKSA9PiBhbnkpIHtcbiAgICBzdXBlcihhcHApXG4gICAgdGhpcy5jYiA9IGNiXG5cbiAgICB0aGlzLmZvbGRlcnMgPSBbXVxuICAgIFZhdWx0LnJlY3Vyc2VDaGlsZHJlbihhcHAudmF1bHQuZ2V0Um9vdCgpLCAoZmlsZSkgPT4ge1xuICAgICAgaWYgKGZpbGUgaW5zdGFuY2VvZiBURm9sZGVyKSB0aGlzLmZvbGRlcnMucHVzaChmaWxlKVxuICAgIH0pXG4gICAgLy8gcmVtb3ZlIHJvb3QgJiBzb3J0XG4gICAgdGhpcy5mb2xkZXJzLnNoaWZ0KClcbiAgICB0aGlzLmZvbGRlcnMuc29ydCgoYSwgYikgPT4ge1xuICAgICAgcmV0dXJuIGEucGF0aC50b0xvY2FsZUxvd2VyQ2FzZSgpLmxvY2FsZUNvbXBhcmUoYi5wYXRoLnRvTG9jYWxlTG93ZXJDYXNlKCkpXG4gICAgfSlcbiAgfVxuXG4gIG9uT3BlbigpIHtcbiAgICBzdXBlci5vbk9wZW4oKVxuICAgIHRoaXMuaW5wdXRFbC5wbGFjZWhvbGRlciA9IFwiQ2hvb3NlIGEgbG9jYXRpb25cIlxuICB9XG5cbiAgZ2V0U3VnZ2VzdGlvbnMocXVlcnk6IHN0cmluZyk6IFRGb2xkZXJbXSB7XG4gICAgcmV0dXJuIHRoaXMuZm9sZGVycy5maWx0ZXIoZm9sZGVyID0+IHtcbiAgICAgIHJldHVybiBmb2xkZXIucGF0aC50b0xvY2FsZUxvd2VyQ2FzZSgpLmluY2x1ZGVzKHF1ZXJ5LnRvTG9jYWxlTG93ZXJDYXNlKCkpXG4gICAgfSlcbiAgfVxuXG4gIHJlbmRlclN1Z2dlc3Rpb24odmFsdWU6IFRGb2xkZXIsIGVsOiBIVE1MRWxlbWVudCkge1xuICAgIGVsLnNldFRleHQodmFsdWUucGF0aClcbiAgfVxuXG4gIHNlbGVjdFN1Z2dlc3Rpb24odmFsdWU6IFRGb2xkZXIsIGV2dDogTW91c2VFdmVudCB8IEtleWJvYXJkRXZlbnQpOiB2b2lkIHtcbiAgICB0aGlzLnNlbGVjdGVkRm9sZGVyID0gdmFsdWVcbiAgICBzdXBlci5zZWxlY3RTdWdnZXN0aW9uKHZhbHVlLCBldnQpXG4gIH1cblxuICBvbkNob29zZVN1Z2dlc3Rpb24oaXRlbTogVEZvbGRlciwgZXZ0OiBNb3VzZUV2ZW50IHwgS2V5Ym9hcmRFdmVudCkge1xuICB9XG5cbiAgb25DbG9zZSgpOiB2b2lkIHtcbiAgICB0aGlzLmNiKHRoaXMuc2VsZWN0ZWRGb2xkZXIpXG4gIH1cblxufVxuXG5leHBvcnQgY29uc3QgcHJvbXB0Rm9yRm9sZGVyU2VsZWN0aW9uID0gYXN5bmMgKGFwcDogQXBwKSA9PiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZTxURm9sZGVyIHwgdm9pZD4oKHJlc29sdmUpID0+IHtcbiAgICBuZXcgU2VsZWN0Rm9sZGVyTW9kYWwoYXBwLCAoZm9sZGVyKSA9PiB7XG4gICAgICByZXNvbHZlKGZvbGRlcilcbiAgICB9KS5vcGVuKClcbiAgfSlcbn0iLCAiZGVjbGFyZSB2YXIgZ2xvYmFsO1xuZXhwb3J0IGNvbnN0IF9nbG9iYWw6IGFueSA9XG4gICAgdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsVGhpcyA6XG4gICAgdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6XG4gICAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOlxuICAgIGdsb2JhbDtcbiIsICLvu79pbXBvcnQgeyBfZ2xvYmFsIH0gZnJvbSBcIi4uL2dsb2JhbHMvZ2xvYmFsXCI7XG5leHBvcnQgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzO1xuZXhwb3J0IGNvbnN0IGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuaWYgKHR5cGVvZiBQcm9taXNlICE9PSAndW5kZWZpbmVkJyAmJiAhX2dsb2JhbC5Qcm9taXNlKXtcbiAgICAvLyBJbiBqc2RvbSwgdGhpcyBpdCBjYW4gYmUgdGhlIGNhc2UgdGhhdCBQcm9taXNlIGlzIG5vdCBwdXQgb24gdGhlIGdsb2JhbCBvYmplY3QuXG4gICAgLy8gSWYgc28sIHdlIG5lZWQgdG8gcGF0Y2ggdGhlIGdsb2JhbCBvYmplY3QgZm9yIHRoZSByZXN0IG9mIHRoZSBjb2RlIHRvIHdvcmsgYXMgZXhwZWN0ZWQuXG4gICAgLy8gT3RoZXIgZGV4aWUgY29kZSBleHBlY3RzIFByb21pc2UgdG8gYmUgb24gdGhlIGdsb2JhbCBvYmplY3QgKGxpa2Ugbm9ybWFsIGJyb3dzZXIgZW52aXJvbm1lbnRzKVxuICAgIF9nbG9iYWwuUHJvbWlzZSA9IFByb21pc2U7XG59XG5leHBvcnQgeyBfZ2xvYmFsIH1cblxuZXhwb3J0IGZ1bmN0aW9uIGV4dGVuZDxUIGV4dGVuZHMgb2JqZWN0LFggZXh0ZW5kcyBvYmplY3Q+KG9iajogVCwgZXh0ZW5zaW9uOiBYKTogVCAmIFggIHtcbiAgICBpZiAodHlwZW9mIGV4dGVuc2lvbiAhPT0gJ29iamVjdCcpIHJldHVybiBvYmogYXMgVCAmIFg7XG4gICAga2V5cyhleHRlbnNpb24pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBvYmpba2V5XSA9IGV4dGVuc2lvbltrZXldO1xuICAgIH0pO1xuICAgIHJldHVybiBvYmogYXMgVCAmIFg7XG59XG5cbmV4cG9ydCBjb25zdCBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbmV4cG9ydCBjb25zdCBfaGFzT3duID0ge30uaGFzT3duUHJvcGVydHk7XG5leHBvcnQgZnVuY3Rpb24gaGFzT3duKG9iaiwgcHJvcCkge1xuICAgIHJldHVybiBfaGFzT3duLmNhbGwob2JqLCBwcm9wKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHByb3BzIChwcm90bywgZXh0ZW5zaW9uKSB7XG4gICAgaWYgKHR5cGVvZiBleHRlbnNpb24gPT09ICdmdW5jdGlvbicpIGV4dGVuc2lvbiA9IGV4dGVuc2lvbihnZXRQcm90byhwcm90bykpO1xuICAgICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiA/IGtleXMgOiBSZWZsZWN0Lm93bktleXMpKGV4dGVuc2lvbikuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICBzZXRQcm9wKHByb3RvLCBrZXksIGV4dGVuc2lvbltrZXldKTtcbiAgICB9KTtcbn1cblxuZXhwb3J0IGNvbnN0IGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXG5leHBvcnQgZnVuY3Rpb24gc2V0UHJvcChvYmosIHByb3AsIGZ1bmN0aW9uT3JHZXRTZXQsIG9wdGlvbnM/KSB7XG4gICAgZGVmaW5lUHJvcGVydHkob2JqLCBwcm9wLCBleHRlbmQoZnVuY3Rpb25PckdldFNldCAmJiBoYXNPd24oZnVuY3Rpb25PckdldFNldCwgXCJnZXRcIikgJiYgdHlwZW9mIGZ1bmN0aW9uT3JHZXRTZXQuZ2V0ID09PSAnZnVuY3Rpb24nID9cbiAgICAgICAge2dldDogZnVuY3Rpb25PckdldFNldC5nZXQsIHNldDogZnVuY3Rpb25PckdldFNldC5zZXQsIGNvbmZpZ3VyYWJsZTogdHJ1ZX0gOlxuICAgICAgICB7dmFsdWU6IGZ1bmN0aW9uT3JHZXRTZXQsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWV9LCBvcHRpb25zKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZXJpdmUoQ2hpbGQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBmcm9tOiBmdW5jdGlvbiAoUGFyZW50KSB7XG4gICAgICAgICAgICBDaGlsZC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFBhcmVudC5wcm90b3R5cGUpO1xuICAgICAgICAgICAgc2V0UHJvcChDaGlsZC5wcm90b3R5cGUsIFwiY29uc3RydWN0b3JcIiwgQ2hpbGQpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBleHRlbmQ6IHByb3BzLmJpbmQobnVsbCwgQ2hpbGQucHJvdG90eXBlKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH07XG59XG5cbmV4cG9ydCBjb25zdCBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UHJvcGVydHlEZXNjcmlwdG9yKG9iaiwgcHJvcCkge1xuICAgIGNvbnN0IHBkID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwgcHJvcCk7XG4gICAgbGV0IHByb3RvO1xuICAgIHJldHVybiBwZCB8fCAocHJvdG8gPSBnZXRQcm90byhvYmopKSAmJiBnZXRQcm9wZXJ0eURlc2NyaXB0b3IgKHByb3RvLCBwcm9wKTtcbn1cblxuY29uc3QgX3NsaWNlID0gW10uc2xpY2U7XG5leHBvcnQgZnVuY3Rpb24gc2xpY2UoYXJncywgc3RhcnQ/LCBlbmQ/KSB7XG4gICAgcmV0dXJuIF9zbGljZS5jYWxsKGFyZ3MsIHN0YXJ0LCBlbmQpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gb3ZlcnJpZGUob3JpZ0Z1bmMsIG92ZXJyaWRlZEZhY3RvcnkpIHtcbiAgICByZXR1cm4gb3ZlcnJpZGVkRmFjdG9yeShvcmlnRnVuYyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnQgKGIpIHtcbiAgICBpZiAoIWIpIHRocm93IG5ldyBFcnJvcihcIkFzc2VydGlvbiBGYWlsZWRcIik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhc2FwKGZuKSB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGlmIChfZ2xvYmFsLnNldEltbWVkaWF0ZSkgc2V0SW1tZWRpYXRlKGZuKTsgZWxzZSBzZXRUaW1lb3V0KGZuLCAwKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFVuaXF1ZUFycmF5KGEpIHtcbiAgICByZXR1cm4gYS5maWx0ZXIoKHZhbHVlLCBpbmRleCwgc2VsZikgPT4gc2VsZi5pbmRleE9mKHZhbHVlKSA9PT0gaW5kZXgpO1xufVxuXG4vKiogR2VuZXJhdGUgYW4gb2JqZWN0IChoYXNoIG1hcCkgYmFzZWQgb24gZ2l2ZW4gYXJyYXkuXG4gKiBAcGFyYW0gZXh0cmFjdG9yIEZ1bmN0aW9uIHRha2luZyBhbiBhcnJheSBpdGVtIGFuZCBpdHMgaW5kZXggYW5kIHJldHVybmluZyBhbiBhcnJheSBvZiAyIGl0ZW1zIChba2V5LCB2YWx1ZV0pIHRvXG4gKiAgICAgICAgaW5zdGVydCBvbiB0aGUgcmVzdWx0aW5nIG9iamVjdCBmb3IgZWFjaCBpdGVtIGluIHRoZSBhcnJheS4gSWYgdGhpcyBmdW5jdGlvbiByZXR1cm5zIGEgZmFsc3kgdmFsdWUsIHRoZVxuICogICAgICAgIGN1cnJlbnQgaXRlbSB3b250IGFmZmVjdCB0aGUgcmVzdWx0aW5nIG9iamVjdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFycmF5VG9PYmplY3Q8VCxSPiAoYXJyYXk6IFRbXSwgZXh0cmFjdG9yOiAoeDpULCBpZHg6IG51bWJlcik9PltzdHJpbmcsIFJdKToge1tuYW1lOiBzdHJpbmddOiBSfSB7XG4gICAgcmV0dXJuIGFycmF5LnJlZHVjZSgocmVzdWx0LCBpdGVtLCBpKSA9PiB7XG4gICAgICAgIHZhciBuYW1lQW5kVmFsdWUgPSBleHRyYWN0b3IoaXRlbSwgaSk7XG4gICAgICAgIGlmIChuYW1lQW5kVmFsdWUpIHJlc3VsdFtuYW1lQW5kVmFsdWVbMF1dID0gbmFtZUFuZFZhbHVlWzFdO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sIHt9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRyeWNhdGNoZXIoZm4sIHJlamVjdCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdHJ5Q2F0Y2goZm46ICguLi5hcmdzOiBhbnlbXSk9PnZvaWQsIG9uZXJyb3IsIGFyZ3M/KSA6IHZvaWQge1xuICAgIHRyeSB7XG4gICAgICAgIGZuLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgIG9uZXJyb3IgJiYgb25lcnJvcihleCk7XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0QnlLZXlQYXRoKG9iaiwga2V5UGF0aCkge1xuICAgIC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL0luZGV4ZWREQi8jc3RlcHMtZm9yLWV4dHJhY3RpbmctYS1rZXktZnJvbS1hLXZhbHVlLXVzaW5nLWEta2V5LXBhdGhcbiAgICBpZiAodHlwZW9mIGtleVBhdGggPT09ICdzdHJpbmcnICYmIGhhc093bihvYmosIGtleVBhdGgpKSByZXR1cm4gb2JqW2tleVBhdGhdOyAvLyBUaGlzIGxpbmUgaXMgbW92ZWQgZnJvbSBsYXN0IHRvIGZpcnN0IGZvciBvcHRpbWl6YXRpb24gcHVycG9zZS5cbiAgICBpZiAoIWtleVBhdGgpIHJldHVybiBvYmo7XG4gICAgaWYgKHR5cGVvZiBrZXlQYXRoICE9PSAnc3RyaW5nJykge1xuICAgICAgICB2YXIgcnYgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBrZXlQYXRoLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgICAgdmFyIHZhbCA9IGdldEJ5S2V5UGF0aChvYmosIGtleVBhdGhbaV0pO1xuICAgICAgICAgICAgcnYucHVzaCh2YWwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBydjtcbiAgICB9XG4gICAgdmFyIHBlcmlvZCA9IGtleVBhdGguaW5kZXhPZignLicpO1xuICAgIGlmIChwZXJpb2QgIT09IC0xKSB7XG4gICAgICAgIHZhciBpbm5lck9iaiA9IG9ialtrZXlQYXRoLnN1YnN0cigwLCBwZXJpb2QpXTtcbiAgICAgICAgcmV0dXJuIGlubmVyT2JqID09IG51bGwgPyB1bmRlZmluZWQgOiBnZXRCeUtleVBhdGgoaW5uZXJPYmosIGtleVBhdGguc3Vic3RyKHBlcmlvZCArIDEpKTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNldEJ5S2V5UGF0aChvYmosIGtleVBhdGgsIHZhbHVlKSB7XG4gICAgaWYgKCFvYmogfHwga2V5UGF0aCA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG4gICAgaWYgKCdpc0Zyb3plbicgaW4gT2JqZWN0ICYmIE9iamVjdC5pc0Zyb3plbihvYmopKSByZXR1cm47XG4gICAgaWYgKHR5cGVvZiBrZXlQYXRoICE9PSAnc3RyaW5nJyAmJiAnbGVuZ3RoJyBpbiBrZXlQYXRoKSB7XG4gICAgICAgIGFzc2VydCh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnICYmICdsZW5ndGgnIGluIHZhbHVlKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBrZXlQYXRoLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgICAgc2V0QnlLZXlQYXRoKG9iaiwga2V5UGF0aFtpXSwgdmFsdWVbaV0pO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHBlcmlvZCA9IGtleVBhdGguaW5kZXhPZignLicpO1xuICAgICAgICBpZiAocGVyaW9kICE9PSAtMSkge1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRLZXlQYXRoID0ga2V5UGF0aC5zdWJzdHIoMCwgcGVyaW9kKTtcbiAgICAgICAgICAgIHZhciByZW1haW5pbmdLZXlQYXRoID0ga2V5UGF0aC5zdWJzdHIocGVyaW9kICsgMSk7XG4gICAgICAgICAgICBpZiAocmVtYWluaW5nS2V5UGF0aCA9PT0gXCJcIilcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNBcnJheShvYmopICYmICFpc05hTihwYXJzZUludChjdXJyZW50S2V5UGF0aCkpKSBvYmouc3BsaWNlKGN1cnJlbnRLZXlQYXRoLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBkZWxldGUgb2JqW2N1cnJlbnRLZXlQYXRoXTtcbiAgICAgICAgICAgICAgICB9IGVsc2Ugb2JqW2N1cnJlbnRLZXlQYXRoXSA9IHZhbHVlO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGlubmVyT2JqID0gb2JqW2N1cnJlbnRLZXlQYXRoXTtcbiAgICAgICAgICAgICAgICBpZiAoIWlubmVyT2JqIHx8ICFoYXNPd24ob2JqLCBjdXJyZW50S2V5UGF0aCkpIGlubmVyT2JqID0gKG9ialtjdXJyZW50S2V5UGF0aF0gPSB7fSk7XG4gICAgICAgICAgICAgICAgc2V0QnlLZXlQYXRoKGlubmVyT2JqLCByZW1haW5pbmdLZXlQYXRoLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmIChpc0FycmF5KG9iaikgJiYgIWlzTmFOKHBhcnNlSW50KGtleVBhdGgpKSkgb2JqLnNwbGljZShrZXlQYXRoLCAxKTtcbiAgICAgICAgICAgICAgICBlbHNlIGRlbGV0ZSBvYmpba2V5UGF0aF07XG4gICAgICAgICAgICB9IGVsc2Ugb2JqW2tleVBhdGhdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWxCeUtleVBhdGgob2JqLCBrZXlQYXRoKSB7XG4gICAgaWYgKHR5cGVvZiBrZXlQYXRoID09PSAnc3RyaW5nJylcbiAgICAgICAgc2V0QnlLZXlQYXRoKG9iaiwga2V5UGF0aCwgdW5kZWZpbmVkKTtcbiAgICBlbHNlIGlmICgnbGVuZ3RoJyBpbiBrZXlQYXRoKVxuICAgICAgICBbXS5tYXAuY2FsbChrZXlQYXRoLCBmdW5jdGlvbihrcCkge1xuICAgICAgICAgICAgc2V0QnlLZXlQYXRoKG9iaiwga3AsIHVuZGVmaW5lZCk7XG4gICAgICAgIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2hhbGxvd0Nsb25lKG9iaikge1xuICAgIHZhciBydiA9IHt9O1xuICAgIGZvciAodmFyIG0gaW4gb2JqKSB7XG4gICAgICAgIGlmIChoYXNPd24ob2JqLCBtKSkgcnZbbV0gPSBvYmpbbV07XG4gICAgfVxuICAgIHJldHVybiBydjtcbn1cblxuY29uc3QgY29uY2F0ID0gW10uY29uY2F0O1xuZXhwb3J0IGZ1bmN0aW9uIGZsYXR0ZW48VD4gKGE6IChUIHwgVFtdKVtdKSA6IFRbXSB7XG4gICAgcmV0dXJuIGNvbmNhdC5hcHBseShbXSwgYSk7XG59XG5cbi8vaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dlYl9Xb3JrZXJzX0FQSS9TdHJ1Y3R1cmVkX2Nsb25lX2FsZ29yaXRobVxuY29uc3QgaW50cmluc2ljVHlwZU5hbWVzID1cbiAgICBcIkJpZ1VpbnQ2NEFycmF5LEJpZ0ludDY0QXJyYXksQXJyYXksQm9vbGVhbixTdHJpbmcsRGF0ZSxSZWdFeHAsQmxvYixGaWxlLEZpbGVMaXN0LEZpbGVTeXN0ZW1GaWxlSGFuZGxlLEZpbGVTeXN0ZW1EaXJlY3RvcnlIYW5kbGUsQXJyYXlCdWZmZXIsRGF0YVZpZXcsVWludDhDbGFtcGVkQXJyYXksSW1hZ2VCaXRtYXAsSW1hZ2VEYXRhLE1hcCxTZXQsQ3J5cHRvS2V5XCJcbiAgICAuc3BsaXQoJywnKS5jb25jYXQoXG4gICAgICAgIGZsYXR0ZW4oWzgsMTYsMzIsNjRdLm1hcChudW09PltcIkludFwiLFwiVWludFwiLFwiRmxvYXRcIl0ubWFwKHQ9PnQrbnVtK1wiQXJyYXlcIikpKVxuICAgICkuZmlsdGVyKHQ9Pl9nbG9iYWxbdF0pO1xuY29uc3QgaW50cmluc2ljVHlwZXMgPSBpbnRyaW5zaWNUeXBlTmFtZXMubWFwKHQ9Pl9nbG9iYWxbdF0pO1xuZXhwb3J0IGNvbnN0IGludHJpbnNpY1R5cGVOYW1lU2V0ID0gYXJyYXlUb09iamVjdChpbnRyaW5zaWNUeXBlTmFtZXMsIHg9Plt4LHRydWVdKTtcblxubGV0IGNpcmN1bGFyUmVmczogbnVsbCB8IFdlYWtNYXA8YW55LGFueT4gPSBudWxsO1xuZXhwb3J0IGZ1bmN0aW9uIGRlZXBDbG9uZTxUPihhbnk6IFQpOiBUIHtcbiAgICBjaXJjdWxhclJlZnMgPSB0eXBlb2YgV2Vha01hcCAhPT0gJ3VuZGVmaW5lZCcgJiYgbmV3IFdlYWtNYXAoKTtcbiAgICBjb25zdCBydiA9IGlubmVyRGVlcENsb25lKGFueSk7XG4gICAgY2lyY3VsYXJSZWZzID0gbnVsbDtcbiAgICByZXR1cm4gcnY7XG59XG5cbmZ1bmN0aW9uIGlubmVyRGVlcENsb25lPFQ+KGFueTogVCk6IFQge1xuICAgIGlmICghYW55IHx8IHR5cGVvZiBhbnkgIT09ICdvYmplY3QnKSByZXR1cm4gYW55O1xuICAgIGxldCBydiA9IGNpcmN1bGFyUmVmcyAmJiBjaXJjdWxhclJlZnMuZ2V0KGFueSk7IC8vIFJlc29sdmUgY2lyY3VsYXIgcmVmZXJlbmNlc1xuICAgIGlmIChydikgcmV0dXJuIHJ2O1xuICAgIGlmIChpc0FycmF5KGFueSkpIHtcbiAgICAgICAgcnYgPSBbXTtcbiAgICAgICAgY2lyY3VsYXJSZWZzICYmIGNpcmN1bGFyUmVmcy5zZXQoYW55LCBydik7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gYW55Lmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgICAgcnYucHVzaChpbm5lckRlZXBDbG9uZShhbnlbaV0pKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaW50cmluc2ljVHlwZXMuaW5kZXhPZihhbnkuY29uc3RydWN0b3IpID49IDApIHtcbiAgICAgICAgcnYgPSBhbnk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgcHJvdG8gPSBnZXRQcm90byhhbnkpO1xuICAgICAgICBydiA9IHByb3RvID09PSBPYmplY3QucHJvdG90eXBlID8ge30gOiBPYmplY3QuY3JlYXRlKHByb3RvKTtcbiAgICAgICAgY2lyY3VsYXJSZWZzICYmIGNpcmN1bGFyUmVmcy5zZXQoYW55LCBydik7XG4gICAgICAgIGZvciAodmFyIHByb3AgaW4gYW55KSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duKGFueSwgcHJvcCkpIHtcbiAgICAgICAgICAgICAgICBydltwcm9wXSA9IGlubmVyRGVlcENsb25lKGFueVtwcm9wXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJ2O1xufVxuXG5jb25zdCB7dG9TdHJpbmd9ID0ge307XG5leHBvcnQgZnVuY3Rpb24gdG9TdHJpbmdUYWcobzogT2JqZWN0KSB7XG4gICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpO1xufVxuXG4vLyBJZiBmaXJzdCBhcmd1bWVudCBpcyBpdGVyYWJsZSBvciBhcnJheS1saWtlLCByZXR1cm4gaXQgYXMgYW4gYXJyYXlcbmV4cG9ydCBjb25zdCBpdGVyYXRvclN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnID9cbiAgICBTeW1ib2wuaXRlcmF0b3IgOlxuICAgICdAQGl0ZXJhdG9yJztcbmV4cG9ydCBjb25zdCBnZXRJdGVyYXRvck9mID0gdHlwZW9mIGl0ZXJhdG9yU3ltYm9sID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24oeCkge1xuICAgIHZhciBpO1xuICAgIHJldHVybiB4ICE9IG51bGwgJiYgKGkgPSB4W2l0ZXJhdG9yU3ltYm9sXSkgJiYgaS5hcHBseSh4KTtcbn0gOiBmdW5jdGlvbiAoKSB7IHJldHVybiBudWxsOyB9O1xuZXhwb3J0IGNvbnN0IGFzeW5jSXRlcmF0b3JTeW1ib2wgPSB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJ1xuICAgID8gU3ltYm9sLmFzeW5jSXRlcmF0b3IgfHwgU3ltYm9sLmZvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yXCIpXG4gICAgOiAnQGFzeW5jSXRlcmF0b3InO1xuXG5leHBvcnQgY29uc3QgTk9fQ0hBUl9BUlJBWSA9IHt9O1xuLy8gVGFrZXMgb25lIG9yIHNldmVyYWwgYXJndW1lbnRzIGFuZCByZXR1cm5zIGFuIGFycmF5IGJhc2VkIG9uIHRoZSBmb2xsb3dpbmcgY3JpdGVyYXM6XG4vLyAqIElmIHNldmVyYWwgYXJndW1lbnRzIHByb3ZpZGVkLCByZXR1cm4gYXJndW1lbnRzIGNvbnZlcnRlZCB0byBhbiBhcnJheSBpbiBhIHdheSB0aGF0XG4vLyAgIHN0aWxsIGFsbG93cyBqYXZhc2NyaXB0IGVuZ2luZSB0byBvcHRpbWl6ZSB0aGUgY29kZS5cbi8vICogSWYgc2luZ2xlIGFyZ3VtZW50IGlzIGFuIGFycmF5LCByZXR1cm4gYSBjbG9uZSBvZiBpdC5cbi8vICogSWYgdGhpcy1wb2ludGVyIGVxdWFscyBOT19DSEFSX0FSUkFZLCBkb24ndCBhY2NlcHQgc3RyaW5ncyBhcyB2YWxpZCBpdGVyYWJsZXMgYXMgYSBzcGVjaWFsXG4vLyAgIGNhc2UgdG8gdGhlIHR3byBidWxsZXRzIGJlbG93LlxuLy8gKiBJZiBzaW5nbGUgYXJndW1lbnQgaXMgYW4gaXRlcmFibGUsIGNvbnZlcnQgaXQgdG8gYW4gYXJyYXkgYW5kIHJldHVybiB0aGUgcmVzdWx0aW5nIGFycmF5LlxuLy8gKiBJZiBzaW5nbGUgYXJndW1lbnQgaXMgYXJyYXktbGlrZSAoaGFzIGxlbmd0aCBvZiB0eXBlIG51bWJlciksIGNvbnZlcnQgaXQgdG8gYW4gYXJyYXkuXG5leHBvcnQgZnVuY3Rpb24gZ2V0QXJyYXlPZiAoYXJyYXlMaWtlKSB7XG4gICAgdmFyIGksIGEsIHgsIGl0O1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGlmIChpc0FycmF5KGFycmF5TGlrZSkpIHJldHVybiBhcnJheUxpa2Uuc2xpY2UoKTtcbiAgICAgICAgaWYgKHRoaXMgPT09IE5PX0NIQVJfQVJSQVkgJiYgdHlwZW9mIGFycmF5TGlrZSA9PT0gJ3N0cmluZycpIHJldHVybiBbYXJyYXlMaWtlXTtcbiAgICAgICAgaWYgKChpdCA9IGdldEl0ZXJhdG9yT2YoYXJyYXlMaWtlKSkpIHtcbiAgICAgICAgICAgIGEgPSBbXTtcbiAgICAgICAgICAgIHdoaWxlICgoeCA9IGl0Lm5leHQoKSksICF4LmRvbmUpIGEucHVzaCh4LnZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhcnJheUxpa2UgPT0gbnVsbCkgcmV0dXJuIFthcnJheUxpa2VdO1xuICAgICAgICBpID0gYXJyYXlMaWtlLmxlbmd0aDtcbiAgICAgICAgaWYgKHR5cGVvZiBpID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgYSA9IG5ldyBBcnJheShpKTtcbiAgICAgICAgICAgIHdoaWxlIChpLS0pIGFbaV0gPSBhcnJheUxpa2VbaV07XG4gICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW2FycmF5TGlrZV07XG4gICAgfVxuICAgIGkgPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGEgPSBuZXcgQXJyYXkoaSk7XG4gICAgd2hpbGUgKGktLSkgYVtpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICByZXR1cm4gYTtcbn1cbmV4cG9ydCBjb25zdCBpc0FzeW5jRnVuY3Rpb24gPSB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJ1xuICAgID8gKGZuOiBGdW5jdGlvbikgPT4gZm5bU3ltYm9sLnRvU3RyaW5nVGFnXSA9PT0gJ0FzeW5jRnVuY3Rpb24nXG4gICAgOiAoKT0+ZmFsc2U7XG4iLCAiLy8gQnkgZGVmYXVsdCwgZGVidWcgd2lsbCBiZSB0cnVlIG9ubHkgaWYgcGxhdGZvcm0gaXMgYSB3ZWIgcGxhdGZvcm0gYW5kIGl0cyBwYWdlIGlzIHNlcnZlZCBmcm9tIGxvY2FsaG9zdC5cbi8vIFdoZW4gZGVidWcgPSB0cnVlLCBlcnJvcidzIHN0YWNrcyB3aWxsIGNvbnRhaW4gYXN5bmNyb25pYyBsb25nIHN0YWNrcy5cbmV4cG9ydCB2YXIgZGVidWcgPSB0eXBlb2YgbG9jYXRpb24gIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIC8vIEJ5IGRlZmF1bHQsIHVzZSBkZWJ1ZyBtb2RlIGlmIHNlcnZlZCBmcm9tIGxvY2FsaG9zdC5cbiAgICAgICAgL14oaHR0cHxodHRwcyk6XFwvXFwvKGxvY2FsaG9zdHwxMjdcXC4wXFwuMFxcLjEpLy50ZXN0KGxvY2F0aW9uLmhyZWYpO1xuXG5leHBvcnQgZnVuY3Rpb24gc2V0RGVidWcodmFsdWUsIGZpbHRlcikge1xuICAgIGRlYnVnID0gdmFsdWU7XG4gICAgbGlicmFyeUZpbHRlciA9IGZpbHRlcjtcbn1cblxuZXhwb3J0IHZhciBsaWJyYXJ5RmlsdGVyID0gKCkgPT4gdHJ1ZTtcblxuZXhwb3J0IGNvbnN0IE5FRURTX1RIUk9XX0ZPUl9TVEFDSyA9ICFuZXcgRXJyb3IoXCJcIikuc3RhY2s7XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRFcnJvcldpdGhTdGFjaygpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBpZiAoTkVFRFNfVEhST1dfRk9SX1NUQUNLKSB0cnkge1xuICAgICAgICAvLyBEb2luZyBzb21ldGhpbmcgbmF1Z2h0eSBpbiBzdHJpY3QgbW9kZSBoZXJlIHRvIHRyaWdnZXIgYSBzcGVjaWZpYyBlcnJvclxuICAgICAgICAvLyB0aGF0IGNhbiBiZSBleHBsaWNpdGVseSBpZ25vcmVkIGluIGRlYnVnZ2VyJ3MgZXhjZXB0aW9uIHNldHRpbmdzLlxuICAgICAgICAvLyBJZiB3ZSdkIGp1c3QgdGhyb3cgbmV3IEVycm9yKCkgaGVyZSwgSUUncyBkZWJ1Z2dlcidzIGV4Y2VwdGlvbiBzZXR0aW5nc1xuICAgICAgICAvLyB3aWxsIGp1c3QgY29uc2lkZXIgaXQgYXMgXCJleGNlcHRpb24gdGhyb3duIGJ5IGphdmFzY3JpcHQgY29kZVwiIHdoaWNoIGlzXG4gICAgICAgIC8vIHNvbWV0aGluZyB5b3Ugd291bGRuJ3Qgd2FudCBpdCB0byBpZ25vcmUuXG4gICAgICAgIGdldEVycm9yV2l0aFN0YWNrLmFyZ3VtZW50cztcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCk7IC8vIEZhbGxiYWNrIGlmIGFib3ZlIGxpbmUgZG9uJ3QgdGhyb3cuXG4gICAgfSBjYXRjaChlKSB7XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEVycm9yKCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwcmV0dHlTdGFjayhleGNlcHRpb24sIG51bUlnbm9yZWRGcmFtZXMpIHtcbiAgICB2YXIgc3RhY2sgPSBleGNlcHRpb24uc3RhY2s7XG4gICAgaWYgKCFzdGFjaykgcmV0dXJuIFwiXCI7XG4gICAgbnVtSWdub3JlZEZyYW1lcyA9IChudW1JZ25vcmVkRnJhbWVzIHx8IDApO1xuICAgIGlmIChzdGFjay5pbmRleE9mKGV4Y2VwdGlvbi5uYW1lKSA9PT0gMClcbiAgICAgICAgbnVtSWdub3JlZEZyYW1lcyArPSAoZXhjZXB0aW9uLm5hbWUgKyBleGNlcHRpb24ubWVzc2FnZSkuc3BsaXQoJ1xcbicpLmxlbmd0aDtcbiAgICByZXR1cm4gc3RhY2suc3BsaXQoJ1xcbicpXG4gICAgICAgIC5zbGljZShudW1JZ25vcmVkRnJhbWVzKVxuICAgICAgICAuZmlsdGVyKGxpYnJhcnlGaWx0ZXIpXG4gICAgICAgIC5tYXAoZnJhbWUgPT4gXCJcXG5cIiArIGZyYW1lKVxuICAgICAgICAuam9pbignJyk7XG59XG5cbi8vIFRPRE86IFJlcGxhY2UgdGhpcyBpbiBmYXZvciBvZiBhIGRlY29yYXRvciBpbnN0ZWFkLlxuZXhwb3J0IGZ1bmN0aW9uIGRlcHJlY2F0ZWQ8VD4gKHdoYXQ6IHN0cmluZywgZm46ICguLi5hcmdzKT0+VCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgJHt3aGF0fSBpcyBkZXByZWNhdGVkLiBTZWUgaHR0cHM6Ly9kZXhpZS5vcmcvZG9jcy9EZXByZWNhdGlvbnMuICR7cHJldHR5U3RhY2soZ2V0RXJyb3JXaXRoU3RhY2soKSwgMSl9YCk7XG4gICAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0gYXMgKC4uLmFyZ3MpPT5UXG59XG4iLCAiaW1wb3J0IHsgZGVyaXZlLCBzZXRQcm9wIH0gZnJvbSAnLi4vZnVuY3Rpb25zL3V0aWxzJztcbmltcG9ydCB7IGdldEVycm9yV2l0aFN0YWNrLCBwcmV0dHlTdGFjayB9IGZyb20gJy4uL2hlbHBlcnMvZGVidWcnO1xuXG52YXIgZGV4aWVFcnJvck5hbWVzID0gW1xuICAgICdNb2RpZnknLFxuICAgICdCdWxrJyxcbiAgICAnT3BlbkZhaWxlZCcsXG4gICAgJ1ZlcnNpb25DaGFuZ2UnLFxuICAgICdTY2hlbWEnLFxuICAgICdVcGdyYWRlJyxcbiAgICAnSW52YWxpZFRhYmxlJyxcbiAgICAnTWlzc2luZ0FQSScsXG4gICAgJ05vU3VjaERhdGFiYXNlJyxcbiAgICAnSW52YWxpZEFyZ3VtZW50JyxcbiAgICAnU3ViVHJhbnNhY3Rpb24nLFxuICAgICdVbnN1cHBvcnRlZCcsXG4gICAgJ0ludGVybmFsJyxcbiAgICAnRGF0YWJhc2VDbG9zZWQnLFxuICAgICdQcmVtYXR1cmVDb21taXQnLFxuICAgICdGb3JlaWduQXdhaXQnXG5dO1xuXG52YXIgaWRiRG9tRXJyb3JOYW1lcyA9IFtcbiAgICAnVW5rbm93bicsXG4gICAgJ0NvbnN0cmFpbnQnLFxuICAgICdEYXRhJyxcbiAgICAnVHJhbnNhY3Rpb25JbmFjdGl2ZScsXG4gICAgJ1JlYWRPbmx5JyxcbiAgICAnVmVyc2lvbicsXG4gICAgJ05vdEZvdW5kJyxcbiAgICAnSW52YWxpZFN0YXRlJyxcbiAgICAnSW52YWxpZEFjY2VzcycsXG4gICAgJ0Fib3J0JyxcbiAgICAnVGltZW91dCcsXG4gICAgJ1F1b3RhRXhjZWVkZWQnLFxuICAgICdTeW50YXgnLFxuICAgICdEYXRhQ2xvbmUnXG5dO1xuXG52YXIgZXJyb3JMaXN0ID0gZGV4aWVFcnJvck5hbWVzLmNvbmNhdChpZGJEb21FcnJvck5hbWVzKTtcblxudmFyIGRlZmF1bHRUZXh0cyA9IHtcbiAgICBWZXJzaW9uQ2hhbmdlZDogXCJEYXRhYmFzZSB2ZXJzaW9uIGNoYW5nZWQgYnkgb3RoZXIgZGF0YWJhc2UgY29ubmVjdGlvblwiLFxuICAgIERhdGFiYXNlQ2xvc2VkOiBcIkRhdGFiYXNlIGhhcyBiZWVuIGNsb3NlZFwiLFxuICAgIEFib3J0OiBcIlRyYW5zYWN0aW9uIGFib3J0ZWRcIixcbiAgICBUcmFuc2FjdGlvbkluYWN0aXZlOiBcIlRyYW5zYWN0aW9uIGhhcyBhbHJlYWR5IGNvbXBsZXRlZCBvciBmYWlsZWRcIixcbiAgICBNaXNzaW5nQVBJOiBcIkluZGV4ZWREQiBBUEkgbWlzc2luZy4gUGxlYXNlIHZpc2l0IGh0dHBzOi8vdGlueXVybC5jb20veTJ1dXZza2JcIlxufTtcblxuLy9cbi8vIERleGllRXJyb3IgLSBiYXNlIGNsYXNzIG9mIGFsbCBvdXQgZXhjZXB0aW9ucy5cbi8vXG5leHBvcnQgZnVuY3Rpb24gRGV4aWVFcnJvciAobmFtZSwgbXNnKSB7XG4gICAgLy8gUmVhc29uIHdlIGRvbid0IHVzZSBFUzYgY2xhc3NlcyBpcyBiZWNhdXNlOlxuICAgIC8vIDEuIEl0IGJsb2F0cyB0cmFuc3BpbGVkIGNvZGUgYW5kIGluY3JlYXNlcyBzaXplIG9mIG1pbmlmaWVkIGNvZGUuXG4gICAgLy8gMi4gSXQgZG9lc24ndCBnaXZlIHVzIG11Y2ggaW4gdGhpcyBjYXNlLlxuICAgIC8vIDMuIEl0IHdvdWxkIHJlcXVpcmUgc3ViIGNsYXNzZXMgdG8gY2FsbCBzdXBlcigpLCB3aGljaFxuICAgIC8vICAgIGlzIG5vdCBuZWVkZWQgd2hlbiBkZXJpdmluZyBmcm9tIEVycm9yLlxuICAgIHRoaXMuX2UgPSBnZXRFcnJvcldpdGhTdGFjaygpO1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5tZXNzYWdlID0gbXNnO1xufVxuXG5kZXJpdmUoRGV4aWVFcnJvcikuZnJvbShFcnJvcikuZXh0ZW5kKHtcbiAgICBzdGFjazoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0YWNrIHx8XG4gICAgICAgICAgICAgICAgKHRoaXMuX3N0YWNrID0gdGhpcy5uYW1lICsgXCI6IFwiICsgdGhpcy5tZXNzYWdlICsgcHJldHR5U3RhY2sodGhpcy5fZSwgMikpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICB0b1N0cmluZzogZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMubmFtZSArIFwiOiBcIiArIHRoaXMubWVzc2FnZTsgfVxufSk7XG5cbmZ1bmN0aW9uIGdldE11bHRpRXJyb3JNZXNzYWdlIChtc2csIGZhaWx1cmVzKSB7XG4gICAgcmV0dXJuIG1zZyArIFwiLiBFcnJvcnM6IFwiICsgT2JqZWN0LmtleXMoZmFpbHVyZXMpXG4gICAgICAgIC5tYXAoa2V5PT5mYWlsdXJlc1trZXldLnRvU3RyaW5nKCkpXG4gICAgICAgIC5maWx0ZXIoKHYsaSxzKT0+cy5pbmRleE9mKHYpID09PSBpKSAvLyBPbmx5IHVuaXF1ZSBlcnJvciBzdHJpbmdzXG4gICAgICAgIC5qb2luKCdcXG4nKTtcbn1cblxuLy9cbi8vIE1vZGlmeUVycm9yIC0gdGhyb3duIGluIENvbGxlY3Rpb24ubW9kaWZ5KClcbi8vIFNwZWNpZmljIGNvbnN0cnVjdG9yIGJlY2F1c2UgaXQgY29udGFpbnMgbWVtYmVycyBmYWlsdXJlcyBhbmQgZmFpbGVkS2V5cy5cbi8vXG5leHBvcnQgZnVuY3Rpb24gTW9kaWZ5RXJyb3IgKG1zZywgZmFpbHVyZXMsIHN1Y2Nlc3NDb3VudCwgZmFpbGVkS2V5cykge1xuICAgIHRoaXMuX2UgPSBnZXRFcnJvcldpdGhTdGFjaygpO1xuICAgIHRoaXMuZmFpbHVyZXMgPSBmYWlsdXJlcztcbiAgICB0aGlzLmZhaWxlZEtleXMgPSBmYWlsZWRLZXlzO1xuICAgIHRoaXMuc3VjY2Vzc0NvdW50ID0gc3VjY2Vzc0NvdW50O1xuICAgIHRoaXMubWVzc2FnZSA9IGdldE11bHRpRXJyb3JNZXNzYWdlKG1zZywgZmFpbHVyZXMpO1xufVxuZGVyaXZlKE1vZGlmeUVycm9yKS5mcm9tKERleGllRXJyb3IpO1xuXG5leHBvcnQgZnVuY3Rpb24gQnVsa0Vycm9yIChtc2csIGZhaWx1cmVzKSB7XG4gICAgdGhpcy5fZSA9IGdldEVycm9yV2l0aFN0YWNrKCk7XG4gICAgdGhpcy5uYW1lID0gXCJCdWxrRXJyb3JcIjtcbiAgICB0aGlzLmZhaWx1cmVzID0gT2JqZWN0LmtleXMoZmFpbHVyZXMpLm1hcChwb3MgPT4gZmFpbHVyZXNbcG9zXSk7XG4gICAgdGhpcy5mYWlsdXJlc0J5UG9zID0gZmFpbHVyZXM7XG4gICAgdGhpcy5tZXNzYWdlID0gZ2V0TXVsdGlFcnJvck1lc3NhZ2UobXNnLCBmYWlsdXJlcyk7XG59XG5kZXJpdmUoQnVsa0Vycm9yKS5mcm9tKERleGllRXJyb3IpO1xuXG4vL1xuLy9cbi8vIER5bmFtaWNhbGx5IGdlbmVyYXRlIGVycm9yIG5hbWVzIGFuZCBleGNlcHRpb24gY2xhc3NlcyBiYXNlZFxuLy8gb24gdGhlIG5hbWVzIGluIGVycm9yTGlzdC5cbi8vXG4vL1xuXG4vLyBNYXAgb2Yge0Vycm9yTmFtZSAtPiBFcnJvck5hbWUgKyBcIkVycm9yXCJ9XG5leHBvcnQgdmFyIGVycm5hbWVzID0gZXJyb3JMaXN0LnJlZHVjZSgob2JqLG5hbWUpPT4ob2JqW25hbWVdPW5hbWUrXCJFcnJvclwiLG9iaikse30pO1xuXG4vLyBOZWVkIGFuIGFsaWFzIGZvciBEZXhpZUVycm9yIGJlY2F1c2Ugd2UncmUgZ29ubmEgY3JlYXRlIHN1YmNsYXNzZXMgd2l0aCB0aGUgc2FtZSBuYW1lLlxuY29uc3QgQmFzZUV4Y2VwdGlvbiA9IERleGllRXJyb3I7XG4vLyBNYXAgb2Yge0Vycm9yTmFtZSAtPiBleGNlcHRpb24gY29uc3RydWN0b3J9XG5leHBvcnQgdmFyIGV4Y2VwdGlvbnMgPSBlcnJvckxpc3QucmVkdWNlKChvYmosbmFtZSk9PntcbiAgICAvLyBMZXQgdGhlIG5hbWUgYmUgXCJEZXhpZUVycm9yXCIgYmVjYXVzZSB0aGlzIG5hbWUgbWF5XG4gICAgLy8gYmUgc2hvd24gaW4gY2FsbCBzdGFjayBhbmQgd2hlbiBkZWJ1Z2dpbmcuIERleGllRXJyb3IgaXNcbiAgICAvLyB0aGUgbW9zdCB0cnVlIG5hbWUgYmVjYXVzZSBpdCBkZXJpdmVzIGZyb20gRGV4aWVFcnJvcixcbiAgICAvLyBhbmQgd2UgY2Fubm90IGNoYW5nZSBGdW5jdGlvbi5uYW1lIHByb2dyYW1hdGljYWxseSB3aXRob3V0XG4gICAgLy8gZHluYW1pY2FsbHkgY3JlYXRlIGEgRnVuY3Rpb24gb2JqZWN0LCB3aGljaCB3b3VsZCBiZSBjb25zaWRlcmVkXG4gICAgLy8gJ2V2YWwtZXZpbCcuXG4gICAgdmFyIGZ1bGxOYW1lID0gbmFtZSArIFwiRXJyb3JcIjtcbiAgICBmdW5jdGlvbiBEZXhpZUVycm9yIChtc2dPcklubmVyLCBpbm5lcil7XG4gICAgICAgIHRoaXMuX2UgPSBnZXRFcnJvcldpdGhTdGFjaygpO1xuICAgICAgICB0aGlzLm5hbWUgPSBmdWxsTmFtZTtcbiAgICAgICAgaWYgKCFtc2dPcklubmVyKSB7XG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2UgPSBkZWZhdWx0VGV4dHNbbmFtZV0gfHwgZnVsbE5hbWU7XG4gICAgICAgICAgICB0aGlzLmlubmVyID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbXNnT3JJbm5lciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRoaXMubWVzc2FnZSA9IGAke21zZ09ySW5uZXJ9JHshaW5uZXIgPyAnJyA6ICdcXG4gJyArIGlubmVyfWA7XG4gICAgICAgICAgICB0aGlzLmlubmVyID0gaW5uZXIgfHwgbnVsbDtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbXNnT3JJbm5lciA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHRoaXMubWVzc2FnZSA9IGAke21zZ09ySW5uZXIubmFtZX0gJHttc2dPcklubmVyLm1lc3NhZ2V9YDtcbiAgICAgICAgICAgIHRoaXMuaW5uZXIgPSBtc2dPcklubmVyO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlcml2ZShEZXhpZUVycm9yKS5mcm9tKEJhc2VFeGNlcHRpb24pO1xuICAgIG9ialtuYW1lXT1EZXhpZUVycm9yO1xuICAgIHJldHVybiBvYmo7XG59LHt9KTtcblxuLy8gVXNlIEVDTUFTQ1JJUFQgc3RhbmRhcmQgZXhjZXB0aW9ucyB3aGVyZSBhcHBsaWNhYmxlOlxuZXhjZXB0aW9ucy5TeW50YXggPSBTeW50YXhFcnJvcjtcbmV4Y2VwdGlvbnMuVHlwZSA9IFR5cGVFcnJvcjtcbmV4Y2VwdGlvbnMuUmFuZ2UgPSBSYW5nZUVycm9yO1xuXG5leHBvcnQgdmFyIGV4Y2VwdGlvbk1hcCA9IGlkYkRvbUVycm9yTmFtZXMucmVkdWNlKChvYmosIG5hbWUpPT57XG4gICAgb2JqW25hbWUgKyBcIkVycm9yXCJdID0gZXhjZXB0aW9uc1tuYW1lXTtcbiAgICByZXR1cm4gb2JqO1xufSwge30pO1xuXG5leHBvcnQgZnVuY3Rpb24gbWFwRXJyb3IgKGRvbUVycm9yLCBtZXNzYWdlKSB7XG4gICAgaWYgKCFkb21FcnJvciB8fCBkb21FcnJvciBpbnN0YW5jZW9mIERleGllRXJyb3IgfHwgZG9tRXJyb3IgaW5zdGFuY2VvZiBUeXBlRXJyb3IgfHwgZG9tRXJyb3IgaW5zdGFuY2VvZiBTeW50YXhFcnJvciB8fCAhZG9tRXJyb3IubmFtZSB8fCAhZXhjZXB0aW9uTWFwW2RvbUVycm9yLm5hbWVdKVxuICAgICAgICByZXR1cm4gZG9tRXJyb3I7XG4gICAgdmFyIHJ2ID0gbmV3IGV4Y2VwdGlvbk1hcFtkb21FcnJvci5uYW1lXShtZXNzYWdlIHx8IGRvbUVycm9yLm1lc3NhZ2UsIGRvbUVycm9yKTtcbiAgICBpZiAoXCJzdGFja1wiIGluIGRvbUVycm9yKSB7XG4gICAgICAgIC8vIERlcml2ZSBzdGFjayBmcm9tIGlubmVyIGV4Y2VwdGlvbiBpZiBpdCBoYXMgYSBzdGFja1xuICAgICAgICBzZXRQcm9wKHJ2LCBcInN0YWNrXCIsIHtnZXQ6IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbm5lci5zdGFjaztcbiAgICAgICAgfX0pO1xuICAgIH1cbiAgICByZXR1cm4gcnY7XG59XG5cbmV4cG9ydCB2YXIgZnVsbE5hbWVFeGNlcHRpb25zID0gZXJyb3JMaXN0LnJlZHVjZSgob2JqLCBuYW1lKT0+e1xuICAgIGlmIChbXCJTeW50YXhcIixcIlR5cGVcIixcIlJhbmdlXCJdLmluZGV4T2YobmFtZSkgPT09IC0xKVxuICAgICAgICBvYmpbbmFtZSArIFwiRXJyb3JcIl0gPSBleGNlcHRpb25zW25hbWVdO1xuICAgIHJldHVybiBvYmo7XG59LCB7fSk7XG5cbmZ1bGxOYW1lRXhjZXB0aW9ucy5Nb2RpZnlFcnJvciA9IE1vZGlmeUVycm9yO1xuZnVsbE5hbWVFeGNlcHRpb25zLkRleGllRXJyb3IgPSBEZXhpZUVycm9yO1xuZnVsbE5hbWVFeGNlcHRpb25zLkJ1bGtFcnJvciA9IEJ1bGtFcnJvcjtcbiIsICJpbXBvcnQge2V4dGVuZH0gZnJvbSAnLi91dGlscyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBub3AoKSB7IH1cbmV4cG9ydCBmdW5jdGlvbiBtaXJyb3IodmFsKSB7IHJldHVybiB2YWw7IH1cbmV4cG9ydCBmdW5jdGlvbiBwdXJlRnVuY3Rpb25DaGFpbihmMSwgZjIpIHtcbiAgICAvLyBFbmFibGVzIGNoYWluZWQgZXZlbnRzIHRoYXQgdGFrZXMgT05FIGFyZ3VtZW50IGFuZCByZXR1cm5zIGl0IHRvIHRoZSBuZXh0IGZ1bmN0aW9uIGluIGNoYWluLlxuICAgIC8vIFRoaXMgcGF0dGVybiBpcyB1c2VkIGluIHRoZSBob29rKFwicmVhZGluZ1wiKSBldmVudC5cbiAgICBpZiAoZjEgPT0gbnVsbCB8fCBmMSA9PT0gbWlycm9yKSByZXR1cm4gZjI7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgcmV0dXJuIGYyKGYxKHZhbCkpO1xuICAgIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjYWxsQm90aChvbjEsIG9uMikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIG9uMS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICBvbjIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaG9va0NyZWF0aW5nQ2hhaW4oZjEsIGYyKSB7XG4gICAgLy8gRW5hYmxlcyBjaGFpbmVkIGV2ZW50cyB0aGF0IHRha2VzIHNldmVyYWwgYXJndW1lbnRzIGFuZCBtYXkgbW9kaWZ5IGZpcnN0IGFyZ3VtZW50IGJ5IG1ha2luZyBhIG1vZGlmaWNhdGlvbiBhbmQgdGhlbiByZXR1cm5pbmcgdGhlIHNhbWUgaW5zdGFuY2UuXG4gICAgLy8gVGhpcyBwYXR0ZXJuIGlzIHVzZWQgaW4gdGhlIGhvb2soXCJjcmVhdGluZ1wiKSBldmVudC5cbiAgICBpZiAoZjEgPT09IG5vcCkgcmV0dXJuIGYyO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZXMgPSBmMS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICBpZiAocmVzICE9PSB1bmRlZmluZWQpIGFyZ3VtZW50c1swXSA9IHJlcztcbiAgICAgICAgdmFyIG9uc3VjY2VzcyA9IHRoaXMub25zdWNjZXNzLCAvLyBJbiBjYXNlIGV2ZW50IGxpc3RlbmVyIGhhcyBzZXQgdGhpcy5vbnN1Y2Nlc3NcbiAgICAgICAgICAgIG9uZXJyb3IgPSB0aGlzLm9uZXJyb3I7ICAgICAvLyBJbiBjYXNlIGV2ZW50IGxpc3RlbmVyIGhhcyBzZXQgdGhpcy5vbmVycm9yXG4gICAgICAgIHRoaXMub25zdWNjZXNzID0gbnVsbDtcbiAgICAgICAgdGhpcy5vbmVycm9yID0gbnVsbDtcbiAgICAgICAgdmFyIHJlczIgPSBmMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICBpZiAob25zdWNjZXNzKSB0aGlzLm9uc3VjY2VzcyA9IHRoaXMub25zdWNjZXNzID8gY2FsbEJvdGgob25zdWNjZXNzLCB0aGlzLm9uc3VjY2VzcykgOiBvbnN1Y2Nlc3M7XG4gICAgICAgIGlmIChvbmVycm9yKSB0aGlzLm9uZXJyb3IgPSB0aGlzLm9uZXJyb3IgPyBjYWxsQm90aChvbmVycm9yLCB0aGlzLm9uZXJyb3IpIDogb25lcnJvcjtcbiAgICAgICAgcmV0dXJuIHJlczIgIT09IHVuZGVmaW5lZCA/IHJlczIgOiByZXM7XG4gICAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhvb2tEZWxldGluZ0NoYWluKGYxLCBmMikge1xuICAgIGlmIChmMSA9PT0gbm9wKSByZXR1cm4gZjI7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZjEuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgdmFyIG9uc3VjY2VzcyA9IHRoaXMub25zdWNjZXNzLCAvLyBJbiBjYXNlIGV2ZW50IGxpc3RlbmVyIGhhcyBzZXQgdGhpcy5vbnN1Y2Nlc3NcbiAgICAgICAgICAgIG9uZXJyb3IgPSB0aGlzLm9uZXJyb3I7ICAgICAvLyBJbiBjYXNlIGV2ZW50IGxpc3RlbmVyIGhhcyBzZXQgdGhpcy5vbmVycm9yXG4gICAgICAgIHRoaXMub25zdWNjZXNzID0gdGhpcy5vbmVycm9yID0gbnVsbDtcbiAgICAgICAgZjIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgaWYgKG9uc3VjY2VzcykgdGhpcy5vbnN1Y2Nlc3MgPSB0aGlzLm9uc3VjY2VzcyA/IGNhbGxCb3RoKG9uc3VjY2VzcywgdGhpcy5vbnN1Y2Nlc3MpIDogb25zdWNjZXNzO1xuICAgICAgICBpZiAob25lcnJvcikgdGhpcy5vbmVycm9yID0gdGhpcy5vbmVycm9yID8gY2FsbEJvdGgob25lcnJvciwgdGhpcy5vbmVycm9yKSA6IG9uZXJyb3I7XG4gICAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhvb2tVcGRhdGluZ0NoYWluKGYxLCBmMikge1xuICAgIGlmIChmMSA9PT0gbm9wKSByZXR1cm4gZjI7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChtb2RpZmljYXRpb25zKSB7XG4gICAgICAgIHZhciByZXMgPSBmMS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICBleHRlbmQobW9kaWZpY2F0aW9ucywgcmVzKTsgLy8gSWYgZjEgcmV0dXJucyBuZXcgbW9kaWZpY2F0aW9ucywgZXh0ZW5kIGNhbGxlcidzIG1vZGlmaWNhdGlvbnMgd2l0aCB0aGUgcmVzdWx0IGJlZm9yZSBjYWxsaW5nIG5leHQgaW4gY2hhaW4uXG4gICAgICAgIHZhciBvbnN1Y2Nlc3MgPSB0aGlzLm9uc3VjY2VzcywgLy8gSW4gY2FzZSBldmVudCBsaXN0ZW5lciBoYXMgc2V0IHRoaXMub25zdWNjZXNzXG4gICAgICAgICAgICBvbmVycm9yID0gdGhpcy5vbmVycm9yOyAgICAgLy8gSW4gY2FzZSBldmVudCBsaXN0ZW5lciBoYXMgc2V0IHRoaXMub25lcnJvclxuICAgICAgICB0aGlzLm9uc3VjY2VzcyA9IG51bGw7XG4gICAgICAgIHRoaXMub25lcnJvciA9IG51bGw7XG4gICAgICAgIHZhciByZXMyID0gZjIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgaWYgKG9uc3VjY2VzcykgdGhpcy5vbnN1Y2Nlc3MgPSB0aGlzLm9uc3VjY2VzcyA/IGNhbGxCb3RoKG9uc3VjY2VzcywgdGhpcy5vbnN1Y2Nlc3MpIDogb25zdWNjZXNzO1xuICAgICAgICBpZiAob25lcnJvcikgdGhpcy5vbmVycm9yID0gdGhpcy5vbmVycm9yID8gY2FsbEJvdGgob25lcnJvciwgdGhpcy5vbmVycm9yKSA6IG9uZXJyb3I7XG4gICAgICAgIHJldHVybiByZXMgPT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICAocmVzMiA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogcmVzMikgOlxuICAgICAgICAgICAgKGV4dGVuZChyZXMsIHJlczIpKTtcbiAgICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmV2ZXJzZVN0b3BwYWJsZUV2ZW50Q2hhaW4oZjEsIGYyKSB7XG4gICAgaWYgKGYxID09PSBub3ApIHJldHVybiBmMjtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoZjIuYXBwbHkodGhpcywgYXJndW1lbnRzKSA9PT0gZmFsc2UpIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGYxLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG5vblN0b3BwYWJsZUV2ZW50Q2hhaW4oZjEsIGYyKSB7XG4gICAgaWYgKGYxID09PSBub3ApIHJldHVybiBmMjtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBmMS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICBmMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwcm9taXNhYmxlQ2hhaW4oZjEsIGYyKSB7XG4gICAgaWYgKGYxID09PSBub3ApIHJldHVybiBmMjtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVzID0gZjEuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgaWYgKHJlcyAmJiB0eXBlb2YgcmVzLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHZhciB0aGl6ID0gdGhpcyxcbiAgICAgICAgICAgICAgICBpID0gYXJndW1lbnRzLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBhcmdzID0gbmV3IEFycmF5KGkpO1xuICAgICAgICAgICAgd2hpbGUgKGktLSkgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIHJldHVybiByZXMudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGYyLmFwcGx5KHRoaXosIGFyZ3MpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGYyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbn1cbiIsICIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LTIwMTcgRGF2aWQgRmFobGFuZGVyXG4gKiBBcGFjaGUgTGljZW5zZSBWZXJzaW9uIDIuMCwgSmFudWFyeSAyMDA0LCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqL1xuaW1wb3J0IHsgX2dsb2JhbCB9IGZyb20gJy4uL2dsb2JhbHMvZ2xvYmFsJztcbmltcG9ydCB7dHJ5Q2F0Y2gsIHByb3BzLCBzZXRQcm9wLCBfZ2xvYmFsLFxuICAgIGdldFByb3BlcnR5RGVzY3JpcHRvciwgZ2V0QXJyYXlPZiwgZXh0ZW5kLCBnZXRQcm90b30gZnJvbSAnLi4vZnVuY3Rpb25zL3V0aWxzJztcbmltcG9ydCB7bm9wLCBjYWxsQm90aCwgbWlycm9yfSBmcm9tICcuLi9mdW5jdGlvbnMvY2hhaW5pbmctZnVuY3Rpb25zJztcbmltcG9ydCB7ZGVidWcsIHByZXR0eVN0YWNrLCBnZXRFcnJvcldpdGhTdGFja30gZnJvbSAnLi9kZWJ1Zyc7XG5pbXBvcnQge2V4Y2VwdGlvbnN9IGZyb20gJy4uL2Vycm9ycyc7XG5cbi8vXG4vLyBQcm9taXNlIGFuZCBab25lIChQU0QpIGZvciBEZXhpZSBsaWJyYXJ5XG4vL1xuLy8gSSBzdGFydGVkIG91dCB3cml0aW5nIHRoaXMgUHJvbWlzZSBjbGFzcyBieSBjb3B5aW5nIHByb21pc2UtbGlnaHQgKGh0dHBzOi8vZ2l0aHViLmNvbS90YXlsb3JoYWtlcy9wcm9taXNlLWxpZ2h0KSBieVxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3RheWxvcmhha2VzIC0gYW4gQSsgYW5kIEVDTUFTQ1JJUFQgNiBjb21wbGlhbnQgUHJvbWlzZSBpbXBsZW1lbnRhdGlvbi5cbi8vXG4vLyBJbiBwcmV2aW91cyB2ZXJzaW9ucyB0aGlzIHdhcyBmaXhlZCBieSBub3QgY2FsbGluZyBzZXRUaW1lb3V0IHdoZW4ga25vd2luZyB0aGF0IHRoZSByZXNvbHZlKCkgb3IgcmVqZWN0KCkgY2FtZSBmcm9tIGFub3RoZXJcbi8vIHRpY2suIEluIERleGllIHYxLjQuMCwgSSd2ZSByZXdyaXR0ZW4gdGhlIFByb21pc2UgY2xhc3MgZW50aXJlbHkuIEp1c3Qgc29tZSBmcmFnbWVudHMgb2YgcHJvbWlzZS1saWdodCBpcyBsZWZ0LiBJIHVzZVxuLy8gYW5vdGhlciBzdHJhdGVneSBub3cgdGhhdCBzaW1wbGlmaWVzIGV2ZXJ5dGhpbmcgYSBsb3Q6IHRvIGFsd2F5cyBleGVjdXRlIGNhbGxiYWNrcyBpbiBhIG5ldyBtaWNyby10YXNrLCBidXQgaGF2ZSBhbiBvd24gbWljcm8tdGFza1xuLy8gZW5naW5lIHRoYXQgaXMgaW5kZXhlZERCIGNvbXBsaWFudCBhY3Jvc3MgYWxsIGJyb3dzZXJzLlxuLy8gUHJvbWlzZSBjbGFzcyBoYXMgYWxzbyBiZWVuIG9wdGltaXplZCBhIGxvdCB3aXRoIGluc3BpcmF0aW9uIGZyb20gYmx1ZWJpcmQgLSB0byBhdm9pZCBjbG9zdXJlcyBhcyBtdWNoIGFzIHBvc3NpYmxlLlxuLy8gQWxzbyB3aXRoIGluc3BpcmF0aW9uIGZyb20gYmx1ZWJpcmQsIGFzeW5jcm9uaWMgc3RhY2tzIGluIGRlYnVnIG1vZGUuXG4vL1xuLy8gU3BlY2lmaWMgbm9uLXN0YW5kYXJkIGZlYXR1cmVzIG9mIHRoaXMgUHJvbWlzZSBjbGFzczpcbi8vICogQ3VzdG9tIHpvbmUgc3VwcG9ydCAoYS5rLmEuIFBTRCkgd2l0aCBhYmlsaXR5IHRvIGtlZXAgem9uZXMgYWxzbyB3aGVuIHVzaW5nIG5hdGl2ZSBwcm9taXNlcyBhcyB3ZWxsIGFzXG4vLyAgIG5hdGl2ZSBhc3luYyAvIGF3YWl0LlxuLy8gKiBQcm9taXNlLmZvbGxvdygpIG1ldGhvZCBidWlsdCB1cG9uIHRoZSBjdXN0b20gem9uZSBlbmdpbmUsIHRoYXQgYWxsb3dzIHVzZXIgdG8gdHJhY2sgYWxsIHByb21pc2VzIGNyZWF0ZWQgZnJvbSBjdXJyZW50IHN0YWNrIGZyYW1lXG4vLyAgIGFuZCBiZWxvdyArIGFsbCBwcm9taXNlcyB0aGF0IHRob3NlIHByb21pc2VzIGNyZWF0ZXMgb3IgYXdhaXRzLlxuLy8gKiBEZXRlY3QgYW55IHVuaGFuZGxlZCBwcm9taXNlIGluIGEgUFNELXNjb3BlIChQU0Qub251bmhhbmRsZWQpLiBcbi8vXG4vLyBEYXZpZCBGYWhsYW5kZXIsIGh0dHBzOi8vZ2l0aHViLmNvbS9kZmFobGFuZGVyXG4vL1xuXG4vLyBKdXN0IGEgcG9pbnRlciB0aGF0IG9ubHkgdGhpcyBtb2R1bGUga25vd3MgYWJvdXQuXG4vLyBVc2VkIGluIFByb21pc2UgY29uc3RydWN0b3IgdG8gZW11bGF0ZSBhIHByaXZhdGUgY29uc3RydWN0b3IuXG52YXIgSU5URVJOQUwgPSB7fTtcblxuLy8gQXN5bmMgc3RhY2tzIChsb25nIHN0YWNrcykgbXVzdCBub3QgZ3JvdyBpbmZpbml0ZWx5LlxuY29uc3RcbiAgICBMT05HX1NUQUNLU19DTElQX0xJTUlUID0gMTAwLFxuICAgIC8vIFdoZW4gY2FsbGluZyBlcnJvci5zdGFjayBvciBwcm9taXNlLnN0YWNrLCBsaW1pdCB0aGUgbnVtYmVyIG9mIGFzeW5jcm9uaWMgc3RhY2tzIHRvIHByaW50IG91dC4gXG4gICAgTUFYX0xPTkdfU1RBQ0tTID0gMjAsXG4gICAgWk9ORV9FQ0hPX0xJTUlUID0gMTAwLFxuICAgIFtyZXNvbHZlZE5hdGl2ZVByb21pc2UsIG5hdGl2ZVByb21pc2VQcm90bywgcmVzb2x2ZWRHbG9iYWxQcm9taXNlXSA9IHR5cGVvZiBQcm9taXNlID09PSAndW5kZWZpbmVkJyA/XG4gICAgICAgIFtdIDpcbiAgICAgICAgKCgpPT57XG4gICAgICAgICAgICBsZXQgZ2xvYmFsUCA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjcnlwdG8gPT09ICd1bmRlZmluZWQnIHx8ICFjcnlwdG8uc3VidGxlKVxuICAgICAgICAgICAgICAgIHJldHVybiBbZ2xvYmFsUCwgZ2V0UHJvdG8oZ2xvYmFsUCksIGdsb2JhbFBdO1xuICAgICAgICAgICAgLy8gR2VuZXJhdGUgYSBuYXRpdmUgcHJvbWlzZSAoYXMgd2luZG93LlByb21pc2UgbWF5IGhhdmUgYmVlbiBwYXRjaGVkKVxuICAgICAgICAgICAgY29uc3QgbmF0aXZlUCA9IGNyeXB0by5zdWJ0bGUuZGlnZXN0KFwiU0hBLTUxMlwiLCBuZXcgVWludDhBcnJheShbMF0pKTtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgbmF0aXZlUCxcbiAgICAgICAgICAgICAgICBnZXRQcm90byhuYXRpdmVQKSxcbiAgICAgICAgICAgICAgICBnbG9iYWxQXG4gICAgICAgICAgICBdO1xuICAgICAgICB9KSgpLFxuICAgIG5hdGl2ZVByb21pc2VUaGVuID0gbmF0aXZlUHJvbWlzZVByb3RvICYmIG5hdGl2ZVByb21pc2VQcm90by50aGVuO1xuXG5leHBvcnQgY29uc3QgTmF0aXZlUHJvbWlzZSA9IHJlc29sdmVkTmF0aXZlUHJvbWlzZSAmJiByZXNvbHZlZE5hdGl2ZVByb21pc2UuY29uc3RydWN0b3I7XG5jb25zdCBwYXRjaEdsb2JhbFByb21pc2UgPSAhIXJlc29sdmVkR2xvYmFsUHJvbWlzZTtcblxudmFyIHN0YWNrX2JlaW5nX2dlbmVyYXRlZCA9IGZhbHNlO1xuXG4vKiBUaGUgZGVmYXVsdCBmdW5jdGlvbiB1c2VkIG9ubHkgZm9yIHRoZSB2ZXJ5IGZpcnN0IHByb21pc2UgaW4gYSBwcm9taXNlIGNoYWluLlxuICAgQXMgc29vbiBhcyB0aGVuIHByb21pc2UgaXMgcmVzb2x2ZWQgb3IgcmVqZWN0ZWQsIGFsbCBuZXh0IHRhc2tzIHdpbGwgYmUgZXhlY3V0ZWQgaW4gbWljcm8gdGlja3NcbiAgIGVtdWxhdGVkIGluIHRoaXMgbW9kdWxlLiBGb3IgaW5kZXhlZERCIGNvbXBhdGliaWxpdHksIHRoaXMgbWVhbnMgdGhhdCBldmVyeSBtZXRob2QgbmVlZHMgdG8gXG4gICBleGVjdXRlIGF0IGxlYXN0IG9uZSBwcm9taXNlIGJlZm9yZSBkb2luZyBhbiBpbmRleGVkREIgb3BlcmF0aW9uLiBEZXhpZSB3aWxsIGFsd2F5cyBjYWxsIFxuICAgZGIucmVhZHkoKS50aGVuKCkgZm9yIGV2ZXJ5IG9wZXJhdGlvbiB0byBtYWtlIHN1cmUgdGhlIGluZGV4ZWREQiBldmVudCBpcyBzdGFydGVkIGluIGFuXG4gICBpbmRleGVkREItY29tcGF0aWJsZSBlbXVsYXRlZCBtaWNybyB0YXNrIGxvb3AuXG4qL1xudmFyIHNjaGVkdWxlUGh5c2ljYWxUaWNrID0gcmVzb2x2ZWRHbG9iYWxQcm9taXNlID9cbiAgICAoKSA9PiB7cmVzb2x2ZWRHbG9iYWxQcm9taXNlLnRoZW4ocGh5c2ljYWxUaWNrKTt9XG4gICAgOlxuICAgIF9nbG9iYWwuc2V0SW1tZWRpYXRlID8gXG4gICAgICAgIC8vIHNldEltbWVkaWF0ZSBzdXBwb3J0ZWQuIFRob3NlIG1vZGVybiBwbGF0Zm9ybXMgYWxzbyBzdXBwb3J0cyBGdW5jdGlvbi5iaW5kKCkuXG4gICAgICAgIHNldEltbWVkaWF0ZS5iaW5kKG51bGwsIHBoeXNpY2FsVGljaykgOlxuICAgICAgICBfZ2xvYmFsLk11dGF0aW9uT2JzZXJ2ZXIgP1xuICAgICAgICAgICAgLy8gTXV0YXRpb25PYnNlcnZlciBzdXBwb3J0ZWRcbiAgICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgaGlkZGVuRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICAgICAgICAobmV3IE11dGF0aW9uT2JzZXJ2ZXIoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBwaHlzaWNhbFRpY2soKTtcbiAgICAgICAgICAgICAgICAgICAgaGlkZGVuRGl2ID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9KSkub2JzZXJ2ZShoaWRkZW5EaXYsIHsgYXR0cmlidXRlczogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICBoaWRkZW5EaXYuc2V0QXR0cmlidXRlKCdpJywgJzEnKTtcbiAgICAgICAgICAgIH0gOlxuICAgICAgICAgICAgLy8gTm8gc3VwcG9ydCBmb3Igc2V0SW1tZWRpYXRlIG9yIE11dGF0aW9uT2JzZXJ2ZXIuIE5vIHdvcnJ5LCBzZXRUaW1lb3V0IGlzIG9ubHkgY2FsbGVkXG4gICAgICAgICAgICAvLyBvbmNlIHRpbWUuIEV2ZXJ5IHRpY2sgdGhhdCBmb2xsb3dzIHdpbGwgYmUgb3VyIGVtdWxhdGVkIG1pY3JvIHRpY2suXG4gICAgICAgICAgICAvLyBDb3VsZCBoYXZlIHVzZXMgc2V0VGltZW91dC5iaW5kKG51bGwsIDAsIHBoeXNpY2FsVGljaykgaWYgaXQgd2FzbnQgZm9yIHRoYXQgRkYxMyBhbmQgYmVsb3cgaGFzIGEgYnVnIFxuICAgICAgICAgICAgKCk9PntzZXRUaW1lb3V0KHBoeXNpY2FsVGljaywwKTt9O1xuXG4vLyBDb25maWd1cmFibGUgdGhyb3VnaCBQcm9taXNlLnNjaGVkdWxlci5cbi8vIERvbid0IGV4cG9ydCBiZWNhdXNlIGl0IHdvdWxkIGJlIHVuc2FmZSB0byBsZXQgdW5rbm93blxuLy8gY29kZSBjYWxsIGl0IHVubGVzcyB0aGV5IGRvIHRyeS4uY2F0Y2ggd2l0aGluIHRoZWlyIGNhbGxiYWNrLlxuLy8gVGhpcyBmdW5jdGlvbiBjYW4gYmUgcmV0cmlldmVkIHRocm91Z2ggZ2V0dGVyIG9mIFByb21pc2Uuc2NoZWR1bGVyIHRob3VnaCxcbi8vIGJ1dCB1c2VycyBtdXN0IG5vdCBkbyBQcm9taXNlLnNjaGVkdWxlciA9IG15RnVuY1RoYXRUaHJvd3NFeGNlcHRpb25cbnZhciBhc2FwID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBhcmdzKSB7XG4gICAgbWljcm90aWNrUXVldWUucHVzaChbY2FsbGJhY2ssIGFyZ3NdKTtcbiAgICBpZiAobmVlZHNOZXdQaHlzaWNhbFRpY2spIHtcbiAgICAgICAgc2NoZWR1bGVQaHlzaWNhbFRpY2soKTtcbiAgICAgICAgbmVlZHNOZXdQaHlzaWNhbFRpY2sgPSBmYWxzZTtcbiAgICB9XG59O1xuXG52YXIgaXNPdXRzaWRlTWljcm9UaWNrID0gdHJ1ZSwgLy8gVHJ1ZSB3aGVuIE5PVCBpbiBhIHZpcnR1YWwgbWljcm9UaWNrLlxuICAgIG5lZWRzTmV3UGh5c2ljYWxUaWNrID0gdHJ1ZSwgLy8gVHJ1ZSB3aGVuIGEgcHVzaCB0byBtaWNyb3RpY2tRdWV1ZSBtdXN0IGFsc28gc2NoZWR1bGVQaHlzaWNhbFRpY2soKVxuICAgIHVuaGFuZGxlZEVycm9ycyA9IFtdLCAvLyBSZWplY3RlZCBwcm9taXNlcyB0aGF0IGhhcyBvY2N1cmVkLiBVc2VkIGZvciB0cmlnZ2VyaW5nICd1bmhhbmRsZWRyZWplY3Rpb24nLlxuICAgIHJlamVjdGluZ0Vycm9ycyA9IFtdLCAvLyBUcmFja3MgaWYgZXJyb3JzIGFyZSBiZWluZyByZS1yZWplY3RlZCBkdXJpbmcgb25SZWplY3RlZCBjYWxsYmFjay5cbiAgICBjdXJyZW50RnVsZmlsbGVyID0gbnVsbCxcbiAgICByZWplY3Rpb25NYXBwZXIgPSBtaXJyb3I7IC8vIFJlbW92ZSBpbiBuZXh0IG1ham9yIHdoZW4gcmVtb3ZpbmcgZXJyb3IgbWFwcGluZyBvZiBET01FcnJvcnMgYW5kIERPTUV4Y2VwdGlvbnNcbiAgICBcbmV4cG9ydCB2YXIgZ2xvYmFsUFNEID0ge1xuICAgIGlkOiAnZ2xvYmFsJyxcbiAgICBnbG9iYWw6IHRydWUsXG4gICAgcmVmOiAwLFxuICAgIHVuaGFuZGxlZHM6IFtdLFxuICAgIG9udW5oYW5kbGVkOiBnbG9iYWxFcnJvcixcbiAgICBwZ3A6IGZhbHNlLFxuICAgIGVudjoge30sXG4gICAgZmluYWxpemU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy51bmhhbmRsZWRzLmZvckVhY2godWggPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBnbG9iYWxFcnJvcih1aFswXSwgdWhbMV0pO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgfSk7XG4gICAgfVxufTtcblxuZXhwb3J0IHZhciBQU0QgPSBnbG9iYWxQU0Q7XG5cbmV4cG9ydCB2YXIgbWljcm90aWNrUXVldWUgPSBbXTsgLy8gQ2FsbGJhY2tzIHRvIGNhbGwgaW4gdGhpcyBvciBuZXh0IHBoeXNpY2FsIHRpY2suXG5leHBvcnQgdmFyIG51bVNjaGVkdWxlZENhbGxzID0gMDsgLy8gTnVtYmVyIG9mIGxpc3RlbmVyLWNhbGxzIGxlZnQgdG8gZG8gaW4gdGhpcyBwaHlzaWNhbCB0aWNrLlxuZXhwb3J0IHZhciB0aWNrRmluYWxpemVycyA9IFtdOyAvLyBGaW5hbGl6ZXJzIHRvIGNhbGwgd2hlbiB0aGVyZSBhcmUgbm8gbW9yZSBhc3luYyBjYWxscyBzY2hlZHVsZWQgd2l0aGluIGN1cnJlbnQgcGh5c2ljYWwgdGljay5cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gRGV4aWVQcm9taXNlKGZuKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzICE9PSAnb2JqZWN0JykgdGhyb3cgbmV3IFR5cGVFcnJvcignUHJvbWlzZXMgbXVzdCBiZSBjb25zdHJ1Y3RlZCB2aWEgbmV3Jyk7ICAgIFxuICAgIHRoaXMuX2xpc3RlbmVycyA9IFtdO1xuICAgIHRoaXMub251bmNhdGNoZWQgPSBub3A7IC8vIERlcHJlY2F0ZSBpbiBuZXh0IG1ham9yLiBOb3QgbmVlZGVkLiBCZXR0ZXIgdG8gdXNlIGdsb2JhbCBlcnJvciBoYW5kbGVyLlxuICAgIFxuICAgIC8vIEEgbGlicmFyeSBtYXkgc2V0IGBwcm9taXNlLl9saWIgPSB0cnVlO2AgYWZ0ZXIgcHJvbWlzZSBpcyBjcmVhdGVkIHRvIG1ha2UgcmVzb2x2ZSgpIG9yIHJlamVjdCgpXG4gICAgLy8gZXhlY3V0ZSB0aGUgbWljcm90YXNrIGVuZ2luZSBpbXBsaWNpdGVseSB3aXRoaW4gdGhlIGNhbGwgdG8gcmVzb2x2ZSgpIG9yIHJlamVjdCgpLlxuICAgIC8vIFRvIHJlbWFpbiBBKyBjb21wbGlhbnQsIGEgbGlicmFyeSBtdXN0IG9ubHkgc2V0IGBfbGliPXRydWVgIGlmIGl0IGNhbiBndWFyYW50ZWUgdGhhdCB0aGUgc3RhY2tcbiAgICAvLyBvbmx5IGNvbnRhaW5zIGxpYnJhcnkgY29kZSB3aGVuIGNhbGxpbmcgcmVzb2x2ZSgpIG9yIHJlamVjdCgpLlxuICAgIC8vIFJVTEUgT0YgVEhVTUI6IE9OTFkgc2V0IF9saWIgPSB0cnVlIGZvciBwcm9taXNlcyBleHBsaWNpdGVseSByZXNvbHZpbmcvcmVqZWN0aW5nIGRpcmVjdGx5IGZyb21cbiAgICAvLyBnbG9iYWwgc2NvcGUgKGV2ZW50IGhhbmRsZXIsIHRpbWVyIGV0YykhXG4gICAgdGhpcy5fbGliID0gZmFsc2U7XG4gICAgLy8gQ3VycmVudCBhc3luYyBzY29wZVxuICAgIHZhciBwc2QgPSAodGhpcy5fUFNEID0gUFNEKTtcblxuICAgIGlmIChkZWJ1Zykge1xuICAgICAgICB0aGlzLl9zdGFja0hvbGRlciA9IGdldEVycm9yV2l0aFN0YWNrKCk7XG4gICAgICAgIHRoaXMuX3ByZXYgPSBudWxsO1xuICAgICAgICB0aGlzLl9udW1QcmV2ID0gMDsgLy8gTnVtYmVyIG9mIHByZXZpb3VzIHByb21pc2VzIChmb3IgbG9uZyBzdGFja3MpXG4gICAgfVxuICAgIFxuICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaWYgKGZuICE9PSBJTlRFUk5BTCkgdGhyb3cgbmV3IFR5cGVFcnJvcignTm90IGEgZnVuY3Rpb24nKTtcbiAgICAgICAgLy8gUHJpdmF0ZSBjb25zdHJ1Y3RvciAoSU5URVJOQUwsIHN0YXRlLCB2YWx1ZSkuXG4gICAgICAgIC8vIFVzZWQgaW50ZXJuYWxseSBieSBQcm9taXNlLnJlc29sdmUoKSBhbmQgUHJvbWlzZS5yZWplY3QoKS5cbiAgICAgICAgdGhpcy5fc3RhdGUgPSBhcmd1bWVudHNbMV07XG4gICAgICAgIHRoaXMuX3ZhbHVlID0gYXJndW1lbnRzWzJdO1xuICAgICAgICBpZiAodGhpcy5fc3RhdGUgPT09IGZhbHNlKVxuICAgICAgICAgICAgaGFuZGxlUmVqZWN0aW9uKHRoaXMsIHRoaXMuX3ZhbHVlKTsgLy8gTWFwIGVycm9yLCBzZXQgc3RhY2sgYW5kIGFkZFBvc3NpYmx5VW5oYW5kbGVkRXJyb3IoKS5cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICB0aGlzLl9zdGF0ZSA9IG51bGw7IC8vIG51bGwgKD1wZW5kaW5nKSwgZmFsc2UgKD1yZWplY3RlZCkgb3IgdHJ1ZSAoPXJlc29sdmVkKVxuICAgIHRoaXMuX3ZhbHVlID0gbnVsbDsgLy8gZXJyb3Igb3IgcmVzdWx0XG4gICAgKytwc2QucmVmOyAvLyBSZWZjb3VudGluZyBjdXJyZW50IHNjb3BlXG4gICAgZXhlY3V0ZVByb21pc2VUYXNrKHRoaXMsIGZuKTtcbn1cblxuLy8gUHJlcGFyZSBhIHByb3BlcnR5IGRlc2NyaXB0b3IgdG8gcHV0IG9udG8gUHJvbWlzZS5wcm90b3R5cGUudGhlblxuY29uc3QgdGhlblByb3AgPSB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHBzZCA9IFBTRCwgbWljcm9UYXNrSWQgPSB0b3RhbEVjaG9lcztcblxuICAgICAgICBmdW5jdGlvbiB0aGVuIChvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICAgICAgICAgICAgdmFyIHBvc3NpYmxlQXdhaXQgPSAhcHNkLmdsb2JhbCAmJiAocHNkICE9PSBQU0QgfHwgbWljcm9UYXNrSWQgIT09IHRvdGFsRWNob2VzKTtcbiAgICAgICAgICAgIGNvbnN0IGNsZWFudXAgPSBwb3NzaWJsZUF3YWl0ICYmICFkZWNyZW1lbnRFeHBlY3RlZEF3YWl0cygpO1xuICAgICAgICAgICAgdmFyIHJ2ID0gbmV3IERleGllUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgcHJvcGFnYXRlVG9MaXN0ZW5lcih0aGlzLCBuZXcgTGlzdGVuZXIoXG4gICAgICAgICAgICAgICAgICAgIG5hdGl2ZUF3YWl0Q29tcGF0aWJsZVdyYXAob25GdWxmaWxsZWQsIHBzZCwgcG9zc2libGVBd2FpdCwgY2xlYW51cCksXG4gICAgICAgICAgICAgICAgICAgIG5hdGl2ZUF3YWl0Q29tcGF0aWJsZVdyYXAob25SZWplY3RlZCwgcHNkLCBwb3NzaWJsZUF3YWl0LCBjbGVhbnVwKSxcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSxcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0LFxuICAgICAgICAgICAgICAgICAgICBwc2QpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZGVidWcgJiYgbGlua1RvUHJldmlvdXNQcm9taXNlKHJ2LCB0aGlzKTtcbiAgICAgICAgICAgIHJldHVybiBydjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoZW4ucHJvdG90eXBlID0gSU5URVJOQUw7IC8vIEZvciBpZGVtcG90ZW5zZSwgc2VlIHNldHRlciBiZWxvdy5cblxuICAgICAgICByZXR1cm4gdGhlbjtcbiAgICB9LFxuICAgIC8vIEJlIGlkZW1wb3RlbnQgYW5kIGFsbG93IGFub3RoZXIgZnJhbWV3b3JrIChzdWNoIGFzIHpvbmUuanMgb3IgYW5vdGhlciBpbnN0YW5jZSBvZiBhIERleGllLlByb21pc2UgbW9kdWxlKSB0byByZXBsYWNlIFByb21pc2UucHJvdG90eXBlLnRoZW5cbiAgICAvLyBhbmQgd2hlbiB0aGF0IGZyYW1ld29yayB3YW50cyB0byByZXN0b3JlIHRoZSBvcmlnaW5hbCBwcm9wZXJ0eSwgd2UgbXVzdCBpZGVudGlmeSB0aGF0IGFuZCByZXN0b3JlIHRoZSBvcmlnaW5hbCBwcm9wZXJ0eSBkZXNjcmlwdG9yLlxuICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHNldFByb3AgKHRoaXMsICd0aGVuJywgdmFsdWUgJiYgdmFsdWUucHJvdG90eXBlID09PSBJTlRFUk5BTCA/XG4gICAgICAgICAgICB0aGVuUHJvcCA6IC8vIFJlc3RvcmUgdG8gb3JpZ2luYWwgcHJvcGVydHkgZGVzY3JpcHRvci5cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTsgLy8gR2V0dGVyIHJldHVybmluZyBwcm92aWRlZCB2YWx1ZSAoYmVoYXZlcyBsaWtlIHZhbHVlIGlzIGp1c3QgY2hhbmdlZClcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldDogdGhlblByb3Auc2V0IC8vIEtlZXAgYSBzZXR0ZXIgdGhhdCBpcyBwcmVwYXJlZCB0byByZXN0b3JlIG9yaWdpbmFsLlxuICAgICAgICAgICAgfVxuICAgICAgICApO1xuICAgIH1cbn07XG5cbnByb3BzKERleGllUHJvbWlzZS5wcm90b3R5cGUsIHtcbiAgICB0aGVuOiB0aGVuUHJvcCwgLy8gRGVmaW5lZCBhYm92ZS5cbiAgICBfdGhlbjogZnVuY3Rpb24gKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gICAgICAgIC8vIEEgbGl0dGxlIHRpbmllciB2ZXJzaW9uIG9mIHRoZW4oKSB0aGF0IGRvbid0IGhhdmUgdG8gY3JlYXRlIGEgcmVzdWx0aW5nIHByb21pc2UuXG4gICAgICAgIHByb3BhZ2F0ZVRvTGlzdGVuZXIodGhpcywgbmV3IExpc3RlbmVyKG51bGwsIG51bGwsIG9uRnVsZmlsbGVkLCBvblJlamVjdGVkLCBQU0QpKTsgICAgICAgIFxuICAgIH0sXG5cbiAgICBjYXRjaDogZnVuY3Rpb24gKG9uUmVqZWN0ZWQpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHJldHVybiB0aGlzLnRoZW4obnVsbCwgb25SZWplY3RlZCk7XG4gICAgICAgIC8vIEZpcnN0IGFyZ3VtZW50IGlzIHRoZSBFcnJvciB0eXBlIHRvIGNhdGNoXG4gICAgICAgIHZhciB0eXBlID0gYXJndW1lbnRzWzBdLFxuICAgICAgICAgICAgaGFuZGxlciA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nID8gdGhpcy50aGVuKG51bGwsIGVyciA9PlxuICAgICAgICAgICAgLy8gQ2F0Y2hpbmcgZXJyb3JzIGJ5IGl0cyBjb25zdHJ1Y3RvciB0eXBlIChzaW1pbGFyIHRvIGphdmEgLyBjKysgLyBjIylcbiAgICAgICAgICAgIC8vIFNhbXBsZTogcHJvbWlzZS5jYXRjaChUeXBlRXJyb3IsIGZ1bmN0aW9uIChlKSB7IC4uLiB9KTtcbiAgICAgICAgICAgIGVyciBpbnN0YW5jZW9mIHR5cGUgPyBoYW5kbGVyKGVycikgOiBQcm9taXNlUmVqZWN0KGVycikpXG4gICAgICAgIDogdGhpcy50aGVuKG51bGwsIGVyciA9PlxuICAgICAgICAgICAgLy8gQ2F0Y2hpbmcgZXJyb3JzIGJ5IHRoZSBlcnJvci5uYW1lIHByb3BlcnR5LiBNYWtlcyBzZW5zZSBmb3IgaW5kZXhlZERCIHdoZXJlIGVycm9yIHR5cGVcbiAgICAgICAgICAgIC8vIGlzIGFsd2F5cyBET01FcnJvciBidXQgd2hlcmUgZS5uYW1lIHRlbGxzIHRoZSBhY3R1YWwgZXJyb3IgdHlwZS5cbiAgICAgICAgICAgIC8vIFNhbXBsZTogcHJvbWlzZS5jYXRjaCgnQ29uc3RyYWludEVycm9yJywgZnVuY3Rpb24gKGUpIHsgLi4uIH0pO1xuICAgICAgICAgICAgZXJyICYmIGVyci5uYW1lID09PSB0eXBlID8gaGFuZGxlcihlcnIpIDogUHJvbWlzZVJlamVjdChlcnIpKTtcbiAgICB9LFxuXG4gICAgZmluYWxseTogZnVuY3Rpb24gKG9uRmluYWxseSkge1xuICAgICAgICByZXR1cm4gdGhpcy50aGVuKHZhbHVlID0+IHtcbiAgICAgICAgICAgIG9uRmluYWxseSgpO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9LCBlcnIgPT4ge1xuICAgICAgICAgICAgb25GaW5hbGx5KCk7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZVJlamVjdChlcnIpO1xuICAgICAgICB9KTtcbiAgICB9LFxuICAgIFxuICAgIHN0YWNrOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fc3RhY2spIHJldHVybiB0aGlzLl9zdGFjaztcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgc3RhY2tfYmVpbmdfZ2VuZXJhdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB2YXIgc3RhY2tzID0gZ2V0U3RhY2sgKHRoaXMsIFtdLCBNQVhfTE9OR19TVEFDS1MpO1xuICAgICAgICAgICAgICAgIHZhciBzdGFjayA9IHN0YWNrcy5qb2luKFwiXFxuRnJvbSBwcmV2aW91czogXCIpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9zdGF0ZSAhPT0gbnVsbCkgdGhpcy5fc3RhY2sgPSBzdGFjazsgLy8gU3RhY2sgbWF5IGJlIHVwZGF0ZWQgb24gcmVqZWN0LlxuICAgICAgICAgICAgICAgIHJldHVybiBzdGFjaztcbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgc3RhY2tfYmVpbmdfZ2VuZXJhdGVkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgdGltZW91dDogZnVuY3Rpb24gKG1zLCBtc2cpIHtcbiAgICAgICAgcmV0dXJuIG1zIDwgSW5maW5pdHkgP1xuICAgICAgICAgICAgbmV3IERleGllUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIGhhbmRsZSA9IHNldFRpbWVvdXQoKCkgPT4gcmVqZWN0KG5ldyBleGNlcHRpb25zLlRpbWVvdXQobXNnKSksIG1zKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KS5maW5hbGx5KGNsZWFyVGltZW91dC5iaW5kKG51bGwsIGhhbmRsZSkpO1xuICAgICAgICAgICAgfSkgOiB0aGlzO1xuICAgIH1cbn0pO1xuXG5pZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKVxuICAgIHNldFByb3AoRGV4aWVQcm9taXNlLnByb3RvdHlwZSwgU3ltYm9sLnRvU3RyaW5nVGFnLCAnRGV4aWUuUHJvbWlzZScpO1xuXG4vLyBOb3cgdGhhdCBQcm9taXNlLnByb3RvdHlwZSBpcyBkZWZpbmVkLCB3ZSBoYXZlIGFsbCBpdCB0YWtlcyB0byBzZXQgZ2xvYmFsUFNELmVudi5cbi8vIEVudmlyb25tZW50IGdsb2JhbHMgc25hcHNob3R0ZWQgb24gbGVhdmluZyBnbG9iYWwgem9uZVxuZ2xvYmFsUFNELmVudiA9IHNuYXBTaG90KCk7XG5cbmZ1bmN0aW9uIExpc3RlbmVyKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkLCByZXNvbHZlLCByZWplY3QsIHpvbmUpIHtcbiAgICB0aGlzLm9uRnVsZmlsbGVkID0gdHlwZW9mIG9uRnVsZmlsbGVkID09PSAnZnVuY3Rpb24nID8gb25GdWxmaWxsZWQgOiBudWxsO1xuICAgIHRoaXMub25SZWplY3RlZCA9IHR5cGVvZiBvblJlamVjdGVkID09PSAnZnVuY3Rpb24nID8gb25SZWplY3RlZCA6IG51bGw7XG4gICAgdGhpcy5yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICB0aGlzLnJlamVjdCA9IHJlamVjdDtcbiAgICB0aGlzLnBzZCA9IHpvbmU7XG59XG5cbi8vIFByb21pc2UgU3RhdGljIFByb3BlcnRpZXNcbnByb3BzIChEZXhpZVByb21pc2UsIHtcbiAgICBhbGw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHZhbHVlcyA9IGdldEFycmF5T2YuYXBwbHkobnVsbCwgYXJndW1lbnRzKSAvLyBTdXBwb3J0cyBpdGVyYWJsZXMsIGltcGxpY2l0IGFyZ3VtZW50cyBhbmQgYXJyYXktbGlrZS5cbiAgICAgICAgICAgIC5tYXAob25Qb3NzaWJsZVBhcmFsbGVsbEFzeW5jKTsgLy8gSGFuZGxlIHBhcmFsbGVsbCBhc3luYy9hd2FpdHMgXG4gICAgICAgIHJldHVybiBuZXcgRGV4aWVQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZXMubGVuZ3RoID09PSAwKSByZXNvbHZlKFtdKTtcbiAgICAgICAgICAgIHZhciByZW1haW5pbmcgPSB2YWx1ZXMubGVuZ3RoO1xuICAgICAgICAgICAgdmFsdWVzLmZvckVhY2goKGEsaSkgPT4gRGV4aWVQcm9taXNlLnJlc29sdmUoYSkudGhlbih4ID0+IHtcbiAgICAgICAgICAgICAgICB2YWx1ZXNbaV0gPSB4O1xuICAgICAgICAgICAgICAgIGlmICghLS1yZW1haW5pbmcpIHJlc29sdmUodmFsdWVzKTtcbiAgICAgICAgICAgIH0sIHJlamVjdCkpO1xuICAgICAgICB9KTtcbiAgICB9LFxuICAgIFxuICAgIHJlc29sdmU6IHZhbHVlID0+IHtcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGV4aWVQcm9taXNlKSByZXR1cm4gdmFsdWU7XG4gICAgICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUudGhlbiA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIG5ldyBEZXhpZVByb21pc2UoKHJlc29sdmUsIHJlamVjdCk9PntcbiAgICAgICAgICAgIHZhbHVlLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBydiA9IG5ldyBEZXhpZVByb21pc2UoSU5URVJOQUwsIHRydWUsIHZhbHVlKTtcbiAgICAgICAgbGlua1RvUHJldmlvdXNQcm9taXNlKHJ2LCBjdXJyZW50RnVsZmlsbGVyKTtcbiAgICAgICAgcmV0dXJuIHJ2O1xuICAgIH0sXG4gICAgXG4gICAgcmVqZWN0OiBQcm9taXNlUmVqZWN0LFxuICAgIFxuICAgIHJhY2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHZhbHVlcyA9IGdldEFycmF5T2YuYXBwbHkobnVsbCwgYXJndW1lbnRzKS5tYXAob25Qb3NzaWJsZVBhcmFsbGVsbEFzeW5jKTtcbiAgICAgICAgcmV0dXJuIG5ldyBEZXhpZVByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdmFsdWVzLm1hcCh2YWx1ZSA9PiBEZXhpZVByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihyZXNvbHZlLCByZWplY3QpKTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIFBTRDoge1xuICAgICAgICBnZXQ6ICgpPT5QU0QsXG4gICAgICAgIHNldDogdmFsdWUgPT4gUFNEID0gdmFsdWVcbiAgICB9LFxuXG4gICAgdG90YWxFY2hvZXM6IHtnZXQ6ICgpPT50b3RhbEVjaG9lc30sXG5cbiAgICAvL3Rhc2s6IHtnZXQ6ICgpPT50YXNrfSxcbiAgICBcbiAgICBuZXdQU0Q6IG5ld1Njb3BlLFxuICAgIFxuICAgIHVzZVBTRDogdXNlUFNELFxuICAgIFxuICAgIHNjaGVkdWxlcjoge1xuICAgICAgICBnZXQ6ICgpID0+IGFzYXAsXG4gICAgICAgIHNldDogdmFsdWUgPT4ge2FzYXAgPSB2YWx1ZX1cbiAgICB9LFxuICAgIFxuICAgIHJlamVjdGlvbk1hcHBlcjoge1xuICAgICAgICBnZXQ6ICgpID0+IHJlamVjdGlvbk1hcHBlcixcbiAgICAgICAgc2V0OiB2YWx1ZSA9PiB7cmVqZWN0aW9uTWFwcGVyID0gdmFsdWU7fSAvLyBNYXAgcmVqZWN0IGZhaWx1cmVzXG4gICAgfSxcbiAgICAgICAgICAgIFxuICAgIGZvbGxvdzogKGZuLCB6b25lUHJvcHMpID0+IHtcbiAgICAgICAgcmV0dXJuIG5ldyBEZXhpZVByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIG5ld1Njb3BlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgcHNkID0gUFNEO1xuICAgICAgICAgICAgICAgIHBzZC51bmhhbmRsZWRzID0gW107IC8vIEZvciB1bmhhbmRsZWQgc3RhbmRhcmQtIG9yIDNyZCBwYXJ0eSBQcm9taXNlcy4gQ2hlY2tlZCBhdCBwc2QuZmluYWxpemUoKVxuICAgICAgICAgICAgICAgIHBzZC5vbnVuaGFuZGxlZCA9IHJlamVjdDsgLy8gVHJpZ2dlcmVkIGRpcmVjdGx5IG9uIHVuaGFuZGxlZCBwcm9taXNlcyBvZiB0aGlzIGxpYnJhcnkuXG4gICAgICAgICAgICAgICAgcHNkLmZpbmFsaXplID0gY2FsbEJvdGgoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBVbmhhbmRsZWQgc3RhbmRhcmQgb3IgM3JkIHBhcnQgcHJvbWlzZXMgYXJlIHB1dCBpbiBQU0QudW5oYW5kbGVkcyBhbmRcbiAgICAgICAgICAgICAgICAgICAgLy8gZXhhbWluZWQgdXBvbiBzY29wZSBjb21wbGV0aW9uIHdoaWxlIHVuaGFuZGxlZCByZWplY3Rpb25zIGluIHRoaXMgUHJvbWlzZVxuICAgICAgICAgICAgICAgICAgICAvLyB3aWxsIHRyaWdnZXIgZGlyZWN0bHkgdGhyb3VnaCBwc2Qub251bmhhbmRsZWRcbiAgICAgICAgICAgICAgICAgICAgcnVuX2F0X2VuZF9vZl90aGlzX29yX25leHRfcGh5c2ljYWxfdGljaygoKT0+e1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51bmhhbmRsZWRzLmxlbmd0aCA9PT0gMCA/IHJlc29sdmUoKSA6IHJlamVjdCh0aGlzLnVuaGFuZGxlZHNbMF0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9LCBwc2QuZmluYWxpemUpO1xuICAgICAgICAgICAgICAgIGZuKCk7XG4gICAgICAgICAgICB9LCB6b25lUHJvcHMsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn0pO1xuXG5pZiAoTmF0aXZlUHJvbWlzZSkge1xuICAgIGlmIChOYXRpdmVQcm9taXNlLmFsbFNldHRsZWQpIHNldFByb3AgKERleGllUHJvbWlzZSwgXCJhbGxTZXR0bGVkXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zdCBwb3NzaWJsZVByb21pc2VzID0gZ2V0QXJyYXlPZi5hcHBseShudWxsLCBhcmd1bWVudHMpLm1hcChvblBvc3NpYmxlUGFyYWxsZWxsQXN5bmMpO1xuICAgICAgICByZXR1cm4gbmV3IERleGllUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgICAgIGlmIChwb3NzaWJsZVByb21pc2VzLmxlbmd0aCA9PT0gMCkgcmVzb2x2ZShbXSk7XG4gICAgICAgICAgICBsZXQgcmVtYWluaW5nID0gcG9zc2libGVQcm9taXNlcy5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdCByZXN1bHRzID0gbmV3IEFycmF5KHJlbWFpbmluZyk7XG4gICAgICAgICAgICBwb3NzaWJsZVByb21pc2VzLmZvckVhY2goKHAsIGkpID0+IERleGllUHJvbWlzZS5yZXNvbHZlKHApLnRoZW4oXG4gICAgICAgICAgICAgICAgdmFsdWUgPT4gcmVzdWx0c1tpXSA9IHtzdGF0dXM6IFwiZnVsZmlsbGVkXCIsIHZhbHVlfSxcbiAgICAgICAgICAgICAgICByZWFzb24gPT4gcmVzdWx0c1tpXSA9IHtzdGF0dXM6IFwicmVqZWN0ZWRcIiwgcmVhc29ufSlcbiAgICAgICAgICAgICAgICAudGhlbigoKT0+LS1yZW1haW5pbmcgfHwgcmVzb2x2ZShyZXN1bHRzKSkpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICBpZiAoTmF0aXZlUHJvbWlzZS5hbnkgJiYgdHlwZW9mIEFnZ3JlZ2F0ZUVycm9yICE9PSAndW5kZWZpbmVkJykgc2V0UHJvcChEZXhpZVByb21pc2UsIFwiYW55XCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zdCBwb3NzaWJsZVByb21pc2VzID0gZ2V0QXJyYXlPZi5hcHBseShudWxsLCBhcmd1bWVudHMpLm1hcChvblBvc3NpYmxlUGFyYWxsZWxsQXN5bmMpO1xuICAgICAgICByZXR1cm4gbmV3IERleGllUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBpZiAocG9zc2libGVQcm9taXNlcy5sZW5ndGggPT09IDApIHJlamVjdChuZXcgQWdncmVnYXRlRXJyb3IoW10pKTtcbiAgICAgICAgICAgIGxldCByZW1haW5pbmcgPSBwb3NzaWJsZVByb21pc2VzLmxlbmd0aDtcbiAgICAgICAgICAgIGNvbnN0IGZhaWx1cmVzID0gbmV3IEFycmF5KHJlbWFpbmluZyk7XG4gICAgICAgICAgICBwb3NzaWJsZVByb21pc2VzLmZvckVhY2goKHAsIGkpID0+IERleGllUHJvbWlzZS5yZXNvbHZlKHApLnRoZW4oXG4gICAgICAgICAgICAgICAgdmFsdWUgPT4gcmVzb2x2ZSh2YWx1ZSksXG4gICAgICAgICAgICAgICAgZmFpbHVyZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGZhaWx1cmVzW2ldID0gZmFpbHVyZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEtLXJlbWFpbmluZykgcmVqZWN0KG5ldyBBZ2dyZWdhdGVFcnJvcihmYWlsdXJlcykpO1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5cbi8qKlxuKiBUYWtlIGEgcG90ZW50aWFsbHkgbWlzYmVoYXZpbmcgcmVzb2x2ZXIgZnVuY3Rpb24gYW5kIG1ha2Ugc3VyZVxuKiBvbkZ1bGZpbGxlZCBhbmQgb25SZWplY3RlZCBhcmUgb25seSBjYWxsZWQgb25jZS5cbipcbiogTWFrZXMgbm8gZ3VhcmFudGVlcyBhYm91dCBhc3luY2hyb255LlxuKi9cbmZ1bmN0aW9uIGV4ZWN1dGVQcm9taXNlVGFzayAocHJvbWlzZSwgZm4pIHtcbiAgICAvLyBQcm9taXNlIFJlc29sdXRpb24gUHJvY2VkdXJlOlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wcm9taXNlcy1hcGx1cy9wcm9taXNlcy1zcGVjI3RoZS1wcm9taXNlLXJlc29sdXRpb24tcHJvY2VkdXJlXG4gICAgdHJ5IHtcbiAgICAgICAgZm4odmFsdWUgPT4ge1xuICAgICAgICAgICAgaWYgKHByb21pc2UuX3N0YXRlICE9PSBudWxsKSByZXR1cm47IC8vIEFscmVhZHkgc2V0dGxlZFxuICAgICAgICAgICAgaWYgKHZhbHVlID09PSBwcm9taXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBIHByb21pc2UgY2Fubm90IGJlIHJlc29sdmVkIHdpdGggaXRzZWxmLicpO1xuICAgICAgICAgICAgdmFyIHNob3VsZEV4ZWN1dGVUaWNrID0gcHJvbWlzZS5fbGliICYmIGJlZ2luTWljcm9UaWNrU2NvcGUoKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGV4ZWN1dGVQcm9taXNlVGFzayhwcm9taXNlLCAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlIGluc3RhbmNlb2YgRGV4aWVQcm9taXNlID9cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLl90aGVuKHJlc29sdmUsIHJlamVjdCkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlLl9zdGF0ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgcHJvbWlzZS5fdmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBwcm9wYWdhdGVBbGxMaXN0ZW5lcnMocHJvbWlzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2hvdWxkRXhlY3V0ZVRpY2spIGVuZE1pY3JvVGlja1Njb3BlKCk7XG4gICAgICAgIH0sIGhhbmRsZVJlamVjdGlvbi5iaW5kKG51bGwsIHByb21pc2UpKTsgLy8gSWYgRnVuY3Rpb24uYmluZCBpcyBub3Qgc3VwcG9ydGVkLiBFeGNlcHRpb24gaXMgaGFuZGxlZCBpbiBjYXRjaCBiZWxvd1xuICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgIGhhbmRsZVJlamVjdGlvbihwcm9taXNlLCBleCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVSZWplY3Rpb24gKHByb21pc2UsIHJlYXNvbikge1xuICAgIHJlamVjdGluZ0Vycm9ycy5wdXNoKHJlYXNvbik7XG4gICAgaWYgKHByb21pc2UuX3N0YXRlICE9PSBudWxsKSByZXR1cm47XG4gICAgdmFyIHNob3VsZEV4ZWN1dGVUaWNrID0gcHJvbWlzZS5fbGliICYmIGJlZ2luTWljcm9UaWNrU2NvcGUoKTtcbiAgICByZWFzb24gPSByZWplY3Rpb25NYXBwZXIocmVhc29uKTtcbiAgICBwcm9taXNlLl9zdGF0ZSA9IGZhbHNlO1xuICAgIHByb21pc2UuX3ZhbHVlID0gcmVhc29uO1xuICAgIGRlYnVnICYmIHJlYXNvbiAhPT0gbnVsbCAmJiB0eXBlb2YgcmVhc29uID09PSAnb2JqZWN0JyAmJiAhcmVhc29uLl9wcm9taXNlICYmIHRyeUNhdGNoKCgpPT57XG4gICAgICAgIHZhciBvcmlnUHJvcCA9IGdldFByb3BlcnR5RGVzY3JpcHRvcihyZWFzb24sIFwic3RhY2tcIik7ICAgICAgICBcbiAgICAgICAgcmVhc29uLl9wcm9taXNlID0gcHJvbWlzZTsgICAgXG4gICAgICAgIHNldFByb3AocmVhc29uLCBcInN0YWNrXCIsIHtcbiAgICAgICAgICAgIGdldDogKCkgPT5cbiAgICAgICAgICAgICAgICBzdGFja19iZWluZ19nZW5lcmF0ZWQgP1xuICAgICAgICAgICAgICAgICAgICBvcmlnUHJvcCAmJiAob3JpZ1Byb3AuZ2V0ID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ1Byb3AuZ2V0LmFwcGx5KHJlYXNvbikgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmlnUHJvcC52YWx1ZSkgOlxuICAgICAgICAgICAgICAgICAgICBwcm9taXNlLnN0YWNrXG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIC8vIEFkZCB0aGUgZmFpbHVyZSB0byBhIGxpc3Qgb2YgcG9zc2libHkgdW5jYXVnaHQgZXJyb3JzXG4gICAgYWRkUG9zc2libHlVbmhhbmRsZWRFcnJvcihwcm9taXNlKTtcbiAgICBwcm9wYWdhdGVBbGxMaXN0ZW5lcnMocHJvbWlzZSk7XG4gICAgaWYgKHNob3VsZEV4ZWN1dGVUaWNrKSBlbmRNaWNyb1RpY2tTY29wZSgpO1xufVxuXG5mdW5jdGlvbiBwcm9wYWdhdGVBbGxMaXN0ZW5lcnMgKHByb21pc2UpIHtcbiAgICAvL2RlYnVnICYmIGxpbmtUb1ByZXZpb3VzUHJvbWlzZShwcm9taXNlKTtcbiAgICB2YXIgbGlzdGVuZXJzID0gcHJvbWlzZS5fbGlzdGVuZXJzO1xuICAgIHByb21pc2UuX2xpc3RlbmVycyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgcHJvcGFnYXRlVG9MaXN0ZW5lcihwcm9taXNlLCBsaXN0ZW5lcnNbaV0pO1xuICAgIH1cbiAgICB2YXIgcHNkID0gcHJvbWlzZS5fUFNEO1xuICAgIC0tcHNkLnJlZiB8fCBwc2QuZmluYWxpemUoKTsgLy8gaWYgcHNkLnJlZiByZWFjaGVzIHplcm8sIGNhbGwgcHNkLmZpbmFsaXplKCk7XG4gICAgaWYgKG51bVNjaGVkdWxlZENhbGxzID09PSAwKSB7XG4gICAgICAgIC8vIElmIG51bVNjaGVkdWxlZENhbGxzIGlzIDAsIGl0IG1lYW5zIHRoYXQgb3VyIHN0YWNrIGlzIG5vdCBpbiBhIGNhbGxiYWNrIG9mIGEgc2NoZWR1bGVkIGNhbGwsXG4gICAgICAgIC8vIGFuZCB0aGF0IG5vIGRlZmVycmVkcyB3aGVyZSBsaXN0ZW5pbmcgdG8gdGhpcyByZWplY3Rpb24gb3Igc3VjY2Vzcy5cbiAgICAgICAgLy8gU2luY2UgdGhlcmUgaXMgYSByaXNrIHRoYXQgb3VyIHN0YWNrIGNhbiBjb250YWluIGFwcGxpY2F0aW9uIGNvZGUgdGhhdCBtYXlcbiAgICAgICAgLy8gZG8gc3R1ZmYgYWZ0ZXIgdGhpcyBjb2RlIGlzIGZpbmlzaGVkIHRoYXQgbWF5IGdlbmVyYXRlIG5ldyBjYWxscywgd2UgY2Fubm90XG4gICAgICAgIC8vIGNhbGwgZmluYWxpemVycyBoZXJlLlxuICAgICAgICArK251bVNjaGVkdWxlZENhbGxzO1xuICAgICAgICBhc2FwKCgpPT57XG4gICAgICAgICAgICBpZiAoLS1udW1TY2hlZHVsZWRDYWxscyA9PT0gMCkgZmluYWxpemVQaHlzaWNhbFRpY2soKTsgLy8gV2lsbCBkZXRlY3QgdW5oYW5kbGVkIGVycm9yc1xuICAgICAgICB9LCBbXSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBwcm9wYWdhdGVUb0xpc3RlbmVyKHByb21pc2UsIGxpc3RlbmVyKSB7XG4gICAgaWYgKHByb21pc2UuX3N0YXRlID09PSBudWxsKSB7XG4gICAgICAgIHByb21pc2UuX2xpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBjYiA9IHByb21pc2UuX3N0YXRlID8gbGlzdGVuZXIub25GdWxmaWxsZWQgOiBsaXN0ZW5lci5vblJlamVjdGVkO1xuICAgIGlmIChjYiA9PT0gbnVsbCkge1xuICAgICAgICAvLyBUaGlzIExpc3RlbmVyIGRvZXNudCBoYXZlIGEgbGlzdGVuZXIgZm9yIHRoZSBldmVudCBiZWluZyB0cmlnZ2VyZWQgKG9uRnVsZmlsbGVkIG9yIG9uUmVqZWN0KSBzbyBsZXRzIGZvcndhcmQgdGhlIGV2ZW50IHRvIGFueSBldmVudHVhbCBsaXN0ZW5lcnMgb24gdGhlIFByb21pc2UgaW5zdGFuY2UgcmV0dXJuZWQgYnkgdGhlbigpIG9yIGNhdGNoKClcbiAgICAgICAgcmV0dXJuIChwcm9taXNlLl9zdGF0ZSA/IGxpc3RlbmVyLnJlc29sdmUgOiBsaXN0ZW5lci5yZWplY3QpIChwcm9taXNlLl92YWx1ZSk7XG4gICAgfVxuICAgICsrbGlzdGVuZXIucHNkLnJlZjtcbiAgICArK251bVNjaGVkdWxlZENhbGxzO1xuICAgIGFzYXAgKGNhbGxMaXN0ZW5lciwgW2NiLCBwcm9taXNlLCBsaXN0ZW5lcl0pO1xufVxuXG5mdW5jdGlvbiBjYWxsTGlzdGVuZXIgKGNiLCBwcm9taXNlLCBsaXN0ZW5lcikge1xuICAgIHRyeSB7XG4gICAgICAgIC8vIFNldCBzdGF0aWMgdmFyaWFibGUgY3VycmVudEZ1bGZpbGxlciB0byB0aGUgcHJvbWlzZSB0aGF0IGlzIGJlaW5nIGZ1bGxmaWxsZWQsXG4gICAgICAgIC8vIHNvIHRoYXQgd2UgY29ubmVjdCB0aGUgY2hhaW4gb2YgcHJvbWlzZXMgKGZvciBsb25nIHN0YWNrcyBzdXBwb3J0KVxuICAgICAgICBjdXJyZW50RnVsZmlsbGVyID0gcHJvbWlzZTtcbiAgICAgICAgXG4gICAgICAgIC8vIENhbGwgY2FsbGJhY2sgYW5kIHJlc29sdmUgb3VyIGxpc3RlbmVyIHdpdGggaXQncyByZXR1cm4gdmFsdWUuXG4gICAgICAgIHZhciByZXQsIHZhbHVlID0gcHJvbWlzZS5fdmFsdWU7XG4gICAgICAgICAgICBcbiAgICAgICAgaWYgKHByb21pc2UuX3N0YXRlKSB7XG4gICAgICAgICAgICAvLyBjYiBpcyBvblJlc29sdmVkXG4gICAgICAgICAgICByZXQgPSBjYiAodmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gY2IgaXMgb25SZWplY3RlZFxuICAgICAgICAgICAgaWYgKHJlamVjdGluZ0Vycm9ycy5sZW5ndGgpIHJlamVjdGluZ0Vycm9ycyA9IFtdO1xuICAgICAgICAgICAgcmV0ID0gY2IodmFsdWUpO1xuICAgICAgICAgICAgaWYgKHJlamVjdGluZ0Vycm9ycy5pbmRleE9mKHZhbHVlKSA9PT0gLTEpXG4gICAgICAgICAgICAgICAgbWFya0Vycm9yQXNIYW5kbGVkKHByb21pc2UpOyAvLyBDYWxsYmFjayBkaWRudCBkbyBQcm9taXNlLnJlamVjdChlcnIpIG5vciByZWplY3QoZXJyKSBvbnRvIGFub3RoZXIgcHJvbWlzZS5cbiAgICAgICAgfVxuICAgICAgICBsaXN0ZW5lci5yZXNvbHZlKHJldCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBFeGNlcHRpb24gdGhyb3duIGluIGNhbGxiYWNrLiBSZWplY3Qgb3VyIGxpc3RlbmVyLlxuICAgICAgICBsaXN0ZW5lci5yZWplY3QoZSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgICAgLy8gUmVzdG9yZSBlbnYgYW5kIGN1cnJlbnRGdWxmaWxsZXIuXG4gICAgICAgIGN1cnJlbnRGdWxmaWxsZXIgPSBudWxsO1xuICAgICAgICBpZiAoLS1udW1TY2hlZHVsZWRDYWxscyA9PT0gMCkgZmluYWxpemVQaHlzaWNhbFRpY2soKTtcbiAgICAgICAgLS1saXN0ZW5lci5wc2QucmVmIHx8IGxpc3RlbmVyLnBzZC5maW5hbGl6ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZ2V0U3RhY2sgKHByb21pc2UsIHN0YWNrcywgbGltaXQpIHtcbiAgICBpZiAoc3RhY2tzLmxlbmd0aCA9PT0gbGltaXQpIHJldHVybiBzdGFja3M7XG4gICAgdmFyIHN0YWNrID0gXCJcIjtcbiAgICBpZiAocHJvbWlzZS5fc3RhdGUgPT09IGZhbHNlKSB7XG4gICAgICAgIHZhciBmYWlsdXJlID0gcHJvbWlzZS5fdmFsdWUsXG4gICAgICAgICAgICBlcnJvck5hbWUsXG4gICAgICAgICAgICBtZXNzYWdlO1xuICAgICAgICBcbiAgICAgICAgaWYgKGZhaWx1cmUgIT0gbnVsbCkge1xuICAgICAgICAgICAgZXJyb3JOYW1lID0gZmFpbHVyZS5uYW1lIHx8IFwiRXJyb3JcIjtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBmYWlsdXJlLm1lc3NhZ2UgfHwgZmFpbHVyZTtcbiAgICAgICAgICAgIHN0YWNrID0gcHJldHR5U3RhY2soZmFpbHVyZSwgMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlcnJvck5hbWUgPSBmYWlsdXJlOyAvLyBJZiBlcnJvciBpcyB1bmRlZmluZWQgb3IgbnVsbCwgc2hvdyB0aGF0LlxuICAgICAgICAgICAgbWVzc2FnZSA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgc3RhY2tzLnB1c2goZXJyb3JOYW1lICsgKG1lc3NhZ2UgPyBcIjogXCIgKyBtZXNzYWdlIDogXCJcIikgKyBzdGFjayk7XG4gICAgfVxuICAgIGlmIChkZWJ1Zykge1xuICAgICAgICBzdGFjayA9IHByZXR0eVN0YWNrKHByb21pc2UuX3N0YWNrSG9sZGVyLCAyKTtcbiAgICAgICAgaWYgKHN0YWNrICYmIHN0YWNrcy5pbmRleE9mKHN0YWNrKSA9PT0gLTEpIHN0YWNrcy5wdXNoKHN0YWNrKTtcbiAgICAgICAgaWYgKHByb21pc2UuX3ByZXYpIGdldFN0YWNrKHByb21pc2UuX3ByZXYsIHN0YWNrcywgbGltaXQpO1xuICAgIH1cbiAgICByZXR1cm4gc3RhY2tzO1xufVxuXG5mdW5jdGlvbiBsaW5rVG9QcmV2aW91c1Byb21pc2UocHJvbWlzZSwgcHJldikge1xuICAgIC8vIFN1cHBvcnQgbG9uZyBzdGFja3MgYnkgbGlua2luZyB0byBwcmV2aW91cyBjb21wbGV0ZWQgcHJvbWlzZS5cbiAgICB2YXIgbnVtUHJldiA9IHByZXYgPyBwcmV2Ll9udW1QcmV2ICsgMSA6IDA7XG4gICAgaWYgKG51bVByZXYgPCBMT05HX1NUQUNLU19DTElQX0xJTUlUKSB7IC8vIFByb2hpYml0IGluZmluaXRlIFByb21pc2UgbG9vcHMgdG8gZ2V0IGFuIGluZmluaXRlIGxvbmcgbWVtb3J5IGNvbnN1bWluZyBcInRhaWxcIi5cbiAgICAgICAgcHJvbWlzZS5fcHJldiA9IHByZXY7XG4gICAgICAgIHByb21pc2UuX251bVByZXYgPSBudW1QcmV2O1xuICAgIH1cbn1cblxuLyogVGhlIGNhbGxiYWNrIHRvIHNjaGVkdWxlIHdpdGggc2V0SW1tZWRpYXRlKCkgb3Igc2V0VGltZW91dCgpLlxuICAgSXQgcnVucyBhIHZpcnR1YWwgbWljcm90aWNrIGFuZCBleGVjdXRlcyBhbnkgY2FsbGJhY2sgcmVnaXN0ZXJlZCBpbiBtaWNyb3RpY2tRdWV1ZS5cbiAqL1xuZnVuY3Rpb24gcGh5c2ljYWxUaWNrKCkge1xuICAgIGJlZ2luTWljcm9UaWNrU2NvcGUoKSAmJiBlbmRNaWNyb1RpY2tTY29wZSgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYmVnaW5NaWNyb1RpY2tTY29wZSgpIHtcbiAgICB2YXIgd2FzUm9vdEV4ZWMgPSBpc091dHNpZGVNaWNyb1RpY2s7XG4gICAgaXNPdXRzaWRlTWljcm9UaWNrID0gZmFsc2U7XG4gICAgbmVlZHNOZXdQaHlzaWNhbFRpY2sgPSBmYWxzZTtcbiAgICByZXR1cm4gd2FzUm9vdEV4ZWM7XG59XG5cbi8qIEV4ZWN1dGVzIG1pY3JvLXRpY2tzIHdpdGhvdXQgZG9pbmcgdHJ5Li5jYXRjaC5cbiAgIFRoaXMgY2FuIGJlIHBvc3NpYmxlIGJlY2F1c2Ugd2Ugb25seSB1c2UgdGhpcyBpbnRlcm5hbGx5IGFuZFxuICAgdGhlIHJlZ2lzdGVyZWQgZnVuY3Rpb25zIGFyZSBleGNlcHRpb24tc2FmZSAodGhleSBkbyB0cnkuLmNhdGNoXG4gICBpbnRlcm5hbGx5IGJlZm9yZSBjYWxsaW5nIGFueSBleHRlcm5hbCBtZXRob2QpLiBJZiByZWdpc3RlcmluZ1xuICAgZnVuY3Rpb25zIGluIHRoZSBtaWNyb3RpY2tRdWV1ZSB0aGF0IGFyZSBub3QgZXhjZXB0aW9uLXNhZmUsIHRoaXNcbiAgIHdvdWxkIGRlc3Ryb3kgdGhlIGZyYW1ld29yayBhbmQgbWFrZSBpdCBpbnN0YWJsZS4gU28gd2UgZG9uJ3QgZXhwb3J0XG4gICBvdXIgYXNhcCBtZXRob2QuXG4qL1xuZXhwb3J0IGZ1bmN0aW9uIGVuZE1pY3JvVGlja1Njb3BlKCkge1xuICAgIHZhciBjYWxsYmFja3MsIGksIGw7XG4gICAgZG8ge1xuICAgICAgICB3aGlsZSAobWljcm90aWNrUXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY2FsbGJhY2tzID0gbWljcm90aWNrUXVldWU7XG4gICAgICAgICAgICBtaWNyb3RpY2tRdWV1ZSA9IFtdO1xuICAgICAgICAgICAgbCA9IGNhbGxiYWNrcy5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSBjYWxsYmFja3NbaV07XG4gICAgICAgICAgICAgICAgaXRlbVswXS5hcHBseShudWxsLCBpdGVtWzFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gd2hpbGUgKG1pY3JvdGlja1F1ZXVlLmxlbmd0aCA+IDApO1xuICAgIGlzT3V0c2lkZU1pY3JvVGljayA9IHRydWU7XG4gICAgbmVlZHNOZXdQaHlzaWNhbFRpY2sgPSB0cnVlO1xufVxuXG5mdW5jdGlvbiBmaW5hbGl6ZVBoeXNpY2FsVGljaygpIHtcbiAgICB2YXIgdW5oYW5kbGVkRXJycyA9IHVuaGFuZGxlZEVycm9ycztcbiAgICB1bmhhbmRsZWRFcnJvcnMgPSBbXTtcbiAgICB1bmhhbmRsZWRFcnJzLmZvckVhY2gocCA9PiB7XG4gICAgICAgIHAuX1BTRC5vbnVuaGFuZGxlZC5jYWxsKG51bGwsIHAuX3ZhbHVlLCBwKTtcbiAgICB9KTtcbiAgICB2YXIgZmluYWxpemVycyA9IHRpY2tGaW5hbGl6ZXJzLnNsaWNlKDApOyAvLyBDbG9uZSBmaXJzdCBiZWNhdXNlIGZpbmFsaXplciBtYXkgcmVtb3ZlIGl0c2VsZiBmcm9tIGxpc3QuXG4gICAgdmFyIGkgPSBmaW5hbGl6ZXJzLmxlbmd0aDtcbiAgICB3aGlsZSAoaSkgZmluYWxpemVyc1stLWldKCk7ICAgIFxufVxuXG5mdW5jdGlvbiBydW5fYXRfZW5kX29mX3RoaXNfb3JfbmV4dF9waHlzaWNhbF90aWNrIChmbikge1xuICAgIGZ1bmN0aW9uIGZpbmFsaXplcigpIHtcbiAgICAgICAgZm4oKTtcbiAgICAgICAgdGlja0ZpbmFsaXplcnMuc3BsaWNlKHRpY2tGaW5hbGl6ZXJzLmluZGV4T2YoZmluYWxpemVyKSwgMSk7XG4gICAgfVxuICAgIHRpY2tGaW5hbGl6ZXJzLnB1c2goZmluYWxpemVyKTtcbiAgICArK251bVNjaGVkdWxlZENhbGxzO1xuICAgIGFzYXAoKCk9PntcbiAgICAgICAgaWYgKC0tbnVtU2NoZWR1bGVkQ2FsbHMgPT09IDApIGZpbmFsaXplUGh5c2ljYWxUaWNrKCk7XG4gICAgfSwgW10pO1xufVxuXG5mdW5jdGlvbiBhZGRQb3NzaWJseVVuaGFuZGxlZEVycm9yKHByb21pc2UpIHtcbiAgICAvLyBPbmx5IGFkZCB0byB1bmhhbmRsZWRFcnJvcnMgaWYgbm90IGFscmVhZHkgdGhlcmUuIFRoZSBmaXJzdCBvbmUgdG8gYWRkIHRvIHRoaXMgbGlzdFxuICAgIC8vIHdpbGwgYmUgdXBvbiB0aGUgZmlyc3QgcmVqZWN0aW9uIHNvIHRoYXQgdGhlIHJvb3QgY2F1c2UgKGZpcnN0IHByb21pc2UgaW4gdGhlXG4gICAgLy8gcmVqZWN0aW9uIGNoYWluKSBpcyB0aGUgb25lIGxpc3RlZC5cbiAgICBpZiAoIXVuaGFuZGxlZEVycm9ycy5zb21lKHAgPT4gcC5fdmFsdWUgPT09IHByb21pc2UuX3ZhbHVlKSlcbiAgICAgICAgdW5oYW5kbGVkRXJyb3JzLnB1c2gocHJvbWlzZSk7XG59XG5cbmZ1bmN0aW9uIG1hcmtFcnJvckFzSGFuZGxlZChwcm9taXNlKSB7XG4gICAgLy8gQ2FsbGVkIHdoZW4gYSByZWplY3QgaGFuZGxlZCBpcyBhY3R1YWxseSBiZWluZyBjYWxsZWQuXG4gICAgLy8gU2VhcmNoIGluIHVuaGFuZGxlZEVycm9ycyBmb3IgYW55IHByb21pc2Ugd2hvcyBfdmFsdWUgaXMgdGhpcyBwcm9taXNlX3ZhbHVlIChsaXN0XG4gICAgLy8gY29udGFpbnMgb25seSByZWplY3RlZCBwcm9taXNlcywgYW5kIG9ubHkgb25lIGl0ZW0gcGVyIGVycm9yKVxuICAgIHZhciBpID0gdW5oYW5kbGVkRXJyb3JzLmxlbmd0aDtcbiAgICB3aGlsZSAoaSkgaWYgKHVuaGFuZGxlZEVycm9yc1stLWldLl92YWx1ZSA9PT0gcHJvbWlzZS5fdmFsdWUpIHtcbiAgICAgICAgLy8gRm91bmQgYSBwcm9taXNlIHRoYXQgZmFpbGVkIHdpdGggdGhpcyBzYW1lIGVycm9yIG9iamVjdCBwb2ludGVyLFxuICAgICAgICAvLyBSZW1vdmUgdGhhdCBzaW5jZSB0aGVyZSBpcyBhIGxpc3RlbmVyIHRoYXQgYWN0dWFsbHkgdGFrZXMgY2FyZSBvZiBpdC5cbiAgICAgICAgdW5oYW5kbGVkRXJyb3JzLnNwbGljZShpLCAxKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gUHJvbWlzZVJlamVjdCAocmVhc29uKSB7XG4gICAgcmV0dXJuIG5ldyBEZXhpZVByb21pc2UoSU5URVJOQUwsIGZhbHNlLCByZWFzb24pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gd3JhcCAoZm4sIGVycm9yQ2F0Y2hlcikge1xuICAgIHZhciBwc2QgPSBQU0Q7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgd2FzUm9vdEV4ZWMgPSBiZWdpbk1pY3JvVGlja1Njb3BlKCksXG4gICAgICAgICAgICBvdXRlclNjb3BlID0gUFNEO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzd2l0Y2hUb1pvbmUocHNkLCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBlcnJvckNhdGNoZXIgJiYgZXJyb3JDYXRjaGVyKGUpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgc3dpdGNoVG9ab25lKG91dGVyU2NvcGUsIGZhbHNlKTtcbiAgICAgICAgICAgIGlmICh3YXNSb290RXhlYykgZW5kTWljcm9UaWNrU2NvcGUoKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5cblxuLy9cbi8vIHZhcmlhYmxlcyB1c2VkIGZvciBuYXRpdmUgYXdhaXQgc3VwcG9ydFxuLy9cbmNvbnN0IHRhc2sgPSB7IGF3YWl0czogMCwgZWNob2VzOiAwLCBpZDogMH07IC8vIFRoZSBvbmdvaW5nIG1hY3JvLXRhc2sgd2hlbiB1c2luZyB6b25lLWVjaG9pbmcuXG52YXIgdGFza0NvdW50ZXIgPSAwOyAvLyBJRCBjb3VudGVyIGZvciBtYWNybyB0YXNrcy5cbnZhciB6b25lU3RhY2sgPSBbXTsgLy8gU3RhY2sgb2YgbGVmdCB6b25lcyB0byByZXN0b3JlIGFzeW5jaHJvbmljYWxseS5cbnZhciB6b25lRWNob2VzID0gMDsgLy8gem9uZUVjaG9lcyBpcyBhIG11c3QgaW4gb3JkZXIgdG8gcGVyc2lzdCB6b25lcyBiZXR3ZWVuIG5hdGl2ZSBhd2FpdCBleHByZXNzaW9ucy5cbnZhciB0b3RhbEVjaG9lcyA9IDA7IC8vIElEIGNvdW50ZXIgZm9yIG1pY3JvLXRhc2tzLiBVc2VkIHRvIGRldGVjdCBwb3NzaWJsZSBuYXRpdmUgYXdhaXQgaW4gb3VyIFByb21pc2UucHJvdG90eXBlLnRoZW4uXG5cblxudmFyIHpvbmVfaWRfY291bnRlciA9IDA7XG5leHBvcnQgZnVuY3Rpb24gbmV3U2NvcGUgKGZuLCBwcm9wcywgYTEsIGEyKSB7XG4gICAgdmFyIHBhcmVudCA9IFBTRCxcbiAgICAgICAgcHNkID0gT2JqZWN0LmNyZWF0ZShwYXJlbnQpO1xuICAgIHBzZC5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgcHNkLnJlZiA9IDA7XG4gICAgcHNkLmdsb2JhbCA9IGZhbHNlO1xuICAgIHBzZC5pZCA9ICsrem9uZV9pZF9jb3VudGVyO1xuICAgIC8vIFByZXBhcmUgZm9yIHByb21pc2UgcGF0Y2hpbmcgKGRvbmUgaW4gdXNlUFNEKTpcbiAgICB2YXIgZ2xvYmFsRW52ID0gZ2xvYmFsUFNELmVudjtcbiAgICBwc2QuZW52ID0gcGF0Y2hHbG9iYWxQcm9taXNlID8ge1xuICAgICAgICBQcm9taXNlOiBEZXhpZVByb21pc2UsIC8vIENoYW5naW5nIHdpbmRvdy5Qcm9taXNlIGNvdWxkIGJlIG9taXR0ZWQgZm9yIENocm9tZSBhbmQgRWRnZSwgd2hlcmUgSURCK1Byb21pc2UgcGxheXMgd2VsbCFcbiAgICAgICAgUHJvbWlzZVByb3A6IHt2YWx1ZTogRGV4aWVQcm9taXNlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlfSxcbiAgICAgICAgYWxsOiBEZXhpZVByb21pc2UuYWxsLFxuICAgICAgICByYWNlOiBEZXhpZVByb21pc2UucmFjZSxcbiAgICAgICAgYWxsU2V0dGxlZDogRGV4aWVQcm9taXNlLmFsbFNldHRsZWQsXG4gICAgICAgIGFueTogRGV4aWVQcm9taXNlLmFueSxcbiAgICAgICAgcmVzb2x2ZTogRGV4aWVQcm9taXNlLnJlc29sdmUsXG4gICAgICAgIHJlamVjdDogRGV4aWVQcm9taXNlLnJlamVjdCxcbiAgICAgICAgbnRoZW46IGdldFBhdGNoZWRQcm9taXNlVGhlbiAoZ2xvYmFsRW52Lm50aGVuLCBwc2QpLCAvLyBuYXRpdmUgdGhlblxuICAgICAgICBndGhlbjogZ2V0UGF0Y2hlZFByb21pc2VUaGVuIChnbG9iYWxFbnYuZ3RoZW4sIHBzZCkgLy8gZ2xvYmFsIHRoZW5cbiAgICB9IDoge307XG4gICAgaWYgKHByb3BzKSBleHRlbmQocHNkLCBwcm9wcyk7XG4gICAgXG4gICAgLy8gdW5oYW5kbGVkcyBhbmQgb251bmhhbmRsZWQgc2hvdWxkIG5vdCBiZSBzcGVjaWZpY2FsbHkgc2V0IGhlcmUuXG4gICAgLy8gTGVhdmUgdGhlbSBvbiBwYXJlbnQgcHJvdG90eXBlLlxuICAgIC8vIHVuaGFuZGxlZHMucHVzaChlcnIpIHdpbGwgcHVzaCB0byBwYXJlbnQncyBwcm90b3R5cGVcbiAgICAvLyBvbnVuaGFuZGxlZCgpIHdpbGwgY2FsbCBwYXJlbnRzIG9udW5oYW5kbGVkICh3aXRoIHRoaXMgc2NvcGUncyB0aGlzLXBvaW50ZXIgdGhvdWdoISlcbiAgICArK3BhcmVudC5yZWY7XG4gICAgcHNkLmZpbmFsaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAtLXRoaXMucGFyZW50LnJlZiB8fCB0aGlzLnBhcmVudC5maW5hbGl6ZSgpO1xuICAgIH1cbiAgICB2YXIgcnYgPSB1c2VQU0QgKHBzZCwgZm4sIGExLCBhMik7XG4gICAgaWYgKHBzZC5yZWYgPT09IDApIHBzZC5maW5hbGl6ZSgpO1xuICAgIHJldHVybiBydjtcbn1cblxuLy8gRnVuY3Rpb24gdG8gY2FsbCBpZiBzY29wZUZ1bmMgcmV0dXJucyBOYXRpdmVQcm9taXNlXG4vLyBBbHNvIGZvciBlYWNoIE5hdGl2ZVByb21pc2UgaW4gdGhlIGFyZ3VtZW50cyB0byBQcm9taXNlLmFsbCgpXG5leHBvcnQgZnVuY3Rpb24gaW5jcmVtZW50RXhwZWN0ZWRBd2FpdHMoKSB7XG4gICAgaWYgKCF0YXNrLmlkKSB0YXNrLmlkID0gKyt0YXNrQ291bnRlcjtcbiAgICArK3Rhc2suYXdhaXRzO1xuICAgIHRhc2suZWNob2VzICs9IFpPTkVfRUNIT19MSU1JVDtcbiAgICByZXR1cm4gdGFzay5pZDtcbn1cblxuLy8gRnVuY3Rpb24gdG8gY2FsbCB3aGVuICd0aGVuJyBjYWxscyBiYWNrIG9uIGEgbmF0aXZlIHByb21pc2Ugd2hlcmUgb25Bd2FpdEV4cGVjdGVkKCkgaGFkIGJlZW4gY2FsbGVkLlxuLy8gQWxzbyBjYWxsIHRoaXMgd2hlbiBhIG5hdGl2ZSBhd2FpdCBjYWxscyB0aGVuIG1ldGhvZCBvbiBhIHByb21pc2UuIEluIHRoYXQgY2FzZSwgZG9uJ3Qgc3VwcGx5XG4vLyBzb3VyY2VUYXNrSWQgYmVjYXVzZSB3ZSBhbHJlYWR5IGtub3cgaXQgcmVmZXJzIHRvIGN1cnJlbnQgdGFzay5cbmV4cG9ydCBmdW5jdGlvbiBkZWNyZW1lbnRFeHBlY3RlZEF3YWl0cygpIHtcbiAgICBpZiAoIXRhc2suYXdhaXRzKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKC0tdGFzay5hd2FpdHMgPT09IDApIHRhc2suaWQgPSAwO1xuICAgIHRhc2suZWNob2VzID0gdGFzay5hd2FpdHMgKiBaT05FX0VDSE9fTElNSVQ7IC8vIFdpbGwgcmVzZXQgZWNob2VzIHRvIDAgaWYgYXdhaXRzIGlzIDAuXG4gICAgcmV0dXJuIHRydWU7XG59XG5cbmlmICgoJycrbmF0aXZlUHJvbWlzZVRoZW4pLmluZGV4T2YoJ1tuYXRpdmUgY29kZV0nKSA9PT0gLTEpIHtcbiAgICAvLyBJZiB0aGUgbmF0aXZlIHByb21pc2UnIHByb3RvdHlwZSBpcyBwYXRjaGVkLCB3ZSBjYW5ub3QgcmVseSBvbiB6b25lIGVjaG9pbmcuXG4gICAgLy8gRGlzYWJsZSB0aGF0IGhlcmU6XG4gICAgaW5jcmVtZW50RXhwZWN0ZWRBd2FpdHMgPSBkZWNyZW1lbnRFeHBlY3RlZEF3YWl0cyA9IG5vcDtcbn1cblxuLy8gQ2FsbCBmcm9tIFByb21pc2UuYWxsKCkgYW5kIFByb21pc2UucmFjZSgpXG5leHBvcnQgZnVuY3Rpb24gb25Qb3NzaWJsZVBhcmFsbGVsbEFzeW5jIChwb3NzaWJsZVByb21pc2UpIHtcbiAgICBpZiAodGFzay5lY2hvZXMgJiYgcG9zc2libGVQcm9taXNlICYmIHBvc3NpYmxlUHJvbWlzZS5jb25zdHJ1Y3RvciA9PT0gTmF0aXZlUHJvbWlzZSkge1xuICAgICAgICBpbmNyZW1lbnRFeHBlY3RlZEF3YWl0cygpOyBcbiAgICAgICAgcmV0dXJuIHBvc3NpYmxlUHJvbWlzZS50aGVuKHggPT4ge1xuICAgICAgICAgICAgZGVjcmVtZW50RXhwZWN0ZWRBd2FpdHMoKTtcbiAgICAgICAgICAgIHJldHVybiB4O1xuICAgICAgICB9LCBlID0+IHtcbiAgICAgICAgICAgIGRlY3JlbWVudEV4cGVjdGVkQXdhaXRzKCk7XG4gICAgICAgICAgICByZXR1cm4gcmVqZWN0aW9uKGUpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHBvc3NpYmxlUHJvbWlzZTtcbn1cblxuZnVuY3Rpb24gem9uZUVudGVyRWNobyh0YXJnZXRab25lKSB7XG4gICAgKyt0b3RhbEVjaG9lcztcbiAgICAvL2NvbnNvbGUubG9nKFwiVG90YWwgZWNob2VzIFwiLCB0b3RhbEVjaG9lcyk7XG4gICAgaWYgKCF0YXNrLmVjaG9lcyB8fCAtLXRhc2suZWNob2VzID09PSAwKSB7XG4gICAgICAgIHRhc2suZWNob2VzID0gdGFzay5pZCA9IDA7IC8vIENhbmNlbCB6b25lIGVjaG9pbmcuXG4gICAgfVxuXG4gICAgem9uZVN0YWNrLnB1c2goUFNEKTtcbiAgICBzd2l0Y2hUb1pvbmUodGFyZ2V0Wm9uZSwgdHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIHpvbmVMZWF2ZUVjaG8oKSB7XG4gICAgdmFyIHpvbmUgPSB6b25lU3RhY2tbem9uZVN0YWNrLmxlbmd0aC0xXTtcbiAgICB6b25lU3RhY2sucG9wKCk7XG4gICAgc3dpdGNoVG9ab25lKHpvbmUsIGZhbHNlKTtcbn1cblxuZnVuY3Rpb24gc3dpdGNoVG9ab25lICh0YXJnZXRab25lLCBiRW50ZXJpbmdab25lKSB7XG4gICAgdmFyIGN1cnJlbnRab25lID0gUFNEO1xuICAgIGlmIChiRW50ZXJpbmdab25lID8gdGFzay5lY2hvZXMgJiYgKCF6b25lRWNob2VzKysgfHwgdGFyZ2V0Wm9uZSAhPT0gUFNEKSA6IHpvbmVFY2hvZXMgJiYgKCEtLXpvbmVFY2hvZXMgfHwgdGFyZ2V0Wm9uZSAhPT0gUFNEKSkge1xuICAgICAgICAvLyBFbnRlciBvciBsZWF2ZSB6b25lIGFzeW5jaHJvbmljYWxseSBhcyB3ZWxsLCBzbyB0aGF0IHRhc2tzIGluaXRpYXRlZCBkdXJpbmcgY3VycmVudCB0aWNrXG4gICAgICAgIC8vIHdpbGwgYmUgc3Vycm91bmRlZCBieSB0aGUgem9uZSB3aGVuIHRoZXkgYXJlIGludm9rZWQuXG4gICAgICAgIGVucXVldWVOYXRpdmVNaWNyb1Rhc2soYkVudGVyaW5nWm9uZSA/IHpvbmVFbnRlckVjaG8uYmluZChudWxsLCB0YXJnZXRab25lKSA6IHpvbmVMZWF2ZUVjaG8pO1xuICAgIH1cbiAgICBpZiAodGFyZ2V0Wm9uZSA9PT0gUFNEKSByZXR1cm47XG5cbiAgICBQU0QgPSB0YXJnZXRab25lOyAvLyBUaGUgYWN0dWFsIHpvbmUgc3dpdGNoIG9jY3VycyBhdCB0aGlzIGxpbmUuXG5cbiAgICAvLyBTbmFwc2hvdCBvbiBldmVyeSBsZWF2ZSBmcm9tIGdsb2JhbCB6b25lLlxuICAgIGlmIChjdXJyZW50Wm9uZSA9PT0gZ2xvYmFsUFNEKSBnbG9iYWxQU0QuZW52ID0gc25hcFNob3QoKTtcblxuICAgIGlmIChwYXRjaEdsb2JhbFByb21pc2UpIHtcbiAgICAgICAgLy8gTGV0J3MgcGF0Y2ggdGhlIGdsb2JhbCBhbmQgbmF0aXZlIFByb21pc2VzIChtYXkgYmUgc2FtZSBvciBtYXkgYmUgZGlmZmVyZW50KVxuICAgICAgICB2YXIgR2xvYmFsUHJvbWlzZSA9IGdsb2JhbFBTRC5lbnYuUHJvbWlzZTtcbiAgICAgICAgLy8gU3dpY2ggZW52aXJvbm1lbnRzIChtYXkgYmUgUFNELXpvbmUgb3IgdGhlIGdsb2JhbCB6b25lLiBCb3RoIGFwcGx5LilcbiAgICAgICAgdmFyIHRhcmdldEVudiA9IHRhcmdldFpvbmUuZW52O1xuXG4gICAgICAgIC8vIENoYW5nZSBQcm9taXNlLnByb3RvdHlwZS50aGVuIGZvciBuYXRpdmUgYW5kIGdsb2JhbCBQcm9taXNlICh0aGV5IE1BWSBkaWZmZXIgb24gcG9seWZpbGxlZCBlbnZpcm9ubWVudHMsIGJ1dCBib3RoIGNhbiBiZSBhY2Nlc3NlZClcbiAgICAgICAgLy8gTXVzdCBiZSBkb25lIG9uIGVhY2ggem9uZSBjaGFuZ2UgYmVjYXVzZSB0aGUgcGF0Y2hlZCBtZXRob2QgY29udGFpbnMgdGFyZ2V0Wm9uZSBpbiBpdHMgY2xvc3VyZS5cbiAgICAgICAgbmF0aXZlUHJvbWlzZVByb3RvLnRoZW4gPSB0YXJnZXRFbnYubnRoZW47XG4gICAgICAgIEdsb2JhbFByb21pc2UucHJvdG90eXBlLnRoZW4gPSB0YXJnZXRFbnYuZ3RoZW47XG5cbiAgICAgICAgaWYgKGN1cnJlbnRab25lLmdsb2JhbCB8fCB0YXJnZXRab25lLmdsb2JhbCkge1xuICAgICAgICAgICAgLy8gTGVhdmluZyBvciBlbnRlcmluZyBnbG9iYWwgem9uZS4gSXQncyB0aW1lIHRvIHBhdGNoIC8gcmVzdG9yZSBnbG9iYWwgUHJvbWlzZS5cblxuICAgICAgICAgICAgLy8gU2V0IHRoaXMgUHJvbWlzZSB0byB3aW5kb3cuUHJvbWlzZSBzbyB0aGF0IHRyYW5zaWxlZCBhc3luYyBmdW5jdGlvbnMgd2lsbCB3b3JrIG9uIEZpcmVmb3gsIFNhZmFyaSBhbmQgSUUsIGFzIHdlbGwgYXMgd2l0aCBab25lanMgYW5kIGFuZ3VsYXIuXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX2dsb2JhbCwgJ1Byb21pc2UnLCB0YXJnZXRFbnYuUHJvbWlzZVByb3ApO1xuXG4gICAgICAgICAgICAvLyBTdXBwb3J0IFByb21pc2UuYWxsKCkgZXRjIHRvIHdvcmsgaW5kZXhlZERCLXNhZmUgYWxzbyB3aGVuIHBlb3BsZSBhcmUgaW5jbHVkaW5nIGVzNi1wcm9taXNlIGFzIGEgbW9kdWxlICh0aGV5IG1pZ2h0XG4gICAgICAgICAgICAvLyBub3QgYmUgYWNjZXNzaW5nIGdsb2JhbC5Qcm9taXNlIGJ1dCBhIGxvY2FsIHJlZmVyZW5jZSB0byBpdClcbiAgICAgICAgICAgIEdsb2JhbFByb21pc2UuYWxsID0gdGFyZ2V0RW52LmFsbDtcbiAgICAgICAgICAgIEdsb2JhbFByb21pc2UucmFjZSA9IHRhcmdldEVudi5yYWNlO1xuICAgICAgICAgICAgR2xvYmFsUHJvbWlzZS5yZXNvbHZlID0gdGFyZ2V0RW52LnJlc29sdmU7XG4gICAgICAgICAgICBHbG9iYWxQcm9taXNlLnJlamVjdCA9IHRhcmdldEVudi5yZWplY3Q7XG4gICAgICAgICAgICBpZiAodGFyZ2V0RW52LmFsbFNldHRsZWQpIEdsb2JhbFByb21pc2UuYWxsU2V0dGxlZCA9IHRhcmdldEVudi5hbGxTZXR0bGVkO1xuICAgICAgICAgICAgaWYgKHRhcmdldEVudi5hbnkpIEdsb2JhbFByb21pc2UuYW55ID0gdGFyZ2V0RW52LmFueTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gc25hcFNob3QgKCkge1xuICAgIHZhciBHbG9iYWxQcm9taXNlID0gX2dsb2JhbC5Qcm9taXNlO1xuICAgIHJldHVybiBwYXRjaEdsb2JhbFByb21pc2UgPyB7XG4gICAgICAgIFByb21pc2U6IEdsb2JhbFByb21pc2UsXG4gICAgICAgIFByb21pc2VQcm9wOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKF9nbG9iYWwsIFwiUHJvbWlzZVwiKSxcbiAgICAgICAgYWxsOiBHbG9iYWxQcm9taXNlLmFsbCxcbiAgICAgICAgcmFjZTogR2xvYmFsUHJvbWlzZS5yYWNlLFxuICAgICAgICBhbGxTZXR0bGVkOiBHbG9iYWxQcm9taXNlLmFsbFNldHRsZWQsXG4gICAgICAgIGFueTogR2xvYmFsUHJvbWlzZS5hbnksXG4gICAgICAgIHJlc29sdmU6IEdsb2JhbFByb21pc2UucmVzb2x2ZSxcbiAgICAgICAgcmVqZWN0OiBHbG9iYWxQcm9taXNlLnJlamVjdCxcbiAgICAgICAgbnRoZW46IG5hdGl2ZVByb21pc2VQcm90by50aGVuLFxuICAgICAgICBndGhlbjogR2xvYmFsUHJvbWlzZS5wcm90b3R5cGUudGhlblxuICAgIH0gOiB7fTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZVBTRCAocHNkLCBmbiwgYTEsIGEyLCBhMykge1xuICAgIHZhciBvdXRlclNjb3BlID0gUFNEO1xuICAgIHRyeSB7XG4gICAgICAgIHN3aXRjaFRvWm9uZShwc2QsIHRydWUpO1xuICAgICAgICByZXR1cm4gZm4oYTEsIGEyLCBhMyk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgICAgc3dpdGNoVG9ab25lKG91dGVyU2NvcGUsIGZhbHNlKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGVucXVldWVOYXRpdmVNaWNyb1Rhc2sgKGpvYikge1xuICAgIC8vXG4gICAgLy8gUHJlY29uZGl0aW9uOiBuYXRpdmVQcm9taXNlVGhlbiAhPT0gdW5kZWZpbmVkXG4gICAgLy9cbiAgICBuYXRpdmVQcm9taXNlVGhlbi5jYWxsKHJlc29sdmVkTmF0aXZlUHJvbWlzZSwgam9iKTtcbn1cblxuZnVuY3Rpb24gbmF0aXZlQXdhaXRDb21wYXRpYmxlV3JhcChmbiwgem9uZSwgcG9zc2libGVBd2FpdCwgY2xlYW51cCkge1xuICAgIHJldHVybiB0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicgPyBmbiA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG91dGVyWm9uZSA9IFBTRDtcbiAgICAgICAgaWYgKHBvc3NpYmxlQXdhaXQpIGluY3JlbWVudEV4cGVjdGVkQXdhaXRzKCk7XG4gICAgICAgIHN3aXRjaFRvWm9uZSh6b25lLCB0cnVlKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgc3dpdGNoVG9ab25lKG91dGVyWm9uZSwgZmFsc2UpO1xuICAgICAgICAgICAgaWYgKGNsZWFudXApIGVucXVldWVOYXRpdmVNaWNyb1Rhc2soZGVjcmVtZW50RXhwZWN0ZWRBd2FpdHMpO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0UGF0Y2hlZFByb21pc2VUaGVuIChvcmlnVGhlbiwgem9uZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAob25SZXNvbHZlZCwgb25SZWplY3RlZCkge1xuICAgICAgICByZXR1cm4gb3JpZ1RoZW4uY2FsbCh0aGlzLFxuICAgICAgICAgICAgbmF0aXZlQXdhaXRDb21wYXRpYmxlV3JhcChvblJlc29sdmVkLCB6b25lKSxcbiAgICAgICAgICAgIG5hdGl2ZUF3YWl0Q29tcGF0aWJsZVdyYXAob25SZWplY3RlZCwgem9uZSkpO1xuICAgIH07XG59XG5cbmNvbnN0IFVOSEFORExFRFJFSkVDVElPTiA9IFwidW5oYW5kbGVkcmVqZWN0aW9uXCI7XG5cbmZ1bmN0aW9uIGdsb2JhbEVycm9yKGVyciwgcHJvbWlzZSkge1xuICAgIHZhciBydjtcbiAgICB0cnkge1xuICAgICAgICBydiA9IHByb21pc2Uub251bmNhdGNoZWQoZXJyKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIGlmIChydiAhPT0gZmFsc2UpIHRyeSB7XG4gICAgICAgIHZhciBldmVudCwgZXZlbnREYXRhID0ge3Byb21pc2U6IHByb21pc2UsIHJlYXNvbjogZXJyfTtcbiAgICAgICAgaWYgKF9nbG9iYWwuZG9jdW1lbnQgJiYgZG9jdW1lbnQuY3JlYXRlRXZlbnQpIHtcbiAgICAgICAgICAgIGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XG4gICAgICAgICAgICBldmVudC5pbml0RXZlbnQoVU5IQU5ETEVEUkVKRUNUSU9OLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgICAgIGV4dGVuZChldmVudCwgZXZlbnREYXRhKTtcbiAgICAgICAgfSBlbHNlIGlmIChfZ2xvYmFsLkN1c3RvbUV2ZW50KSB7XG4gICAgICAgICAgICBldmVudCA9IG5ldyBDdXN0b21FdmVudChVTkhBTkRMRURSRUpFQ1RJT04sIHtkZXRhaWw6IGV2ZW50RGF0YX0pO1xuICAgICAgICAgICAgZXh0ZW5kKGV2ZW50LCBldmVudERhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChldmVudCAmJiBfZ2xvYmFsLmRpc3BhdGNoRXZlbnQpIHtcbiAgICAgICAgICAgIGRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgICAgICAgICAgaWYgKCFfZ2xvYmFsLlByb21pc2VSZWplY3Rpb25FdmVudCAmJiBfZ2xvYmFsLm9udW5oYW5kbGVkcmVqZWN0aW9uKVxuICAgICAgICAgICAgICAgIC8vIE5vIG5hdGl2ZSBzdXBwb3J0IGZvciBQcm9taXNlUmVqZWN0aW9uRXZlbnQgYnV0IHVzZXIgaGFzIHNldCB3aW5kb3cub251bmhhbmRsZWRyZWplY3Rpb24uIE1hbnVhbGx5IGNhbGwgaXQuXG4gICAgICAgICAgICAgICAgdHJ5IHtfZ2xvYmFsLm9udW5oYW5kbGVkcmVqZWN0aW9uKGV2ZW50KTt9IGNhdGNoIChfKSB7fVxuICAgICAgICB9XG4gICAgICAgIGlmIChkZWJ1ZyAmJiBldmVudCAmJiAhZXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGBVbmhhbmRsZWQgcmVqZWN0aW9uOiAke2Vyci5zdGFjayB8fCBlcnJ9YCk7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7fVxufVxuXG5leHBvcnQgdmFyIHJlamVjdGlvbiA9IERleGllUHJvbWlzZS5yZWplY3Q7XG5cbmV4cG9ydCB7RGV4aWVQcm9taXNlfTtcbiIsICJpbXBvcnQgeyBQU0QsIHJlamVjdGlvbiwgbmV3U2NvcGUgfSBmcm9tIFwiLi4vaGVscGVycy9wcm9taXNlXCI7XG5pbXBvcnQgeyBEZXhpZU9wdGlvbnMgfSBmcm9tIFwiLi4vcHVibGljL3R5cGVzL2RleGllLWNvbnN0cnVjdG9yXCI7XG5pbXBvcnQgeyBlcnJuYW1lcywgZXhjZXB0aW9ucyB9IGZyb20gXCIuLi9lcnJvcnNcIjtcbmltcG9ydCB7IG5vcCB9IGZyb20gXCIuL2NoYWluaW5nLWZ1bmN0aW9uc1wiO1xuaW1wb3J0IHsgVHJhbnNhY3Rpb24gfSBmcm9tIFwiLi4vY2xhc3Nlcy90cmFuc2FjdGlvblwiO1xuaW1wb3J0IHsgRGV4aWUgfSBmcm9tICcuLi9jbGFzc2VzL2RleGllJztcblxuLyogR2VuZXJhdGUgYSB0ZW1wb3JhcnkgdHJhbnNhY3Rpb24gd2hlbiBkYiBvcGVyYXRpb25zIGFyZSBkb25lIG91dHNpZGUgYSB0cmFuc2FjdGlvbiBzY29wZS5cbiovXG5leHBvcnQgZnVuY3Rpb24gdGVtcFRyYW5zYWN0aW9uIChcbiAgZGI6IERleGllLFxuICBtb2RlOiBJREJUcmFuc2FjdGlvbk1vZGUsXG4gIHN0b3JlTmFtZXM6IHN0cmluZ1tdLFxuICBmbjogKHJlc29sdmUsIHJlamVjdCwgdHJhbnM6IFRyYW5zYWN0aW9uKSA9PiBhbnkpXG4gIC8vIExhc3QgYXJndW1lbnQgaXMgXCJ3cml0ZUxvY2tlZFwiLiBCdXQgdGhpcyBkb2VzbnQgYXBwbHkgdG8gb25lc2hvdCBkaXJlY3QgZGIgb3BlcmF0aW9ucywgc28gd2UgaWdub3JlIGl0Llxue1xuICBpZiAoIWRiLmlkYmRiIHx8ICghZGIuX3N0YXRlLm9wZW5Db21wbGV0ZSAmJiAoIVBTRC5sZXRUaHJvdWdoICYmICFkYi5fdmlwKSkpIHtcbiAgICBpZiAoZGIuX3N0YXRlLm9wZW5Db21wbGV0ZSkge1xuICAgICAgLy8gZGIuaWRiZGIgaXMgZmFsc3kgYnV0IG9wZW5Db21wbGV0ZSBpcyB0cnVlLiBNdXN0IGhhdmUgYmVlbiBhbiBleGNlcHRpb24gZHVyaW4gb3Blbi5cbiAgICAgIC8vIERvbid0IHdhaXQgZm9yIG9wZW5Db21wbGV0ZSBhcyBpdCB3b3VsZCBsZWFkIHRvIGluZmluaXRlIGxvb3AuXG4gICAgICByZXR1cm4gcmVqZWN0aW9uKG5ldyBleGNlcHRpb25zLkRhdGFiYXNlQ2xvc2VkKGRiLl9zdGF0ZS5kYk9wZW5FcnJvcikpO1xuICAgIH1cbiAgICBpZiAoIWRiLl9zdGF0ZS5pc0JlaW5nT3BlbmVkKSB7XG4gICAgICBpZiAoIWRiLl9vcHRpb25zLmF1dG9PcGVuKVxuICAgICAgICByZXR1cm4gcmVqZWN0aW9uKG5ldyBleGNlcHRpb25zLkRhdGFiYXNlQ2xvc2VkKCkpO1xuICAgICAgZGIub3BlbigpLmNhdGNoKG5vcCk7IC8vIE9wZW4gaW4gYmFja2dyb3VuZC4gSWYgaWYgZmFpbHMsIGl0IHdpbGwgYmUgY2F0Y2hlZCBieSB0aGUgZmluYWwgcHJvbWlzZSBhbnl3YXkuXG4gICAgfVxuICAgIHJldHVybiBkYi5fc3RhdGUuZGJSZWFkeVByb21pc2UudGhlbigoKSA9PiB0ZW1wVHJhbnNhY3Rpb24oZGIsIG1vZGUsIHN0b3JlTmFtZXMsIGZuKSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHRyYW5zID0gZGIuX2NyZWF0ZVRyYW5zYWN0aW9uKG1vZGUsIHN0b3JlTmFtZXMsIGRiLl9kYlNjaGVtYSk7XG4gICAgdHJ5IHtcbiAgICAgIHRyYW5zLmNyZWF0ZSgpO1xuICAgICAgZGIuX3N0YXRlLlBSMTM5OF9tYXhMb29wID0gMztcbiAgICB9IGNhdGNoIChleCkge1xuICAgICAgaWYgKGV4Lm5hbWUgPT09IGVycm5hbWVzLkludmFsaWRTdGF0ZSAmJiBkYi5pc09wZW4oKSAmJiAtLWRiLl9zdGF0ZS5QUjEzOThfbWF4TG9vcCA+IDApIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdEZXhpZTogTmVlZCB0byByZW9wZW4gZGInKTtcbiAgICAgICAgZGIuX2Nsb3NlKCk7XG4gICAgICAgIHJldHVybiBkYi5vcGVuKCkudGhlbigoKT0+dGVtcFRyYW5zYWN0aW9uKGRiLCBtb2RlLCBzdG9yZU5hbWVzLCBmbikpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlamVjdGlvbihleCk7XG4gICAgfVxuICAgIHJldHVybiB0cmFucy5fcHJvbWlzZShtb2RlLCAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICByZXR1cm4gbmV3U2NvcGUoKCkgPT4geyAvLyBPUFRJTUlaQVRJT04gUE9TU0lCTEU/IG5ld1Njb3BlKCkgbm90IG5lZWRlZCBiZWNhdXNlIGl0J3MgYWxyZWFkeSBkb25lIGluIF9wcm9taXNlLlxuICAgICAgICBQU0QudHJhbnMgPSB0cmFucztcbiAgICAgICAgcmV0dXJuIGZuKHJlc29sdmUsIHJlamVjdCwgdHJhbnMpO1xuICAgICAgfSk7XG4gICAgfSkudGhlbihyZXN1bHQgPT4ge1xuICAgICAgLy8gSW5zdGVhZCBvZiByZXNvbHZpbmcgdmFsdWUgZGlyZWN0bHksIHdhaXQgd2l0aCByZXNvbHZpbmcgaXQgdW50aWwgdHJhbnNhY3Rpb24gaGFzIGNvbXBsZXRlZC5cbiAgICAgIC8vIE90aGVyd2lzZSB0aGUgZGF0YSB3b3VsZCBub3QgYmUgaW4gdGhlIERCIGlmIHJlcXVlc3RpbmcgaXQgaW4gdGhlIHRoZW4oKSBvcGVyYXRpb24uXG4gICAgICAvLyBTcGVjaWZpY2FsbHksIHRvIGVuc3VyZSB0aGF0IHRoZSBmb2xsb3dpbmcgZXhwcmVzc2lvbiB3aWxsIHdvcms6XG4gICAgICAvL1xuICAgICAgLy8gICBkYi5mcmllbmRzLnB1dCh7bmFtZTogXCJBcm5lXCJ9KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vICAgICAgIGRiLmZyaWVuZHMud2hlcmUoXCJuYW1lXCIpLmVxdWFscyhcIkFybmVcIikuY291bnQoZnVuY3Rpb24oY291bnQpIHtcbiAgICAgIC8vICAgICAgICAgICBhc3NlcnQgKGNvdW50ID09PSAxKTtcbiAgICAgIC8vICAgICAgIH0pO1xuICAgICAgLy8gICB9KTtcbiAgICAgIC8vXG4gICAgICByZXR1cm4gdHJhbnMuX2NvbXBsZXRpb24udGhlbigoKSA9PiByZXN1bHQpO1xuICAgIH0pOy8qLmNhdGNoKGVyciA9PiB7IC8vIERvbid0IGRvIHRoaXMgYXMgb2Ygbm93LiBJZiB3b3VsZCBhZmZlY3QgYnVsay0gYW5kIG1vZGlmeSBtZXRob2RzIGluIGEgd2F5IHRoYXQgY291bGQgYmUgbW9yZSBpbnR1aXRpdmUuIEJ1dCB3YWl0ISBNYXliZSBjaGFuZ2UgaW4gbmV4dCBtYWpvci5cbiAgICAgICAgICB0cmFucy5fcmVqZWN0KGVycik7XG4gICAgICAgICAgcmV0dXJuIHJlamVjdGlvbihlcnIpO1xuICAgICAgfSk7Ki9cbiAgfVxufVxuIiwgImltcG9ydCB7IERleGllIH0gZnJvbSBcIi4uL2NsYXNzZXMvZGV4aWVcIjtcblxuZXhwb3J0IGNvbnN0IERFWElFX1ZFUlNJT04gPSAne3ZlcnNpb259JzsgLy8gUmVwbGFjZWQgYnkgYnVpbGQtc2NyaXB0LlxuZXhwb3J0IGNvbnN0IG1heFN0cmluZyA9IFN0cmluZy5mcm9tQ2hhckNvZGUoNjU1MzUpO1xuZXhwb3J0IGNvbnN0IG1pbktleSA9IC1JbmZpbml0eTsgLy8gbWluS2V5IGNhbiBiZSBjb25zdGFudC4gbWF4S2V5IG11c3QgYmUgYSBwcm9wIG9mIERleGllIChfbWF4S2V5KVxuZXhwb3J0IGNvbnN0IElOVkFMSURfS0VZX0FSR1VNRU5UID1cbiAgXCJJbnZhbGlkIGtleSBwcm92aWRlZC4gS2V5cyBtdXN0IGJlIG9mIHR5cGUgc3RyaW5nLCBudW1iZXIsIERhdGUgb3IgQXJyYXk8c3RyaW5nIHwgbnVtYmVyIHwgRGF0ZT4uXCI7XG5leHBvcnQgY29uc3QgU1RSSU5HX0VYUEVDVEVEID0gXCJTdHJpbmcgZXhwZWN0ZWQuXCI7XG5leHBvcnQgY29uc3QgY29ubmVjdGlvbnM6IERleGllW10gPSBbXTtcbmV4cG9ydCBjb25zdCBpc0lFT3JFZGdlID1cbiAgdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgLyhNU0lFfFRyaWRlbnR8RWRnZSkvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5leHBvcnQgY29uc3QgaGFzSUVEZWxldGVPYmplY3RTdG9yZUJ1ZyA9IGlzSUVPckVkZ2U7XG5leHBvcnQgY29uc3QgaGFuZ3NPbkRlbGV0ZUxhcmdlS2V5UmFuZ2UgPSBpc0lFT3JFZGdlO1xuZXhwb3J0IGNvbnN0IGRleGllU3RhY2tGcmFtZUZpbHRlciA9IGZyYW1lID0+ICEvKGRleGllXFwuanN8ZGV4aWVcXC5taW5cXC5qcykvLnRlc3QoZnJhbWUpO1xuZXhwb3J0IGNvbnN0IERCTkFNRVNfREIgPSAnX19kYm5hbWVzJztcbmV4cG9ydCBjb25zdCBSRUFET05MWSA9ICdyZWFkb25seSc7XG5leHBvcnQgY29uc3QgUkVBRFdSSVRFID0gJ3JlYWR3cml0ZSc7XG4iLCAiZXhwb3J0IGZ1bmN0aW9uIGNvbWJpbmUoZmlsdGVyMSwgZmlsdGVyMikge1xuICByZXR1cm4gZmlsdGVyMSA/XG4gICAgICBmaWx0ZXIyID9cbiAgICAgICAgICBmdW5jdGlvbiAoKSB7IHJldHVybiBmaWx0ZXIxLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgJiYgZmlsdGVyMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IDpcbiAgICAgICAgICBmaWx0ZXIxIDpcbiAgICAgIGZpbHRlcjI7XG59XG4iLCAiaW1wb3J0IHsgREJDb3JlS2V5UmFuZ2UsIERCQ29yZVJhbmdlVHlwZSB9IGZyb20gJy4uL3B1YmxpYy90eXBlcy9kYmNvcmUnO1xuXG5leHBvcnQgY29uc3QgQW55UmFuZ2U6IERCQ29yZUtleVJhbmdlID0ge1xuICB0eXBlOiBEQkNvcmVSYW5nZVR5cGUuQW55LFxuICBsb3dlcjogLUluZmluaXR5LFxuICBsb3dlck9wZW46IGZhbHNlLFxuICB1cHBlcjogW1tdXSxcbiAgdXBwZXJPcGVuOiBmYWxzZVxufVxuXG5leHBvcnQgY29uc3QgTmV2ZXJSYW5nZTogREJDb3JlS2V5UmFuZ2UgPSB7XG4gIHR5cGU6IERCQ29yZVJhbmdlVHlwZS5OZXZlcixcbiAgbG93ZXI6IC1JbmZpbml0eSxcbiAgbG93ZXJPcGVuOiB0cnVlLFxuICB1cHBlcjogLUluZmluaXR5LFxuICB1cHBlck9wZW46IHRydWVcbn1cbiIsICJpbXBvcnQgeyBkZWVwQ2xvbmUsIGRlbEJ5S2V5UGF0aCwgZ2V0QnlLZXlQYXRoIH0gZnJvbSAnLi91dGlscyc7XG5cbi8vIFRoaXMgd29ya2Fyb3VuZCBpcyBuZWVkZWQgc2luY2Ugb2JqIGNvdWxkIGJlIGEgY3VzdG9tLWNsYXNzIGluc3RhbmNlIHdpdGggYW5cbi8vIHVuaW5pdGlhbGl6ZWQga2V5UGF0aC4gU2VlIHRoZSBmb2xsb3dpbmcgY29tbWVudCBmb3IgbW9yZSBjb250ZXh0OlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2RmYWhsYW5kZXIvRGV4aWUuanMvaXNzdWVzLzEyODAjaXNzdWVjb21tZW50LTgyMzU1Nzg4MVxuZXhwb3J0IGZ1bmN0aW9uIHdvcmthcm91bmRGb3JVbmRlZmluZWRQcmltS2V5KGtleVBhdGg6IHN0cmluZyB8IEFycmF5TGlrZTxzdHJpbmc+KSB7XG4gIC8vIFdvcmthcm91bmQgb25seSBuZWVkZWQgZm9yIHBsYWluIG5vbi1kb3R0ZWQga2V5UGF0aHNcbiAgcmV0dXJuIHR5cGVvZiBrZXlQYXRoID09PSBcInN0cmluZ1wiICYmICEvXFwuLy50ZXN0KGtleVBhdGgpIFxuICA/IChvYmo6IG9iamVjdCkgPT4ge1xuICAgIGlmIChvYmpba2V5UGF0aF0gPT09IHVuZGVmaW5lZCAmJiAoa2V5UGF0aCBpbiBvYmopKSB7XG4gICAgICAvLyBwcm9wZXJ0eSBleGlzdHMgYnV0IGlzIHVuZGVmaW5lZC4gVGhpcyB3aWxsIG5vdCBiZSBsaWtlZCBieSBJbmRleGVkZGIuXG4gICAgICAvLyBOZWVkIHRvIHJlbW92ZSB0aGUgcHJvcGVydHkgYmVmb3JlIGFkZGluZyBpdCBidXQgd2UgbmVlZCB0byBjbG9uZSBpdCBiZWZvcmVcbiAgICAgIC8vIGRvaW5nIHRoYXQgdG8gbm90IGJlIGludHJ1c2l2ZS5cbiAgICAgIG9iaiA9IGRlZXBDbG9uZShvYmopO1xuICAgICAgZGVsZXRlIG9ialtrZXlQYXRoXTtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuICA6IChvYmo6IG9iamVjdCkgPT4gb2JqO1xufSIsICJpbXBvcnQgeyBCdWxrRXJyb3IsIGV4Y2VwdGlvbnMgfSBmcm9tICcuLi8uLi9lcnJvcnMnO1xuaW1wb3J0IHsgVGFibGUgYXMgSVRhYmxlIH0gZnJvbSAnLi4vLi4vcHVibGljL3R5cGVzL3RhYmxlJztcbmltcG9ydCB7IFRhYmxlU2NoZW1hIH0gZnJvbSAnLi4vLi4vcHVibGljL3R5cGVzL3RhYmxlLXNjaGVtYSc7XG5pbXBvcnQgeyBUYWJsZUhvb2tzIH0gZnJvbSAnLi4vLi4vcHVibGljL3R5cGVzL3RhYmxlLWhvb2tzJztcbmltcG9ydCB7IERleGllUHJvbWlzZSBhcyBQcm9taXNlLCBQU0QsIG5ld1Njb3BlLCB3cmFwLCByZWplY3Rpb24sIGJlZ2luTWljcm9UaWNrU2NvcGUsIGVuZE1pY3JvVGlja1Njb3BlIH0gZnJvbSAnLi4vLi4vaGVscGVycy9wcm9taXNlJztcbmltcG9ydCB7IFRyYW5zYWN0aW9uIH0gZnJvbSAnLi4vdHJhbnNhY3Rpb24nO1xuaW1wb3J0IHsgRGV4aWUgfSBmcm9tICcuLi9kZXhpZSc7XG5pbXBvcnQgeyB0ZW1wVHJhbnNhY3Rpb24gfSBmcm9tICcuLi8uLi9mdW5jdGlvbnMvdGVtcC10cmFuc2FjdGlvbic7XG5pbXBvcnQgeyBDb2xsZWN0aW9uIH0gZnJvbSAnLi4vY29sbGVjdGlvbic7XG5pbXBvcnQgeyBpc0FycmF5LCBrZXlzLCBnZXRCeUtleVBhdGgsIGhhc093biwgc2V0QnlLZXlQYXRoLCBkZWVwQ2xvbmUsIHRyeUNhdGNoLCBhcnJheVRvT2JqZWN0LCBleHRlbmQgfSBmcm9tICcuLi8uLi9mdW5jdGlvbnMvdXRpbHMnO1xuaW1wb3J0IHsgbWF4U3RyaW5nIH0gZnJvbSAnLi4vLi4vZ2xvYmFscy9jb25zdGFudHMnO1xuaW1wb3J0IHsgY29tYmluZSB9IGZyb20gJy4uLy4uL2Z1bmN0aW9ucy9jb21iaW5lJztcbmltcG9ydCB7IFByb21pc2VFeHRlbmRlZCB9IGZyb20gXCIuLi8uLi9wdWJsaWMvdHlwZXMvcHJvbWlzZS1leHRlbmRlZFwiO1xuaW1wb3J0IHsgSW5kZXhhYmxlVHlwZSB9IGZyb20gJy4uLy4uL3B1YmxpYy90eXBlcy9pbmRleGFibGUtdHlwZSc7XG5pbXBvcnQgeyBkZWJ1ZyB9IGZyb20gJy4uLy4uL2hlbHBlcnMvZGVidWcnO1xuaW1wb3J0IHsgREJDb3JlVGFibGUgfSBmcm9tICcuLi8uLi9wdWJsaWMvdHlwZXMvZGJjb3JlJztcbmltcG9ydCB7IEFueVJhbmdlIH0gZnJvbSAnLi4vLi4vZGJjb3JlL2tleXJhbmdlJztcbmltcG9ydCB7IHdvcmthcm91bmRGb3JVbmRlZmluZWRQcmltS2V5IH0gZnJvbSAnLi4vLi4vZnVuY3Rpb25zL3dvcmthcm91bmQtdW5kZWZpbmVkLXByaW1rZXknO1xuXG4vKiogY2xhc3MgVGFibGVcbiAqIFxuICogaHR0cHM6Ly9kZXhpZS5vcmcvZG9jcy9UYWJsZS9UYWJsZVxuICovXG5leHBvcnQgY2xhc3MgVGFibGUgaW1wbGVtZW50cyBJVGFibGU8YW55LCBJbmRleGFibGVUeXBlPiB7XG4gIGRiOiBEZXhpZTtcbiAgX3R4PzogVHJhbnNhY3Rpb247XG4gIG5hbWU6IHN0cmluZztcbiAgc2NoZW1hOiBUYWJsZVNjaGVtYTtcbiAgaG9vazogVGFibGVIb29rcztcbiAgY29yZTogREJDb3JlVGFibGU7XG5cbiAgX3RyYW5zKFxuICAgIG1vZGU6IElEQlRyYW5zYWN0aW9uTW9kZSxcbiAgICBmbjogKGlkYnRyYW5zOiBJREJUcmFuc2FjdGlvbiwgZHhUcmFuczogVHJhbnNhY3Rpb24pID0+IFByb21pc2VMaWtlPGFueT4gfCB2b2lkLFxuICAgIHdyaXRlTG9ja2VkPzogYm9vbGVhbiB8IHN0cmluZykgOiBQcm9taXNlRXh0ZW5kZWQ8YW55PlxuICB7XG4gICAgY29uc3QgdHJhbnM6IFRyYW5zYWN0aW9uID0gdGhpcy5fdHggfHwgUFNELnRyYW5zO1xuICAgIGNvbnN0IHRhYmxlTmFtZSA9IHRoaXMubmFtZTtcbiAgICBcbiAgICBmdW5jdGlvbiBjaGVja1RhYmxlSW5UcmFuc2FjdGlvbihyZXNvbHZlLCByZWplY3QsIHRyYW5zOiBUcmFuc2FjdGlvbikge1xuICAgICAgaWYgKCF0cmFucy5zY2hlbWFbdGFibGVOYW1lXSlcbiAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuTm90Rm91bmQoXCJUYWJsZSBcIiArIHRhYmxlTmFtZSArIFwiIG5vdCBwYXJ0IG9mIHRyYW5zYWN0aW9uXCIpO1xuICAgICAgcmV0dXJuIGZuKHRyYW5zLmlkYnRyYW5zLCB0cmFucyk7XG4gICAgfVxuICAgIC8vIFN1cnJvdW5kIGFsbCBpbiBhIG1pY3JvdGljayBzY29wZS5cbiAgICAvLyBSZWFzb246IEJyb3dzZXJzIChtb2Rlcm4gU2FmYXJpICsgb2xkZXIgb3RoZXJzKVxuICAgIC8vIHN0aWxsIGFzIG9mIDIwMTgtMTAtMTAgaGFzIHByb2JsZW1zIGtlZXBpbmcgYSB0cmFuc2FjdGlvblxuICAgIC8vIGFsaXZlIGJldHdlZW4gbWljcm8gdGlja3MuIFNhZmFyaSBiZWNhdXNlIGlmIHRyYW5zYWN0aW9uXG4gICAgLy8gaXMgY3JlYXRlZCBidXQgbm90IHVzZWQgaW4gc2FtZSBtaWNyb3RpY2ssIGl0IHdpbGwgZ29cbiAgICAvLyBhd2F5LiBUaGF0IHNwZWNpZmljIGlzc3VlIGNvdWxkIGJlIHNvbHZlZCBpbiBEQkNvcmVcbiAgICAvLyBieSBvcGVuaW5nIHRoZSB0cmFuc2FjdGlvbiBqdXN0IGJlZm9yZSB1c2luZyBpdCBpbnN0ZWFkLlxuICAgIC8vIEJ1dCBvbGRlciBGaXJlZm94ZXMgYW5kIElFMTEgKHdpdGggUHJvbWlzZSBwb2x5ZmlsbHMpXG4gICAgLy8gd2lsbCBzdGlsbCBoYXZlIHByb2JzLlxuICAgIC8vIFRoZSBiZWdpbk1pY3JvdGlja1Njb3BlKCkvZW5kTWljcm90aWNrU2NvcGUoKSB3b3Jrc1xuICAgIC8vIGluIGNvb3BlcmF0aW9uIHdpdGggRGV4aWUuUHJvbWlzZSB0byBvcmNoZXN0cmF0ZVxuICAgIC8vIHRoZSBtaWNyby10aWNrcyBpbiBlbmRNaWNyb3RpY2tTY29wZSgpIHJhdGhlciB0aGFuXG4gICAgLy8gaW4gbmF0aXZlIGVuZ2luZS5cbiAgICBjb25zdCB3YXNSb290RXhlYyA9IGJlZ2luTWljcm9UaWNrU2NvcGUoKTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHRyYW5zICYmIHRyYW5zLmRiID09PSB0aGlzLmRiID9cbiAgICAgICAgdHJhbnMgPT09IFBTRC50cmFucyA/XG4gICAgICAgICAgdHJhbnMuX3Byb21pc2UobW9kZSwgY2hlY2tUYWJsZUluVHJhbnNhY3Rpb24sIHdyaXRlTG9ja2VkKSA6XG4gICAgICAgICAgbmV3U2NvcGUoKCkgPT4gdHJhbnMuX3Byb21pc2UobW9kZSwgY2hlY2tUYWJsZUluVHJhbnNhY3Rpb24sIHdyaXRlTG9ja2VkKSwgeyB0cmFuczogdHJhbnMsIHRyYW5zbGVzczogUFNELnRyYW5zbGVzcyB8fCBQU0QgfSkgOlxuICAgICAgICB0ZW1wVHJhbnNhY3Rpb24odGhpcy5kYiwgbW9kZSwgW3RoaXMubmFtZV0sIGNoZWNrVGFibGVJblRyYW5zYWN0aW9uKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKHdhc1Jvb3RFeGVjKSBlbmRNaWNyb1RpY2tTY29wZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBUYWJsZS5nZXQoKVxuICAgKiBcbiAgICogaHR0cHM6Ly9kZXhpZS5vcmcvZG9jcy9UYWJsZS9UYWJsZS5nZXQoKVxuICAgKiBcbiAgICoqL1xuICBnZXQoa2V5T3JDcml0LCBjYj8pIHtcbiAgICBpZiAoa2V5T3JDcml0ICYmIGtleU9yQ3JpdC5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KVxuICAgICAgcmV0dXJuIHRoaXMud2hlcmUoa2V5T3JDcml0IGFzIHsgW2tleTogc3RyaW5nXTogSW5kZXhhYmxlVHlwZSB9KS5maXJzdChjYik7XG5cbiAgICByZXR1cm4gdGhpcy5fdHJhbnMoJ3JlYWRvbmx5JywgKHRyYW5zKSA9PiB7XG4gICAgICByZXR1cm4gdGhpcy5jb3JlLmdldCh7dHJhbnMsIGtleToga2V5T3JDcml0fSlcbiAgICAgICAgLnRoZW4ocmVzID0+IHRoaXMuaG9vay5yZWFkaW5nLmZpcmUocmVzKSk7XG4gICAgfSkudGhlbihjYik7XG4gIH1cblxuICAvKiogVGFibGUud2hlcmUoKVxuICAgKiBcbiAgICogaHR0cHM6Ly9kZXhpZS5vcmcvZG9jcy9UYWJsZS9UYWJsZS53aGVyZSgpXG4gICAqIFxuICAgKiovXG4gIHdoZXJlKGluZGV4T3JDcml0OiBzdHJpbmcgfCBzdHJpbmdbXSB8IHsgW2tleTogc3RyaW5nXTogSW5kZXhhYmxlVHlwZSB9KSB7XG4gICAgaWYgKHR5cGVvZiBpbmRleE9yQ3JpdCA9PT0gJ3N0cmluZycpXG4gICAgICByZXR1cm4gbmV3IHRoaXMuZGIuV2hlcmVDbGF1c2UodGhpcywgaW5kZXhPckNyaXQpO1xuICAgIGlmIChpc0FycmF5KGluZGV4T3JDcml0KSlcbiAgICAgIHJldHVybiBuZXcgdGhpcy5kYi5XaGVyZUNsYXVzZSh0aGlzLCBgWyR7aW5kZXhPckNyaXQuam9pbignKycpfV1gKTtcbiAgICAvLyBpbmRleE9yQ3JpdCBpcyBhbiBvYmplY3QgbWFwIG9mIHtba2V5UGF0aF06dmFsdWV9IFxuICAgIGNvbnN0IGtleVBhdGhzID0ga2V5cyhpbmRleE9yQ3JpdCk7XG4gICAgaWYgKGtleVBhdGhzLmxlbmd0aCA9PT0gMSlcbiAgICAgIC8vIE9ubHkgb25lIGNyaXRlcmEuIFRoaXMgd2FzIHRoZSBlYXN5IGNhc2U6XG4gICAgICByZXR1cm4gdGhpc1xuICAgICAgICAud2hlcmUoa2V5UGF0aHNbMF0pXG4gICAgICAgIC5lcXVhbHMoaW5kZXhPckNyaXRba2V5UGF0aHNbMF1dKTtcblxuICAgIC8vIE11bHRpcGxlIGNyaXRlcmlhcy5cbiAgICAvLyBMZXQncyB0cnkgZmluZGluZyBhIGNvbXBvdW5kIGluZGV4IHRoYXQgbWF0Y2hlcyBhbGwga2V5UGF0aHMgaW5cbiAgICAvLyBhcmJyaXRhcnkgb3JkZXI6XG4gICAgY29uc3QgY29tcG91bmRJbmRleCA9IHRoaXMuc2NoZW1hLmluZGV4ZXMuY29uY2F0KHRoaXMuc2NoZW1hLnByaW1LZXkpLmZpbHRlcihpeCA9PiB7XG4gICAgICBpZiAoXG4gICAgICAgIGl4LmNvbXBvdW5kICYmXG4gICAgICAgIGtleVBhdGhzLmV2ZXJ5KGtleVBhdGggPT4gaXgua2V5UGF0aC5pbmRleE9mKGtleVBhdGgpID49IDApKSB7XG4gICAgICAgICAgZm9yIChsZXQgaT0wOyBpPGtleVBhdGhzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAoa2V5UGF0aHMuaW5kZXhPZihpeC5rZXlQYXRoW2ldKSA9PT0gLTEpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSkuc29ydCgoYSxiKSA9PiBhLmtleVBhdGgubGVuZ3RoIC0gYi5rZXlQYXRoLmxlbmd0aClbMF07XG4gICAgICAgICAgICBcbiAgICBpZiAoY29tcG91bmRJbmRleCAmJiB0aGlzLmRiLl9tYXhLZXkgIT09IG1heFN0cmluZykge1xuICAgICAgLy8gQ29vbCEgV2UgZm91bmQgc3VjaCBjb21wb3VuZCBpbmRleFxuICAgICAgLy8gYW5kIHRoaXMgYnJvd3NlciBzdXBwb3J0cyBjb21wb3VuZCBpbmRleGVzIChtYXhLZXkgIT09IG1heFN0cmluZykhXG4gICAgICBjb25zdCBrZXlQYXRoc0luVmFsaWRPcmRlciA9IChjb21wb3VuZEluZGV4LmtleVBhdGggYXMgc3RyaW5nW10pLnNsaWNlKDAsIGtleVBhdGhzLmxlbmd0aCk7XG4gICAgICByZXR1cm4gdGhpc1xuICAgICAgICAud2hlcmUoa2V5UGF0aHNJblZhbGlkT3JkZXIpXG4gICAgICAgIC5lcXVhbHMoa2V5UGF0aHNJblZhbGlkT3JkZXIubWFwKGtwID0+IGluZGV4T3JDcml0W2twXSkpO1xuICAgIH1cblxuICAgIGlmICghY29tcG91bmRJbmRleCAmJiBkZWJ1ZykgY29uc29sZS53YXJuKFxuICAgICAgYFRoZSBxdWVyeSAke0pTT04uc3RyaW5naWZ5KGluZGV4T3JDcml0KX0gb24gJHt0aGlzLm5hbWV9IHdvdWxkIGJlbmVmaXQgb2YgYSBgICtcbiAgICAgIGBjb21wb3VuZCBpbmRleCBbJHtrZXlQYXRocy5qb2luKCcrJyl9XWApO1xuXG4gICAgLy8gT2ssIG5vdyBsZXQncyBmYWxsYmFjayB0byBmaW5kaW5nIGF0IGxlYXN0IG9uZSBtYXRjaGluZyBpbmRleFxuICAgIC8vIGFuZCBmaWx0ZXIgdGhlIHJlc3QuXG4gICAgY29uc3QgeyBpZHhCeU5hbWUgfSA9IHRoaXMuc2NoZW1hO1xuICAgIGNvbnN0IGlkYiA9IHRoaXMuZGIuX2RlcHMuaW5kZXhlZERCO1xuXG4gICAgZnVuY3Rpb24gZXF1YWxzIChhLCBiKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gaWRiLmNtcChhLGIpID09PSAwOyAvLyBXb3JrcyB3aXRoIGFsbCBpbmRleGFibGUgdHlwZXMgaW5jbHVkaW5nIGJpbmFyeSBrZXlzLlxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgW2lkeCwgZmlsdGVyRnVuY3Rpb25dID0ga2V5UGF0aHMucmVkdWNlKChbcHJldkluZGV4LCBwcmV2RmlsdGVyRm5dLCBrZXlQYXRoKSA9PiB7XG4gICAgICBjb25zdCBpbmRleCA9IGlkeEJ5TmFtZVtrZXlQYXRoXTtcbiAgICAgIGNvbnN0IHZhbHVlID0gaW5kZXhPckNyaXRba2V5UGF0aF07XG4gICAgICByZXR1cm4gW1xuICAgICAgICBwcmV2SW5kZXggfHwgaW5kZXgsIC8vIGlkeDo6PVBpY2sgaW5kZXggb2YgZmlyc3QgbWF0Y2hpbmcga2V5cGF0aFxuICAgICAgICBwcmV2SW5kZXggfHwgIWluZGV4ID8gLy8gZmlsdGVyOjo9bnVsbCBpZiBub3QgbmVlZGVkLCBvdGhlcndpc2UgY29tYmluZSBmdW5jdGlvbiBmaWx0ZXJcbiAgICAgICAgICBjb21iaW5lKFxuICAgICAgICAgICAgcHJldkZpbHRlckZuLFxuICAgICAgICAgICAgaW5kZXggJiYgaW5kZXgubXVsdGkgP1xuICAgICAgICAgICAgICB4ID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9wID0gZ2V0QnlLZXlQYXRoKHgsIGtleVBhdGgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpc0FycmF5KHByb3ApICYmIHByb3Auc29tZShpdGVtID0+IGVxdWFscyh2YWx1ZSwgaXRlbSkpO1xuICAgICAgICAgICAgICB9IDogeCA9PiBlcXVhbHModmFsdWUsIGdldEJ5S2V5UGF0aCh4LCBrZXlQYXRoKSkpXG4gICAgICAgICAgOiBwcmV2RmlsdGVyRm5cbiAgICAgIF07XG4gICAgfSwgW251bGwsIG51bGxdKTtcblxuICAgIHJldHVybiBpZHggP1xuICAgICAgdGhpcy53aGVyZShpZHgubmFtZSkuZXF1YWxzKGluZGV4T3JDcml0W2lkeC5rZXlQYXRoXSlcbiAgICAgICAgLmZpbHRlcihmaWx0ZXJGdW5jdGlvbikgOlxuICAgICAgY29tcG91bmRJbmRleCA/XG4gICAgICAgIHRoaXMuZmlsdGVyKGZpbHRlckZ1bmN0aW9uKSA6IC8vIEhhcyBjb21wb3VuZCBidXQgYnJvd3NlciBiYWQuIEFsbG93IGZpbHRlci5cbiAgICAgICAgdGhpcy53aGVyZShrZXlQYXRocykuZXF1YWxzKCcnKTsgLy8gTm8gaW5kZXggYXQgYWxsLiBGYWlsIGxhemlseSB3aXRoIFwiW2ErYitjXSBpcyBub3QgaW5kZXhlZFwiXG4gIH1cblxuICAvKiogVGFibGUuZmlsdGVyKClcbiAgICogXG4gICAqIGh0dHBzOi8vZGV4aWUub3JnL2RvY3MvVGFibGUvVGFibGUuZmlsdGVyKClcbiAgICogXG4gICAqKi9cbiAgZmlsdGVyKGZpbHRlckZ1bmN0aW9uOiAob2JqOiBhbnkpID0+IGJvb2xlYW4pIHtcbiAgICByZXR1cm4gdGhpcy50b0NvbGxlY3Rpb24oKS5hbmQoZmlsdGVyRnVuY3Rpb24pO1xuICB9XG5cbiAgLyoqIFRhYmxlLmNvdW50KClcbiAgICogXG4gICAqIGh0dHBzOi8vZGV4aWUub3JnL2RvY3MvVGFibGUvVGFibGUuY291bnQoKVxuICAgKiBcbiAgICoqL1xuICBjb3VudCh0aGVuU2hvcnRjdXQ/OiBhbnkpIHtcbiAgICByZXR1cm4gdGhpcy50b0NvbGxlY3Rpb24oKS5jb3VudCh0aGVuU2hvcnRjdXQpO1xuICB9XG5cbiAgLyoqIFRhYmxlLm9mZnNldCgpXG4gICAqIFxuICAgKiBodHRwczovL2RleGllLm9yZy9kb2NzL1RhYmxlL1RhYmxlLm9mZnNldCgpXG4gICAqIFxuICAgKiovXG4gIG9mZnNldChvZmZzZXQ6IG51bWJlcikge1xuICAgIHJldHVybiB0aGlzLnRvQ29sbGVjdGlvbigpLm9mZnNldChvZmZzZXQpO1xuICB9XG5cbiAgLyoqIFRhYmxlLmxpbWl0KClcbiAgICogXG4gICAqIGh0dHBzOi8vZGV4aWUub3JnL2RvY3MvVGFibGUvVGFibGUubGltaXQoKVxuICAgKiBcbiAgICoqL1xuICBsaW1pdChudW1Sb3dzOiBudW1iZXIpIHtcbiAgICByZXR1cm4gdGhpcy50b0NvbGxlY3Rpb24oKS5saW1pdChudW1Sb3dzKTtcbiAgfVxuXG4gIC8qKiBUYWJsZS5lYWNoKClcbiAgICogXG4gICAqIGh0dHBzOi8vZGV4aWUub3JnL2RvY3MvVGFibGUvVGFibGUuZWFjaCgpXG4gICAqIFxuICAgKiovXG4gIGVhY2goY2FsbGJhY2s6IChvYmo6IGFueSwgY3Vyc29yOiB7IGtleTogSW5kZXhhYmxlVHlwZSwgcHJpbWFyeUtleTogSW5kZXhhYmxlVHlwZSB9KSA9PiBhbnkpIHtcbiAgICByZXR1cm4gdGhpcy50b0NvbGxlY3Rpb24oKS5lYWNoKGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKiBUYWJsZS50b0FycmF5KClcbiAgICogXG4gICAqIGh0dHBzOi8vZGV4aWUub3JnL2RvY3MvVGFibGUvVGFibGUudG9BcnJheSgpXG4gICAqIFxuICAgKiovXG4gIHRvQXJyYXkodGhlblNob3J0Y3V0PzogYW55KSB7XG4gICAgcmV0dXJuIHRoaXMudG9Db2xsZWN0aW9uKCkudG9BcnJheSh0aGVuU2hvcnRjdXQpO1xuICB9XG5cbiAgLyoqIFRhYmxlLnRvQ29sbGVjdGlvbigpXG4gICAqIFxuICAgKiBodHRwczovL2RleGllLm9yZy9kb2NzL1RhYmxlL1RhYmxlLnRvQ29sbGVjdGlvbigpXG4gICAqIFxuICAgKiovXG4gIHRvQ29sbGVjdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IHRoaXMuZGIuQ29sbGVjdGlvbihuZXcgdGhpcy5kYi5XaGVyZUNsYXVzZSh0aGlzKSk7XG4gIH1cblxuICAvKiogVGFibGUub3JkZXJCeSgpXG4gICAqIFxuICAgKiBodHRwczovL2RleGllLm9yZy9kb2NzL1RhYmxlL1RhYmxlLm9yZGVyQnkoKVxuICAgKiBcbiAgICoqL1xuICBvcmRlckJ5KGluZGV4OiBzdHJpbmcgfCBzdHJpbmdbXSkge1xuICAgIHJldHVybiBuZXcgdGhpcy5kYi5Db2xsZWN0aW9uKFxuICAgICAgbmV3IHRoaXMuZGIuV2hlcmVDbGF1c2UodGhpcywgaXNBcnJheShpbmRleCkgP1xuICAgICAgICBgWyR7aW5kZXguam9pbignKycpfV1gIDpcbiAgICAgICAgaW5kZXgpKTtcbiAgfVxuXG4gIC8qKiBUYWJsZS5yZXZlcnNlKClcbiAgICogXG4gICAqIGh0dHBzOi8vZGV4aWUub3JnL2RvY3MvVGFibGUvVGFibGUucmV2ZXJzZSgpXG4gICAqIFxuICAgKiovXG4gIHJldmVyc2UoKTogQ29sbGVjdGlvbiB7XG4gICAgcmV0dXJuIHRoaXMudG9Db2xsZWN0aW9uKCkucmV2ZXJzZSgpO1xuICB9XG5cbiAgLyoqIFRhYmxlLm1hcFRvQ2xhc3MoKVxuICAgKiBcbiAgICogaHR0cHM6Ly9kZXhpZS5vcmcvZG9jcy9UYWJsZS9UYWJsZS5tYXBUb0NsYXNzKClcbiAgICogXG4gICAqKi9cbiAgbWFwVG9DbGFzcyhjb25zdHJ1Y3RvcjogRnVuY3Rpb24pIHtcbiAgICB0aGlzLnNjaGVtYS5tYXBwZWRDbGFzcyA9IGNvbnN0cnVjdG9yO1xuICAgIC8vIE5vdywgc3Vic2NyaWJlIHRvIHRoZSB3aGVuKFwicmVhZGluZ1wiKSBldmVudCB0byBtYWtlIGFsbCBvYmplY3RzIHRoYXQgY29tZSBvdXQgZnJvbSB0aGlzIHRhYmxlIGluaGVyaXQgZnJvbSBnaXZlbiBjbGFzc1xuICAgIC8vIG5vIG1hdHRlciB3aGljaCBtZXRob2QgdG8gdXNlIGZvciByZWFkaW5nIChUYWJsZS5nZXQoKSBvciBUYWJsZS53aGVyZSguLi4pLi4uIClcbiAgICBjb25zdCByZWFkSG9vayA9IG9iaiA9PiB7XG4gICAgICBpZiAoIW9iaikgcmV0dXJuIG9iajsgLy8gTm8gdmFsaWQgb2JqZWN0LiAoVmFsdWUgaXMgbnVsbCkuIFJldHVybiBhcyBpcy5cbiAgICAgIC8vIENyZWF0ZSBhIG5ldyBvYmplY3QgdGhhdCBkZXJpdmVzIGZyb20gY29uc3RydWN0b3I6XG4gICAgICBjb25zdCByZXMgPSBPYmplY3QuY3JlYXRlKGNvbnN0cnVjdG9yLnByb3RvdHlwZSk7XG4gICAgICAvLyBDbG9uZSBtZW1iZXJzOlxuICAgICAgZm9yICh2YXIgbSBpbiBvYmopIGlmIChoYXNPd24ob2JqLCBtKSkgdHJ5IHsgcmVzW21dID0gb2JqW21dOyB9IGNhdGNoIChfKSB7IH1cbiAgICAgIHJldHVybiByZXM7XG4gICAgfTtcblxuICAgIGlmICh0aGlzLnNjaGVtYS5yZWFkSG9vaykge1xuICAgICAgdGhpcy5ob29rLnJlYWRpbmcudW5zdWJzY3JpYmUodGhpcy5zY2hlbWEucmVhZEhvb2spO1xuICAgIH1cbiAgICB0aGlzLnNjaGVtYS5yZWFkSG9vayA9IHJlYWRIb29rO1xuICAgIHRoaXMuaG9vayhcInJlYWRpbmdcIiwgcmVhZEhvb2spO1xuICAgIHJldHVybiBjb25zdHJ1Y3RvcjtcbiAgfVxuXG4gIC8qKiBAZGVwcmVjYXRlZCAqL1xuICBkZWZpbmVDbGFzcygpIHtcbiAgICBmdW5jdGlvbiBDbGFzcyAoY29udGVudCl7XG4gICAgICBleHRlbmQodGhpcywgY29udGVudCk7XG4gICAgfTtcbiAgICByZXR1cm4gdGhpcy5tYXBUb0NsYXNzKENsYXNzKTtcbiAgfVxuXG4gIC8qKiBUYWJsZS5hZGQoKVxuICAgKiBcbiAgICogaHR0cHM6Ly9kZXhpZS5vcmcvZG9jcy9UYWJsZS9UYWJsZS5hZGQoKVxuICAgKiBcbiAgICoqL1xuICBhZGQob2JqLCBrZXk/OiBJbmRleGFibGVUeXBlKTogUHJvbWlzZUV4dGVuZGVkPEluZGV4YWJsZVR5cGU+IHtcbiAgICBjb25zdCB7YXV0bywga2V5UGF0aH0gPSB0aGlzLnNjaGVtYS5wcmltS2V5O1xuICAgIGxldCBvYmpUb0FkZCA9IG9iajtcbiAgICBpZiAoa2V5UGF0aCAmJiBhdXRvKSB7XG4gICAgICBvYmpUb0FkZCA9IHdvcmthcm91bmRGb3JVbmRlZmluZWRQcmltS2V5KGtleVBhdGgpKG9iaik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl90cmFucygncmVhZHdyaXRlJywgdHJhbnMgPT4ge1xuICAgICAgcmV0dXJuIHRoaXMuY29yZS5tdXRhdGUoe3RyYW5zLCB0eXBlOiAnYWRkJywga2V5czoga2V5ICE9IG51bGwgPyBba2V5XSA6IG51bGwsIHZhbHVlczogW29ialRvQWRkXX0pO1xuICAgIH0pLnRoZW4ocmVzID0+IHJlcy5udW1GYWlsdXJlcyA/IFByb21pc2UucmVqZWN0KHJlcy5mYWlsdXJlc1swXSkgOiByZXMubGFzdFJlc3VsdClcbiAgICAudGhlbihsYXN0UmVzdWx0ID0+IHtcbiAgICAgIGlmIChrZXlQYXRoKSB7XG4gICAgICAgIC8vIFRoaXMgcGFydCBzaG91bGQgYmUgaGVyZSBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eS5cbiAgICAgICAgLy8gSWYgZXZlciBmZWVsaW5nIHRvbyBiYWQgYWJvdXQgdGhpcywgcGxlYXNlIHdhaXQgdG8gYSBuZXcgbWFqb3IgYmVmb3JlIHJlbW92aW5nIGl0LFxuICAgICAgICAvLyBhbmQgZG9jdW1lbnQgdGhlIGNoYW5nZSB0aG9yb3VnaGx5LlxuICAgICAgICB0cnl7c2V0QnlLZXlQYXRoKG9iaiwga2V5UGF0aCwgbGFzdFJlc3VsdCk7fWNhdGNoKF8pe307XG4gICAgICB9XG4gICAgICByZXR1cm4gbGFzdFJlc3VsdDtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKiBUYWJsZS51cGRhdGUoKVxuICAgKiBcbiAgICogaHR0cHM6Ly9kZXhpZS5vcmcvZG9jcy9UYWJsZS9UYWJsZS51cGRhdGUoKVxuICAgKiBcbiAgICoqL1xuICB1cGRhdGUoa2V5T3JPYmplY3QsIG1vZGlmaWNhdGlvbnM6IHsgW2tleVBhdGg6IHN0cmluZ106IGFueTsgfSB8ICgob2JqOiBhbnksIGN0eDp7dmFsdWU6IGFueSwgcHJpbUtleTogSW5kZXhhYmxlVHlwZX0pID0+IHZvaWQgfCBib29sZWFuKSk6IFByb21pc2VFeHRlbmRlZDxudW1iZXI+IHtcbiAgICBpZiAodHlwZW9mIGtleU9yT2JqZWN0ID09PSAnb2JqZWN0JyAmJiAhaXNBcnJheShrZXlPck9iamVjdCkpIHtcbiAgICAgIGNvbnN0IGtleSA9IGdldEJ5S2V5UGF0aChrZXlPck9iamVjdCwgdGhpcy5zY2hlbWEucHJpbUtleS5rZXlQYXRoKTtcbiAgICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZCkgcmV0dXJuIHJlamVjdGlvbihuZXcgZXhjZXB0aW9ucy5JbnZhbGlkQXJndW1lbnQoXG4gICAgICAgIFwiR2l2ZW4gb2JqZWN0IGRvZXMgbm90IGNvbnRhaW4gaXRzIHByaW1hcnkga2V5XCIpKTtcbiAgICAgIC8vIG9iamVjdCB0byBtb2RpZnkuIEFsc28gbW9kaWZ5IGdpdmVuIG9iamVjdCB3aXRoIHRoZSBtb2RpZmljYXRpb25zOlxuICAgICAgLy8gVGhpcyBwYXJ0IHNob3VsZCBiZSBoZXJlIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LlxuICAgICAgLy8gSWYgZXZlciBmZWVsaW5nIHRvbyBiYWQgYWJvdXQgbXV0YXRpbmcgZ2l2ZW4gb2JqZWN0LCBwbGVhc2Ugd2FpdCB0byBhIG5ldyBtYWpvciBiZWZvcmUgcmVtb3ZpbmcgaXQsXG4gICAgICAvLyBhbmQgZG9jdW1lbnQgdGhlIGNoYW5nZSB0aG9yb3VnaGx5LlxuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBtb2RpZmljYXRpb25zICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICBrZXlzKG1vZGlmaWNhdGlvbnMpLmZvckVhY2goa2V5UGF0aCA9PiB7XG4gICAgICAgICAgICBzZXRCeUtleVBhdGgoa2V5T3JPYmplY3QsIGtleVBhdGgsIG1vZGlmaWNhdGlvbnNba2V5UGF0aF0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE5vdyBzaW5jZSB3ZSBzdXBwb3J0IGZ1bmN0aW9uIGFyZ3VtZW50LCB3ZSBzaG91bGQgaGF2ZSBhIHNpbWlsYXIgYmVoYXZpb3IgaGVyZSBhcyB3ZWxsXG4gICAgICAgICAgLy8gKGFzIGxvbmcgYXMgd2UgZG8gdGhpcyBtdXRhYmlsaXR5IHN0dWZmIG9uIHRoZSBnaXZlbiBvYmplY3QpXG4gICAgICAgICAgbW9kaWZpY2F0aW9ucyhrZXlPck9iamVjdCwge3ZhbHVlOiBrZXlPck9iamVjdCwgcHJpbUtleToga2V5fSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2gge1xuICAgICAgICAvLyBNYXliZSBnaXZlbiBvYmplY3Qgd2FzIGZyb3plbi5cbiAgICAgICAgLy8gVGhpcyBwYXJ0IGlzIG5vdCBlc3NlbnRpYWwuIEp1c3QgbW92ZSBvbiBhcyBub3RoaW5nIGhhcHBlbmVkLi4uXG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy53aGVyZShcIjppZFwiKS5lcXVhbHMoa2V5KS5tb2RpZnkobW9kaWZpY2F0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGtleSB0byBtb2RpZnlcbiAgICAgIHJldHVybiB0aGlzLndoZXJlKFwiOmlkXCIpLmVxdWFscyhrZXlPck9iamVjdCkubW9kaWZ5KG1vZGlmaWNhdGlvbnMpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBUYWJsZS5wdXQoKVxuICAgKiBcbiAgICogaHR0cHM6Ly9kZXhpZS5vcmcvZG9jcy9UYWJsZS9UYWJsZS5wdXQoKVxuICAgKiBcbiAgICoqL1xuICBwdXQob2JqLCBrZXk/OiBJbmRleGFibGVUeXBlKTogUHJvbWlzZUV4dGVuZGVkPEluZGV4YWJsZVR5cGU+IHtcbiAgICBjb25zdCB7YXV0bywga2V5UGF0aH0gPSB0aGlzLnNjaGVtYS5wcmltS2V5O1xuICAgIGxldCBvYmpUb0FkZCA9IG9iajtcbiAgICBpZiAoa2V5UGF0aCAmJiBhdXRvKSB7XG4gICAgICBvYmpUb0FkZCA9IHdvcmthcm91bmRGb3JVbmRlZmluZWRQcmltS2V5KGtleVBhdGgpKG9iaik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl90cmFucyhcbiAgICAgICdyZWFkd3JpdGUnLFxuICAgICAgdHJhbnMgPT4gdGhpcy5jb3JlLm11dGF0ZSh7dHJhbnMsIHR5cGU6ICdwdXQnLCB2YWx1ZXM6IFtvYmpUb0FkZF0sIGtleXM6IGtleSAhPSBudWxsID8gW2tleV0gOiBudWxsfSkpXG4gICAgLnRoZW4ocmVzID0+IHJlcy5udW1GYWlsdXJlcyA/IFByb21pc2UucmVqZWN0KHJlcy5mYWlsdXJlc1swXSkgOiByZXMubGFzdFJlc3VsdClcbiAgICAudGhlbihsYXN0UmVzdWx0ID0+IHtcbiAgICAgIGlmIChrZXlQYXRoKSB7XG4gICAgICAgIC8vIFRoaXMgcGFydCBzaG91bGQgYmUgaGVyZSBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eS5cbiAgICAgICAgLy8gSWYgZXZlciBmZWVsaW5nIHRvbyBiYWQgYWJvdXQgdGhpcywgcGxlYXNlIHdhaXQgdG8gYSBuZXcgbWFqb3IgYmVmb3JlIHJlbW92aW5nIGl0LFxuICAgICAgICAvLyBhbmQgZG9jdW1lbnQgdGhlIGNoYW5nZSB0aG9yb3VnaGx5LlxuICAgICAgICB0cnl7c2V0QnlLZXlQYXRoKG9iaiwga2V5UGF0aCwgbGFzdFJlc3VsdCk7fWNhdGNoKF8pe307XG4gICAgICB9XG4gICAgICByZXR1cm4gbGFzdFJlc3VsdDtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKiBUYWJsZS5kZWxldGUoKVxuICAgKiBcbiAgICogaHR0cHM6Ly9kZXhpZS5vcmcvZG9jcy9UYWJsZS9UYWJsZS5kZWxldGUoKVxuICAgKiBcbiAgICoqL1xuICBkZWxldGUoa2V5OiBJbmRleGFibGVUeXBlKTogUHJvbWlzZUV4dGVuZGVkPHZvaWQ+IHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnMoJ3JlYWR3cml0ZScsXG4gICAgICB0cmFucyA9PiB0aGlzLmNvcmUubXV0YXRlKHt0cmFucywgdHlwZTogJ2RlbGV0ZScsIGtleXM6IFtrZXldfSkpXG4gICAgLnRoZW4ocmVzID0+IHJlcy5udW1GYWlsdXJlcyA/IFByb21pc2UucmVqZWN0KHJlcy5mYWlsdXJlc1swXSkgOiB1bmRlZmluZWQpO1xuICB9XG5cbiAgLyoqIFRhYmxlLmNsZWFyKClcbiAgICogXG4gICAqIGh0dHBzOi8vZGV4aWUub3JnL2RvY3MvVGFibGUvVGFibGUuY2xlYXIoKVxuICAgKiBcbiAgICoqL1xuICBjbGVhcigpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnMoJ3JlYWR3cml0ZScsXG4gICAgICB0cmFucyA9PiB0aGlzLmNvcmUubXV0YXRlKHt0cmFucywgdHlwZTogJ2RlbGV0ZVJhbmdlJywgcmFuZ2U6IEFueVJhbmdlfSkpXG4gICAgICAgIC50aGVuKHJlcyA9PiByZXMubnVtRmFpbHVyZXMgPyBQcm9taXNlLnJlamVjdChyZXMuZmFpbHVyZXNbMF0pIDogdW5kZWZpbmVkKTtcbiAgfVxuXG4gIC8qKiBUYWJsZS5idWxrR2V0KClcbiAgICogXG4gICAqIGh0dHBzOi8vZGV4aWUub3JnL2RvY3MvVGFibGUvVGFibGUuYnVsa0dldCgpXG4gICAqIFxuICAgKiBAcGFyYW0ga2V5cyBcbiAgICovXG4gIGJ1bGtHZXQoa2V5czogSW5kZXhhYmxlVHlwZVtdKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zKCdyZWFkb25seScsIHRyYW5zID0+IHtcbiAgICAgIHJldHVybiB0aGlzLmNvcmUuZ2V0TWFueSh7XG4gICAgICAgIGtleXMsXG4gICAgICAgIHRyYW5zXG4gICAgICB9KS50aGVuKHJlc3VsdCA9PiByZXN1bHQubWFwKHJlcyA9PiB0aGlzLmhvb2sucmVhZGluZy5maXJlKHJlcykpKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKiBUYWJsZS5idWxrQWRkKClcbiAgICogXG4gICAqIGh0dHBzOi8vZGV4aWUub3JnL2RvY3MvVGFibGUvVGFibGUuYnVsa0FkZCgpXG4gICAqIFxuICAgKiovXG4gIGJ1bGtBZGQoXG4gICAgb2JqZWN0czogYW55W10sXG4gICAga2V5c09yT3B0aW9ucz86IFJlYWRvbmx5QXJyYXk8SW5kZXhhYmxlVHlwZT4gfCB7IGFsbEtleXM/OiBib29sZWFuIH0sXG4gICAgb3B0aW9ucz86IHsgYWxsS2V5cz86IGJvb2xlYW4gfVxuICApIHsgICAgXG4gICAgY29uc3Qga2V5cyA9IEFycmF5LmlzQXJyYXkoa2V5c09yT3B0aW9ucykgPyBrZXlzT3JPcHRpb25zIDogdW5kZWZpbmVkO1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IChrZXlzID8gdW5kZWZpbmVkIDoga2V5c09yT3B0aW9ucyBhcyB7IGFsbEtleXM/OiBib29sZWFuIH0pO1xuICAgIGNvbnN0IHdhbnRSZXN1bHRzID0gb3B0aW9ucyA/IG9wdGlvbnMuYWxsS2V5cyA6IHVuZGVmaW5lZDtcblxuICAgIHJldHVybiB0aGlzLl90cmFucygncmVhZHdyaXRlJywgdHJhbnMgPT4ge1xuICAgICAgY29uc3Qge2F1dG8sIGtleVBhdGh9ID0gdGhpcy5zY2hlbWEucHJpbUtleTtcbiAgICAgIGlmIChrZXlQYXRoICYmIGtleXMpXG4gICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLkludmFsaWRBcmd1bWVudChcImJ1bGtBZGQoKToga2V5cyBhcmd1bWVudCBpbnZhbGlkIG9uIHRhYmxlcyB3aXRoIGluYm91bmQga2V5c1wiKTtcbiAgICAgIGlmIChrZXlzICYmIGtleXMubGVuZ3RoICE9PSBvYmplY3RzLmxlbmd0aClcbiAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuSW52YWxpZEFyZ3VtZW50KFwiQXJndW1lbnRzIG9iamVjdHMgYW5kIGtleXMgbXVzdCBoYXZlIHRoZSBzYW1lIGxlbmd0aFwiKTtcblxuICAgICAgY29uc3QgbnVtT2JqZWN0cyA9IG9iamVjdHMubGVuZ3RoOyAvLyBQaWNrIGxlbmd0aCBoZXJlIHRvIGFsbG93IGdhcmJhZ2UgY29sbGVjdGlvbiBvZiBvYmplY3RzIGxhdGVyXG4gICAgICBsZXQgb2JqZWN0c1RvQWRkID0ga2V5UGF0aCAmJiBhdXRvID9cbiAgICAgICAgb2JqZWN0cy5tYXAod29ya2Fyb3VuZEZvclVuZGVmaW5lZFByaW1LZXkoa2V5UGF0aCkpIDpcbiAgICAgICAgb2JqZWN0cztcbiAgICAgIHJldHVybiB0aGlzLmNvcmUubXV0YXRlKFxuICAgICAgICB7dHJhbnMsIHR5cGU6ICdhZGQnLCBrZXlzOiBrZXlzIGFzIEluZGV4YWJsZVR5cGVbXSwgdmFsdWVzOiBvYmplY3RzVG9BZGQsIHdhbnRSZXN1bHRzfVxuICAgICAgKVxuICAgICAgICAudGhlbigoe251bUZhaWx1cmVzLCByZXN1bHRzLGxhc3RSZXN1bHQsIGZhaWx1cmVzfSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHdhbnRSZXN1bHRzID8gcmVzdWx0cyA6IGxhc3RSZXN1bHQ7XG4gICAgICAgICAgaWYgKG51bUZhaWx1cmVzID09PSAwKSByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIHRocm93IG5ldyBCdWxrRXJyb3IoXG4gICAgICAgICAgICBgJHt0aGlzLm5hbWV9LmJ1bGtBZGQoKTogJHtudW1GYWlsdXJlc30gb2YgJHtudW1PYmplY3RzfSBvcGVyYXRpb25zIGZhaWxlZGAsIGZhaWx1cmVzKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKiogVGFibGUuYnVsa1B1dCgpXG4gICAqIFxuICAgKiBodHRwczovL2RleGllLm9yZy9kb2NzL1RhYmxlL1RhYmxlLmJ1bGtQdXQoKVxuICAgKiBcbiAgICoqL1xuICBidWxrUHV0KFxuICAgIG9iamVjdHM6IGFueVtdLFxuICAgIGtleXNPck9wdGlvbnM/OiBSZWFkb25seUFycmF5PEluZGV4YWJsZVR5cGU+IHwgeyBhbGxLZXlzPzogYm9vbGVhbiB9LFxuICAgIG9wdGlvbnM/OiB7IGFsbEtleXM/OiBib29sZWFuIH1cbiAgKSB7ICAgXG4gICAgY29uc3Qga2V5cyA9IEFycmF5LmlzQXJyYXkoa2V5c09yT3B0aW9ucykgPyBrZXlzT3JPcHRpb25zIDogdW5kZWZpbmVkO1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IChrZXlzID8gdW5kZWZpbmVkIDoga2V5c09yT3B0aW9ucyBhcyB7IGFsbEtleXM/OiBib29sZWFuIH0pO1xuICAgIGNvbnN0IHdhbnRSZXN1bHRzID0gb3B0aW9ucyA/IG9wdGlvbnMuYWxsS2V5cyA6IHVuZGVmaW5lZDtcblxuICAgIHJldHVybiB0aGlzLl90cmFucygncmVhZHdyaXRlJywgdHJhbnMgPT4ge1xuICAgICAgY29uc3Qge2F1dG8sIGtleVBhdGh9ID0gdGhpcy5zY2hlbWEucHJpbUtleTtcbiAgICAgIGlmIChrZXlQYXRoICYmIGtleXMpXG4gICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLkludmFsaWRBcmd1bWVudChcImJ1bGtQdXQoKToga2V5cyBhcmd1bWVudCBpbnZhbGlkIG9uIHRhYmxlcyB3aXRoIGluYm91bmQga2V5c1wiKTtcbiAgICAgIGlmIChrZXlzICYmIGtleXMubGVuZ3RoICE9PSBvYmplY3RzLmxlbmd0aClcbiAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuSW52YWxpZEFyZ3VtZW50KFwiQXJndW1lbnRzIG9iamVjdHMgYW5kIGtleXMgbXVzdCBoYXZlIHRoZSBzYW1lIGxlbmd0aFwiKTtcblxuICAgICAgY29uc3QgbnVtT2JqZWN0cyA9IG9iamVjdHMubGVuZ3RoOyAvLyBQaWNrIGxlbmd0aCBoZXJlIHRvIGFsbG93IGdhcmJhZ2UgY29sbGVjdGlvbiBvZiBvYmplY3RzIGxhdGVyXG4gICAgICBsZXQgb2JqZWN0c1RvUHV0ID0ga2V5UGF0aCAmJiBhdXRvID9cbiAgICAgICAgb2JqZWN0cy5tYXAod29ya2Fyb3VuZEZvclVuZGVmaW5lZFByaW1LZXkoa2V5UGF0aCkpIDpcbiAgICAgICAgb2JqZWN0cztcblxuICAgICAgcmV0dXJuIHRoaXMuY29yZS5tdXRhdGUoXG4gICAgICAgIHt0cmFucywgdHlwZTogJ3B1dCcsIGtleXM6IGtleXMgYXMgSW5kZXhhYmxlVHlwZVtdLCB2YWx1ZXM6IG9iamVjdHNUb1B1dCwgd2FudFJlc3VsdHN9XG4gICAgICApXG4gICAgICAgIC50aGVuKCh7bnVtRmFpbHVyZXMsIHJlc3VsdHMsIGxhc3RSZXN1bHQsIGZhaWx1cmVzfSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHdhbnRSZXN1bHRzID8gcmVzdWx0cyA6IGxhc3RSZXN1bHQ7XG4gICAgICAgICAgaWYgKG51bUZhaWx1cmVzID09PSAwKSByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIHRocm93IG5ldyBCdWxrRXJyb3IoXG4gICAgICAgICAgICBgJHt0aGlzLm5hbWV9LmJ1bGtQdXQoKTogJHtudW1GYWlsdXJlc30gb2YgJHtudW1PYmplY3RzfSBvcGVyYXRpb25zIGZhaWxlZGAsIGZhaWx1cmVzKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKiogVGFibGUuYnVsa0RlbGV0ZSgpXG4gICAqIFxuICAgKiBodHRwczovL2RleGllLm9yZy9kb2NzL1RhYmxlL1RhYmxlLmJ1bGtEZWxldGUoKVxuICAgKiBcbiAgICoqL1xuICBidWxrRGVsZXRlKGtleXM6IFJlYWRvbmx5QXJyYXk8SW5kZXhhYmxlVHlwZT4pOiBQcm9taXNlRXh0ZW5kZWQ8dm9pZD4ge1xuICAgIGNvbnN0IG51bUtleXMgPSBrZXlzLmxlbmd0aDtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnMoJ3JlYWR3cml0ZScsIHRyYW5zID0+IHtcbiAgICAgIHJldHVybiB0aGlzLmNvcmUubXV0YXRlKHt0cmFucywgdHlwZTogJ2RlbGV0ZScsIGtleXM6IGtleXMgYXMgSW5kZXhhYmxlVHlwZVtdfSk7XG4gICAgfSkudGhlbigoe251bUZhaWx1cmVzLCBsYXN0UmVzdWx0LCBmYWlsdXJlc30pID0+IHtcbiAgICAgIGlmIChudW1GYWlsdXJlcyA9PT0gMCkgcmV0dXJuIGxhc3RSZXN1bHQ7XG4gICAgICB0aHJvdyBuZXcgQnVsa0Vycm9yKFxuICAgICAgICBgJHt0aGlzLm5hbWV9LmJ1bGtEZWxldGUoKTogJHtudW1GYWlsdXJlc30gb2YgJHtudW1LZXlzfSBvcGVyYXRpb25zIGZhaWxlZGAsIGZhaWx1cmVzKTtcbiAgICB9KTtcbiAgfVxufVxuIiwgImltcG9ydCB7a2V5cywgaXNBcnJheSwgYXNhcH0gZnJvbSAnLi4vZnVuY3Rpb25zL3V0aWxzJztcbmltcG9ydCB7bm9wLCBtaXJyb3IsIHJldmVyc2VTdG9wcGFibGVFdmVudENoYWlufSBmcm9tICcuLi9mdW5jdGlvbnMvY2hhaW5pbmctZnVuY3Rpb25zJztcbmltcG9ydCB7ZXhjZXB0aW9uc30gZnJvbSAnLi4vZXJyb3JzJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gRXZlbnRzKGN0eCkge1xuICAgIHZhciBldnMgPSB7fTtcbiAgICB2YXIgcnYgPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBzdWJzY3JpYmVyKSB7XG4gICAgICAgIGlmIChzdWJzY3JpYmVyKSB7XG4gICAgICAgICAgICAvLyBTdWJzY3JpYmUuIElmIGFkZGl0aW9uYWwgYXJndW1lbnRzIHRoYW4ganVzdCB0aGUgc3Vic2NyaWJlciB3YXMgcHJvdmlkZWQsIGZvcndhcmQgdGhlbSBhcyB3ZWxsLlxuICAgICAgICAgICAgdmFyIGkgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KGkgLSAxKTtcbiAgICAgICAgICAgIHdoaWxlICgtLWkpIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZXZzW2V2ZW50TmFtZV0uc3Vic2NyaWJlLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICAgICAgcmV0dXJuIGN0eDtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgKGV2ZW50TmFtZSkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAvLyBSZXR1cm4gaW50ZXJmYWNlIGFsbG93aW5nIHRvIGZpcmUgb3IgdW5zdWJzY3JpYmUgZnJvbSBldmVudFxuICAgICAgICAgICAgcmV0dXJuIGV2c1tldmVudE5hbWVdO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBydi5hZGRFdmVudFR5cGUgPSBhZGQ7XG4gICAgXG4gICAgZm9yICh2YXIgaSA9IDEsIGwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgIGFkZChhcmd1bWVudHNbaV0pO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gcnY7XG5cbiAgICBmdW5jdGlvbiBhZGQoZXZlbnROYW1lLCBjaGFpbkZ1bmN0aW9uLCBkZWZhdWx0RnVuY3Rpb24pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBldmVudE5hbWUgPT09ICdvYmplY3QnKSByZXR1cm4gYWRkQ29uZmlndXJlZEV2ZW50cyhldmVudE5hbWUpO1xuICAgICAgICBpZiAoIWNoYWluRnVuY3Rpb24pIGNoYWluRnVuY3Rpb24gPSByZXZlcnNlU3RvcHBhYmxlRXZlbnRDaGFpbjtcbiAgICAgICAgaWYgKCFkZWZhdWx0RnVuY3Rpb24pIGRlZmF1bHRGdW5jdGlvbiA9IG5vcDtcblxuICAgICAgICB2YXIgY29udGV4dCA9IHtcbiAgICAgICAgICAgIHN1YnNjcmliZXJzOiBbXSxcbiAgICAgICAgICAgIGZpcmU6IGRlZmF1bHRGdW5jdGlvbixcbiAgICAgICAgICAgIHN1YnNjcmliZTogZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRleHQuc3Vic2NyaWJlcnMuaW5kZXhPZihjYikgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuc3Vic2NyaWJlcnMucHVzaChjYik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuZmlyZSA9IGNoYWluRnVuY3Rpb24oY29udGV4dC5maXJlLCBjYik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVuc3Vic2NyaWJlOiBmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LnN1YnNjcmliZXJzID0gY29udGV4dC5zdWJzY3JpYmVycy5maWx0ZXIoZnVuY3Rpb24gKGZuKSB7IHJldHVybiBmbiAhPT0gY2I7IH0pO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuZmlyZSA9IGNvbnRleHQuc3Vic2NyaWJlcnMucmVkdWNlKGNoYWluRnVuY3Rpb24sIGRlZmF1bHRGdW5jdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGV2c1tldmVudE5hbWVdID0gcnZbZXZlbnROYW1lXSA9IGNvbnRleHQ7XG4gICAgICAgIHJldHVybiBjb250ZXh0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZENvbmZpZ3VyZWRFdmVudHMoY2ZnKSB7XG4gICAgICAgIC8vIGV2ZW50cyh0aGlzLCB7cmVhZGluZzogW2Z1bmN0aW9uQ2hhaW4sIG5vcF19KTtcbiAgICAgICAga2V5cyhjZmcpLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50TmFtZSkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBjZmdbZXZlbnROYW1lXTtcbiAgICAgICAgICAgIGlmIChpc0FycmF5KGFyZ3MpKSB7XG4gICAgICAgICAgICAgICAgYWRkKGV2ZW50TmFtZSwgY2ZnW2V2ZW50TmFtZV1bMF0sIGNmZ1tldmVudE5hbWVdWzFdKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYXJncyA9PT0gJ2FzYXAnKSB7XG4gICAgICAgICAgICAgICAgLy8gUmF0aGVyIHRoYW4gYXBwcm9hY2hpbmcgZXZlbnQgc3Vic2NyaXB0aW9uIHVzaW5nIGEgZnVuY3Rpb25hbCBhcHByb2FjaCwgd2UgaGVyZSBkbyBpdCBpbiBhIGZvci1sb29wIHdoZXJlIHN1YnNjcmliZXIgaXMgZXhlY3V0ZWQgaW4gaXRzIG93biBzdGFja1xuICAgICAgICAgICAgICAgIC8vIGVuYWJsaW5nIHRoYXQgYW55IGV4Y2VwdGlvbiB0aGF0IG9jY3VyIHdvbnQgZGlzdHVyYiB0aGUgaW5pdGlhdG9yIGFuZCBhbHNvIG5vdCBuZXNjZXNzYXJ5IGJlIGNhdGNoZWQgYW5kIGZvcmdvdHRlbi5cbiAgICAgICAgICAgICAgICB2YXIgY29udGV4dCA9IGFkZChldmVudE5hbWUsIG1pcnJvciwgZnVuY3Rpb24gZmlyZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gT3B0aW1hemF0aW9uLXNhZmUgY2xvbmluZyBvZiBhcmd1bWVudHMgaW50byBhcmdzLlxuICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoaSk7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChpLS0pIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICAgICAgICAgIC8vIEFsbCBlYWNoIHN1YnNjcmliZXI6XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuc3Vic2NyaWJlcnMuZm9yRWFjaChmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzYXAoZnVuY3Rpb24gZmlyZUV2ZW50KCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZuLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHRocm93IG5ldyBleGNlcHRpb25zLkludmFsaWRBcmd1bWVudChcIkludmFsaWQgZXZlbnQgY29uZmlnXCIpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG4iLCAiaW1wb3J0IHsgYXJyYXlUb09iamVjdCwgZGVyaXZlIH0gZnJvbSAnLi91dGlscyc7XG5cblxuZXhwb3J0IGZ1bmN0aW9uIG1ha2VDbGFzc0NvbnN0cnVjdG9yPFRDb25zdHJ1Y3Rvcj4gKHByb3RvdHlwZTogT2JqZWN0LCBjb25zdHJ1Y3RvcjogRnVuY3Rpb24pIHtcbiAgLypjb25zdCBwcm9wZXJ0eURlc2NyaXB0b3JNYXAgPSBhcnJheVRvT2JqZWN0KFxuICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHByb3RvdHlwZSksXG4gICAgcHJvcEtleSA9PiBbcHJvcEtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihwcm90b3R5cGUsIHByb3BLZXkpXSk7XG5cbiAgLy8gQm90aCBkZXJpdmUgYW5kIGNsb25lIHRoZSBwcm90b3R5cGUuXG4gIC8vICAgZGVyaXZlOiBTbyB0aGF0IHggaW5zdGFuY2VvZiBUIHJldHVybnMgdHJ1ZSB3aGVuIFQgaXMgdGhlIGNsYXNzIHRlbXBsYXRlLlxuICAvLyAgIGNsb25lOiBPcHRpbWl6ZXMgbWV0aG9kIGFjY2VzcyBhIGJpdCAoYnV0IGFjdHVhbGx5IG5vdCBuZXNjZXNzYXJ5KVxuICBjb25zdCBkZXJpdmVkUHJvdG90eXBlQ2xvbmUgPSBPYmplY3QuY3JlYXRlKHByb3RvdHlwZSwgcHJvcGVydHlEZXNjcmlwdG9yTWFwKTtcbiAgZGVyaXZlZFByb3RvdHlwZUNsb25lLmNvbnN0cnVjdG9yID0gY29uc3RydWN0b3I7XG4gIGNvbnN0cnVjdG9yLnByb3RvdHlwZSA9IGRlcml2ZWRQcm90b3R5cGVDbG9uZTtcbiAgcmV0dXJuIGNvbnN0cnVjdG9yIGFzIGFueSBhcyBUQ29uc3RydWN0b3I7Ki9cblxuICAvLyBLZWVwIHRoZSBhYm92ZSBjb2RlIGluIGNhc2Ugd2Ugd2FudCB0byBjbG9uZSBBTkQgZGVyaXZlIHRoZSBwYXJlbnQgcHJvdG90eXBlLlxuICAvLyBSZWFzb24gd291bGQgYmUgb3B0aW1pemF0aW9uIG9mIHByb3BlcnR5IGFjY2Vzcy5cbiAgLy8gVGhlIGNvZGUgYmVsb3cgd2lsbCBvbmx5IGNyZWF0ZSBhIHByb3RvdHlwYWwgaW5oZXJpdGFuY2UgZnJvbSBnaXZlbiBjb25zdHJ1Y3RvciBmdW5jdGlvblxuICAvLyB0byBnaXZlbiBwcm90b3R5cGUuXG4gIGRlcml2ZShjb25zdHJ1Y3RvcikuZnJvbSh7cHJvdG90eXBlfSk7XG4gIHJldHVybiBjb25zdHJ1Y3RvciBhcyBhbnkgYXMgVENvbnN0cnVjdG9yOyAgXG59XG4iLCAiaW1wb3J0IHsgRGV4aWUgfSBmcm9tICcuLi9kZXhpZSc7XG5pbXBvcnQgeyBUYWJsZVNjaGVtYSB9IGZyb20gJy4uLy4uL3B1YmxpYy90eXBlcy90YWJsZS1zY2hlbWEnO1xuaW1wb3J0IHsgVHJhbnNhY3Rpb24gfSBmcm9tICcuLi90cmFuc2FjdGlvbi90cmFuc2FjdGlvbic7XG5pbXBvcnQgeyBob29rQ3JlYXRpbmdDaGFpbiwgcHVyZUZ1bmN0aW9uQ2hhaW4sIG5vcCwgbWlycm9yLCBob29rVXBkYXRpbmdDaGFpbiwgaG9va0RlbGV0aW5nQ2hhaW4gfSBmcm9tICcuLi8uLi9mdW5jdGlvbnMvY2hhaW5pbmctZnVuY3Rpb25zJztcbmltcG9ydCB7IFRhYmxlSG9va3MgfSBmcm9tICcuLi8uLi9wdWJsaWMvdHlwZXMvdGFibGUtaG9va3MnO1xuaW1wb3J0IHsgVGFibGUgfSBmcm9tICcuL3RhYmxlJztcbmltcG9ydCBFdmVudHMgZnJvbSAnLi4vLi4vaGVscGVycy9FdmVudHMnO1xuaW1wb3J0IHsgbWFrZUNsYXNzQ29uc3RydWN0b3IgfSBmcm9tICcuLi8uLi9mdW5jdGlvbnMvbWFrZS1jbGFzcy1jb25zdHJ1Y3Rvcic7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVGFibGVDb25zdHJ1Y3RvciB7XG4gIG5ldyAobmFtZTogc3RyaW5nLCB0YWJsZVNjaGVtYTogVGFibGVTY2hlbWEsIG9wdGlvbmFsVHJhbnM/OiBUcmFuc2FjdGlvbikgOiBUYWJsZTtcbiAgcHJvdG90eXBlOiBUYWJsZTtcbn1cblxuLyoqIEdlbmVyYXRlcyBhIFRhYmxlIGNvbnN0cnVjdG9yIGJvdW5kIHRvIGdpdmVuIERleGllIGluc3RhbmNlLlxuICogXG4gKiBUaGUgcHVycG9zZSBvZiBoYXZpbmcgZHluYW1pY2FsbHkgY3JlYXRlZCBjb25zdHJ1Y3RvcnMsIGlzIHRvIGFsbG93XG4gKiBhZGRvbnMgdG8gZXh0ZW5kIGNsYXNzZXMgZm9yIGEgY2VydGFpbiBEZXhpZSBpbnN0YW5jZSB3aXRob3V0IGFmZmVjdGluZ1xuICogb3RoZXIgZGIgaW5zdGFuY2VzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlVGFibGVDb25zdHJ1Y3RvciAoZGI6IERleGllKSB7XG4gIHJldHVybiBtYWtlQ2xhc3NDb25zdHJ1Y3RvcjxUYWJsZUNvbnN0cnVjdG9yPihcbiAgICBUYWJsZS5wcm90b3R5cGUsXG5cbiAgICBmdW5jdGlvbiBUYWJsZSAodGhpczogVGFibGUsIG5hbWU6IHN0cmluZywgdGFibGVTY2hlbWE6IFRhYmxlU2NoZW1hLCB0cmFucz86IFRyYW5zYWN0aW9uKSB7XG4gICAgICB0aGlzLmRiID0gZGI7XG4gICAgICB0aGlzLl90eCA9IHRyYW5zO1xuICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgIHRoaXMuc2NoZW1hID0gdGFibGVTY2hlbWE7XG4gICAgICB0aGlzLmhvb2sgPSBkYi5fYWxsVGFibGVzW25hbWVdID8gZGIuX2FsbFRhYmxlc1tuYW1lXS5ob29rIDogRXZlbnRzKG51bGwsIHtcbiAgICAgICAgXCJjcmVhdGluZ1wiOiBbaG9va0NyZWF0aW5nQ2hhaW4sIG5vcF0sXG4gICAgICAgIFwicmVhZGluZ1wiOiBbcHVyZUZ1bmN0aW9uQ2hhaW4sIG1pcnJvcl0sXG4gICAgICAgIFwidXBkYXRpbmdcIjogW2hvb2tVcGRhdGluZ0NoYWluLCBub3BdLFxuICAgICAgICBcImRlbGV0aW5nXCI6IFtob29rRGVsZXRpbmdDaGFpbiwgbm9wXVxuICAgICAgfSkgYXMgVGFibGVIb29rcztcbiAgICB9XG5cbiAgKTtcbn1cbiIsICJpbXBvcnQgeyBjb21iaW5lIH0gZnJvbSBcIi4uLy4uL2Z1bmN0aW9ucy9jb21iaW5lXCI7XG5pbXBvcnQgeyBleGNlcHRpb25zIH0gZnJvbSBcIi4uLy4uL2Vycm9yc1wiO1xuaW1wb3J0IHsgaGFzT3duIH0gZnJvbSBcIi4uLy4uL2Z1bmN0aW9ucy91dGlsc1wiO1xuaW1wb3J0IHsgd3JhcCB9IGZyb20gXCIuLi8uLi9oZWxwZXJzL3Byb21pc2VcIjtcbmltcG9ydCB7IENvbGxlY3Rpb24gfSBmcm9tICcuLyc7XG5pbXBvcnQgeyBEQkNvcmVDdXJzb3IsIERCQ29yZVRhYmxlLCBEQkNvcmVUcmFuc2FjdGlvbiwgREJDb3JlVGFibGVTY2hlbWEsIERCQ29yZVJhbmdlVHlwZSB9IGZyb20gJy4uLy4uL3B1YmxpYy90eXBlcy9kYmNvcmUnO1xuaW1wb3J0IHsgbm9wIH0gZnJvbSAnLi4vLi4vZnVuY3Rpb25zL2NoYWluaW5nLWZ1bmN0aW9ucyc7XG5cbnR5cGUgQ29sbGVjdGlvbkNvbnRleHQgPSBDb2xsZWN0aW9uW1wiX2N0eFwiXTtcblxuZXhwb3J0IGZ1bmN0aW9uIGlzUGxhaW5LZXlSYW5nZSAoY3R4OiBDb2xsZWN0aW9uQ29udGV4dCwgaWdub3JlTGltaXRGaWx0ZXI/OiBib29sZWFuKSB7XG4gIHJldHVybiAhKGN0eC5maWx0ZXIgfHwgY3R4LmFsZ29yaXRobSB8fCBjdHgub3IpICYmXG4gICAgICAoaWdub3JlTGltaXRGaWx0ZXIgPyBjdHguanVzdExpbWl0IDogIWN0eC5yZXBsYXlGaWx0ZXIpO1xufSAgICBcblxuZXhwb3J0IGZ1bmN0aW9uIGFkZEZpbHRlcihjdHg6IENvbGxlY3Rpb25Db250ZXh0LCBmbjogRnVuY3Rpb24pIHtcbiAgY3R4LmZpbHRlciA9IGNvbWJpbmUoY3R4LmZpbHRlciwgZm4pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYWRkUmVwbGF5RmlsdGVyIChjdHg6IENvbGxlY3Rpb25Db250ZXh0LCBmYWN0b3J5LCBpc0xpbWl0RmlsdGVyPykge1xuICB2YXIgY3VyciA9IGN0eC5yZXBsYXlGaWx0ZXI7XG4gIGN0eC5yZXBsYXlGaWx0ZXIgPSBjdXJyID8gKCk9PmNvbWJpbmUoY3VycigpLCBmYWN0b3J5KCkpIDogZmFjdG9yeTtcbiAgY3R4Lmp1c3RMaW1pdCA9IGlzTGltaXRGaWx0ZXIgJiYgIWN1cnI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGRNYXRjaEZpbHRlcihjdHg6IENvbGxlY3Rpb25Db250ZXh0LCBmbikge1xuICBjdHguaXNNYXRjaCA9IGNvbWJpbmUoY3R4LmlzTWF0Y2gsIGZuKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEluZGV4T3JTdG9yZShjdHg6IENvbGxlY3Rpb25Db250ZXh0LCBjb3JlU2NoZW1hOiBEQkNvcmVUYWJsZVNjaGVtYSkge1xuICAvLyBUT0RPOiBSZXdyaXRlIHRoaXMuIE5vIG5lZWQgdG8ga25vdyBjdHguaXNQcmltS2V5LiBjdHguaW5kZXggc2hvdWxkIGhvbGQgdGhlIGtleXBhdGguXG4gIC8vIFN0aWxsLCB0aHJvdyBpZiBub3QgZm91bmQhXG4gIGlmIChjdHguaXNQcmltS2V5KSByZXR1cm4gY29yZVNjaGVtYS5wcmltYXJ5S2V5O1xuICBjb25zdCBpbmRleCA9IGNvcmVTY2hlbWEuZ2V0SW5kZXhCeUtleVBhdGgoY3R4LmluZGV4KTtcbiAgaWYgKCFpbmRleCkgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuU2NoZW1hKFwiS2V5UGF0aCBcIiArIGN0eC5pbmRleCArIFwiIG9uIG9iamVjdCBzdG9yZSBcIiArIGNvcmVTY2hlbWEubmFtZSArIFwiIGlzIG5vdCBpbmRleGVkXCIpO1xuICByZXR1cm4gaW5kZXg7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBvcGVuQ3Vyc29yKGN0eDogQ29sbGVjdGlvbkNvbnRleHQsIGNvcmVUYWJsZTogREJDb3JlVGFibGUsIHRyYW5zOiBEQkNvcmVUcmFuc2FjdGlvbikge1xuICBjb25zdCBpbmRleCA9IGdldEluZGV4T3JTdG9yZShjdHgsIGNvcmVUYWJsZS5zY2hlbWEpO1xuICByZXR1cm4gY29yZVRhYmxlLm9wZW5DdXJzb3Ioe1xuICAgIHRyYW5zLFxuICAgIHZhbHVlczogIWN0eC5rZXlzT25seSxcbiAgICByZXZlcnNlOiBjdHguZGlyID09PSAncHJldicsXG4gICAgdW5pcXVlOiAhIWN0eC51bmlxdWUsXG4gICAgcXVlcnk6IHtcbiAgICAgIGluZGV4LCBcbiAgICAgIHJhbmdlOiBjdHgucmFuZ2VcbiAgICB9XG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXRlciAoXG4gIGN0eDogQ29sbGVjdGlvbkNvbnRleHQsIFxuICBmbjogKGl0ZW0sIGN1cnNvcjogREJDb3JlQ3Vyc29yLCBhZHZhbmNlOiBGdW5jdGlvbik9PnZvaWQsXG4gIGNvcmVUcmFuczogREJDb3JlVHJhbnNhY3Rpb24sXG4gIGNvcmVUYWJsZTogREJDb3JlVGFibGUpOiBQcm9taXNlPGFueT5cbntcbiAgY29uc3QgZmlsdGVyID0gY3R4LnJlcGxheUZpbHRlciA/IGNvbWJpbmUoY3R4LmZpbHRlciwgY3R4LnJlcGxheUZpbHRlcigpKSA6IGN0eC5maWx0ZXI7XG4gIGlmICghY3R4Lm9yKSB7XG4gICAgICByZXR1cm4gaXRlcmF0ZShcbiAgICAgICAgb3BlbkN1cnNvcihjdHgsIGNvcmVUYWJsZSwgY29yZVRyYW5zKSxcbiAgICAgICAgY29tYmluZShjdHguYWxnb3JpdGhtLCBmaWx0ZXIpLCBmbiwgIWN0eC5rZXlzT25seSAmJiBjdHgudmFsdWVNYXBwZXIpO1xuICB9IGVsc2Uge1xuICAgICAgY29uc3Qgc2V0ID0ge307XG5cbiAgICAgIGNvbnN0IHVuaW9uID0gKGl0ZW06IGFueSwgY3Vyc29yOiBEQkNvcmVDdXJzb3IsIGFkdmFuY2UpID0+IHtcbiAgICAgICAgICBpZiAoIWZpbHRlciB8fCBmaWx0ZXIoY3Vyc29yLCBhZHZhbmNlLCByZXN1bHQ9PmN1cnNvci5zdG9wKHJlc3VsdCksIGVyciA9PiBjdXJzb3IuZmFpbChlcnIpKSkge1xuICAgICAgICAgICAgICB2YXIgcHJpbWFyeUtleSA9IGN1cnNvci5wcmltYXJ5S2V5O1xuICAgICAgICAgICAgICB2YXIga2V5ID0gJycgKyBwcmltYXJ5S2V5O1xuICAgICAgICAgICAgICBpZiAoa2V5ID09PSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nKSBrZXkgPSAnJyArIG5ldyBVaW50OEFycmF5KHByaW1hcnlLZXkpO1xuICAgICAgICAgICAgICBpZiAoIWhhc093bihzZXQsIGtleSkpIHtcbiAgICAgICAgICAgICAgICAgIHNldFtrZXldID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIGZuKGl0ZW0sIGN1cnNvciwgYWR2YW5jZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBQcm9taXNlLmFsbChbXG4gICAgICAgIGN0eC5vci5faXRlcmF0ZSh1bmlvbiwgY29yZVRyYW5zKSxcbiAgICAgICAgaXRlcmF0ZShvcGVuQ3Vyc29yKGN0eCwgY29yZVRhYmxlLCBjb3JlVHJhbnMpLCBjdHguYWxnb3JpdGhtLCB1bmlvbiwgIWN0eC5rZXlzT25seSAmJiBjdHgudmFsdWVNYXBwZXIpXG4gICAgICBdKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpdGVyYXRlKGN1cnNvclByb21pc2U6IFByb21pc2U8REJDb3JlQ3Vyc29yPiwgZmlsdGVyLCBmbiwgdmFsdWVNYXBwZXIpOiBQcm9taXNlPGFueT4ge1xuICBcbiAgLy8gQXBwbHkgdmFsdWVNYXBwZXIgKGhvb2soJ3JlYWRpbmcnKSBvciBtYXBwcGVkIGNsYXNzKVxuICB2YXIgbWFwcGVkRm4gPSB2YWx1ZU1hcHBlciA/ICh4LGMsYSkgPT4gZm4odmFsdWVNYXBwZXIoeCksYyxhKSA6IGZuO1xuICAvLyBXcmFwIGZuIHdpdGggUFNEIGFuZCBtaWNyb3RpY2sgc3R1ZmYgZnJvbSBQcm9taXNlLlxuICB2YXIgd3JhcHBlZEZuID0gd3JhcChtYXBwZWRGbik7XG4gIFxuICByZXR1cm4gY3Vyc29yUHJvbWlzZS50aGVuKGN1cnNvciA9PiB7XG4gICAgaWYgKGN1cnNvcikge1xuICAgICAgcmV0dXJuIGN1cnNvci5zdGFydCgoKT0+e1xuICAgICAgICB2YXIgYyA9ICgpPT5jdXJzb3IuY29udGludWUoKTtcbiAgICAgICAgaWYgKCFmaWx0ZXIgfHwgZmlsdGVyKGN1cnNvciwgYWR2YW5jZXIgPT4gYyA9IGFkdmFuY2VyLCB2YWw9PntjdXJzb3Iuc3RvcCh2YWwpO2M9bm9wfSwgZSA9PiB7Y3Vyc29yLmZhaWwoZSk7YyA9IG5vcDt9KSlcbiAgICAgICAgICB3cmFwcGVkRm4oY3Vyc29yLnZhbHVlLCBjdXJzb3IsIGFkdmFuY2VyID0+IGMgPSBhZHZhbmNlcik7XG4gICAgICAgIGMoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG59XG4iLCAiLy8gSW1wbGVtZW50YXRpb24gb2YgaHR0cHM6Ly93d3cudzMub3JnL1RSL0luZGV4ZWREQi0zLyNjb21wYXJlLXR3by1rZXlzXG5cbmltcG9ydCB7IHRvU3RyaW5nVGFnIH0gZnJvbSAnLi91dGlscyc7XG5cbi8vIC4uLiB3aXRoIHRoZSBhZGp1c3RtZW50IHRvIHJldHVybiBOYU4gaW5zdGVhZCBvZiB0aHJvd2luZy5cbmV4cG9ydCBmdW5jdGlvbiBjbXAoYTogYW55LCBiOiBhbnkpOiBudW1iZXIge1xuICB0cnkge1xuICAgIGNvbnN0IHRhID0gdHlwZShhKTtcbiAgICBjb25zdCB0YiA9IHR5cGUoYik7XG4gICAgaWYgKHRhICE9PSB0Yikge1xuICAgICAgaWYgKHRhID09PSAnQXJyYXknKSByZXR1cm4gMTtcbiAgICAgIGlmICh0YiA9PT0gJ0FycmF5JykgcmV0dXJuIC0xO1xuICAgICAgaWYgKHRhID09PSAnYmluYXJ5JykgcmV0dXJuIDE7XG4gICAgICBpZiAodGIgPT09ICdiaW5hcnknKSByZXR1cm4gLTE7XG4gICAgICBpZiAodGEgPT09ICdzdHJpbmcnKSByZXR1cm4gMTtcbiAgICAgIGlmICh0YiA9PT0gJ3N0cmluZycpIHJldHVybiAtMTtcbiAgICAgIGlmICh0YSA9PT0gJ0RhdGUnKSByZXR1cm4gMTtcbiAgICAgIGlmICh0YiAhPT0gJ0RhdGUnKSByZXR1cm4gTmFOO1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICBzd2l0Y2ggKHRhKSB7XG4gICAgICBjYXNlICdudW1iZXInOlxuICAgICAgY2FzZSAnRGF0ZSc6XG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICByZXR1cm4gYSA+IGIgPyAxIDogYSA8IGIgPyAtMSA6IDA7XG4gICAgICBjYXNlICdiaW5hcnknOiB7XG4gICAgICAgIHJldHVybiBjb21wYXJlVWludDhBcnJheXMoZ2V0VWludDhBcnJheShhKSwgZ2V0VWludDhBcnJheShiKSk7XG4gICAgICB9XG4gICAgICBjYXNlICdBcnJheSc6XG4gICAgICAgIHJldHVybiBjb21wYXJlQXJyYXlzKGEsIGIpO1xuICAgIH1cbiAgfSBjYXRjaCB7fVxuICByZXR1cm4gTmFOOyAvLyBSZXR1cm4gdmFsdWUgaWYgYW55IGdpdmVuIGFyZ3MgYXJlIHZhbGlkIGtleXMuXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb21wYXJlQXJyYXlzKGE6IGFueVtdLCBiOiBhbnlbXSk6IG51bWJlciB7XG4gIGNvbnN0IGFsID0gYS5sZW5ndGg7XG4gIGNvbnN0IGJsID0gYi5sZW5ndGg7XG4gIGNvbnN0IGwgPSBhbCA8IGJsID8gYWwgOiBibDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsOyArK2kpIHtcbiAgICBjb25zdCByZXMgPSBjbXAoYVtpXSwgYltpXSk7XG4gICAgaWYgKHJlcyAhPT0gMCkgcmV0dXJuIHJlcztcbiAgfVxuICByZXR1cm4gYWwgPT09IGJsID8gMCA6IGFsIDwgYmwgPyAtMSA6IDE7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb21wYXJlVWludDhBcnJheXMoXG4gIGE6IFVpbnQ4QXJyYXksXG4gIGI6IFVpbnQ4QXJyYXlcbikge1xuICBjb25zdCBhbCA9IGEubGVuZ3RoO1xuICBjb25zdCBibCA9IGIubGVuZ3RoO1xuICBjb25zdCBsID0gYWwgPCBibCA/IGFsIDogYmw7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbDsgKytpKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHJldHVybiBhW2ldIDwgYltpXSA/IC0xIDogMTtcbiAgfVxuICByZXR1cm4gYWwgPT09IGJsID8gMCA6IGFsIDwgYmwgPyAtMSA6IDE7XG59XG5cbi8vIEltcGxlbWVudGF0aW9uIG9mIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9JbmRleGVkREItMy8ja2V5LXR5cGVcbmZ1bmN0aW9uIHR5cGUoeDogYW55KSB7XG4gIGNvbnN0IHQgPSB0eXBlb2YgeDtcbiAgaWYgKHQgIT09ICdvYmplY3QnKSByZXR1cm4gdDtcbiAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyh4KSkgcmV0dXJuICdiaW5hcnknO1xuICBjb25zdCB0c1RhZyA9IHRvU3RyaW5nVGFnKHgpOyAvLyBDYW5ub3QgdXNlIGluc3RhbmNlb2YgaW4gU2FmYXJpXG4gIHJldHVybiB0c1RhZyA9PT0gJ0FycmF5QnVmZmVyJyA/ICdiaW5hcnknIDogKHRzVGFnIGFzICdBcnJheScgfCAnRGF0ZScpO1xufVxuXG50eXBlIEJpbmFyeVR5cGUgPVxuICB8IEFycmF5QnVmZmVyXG4gIHwgRGF0YVZpZXdcbiAgfCBVaW50OENsYW1wZWRBcnJheVxuICB8IEFycmF5QnVmZmVyVmlld1xuICB8IFVpbnQ4QXJyYXlcbiAgfCBJbnQ4QXJyYXlcbiAgfCBVaW50MTZBcnJheVxuICB8IEludDE2QXJyYXlcbiAgfCBVaW50MzJBcnJheVxuICB8IEludDMyQXJyYXlcbiAgfCBGbG9hdDMyQXJyYXlcbiAgfCBGbG9hdDY0QXJyYXk7XG5cbmZ1bmN0aW9uIGdldFVpbnQ4QXJyYXkoYTogQmluYXJ5VHlwZSk6IFVpbnQ4QXJyYXkge1xuICBpZiAoYSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHJldHVybiBhO1xuICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KGEpKVxuICAgIC8vIFR5cGVkQXJyYXkgb3IgRGF0YVZpZXdcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYS5idWZmZXIsIGEuYnl0ZU9mZnNldCwgYS5ieXRlTGVuZ3RoKTtcbiAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGEpOyAvLyBBcnJheUJ1ZmZlclxufVxuIiwgImltcG9ydCB7IENvbGxlY3Rpb24gYXMgSUNvbGxlY3Rpb24gfSBmcm9tIFwiLi4vLi4vcHVibGljL3R5cGVzL2NvbGxlY3Rpb25cIjtcbmltcG9ydCB7IERleGllIH0gZnJvbSBcIi4uL2RleGllXCI7XG5pbXBvcnQgeyBUYWJsZSB9IGZyb20gXCIuLi90YWJsZVwiO1xuaW1wb3J0IHsgSW5kZXhhYmxlVHlwZSwgSW5kZXhhYmxlVHlwZUFycmF5UmVhZG9ubHkgfSBmcm9tIFwiLi4vLi4vcHVibGljL3R5cGVzL2luZGV4YWJsZS10eXBlXCI7XG5pbXBvcnQgeyBQcm9taXNlRXh0ZW5kZWQgfSBmcm9tIFwiLi4vLi4vcHVibGljL3R5cGVzL3Byb21pc2UtZXh0ZW5kZWRcIjtcbmltcG9ydCB7IGl0ZXIsIGlzUGxhaW5LZXlSYW5nZSwgZ2V0SW5kZXhPclN0b3JlLCBhZGRSZXBsYXlGaWx0ZXIsIGFkZEZpbHRlciwgYWRkTWF0Y2hGaWx0ZXIgfSBmcm9tIFwiLi9jb2xsZWN0aW9uLWhlbHBlcnNcIjtcbmltcG9ydCB7IHJlamVjdGlvbiB9IGZyb20gXCIuLi8uLi9oZWxwZXJzL3Byb21pc2VcIjtcbmltcG9ydCB7IGNvbWJpbmUgfSBmcm9tIFwiLi4vLi4vZnVuY3Rpb25zL2NvbWJpbmVcIjtcbmltcG9ydCB7IGV4dGVuZCwgaGFzT3duLCBkZWVwQ2xvbmUsIGtleXMsIHNldEJ5S2V5UGF0aCwgZ2V0QnlLZXlQYXRoIH0gZnJvbSBcIi4uLy4uL2Z1bmN0aW9ucy91dGlsc1wiO1xuaW1wb3J0IHsgTW9kaWZ5RXJyb3IgfSBmcm9tIFwiLi4vLi4vZXJyb3JzXCI7XG5pbXBvcnQgeyBoYW5nc09uRGVsZXRlTGFyZ2VLZXlSYW5nZSB9IGZyb20gXCIuLi8uLi9nbG9iYWxzL2NvbnN0YW50c1wiO1xuaW1wb3J0IHsgVGhlblNob3J0Y3V0IH0gZnJvbSBcIi4uLy4uL3B1YmxpYy90eXBlcy90aGVuLXNob3J0Y3V0XCI7XG5pbXBvcnQgeyBUcmFuc2FjdGlvbiB9IGZyb20gJy4uL3RyYW5zYWN0aW9uJztcbmltcG9ydCB7IERCQ29yZUN1cnNvciwgREJDb3JlVHJhbnNhY3Rpb24sIERCQ29yZVJhbmdlVHlwZSwgREJDb3JlTXV0YXRlUmVzcG9uc2UsIERCQ29yZUtleVJhbmdlIH0gZnJvbSAnLi4vLi4vcHVibGljL3R5cGVzL2RiY29yZSc7XG5pbXBvcnQgeyBjbXAgfSBmcm9tIFwiLi4vLi4vZnVuY3Rpb25zL2NtcFwiO1xuXG4vKiogY2xhc3MgQ29sbGVjdGlvblxuICogXG4gKiBodHRwczovL2RleGllLm9yZy9kb2NzL0NvbGxlY3Rpb24vQ29sbGVjdGlvblxuICovXG5leHBvcnQgY2xhc3MgQ29sbGVjdGlvbiBpbXBsZW1lbnRzIElDb2xsZWN0aW9uIHtcbiAgZGI6IERleGllO1xuICBfY3R4OiB7XG4gICAgdGFibGU6IFRhYmxlO1xuICAgIGluZGV4Pzogc3RyaW5nIHwgbnVsbDtcbiAgICBpc1ByaW1LZXk/OiBib29sZWFuO1xuICAgIHJhbmdlOiBEQkNvcmVLZXlSYW5nZTtcbiAgICBrZXlzT25seTogYm9vbGVhbjtcbiAgICBkaXI6IFwibmV4dFwiIHwgXCJwcmV2XCI7XG4gICAgdW5pcXVlOiBcIlwiIHwgXCJ1bmlxdWVcIjtcbiAgICBhbGdvcml0aG0/OiBGdW5jdGlvbiB8IG51bGw7XG4gICAgZmlsdGVyPzogRnVuY3Rpb24gfCBudWxsO1xuICAgIHJlcGxheUZpbHRlcjogRnVuY3Rpb24gfCBudWxsO1xuICAgIGp1c3RMaW1pdDogYm9vbGVhbjsgLy8gVHJ1ZSBpZiBhIHJlcGxheUZpbHRlciBpcyBqdXN0IGEgZmlsdGVyIHRoYXQgcGVyZm9ybXMgYSBcImxpbWl0XCIgb3BlcmF0aW9uIChvciBub25lIGF0IGFsbClcbiAgICBpc01hdGNoOiBGdW5jdGlvbiB8IG51bGw7XG4gICAgb2Zmc2V0OiBudW1iZXIsXG4gICAgbGltaXQ6IG51bWJlcixcbiAgICBlcnJvcjogYW55LCAvLyBJZiBzZXQsIGFueSBwcm9taXNlIG11c3QgYmUgcmVqZWN0ZWQgd2l0aCB0aGlzIGVycm9yXG4gICAgb3I6IENvbGxlY3Rpb24sXG4gICAgdmFsdWVNYXBwZXI6IChhbnkpID0+IGFueVxuICB9XG4gIFxuICBfb25kaXJlY3Rpb25jaGFuZ2U/OiBGdW5jdGlvbjtcblxuICBfcmVhZDxUPihmbjogKGlkYnRyYW5zOiBJREJUcmFuc2FjdGlvbiwgZHhUcmFuczogVHJhbnNhY3Rpb24pID0+IFByb21pc2VMaWtlPFQ+LCBjYj8pOiBQcm9taXNlRXh0ZW5kZWQ8VD4ge1xuICAgIHZhciBjdHggPSB0aGlzLl9jdHg7XG4gICAgcmV0dXJuIGN0eC5lcnJvciA/XG4gICAgICBjdHgudGFibGUuX3RyYW5zKG51bGwsIHJlamVjdGlvbi5iaW5kKG51bGwsIGN0eC5lcnJvcikpIDpcbiAgICAgIGN0eC50YWJsZS5fdHJhbnMoJ3JlYWRvbmx5JywgZm4pLnRoZW4oY2IpO1xuICB9XG5cbiAgX3dyaXRlPFQ+KGZuOiAoaWRidHJhbnM6IElEQlRyYW5zYWN0aW9uLCBkeFRyYW5zOiBUcmFuc2FjdGlvbikgPT4gUHJvbWlzZUxpa2U8VD4pOiBQcm9taXNlRXh0ZW5kZWQ8VD4ge1xuICAgIHZhciBjdHggPSB0aGlzLl9jdHg7XG4gICAgcmV0dXJuIGN0eC5lcnJvciA/XG4gICAgICBjdHgudGFibGUuX3RyYW5zKG51bGwsIHJlamVjdGlvbi5iaW5kKG51bGwsIGN0eC5lcnJvcikpIDpcbiAgICAgIGN0eC50YWJsZS5fdHJhbnMoJ3JlYWR3cml0ZScsIGZuLCBcImxvY2tlZFwiKTsgLy8gV2hlbiBkb2luZyB3cml0ZSBvcGVyYXRpb25zIG9uIGNvbGxlY3Rpb25zLCBhbHdheXMgbG9jayB0aGUgb3BlcmF0aW9uIHNvIHRoYXQgdXBjb21pbmcgb3BlcmF0aW9ucyBnZXRzIHF1ZXVlZC5cbiAgfVxuXG4gIF9hZGRBbGdvcml0aG0oZm4pIHtcbiAgICB2YXIgY3R4ID0gdGhpcy5fY3R4O1xuICAgIGN0eC5hbGdvcml0aG0gPSBjb21iaW5lKGN0eC5hbGdvcml0aG0sIGZuKTtcbiAgfVxuXG4gIF9pdGVyYXRlKFxuICAgIGZuOiAoaXRlbSwgY3Vyc29yOiBEQkNvcmVDdXJzb3IsIGFkdmFuY2U6IEZ1bmN0aW9uKSA9PiB2b2lkLFxuICAgIGNvcmVUcmFuczogREJDb3JlVHJhbnNhY3Rpb24pIDogUHJvbWlzZTxhbnk+XG4gIHtcbiAgICByZXR1cm4gaXRlcih0aGlzLl9jdHgsIGZuLCBjb3JlVHJhbnMsIHRoaXMuX2N0eC50YWJsZS5jb3JlKTtcbiAgfVxuXG4gIC8qKiBDb2xsZWN0aW9uLmNsb25lKClcbiAgICogXG4gICAqIGh0dHBzOi8vZGV4aWUub3JnL2RvY3MvQ29sbGVjdGlvbi9Db2xsZWN0aW9uLmNsb25lKClcbiAgICogXG4gICAqKi9cbiAgY2xvbmUocHJvcHM/KSB7XG4gICAgdmFyIHJ2ID0gT2JqZWN0LmNyZWF0ZSh0aGlzLmNvbnN0cnVjdG9yLnByb3RvdHlwZSksXG4gICAgICBjdHggPSBPYmplY3QuY3JlYXRlKHRoaXMuX2N0eCk7XG4gICAgaWYgKHByb3BzKSBleHRlbmQoY3R4LCBwcm9wcyk7XG4gICAgcnYuX2N0eCA9IGN0eDtcbiAgICByZXR1cm4gcnY7XG4gIH1cblxuICAvKiogQ29sbGVjdGlvbi5yYXcoKVxuICAgKiBcbiAgICogaHR0cHM6Ly9kZXhpZS5vcmcvZG9jcy9Db2xsZWN0aW9uL0NvbGxlY3Rpb24ucmF3KClcbiAgICogXG4gICAqKi9cbiAgcmF3KCkge1xuICAgIHRoaXMuX2N0eC52YWx1ZU1hcHBlciA9IG51bGw7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKiogQ29sbGVjdGlvbi5lYWNoKClcbiAgICogXG4gICAqIGh0dHBzOi8vZGV4aWUub3JnL2RvY3MvQ29sbGVjdGlvbi9Db2xsZWN0aW9uLmVhY2goKVxuICAgKiBcbiAgICoqL1xuICBlYWNoKGZuOiAob2JqLCBjdXJzb3I6IERCQ29yZUN1cnNvcikgPT4gYW55KTogUHJvbWlzZUV4dGVuZGVkPHZvaWQ+IHtcbiAgICB2YXIgY3R4ID0gdGhpcy5fY3R4O1xuXG4gICAgcmV0dXJuIHRoaXMuX3JlYWQodHJhbnMgPT4gaXRlcihjdHgsIGZuLCB0cmFucywgY3R4LnRhYmxlLmNvcmUpKTtcbiAgfVxuXG4gIC8qKiBDb2xsZWN0aW9uLmNvdW50KClcbiAgICogXG4gICAqIGh0dHBzOi8vZGV4aWUub3JnL2RvY3MvQ29sbGVjdGlvbi9Db2xsZWN0aW9uLmNvdW50KClcbiAgICogXG4gICAqKi9cbiAgY291bnQoY2I/KSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlYWQodHJhbnMgPT4ge1xuICAgICAgY29uc3QgY3R4ID0gdGhpcy5fY3R4O1xuICAgICAgY29uc3QgY29yZVRhYmxlID0gY3R4LnRhYmxlLmNvcmU7XG4gICAgICBpZiAoaXNQbGFpbktleVJhbmdlKGN0eCwgdHJ1ZSkpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBhIHBsYWluIGtleSByYW5nZS4gV2UgY2FuIHVzZSB0aGUgY291bnQoKSBtZXRob2QgaWYgdGhlIGluZGV4LlxuICAgICAgICByZXR1cm4gY29yZVRhYmxlLmNvdW50KHtcbiAgICAgICAgICB0cmFucyxcbiAgICAgICAgICBxdWVyeToge1xuICAgICAgICAgICAgaW5kZXg6IGdldEluZGV4T3JTdG9yZShjdHgsIGNvcmVUYWJsZS5zY2hlbWEpLFxuICAgICAgICAgICAgcmFuZ2U6IGN0eC5yYW5nZVxuICAgICAgICAgIH1cbiAgICAgICAgfSkudGhlbihjb3VudCA9PiBNYXRoLm1pbihjb3VudCwgY3R4LmxpbWl0KSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBBbGdvcml0aG1zLCBmaWx0ZXJzIG9yIGV4cHJlc3Npb25zIGFyZSBhcHBsaWVkLiBOZWVkIHRvIGNvdW50IG1hbnVhbGx5LlxuICAgICAgICB2YXIgY291bnQgPSAwO1xuICAgICAgICByZXR1cm4gaXRlcihjdHgsICgpID0+IHsgKytjb3VudDsgcmV0dXJuIGZhbHNlOyB9LCB0cmFucywgY29yZVRhYmxlKVxuICAgICAgICAudGhlbigoKT0+Y291bnQpO1xuICAgICAgfVxuICAgIH0pLnRoZW4oY2IpO1xuICB9XG5cbiAgLyoqIENvbGxlY3Rpb24uc29ydEJ5KClcbiAgICogXG4gICAqIGh0dHBzOi8vZGV4aWUub3JnL2RvY3MvQ29sbGVjdGlvbi9Db2xsZWN0aW9uLnNvcnRCeSgpXG4gICAqIFxuICAgKiovXG4gIHNvcnRCeShrZXlQYXRoOiBzdHJpbmcpOiBQcm9taXNlRXh0ZW5kZWQ8YW55W10+O1xuICBzb3J0Qnk8Uj4oa2V5UGF0aDogc3RyaW5nLCB0aGVuU2hvcnRjdXQ6IFRoZW5TaG9ydGN1dDxhbnlbXSwgUj4pIDogUHJvbWlzZUV4dGVuZGVkPFI+O1xuICBzb3J0Qnkoa2V5UGF0aDogc3RyaW5nLCBjYj86IFRoZW5TaG9ydGN1dDxhbnlbXSwgYW55Pikge1xuICAgIGNvbnN0IHBhcnRzID0ga2V5UGF0aC5zcGxpdCgnLicpLnJldmVyc2UoKSxcbiAgICAgIGxhc3RQYXJ0ID0gcGFydHNbMF0sXG4gICAgICBsYXN0SW5kZXggPSBwYXJ0cy5sZW5ndGggLSAxO1xuICAgIGZ1bmN0aW9uIGdldHZhbChvYmosIGkpIHtcbiAgICAgIGlmIChpKSByZXR1cm4gZ2V0dmFsKG9ialtwYXJ0c1tpXV0sIGkgLSAxKTtcbiAgICAgIHJldHVybiBvYmpbbGFzdFBhcnRdO1xuICAgIH1cbiAgICB2YXIgb3JkZXIgPSB0aGlzLl9jdHguZGlyID09PSBcIm5leHRcIiA/IDEgOiAtMTtcblxuICAgIGZ1bmN0aW9uIHNvcnRlcihhLCBiKSB7XG4gICAgICB2YXIgYVZhbCA9IGdldHZhbChhLCBsYXN0SW5kZXgpLFxuICAgICAgICBiVmFsID0gZ2V0dmFsKGIsIGxhc3RJbmRleCk7XG4gICAgICByZXR1cm4gYVZhbCA8IGJWYWwgPyAtb3JkZXIgOiBhVmFsID4gYlZhbCA/IG9yZGVyIDogMDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudG9BcnJheShmdW5jdGlvbiAoYSkge1xuICAgICAgcmV0dXJuIGEuc29ydChzb3J0ZXIpO1xuICAgIH0pLnRoZW4oY2IpO1xuICB9XG5cbiAgLyoqIENvbGxlY3Rpb24udG9BcnJheSgpXG4gICAqIFxuICAgKiBodHRwczovL2RleGllLm9yZy9kb2NzL0NvbGxlY3Rpb24vQ29sbGVjdGlvbi50b0FycmF5KClcbiAgICogXG4gICAqKi9cbiAgdG9BcnJheShjYj8pOiBQcm9taXNlRXh0ZW5kZWQ8YW55W10+IHtcbiAgICByZXR1cm4gdGhpcy5fcmVhZCh0cmFucyA9PiB7XG4gICAgICB2YXIgY3R4ID0gdGhpcy5fY3R4O1xuICAgICAgaWYgKGN0eC5kaXIgPT09ICduZXh0JyAmJiBpc1BsYWluS2V5UmFuZ2UoY3R4LCB0cnVlKSAmJiBjdHgubGltaXQgPiAwKSB7XG4gICAgICAgIC8vIFNwZWNpYWwgb3B0aW1hdGlvbiBpZiB3ZSBjb3VsZCB1c2UgSURCT2JqZWN0U3RvcmUuZ2V0QWxsKCkgb3JcbiAgICAgICAgLy8gSURCS2V5UmFuZ2UuZ2V0QWxsKCk6XG4gICAgICAgIGNvbnN0IHt2YWx1ZU1hcHBlcn0gPSBjdHg7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gZ2V0SW5kZXhPclN0b3JlKGN0eCwgY3R4LnRhYmxlLmNvcmUuc2NoZW1hKTtcbiAgICAgICAgcmV0dXJuIGN0eC50YWJsZS5jb3JlLnF1ZXJ5KHtcbiAgICAgICAgICB0cmFucyxcbiAgICAgICAgICBsaW1pdDogY3R4LmxpbWl0LFxuICAgICAgICAgIHZhbHVlczogdHJ1ZSxcbiAgICAgICAgICBxdWVyeToge1xuICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICByYW5nZTogY3R4LnJhbmdlXG4gICAgICAgICAgfVxuICAgICAgICB9KS50aGVuKCh7cmVzdWx0fSkgPT4gdmFsdWVNYXBwZXIgPyByZXN1bHQubWFwKHZhbHVlTWFwcGVyKSA6IHJlc3VsdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBHZXR0aW5nIGFycmF5IHRocm91Z2ggYSBjdXJzb3IuXG4gICAgICAgIGNvbnN0IGEgPSBbXTtcbiAgICAgICAgcmV0dXJuIGl0ZXIoY3R4LCBpdGVtID0+IGEucHVzaChpdGVtKSwgdHJhbnMsIGN0eC50YWJsZS5jb3JlKS50aGVuKCgpPT5hKTtcbiAgICAgIH1cbiAgICB9LCBjYik7XG4gIH1cblxuICAvKiogQ29sbGVjdGlvbi5vZmZzZXQoKVxuICAgKiBcbiAgICogaHR0cHM6Ly9kZXhpZS5vcmcvZG9jcy9Db2xsZWN0aW9uL0NvbGxlY3Rpb24ub2Zmc2V0KClcbiAgICogXG4gICAqKi9cbiAgb2Zmc2V0KG9mZnNldDogbnVtYmVyKSA6IENvbGxlY3Rpb257XG4gICAgdmFyIGN0eCA9IHRoaXMuX2N0eDtcbiAgICBpZiAob2Zmc2V0IDw9IDApIHJldHVybiB0aGlzO1xuICAgIGN0eC5vZmZzZXQgKz0gb2Zmc2V0OyAvLyBGb3IgY291bnQoKVxuICAgIGlmIChpc1BsYWluS2V5UmFuZ2UoY3R4KSkge1xuICAgICAgYWRkUmVwbGF5RmlsdGVyKGN0eCwgKCkgPT4ge1xuICAgICAgICB2YXIgb2Zmc2V0TGVmdCA9IG9mZnNldDtcbiAgICAgICAgcmV0dXJuIChjdXJzb3IsIGFkdmFuY2UpID0+IHtcbiAgICAgICAgICBpZiAob2Zmc2V0TGVmdCA9PT0gMCkgcmV0dXJuIHRydWU7XG4gICAgICAgICAgaWYgKG9mZnNldExlZnQgPT09IDEpIHsgLS1vZmZzZXRMZWZ0OyByZXR1cm4gZmFsc2U7IH1cbiAgICAgICAgICBhZHZhbmNlKCgpID0+IHtcbiAgICAgICAgICAgIGN1cnNvci5hZHZhbmNlKG9mZnNldExlZnQpO1xuICAgICAgICAgICAgb2Zmc2V0TGVmdCA9IDA7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFkZFJlcGxheUZpbHRlcihjdHgsICgpID0+IHtcbiAgICAgICAgdmFyIG9mZnNldExlZnQgPSBvZmZzZXQ7XG4gICAgICAgIHJldHVybiAoKSA9PiAoLS1vZmZzZXRMZWZ0IDwgMCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKiogQ29sbGVjdGlvbi5saW1pdCgpXG4gICAqIFxuICAgKiBodHRwczovL2RleGllLm9yZy9kb2NzL0NvbGxlY3Rpb24vQ29sbGVjdGlvbi5saW1pdCgpXG4gICAqIFxuICAgKiovXG4gIGxpbWl0KG51bVJvd3M6IG51bWJlcikgOiBDb2xsZWN0aW9uIHtcbiAgICB0aGlzLl9jdHgubGltaXQgPSBNYXRoLm1pbih0aGlzLl9jdHgubGltaXQsIG51bVJvd3MpOyAvLyBGb3IgY291bnQoKVxuICAgIGFkZFJlcGxheUZpbHRlcih0aGlzLl9jdHgsICgpID0+IHtcbiAgICAgIHZhciByb3dzTGVmdCA9IG51bVJvd3M7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGN1cnNvciwgYWR2YW5jZSwgcmVzb2x2ZSkge1xuICAgICAgICBpZiAoLS1yb3dzTGVmdCA8PSAwKSBhZHZhbmNlKHJlc29sdmUpOyAvLyBTdG9wIGFmdGVyIHRoaXMgaXRlbSBoYXMgYmVlbiBpbmNsdWRlZFxuICAgICAgICByZXR1cm4gcm93c0xlZnQgPj0gMDsgLy8gSWYgbnVtUm93cyBpcyBhbHJlYWR5IGJlbG93IDAsIHJldHVybiBmYWxzZSBiZWNhdXNlIHRoZW4gMCB3YXMgcGFzc2VkIHRvIG51bVJvd3MgaW5pdGlhbGx5LiBPdGhlcndpc2Ugd2Ugd291bGRudCBjb21lIGhlcmUuXG4gICAgICB9O1xuICAgIH0sIHRydWUpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqIENvbGxlY3Rpb24udW50aWwoKVxuICAgKiBcbiAgICogaHR0cHM6Ly9kZXhpZS5vcmcvZG9jcy9Db2xsZWN0aW9uL0NvbGxlY3Rpb24udW50aWwoKVxuICAgKiBcbiAgICoqL1xuICB1bnRpbChmaWx0ZXJGdW5jdGlvbjogKHgpID0+IGJvb2xlYW4sIGJJbmNsdWRlU3RvcEVudHJ5Pykge1xuICAgIGFkZEZpbHRlcih0aGlzLl9jdHgsIGZ1bmN0aW9uIChjdXJzb3IsIGFkdmFuY2UsIHJlc29sdmUpIHtcbiAgICAgIGlmIChmaWx0ZXJGdW5jdGlvbihjdXJzb3IudmFsdWUpKSB7XG4gICAgICAgIGFkdmFuY2UocmVzb2x2ZSk7XG4gICAgICAgIHJldHVybiBiSW5jbHVkZVN0b3BFbnRyeTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqIENvbGxlY3Rpb24uZmlyc3QoKVxuICAgKiBcbiAgICogaHR0cHM6Ly9kZXhpZS5vcmcvZG9jcy9Db2xsZWN0aW9uL0NvbGxlY3Rpb24uZmlyc3QoKVxuICAgKiBcbiAgICoqL1xuICBmaXJzdChjYj8pIHtcbiAgICByZXR1cm4gdGhpcy5saW1pdCgxKS50b0FycmF5KGZ1bmN0aW9uIChhKSB7IHJldHVybiBhWzBdOyB9KS50aGVuKGNiKTtcbiAgfVxuXG4gIC8qKiBDb2xsZWN0aW9uLmxhc3QoKVxuICAgKiBcbiAgICogaHR0cHM6Ly9kZXhpZS5vcmcvZG9jcy9Db2xsZWN0aW9uL0NvbGxlY3Rpb24ubGFzdCgpXG4gICAqIFxuICAgKiovXG4gIGxhc3QoY2I/KSB7XG4gICAgcmV0dXJuIHRoaXMucmV2ZXJzZSgpLmZpcnN0KGNiKTtcbiAgfVxuXG4gIC8qKiBDb2xsZWN0aW9uLmZpbHRlcigpXG4gICAqIFxuICAgKiBodHRwczovL2RleGllLm9yZy9kb2NzL0NvbGxlY3Rpb24vQ29sbGVjdGlvbi5maWx0ZXIoKVxuICAgKiBcbiAgICoqL1xuICBmaWx0ZXIoZmlsdGVyRnVuY3Rpb246ICh4KSA9PiBib29sZWFuKTogQ29sbGVjdGlvbiB7XG4gICAgLy8vIDxwYXJhbSBuYW1lPVwianNGdW5jdGlvbkZpbHRlclwiIHR5cGU9XCJGdW5jdGlvblwiPmZ1bmN0aW9uKHZhbCl7cmV0dXJuIHRydWUvZmFsc2V9PC9wYXJhbT5cbiAgICBhZGRGaWx0ZXIodGhpcy5fY3R4LCBmdW5jdGlvbiAoY3Vyc29yKSB7XG4gICAgICByZXR1cm4gZmlsdGVyRnVuY3Rpb24oY3Vyc29yLnZhbHVlKTtcbiAgICB9KTtcbiAgICAvLyBtYXRjaCBmaWx0ZXJzIG5vdCB1c2VkIGluIERleGllLmpzIGJ1dCBjYW4gYmUgdXNlZCBieSAzcmQgcGFydCBsaWJyYXJpZXMgdG8gdGVzdCBhXG4gICAgLy8gY29sbGVjdGlvbiBmb3IgYSBtYXRjaCB3aXRob3V0IHF1ZXJ5aW5nIERCLiBVc2VkIGJ5IERleGllLk9ic2VydmFibGUuXG4gICAgYWRkTWF0Y2hGaWx0ZXIodGhpcy5fY3R4LCBmaWx0ZXJGdW5jdGlvbik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKiogQ29sbGVjdGlvbi5hbmQoKVxuICAgKiBcbiAgICogaHR0cHM6Ly9kZXhpZS5vcmcvZG9jcy9Db2xsZWN0aW9uL0NvbGxlY3Rpb24uYW5kKClcbiAgICogXG4gICAqKi9cbiAgYW5kKGZpbHRlcjogKHgpID0+IGJvb2xlYW4pIHtcbiAgICByZXR1cm4gdGhpcy5maWx0ZXIoZmlsdGVyKTtcbiAgfVxuXG4gIC8qKiBDb2xsZWN0aW9uLm9yKClcbiAgICogXG4gICAqIGh0dHBzOi8vZGV4aWUub3JnL2RvY3MvQ29sbGVjdGlvbi9Db2xsZWN0aW9uLm9yKClcbiAgICogXG4gICAqKi9cbiAgb3IoaW5kZXhOYW1lOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gbmV3IHRoaXMuZGIuV2hlcmVDbGF1c2UodGhpcy5fY3R4LnRhYmxlLCBpbmRleE5hbWUsIHRoaXMpO1xuICB9XG5cbiAgLyoqIENvbGxlY3Rpb24ucmV2ZXJzZSgpXG4gICAqIFxuICAgKiBodHRwczovL2RleGllLm9yZy9kb2NzL0NvbGxlY3Rpb24vQ29sbGVjdGlvbi5yZXZlcnNlKClcbiAgICogXG4gICAqKi9cbiAgcmV2ZXJzZSgpIHtcbiAgICB0aGlzLl9jdHguZGlyID0gKHRoaXMuX2N0eC5kaXIgPT09IFwicHJldlwiID8gXCJuZXh0XCIgOiBcInByZXZcIik7XG4gICAgaWYgKHRoaXMuX29uZGlyZWN0aW9uY2hhbmdlKSB0aGlzLl9vbmRpcmVjdGlvbmNoYW5nZSh0aGlzLl9jdHguZGlyKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKiBDb2xsZWN0aW9uLmRlc2MoKVxuICAgKiBcbiAgICogaHR0cHM6Ly9kZXhpZS5vcmcvZG9jcy9Db2xsZWN0aW9uL0NvbGxlY3Rpb24uZGVzYygpXG4gICAqIFxuICAgKiovXG4gIGRlc2MoKSB7XG4gICAgcmV0dXJuIHRoaXMucmV2ZXJzZSgpO1xuICB9XG5cbiAgLyoqIENvbGxlY3Rpb24uZWFjaEtleSgpXG4gICAqIFxuICAgKiBodHRwczovL2RleGllLm9yZy9kb2NzL0NvbGxlY3Rpb24vQ29sbGVjdGlvbi5lYWNoS2V5KClcbiAgICogXG4gICAqKi9cbiAgZWFjaEtleShjYj8pIHtcbiAgICB2YXIgY3R4ID0gdGhpcy5fY3R4O1xuICAgIGN0eC5rZXlzT25seSA9ICFjdHguaXNNYXRjaDtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICh2YWwsIGN1cnNvcikgeyBjYihjdXJzb3Iua2V5LCBjdXJzb3IpOyB9KTtcbiAgfVxuXG4gIC8qKiBDb2xsZWN0aW9uLmVhY2hVbmlxdWVLZXkoKVxuICAgKiBcbiAgICogaHR0cHM6Ly9kZXhpZS5vcmcvZG9jcy9Db2xsZWN0aW9uL0NvbGxlY3Rpb24uZWFjaFVuaXF1ZUtleSgpXG4gICAqIFxuICAgKiovXG4gIGVhY2hVbmlxdWVLZXkoY2I/KSB7XG4gICAgdGhpcy5fY3R4LnVuaXF1ZSA9IFwidW5pcXVlXCI7XG4gICAgcmV0dXJuIHRoaXMuZWFjaEtleShjYik7XG4gIH1cblxuICAvKiogQ29sbGVjdGlvbi5lYWNoUHJpbWFyeUtleSgpXG4gICAqIFxuICAgKiBodHRwczovL2RleGllLm9yZy9kb2NzL0NvbGxlY3Rpb24vQ29sbGVjdGlvbi5lYWNoUHJpbWFyeUtleSgpXG4gICAqIFxuICAgKiovXG4gIGVhY2hQcmltYXJ5S2V5KGNiPykge1xuICAgIHZhciBjdHggPSB0aGlzLl9jdHg7XG4gICAgY3R4LmtleXNPbmx5ID0gIWN0eC5pc01hdGNoO1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKHZhbCwgY3Vyc29yKSB7IGNiKGN1cnNvci5wcmltYXJ5S2V5LCBjdXJzb3IpOyB9KTtcbiAgfVxuXG4gIC8qKiBDb2xsZWN0aW9uLmtleXMoKVxuICAgKiBcbiAgICogaHR0cHM6Ly9kZXhpZS5vcmcvZG9jcy9Db2xsZWN0aW9uL0NvbGxlY3Rpb24ua2V5cygpXG4gICAqIFxuICAgKiovXG4gIGtleXMoY2I/KSB7XG4gICAgdmFyIGN0eCA9IHRoaXMuX2N0eDtcbiAgICBjdHgua2V5c09ubHkgPSAhY3R4LmlzTWF0Y2g7XG4gICAgdmFyIGEgPSBbXTtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uIChpdGVtLCBjdXJzb3IpIHtcbiAgICAgIGEucHVzaChjdXJzb3Iua2V5KTtcbiAgICB9KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBhO1xuICAgIH0pLnRoZW4oY2IpO1xuICB9XG5cbiAgLyoqIENvbGxlY3Rpb24ucHJpbWFyeUtleXMoKVxuICAgKiBcbiAgICogaHR0cHM6Ly9kZXhpZS5vcmcvZG9jcy9Db2xsZWN0aW9uL0NvbGxlY3Rpb24ucHJpbWFyeUtleXMoKVxuICAgKiBcbiAgICoqL1xuICBwcmltYXJ5S2V5cyhjYj8pIDogUHJvbWlzZUV4dGVuZGVkPEluZGV4YWJsZVR5cGVbXT4ge1xuICAgIHZhciBjdHggPSB0aGlzLl9jdHg7XG4gICAgaWYgKGN0eC5kaXIgPT09ICduZXh0JyAmJiBpc1BsYWluS2V5UmFuZ2UoY3R4LCB0cnVlKSAmJiBjdHgubGltaXQgPiAwKSB7XG4gICAgICAvLyBTcGVjaWFsIG9wdGltYXRpb24gaWYgd2UgY291bGQgdXNlIElEQk9iamVjdFN0b3JlLmdldEFsbEtleXMoKSBvclxuICAgICAgLy8gSURCS2V5UmFuZ2UuZ2V0QWxsS2V5cygpOlxuICAgICAgcmV0dXJuIHRoaXMuX3JlYWQodHJhbnMgPT4ge1xuICAgICAgICB2YXIgaW5kZXggPSBnZXRJbmRleE9yU3RvcmUoY3R4LCBjdHgudGFibGUuY29yZS5zY2hlbWEpO1xuICAgICAgICByZXR1cm4gY3R4LnRhYmxlLmNvcmUucXVlcnkoe1xuICAgICAgICAgIHRyYW5zLFxuICAgICAgICAgIHZhbHVlczogZmFsc2UsXG4gICAgICAgICAgbGltaXQ6IGN0eC5saW1pdCxcbiAgICAgICAgICBxdWVyeToge1xuICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICByYW5nZTogY3R4LnJhbmdlXG4gICAgICAgICAgfX0pO1xuICAgICAgfSkudGhlbigoe3Jlc3VsdH0pPT5yZXN1bHQpLnRoZW4oY2IpO1xuICAgIH1cbiAgICBjdHgua2V5c09ubHkgPSAhY3R4LmlzTWF0Y2g7XG4gICAgdmFyIGEgPSBbXTtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uIChpdGVtLCBjdXJzb3IpIHtcbiAgICAgIGEucHVzaChjdXJzb3IucHJpbWFyeUtleSk7XG4gICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gYTtcbiAgICB9KS50aGVuKGNiKTtcbiAgfVxuXG4gIC8qKiBDb2xsZWN0aW9uLnVuaXF1ZUtleXMoKVxuICAgKiBcbiAgICogaHR0cHM6Ly9kZXhpZS5vcmcvZG9jcy9Db2xsZWN0aW9uL0NvbGxlY3Rpb24udW5pcXVlS2V5cygpXG4gICAqIFxuICAgKiovXG4gIHVuaXF1ZUtleXMoY2I/KSB7XG4gICAgdGhpcy5fY3R4LnVuaXF1ZSA9IFwidW5pcXVlXCI7XG4gICAgcmV0dXJuIHRoaXMua2V5cyhjYik7XG4gIH1cblxuICAvKiogQ29sbGVjdGlvbi5maXJzdEtleSgpXG4gICAqIFxuICAgKiBodHRwczovL2RleGllLm9yZy9kb2NzL0NvbGxlY3Rpb24vQ29sbGVjdGlvbi5maXJzdEtleSgpXG4gICAqIFxuICAgKiovXG4gIGZpcnN0S2V5KGNiPykge1xuICAgIHJldHVybiB0aGlzLmxpbWl0KDEpLmtleXMoZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGFbMF07IH0pLnRoZW4oY2IpO1xuICB9XG5cbiAgLyoqIENvbGxlY3Rpb24ubGFzdEtleSgpXG4gICAqIFxuICAgKiBodHRwczovL2RleGllLm9yZy9kb2NzL0NvbGxlY3Rpb24vQ29sbGVjdGlvbi5sYXN0S2V5KClcbiAgICogXG4gICAqKi9cbiAgbGFzdEtleShjYj8pIHtcbiAgICByZXR1cm4gdGhpcy5yZXZlcnNlKCkuZmlyc3RLZXkoY2IpO1xuICB9XG5cbiAgLyoqIENvbGxlY3Rpb24uZGlzdGluY3QoKVxuICAgKiBcbiAgICogaHR0cHM6Ly9kZXhpZS5vcmcvZG9jcy9Db2xsZWN0aW9uL0NvbGxlY3Rpb24uZGlzdGluY3QoKVxuICAgKiBcbiAgICoqL1xuICBkaXN0aW5jdCgpIHtcbiAgICB2YXIgY3R4ID0gdGhpcy5fY3R4LFxuICAgICAgaWR4ID0gY3R4LmluZGV4ICYmIGN0eC50YWJsZS5zY2hlbWEuaWR4QnlOYW1lW2N0eC5pbmRleF07XG4gICAgaWYgKCFpZHggfHwgIWlkeC5tdWx0aSkgcmV0dXJuIHRoaXM7IC8vIGRpc3RpbmN0KCkgb25seSBtYWtlcyBkaWZmZXJlbmNpZXMgb24gbXVsdGlFbnRyeSBpbmRleGVzLlxuICAgIHZhciBzZXQgPSB7fTtcbiAgICBhZGRGaWx0ZXIodGhpcy5fY3R4LCBmdW5jdGlvbiAoY3Vyc29yOiBEQkNvcmVDdXJzb3IpIHtcbiAgICAgIHZhciBzdHJLZXkgPSBjdXJzb3IucHJpbWFyeUtleS50b1N0cmluZygpOyAvLyBDb252ZXJ0cyBhbnkgRGF0ZSB0byBTdHJpbmcsIFN0cmluZyB0byBTdHJpbmcsIE51bWJlciB0byBTdHJpbmcgYW5kIEFycmF5IHRvIGNvbW1hLXNlcGFyYXRlZCBzdHJpbmdcbiAgICAgIHZhciBmb3VuZCA9IGhhc093bihzZXQsIHN0cktleSk7XG4gICAgICBzZXRbc3RyS2V5XSA9IHRydWU7XG4gICAgICByZXR1cm4gIWZvdW5kO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy9cbiAgLy8gTWV0aG9kcyB0aGF0IG11dGF0ZSBzdG9yYWdlXG4gIC8vXG5cbiAgLyoqIENvbGxlY3Rpb24ubW9kaWZ5KClcbiAgICogXG4gICAqIGh0dHBzOi8vZGV4aWUub3JnL2RvY3MvQ29sbGVjdGlvbi9Db2xsZWN0aW9uLm1vZGlmeSgpXG4gICAqIFxuICAgKiovXG4gIG1vZGlmeShjaGFuZ2VzOiB7IFtrZXlQYXRoOiBzdHJpbmddOiBhbnkgfSkgOiBQcm9taXNlRXh0ZW5kZWQ8bnVtYmVyPlxuICBtb2RpZnkoY2hhbmdlczogKG9iajogYW55LCBjdHg6e3ZhbHVlOiBhbnksIHByaW1LZXk6IEluZGV4YWJsZVR5cGV9KSA9PiB2b2lkIHwgYm9vbGVhbik6IFByb21pc2VFeHRlbmRlZDxudW1iZXI+IHtcbiAgICB2YXIgY3R4ID0gdGhpcy5fY3R4O1xuICAgIHJldHVybiB0aGlzLl93cml0ZSh0cmFucyA9PiB7XG4gICAgICB2YXIgbW9kaWZ5ZXI6IChvYmo6IGFueSwgY3R4Ont2YWx1ZTogYW55LCBwcmltS2V5OiBJbmRleGFibGVUeXBlfSkgPT4gdm9pZCB8IGJvb2xlYW5cbiAgICAgIGlmICh0eXBlb2YgY2hhbmdlcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBDaGFuZ2VzIGlzIGEgZnVuY3Rpb24gdGhhdCBtYXkgdXBkYXRlLCBhZGQgb3IgZGVsZXRlIHByb3B0ZXJ0aWVzIG9yIGV2ZW4gcmVxdWlyZSBhIGRlbGV0aW9uIHRoZSBvYmplY3QgaXRzZWxmIChkZWxldGUgdGhpcy5pdGVtKVxuICAgICAgICBtb2RpZnllciA9IGNoYW5nZXM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBjaGFuZ2VzIGlzIGEgc2V0IG9mIHtrZXlQYXRoOiB2YWx1ZX0gYW5kIG5vIG9uZSBpcyBsaXN0ZW5pbmcgdG8gdGhlIHVwZGF0aW5nIGhvb2suXG4gICAgICAgIHZhciBrZXlQYXRocyA9IGtleXMoY2hhbmdlcyk7XG4gICAgICAgIHZhciBudW1LZXlzID0ga2V5UGF0aHMubGVuZ3RoO1xuICAgICAgICBtb2RpZnllciA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgdmFyIGFueXRoaW5nTW9kaWZpZWQgPSBmYWxzZTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bUtleXM7ICsraSkge1xuICAgICAgICAgICAgdmFyIGtleVBhdGggPSBrZXlQYXRoc1tpXSwgdmFsID0gY2hhbmdlc1trZXlQYXRoXTtcbiAgICAgICAgICAgIGlmIChnZXRCeUtleVBhdGgoaXRlbSwga2V5UGF0aCkgIT09IHZhbCkge1xuICAgICAgICAgICAgICBzZXRCeUtleVBhdGgoaXRlbSwga2V5UGF0aCwgdmFsKTsgLy8gQWRkaW5nIHtrZXlQYXRoOiB1bmRlZmluZWR9IG1lYW5zIHRoYXQgdGhlIGtleVBhdGggc2hvdWxkIGJlIGRlbGV0ZWQuIEhhbmRsZWQgYnkgc2V0QnlLZXlQYXRoXG4gICAgICAgICAgICAgIGFueXRoaW5nTW9kaWZpZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gYW55dGhpbmdNb2RpZmllZDtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgY29yZVRhYmxlID0gY3R4LnRhYmxlLmNvcmU7XG4gICAgICBjb25zdCB7b3V0Ym91bmQsIGV4dHJhY3RLZXl9ID0gY29yZVRhYmxlLnNjaGVtYS5wcmltYXJ5S2V5O1xuICAgICAgY29uc3QgbGltaXQgPSB0aGlzLmRiLl9vcHRpb25zLm1vZGlmeUNodW5rU2l6ZSB8fCAyMDA7XG4gICAgICBjb25zdCB0b3RhbEZhaWx1cmVzID0gW107XG4gICAgICBsZXQgc3VjY2Vzc0NvdW50ID0gMDtcbiAgICAgIGNvbnN0IGZhaWxlZEtleXM6IEluZGV4YWJsZVR5cGVbXSA9IFtdO1xuICAgICAgY29uc3QgYXBwbHlNdXRhdGVSZXN1bHQgPSAoZXhwZWN0ZWRDb3VudDogbnVtYmVyLCByZXM6IERCQ29yZU11dGF0ZVJlc3BvbnNlKSA9PiB7XG4gICAgICAgIGNvbnN0IHtmYWlsdXJlcywgbnVtRmFpbHVyZXN9ID0gcmVzO1xuICAgICAgICBzdWNjZXNzQ291bnQgKz0gZXhwZWN0ZWRDb3VudCAtIG51bUZhaWx1cmVzO1xuICAgICAgICBmb3IgKGxldCBwb3Mgb2Yga2V5cyhmYWlsdXJlcykpIHtcbiAgICAgICAgICB0b3RhbEZhaWx1cmVzLnB1c2goZmFpbHVyZXNbcG9zXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmNsb25lKCkucHJpbWFyeUtleXMoKS50aGVuKGtleXMgPT4ge1xuXG4gICAgICAgIGNvbnN0IG5leHRDaHVuayA9IChvZmZzZXQ6IG51bWJlcikgPT4ge1xuICAgICAgICAgIGNvbnN0IGNvdW50ID0gTWF0aC5taW4obGltaXQsIGtleXMubGVuZ3RoIC0gb2Zmc2V0KTtcbiAgICAgICAgICByZXR1cm4gY29yZVRhYmxlLmdldE1hbnkoe1xuICAgICAgICAgICAgdHJhbnMsXG4gICAgICAgICAgICBrZXlzOiBrZXlzLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgY291bnQpLFxuICAgICAgICAgICAgY2FjaGU6IFwiaW1tdXRhYmxlXCIgLy8gT3B0aW1pemUgZm9yIDIgdGhpbmdzOlxuICAgICAgICAgICAgLy8gMSkgb2JzZXJ2YWJpbGl0eS1taWRkbGV3YXJlIGNhbiB0cmFjayBjaGFuZ2VzIGJldHRlci5cbiAgICAgICAgICAgIC8vIDIpIGhvb2tzIG1pZGRsZXdhcmUgZG9uJ3QgaGF2ZSB0byBxdWVyeSB0aGUgZXhpc3RpbmcgdmFsdWVzIGFnYWluIHdoZW4gdHJhY2tpbmcgY2hhbmdlcy5cbiAgICAgICAgICAgIC8vIFdlIGNhbiB1c2UgXCJpbW11dGFibGVcIiBiZWNhdXNlIHdlIHByb21pc2UgdG8gbm90IHRvdWNoIHRoZSB2YWx1ZXMgd2UgcmV0cmlldmUgaGVyZSFcbiAgICAgICAgICB9KS50aGVuKHZhbHVlcyA9PiB7XG4gICAgICAgICAgICBjb25zdCBhZGRWYWx1ZXMgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IHB1dFZhbHVlcyA9IFtdO1xuICAgICAgICAgICAgY29uc3QgcHV0S2V5cyA9IG91dGJvdW5kID8gW10gOiBudWxsO1xuICAgICAgICAgICAgY29uc3QgZGVsZXRlS2V5cyA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgaT0wOyBpPGNvdW50OyArK2kpIHtcbiAgICAgICAgICAgICAgY29uc3Qgb3JpZ1ZhbHVlID0gdmFsdWVzW2ldO1xuICAgICAgICAgICAgICBjb25zdCBjdHggPSB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGRlZXBDbG9uZShvcmlnVmFsdWUpLFxuICAgICAgICAgICAgICAgIHByaW1LZXk6IGtleXNbb2Zmc2V0K2ldXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIGlmIChtb2RpZnllci5jYWxsKGN0eCwgY3R4LnZhbHVlLCBjdHgpICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGlmIChjdHgudmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgLy8gRGVsZXRlZFxuICAgICAgICAgICAgICAgICAgZGVsZXRlS2V5cy5wdXNoKGtleXNbb2Zmc2V0K2ldKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFvdXRib3VuZCAmJiBjbXAoZXh0cmFjdEtleShvcmlnVmFsdWUpLCBleHRyYWN0S2V5KGN0eC52YWx1ZSkpICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAvLyBDaGFuZ2VkIHByaW1hcnkga2V5IG9mIGluYm91bmRcbiAgICAgICAgICAgICAgICAgIGRlbGV0ZUtleXMucHVzaChrZXlzW29mZnNldCtpXSk7XG4gICAgICAgICAgICAgICAgICBhZGRWYWx1ZXMucHVzaChjdHgudmFsdWUpXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIC8vIENoYW5nZWQgdmFsdWVcbiAgICAgICAgICAgICAgICAgIHB1dFZhbHVlcy5wdXNoKGN0eC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICBpZiAob3V0Ym91bmQpIHB1dEtleXMucHVzaChrZXlzW29mZnNldCtpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjcml0ZXJpYSA9IGlzUGxhaW5LZXlSYW5nZShjdHgpICYmXG4gICAgICAgICAgICAgIGN0eC5saW1pdCA9PT0gSW5maW5pdHkgJiZcbiAgICAgICAgICAgICAgKHR5cGVvZiBjaGFuZ2VzICE9PSAnZnVuY3Rpb24nIHx8IGNoYW5nZXMgPT09IGRlbGV0ZUNhbGxiYWNrKSAmJiB7XG4gICAgICAgICAgICAgICAgaW5kZXg6IGN0eC5pbmRleCxcbiAgICAgICAgICAgICAgICByYW5nZTogY3R4LnJhbmdlXG4gICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoYWRkVmFsdWVzLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgICAgICAgY29yZVRhYmxlLm11dGF0ZSh7dHJhbnMsIHR5cGU6ICdhZGQnLCB2YWx1ZXM6IGFkZFZhbHVlc30pXG4gICAgICAgICAgICAgICAgLnRoZW4ocmVzID0+IHtcbiAgICAgICAgICAgICAgICAgIGZvciAobGV0IHBvcyBpbiByZXMuZmFpbHVyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGZyb20gZGVsZXRlS2V5cyB0aGUga2V5IG9mIHRoZSBvYmplY3QgdGhhdCBmYWlsZWQgdG8gY2hhbmdlIGl0cyBwcmltYXJ5IGtleVxuICAgICAgICAgICAgICAgICAgICBkZWxldGVLZXlzLnNwbGljZShwYXJzZUludChwb3MpLCAxKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGFwcGx5TXV0YXRlUmVzdWx0KGFkZFZhbHVlcy5sZW5ndGgsIHJlcyk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICkudGhlbigoKT0+KHB1dFZhbHVlcy5sZW5ndGggPiAwIHx8IChjcml0ZXJpYSAmJiB0eXBlb2YgY2hhbmdlcyA9PT0gJ29iamVjdCcpKSAmJlxuICAgICAgICAgICAgICAgIGNvcmVUYWJsZS5tdXRhdGUoe1xuICAgICAgICAgICAgICAgICAgdHJhbnMsXG4gICAgICAgICAgICAgICAgICB0eXBlOiAncHV0JyxcbiAgICAgICAgICAgICAgICAgIGtleXM6IHB1dEtleXMsXG4gICAgICAgICAgICAgICAgICB2YWx1ZXM6IHB1dFZhbHVlcyxcbiAgICAgICAgICAgICAgICAgIGNyaXRlcmlhLFxuICAgICAgICAgICAgICAgICAgY2hhbmdlU3BlYzogdHlwZW9mIGNoYW5nZXMgIT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgICAgICAgICAgJiYgY2hhbmdlc1xuICAgICAgICAgICAgICAgIH0pLnRoZW4ocmVzPT5hcHBseU11dGF0ZVJlc3VsdChwdXRWYWx1ZXMubGVuZ3RoLCByZXMpKVxuICAgICAgICAgICAgKS50aGVuKCgpPT4oZGVsZXRlS2V5cy5sZW5ndGggPiAwIHx8IChjcml0ZXJpYSAmJiBjaGFuZ2VzID09PSBkZWxldGVDYWxsYmFjaykpICYmXG4gICAgICAgICAgICAgICAgY29yZVRhYmxlLm11dGF0ZSh7XG4gICAgICAgICAgICAgICAgICB0cmFucyxcbiAgICAgICAgICAgICAgICAgIHR5cGU6ICdkZWxldGUnLFxuICAgICAgICAgICAgICAgICAga2V5czogZGVsZXRlS2V5cyxcbiAgICAgICAgICAgICAgICAgIGNyaXRlcmlhXG4gICAgICAgICAgICAgICAgfSkudGhlbihyZXM9PmFwcGx5TXV0YXRlUmVzdWx0KGRlbGV0ZUtleXMubGVuZ3RoLCByZXMpKVxuICAgICAgICAgICAgKS50aGVuKCgpPT57XG4gICAgICAgICAgICAgIHJldHVybiBrZXlzLmxlbmd0aCA+IG9mZnNldCArIGNvdW50ICYmIG5leHRDaHVuayhvZmZzZXQgKyBsaW1pdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXh0Q2h1bmsoMCkudGhlbigoKT0+e1xuICAgICAgICAgIGlmICh0b3RhbEZhaWx1cmVzLmxlbmd0aCA+IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgTW9kaWZ5RXJyb3IoXCJFcnJvciBtb2RpZnlpbmcgb25lIG9yIG1vcmUgb2JqZWN0c1wiLCB0b3RhbEZhaWx1cmVzLCBzdWNjZXNzQ291bnQsIGZhaWxlZEtleXMgYXMgSW5kZXhhYmxlVHlwZUFycmF5UmVhZG9ubHkpO1xuXG4gICAgICAgICAgcmV0dXJuIGtleXMubGVuZ3RoO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgfSk7XG4gIH1cblxuICAvKiogQ29sbGVjdGlvbi5kZWxldGUoKVxuICAgKiBcbiAgICogaHR0cHM6Ly9kZXhpZS5vcmcvZG9jcy9Db2xsZWN0aW9uL0NvbGxlY3Rpb24uZGVsZXRlKClcbiAgICogXG4gICAqKi9cbiAgZGVsZXRlKCkgOiBQcm9taXNlRXh0ZW5kZWQ8bnVtYmVyPiB7XG4gICAgdmFyIGN0eCA9IHRoaXMuX2N0eCxcbiAgICAgIHJhbmdlID0gY3R4LnJhbmdlO1xuICAgICAgLy9kZWxldGluZ0hvb2sgPSBjdHgudGFibGUuaG9vay5kZWxldGluZy5maXJlLFxuICAgICAgLy9oYXNEZWxldGVIb29rID0gZGVsZXRpbmdIb29rICE9PSBub3A7XG4gICAgaWYgKGlzUGxhaW5LZXlSYW5nZShjdHgpICYmXG4gICAgICAoKGN0eC5pc1ByaW1LZXkgJiYgIWhhbmdzT25EZWxldGVMYXJnZUtleVJhbmdlKSB8fCByYW5nZS50eXBlID09PSBEQkNvcmVSYW5nZVR5cGUuQW55KSkgLy8gaWYgbm8gcmFuZ2UsIHdlJ2xsIHVzZSBjbGVhcigpLlxuICAgIHtcbiAgICAgIC8vIE1heSB1c2UgSURCT2JqZWN0U3RvcmUuZGVsZXRlKElEQktleVJhbmdlKSBpbiB0aGlzIGNhc2UgKElzc3VlICMyMDgpXG4gICAgICAvLyBGb3IgY2hyb21pdW0sIHRoaXMgaXMgdGhlIHdheSBtb3N0IG9wdGltaXplZCB2ZXJzaW9uLlxuICAgICAgLy8gRm9yIElFL0VkZ2UsIHRoaXMgY291bGQgaGFuZyB0aGUgaW5kZXhlZERCIGVuZ2luZSBhbmQgbWFrZSBvcGVyYXRpbmcgc3lzdGVtIGluc3RhYmxlXG4gICAgICAvLyAoaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vZGZhaGxhbmRlci81YTM5MzI4ZjAyOWRlMTgyMjJjZjIxMjVkNTZjMzhmNylcbiAgICAgIHJldHVybiB0aGlzLl93cml0ZSh0cmFucyA9PiB7XG4gICAgICAgIC8vIE91ciBBUEkgY29udHJhY3QgaXMgdG8gcmV0dXJuIGEgY291bnQgb2YgZGVsZXRlZCBpdGVtcywgc28gd2UgaGF2ZSB0byBjb3VudCgpIGJlZm9yZSBkZWxldGUoKS5cbiAgICAgICAgY29uc3Qge3ByaW1hcnlLZXl9ID0gY3R4LnRhYmxlLmNvcmUuc2NoZW1hO1xuICAgICAgICBjb25zdCBjb3JlUmFuZ2UgPSByYW5nZTtcbiAgICAgICAgcmV0dXJuIGN0eC50YWJsZS5jb3JlLmNvdW50KHt0cmFucywgcXVlcnk6IHtpbmRleDogcHJpbWFyeUtleSwgcmFuZ2U6IGNvcmVSYW5nZX19KS50aGVuKGNvdW50ID0+IHtcbiAgICAgICAgICByZXR1cm4gY3R4LnRhYmxlLmNvcmUubXV0YXRlKHt0cmFucywgdHlwZTogJ2RlbGV0ZVJhbmdlJywgcmFuZ2U6IGNvcmVSYW5nZX0pXG4gICAgICAgICAgLnRoZW4oKHtmYWlsdXJlcywgbGFzdFJlc3VsdCwgcmVzdWx0cywgbnVtRmFpbHVyZXN9KSA9PiB7XG4gICAgICAgICAgICBpZiAobnVtRmFpbHVyZXMpIHRocm93IG5ldyBNb2RpZnlFcnJvcihcIkNvdWxkIG5vdCBkZWxldGUgc29tZSB2YWx1ZXNcIixcbiAgICAgICAgICAgICAgT2JqZWN0LmtleXMoZmFpbHVyZXMpLm1hcChwb3MgPT4gZmFpbHVyZXNbcG9zXSksXG4gICAgICAgICAgICAgIGNvdW50IC0gbnVtRmFpbHVyZXMpO1xuICAgICAgICAgICAgcmV0dXJuIGNvdW50IC0gbnVtRmFpbHVyZXM7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMubW9kaWZ5KGRlbGV0ZUNhbGxiYWNrKTtcbiAgfVxufVxuXG5jb25zdCBkZWxldGVDYWxsYmFjayA9ICh2YWx1ZSwgY3R4KSA9PiBjdHgudmFsdWUgPSBudWxsO1xuIiwgImltcG9ydCB7IERleGllIH0gZnJvbSAnLi4vLi4vY2xhc3Nlcy9kZXhpZSc7XG5pbXBvcnQgeyBtYWtlQ2xhc3NDb25zdHJ1Y3RvciB9IGZyb20gJy4uLy4uL2Z1bmN0aW9ucy9tYWtlLWNsYXNzLWNvbnN0cnVjdG9yJztcbmltcG9ydCB7IENvbGxlY3Rpb24gfSBmcm9tICcuL2NvbGxlY3Rpb24nO1xuaW1wb3J0IHsgV2hlcmVDbGF1c2UgfSBmcm9tICcuLi93aGVyZS1jbGF1c2Uvd2hlcmUtY2xhdXNlJztcbmltcG9ydCB7IEFueVJhbmdlIH0gZnJvbSAnLi4vLi4vZGJjb3JlL2tleXJhbmdlJztcbmltcG9ydCB7IERCQ29yZUtleVJhbmdlIH0gZnJvbSAnLi4vLi4vcHVibGljL3R5cGVzL2RiY29yZSc7XG5pbXBvcnQgeyBtaXJyb3IgfSBmcm9tICcuLi8uLi9mdW5jdGlvbnMvY2hhaW5pbmctZnVuY3Rpb25zJztcblxuLyoqIENvbnN0cnVjdHMgYSBDb2xsZWN0aW9uIGluc3RhbmNlLiAqL1xuZXhwb3J0IGludGVyZmFjZSBDb2xsZWN0aW9uQ29uc3RydWN0b3Ige1xuICBuZXcod2hlcmVDbGF1c2U/OiBXaGVyZUNsYXVzZSB8IG51bGwsIGtleVJhbmdlR2VuZXJhdG9yPzogKCkgPT4gREJDb3JlS2V5UmFuZ2UpOiBDb2xsZWN0aW9uO1xuICBwcm90b3R5cGU6IENvbGxlY3Rpb247XG59XG5cbi8qKiBHZW5lcmF0ZXMgYSBDb2xsZWN0aW9uIGNvbnN0cnVjdG9yIGJvdW5kIHRvIGdpdmVuIERleGllIGluc3RhbmNlLlxuICogXG4gKiBUaGUgcHVycG9zZSBvZiBoYXZpbmcgZHluYW1pY2FsbHkgY3JlYXRlZCBjb25zdHJ1Y3RvcnMsIGlzIHRvIGFsbG93XG4gKiBhZGRvbnMgdG8gZXh0ZW5kIGNsYXNzZXMgZm9yIGEgY2VydGFpbiBEZXhpZSBpbnN0YW5jZSB3aXRob3V0IGFmZmVjdGluZ1xuICogb3RoZXIgZGIgaW5zdGFuY2VzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ29sbGVjdGlvbkNvbnN0cnVjdG9yKGRiOiBEZXhpZSkge1xuICByZXR1cm4gbWFrZUNsYXNzQ29uc3RydWN0b3I8Q29sbGVjdGlvbkNvbnN0cnVjdG9yPihcbiAgICBDb2xsZWN0aW9uLnByb3RvdHlwZSxcblxuICAgIGZ1bmN0aW9uIENvbGxlY3Rpb24oXG4gICAgICB0aGlzOiBDb2xsZWN0aW9uLFxuICAgICAgd2hlcmVDbGF1c2U/OiBXaGVyZUNsYXVzZSB8IG51bGwsXG4gICAgICBrZXlSYW5nZUdlbmVyYXRvcj86ICgpID0+IERCQ29yZUtleVJhbmdlKVxuICAgIHtcbiAgICAgIHRoaXMuZGIgPSBkYjtcbiAgICAgIGxldCBrZXlSYW5nZSA9IEFueVJhbmdlLCBlcnJvciA9IG51bGw7XG4gICAgICBpZiAoa2V5UmFuZ2VHZW5lcmF0b3IpIHRyeSB7XG4gICAgICAgIGtleVJhbmdlID0ga2V5UmFuZ2VHZW5lcmF0b3IoKTtcbiAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgIGVycm9yID0gZXg7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHdoZXJlQ3R4ID0gd2hlcmVDbGF1c2UuX2N0eDtcbiAgICAgIGNvbnN0IHRhYmxlID0gd2hlcmVDdHgudGFibGU7XG4gICAgICBjb25zdCByZWFkaW5nSG9vayA9IHRhYmxlLmhvb2sucmVhZGluZy5maXJlO1xuICAgICAgdGhpcy5fY3R4ID0ge1xuICAgICAgICB0YWJsZTogdGFibGUsXG4gICAgICAgIGluZGV4OiB3aGVyZUN0eC5pbmRleCxcbiAgICAgICAgaXNQcmltS2V5OiAoIXdoZXJlQ3R4LmluZGV4IHx8ICh0YWJsZS5zY2hlbWEucHJpbUtleS5rZXlQYXRoICYmIHdoZXJlQ3R4LmluZGV4ID09PSB0YWJsZS5zY2hlbWEucHJpbUtleS5uYW1lKSksXG4gICAgICAgIHJhbmdlOiBrZXlSYW5nZSxcbiAgICAgICAga2V5c09ubHk6IGZhbHNlLFxuICAgICAgICBkaXI6IFwibmV4dFwiLFxuICAgICAgICB1bmlxdWU6IFwiXCIsXG4gICAgICAgIGFsZ29yaXRobTogbnVsbCxcbiAgICAgICAgZmlsdGVyOiBudWxsLFxuICAgICAgICByZXBsYXlGaWx0ZXI6IG51bGwsXG4gICAgICAgIGp1c3RMaW1pdDogdHJ1ZSwgLy8gVHJ1ZSBpZiBhIHJlcGxheUZpbHRlciBpcyBqdXN0IGEgZmlsdGVyIHRoYXQgcGVyZm9ybXMgYSBcImxpbWl0XCIgb3BlcmF0aW9uIChvciBub25lIGF0IGFsbClcbiAgICAgICAgaXNNYXRjaDogbnVsbCxcbiAgICAgICAgb2Zmc2V0OiAwLFxuICAgICAgICBsaW1pdDogSW5maW5pdHksXG4gICAgICAgIGVycm9yOiBlcnJvciwgLy8gSWYgc2V0LCBhbnkgcHJvbWlzZSBtdXN0IGJlIHJlamVjdGVkIHdpdGggdGhpcyBlcnJvclxuICAgICAgICBvcjogd2hlcmVDdHgub3IsXG4gICAgICAgIHZhbHVlTWFwcGVyOiByZWFkaW5nSG9vayAhPT0gbWlycm9yID8gcmVhZGluZ0hvb2sgOiBudWxsXG4gICAgICB9O1xuICAgIH1cbiAgKTtcbn1cbiIsICJpbXBvcnQgeyBJbmRleGFibGVUeXBlIH0gZnJvbSAnLi4vcHVibGljL3R5cGVzL2luZGV4YWJsZS10eXBlJztcblxuZXhwb3J0IGZ1bmN0aW9uIHNpbXBsZUNvbXBhcmUoYSwgYikge1xuICByZXR1cm4gYSA8IGIgPyAtMSA6IGEgPT09IGIgPyAwIDogMTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNpbXBsZUNvbXBhcmVSZXZlcnNlKGEsIGIpIHtcbiAgcmV0dXJuIGEgPiBiID8gLTEgOiBhID09PSBiID8gMCA6IDE7XG59XG4iLCAiaW1wb3J0IHsgV2hlcmVDbGF1c2UgfSBmcm9tICcuL3doZXJlLWNsYXVzZSc7XG5pbXBvcnQgeyBDb2xsZWN0aW9uIH0gZnJvbSAnLi4vY29sbGVjdGlvbic7XG5pbXBvcnQgeyBTVFJJTkdfRVhQRUNURUQgfSBmcm9tICcuLi8uLi9nbG9iYWxzL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBzaW1wbGVDb21wYXJlLCBzaW1wbGVDb21wYXJlUmV2ZXJzZSB9IGZyb20gJy4uLy4uL2Z1bmN0aW9ucy9jb21wYXJlLWZ1bmN0aW9ucyc7XG5pbXBvcnQgeyBJbmRleGFibGVUeXBlIH0gZnJvbSAnLi4vLi4vcHVibGljJztcbmltcG9ydCB7IERCQ29yZUtleVJhbmdlLCBEQkNvcmVSYW5nZVR5cGUgfSBmcm9tICcuLi8uLi9wdWJsaWMvdHlwZXMvZGJjb3JlJztcblxuZXhwb3J0IGZ1bmN0aW9uIGZhaWwoY29sbGVjdGlvbk9yV2hlcmVDbGF1c2U6IENvbGxlY3Rpb24gfCBXaGVyZUNsYXVzZSwgZXJyLCBUPykge1xuICB2YXIgY29sbGVjdGlvbiA9IGNvbGxlY3Rpb25PcldoZXJlQ2xhdXNlIGluc3RhbmNlb2YgV2hlcmVDbGF1c2UgP1xuICAgICAgbmV3IGNvbGxlY3Rpb25PcldoZXJlQ2xhdXNlLkNvbGxlY3Rpb24gKGNvbGxlY3Rpb25PcldoZXJlQ2xhdXNlKSA6XG4gICAgICBjb2xsZWN0aW9uT3JXaGVyZUNsYXVzZTtcbiAgICAgIFxuICBjb2xsZWN0aW9uLl9jdHguZXJyb3IgPSBUID8gbmV3IFQoZXJyKSA6IG5ldyBUeXBlRXJyb3IoZXJyKTtcbiAgcmV0dXJuIGNvbGxlY3Rpb247XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlbXB0eUNvbGxlY3Rpb24od2hlcmVDbGF1c2U6IFdoZXJlQ2xhdXNlKSB7XG4gIHJldHVybiBuZXcgd2hlcmVDbGF1c2UuQ29sbGVjdGlvbiAod2hlcmVDbGF1c2UsICgpID0+IHJhbmdlRXF1YWwoXCJcIikpLmxpbWl0KDApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdXBwZXJGYWN0b3J5KGRpcjogJ25leHQnIHwgJ3ByZXYnKSB7XG4gIHJldHVybiBkaXIgPT09IFwibmV4dFwiID9cbiAgICAoczogc3RyaW5nKSA9PiBzLnRvVXBwZXJDYXNlKCkgOlxuICAgIChzOiBzdHJpbmcpID0+IHMudG9Mb3dlckNhc2UoKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxvd2VyRmFjdG9yeShkaXI6ICduZXh0JyB8ICdwcmV2Jykge1xuICByZXR1cm4gZGlyID09PSBcIm5leHRcIiA/XG4gICAgKHM6IHN0cmluZykgPT4gcy50b0xvd2VyQ2FzZSgpIDpcbiAgICAoczogc3RyaW5nKSA9PiBzLnRvVXBwZXJDYXNlKCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBuZXh0Q2FzaW5nKGtleSwgbG93ZXJLZXksIHVwcGVyTmVlZGxlLCBsb3dlck5lZWRsZSwgY21wLCBkaXIpIHtcbiAgdmFyIGxlbmd0aCA9IE1hdGgubWluKGtleS5sZW5ndGgsIGxvd2VyTmVlZGxlLmxlbmd0aCk7XG4gIHZhciBsbHAgPSAtMTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgdmFyIGx3cktleUNoYXIgPSBsb3dlcktleVtpXTtcbiAgICAgIGlmIChsd3JLZXlDaGFyICE9PSBsb3dlck5lZWRsZVtpXSkge1xuICAgICAgICAgIGlmIChjbXAoa2V5W2ldLCB1cHBlck5lZWRsZVtpXSkgPCAwKSByZXR1cm4ga2V5LnN1YnN0cigwLCBpKSArIHVwcGVyTmVlZGxlW2ldICsgdXBwZXJOZWVkbGUuc3Vic3RyKGkgKyAxKTtcbiAgICAgICAgICBpZiAoY21wKGtleVtpXSwgbG93ZXJOZWVkbGVbaV0pIDwgMCkgcmV0dXJuIGtleS5zdWJzdHIoMCwgaSkgKyBsb3dlck5lZWRsZVtpXSArIHVwcGVyTmVlZGxlLnN1YnN0cihpICsgMSk7XG4gICAgICAgICAgaWYgKGxscCA+PSAwKSByZXR1cm4ga2V5LnN1YnN0cigwLCBsbHApICsgbG93ZXJLZXlbbGxwXSArIHVwcGVyTmVlZGxlLnN1YnN0cihsbHAgKyAxKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmIChjbXAoa2V5W2ldLCBsd3JLZXlDaGFyKSA8IDApIGxscCA9IGk7XG4gIH1cbiAgaWYgKGxlbmd0aCA8IGxvd2VyTmVlZGxlLmxlbmd0aCAmJiBkaXIgPT09IFwibmV4dFwiKSByZXR1cm4ga2V5ICsgdXBwZXJOZWVkbGUuc3Vic3RyKGtleS5sZW5ndGgpO1xuICBpZiAobGVuZ3RoIDwga2V5Lmxlbmd0aCAmJiBkaXIgPT09IFwicHJldlwiKSByZXR1cm4ga2V5LnN1YnN0cigwLCB1cHBlck5lZWRsZS5sZW5ndGgpO1xuICByZXR1cm4gKGxscCA8IDAgPyBudWxsIDoga2V5LnN1YnN0cigwLCBsbHApICsgbG93ZXJOZWVkbGVbbGxwXSArIHVwcGVyTmVlZGxlLnN1YnN0cihsbHAgKyAxKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGRJZ25vcmVDYXNlQWxnb3JpdGhtKHdoZXJlQ2xhdXNlOiBXaGVyZUNsYXVzZSwgbWF0Y2gsIG5lZWRsZXMsIHN1ZmZpeCkge1xuICAvLy8gPHBhcmFtIG5hbWU9XCJuZWVkbGVzXCIgdHlwZT1cIkFycmF5XCIgZWxlbWVudFR5cGU9XCJTdHJpbmdcIj48L3BhcmFtPlxuICB2YXIgdXBwZXIsIGxvd2VyLCBjb21wYXJlLCB1cHBlck5lZWRsZXMsIGxvd2VyTmVlZGxlcywgZGlyZWN0aW9uLCBuZXh0S2V5U3VmZml4LFxuICAgICAgbmVlZGxlc0xlbiA9IG5lZWRsZXMubGVuZ3RoO1xuICBpZiAoIW5lZWRsZXMuZXZlcnkocyA9PiB0eXBlb2YgcyA9PT0gJ3N0cmluZycpKSB7XG4gICAgICByZXR1cm4gZmFpbCh3aGVyZUNsYXVzZSwgU1RSSU5HX0VYUEVDVEVEKTtcbiAgfVxuICBmdW5jdGlvbiBpbml0RGlyZWN0aW9uKGRpcikge1xuICAgICAgdXBwZXIgPSB1cHBlckZhY3RvcnkoZGlyKTtcbiAgICAgIGxvd2VyID0gbG93ZXJGYWN0b3J5KGRpcik7XG4gICAgICBjb21wYXJlID0gKGRpciA9PT0gXCJuZXh0XCIgPyBzaW1wbGVDb21wYXJlIDogc2ltcGxlQ29tcGFyZVJldmVyc2UpO1xuICAgICAgdmFyIG5lZWRsZUJvdW5kcyA9IG5lZWRsZXMubWFwKGZ1bmN0aW9uIChuZWVkbGUpe1xuICAgICAgICAgIHJldHVybiB7bG93ZXI6IGxvd2VyKG5lZWRsZSksIHVwcGVyOiB1cHBlcihuZWVkbGUpfTtcbiAgICAgIH0pLnNvcnQoZnVuY3Rpb24oYSxiKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbXBhcmUoYS5sb3dlciwgYi5sb3dlcik7XG4gICAgICB9KTtcbiAgICAgIHVwcGVyTmVlZGxlcyA9IG5lZWRsZUJvdW5kcy5tYXAoZnVuY3Rpb24gKG5iKXsgcmV0dXJuIG5iLnVwcGVyOyB9KTtcbiAgICAgIGxvd2VyTmVlZGxlcyA9IG5lZWRsZUJvdW5kcy5tYXAoZnVuY3Rpb24gKG5iKXsgcmV0dXJuIG5iLmxvd2VyOyB9KTtcbiAgICAgIGRpcmVjdGlvbiA9IGRpcjtcbiAgICAgIG5leHRLZXlTdWZmaXggPSAoZGlyID09PSBcIm5leHRcIiA/IFwiXCIgOiBzdWZmaXgpO1xuICB9XG4gIGluaXREaXJlY3Rpb24oXCJuZXh0XCIpO1xuXG4gIHZhciBjID0gbmV3IHdoZXJlQ2xhdXNlLkNvbGxlY3Rpb24gKFxuICAgICAgd2hlcmVDbGF1c2UsXG4gICAgICAoKT0+Y3JlYXRlUmFuZ2UodXBwZXJOZWVkbGVzWzBdLCBsb3dlck5lZWRsZXNbbmVlZGxlc0xlbi0xXSArIHN1ZmZpeClcbiAgKTtcblxuICBjLl9vbmRpcmVjdGlvbmNoYW5nZSA9IGZ1bmN0aW9uIChkaXJlY3Rpb24pIHtcbiAgICAgIC8vIFRoaXMgZXZlbnQgb25seXMgb2NjdXIgYmVmb3JlIGZpbHRlciBpcyBjYWxsZWQgdGhlIGZpcnN0IHRpbWUuXG4gICAgICBpbml0RGlyZWN0aW9uKGRpcmVjdGlvbik7XG4gIH07XG5cbiAgdmFyIGZpcnN0UG9zc2libGVOZWVkbGUgPSAwO1xuXG4gIGMuX2FkZEFsZ29yaXRobShmdW5jdGlvbiAoY3Vyc29yLCBhZHZhbmNlLCByZXNvbHZlKSB7XG4gICAgICAvLy8gPHBhcmFtIG5hbWU9XCJjdXJzb3JcIiB0eXBlPVwiSURCQ3Vyc29yXCI+PC9wYXJhbT5cbiAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImFkdmFuY2VcIiB0eXBlPVwiRnVuY3Rpb25cIj48L3BhcmFtPlxuICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzb2x2ZVwiIHR5cGU9XCJGdW5jdGlvblwiPjwvcGFyYW0+XG4gICAgICB2YXIga2V5ID0gY3Vyc29yLmtleTtcbiAgICAgIGlmICh0eXBlb2Yga2V5ICE9PSAnc3RyaW5nJykgcmV0dXJuIGZhbHNlO1xuICAgICAgdmFyIGxvd2VyS2V5ID0gbG93ZXIoa2V5KTtcbiAgICAgIGlmIChtYXRjaChsb3dlcktleSwgbG93ZXJOZWVkbGVzLCBmaXJzdFBvc3NpYmxlTmVlZGxlKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgbG93ZXN0UG9zc2libGVDYXNpbmcgPSBudWxsO1xuICAgICAgICAgIGZvciAodmFyIGk9Zmlyc3RQb3NzaWJsZU5lZWRsZTsgaTxuZWVkbGVzTGVuOyArK2kpIHtcbiAgICAgICAgICAgICAgdmFyIGNhc2luZyA9IG5leHRDYXNpbmcoa2V5LCBsb3dlcktleSwgdXBwZXJOZWVkbGVzW2ldLCBsb3dlck5lZWRsZXNbaV0sIGNvbXBhcmUsIGRpcmVjdGlvbik7XG4gICAgICAgICAgICAgIGlmIChjYXNpbmcgPT09IG51bGwgJiYgbG93ZXN0UG9zc2libGVDYXNpbmcgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgICBmaXJzdFBvc3NpYmxlTmVlZGxlID0gaSArIDE7XG4gICAgICAgICAgICAgIGVsc2UgaWYgKGxvd2VzdFBvc3NpYmxlQ2FzaW5nID09PSBudWxsIHx8IGNvbXBhcmUobG93ZXN0UG9zc2libGVDYXNpbmcsIGNhc2luZykgPiAwKSB7XG4gICAgICAgICAgICAgICAgICBsb3dlc3RQb3NzaWJsZUNhc2luZyA9IGNhc2luZztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobG93ZXN0UG9zc2libGVDYXNpbmcgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgYWR2YW5jZShmdW5jdGlvbiAoKSB7IGN1cnNvci5jb250aW51ZShsb3dlc3RQb3NzaWJsZUNhc2luZyArIG5leHRLZXlTdWZmaXgpOyB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBhZHZhbmNlKHJlc29sdmUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gIH0pO1xuICByZXR1cm4gYztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVJhbmdlIChsb3dlcjogSW5kZXhhYmxlVHlwZSwgdXBwZXI6IEluZGV4YWJsZVR5cGUsIGxvd2VyT3Blbj86IGJvb2xlYW4sIHVwcGVyT3Blbj86IGJvb2xlYW4pOiBEQkNvcmVLZXlSYW5nZSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogREJDb3JlUmFuZ2VUeXBlLlJhbmdlLFxuICAgICAgICBsb3dlcixcbiAgICAgICAgdXBwZXIsXG4gICAgICAgIGxvd2VyT3BlbixcbiAgICAgICAgdXBwZXJPcGVuXG4gICAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJhbmdlRXF1YWwgKHZhbHVlOiBJbmRleGFibGVUeXBlKSA6IERCQ29yZUtleVJhbmdlIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBEQkNvcmVSYW5nZVR5cGUuRXF1YWwsXG4gICAgICAgIGxvd2VyOiB2YWx1ZSxcbiAgICAgICAgdXBwZXI6IHZhbHVlXG4gICAgfTtcbn1cbiIsICJpbXBvcnQgeyBXaGVyZUNsYXVzZSBhcyBJV2hlcmVDbGF1c2UgfSBmcm9tIFwiLi4vLi4vcHVibGljL3R5cGVzL3doZXJlLWNsYXVzZVwiO1xuaW1wb3J0IHsgQ29sbGVjdGlvbiB9IGZyb20gXCIuLi9jb2xsZWN0aW9uXCI7XG5pbXBvcnQgeyBUYWJsZSB9IGZyb20gXCIuLi90YWJsZVwiO1xuaW1wb3J0IHsgSW5kZXhhYmxlVHlwZSB9IGZyb20gXCIuLi8uLi9wdWJsaWMvdHlwZXMvaW5kZXhhYmxlLXR5cGVcIjtcbmltcG9ydCB7IGVtcHR5Q29sbGVjdGlvbiwgZmFpbCwgYWRkSWdub3JlQ2FzZUFsZ29yaXRobSwgY3JlYXRlUmFuZ2UsIHJhbmdlRXF1YWwgfSBmcm9tICcuL3doZXJlLWNsYXVzZS1oZWxwZXJzJztcbmltcG9ydCB7IElOVkFMSURfS0VZX0FSR1VNRU5ULCBTVFJJTkdfRVhQRUNURUQsIG1heFN0cmluZywgbWluS2V5IH0gZnJvbSAnLi4vLi4vZ2xvYmFscy9jb25zdGFudHMnO1xuaW1wb3J0IHsgZ2V0QXJyYXlPZiwgTk9fQ0hBUl9BUlJBWSB9IGZyb20gJy4uLy4uL2Z1bmN0aW9ucy91dGlscyc7XG5pbXBvcnQgeyBleGNlcHRpb25zIH0gZnJvbSAnLi4vLi4vZXJyb3JzJztcbmltcG9ydCB7IERleGllIH0gZnJvbSAnLi4vZGV4aWUnO1xuaW1wb3J0IHsgQ29sbGVjdGlvbiBhcyBJQ29sbGVjdGlvbn0gZnJvbSBcIi4uLy4uL3B1YmxpYy90eXBlcy9jb2xsZWN0aW9uXCI7XG5cbi8qKiBjbGFzcyBXaGVyZUNsYXVzZVxuICogXG4gKiBodHRwczovL2RleGllLm9yZy9kb2NzL1doZXJlQ2xhdXNlL1doZXJlQ2xhdXNlXG4gKi9cbmV4cG9ydCBjbGFzcyBXaGVyZUNsYXVzZSBpbXBsZW1lbnRzIElXaGVyZUNsYXVzZSB7XG4gIGRiOiBEZXhpZTtcbiAgX0lEQktleVJhbmdlOiB0eXBlb2YgSURCS2V5UmFuZ2U7XG4gIF9jdHg6IHtcbiAgICB0YWJsZTogVGFibGU7XG4gICAgaW5kZXg6IHN0cmluZztcbiAgICBvcjogQ29sbGVjdGlvbjtcbiAgfVxuICBfY21wOiAoYTogSW5kZXhhYmxlVHlwZSwgYjogSW5kZXhhYmxlVHlwZSkgPT4gbnVtYmVyO1xuICBfYXNjZW5kaW5nOiAoYTogSW5kZXhhYmxlVHlwZSwgYjogSW5kZXhhYmxlVHlwZSkgPT4gbnVtYmVyO1xuICBfZGVzY2VuZGluZzogKGE6IEluZGV4YWJsZVR5cGUsIGI6IEluZGV4YWJsZVR5cGUpID0+IG51bWJlcjtcbiAgX21pbjogKGE6IEluZGV4YWJsZVR5cGUsIGI6IEluZGV4YWJsZVR5cGUpID0+IEluZGV4YWJsZVR5cGU7XG4gIF9tYXg6IChhOiBJbmRleGFibGVUeXBlLCBiOiBJbmRleGFibGVUeXBlKSA9PiBJbmRleGFibGVUeXBlO1xuXG4gIGdldCBDb2xsZWN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9jdHgudGFibGUuZGIuQ29sbGVjdGlvbjtcbiAgfVxuXG4gIC8qKiBXaGVyZUNsYXVzZS5iZXR3ZWVuKClcbiAgICogXG4gICAqIGh0dHBzOi8vZGV4aWUub3JnL2RvY3MvV2hlcmVDbGF1c2UvV2hlcmVDbGF1c2UuYmV0d2VlbigpXG4gICAqIFxuICAgKiovXG4gIGJldHdlZW4obG93ZXI6IEluZGV4YWJsZVR5cGUsIHVwcGVyOiBJbmRleGFibGVUeXBlLCBpbmNsdWRlTG93ZXI/OiBib29sZWFuLCBpbmNsdWRlVXBwZXI/OiBib29sZWFuKSB7XG4gICAgaW5jbHVkZUxvd2VyID0gaW5jbHVkZUxvd2VyICE9PSBmYWxzZTsgICAvLyBEZWZhdWx0IHRvIHRydWVcbiAgICBpbmNsdWRlVXBwZXIgPSBpbmNsdWRlVXBwZXIgPT09IHRydWU7ICAgIC8vIERlZmF1bHQgdG8gZmFsc2VcbiAgICB0cnkge1xuICAgICAgaWYgKCh0aGlzLl9jbXAobG93ZXIsIHVwcGVyKSA+IDApIHx8XG4gICAgICAgICh0aGlzLl9jbXAobG93ZXIsIHVwcGVyKSA9PT0gMCAmJiAoaW5jbHVkZUxvd2VyIHx8IGluY2x1ZGVVcHBlcikgJiYgIShpbmNsdWRlTG93ZXIgJiYgaW5jbHVkZVVwcGVyKSkpXG4gICAgICAgIHJldHVybiBlbXB0eUNvbGxlY3Rpb24odGhpcyk7IC8vIFdvcmthcm91bmQgZm9yIGlkaW90aWMgVzNDIFNwZWNpZmljYXRpb24gdGhhdCBEYXRhRXJyb3IgbXVzdCBiZSB0aHJvd24gaWYgbG93ZXIgPiB1cHBlci4gVGhlIG5hdHVyYWwgcmVzdWx0IHdvdWxkIGJlIHRvIHJldHVybiBhbiBlbXB0eSBjb2xsZWN0aW9uLlxuICAgICAgcmV0dXJuIG5ldyB0aGlzLkNvbGxlY3Rpb24odGhpcywgKCk9PmNyZWF0ZVJhbmdlKGxvd2VyLCB1cHBlciwgIWluY2x1ZGVMb3dlciwgIWluY2x1ZGVVcHBlcikpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBmYWlsKHRoaXMsIElOVkFMSURfS0VZX0FSR1VNRU5UKTtcbiAgICB9XG4gIH1cblxuICAvKiogV2hlcmVDbGF1c2UuZXF1YWxzKClcbiAgICogXG4gICAqIGh0dHBzOi8vZGV4aWUub3JnL2RvY3MvV2hlcmVDbGF1c2UvV2hlcmVDbGF1c2UuZXF1YWxzKClcbiAgICogXG4gICAqKi9cbiAgZXF1YWxzKHZhbHVlOiBJbmRleGFibGVUeXBlKSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHJldHVybiBmYWlsKHRoaXMsIElOVkFMSURfS0VZX0FSR1VNRU5UKTtcbiAgICByZXR1cm4gbmV3IHRoaXMuQ29sbGVjdGlvbih0aGlzLCAoKSA9PiByYW5nZUVxdWFsKHZhbHVlKSkgYXMgSUNvbGxlY3Rpb247XG4gIH1cblxuICAvKiogV2hlcmVDbGF1c2UuYWJvdmUoKVxuICAgKiBcbiAgICogaHR0cHM6Ly9kZXhpZS5vcmcvZG9jcy9XaGVyZUNsYXVzZS9XaGVyZUNsYXVzZS5hYm92ZSgpXG4gICAqIFxuICAgKiovXG4gIGFib3ZlKHZhbHVlOiBJbmRleGFibGVUeXBlKSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHJldHVybiBmYWlsKHRoaXMsIElOVkFMSURfS0VZX0FSR1VNRU5UKTtcbiAgICByZXR1cm4gbmV3IHRoaXMuQ29sbGVjdGlvbih0aGlzLCAoKSA9PiBjcmVhdGVSYW5nZSh2YWx1ZSwgdW5kZWZpbmVkLCB0cnVlKSk7XG4gIH1cblxuICAvKiogV2hlcmVDbGF1c2UuYWJvdmVPckVxdWFsKClcbiAgICogXG4gICAqIGh0dHBzOi8vZGV4aWUub3JnL2RvY3MvV2hlcmVDbGF1c2UvV2hlcmVDbGF1c2UuYWJvdmVPckVxdWFsKClcbiAgICogXG4gICAqKi9cbiAgYWJvdmVPckVxdWFsKHZhbHVlOiBJbmRleGFibGVUeXBlKSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHJldHVybiBmYWlsKHRoaXMsIElOVkFMSURfS0VZX0FSR1VNRU5UKTtcbiAgICByZXR1cm4gbmV3IHRoaXMuQ29sbGVjdGlvbih0aGlzLCAoKSA9PiBjcmVhdGVSYW5nZSh2YWx1ZSwgdW5kZWZpbmVkLCBmYWxzZSkpO1xuICB9XG5cbiAgLyoqIFdoZXJlQ2xhdXNlLmJlbG93KClcbiAgICogXG4gICAqIGh0dHBzOi8vZGV4aWUub3JnL2RvY3MvV2hlcmVDbGF1c2UvV2hlcmVDbGF1c2UuYmVsb3coKVxuICAgKiBcbiAgICoqL1xuICBiZWxvdyh2YWx1ZTogSW5kZXhhYmxlVHlwZSkge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSByZXR1cm4gZmFpbCh0aGlzLCBJTlZBTElEX0tFWV9BUkdVTUVOVCk7XG4gICAgcmV0dXJuIG5ldyB0aGlzLkNvbGxlY3Rpb24odGhpcywgKCkgPT4gY3JlYXRlUmFuZ2UodW5kZWZpbmVkLCB2YWx1ZSwgZmFsc2UsIHRydWUpKTtcbiAgfVxuXG4gIC8qKiBXaGVyZUNsYXVzZS5iZWxvd09yRXF1YWwoKVxuICAgKiBcbiAgICogaHR0cHM6Ly9kZXhpZS5vcmcvZG9jcy9XaGVyZUNsYXVzZS9XaGVyZUNsYXVzZS5iZWxvd09yRXF1YWwoKVxuICAgKiBcbiAgICoqL1xuICBiZWxvd09yRXF1YWwodmFsdWU6IEluZGV4YWJsZVR5cGUpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkgcmV0dXJuIGZhaWwodGhpcywgSU5WQUxJRF9LRVlfQVJHVU1FTlQpO1xuICAgIHJldHVybiBuZXcgdGhpcy5Db2xsZWN0aW9uKHRoaXMsICgpID0+IGNyZWF0ZVJhbmdlKHVuZGVmaW5lZCwgdmFsdWUpKTtcbiAgfVxuXG4gIC8qKiBXaGVyZUNsYXVzZS5zdGFydHNXaXRoKClcbiAgICogXG4gICAqIGh0dHBzOi8vZGV4aWUub3JnL2RvY3MvV2hlcmVDbGF1c2UvV2hlcmVDbGF1c2Uuc3RhcnRzV2l0aCgpXG4gICAqIFxuICAgKiovXG4gIHN0YXJ0c1dpdGgoc3RyOiBzdHJpbmcpIHtcbiAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHJldHVybiBmYWlsKHRoaXMsIFNUUklOR19FWFBFQ1RFRCk7XG4gICAgcmV0dXJuIHRoaXMuYmV0d2VlbihzdHIsIHN0ciArIG1heFN0cmluZywgdHJ1ZSwgdHJ1ZSk7XG4gIH1cblxuICAvKiogV2hlcmVDbGF1c2Uuc3RhcnRzV2l0aElnbm9yZUNhc2UoKVxuICAgKiBcbiAgICogaHR0cHM6Ly9kZXhpZS5vcmcvZG9jcy9XaGVyZUNsYXVzZS9XaGVyZUNsYXVzZS5zdGFydHNXaXRoSWdub3JlQ2FzZSgpXG4gICAqIFxuICAgKiovXG4gIHN0YXJ0c1dpdGhJZ25vcmVDYXNlKHN0cjogc3RyaW5nKSB7XG4gICAgaWYgKHN0ciA9PT0gXCJcIikgcmV0dXJuIHRoaXMuc3RhcnRzV2l0aChzdHIpO1xuICAgIHJldHVybiBhZGRJZ25vcmVDYXNlQWxnb3JpdGhtKHRoaXMsICh4LCBhKSA9PiB4LmluZGV4T2YoYVswXSkgPT09IDAsIFtzdHJdLCBtYXhTdHJpbmcpO1xuICB9XG5cbiAgLyoqIFdoZXJlQ2xhdXNlLmVxdWFsc0lnbm9yZUNhc2UoKVxuICAgKiBcbiAgICogaHR0cHM6Ly9kZXhpZS5vcmcvZG9jcy9XaGVyZUNsYXVzZS9XaGVyZUNsYXVzZS5lcXVhbHNJZ25vcmVDYXNlKClcbiAgICogXG4gICAqKi9cbiAgZXF1YWxzSWdub3JlQ2FzZShzdHI6IHN0cmluZykge1xuICAgIHJldHVybiBhZGRJZ25vcmVDYXNlQWxnb3JpdGhtKHRoaXMsICh4LCBhKSA9PiB4ID09PSBhWzBdLCBbc3RyXSwgXCJcIik7XG4gIH1cblxuICAvKiogV2hlcmVDbGF1c2UuYW55T2ZJZ25vcmVDYXNlKClcbiAgICogXG4gICAqIGh0dHBzOi8vZGV4aWUub3JnL2RvY3MvV2hlcmVDbGF1c2UvV2hlcmVDbGF1c2UuYW55T2ZJZ25vcmVDYXNlKClcbiAgICogXG4gICAqKi9cbiAgYW55T2ZJZ25vcmVDYXNlKC4uLnZhbHVlczogc3RyaW5nW10pOiBDb2xsZWN0aW9uO1xuICBhbnlPZklnbm9yZUNhc2UodmFsdWVzOiBzdHJpbmdbXSk6IENvbGxlY3Rpb247XG4gIGFueU9mSWdub3JlQ2FzZSgpIHtcbiAgICB2YXIgc2V0ID0gZ2V0QXJyYXlPZi5hcHBseShOT19DSEFSX0FSUkFZLCBhcmd1bWVudHMpO1xuICAgIGlmIChzZXQubGVuZ3RoID09PSAwKSByZXR1cm4gZW1wdHlDb2xsZWN0aW9uKHRoaXMpO1xuICAgIHJldHVybiBhZGRJZ25vcmVDYXNlQWxnb3JpdGhtKHRoaXMsICh4LCBhKSA9PiBhLmluZGV4T2YoeCkgIT09IC0xLCBzZXQsIFwiXCIpO1xuICB9XG5cbiAgLyoqIFdoZXJlQ2xhdXNlLnN0YXJ0c1dpdGhBbnlPZklnbm9yZUNhc2UoKVxuICAgKiBcbiAgICogaHR0cHM6Ly9kZXhpZS5vcmcvZG9jcy9XaGVyZUNsYXVzZS9XaGVyZUNsYXVzZS5zdGFydHNXaXRoQW55T2ZJZ25vcmVDYXNlKClcbiAgICogXG4gICAqKi9cbiAgc3RhcnRzV2l0aEFueU9mSWdub3JlQ2FzZSguLi52YWx1ZXM6IHN0cmluZ1tdKTogQ29sbGVjdGlvbjtcbiAgc3RhcnRzV2l0aEFueU9mSWdub3JlQ2FzZSh2YWx1ZXM6IHN0cmluZ1tdKTogQ29sbGVjdGlvbjtcbiAgc3RhcnRzV2l0aEFueU9mSWdub3JlQ2FzZSgpIHtcbiAgICB2YXIgc2V0ID0gZ2V0QXJyYXlPZi5hcHBseShOT19DSEFSX0FSUkFZLCBhcmd1bWVudHMpO1xuICAgIGlmIChzZXQubGVuZ3RoID09PSAwKSByZXR1cm4gZW1wdHlDb2xsZWN0aW9uKHRoaXMpO1xuICAgIHJldHVybiBhZGRJZ25vcmVDYXNlQWxnb3JpdGhtKHRoaXMsICh4LCBhKSA9PiBhLnNvbWUobiA9PiB4LmluZGV4T2YobikgPT09IDApLCBzZXQsIG1heFN0cmluZyk7XG4gIH1cblxuICAvKiogV2hlcmVDbGF1c2UuYW55T2YoKVxuICAgKiBcbiAgICogaHR0cHM6Ly9kZXhpZS5vcmcvZG9jcy9XaGVyZUNsYXVzZS9XaGVyZUNsYXVzZS5hbnlPZigpXG4gICAqIFxuICAgKiovXG4gIGFueU9mKC4uLnZhbHVlczogc3RyaW5nW10pOiBDb2xsZWN0aW9uO1xuICBhbnlPZih2YWx1ZXM6IHN0cmluZ1tdKTogQ29sbGVjdGlvbjtcbiAgYW55T2YoKSB7XG4gICAgY29uc3Qgc2V0ID0gZ2V0QXJyYXlPZi5hcHBseShOT19DSEFSX0FSUkFZLCBhcmd1bWVudHMpO1xuICAgIGxldCBjb21wYXJlID0gdGhpcy5fY21wO1xuICAgIHRyeSB7IHNldC5zb3J0KGNvbXBhcmUpOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWlsKHRoaXMsIElOVkFMSURfS0VZX0FSR1VNRU5UKTsgfVxuICAgIGlmIChzZXQubGVuZ3RoID09PSAwKSByZXR1cm4gZW1wdHlDb2xsZWN0aW9uKHRoaXMpO1xuICAgIGNvbnN0IGMgPSBuZXcgdGhpcy5Db2xsZWN0aW9uKHRoaXMsICgpID0+IGNyZWF0ZVJhbmdlKHNldFswXSwgc2V0W3NldC5sZW5ndGggLSAxXSkpO1xuXG4gICAgYy5fb25kaXJlY3Rpb25jaGFuZ2UgPSBkaXJlY3Rpb24gPT4ge1xuICAgICAgY29tcGFyZSA9IChkaXJlY3Rpb24gPT09IFwibmV4dFwiID9cbiAgICAgICAgdGhpcy5fYXNjZW5kaW5nIDpcbiAgICAgICAgdGhpcy5fZGVzY2VuZGluZyk7XG4gICAgICBzZXQuc29ydChjb21wYXJlKTtcbiAgICB9O1xuXG4gICAgbGV0IGkgPSAwO1xuICAgIGMuX2FkZEFsZ29yaXRobSgoY3Vyc29yLCBhZHZhbmNlLCByZXNvbHZlKSA9PiB7XG4gICAgICBjb25zdCBrZXkgPSBjdXJzb3Iua2V5O1xuICAgICAgd2hpbGUgKGNvbXBhcmUoa2V5LCBzZXRbaV0pID4gMCkge1xuICAgICAgICAvLyBUaGUgY3Vyc29yIGhhcyBwYXNzZWQgYmV5b25kIHRoaXMga2V5LiBDaGVjayBuZXh0LlxuICAgICAgICArK2k7XG4gICAgICAgIGlmIChpID09PSBzZXQubGVuZ3RoKSB7XG4gICAgICAgICAgLy8gVGhlcmUgaXMgbm8gbmV4dC4gU3RvcCBzZWFyY2hpbmcuXG4gICAgICAgICAgYWR2YW5jZShyZXNvbHZlKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjb21wYXJlKGtleSwgc2V0W2ldKSA9PT0gMCkge1xuICAgICAgICAvLyBUaGUgY3VycmVudCBjdXJzb3IgdmFsdWUgc2hvdWxkIGJlIGluY2x1ZGVkIGFuZCB3ZSBzaG91bGQgY29udGludWUgYSBzaW5nbGUgc3RlcCBpbiBjYXNlIG5leHQgaXRlbSBoYXMgdGhlIHNhbWUga2V5IG9yIHBvc3NpYmx5IG91ciBuZXh0IGtleSBpbiBzZXQuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gY3Vyc29yLmtleSBub3QgeWV0IGF0IHNldFtpXS4gRm9yd2FyZCBjdXJzb3IgdG8gdGhlIG5leHQga2V5IHRvIGh1bnQgZm9yLlxuICAgICAgICBhZHZhbmNlKCgpID0+IHsgY3Vyc29yLmNvbnRpbnVlKHNldFtpXSk7IH0pO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGM7XG4gIH1cblxuICAvKiogV2hlcmVDbGF1c2Uubm90RXF1YWwoKVxuICAgKiBcbiAgICogaHR0cHM6Ly9kZXhpZS5vcmcvZG9jcy9XaGVyZUNsYXVzZS9XaGVyZUNsYXVzZS5ub3RFcXVhbCgpXG4gICAqIFxuICAgKiovXG4gIG5vdEVxdWFsKHZhbHVlOiBJbmRleGFibGVUeXBlKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5BbnlSYW5nZShbW21pbktleSwgdmFsdWVdLCBbdmFsdWUsIHRoaXMuZGIuX21heEtleV1dLCB7IGluY2x1ZGVMb3dlcnM6IGZhbHNlLCBpbmNsdWRlVXBwZXJzOiBmYWxzZSB9KTtcbiAgfVxuXG4gIC8qKiBXaGVyZUNsYXVzZS5ub25lT2YoKVxuICAgKiBcbiAgICogaHR0cHM6Ly9kZXhpZS5vcmcvZG9jcy9XaGVyZUNsYXVzZS9XaGVyZUNsYXVzZS5ub25lT2YoKVxuICAgKiBcbiAgICoqL1xuICBub25lT2YoLi4udmFsdWVzOiBzdHJpbmdbXSk6IENvbGxlY3Rpb247XG4gIG5vbmVPZih2YWx1ZXM6IHN0cmluZ1tdKTogQ29sbGVjdGlvbjtcbiAgbm9uZU9mKCkge1xuICAgIGNvbnN0IHNldCA9IGdldEFycmF5T2YuYXBwbHkoTk9fQ0hBUl9BUlJBWSwgYXJndW1lbnRzKTtcbiAgICBpZiAoc2V0Lmxlbmd0aCA9PT0gMCkgcmV0dXJuIG5ldyB0aGlzLkNvbGxlY3Rpb24odGhpcyk7IC8vIFJldHVybiBlbnRpcmUgY29sbGVjdGlvbi5cbiAgICB0cnkgeyBzZXQuc29ydCh0aGlzLl9hc2NlbmRpbmcpOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWlsKHRoaXMsIElOVkFMSURfS0VZX0FSR1VNRU5UKTsgfVxuICAgIC8vIFRyYW5zZm9ybSBbXCJhXCIsXCJiXCIsXCJjXCJdIHRvIGEgc2V0IG9mIHJhbmdlcyBmb3IgYmV0d2Vlbi9hYm92ZS9iZWxvdzogW1ttaW5LZXksXCJhXCJdLCBbXCJhXCIsXCJiXCJdLCBbXCJiXCIsXCJjXCJdLCBbXCJjXCIsbWF4S2V5XV1cbiAgICBjb25zdCByYW5nZXMgPSBzZXQucmVkdWNlKFxuICAgICAgKHJlcywgdmFsKSA9PiByZXMgP1xuICAgICAgICByZXMuY29uY2F0KFtbcmVzW3Jlcy5sZW5ndGggLSAxXVsxXSwgdmFsXV0pIDpcbiAgICAgICAgW1ttaW5LZXksIHZhbF1dLFxuICAgICAgbnVsbCk7XG4gICAgcmFuZ2VzLnB1c2goW3NldFtzZXQubGVuZ3RoIC0gMV0sIHRoaXMuZGIuX21heEtleV0pO1xuICAgIHJldHVybiB0aGlzLmluQW55UmFuZ2UocmFuZ2VzLCB7IGluY2x1ZGVMb3dlcnM6IGZhbHNlLCBpbmNsdWRlVXBwZXJzOiBmYWxzZSB9KTtcbiAgfVxuXG4gIC8qKiBXaGVyZUNsYXVzZS5pbkFueVJhbmdlKClcbiAgICogXG4gICAqIGh0dHBzOi8vZGV4aWUub3JnL2RvY3MvV2hlcmVDbGF1c2UvV2hlcmVDbGF1c2UuaW5BbnlSYW5nZSgpXG4gICAqIFxuICAgKiovXG4gIGluQW55UmFuZ2UoXG4gICAgcmFuZ2VzOiBSZWFkb25seUFycmF5PHsgMDogSW5kZXhhYmxlVHlwZSwgMTogSW5kZXhhYmxlVHlwZSB9PixcbiAgICBvcHRpb25zPzogeyBpbmNsdWRlTG93ZXJzPzogYm9vbGVhbiwgaW5jbHVkZVVwcGVycz86IGJvb2xlYW4gfSlcbiAge1xuICAgIGNvbnN0IGNtcCA9IHRoaXMuX2NtcCxcbiAgICAgICAgICBhc2NlbmRpbmcgPSB0aGlzLl9hc2NlbmRpbmcsXG4gICAgICAgICAgZGVzY2VuZGluZyA9IHRoaXMuX2Rlc2NlbmRpbmcsXG4gICAgICAgICAgbWluID0gdGhpcy5fbWluLFxuICAgICAgICAgIG1heCA9IHRoaXMuX21heDtcblxuICAgIGlmIChyYW5nZXMubGVuZ3RoID09PSAwKSByZXR1cm4gZW1wdHlDb2xsZWN0aW9uKHRoaXMpO1xuICAgIGlmICghcmFuZ2VzLmV2ZXJ5KHJhbmdlID0+XG4gICAgICByYW5nZVswXSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICByYW5nZVsxXSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICBhc2NlbmRpbmcocmFuZ2VbMF0sIHJhbmdlWzFdKSA8PSAwKSkge1xuICAgICAgcmV0dXJuIGZhaWwoXG4gICAgICAgIHRoaXMsXG4gICAgICAgIFwiRmlyc3QgYXJndW1lbnQgdG8gaW5BbnlSYW5nZSgpIG11c3QgYmUgYW4gQXJyYXkgb2YgdHdvLXZhbHVlIEFycmF5cyBbbG93ZXIsdXBwZXJdIHdoZXJlIHVwcGVyIG11c3Qgbm90IGJlIGxvd2VyIHRoYW4gbG93ZXJcIixcbiAgICAgICAgZXhjZXB0aW9ucy5JbnZhbGlkQXJndW1lbnQpO1xuICAgIH1cbiAgICBjb25zdCBpbmNsdWRlTG93ZXJzID0gIW9wdGlvbnMgfHwgb3B0aW9ucy5pbmNsdWRlTG93ZXJzICE9PSBmYWxzZTsgICAvLyBEZWZhdWx0IHRvIHRydWVcbiAgICBjb25zdCBpbmNsdWRlVXBwZXJzID0gb3B0aW9ucyAmJiBvcHRpb25zLmluY2x1ZGVVcHBlcnMgPT09IHRydWU7ICAgIC8vIERlZmF1bHQgdG8gZmFsc2VcblxuICAgIGZ1bmN0aW9uIGFkZFJhbmdlKHJhbmdlcywgbmV3UmFuZ2UpIHtcbiAgICAgIGxldCBpID0gMCwgbCA9IHJhbmdlcy5sZW5ndGg7XG4gICAgICBmb3IgKDsgaSA8IGw7ICsraSkge1xuICAgICAgICBjb25zdCByYW5nZSA9IHJhbmdlc1tpXTtcbiAgICAgICAgaWYgKGNtcChuZXdSYW5nZVswXSwgcmFuZ2VbMV0pIDwgMCAmJiBjbXAobmV3UmFuZ2VbMV0sIHJhbmdlWzBdKSA+IDApIHtcbiAgICAgICAgICByYW5nZVswXSA9IG1pbihyYW5nZVswXSwgbmV3UmFuZ2VbMF0pO1xuICAgICAgICAgIHJhbmdlWzFdID0gbWF4KHJhbmdlWzFdLCBuZXdSYW5nZVsxXSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpID09PSBsKVxuICAgICAgICByYW5nZXMucHVzaChuZXdSYW5nZSk7XG4gICAgICByZXR1cm4gcmFuZ2VzO1xuICAgIH1cblxuICAgIGxldCBzb3J0RGlyZWN0aW9uID0gYXNjZW5kaW5nO1xuICAgIGZ1bmN0aW9uIHJhbmdlU29ydGVyKGEsIGIpIHsgcmV0dXJuIHNvcnREaXJlY3Rpb24oYVswXSwgYlswXSk7IH1cblxuICAgIC8vIEpvaW4gb3ZlcmxhcHBpbmcgcmFuZ2VzXG4gICAgbGV0IHNldDtcbiAgICB0cnkge1xuICAgICAgc2V0ID0gcmFuZ2VzLnJlZHVjZShhZGRSYW5nZSwgW10pO1xuICAgICAgc2V0LnNvcnQocmFuZ2VTb3J0ZXIpO1xuICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICByZXR1cm4gZmFpbCh0aGlzLCBJTlZBTElEX0tFWV9BUkdVTUVOVCk7XG4gICAgfVxuXG4gICAgbGV0IHJhbmdlUG9zID0gMDtcbiAgICBjb25zdCBrZXlJc0JleW9uZEN1cnJlbnRFbnRyeSA9IGluY2x1ZGVVcHBlcnMgP1xuICAgICAga2V5ID0+IGFzY2VuZGluZyhrZXksIHNldFtyYW5nZVBvc11bMV0pID4gMCA6XG4gICAgICBrZXkgPT4gYXNjZW5kaW5nKGtleSwgc2V0W3JhbmdlUG9zXVsxXSkgPj0gMDtcblxuICAgIGNvbnN0IGtleUlzQmVmb3JlQ3VycmVudEVudHJ5ID0gaW5jbHVkZUxvd2VycyA/XG4gICAgICBrZXkgPT4gZGVzY2VuZGluZyhrZXksIHNldFtyYW5nZVBvc11bMF0pID4gMCA6XG4gICAgICBrZXkgPT4gZGVzY2VuZGluZyhrZXksIHNldFtyYW5nZVBvc11bMF0pID49IDA7XG5cbiAgICBmdW5jdGlvbiBrZXlXaXRoaW5DdXJyZW50UmFuZ2Uoa2V5KSB7XG4gICAgICByZXR1cm4gIWtleUlzQmV5b25kQ3VycmVudEVudHJ5KGtleSkgJiYgIWtleUlzQmVmb3JlQ3VycmVudEVudHJ5KGtleSk7XG4gICAgfVxuXG4gICAgbGV0IGNoZWNrS2V5ID0ga2V5SXNCZXlvbmRDdXJyZW50RW50cnk7XG5cbiAgICBjb25zdCBjID0gbmV3IHRoaXMuQ29sbGVjdGlvbihcbiAgICAgIHRoaXMsXG4gICAgICAoKSA9PiBjcmVhdGVSYW5nZShzZXRbMF1bMF0sIHNldFtzZXQubGVuZ3RoIC0gMV1bMV0sICFpbmNsdWRlTG93ZXJzLCAhaW5jbHVkZVVwcGVycykpO1xuXG4gICAgYy5fb25kaXJlY3Rpb25jaGFuZ2UgPSBkaXJlY3Rpb24gPT4ge1xuICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgY2hlY2tLZXkgPSBrZXlJc0JleW9uZEN1cnJlbnRFbnRyeTtcbiAgICAgICAgc29ydERpcmVjdGlvbiA9IGFzY2VuZGluZztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNoZWNrS2V5ID0ga2V5SXNCZWZvcmVDdXJyZW50RW50cnk7XG4gICAgICAgIHNvcnREaXJlY3Rpb24gPSBkZXNjZW5kaW5nO1xuICAgICAgfVxuICAgICAgc2V0LnNvcnQocmFuZ2VTb3J0ZXIpO1xuICAgIH07XG5cbiAgICBjLl9hZGRBbGdvcml0aG0oKGN1cnNvciwgYWR2YW5jZSwgcmVzb2x2ZSkgPT4ge1xuICAgICAgdmFyIGtleSA9IGN1cnNvci5rZXk7XG4gICAgICB3aGlsZSAoY2hlY2tLZXkoa2V5KSkge1xuICAgICAgICAvLyBUaGUgY3Vyc29yIGhhcyBwYXNzZWQgYmV5b25kIHRoaXMga2V5LiBDaGVjayBuZXh0LlxuICAgICAgICArK3JhbmdlUG9zO1xuICAgICAgICBpZiAocmFuZ2VQb3MgPT09IHNldC5sZW5ndGgpIHtcbiAgICAgICAgICAvLyBUaGVyZSBpcyBubyBuZXh0LiBTdG9wIHNlYXJjaGluZy5cbiAgICAgICAgICBhZHZhbmNlKHJlc29sdmUpO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGtleVdpdGhpbkN1cnJlbnRSYW5nZShrZXkpKSB7XG4gICAgICAgIC8vIFRoZSBjdXJyZW50IGN1cnNvciB2YWx1ZSBzaG91bGQgYmUgaW5jbHVkZWQgYW5kIHdlIHNob3VsZCBjb250aW51ZSBhIHNpbmdsZSBzdGVwIGluIGNhc2UgbmV4dCBpdGVtIGhhcyB0aGUgc2FtZSBrZXkgb3IgcG9zc2libHkgb3VyIG5leHQga2V5IGluIHNldC5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX2NtcChrZXksIHNldFtyYW5nZVBvc11bMV0pID09PSAwIHx8IHRoaXMuX2NtcChrZXksIHNldFtyYW5nZVBvc11bMF0pID09PSAwKSB7XG4gICAgICAgIC8vIGluY2x1ZGVVcHBlciBvciBpbmNsdWRlTG93ZXIgaXMgZmFsc2Ugc28ga2V5V2l0aGluQ3VycmVudFJhbmdlKCkgcmV0dXJucyBmYWxzZSBldmVuIHRob3VnaCB3ZSBhcmUgYXQgcmFuZ2UgYm9yZGVyLlxuICAgICAgICAvLyBDb250aW51ZSB0byBuZXh0IGtleSBidXQgZG9uJ3QgaW5jbHVkZSB0aGlzIG9uZS5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gY3Vyc29yLmtleSBub3QgeWV0IGF0IHNldFtpXS4gRm9yd2FyZCBjdXJzb3IgdG8gdGhlIG5leHQga2V5IHRvIGh1bnQgZm9yLlxuICAgICAgICBhZHZhbmNlKCgpID0+IHtcbiAgICAgICAgICBpZiAoc29ydERpcmVjdGlvbiA9PT0gYXNjZW5kaW5nKSBjdXJzb3IuY29udGludWUoc2V0W3JhbmdlUG9zXVswXSk7XG4gICAgICAgICAgZWxzZSBjdXJzb3IuY29udGludWUoc2V0W3JhbmdlUG9zXVsxXSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGM7XG4gIH1cblxuICAvKiogV2hlcmVDbGF1c2Uuc3RhcnRzV2l0aEFueU9mKClcbiAgICogXG4gICAqIGh0dHBzOi8vZGV4aWUub3JnL2RvY3MvV2hlcmVDbGF1c2UvV2hlcmVDbGF1c2Uuc3RhcnRzV2l0aEFueU9mKClcbiAgICogXG4gICAqKi9cbiAgc3RhcnRzV2l0aEFueU9mKC4uLnByZWZpeGVzOiBzdHJpbmdbXSk6IENvbGxlY3Rpb247XG4gIHN0YXJ0c1dpdGhBbnlPZihwcmVmaXhlczogc3RyaW5nW10pOiBDb2xsZWN0aW9uO1xuICBzdGFydHNXaXRoQW55T2YoKSB7XG4gICAgY29uc3Qgc2V0ID0gZ2V0QXJyYXlPZi5hcHBseShOT19DSEFSX0FSUkFZLCBhcmd1bWVudHMpO1xuXG4gICAgaWYgKCFzZXQuZXZlcnkocyA9PiB0eXBlb2YgcyA9PT0gJ3N0cmluZycpKSB7XG4gICAgICAgIHJldHVybiBmYWlsKHRoaXMsIFwic3RhcnRzV2l0aEFueU9mKCkgb25seSB3b3JrcyB3aXRoIHN0cmluZ3NcIik7XG4gICAgfVxuICAgIGlmIChzZXQubGVuZ3RoID09PSAwKSByZXR1cm4gZW1wdHlDb2xsZWN0aW9uKHRoaXMpO1xuXG4gICAgcmV0dXJuIHRoaXMuaW5BbnlSYW5nZShzZXQubWFwKChzdHI6IHN0cmluZykgPT4gW3N0ciwgc3RyICsgbWF4U3RyaW5nXSkpO1xuICB9XG5cbn1cbiIsICJpbXBvcnQgeyBEZXhpZSB9IGZyb20gJy4uL2RleGllJztcbmltcG9ydCB7IG1ha2VDbGFzc0NvbnN0cnVjdG9yIH0gZnJvbSAnLi4vLi4vZnVuY3Rpb25zL21ha2UtY2xhc3MtY29uc3RydWN0b3InO1xuaW1wb3J0IHsgV2hlcmVDbGF1c2UgfSBmcm9tICcuL3doZXJlLWNsYXVzZSc7XG5pbXBvcnQgeyBUYWJsZSB9IGZyb20gJy4uL3RhYmxlJztcbmltcG9ydCB7IENvbGxlY3Rpb24gfSBmcm9tICcuLi9jb2xsZWN0aW9uJztcbmltcG9ydCB7IGV4Y2VwdGlvbnMgfSBmcm9tICcuLi8uLi9lcnJvcnMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFdoZXJlQ2xhdXNlQ29uc3RydWN0b3Ige1xuICBuZXcodGFibGU6IFRhYmxlLCBpbmRleD86IHN0cmluZywgb3JDb2xsZWN0aW9uPzogQ29sbGVjdGlvbik6IFdoZXJlQ2xhdXNlO1xuICBwcm90b3R5cGU6IFdoZXJlQ2xhdXNlO1xufVxuXG4vKiogR2VuZXJhdGVzIGEgV2hlcmVDbGF1c2UgY29uc3RydWN0b3IuXG4gKiBcbiAqIFRoZSBwdXJwb3NlIG9mIGhhdmluZyBkeW5hbWljYWxseSBjcmVhdGVkIGNvbnN0cnVjdG9ycywgaXMgdG8gYWxsb3dcbiAqIGFkZG9ucyB0byBleHRlbmQgY2xhc3NlcyBmb3IgYSBjZXJ0YWluIERleGllIGluc3RhbmNlIHdpdGhvdXQgYWZmZWN0aW5nXG4gKiBvdGhlciBkYiBpbnN0YW5jZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVXaGVyZUNsYXVzZUNvbnN0cnVjdG9yKGRiOiBEZXhpZSkge1xuICByZXR1cm4gbWFrZUNsYXNzQ29uc3RydWN0b3I8V2hlcmVDbGF1c2VDb25zdHJ1Y3Rvcj4oXG4gICAgV2hlcmVDbGF1c2UucHJvdG90eXBlLFxuXG4gICAgZnVuY3Rpb24gV2hlcmVDbGF1c2UodGhpczogV2hlcmVDbGF1c2UsIHRhYmxlOiBUYWJsZSwgaW5kZXg/OiBzdHJpbmcsIG9yQ29sbGVjdGlvbj86IENvbGxlY3Rpb24pIHtcbiAgICAgIHRoaXMuZGIgPSBkYjtcbiAgICAgIHRoaXMuX2N0eCA9IHtcbiAgICAgICAgdGFibGU6IHRhYmxlLFxuICAgICAgICBpbmRleDogaW5kZXggPT09IFwiOmlkXCIgPyBudWxsIDogaW5kZXgsXG4gICAgICAgIG9yOiBvckNvbGxlY3Rpb25cbiAgICAgIH07XG4gICAgICBjb25zdCBpbmRleGVkREIgPSBkYi5fZGVwcy5pbmRleGVkREI7XG4gICAgICBpZiAoIWluZGV4ZWREQikgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuTWlzc2luZ0FQSSgpO1xuICAgICAgdGhpcy5fY21wID0gdGhpcy5fYXNjZW5kaW5nID0gaW5kZXhlZERCLmNtcC5iaW5kKGluZGV4ZWREQik7XG4gICAgICB0aGlzLl9kZXNjZW5kaW5nID0gKGEsIGIpID0+IGluZGV4ZWREQi5jbXAoYiwgYSk7XG4gICAgICB0aGlzLl9tYXggPSAoYSwgYikgPT4gaW5kZXhlZERCLmNtcChhLGIpID4gMCA/IGEgOiBiO1xuICAgICAgdGhpcy5fbWluID0gKGEsIGIpID0+IGluZGV4ZWREQi5jbXAoYSxiKSA8IDAgPyBhIDogYjtcbiAgICAgIHRoaXMuX0lEQktleVJhbmdlID0gZGIuX2RlcHMuSURCS2V5UmFuZ2U7XG4gICAgfVxuICApO1xufVxuIiwgImltcG9ydCB7IHdyYXAgfSBmcm9tIFwiLi4vaGVscGVycy9wcm9taXNlXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBldmVudFJlamVjdEhhbmRsZXIocmVqZWN0KSB7XG4gIHJldHVybiB3cmFwKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgcHJldmVudERlZmF1bHQoZXZlbnQpO1xuICAgICAgcmVqZWN0IChldmVudC50YXJnZXQuZXJyb3IpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGV2ZW50U3VjY2Vzc0hhbmRsZXIgKHJlc29sdmUpIHtcbiAgcmV0dXJuIHdyYXAoZnVuY3Rpb24gKGV2ZW50KXtcbiAgICAgIHJlc29sdmUoZXZlbnQudGFyZ2V0LnJlc3VsdCk7XG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaG9va2VkRXZlbnRSZWplY3RIYW5kbGVyIChyZWplY3QpIHtcbiAgcmV0dXJuIHdyYXAoZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAvLyBTZWUgY29tbWVudCBvbiBob29rZWRFdmVudFN1Y2Nlc3NIYW5kbGVyKCkgd2h5IHdyYXAoKSBpcyBuZWVkZWQgb25seSB3aGVuIHN1cHBvcnRpbmcgaG9va3MuXG4gICAgICBcbiAgICAgIHZhciByZXEgPSBldmVudC50YXJnZXQsXG4gICAgICAgICAgZXJyID0gcmVxLmVycm9yLFxuICAgICAgICAgIGN0eCA9IHJlcS5faG9va0N0eCwvLyBDb250YWlucyB0aGUgaG9vayBlcnJvciBoYW5kbGVyLiBQdXQgaGVyZSBpbnN0ZWFkIG9mIGNsb3N1cmUgdG8gYm9vc3QgcGVyZm9ybWFuY2UuXG4gICAgICAgICAgaG9va0Vycm9ySGFuZGxlciA9IGN0eCAmJiBjdHgub25lcnJvcjtcbiAgICAgIGhvb2tFcnJvckhhbmRsZXIgJiYgaG9va0Vycm9ySGFuZGxlcihlcnIpO1xuICAgICAgcHJldmVudERlZmF1bHQoZXZlbnQpO1xuICAgICAgcmVqZWN0IChlcnIpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhvb2tlZEV2ZW50U3VjY2Vzc0hhbmRsZXIocmVzb2x2ZSkge1xuICAvLyB3cmFwKCkgaXMgbmVlZGVkIHdoZW4gY2FsbGluZyBob29rcyBiZWNhdXNlIHRoZSByYXJlIHNjZW5hcmlvIG9mOlxuICAvLyAgKiBob29rIGRvZXMgYSBkYiBvcGVyYXRpb24gdGhhdCBmYWlscyBpbW1lZGlhdGVseSAoSURCIHRocm93cyBleGNlcHRpb24pXG4gIC8vICAgIEZvciBjYWxsaW5nIGRiIG9wZXJhdGlvbnMgb24gY29ycmVjdCB0cmFuc2FjdGlvbiwgd3JhcCBtYWtlcyBzdXJlIHRvIHNldCBQU0QgY29ycmVjdGx5LlxuICAvLyAgICB3cmFwKCkgd2lsbCBhbHNvIGV4ZWN1dGUgaW4gYSB2aXJ0dWFsIHRpY2suXG4gIC8vICAqIElmIG5vdCB3cmFwcGVkIGluIGEgdmlydHVhbCB0aWNrLCBkaXJlY3QgZXhjZXB0aW9uIHdpbGwgbGF1bmNoIGEgbmV3IHBoeXNpY2FsIHRpY2suXG4gIC8vICAqIElmIHRoaXMgd2FzIHRoZSBsYXN0IGV2ZW50IGluIHRoZSBidWxrLCB0aGUgcHJvbWlzZSB3aWxsIHJlc29sdmUgYWZ0ZXIgYSBwaHlzaWNhbCB0aWNrXG4gIC8vICAgIGFuZCB0aGUgdHJhbnNhY3Rpb24gd2lsbCBoYXZlIGNvbW1pdHRlZCBhbHJlYWR5LlxuICAvLyBJZiBubyBob29rLCB0aGUgdmlydHVhbCB0aWNrIHdpbGwgYmUgZXhlY3V0ZWQgaW4gdGhlIHJlamVjdCgpL3Jlc29sdmUgb2YgdGhlIGZpbmFsIHByb21pc2UsXG4gIC8vIGJlY2F1c2UgaXQgaXMgYWx3YXlzIG1hcmtlZCB3aXRoIF9saWIgPSB0cnVlIHdoZW4gY3JlYXRlZCB1c2luZyBUcmFuc2FjdGlvbi5fcHJvbWlzZSgpLlxuICByZXR1cm4gd3JhcChmdW5jdGlvbihldmVudCkge1xuICAgICAgdmFyIHJlcSA9IGV2ZW50LnRhcmdldCxcbiAgICAgICAgICBjdHggPSByZXEuX2hvb2tDdHgsLy8gQ29udGFpbnMgdGhlIGhvb2sgZXJyb3IgaGFuZGxlci4gUHV0IGhlcmUgaW5zdGVhZCBvZiBjbG9zdXJlIHRvIGJvb3N0IHBlcmZvcm1hbmNlLlxuICAgICAgICAgIHJlc3VsdCA9IGN0eC52YWx1ZSB8fCByZXEucmVzdWx0LCAvLyBQYXNzIHRoZSBvYmplY3QgdmFsdWUgb24gdXBkYXRlcy4gVGhlIHJlc3VsdCBmcm9tIElEQiBpcyB0aGUgcHJpbWFyeSBrZXkuXG4gICAgICAgICAgaG9va1N1Y2Nlc3NIYW5kbGVyID0gY3R4ICYmIGN0eC5vbnN1Y2Nlc3M7XG4gICAgICBob29rU3VjY2Vzc0hhbmRsZXIgJiYgaG9va1N1Y2Nlc3NIYW5kbGVyKHJlc3VsdCk7XG4gICAgICByZXNvbHZlICYmIHJlc29sdmUocmVzdWx0KTtcbiAgfSwgcmVzb2x2ZSk7XG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIHByZXZlbnREZWZhdWx0KGV2ZW50KSB7XG4gIGlmIChldmVudC5zdG9wUHJvcGFnYXRpb24pIC8vIEluZGV4ZWREQlNoaW0gZG9lc250IHN1cHBvcnQgdGhpcyBvbiBTYWZhcmkgOCBhbmQgYmVsb3cuXG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgaWYgKGV2ZW50LnByZXZlbnREZWZhdWx0KSAvLyBJbmRleGVkREJTaGltIGRvZXNudCBzdXBwb3J0IHRoaXMgb24gU2FmYXJpIDggYW5kIGJlbG93LlxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIEJ1bGtFcnJvckhhbmRsZXJDYXRjaEFsbChlcnJvckxpc3QsIGRvbmU/LCBzdXBwb3J0SG9va3M/KSB7XG4gIHJldHVybiAoc3VwcG9ydEhvb2tzID8gaG9va2VkRXZlbnRSZWplY3RIYW5kbGVyIDogZXZlbnRSZWplY3RIYW5kbGVyKShlID0+IHtcbiAgICAgIGVycm9yTGlzdC5wdXNoKGUpO1xuICAgICAgZG9uZSAmJiBkb25lKCk7XG4gIH0pO1xufVxuXG4iLCAiaW1wb3J0IEV2ZW50cyBmcm9tICcuLi9oZWxwZXJzL0V2ZW50cyc7XG5pbXBvcnQgeyBHbG9iYWxEZXhpZUV2ZW50cyB9IGZyb20gJy4uL3B1YmxpYy90eXBlcy9kYi1ldmVudHMnO1xuXG5leHBvcnQgY29uc3QgREVYSUVfU1RPUkFHRV9NVVRBVEVEX0VWRU5UX05BTUUgPSAnc3RvcmFnZW11dGF0ZWQnIGFzICdzdG9yYWdlbXV0YXRlZCc7XG5cbi8vIE5hbWUgb2YgdGhlIGdsb2JhbCBldmVudCBmaXJlZCB1c2luZyBET00gZGlzcGF0Y2hFdmVudCAoaWYgbm90IGluIG5vZGUpLlxuLy8gUmVhc29uIGZvciBwcm9wYWdhdGluZyB0aGlzIGFzIGEgRE9NIGV2ZW50IGlzIGZvciBnZXR0aW5nIHJlYWN0aXZpdHkgYWNyb3NzXG4vLyBtdWx0aXBsZSB2ZXJzaW9ucyBvZiBEZXhpZSB3aXRoaW4gdGhlIHNhbWUgYXBwIChhcyBsb25nIGFzIHRoZXkgYXJlXG4vLyBjb21wYXRpYmxlIHdpdGggcmVnYXJkcyB0byB0aGUgZXZlbnQgZGF0YSkuXG4vLyBJZiB0aGUgT2JzZXJ2YWJpbGl0eVNldCBwcm90b2NvbCBjaGFuZ2UgaW4gYSB3YXkgdGhhdCB3b3VsZCBub3QgYmUgYmFja3dhcmRcbi8vIGNvbXBhdGlibGUsIG1ha2Ugc3VyZSBhbHNvIHVwZGF0ZSB0aGUgZXZlbnQgbmFtZSB0byBhIG5ldyBudW1iZXIgYXQgdGhlIGVuZFxuLy8gc28gdGhhdCB0d28gRGV4aWUgaW5zdGFuY2VzIG9mIGRpZmZlcmVudCB2ZXJzaW9ucyBjb250aW51ZSB0byB3b3JrIHRvZ2V0aGVyXG4vLyAgLSBtYXliZSBub3QgYWJsZSB0byBjb21tdW5pY2F0ZSBidXQgd29uJ3QgZmFpbCBkdWUgdG8gdW5leHBlY3RlZCBkYXRhIGluXG4vLyB0aGUgZGV0YWlsIHByb3BlcnR5IG9mIHRoZSBDdXN0b21FdmVudC4gSWYgc28sIGFsc28gbWFrZSBzdXJlIHRvIHVkcGF0ZVxuLy8gZG9jcyBhbmQgZXhwbGFpbiBhdCB3aGljaCBEZXhpZSB2ZXJzaW9uIHRoZSBuZXcgbmFtZSBhbmQgZm9ybWF0IG9mIHRoZSBldmVudFxuLy8gaXMgYmVpbmcgdXNlZC5cbmV4cG9ydCBjb25zdCBTVE9SQUdFX01VVEFURURfRE9NX0VWRU5UX05BTUUgPSAneC1zdG9yYWdlbXV0YXRlZC0xJztcblxuZXhwb3J0IGNvbnN0IGdsb2JhbEV2ZW50cyA9IEV2ZW50cyhudWxsLCBERVhJRV9TVE9SQUdFX01VVEFURURfRVZFTlRfTkFNRSkgYXMgR2xvYmFsRGV4aWVFdmVudHM7XG4iLCAiaW1wb3J0IHsgVHJhbnNhY3Rpb24gYXMgSVRyYW5zYWN0aW9uIH0gZnJvbSAnLi4vLi4vcHVibGljL3R5cGVzL3RyYW5zYWN0aW9uJztcbmltcG9ydCB7IERleGllUHJvbWlzZSwgd3JhcCwgcmVqZWN0aW9uIH0gZnJvbSBcIi4uLy4uL2hlbHBlcnMvcHJvbWlzZVwiO1xuaW1wb3J0IHsgRGJTY2hlbWEgfSBmcm9tICcuLi8uLi9wdWJsaWMvdHlwZXMvZGItc2NoZW1hJztcbmltcG9ydCB7IGFzc2VydCwgaGFzT3duIH0gZnJvbSAnLi4vLi4vZnVuY3Rpb25zL3V0aWxzJztcbmltcG9ydCB7IFBTRCwgdXNlUFNEIH0gZnJvbSAnLi4vLi4vaGVscGVycy9wcm9taXNlJztcbmltcG9ydCB7IERleGllIH0gZnJvbSAnLi4vZGV4aWUnO1xuaW1wb3J0IHsgZXhjZXB0aW9ucyB9IGZyb20gJy4uLy4uL2Vycm9ycyc7XG5pbXBvcnQgeyBzYWZhcmlNdWx0aVN0b3JlRml4IH0gZnJvbSAnLi4vLi4vZnVuY3Rpb25zL3F1aXJrcyc7XG5pbXBvcnQgeyBwcmV2ZW50RGVmYXVsdCB9IGZyb20gJy4uLy4uL2Z1bmN0aW9ucy9ldmVudC13cmFwcGVycyc7XG5pbXBvcnQgeyBuZXdTY29wZSB9IGZyb20gJy4uLy4uL2hlbHBlcnMvcHJvbWlzZSc7XG5pbXBvcnQgKiBhcyBEZWJ1ZyBmcm9tICcuLi8uLi9oZWxwZXJzL2RlYnVnJztcbmltcG9ydCB7IFRhYmxlIH0gZnJvbSAnLi4vdGFibGUnO1xuaW1wb3J0IHsgZ2xvYmFsRXZlbnRzIH0gZnJvbSAnLi4vLi4vZ2xvYmFscy9nbG9iYWwtZXZlbnRzJztcblxuLyoqIFRyYW5zYWN0aW9uXG4gKiBcbiAqIGh0dHBzOi8vZGV4aWUub3JnL2RvY3MvVHJhbnNhY3Rpb24vVHJhbnNhY3Rpb25cbiAqIFxuICoqL1xuZXhwb3J0IGNsYXNzIFRyYW5zYWN0aW9uIGltcGxlbWVudHMgSVRyYW5zYWN0aW9uIHtcbiAgZGI6IERleGllO1xuICBhY3RpdmU6IGJvb2xlYW47XG4gIG1vZGU6IElEQlRyYW5zYWN0aW9uTW9kZTtcbiAgY2hyb21lVHJhbnNhY3Rpb25EdXJhYmlsaXR5OiBDaHJvbWVUcmFuc2FjdGlvbkR1cmFiaWxpdHk7XG4gIGlkYnRyYW5zOiBJREJUcmFuc2FjdGlvbjtcbiAgc3RvcmVOYW1lczogc3RyaW5nW107XG4gIG9uOiBhbnk7XG4gIHBhcmVudD86IFRyYW5zYWN0aW9uO1xuICBzY2hlbWE6IERiU2NoZW1hO1xuICBfbWVtb2l6ZWRUYWJsZXM6IHtbdGFibGVOYW1lOiBzdHJpbmddOiBUYWJsZX07XG5cbiAgX3JlY3Vsb2NrOiBudW1iZXI7XG4gIF9ibG9ja2VkRnVuY3M6IHsgMDogKCkgPT4gYW55LCAxOiBhbnkgfVtdO1xuICBfcmVzb2x2ZTogKCkgPT4gdm9pZDtcbiAgX3JlamVjdDogKEVycm9yKSA9PiB2b2lkO1xuICBfd2FpdGluZ0ZvcjogRGV4aWVQcm9taXNlOyAvLyBmb3Igd2FpdEZvcigpXG4gIF93YWl0aW5nUXVldWU6IEZ1bmN0aW9uW107IC8vIGZvciB3YWl0Rm9yKClcbiAgX3NwaW5Db3VudDogbnVtYmVyOyAvLyBKdXN0IGZvciBkZWJ1Z2dpbmcgd2FpdEZvcigpXG4gIF9jb21wbGV0aW9uOiBEZXhpZVByb21pc2U7XG5cbiAgLy9cbiAgLy8gVHJhbnNhY3Rpb24gaW50ZXJuYWwgbWV0aG9kcyAobm90IHJlcXVpcmVkIGJ5IEFQSSB1c2VycywgYnV0IG5lZWRlZCBpbnRlcm5hbGx5IGFuZCBldmVudHVhbGx5IGJ5IGRleGllIGV4dGVuc2lvbnMpXG4gIC8vXG5cbiAgLyoqIFRyYW5zYWN0aW9uLl9sb2NrKClcbiAgICogXG4gICAqIEludGVybmFsIG1ldGhvZC5cbiAgICovXG4gIF9sb2NrKCkge1xuICAgIGFzc2VydCghUFNELmdsb2JhbCk7IC8vIExvY2tpbmcgYW5kIHVubG9ja2luZyByZXVpcmVzIHRvIGJlIHdpdGhpbiBhIFBTRCBzY29wZS5cbiAgICAvLyBUZW1wb3Jhcnkgc2V0IGFsbCByZXF1ZXN0cyBpbnRvIGEgcGVuZGluZyBxdWV1ZSBpZiB0aGV5IGFyZSBjYWxsZWQgYmVmb3JlIGRhdGFiYXNlIGlzIHJlYWR5LlxuICAgICsrdGhpcy5fcmVjdWxvY2s7IC8vIFJlY3Vyc2l2ZSByZWFkL3dyaXRlIGxvY2sgcGF0dGVybiB1c2luZyBQU0QgKFByb21pc2UgU3BlY2lmaWMgRGF0YSkgaW5zdGVhZCBvZiBUTFMgKFRocmVhZCBMb2NhbCBTdG9yYWdlKVxuICAgIGlmICh0aGlzLl9yZWN1bG9jayA9PT0gMSAmJiAhUFNELmdsb2JhbCkgUFNELmxvY2tPd25lckZvciA9IHRoaXM7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKiogVHJhbnNhY3Rpb24uX3VubG9jaygpXG4gICAqIFxuICAgKiBJbnRlcm5hbCBtZXRob2QuXG4gICAqL1xuICBfdW5sb2NrKCkge1xuICAgIGFzc2VydCghUFNELmdsb2JhbCk7IC8vIExvY2tpbmcgYW5kIHVubG9ja2luZyByZXVpcmVzIHRvIGJlIHdpdGhpbiBhIFBTRCBzY29wZS5cbiAgICBpZiAoLS10aGlzLl9yZWN1bG9jayA9PT0gMCkge1xuICAgICAgaWYgKCFQU0QuZ2xvYmFsKSBQU0QubG9ja093bmVyRm9yID0gbnVsbDtcbiAgICAgIHdoaWxlICh0aGlzLl9ibG9ja2VkRnVuY3MubGVuZ3RoID4gMCAmJiAhdGhpcy5fbG9ja2VkKCkpIHtcbiAgICAgICAgdmFyIGZuQW5kUFNEID0gdGhpcy5fYmxvY2tlZEZ1bmNzLnNoaWZ0KCk7XG4gICAgICAgIHRyeSB7IHVzZVBTRChmbkFuZFBTRFsxXSwgZm5BbmRQU0RbMF0pOyB9IGNhdGNoIChlKSB7IH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKiogVHJhbnNhY3Rpb24uX2xvY2soKVxuICAgKiBcbiAgICogSW50ZXJuYWwgbWV0aG9kLlxuICAgKi9cbiAgX2xvY2tlZCgpIHtcbiAgICAvLyBDaGVja3MgaWYgYW55IHdyaXRlLWxvY2sgaXMgYXBwbGllZCBvbiB0aGlzIHRyYW5zYWN0aW9uLlxuICAgIC8vIFRvIHNpbXBsaWZ5IHRoZSBEZXhpZSBBUEkgZm9yIGV4dGVuc2lvbiBpbXBsZW1lbnRhdGlvbnMsIHdlIHN1cHBvcnQgcmVjdXJzaXZlIGxvY2tzLlxuICAgIC8vIFRoaXMgaXMgYWNjb21wbGlzaGVkIGJ5IHVzaW5nIFwiUHJvbWlzZSBTcGVjaWZpYyBEYXRhXCIgKFBTRCkuXG4gICAgLy8gUFNEIGRhdGEgaXMgYm91bmQgdG8gYSBQcm9taXNlIGFuZCBhbnkgY2hpbGQgUHJvbWlzZSBlbWl0dGVkIHRocm91Z2ggdGhlbigpIG9yIHJlc29sdmUoIG5ldyBQcm9taXNlKCkgKS5cbiAgICAvLyBQU0QgaXMgbG9jYWwgdG8gY29kZSBleGVjdXRpbmcgb24gdG9wIG9mIHRoZSBjYWxsIHN0YWNrcyBvZiBhbnkgb2YgYW55IGNvZGUgZXhlY3V0ZWQgYnkgUHJvbWlzZSgpOlxuICAgIC8vICAgICAgICAgKiBjYWxsYmFjayBnaXZlbiB0byB0aGUgUHJvbWlzZSgpIGNvbnN0cnVjdG9yICAoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCl7Li4ufSlcbiAgICAvLyAgICAgICAgICogY2FsbGJhY2tzIGdpdmVuIHRvIHRoZW4oKS9jYXRjaCgpL2ZpbmFsbHkoKSBtZXRob2RzIChmdW5jdGlvbiAodmFsdWUpey4uLn0pXG4gICAgLy8gSWYgY3JlYXRpbmcgYSBuZXcgaW5kZXBlbmRhbnQgUHJvbWlzZSBpbnN0YW5jZSBmcm9tIHdpdGhpbiBhIFByb21pc2UgY2FsbCBzdGFjaywgdGhlIG5ldyBQcm9taXNlIHdpbGwgZGVyaXZlIHRoZSBQU0QgZnJvbSB0aGUgY2FsbCBzdGFjayBvZiB0aGUgcGFyZW50IFByb21pc2UuXG4gICAgLy8gRGVyaXZhdGlvbiBpcyBkb25lIHNvIHRoYXQgdGhlIGlubmVyIFBTRCBfX3Byb3RvX18gcG9pbnRzIHRvIHRoZSBvdXRlciBQU0QuXG4gICAgLy8gUFNELmxvY2tPd25lckZvciB3aWxsIHBvaW50IHRvIGN1cnJlbnQgdHJhbnNhY3Rpb24gb2JqZWN0IGlmIHRoZSBjdXJyZW50bHkgZXhlY3V0aW5nIFBTRCBzY29wZSBvd25zIHRoZSBsb2NrLlxuICAgIHJldHVybiB0aGlzLl9yZWN1bG9jayAmJiBQU0QubG9ja093bmVyRm9yICE9PSB0aGlzO1xuICB9XG5cbiAgLyoqIFRyYW5zYWN0aW9uLmNyZWF0ZSgpXG4gICAqIFxuICAgKiBJbnRlcm5hbCBtZXRob2QuXG4gICAqIFxuICAgKi9cbiAgY3JlYXRlKGlkYnRyYW5zPzogSURCVHJhbnNhY3Rpb24pIHtcbiAgICBpZiAoIXRoaXMubW9kZSkgcmV0dXJuIHRoaXM7XG4gICAgY29uc3QgaWRiZGIgPSB0aGlzLmRiLmlkYmRiO1xuICAgIGNvbnN0IGRiT3BlbkVycm9yID0gdGhpcy5kYi5fc3RhdGUuZGJPcGVuRXJyb3I7XG4gICAgYXNzZXJ0KCF0aGlzLmlkYnRyYW5zKTtcbiAgICBpZiAoIWlkYnRyYW5zICYmICFpZGJkYikge1xuICAgICAgc3dpdGNoIChkYk9wZW5FcnJvciAmJiBkYk9wZW5FcnJvci5uYW1lKSB7XG4gICAgICAgIGNhc2UgXCJEYXRhYmFzZUNsb3NlZEVycm9yXCI6XG4gICAgICAgICAgLy8gRXJyb3JzIHdoZXJlIGl0IGlzIG5vIGRpZmZlcmVuY2Ugd2hldGhlciBpdCB3YXMgY2F1c2VkIGJ5IHRoZSB1c2VyIG9wZXJhdGlvbiBvciBhbiBlYXJsaWVyIGNhbGwgdG8gZGIub3BlbigpXG4gICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuRGF0YWJhc2VDbG9zZWQoZGJPcGVuRXJyb3IpO1xuICAgICAgICBjYXNlIFwiTWlzc2luZ0FQSUVycm9yXCI6XG4gICAgICAgICAgLy8gRXJyb3JzIHdoZXJlIGl0IGlzIG5vIGRpZmZlcmVuY2Ugd2hldGhlciBpdCB3YXMgY2F1c2VkIGJ5IHRoZSB1c2VyIG9wZXJhdGlvbiBvciBhbiBlYXJsaWVyIGNhbGwgdG8gZGIub3BlbigpXG4gICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuTWlzc2luZ0FQSShkYk9wZW5FcnJvci5tZXNzYWdlLCBkYk9wZW5FcnJvcik7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgLy8gTWFrZSBpdCBjbGVhciB0aGF0IHRoZSB1c2VyIG9wZXJhdGlvbiB3YXMgbm90IHdoYXQgY2F1c2VkIHRoZSBlcnJvciAtIHRoZSBlcnJvciBoYWQgb2NjdXJyZWQgZWFybGllciBvbiBkYi5vcGVuKCkhXG4gICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuT3BlbkZhaWxlZChkYk9wZW5FcnJvcik7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghdGhpcy5hY3RpdmUpIHRocm93IG5ldyBleGNlcHRpb25zLlRyYW5zYWN0aW9uSW5hY3RpdmUoKTtcbiAgICBhc3NlcnQodGhpcy5fY29tcGxldGlvbi5fc3RhdGUgPT09IG51bGwpOyAvLyBDb21wbGV0aW9uIFByb21pc2UgbXVzdCBzdGlsbCBiZSBwZW5kaW5nLlxuXG4gICAgaWRidHJhbnMgPSB0aGlzLmlkYnRyYW5zID0gaWRidHJhbnMgfHxcbiAgICAgICh0aGlzLmRiLmNvcmUgXG4gICAgICAgID8gdGhpcy5kYi5jb3JlLnRyYW5zYWN0aW9uKHRoaXMuc3RvcmVOYW1lcywgdGhpcy5tb2RlIGFzICdyZWFkd3JpdGUnIHwgJ3JlYWRvbmx5JywgeyBkdXJhYmlsaXR5OiB0aGlzLmNocm9tZVRyYW5zYWN0aW9uRHVyYWJpbGl0eSB9KVxuICAgICAgICA6IGlkYmRiLnRyYW5zYWN0aW9uKHRoaXMuc3RvcmVOYW1lcywgdGhpcy5tb2RlLCB7IGR1cmFiaWxpdHk6IHRoaXMuY2hyb21lVHJhbnNhY3Rpb25EdXJhYmlsaXR5IH0pXG4gICAgICApIGFzIElEQlRyYW5zYWN0aW9uO1xuXG4gICAgaWRidHJhbnMub25lcnJvciA9IHdyYXAoZXYgPT4ge1xuICAgICAgcHJldmVudERlZmF1bHQoZXYpOy8vIFByb2hpYml0IGRlZmF1bHQgYnViYmxpbmcgdG8gd2luZG93LmVycm9yXG4gICAgICB0aGlzLl9yZWplY3QoaWRidHJhbnMuZXJyb3IpO1xuICAgIH0pO1xuICAgIGlkYnRyYW5zLm9uYWJvcnQgPSB3cmFwKGV2ID0+IHtcbiAgICAgIHByZXZlbnREZWZhdWx0KGV2KTtcbiAgICAgIHRoaXMuYWN0aXZlICYmIHRoaXMuX3JlamVjdChuZXcgZXhjZXB0aW9ucy5BYm9ydChpZGJ0cmFucy5lcnJvcikpO1xuICAgICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgICAgIHRoaXMub24oXCJhYm9ydFwiKS5maXJlKGV2KTtcbiAgICB9KTtcbiAgICBpZGJ0cmFucy5vbmNvbXBsZXRlID0gd3JhcCgoKSA9PiB7XG4gICAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgdGhpcy5fcmVzb2x2ZSgpO1xuICAgICAgaWYgKCdtdXRhdGVkUGFydHMnIGluIGlkYnRyYW5zKSB7XG4gICAgICAgIGdsb2JhbEV2ZW50cy5zdG9yYWdlbXV0YXRlZC5maXJlKGlkYnRyYW5zW1wibXV0YXRlZFBhcnRzXCJdKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKiBUcmFuc2FjdGlvbi5fcHJvbWlzZSgpXG4gICAqIFxuICAgKiBJbnRlcm5hbCBtZXRob2QuXG4gICAqL1xuICBfcHJvbWlzZShcbiAgICBtb2RlOiBJREJUcmFuc2FjdGlvbk1vZGUsXG4gICAgZm46IChyZXNvbHZlLCByZWplY3QsIHRyYW5zOiBUcmFuc2FjdGlvbikgPT4gUHJvbWlzZUxpa2U8YW55PiB8IHZvaWQsXG4gICAgYldyaXRlTG9jaz86IHN0cmluZyB8IGJvb2xlYW4pOiBEZXhpZVByb21pc2VcbiAge1xuICAgIGlmIChtb2RlID09PSAncmVhZHdyaXRlJyAmJiB0aGlzLm1vZGUgIT09ICdyZWFkd3JpdGUnKVxuICAgICAgcmV0dXJuIHJlamVjdGlvbihuZXcgZXhjZXB0aW9ucy5SZWFkT25seShcIlRyYW5zYWN0aW9uIGlzIHJlYWRvbmx5XCIpKTtcblxuICAgIGlmICghdGhpcy5hY3RpdmUpXG4gICAgICByZXR1cm4gcmVqZWN0aW9uKG5ldyBleGNlcHRpb25zLlRyYW5zYWN0aW9uSW5hY3RpdmUoKSk7XG5cbiAgICBpZiAodGhpcy5fbG9ja2VkKCkpIHtcbiAgICAgIHJldHVybiBuZXcgRGV4aWVQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgdGhpcy5fYmxvY2tlZEZ1bmNzLnB1c2goWygpID0+IHtcbiAgICAgICAgICB0aGlzLl9wcm9taXNlKG1vZGUsIGZuLCBiV3JpdGVMb2NrKS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0sIFBTRF0pO1xuICAgICAgfSk7XG5cbiAgICB9IGVsc2UgaWYgKGJXcml0ZUxvY2spIHtcbiAgICAgIHJldHVybiBuZXdTY29wZSgoKSA9PiB7XG4gICAgICAgIHZhciBwID0gbmV3IERleGllUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgdGhpcy5fbG9jaygpO1xuICAgICAgICAgIGNvbnN0IHJ2ID0gZm4ocmVzb2x2ZSwgcmVqZWN0LCB0aGlzKTtcbiAgICAgICAgICBpZiAocnYgJiYgcnYudGhlbikgcnYudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgICAgcC5maW5hbGx5KCgpID0+IHRoaXMuX3VubG9jaygpKTtcbiAgICAgICAgcC5fbGliID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHA7XG4gICAgICB9KTtcblxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcCA9IG5ldyBEZXhpZVByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICB2YXIgcnYgPSBmbihyZXNvbHZlLCByZWplY3QsIHRoaXMpO1xuICAgICAgICBpZiAocnYgJiYgcnYudGhlbikgcnYudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgfSk7XG4gICAgICBwLl9saWIgPSB0cnVlO1xuICAgICAgcmV0dXJuIHA7XG4gICAgfVxuICB9XG5cbiAgLyoqIFRyYW5zYWN0aW9uLl9yb290KClcbiAgICogXG4gICAqIEludGVybmFsIG1ldGhvZC4gUmV0cmlldmVzIHRoZSByb290IHRyYW5zYWN0aW9uIGluIHRoZSB0cmVlIG9mIHN1YiB0cmFuc2FjdGlvbnMuXG4gICAqL1xuICBfcm9vdCgpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJlbnQgPyB0aGlzLnBhcmVudC5fcm9vdCgpIDogdGhpcztcbiAgfVxuXG4gIC8qKiBUcmFuc2FjdGlvbi53YWl0Rm9yKClcbiAgICogXG4gICAqIEludGVybmFsIG1ldGhvZC4gQ2FuIGJlIGFjY2Vzc2VkIGZyb20gdGhlIHB1YmxpYyBBUEkgdGhyb3VnaFxuICAgKiBEZXhpZS53YWl0Rm9yKCk6IGh0dHBzOi8vZGV4aWUub3JnL2RvY3MvRGV4aWUvRGV4aWUud2FpdEZvcigpXG4gICAqIFxuICAgKiovXG4gIHdhaXRGb3IocHJvbWlzZUxpa2U6IFByb21pc2VMaWtlPGFueT4pIHtcbiAgICAvLyBBbHdheXMgb3BlcmF0ZSBvbiB0aGUgcm9vdCB0cmFuc2FjdGlvbiAoaW4gY2FzZSB0aGlzIGlzIGEgc3ViIHN0cmFuc2FjdGlvbilcbiAgICB2YXIgcm9vdCA9IHRoaXMuX3Jvb3QoKTtcbiAgICAvLyBGb3Igc3RhYmlsaXR5IHJlYXNvbnMsIGNvbnZlcnQgcGFyYW1ldGVyIHRvIHByb21pc2Ugbm8gbWF0dGVyIHdoYXQgdHlwZSBpcyBwYXNzZWQgdG8gd2FpdEZvcigpLlxuICAgIC8vIChXZSBtdXN0IGJlIGFibGUgdG8gY2FsbCAudGhlbigpIG9uIGl0LilcbiAgICBjb25zdCBwcm9taXNlID0gRGV4aWVQcm9taXNlLnJlc29sdmUocHJvbWlzZUxpa2UpO1xuICAgIGlmIChyb290Ll93YWl0aW5nRm9yKSB7XG4gICAgICAvLyBBbHJlYWR5IGNhbGxlZCB3YWl0Rm9yKCkuIFdhaXQgZm9yIGJvdGggdG8gY29tcGxldGUuXG4gICAgICByb290Ll93YWl0aW5nRm9yID0gcm9vdC5fd2FpdGluZ0Zvci50aGVuKCgpID0+IHByb21pc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBXZSdyZSBub3QgaW4gd2FpdGluZyBzdGF0ZS4gU3RhcnQgd2FpdGluZyBzdGF0ZS5cbiAgICAgIHJvb3QuX3dhaXRpbmdGb3IgPSBwcm9taXNlO1xuICAgICAgcm9vdC5fd2FpdGluZ1F1ZXVlID0gW107XG4gICAgICAvLyBTdGFydCBpbnRlcmFjdGluZyB3aXRoIGluZGV4ZWREQiB1bnRpbCBwcm9taXNlIGNvbXBsZXRlczpcbiAgICAgIHZhciBzdG9yZSA9IHJvb3QuaWRidHJhbnMub2JqZWN0U3RvcmUocm9vdC5zdG9yZU5hbWVzWzBdKTtcbiAgICAgIChmdW5jdGlvbiBzcGluKCkge1xuICAgICAgICArK3Jvb3QuX3NwaW5Db3VudDsgLy8gRm9yIGRlYnVnZ2luZyBvbmx5XG4gICAgICAgIHdoaWxlIChyb290Ll93YWl0aW5nUXVldWUubGVuZ3RoKSAocm9vdC5fd2FpdGluZ1F1ZXVlLnNoaWZ0KCkpKCk7XG4gICAgICAgIGlmIChyb290Ll93YWl0aW5nRm9yKSBzdG9yZS5nZXQoLUluZmluaXR5KS5vbnN1Y2Nlc3MgPSBzcGluO1xuICAgICAgfSgpKTtcbiAgICB9XG4gICAgdmFyIGN1cnJlbnRXYWl0UHJvbWlzZSA9IHJvb3QuX3dhaXRpbmdGb3I7XG4gICAgcmV0dXJuIG5ldyBEZXhpZVByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgcHJvbWlzZS50aGVuKFxuICAgICAgICByZXMgPT4gcm9vdC5fd2FpdGluZ1F1ZXVlLnB1c2god3JhcChyZXNvbHZlLmJpbmQobnVsbCwgcmVzKSkpLFxuICAgICAgICBlcnIgPT4gcm9vdC5fd2FpdGluZ1F1ZXVlLnB1c2god3JhcChyZWplY3QuYmluZChudWxsLCBlcnIpKSlcbiAgICAgICkuZmluYWxseSgoKSA9PiB7XG4gICAgICAgIGlmIChyb290Ll93YWl0aW5nRm9yID09PSBjdXJyZW50V2FpdFByb21pc2UpIHtcbiAgICAgICAgICAvLyBObyBvbmUgYWRkZWQgYSB3YWl0IGFmdGVyIHVzLiBTYWZlIHRvIHN0b3AgdGhlIHNwaW5uaW5nLlxuICAgICAgICAgIHJvb3QuX3dhaXRpbmdGb3IgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSAgXG5cbiAgLyoqIFRyYW5zYWN0aW9uLmFib3J0KClcbiAgICogXG4gICAqIGh0dHBzOi8vZGV4aWUub3JnL2RvY3MvVHJhbnNhY3Rpb24vVHJhbnNhY3Rpb24uYWJvcnQoKVxuICAgKi9cbiAgYWJvcnQoKSB7XG4gICAgaWYgKHRoaXMuYWN0aXZlKSB7XG4gICAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgaWYgKHRoaXMuaWRidHJhbnMpIHRoaXMuaWRidHJhbnMuYWJvcnQoKTtcbiAgICAgIHRoaXMuX3JlamVjdChuZXcgZXhjZXB0aW9ucy5BYm9ydCgpKTtcbiAgICB9XG4gIH1cblxuICAvKiogVHJhbnNhY3Rpb24udGFibGUoKVxuICAgKiBcbiAgICogaHR0cHM6Ly9kZXhpZS5vcmcvZG9jcy9UcmFuc2FjdGlvbi9UcmFuc2FjdGlvbi50YWJsZSgpXG4gICAqL1xuICB0YWJsZSh0YWJsZU5hbWU6IHN0cmluZykge1xuICAgIGNvbnN0IG1lbW9pemVkVGFibGVzID0gKHRoaXMuX21lbW9pemVkVGFibGVzIHx8ICh0aGlzLl9tZW1vaXplZFRhYmxlcyA9IHt9KSk7XG4gICAgaWYgKGhhc093bihtZW1vaXplZFRhYmxlcywgdGFibGVOYW1lKSlcbiAgICAgIHJldHVybiBtZW1vaXplZFRhYmxlc1t0YWJsZU5hbWVdO1xuICAgIGNvbnN0IHRhYmxlU2NoZW1hID0gdGhpcy5zY2hlbWFbdGFibGVOYW1lXTtcbiAgICBpZiAoIXRhYmxlU2NoZW1hKSB7XG4gICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5Ob3RGb3VuZChcIlRhYmxlIFwiICsgdGFibGVOYW1lICsgXCIgbm90IHBhcnQgb2YgdHJhbnNhY3Rpb25cIik7ICAgICAgICBcbiAgICB9XG5cbiAgICBjb25zdCB0cmFuc2FjdGlvbkJvdW5kVGFibGUgPSBuZXcgdGhpcy5kYi5UYWJsZSh0YWJsZU5hbWUsIHRhYmxlU2NoZW1hLCB0aGlzKTtcbiAgICB0cmFuc2FjdGlvbkJvdW5kVGFibGUuY29yZSA9IHRoaXMuZGIuY29yZS50YWJsZSh0YWJsZU5hbWUpO1xuICAgIG1lbW9pemVkVGFibGVzW3RhYmxlTmFtZV0gPSB0cmFuc2FjdGlvbkJvdW5kVGFibGU7XG4gICAgcmV0dXJuIHRyYW5zYWN0aW9uQm91bmRUYWJsZTtcbiAgfVxufVxuIiwgImltcG9ydCB7IERleGllIH0gZnJvbSAnLi4vZGV4aWUnO1xuaW1wb3J0IHsgbWFrZUNsYXNzQ29uc3RydWN0b3IgfSBmcm9tICcuLi8uLi9mdW5jdGlvbnMvbWFrZS1jbGFzcy1jb25zdHJ1Y3Rvcic7XG5pbXBvcnQgeyBUcmFuc2FjdGlvbiB9IGZyb20gJy4vdHJhbnNhY3Rpb24nO1xuaW1wb3J0IHsgRGJTY2hlbWEgfSBmcm9tICcuLi8uLi9wdWJsaWMvdHlwZXMvZGItc2NoZW1hJztcbmltcG9ydCBFdmVudHMgZnJvbSAnLi4vLi4vaGVscGVycy9FdmVudHMnO1xuaW1wb3J0IFByb21pc2UsIHsgcmVqZWN0aW9uIH0gZnJvbSAnLi4vLi4vaGVscGVycy9wcm9taXNlJztcblxuZXhwb3J0IGludGVyZmFjZSBUcmFuc2FjdGlvbkNvbnN0cnVjdG9yPFQgZXh0ZW5kcyBUcmFuc2FjdGlvbj1UcmFuc2FjdGlvbj4ge1xuICBuZXcgKFxuICAgIG1vZGU6IElEQlRyYW5zYWN0aW9uTW9kZSxcbiAgICBzdG9yZU5hbWVzOiBzdHJpbmdbXSxcbiAgICBkYnNjaGVtYTogRGJTY2hlbWEsXG4gICAgY2hyb21lVHJhbnNhY3Rpb25EdXJhYmlsaXR5OiBDaHJvbWVUcmFuc2FjdGlvbkR1cmFiaWxpdHksXG4gICAgcGFyZW50PzogVHJhbnNhY3Rpb24pIDogVDtcbiAgcHJvdG90eXBlOiBUO1xufVxuXG4vKiogR2VuZXJhdGVzIGEgVHJhbnNhY3Rpb24gY29uc3RydWN0b3IgYm91bmQgdG8gZ2l2ZW4gRGV4aWUgaW5zdGFuY2UuXG4gKiBcbiAqIFRoZSBwdXJwb3NlIG9mIGhhdmluZyBkeW5hbWljYWxseSBjcmVhdGVkIGNvbnN0cnVjdG9ycywgaXMgdG8gYWxsb3dcbiAqIGFkZG9ucyB0byBleHRlbmQgY2xhc3NlcyBmb3IgYSBjZXJ0YWluIERleGllIGluc3RhbmNlIHdpdGhvdXQgYWZmZWN0aW5nXG4gKiBvdGhlciBkYiBpbnN0YW5jZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVUcmFuc2FjdGlvbkNvbnN0cnVjdG9yKGRiOiBEZXhpZSkge1xuICByZXR1cm4gbWFrZUNsYXNzQ29uc3RydWN0b3I8VHJhbnNhY3Rpb25Db25zdHJ1Y3RvcjxUcmFuc2FjdGlvbj4+KFxuICAgIFRyYW5zYWN0aW9uLnByb3RvdHlwZSxcbiAgICBmdW5jdGlvbiBUcmFuc2FjdGlvbiAoXG4gICAgICB0aGlzOiBUcmFuc2FjdGlvbixcbiAgICAgIG1vZGU6IElEQlRyYW5zYWN0aW9uTW9kZSxcbiAgICAgIHN0b3JlTmFtZXM6IHN0cmluZ1tdLFxuICAgICAgZGJzY2hlbWE6IERiU2NoZW1hLFxuICAgICAgY2hyb21lVHJhbnNhY3Rpb25EdXJhYmlsaXR5OiBDaHJvbWVUcmFuc2FjdGlvbkR1cmFiaWxpdHksXG4gICAgICBwYXJlbnQ/OiBUcmFuc2FjdGlvbilcbiAgICB7XG4gICAgICB0aGlzLmRiID0gZGI7XG4gICAgICB0aGlzLm1vZGUgPSBtb2RlO1xuICAgICAgdGhpcy5zdG9yZU5hbWVzID0gc3RvcmVOYW1lcztcbiAgICAgIHRoaXMuc2NoZW1hID0gZGJzY2hlbWE7XG4gICAgICB0aGlzLmNocm9tZVRyYW5zYWN0aW9uRHVyYWJpbGl0eSA9IGNocm9tZVRyYW5zYWN0aW9uRHVyYWJpbGl0eTtcbiAgICAgIHRoaXMuaWRidHJhbnMgPSBudWxsO1xuICAgICAgdGhpcy5vbiA9IEV2ZW50cyh0aGlzLCBcImNvbXBsZXRlXCIsIFwiZXJyb3JcIiwgXCJhYm9ydFwiKTtcbiAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50IHx8IG51bGw7XG4gICAgICB0aGlzLmFjdGl2ZSA9IHRydWU7XG4gICAgICB0aGlzLl9yZWN1bG9jayA9IDA7XG4gICAgICB0aGlzLl9ibG9ja2VkRnVuY3MgPSBbXTtcbiAgICAgIHRoaXMuX3Jlc29sdmUgPSBudWxsO1xuICAgICAgdGhpcy5fcmVqZWN0ID0gbnVsbDtcbiAgICAgIHRoaXMuX3dhaXRpbmdGb3IgPSBudWxsO1xuICAgICAgdGhpcy5fd2FpdGluZ1F1ZXVlID0gbnVsbDtcbiAgICAgIHRoaXMuX3NwaW5Db3VudCA9IDA7IC8vIEp1c3QgZm9yIGRlYnVnZ2luZyB3YWl0Rm9yKClcbiAgICAgIHRoaXMuX2NvbXBsZXRpb24gPSBuZXcgUHJvbWlzZSAoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgIHRoaXMuX3Jlc29sdmUgPSByZXNvbHZlO1xuICAgICAgICAgIHRoaXMuX3JlamVjdCA9IHJlamVjdDtcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICB0aGlzLl9jb21wbGV0aW9uLnRoZW4oXG4gICAgICAgICAgKCk9PiB7XG4gICAgICAgICAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICAgIHRoaXMub24uY29tcGxldGUuZmlyZSgpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZSA9PiB7XG4gICAgICAgICAgICAgIHZhciB3YXNBY3RpdmUgPSB0aGlzLmFjdGl2ZTtcbiAgICAgICAgICAgICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgdGhpcy5vbi5lcnJvci5maXJlKGUpO1xuICAgICAgICAgICAgICB0aGlzLnBhcmVudCA/XG4gICAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5fcmVqZWN0KGUpIDpcbiAgICAgICAgICAgICAgICAgIHdhc0FjdGl2ZSAmJiB0aGlzLmlkYnRyYW5zICYmIHRoaXMuaWRidHJhbnMuYWJvcnQoKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdGlvbihlKTsgLy8gSW5kaWNhdGUgd2UgYWN0dWFsbHkgRE8gTk9UIGNhdGNoIHRoaXMgZXJyb3IuXG4gICAgICAgICAgfSk7XG4gICAgXG4gICAgfSk7XG59XG4iLCAiaW1wb3J0IHsgSW5kZXhTcGVjIH0gZnJvbSAnLi4vcHVibGljL3R5cGVzL2luZGV4LXNwZWMnO1xuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlSW5kZXhTcGVjKFxuICBuYW1lOiBzdHJpbmcsXG4gIGtleVBhdGg6IHN0cmluZyB8IHN0cmluZ1tdLFxuICB1bmlxdWU6IGJvb2xlYW4sXG4gIG11bHRpOiBib29sZWFuLFxuICBhdXRvOiBib29sZWFuLFxuICBjb21wb3VuZDogYm9vbGVhbixcbiAgaXNQcmltS2V5OiBib29sZWFuXG4pOiBJbmRleFNwZWMge1xuICByZXR1cm4ge1xuICAgIG5hbWUsXG4gICAga2V5UGF0aCxcbiAgICB1bmlxdWUsXG4gICAgbXVsdGksXG4gICAgYXV0byxcbiAgICBjb21wb3VuZCxcbiAgICBzcmM6ICh1bmlxdWUgJiYgIWlzUHJpbUtleSA/ICcmJyA6ICcnKSArIChtdWx0aSA/ICcqJyA6ICcnKSArIChhdXRvID8gXCIrK1wiIDogXCJcIikgKyBuYW1lRnJvbUtleVBhdGgoa2V5UGF0aClcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbmFtZUZyb21LZXlQYXRoIChrZXlQYXRoPzogc3RyaW5nIHwgc3RyaW5nW10pOiBzdHJpbmcge1xuICByZXR1cm4gdHlwZW9mIGtleVBhdGggPT09ICdzdHJpbmcnID9cbiAgICBrZXlQYXRoIDpcbiAgICBrZXlQYXRoID8gKCdbJyArIFtdLmpvaW4uY2FsbChrZXlQYXRoLCAnKycpICsgJ10nKSA6IFwiXCI7XG59XG4iLCAiaW1wb3J0IHsgSW5kZXhTcGVjIH0gZnJvbSAnLi4vcHVibGljL3R5cGVzL2luZGV4LXNwZWMnO1xuaW1wb3J0IHsgVGFibGVTY2hlbWEgfSBmcm9tICcuLi9wdWJsaWMvdHlwZXMvdGFibGUtc2NoZW1hJztcbmltcG9ydCB7IGNyZWF0ZUluZGV4U3BlYyB9IGZyb20gJy4vaW5kZXgtc3BlYyc7XG5pbXBvcnQgeyBhcnJheVRvT2JqZWN0IH0gZnJvbSAnLi4vZnVuY3Rpb25zL3V0aWxzJztcblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVRhYmxlU2NoZW1hIChcbiAgbmFtZTogc3RyaW5nLFxuICBwcmltS2V5OiBJbmRleFNwZWMsXG4gIGluZGV4ZXM6IEluZGV4U3BlY1tdXG4pOiBUYWJsZVNjaGVtYSB7XG4gIHJldHVybiB7XG4gICAgbmFtZSxcbiAgICBwcmltS2V5LFxuICAgIGluZGV4ZXMsXG4gICAgbWFwcGVkQ2xhc3M6IG51bGwsXG4gICAgaWR4QnlOYW1lOiBhcnJheVRvT2JqZWN0KGluZGV4ZXMsIGluZGV4ID0+IFtpbmRleC5uYW1lLCBpbmRleF0pXG4gIH07XG59XG4iLCAiaW1wb3J0IHsgbWF4U3RyaW5nIH0gZnJvbSAnLi4vZ2xvYmFscy9jb25zdGFudHMnO1xuXG5leHBvcnQgZnVuY3Rpb24gc2FmYXJpTXVsdGlTdG9yZUZpeChzdG9yZU5hbWVzOiBzdHJpbmdbXSkge1xuICByZXR1cm4gc3RvcmVOYW1lcy5sZW5ndGggPT09IDEgPyBzdG9yZU5hbWVzWzBdIDogc3RvcmVOYW1lcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldE5hdGl2ZUdldERhdGFiYXNlTmFtZXNGbihpbmRleGVkREIpIHtcbiAgdmFyIGZuID0gaW5kZXhlZERCICYmIChpbmRleGVkREIuZ2V0RGF0YWJhc2VOYW1lcyB8fCBpbmRleGVkREIud2Via2l0R2V0RGF0YWJhc2VOYW1lcyk7XG4gIHJldHVybiBmbiAmJiBmbi5iaW5kKGluZGV4ZWREQik7XG59XG5cbmV4cG9ydCBsZXQgZ2V0TWF4S2V5ID0gKElkYktleVJhbmdlOiB0eXBlb2YgSURCS2V5UmFuZ2UpID0+IHtcbiAgdHJ5IHtcbiAgICBJZGJLZXlSYW5nZS5vbmx5KFtbXV0pO1xuICAgIGdldE1heEtleSA9ICgpID0+IFtbXV07XG4gICAgcmV0dXJuIFtbXV07XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBnZXRNYXhLZXkgPSAoKSA9PiBtYXhTdHJpbmc7XG4gICAgcmV0dXJuIG1heFN0cmluZztcbiAgfVxufVxuIiwgImltcG9ydCB7IGdldEJ5S2V5UGF0aCB9IGZyb20gJy4uL2Z1bmN0aW9ucy91dGlscyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRLZXlFeHRyYWN0b3IgKGtleVBhdGg6IG51bGwgfCBzdHJpbmcgfCBzdHJpbmdbXSkgOiAoYTogYW55KSA9PiBhbnkge1xuICBpZiAoa2V5UGF0aCA9PSBudWxsKSB7XG4gICAgcmV0dXJuICgpID0+IHVuZGVmaW5lZDtcbiAgfSBlbHNlIGlmICh0eXBlb2Yga2V5UGF0aCA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZ2V0U2luZ2xlUGF0aEtleUV4dHJhY3RvcihrZXlQYXRoKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gb2JqID0+IGdldEJ5S2V5UGF0aChvYmosIGtleVBhdGgpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRTaW5nbGVQYXRoS2V5RXh0cmFjdG9yKGtleVBhdGg6IHN0cmluZykge1xuICBjb25zdCBzcGxpdCA9IGtleVBhdGguc3BsaXQoJy4nKTtcbiAgaWYgKHNwbGl0Lmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBvYmogPT4gb2JqW2tleVBhdGhdO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBvYmogPT4gZ2V0QnlLZXlQYXRoKG9iaiwga2V5UGF0aCk7XG4gIH1cbn1cbiIsICJpbXBvcnQge1xuICBEQkNvcmUsXG4gIERCQ29yZUN1cnNvcixcbiAgREJDb3JlT3BlbkN1cnNvclJlcXVlc3QsXG4gIERCQ29yZVF1ZXJ5UmVxdWVzdCxcbiAgREJDb3JlSW5kZXgsXG4gIERCQ29yZUtleVJhbmdlLFxuICBEQkNvcmVRdWVyeVJlc3BvbnNlLFxuICBEQkNvcmVSYW5nZVR5cGUsXG4gIERCQ29yZVNjaGVtYSxcbiAgREJDb3JlVGFibGVTY2hlbWEsXG4gIERCQ29yZVRhYmxlLFxuICBEQkNvcmVNdXRhdGVSZXNwb25zZSxcbn0gZnJvbSBcIi4uL3B1YmxpYy90eXBlcy9kYmNvcmVcIjtcbmltcG9ydCB7IGlzQXJyYXkgfSBmcm9tICcuLi9mdW5jdGlvbnMvdXRpbHMnO1xuaW1wb3J0IHsgZXZlbnRSZWplY3RIYW5kbGVyLCBwcmV2ZW50RGVmYXVsdCB9IGZyb20gJy4uL2Z1bmN0aW9ucy9ldmVudC13cmFwcGVycyc7XG5pbXBvcnQgeyB3cmFwIH0gZnJvbSAnLi4vaGVscGVycy9wcm9taXNlJztcbmltcG9ydCB7IGdldE1heEtleSB9IGZyb20gJy4uL2Z1bmN0aW9ucy9xdWlya3MnO1xuaW1wb3J0IHsgZ2V0S2V5RXh0cmFjdG9yIH0gZnJvbSAnLi9nZXQta2V5LWV4dHJhY3Rvcic7XG5cbmV4cG9ydCBmdW5jdGlvbiBhcnJheWlmeTxUPihhcnJheUxpa2U6IHtsZW5ndGg6IG51bWJlciwgW2luZGV4OiBudW1iZXJdOiBUfSk6IFRbXSB7XG4gIHJldHVybiBbXS5zbGljZS5jYWxsKGFycmF5TGlrZSk7XG59XG5leHBvcnQgZnVuY3Rpb24gcGljazxULFByb3AgZXh0ZW5kcyBrZXlvZiBUPihvYmo6IFQsIHByb3BzOiBQcm9wW10pOiBQaWNrPFQsIFByb3A+IHtcbiAgY29uc3QgcmVzdWx0ID0ge30gYXMgUGljazxULCBQcm9wPjtcbiAgcHJvcHMuZm9yRWFjaChwcm9wID0+IHJlc3VsdFtwcm9wXSA9IG9ialtwcm9wXSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmxldCBfaWRfY291bnRlciA9IDA7XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRLZXlQYXRoQWxpYXMoa2V5UGF0aDogbnVsbCB8IHN0cmluZyB8IHN0cmluZ1tdKSB7XG4gIHJldHVybiBrZXlQYXRoID09IG51bGwgP1xuICAgIFwiOmlkXCIgOlxuICAgIHR5cGVvZiBrZXlQYXRoID09PSAnc3RyaW5nJyA/XG4gICAgICBrZXlQYXRoIDpcbiAgICAgIGBbJHtrZXlQYXRoLmpvaW4oJysnKX1dYDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZURCQ29yZSAoXG4gIGRiOiBJREJEYXRhYmFzZSxcbiAgSWRiS2V5UmFuZ2U6IHR5cGVvZiBJREJLZXlSYW5nZSxcbiAgdG1wVHJhbnM6IElEQlRyYW5zYWN0aW9uKSA6IERCQ29yZVxue1xuICBmdW5jdGlvbiBleHRyYWN0U2NoZW1hKGRiOiBJREJEYXRhYmFzZSwgdHJhbnM6IElEQlRyYW5zYWN0aW9uKSA6IHtzY2hlbWE6IERCQ29yZVNjaGVtYSwgaGFzR2V0QWxsOiBib29sZWFufSB7XG4gICAgY29uc3QgdGFibGVzID0gYXJyYXlpZnkoZGIub2JqZWN0U3RvcmVOYW1lcyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNjaGVtYToge1xuICAgICAgICBuYW1lOiBkYi5uYW1lLFxuICAgICAgICB0YWJsZXM6IHRhYmxlcy5tYXAodGFibGUgPT4gdHJhbnMub2JqZWN0U3RvcmUodGFibGUpKS5tYXAoc3RvcmUgPT4ge1xuICAgICAgICAgIGNvbnN0IHtrZXlQYXRoLCBhdXRvSW5jcmVtZW50fSA9IHN0b3JlO1xuICAgICAgICAgIGNvbnN0IGNvbXBvdW5kID0gaXNBcnJheShrZXlQYXRoKTtcbiAgICAgICAgICBjb25zdCBvdXRib3VuZCA9IGtleVBhdGggPT0gbnVsbDtcbiAgICAgICAgICBjb25zdCBpbmRleEJ5S2V5UGF0aDoge1trZXlQYXRoQWxpYXM6IHN0cmluZ106IERCQ29yZUluZGV4fSA9IHt9O1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgICAgICAgIG5hbWU6IHN0b3JlLm5hbWUsXG4gICAgICAgICAgICBwcmltYXJ5S2V5OiB7XG4gICAgICAgICAgICAgIG5hbWU6IG51bGwsXG4gICAgICAgICAgICAgIGlzUHJpbWFyeUtleTogdHJ1ZSxcbiAgICAgICAgICAgICAgb3V0Ym91bmQsXG4gICAgICAgICAgICAgIGNvbXBvdW5kLFxuICAgICAgICAgICAgICBrZXlQYXRoLFxuICAgICAgICAgICAgICBhdXRvSW5jcmVtZW50LFxuICAgICAgICAgICAgICB1bmlxdWU6IHRydWUsXG4gICAgICAgICAgICAgIGV4dHJhY3RLZXk6IGdldEtleUV4dHJhY3RvcihrZXlQYXRoKVxuICAgICAgICAgICAgfSBhcyBEQkNvcmVJbmRleCxcbiAgICAgICAgICAgIGluZGV4ZXM6IGFycmF5aWZ5KHN0b3JlLmluZGV4TmFtZXMpLm1hcChpbmRleE5hbWUgPT4gc3RvcmUuaW5kZXgoaW5kZXhOYW1lKSlcbiAgICAgICAgICAgICAgLm1hcChpbmRleCA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qge25hbWUsIHVuaXF1ZSwgbXVsdGlFbnRyeSwga2V5UGF0aH0gPSBpbmRleDtcbiAgICAgICAgICAgICAgICBjb25zdCBjb21wb3VuZCA9IGlzQXJyYXkoa2V5UGF0aCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0OiBEQkNvcmVJbmRleCA9IHtcbiAgICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICBjb21wb3VuZCxcbiAgICAgICAgICAgICAgICAgIGtleVBhdGgsXG4gICAgICAgICAgICAgICAgICB1bmlxdWUsXG4gICAgICAgICAgICAgICAgICBtdWx0aUVudHJ5LFxuICAgICAgICAgICAgICAgICAgZXh0cmFjdEtleTogZ2V0S2V5RXh0cmFjdG9yKGtleVBhdGgpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpbmRleEJ5S2V5UGF0aFtnZXRLZXlQYXRoQWxpYXMoa2V5UGF0aCldID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgZ2V0SW5kZXhCeUtleVBhdGg6IChrZXlQYXRoOiBudWxsIHwgc3RyaW5nIHwgc3RyaW5nW10pID0+IGluZGV4QnlLZXlQYXRoW2dldEtleVBhdGhBbGlhcyhrZXlQYXRoKV1cbiAgICAgICAgICB9O1xuICAgICAgICAgIGluZGV4QnlLZXlQYXRoW1wiOmlkXCJdID0gcmVzdWx0LnByaW1hcnlLZXk7XG4gICAgICAgICAgaWYgKGtleVBhdGggIT0gbnVsbCkge1xuICAgICAgICAgICAgaW5kZXhCeUtleVBhdGhbZ2V0S2V5UGF0aEFsaWFzKGtleVBhdGgpXSA9IHJlc3VsdC5wcmltYXJ5S2V5O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9KVxuICAgICAgfSxcbiAgICAgIGhhc0dldEFsbDogdGFibGVzLmxlbmd0aCA+IDAgJiYgKCdnZXRBbGwnIGluIHRyYW5zLm9iamVjdFN0b3JlKHRhYmxlc1swXSkpICYmXG4gICAgICAgICEodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgL1NhZmFyaS8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSAmJlxuICAgICAgICAhLyhDaHJvbWVcXC98RWRnZVxcLykvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiZcbiAgICAgICAgW10uY29uY2F0KG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL1NhZmFyaVxcLyhcXGQqKS8pKVsxXSA8IDYwNCkgLy8gQnVnIHdpdGggZ2V0QWxsKCkgb24gU2FmYXJpIHZlcjw2MDQuIFNlZSBkaXNjdXNzaW9uIGZvbGxvd2luZyBQUiAjNTc5XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1ha2VJREJLZXlSYW5nZSAocmFuZ2U6IERCQ29yZUtleVJhbmdlKSA6IElEQktleVJhbmdlIHwgbnVsbCB7XG4gICAgaWYgKHJhbmdlLnR5cGUgPT09IERCQ29yZVJhbmdlVHlwZS5BbnkpIHJldHVybiBudWxsO1xuICAgIGlmIChyYW5nZS50eXBlID09PSBEQkNvcmVSYW5nZVR5cGUuTmV2ZXIpIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjb252ZXJ0IG5ldmVyIHR5cGUgdG8gSURCS2V5UmFuZ2VcIik7XG4gICAgY29uc3Qge2xvd2VyLCB1cHBlciwgbG93ZXJPcGVuLCB1cHBlck9wZW59ID0gcmFuZ2U7XG4gICAgY29uc3QgaWRiUmFuZ2UgPSBsb3dlciA9PT0gdW5kZWZpbmVkID9cbiAgICAgIHVwcGVyID09PSB1bmRlZmluZWQgP1xuICAgICAgICBudWxsIDogLy9JREJLZXlSYW5nZS5sb3dlckJvdW5kKC1JbmZpbml0eSwgZmFsc2UpIDogLy8gQW55IHJhbmdlIChUT0RPOiBTaG91bGQgd2UgcmV0dXJuIG51bGwgaW5zdGVhZD8pXG4gICAgICAgIElkYktleVJhbmdlLnVwcGVyQm91bmQodXBwZXIsICEhdXBwZXJPcGVuKSA6IC8vIGJlbG93XG4gICAgICB1cHBlciA9PT0gdW5kZWZpbmVkID9cbiAgICAgICAgSWRiS2V5UmFuZ2UubG93ZXJCb3VuZChsb3dlciwgISFsb3dlck9wZW4pIDogLy8gYWJvdmVcbiAgICAgICAgSWRiS2V5UmFuZ2UuYm91bmQobG93ZXIsIHVwcGVyLCAhIWxvd2VyT3BlbiwgISF1cHBlck9wZW4pO1xuICAgIHJldHVybiBpZGJSYW5nZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZURiQ29yZVRhYmxlKHRhYmxlU2NoZW1hOiBEQkNvcmVUYWJsZVNjaGVtYSk6IERCQ29yZVRhYmxlIHtcbiAgICBjb25zdCB0YWJsZU5hbWUgPSB0YWJsZVNjaGVtYS5uYW1lO1xuXG4gICAgZnVuY3Rpb24gbXV0YXRlICh7dHJhbnMsIHR5cGUsIGtleXMsIHZhbHVlcywgcmFuZ2V9KSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2U8REJDb3JlTXV0YXRlUmVzcG9uc2U+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgcmVzb2x2ZSA9IHdyYXAocmVzb2x2ZSk7XG4gICAgICAgIGNvbnN0IHN0b3JlID0gKHRyYW5zIGFzIElEQlRyYW5zYWN0aW9uKS5vYmplY3RTdG9yZSh0YWJsZU5hbWUpO1xuICAgICAgICBjb25zdCBvdXRib3VuZCA9IHN0b3JlLmtleVBhdGggPT0gbnVsbDtcbiAgICAgICAgY29uc3QgaXNBZGRPclB1dCA9IHR5cGUgPT09IFwicHV0XCIgfHwgdHlwZSA9PT0gXCJhZGRcIjtcbiAgICAgICAgaWYgKCFpc0FkZE9yUHV0ICYmIHR5cGUgIT09ICdkZWxldGUnICYmIHR5cGUgIT09ICdkZWxldGVSYW5nZScpXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yIChcIkludmFsaWQgb3BlcmF0aW9uIHR5cGU6IFwiICsgdHlwZSk7XG5cbiAgICAgICAgY29uc3Qge2xlbmd0aH0gPSBrZXlzIHx8IHZhbHVlcyB8fCB7bGVuZ3RoOiAxfTsgLy8ga2V5cy5sZW5ndGggaWYga2V5cy4gdmFsdWVzLmxlbmd0aCBpZiB2YWx1ZXMuIDEgaWYgcmFuZ2UuXG4gICAgICAgIGlmIChrZXlzICYmIHZhbHVlcyAmJiBrZXlzLmxlbmd0aCAhPT0gdmFsdWVzLmxlbmd0aCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkdpdmVuIGtleXMgYXJyYXkgbXVzdCBoYXZlIHNhbWUgbGVuZ3RoIGFzIGdpdmVuIHZhbHVlcyBhcnJheS5cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlbmd0aCA9PT0gMClcbiAgICAgICAgICAvLyBObyBpdGVtcyB0byB3cml0ZS4gRG9uJ3QgZXZlbiBib3RoZXIhXG4gICAgICAgICAgcmV0dXJuIHJlc29sdmUoe251bUZhaWx1cmVzOiAwLCBmYWlsdXJlczoge30sIHJlc3VsdHM6IFtdLCBsYXN0UmVzdWx0OiB1bmRlZmluZWR9KTtcblxuICAgICAgICBsZXQgcmVxOiBJREJSZXF1ZXN0O1xuICAgICAgICBjb25zdCByZXFzOiBJREJSZXF1ZXN0W10gPSBbXTtcbiAgICAgICAgICBcbiAgICAgICAgY29uc3QgZmFpbHVyZXM6IHtbb3BlcmF0aW9uTnVtYmVyOiBudW1iZXJdOiBFcnJvcn0gPSBbXTtcbiAgICAgICAgbGV0IG51bUZhaWx1cmVzID0gMDtcbiAgICAgICAgY29uc3QgZXJyb3JIYW5kbGVyID0gXG4gICAgICAgICAgZXZlbnQgPT4ge1xuICAgICAgICAgICAgKytudW1GYWlsdXJlcztcbiAgICAgICAgICAgIHByZXZlbnREZWZhdWx0KGV2ZW50KTtcbiAgICAgICAgICB9O1xuICBcbiAgICAgICAgaWYgKHR5cGUgPT09ICdkZWxldGVSYW5nZScpIHtcbiAgICAgICAgICAvLyBIZXJlIHRoZSBhcmd1bWVudCBpcyB0aGUgcmFuZ2VcbiAgICAgICAgICBpZiAocmFuZ2UudHlwZSA9PT0gREJDb3JlUmFuZ2VUeXBlLk5ldmVyKVxuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoe251bUZhaWx1cmVzLCBmYWlsdXJlcywgcmVzdWx0czogW10sIGxhc3RSZXN1bHQ6IHVuZGVmaW5lZH0pOyAvLyBEZWxldGluZyB0aGUgTmV2ZXIgcmFuZ2Ugc2hvdWxudCBkbyBhbnl0aGluZy5cbiAgICAgICAgICBpZiAocmFuZ2UudHlwZSA9PT0gREJDb3JlUmFuZ2VUeXBlLkFueSlcbiAgICAgICAgICAgIHJlcXMucHVzaChyZXEgPSBzdG9yZS5jbGVhcigpKTsgLy8gRGVsZXRpbmcgdGhlIEFueSByYW5nZSBpcyBlcXVpdmFsZW50IHRvIHN0b3JlLmNsZWFyKClcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXFzLnB1c2gocmVxID0gc3RvcmUuZGVsZXRlKG1ha2VJREJLZXlSYW5nZShyYW5nZSkpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBObyBtYXR0ZXIgYWRkLCBwdXQgb3IgZGVsZXRlIC0gZmluZCBvdXQgYXJyYXlzIG9mIGZpcnN0IGFuZCBzZWNvbmQgYXJndW1lbnRzIHRvIGl0LlxuICAgICAgICAgIGNvbnN0IFthcmdzMSwgYXJnczJdID0gaXNBZGRPclB1dCA/XG4gICAgICAgICAgICBvdXRib3VuZCA/XG4gICAgICAgICAgICAgIFt2YWx1ZXMsIGtleXNdIDpcbiAgICAgICAgICAgICAgW3ZhbHVlcywgbnVsbF0gOlxuICAgICAgICAgICAgW2tleXMsIG51bGxdO1xuXG4gICAgICAgICAgaWYgKGlzQWRkT3JQdXQpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGk9MDsgaTxsZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICByZXFzLnB1c2gocmVxID0gKGFyZ3MyICYmIGFyZ3MyW2ldICE9PSB1bmRlZmluZWQgP1xuICAgICAgICAgICAgICAgIHN0b3JlW3R5cGVdKGFyZ3MxW2ldLCBhcmdzMltpXSkgOlxuICAgICAgICAgICAgICAgIHN0b3JlW3R5cGVdKGFyZ3MxW2ldKSkgYXMgSURCUmVxdWVzdCk7XG4gICAgICAgICAgICAgIHJlcS5vbmVycm9yID0gZXJyb3JIYW5kbGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpPTA7IGk8bGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgcmVxcy5wdXNoKHJlcSA9IHN0b3JlW3R5cGVdKGFyZ3MxW2ldKSBhcyBJREJSZXF1ZXN0KTtcbiAgICAgICAgICAgICAgcmVxLm9uZXJyb3IgPSBlcnJvckhhbmRsZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRvbmUgPSBldmVudCA9PiB7XG4gICAgICAgICAgY29uc3QgbGFzdFJlc3VsdCA9IGV2ZW50LnRhcmdldC5yZXN1bHQ7XG4gICAgICAgICAgcmVxcy5mb3JFYWNoKChyZXEsIGkpID0+IHJlcS5lcnJvciAhPSBudWxsICYmIChmYWlsdXJlc1tpXSA9IHJlcS5lcnJvcikpO1xuICAgICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgICAgbnVtRmFpbHVyZXMsXG4gICAgICAgICAgICBmYWlsdXJlcyxcbiAgICAgICAgICAgIHJlc3VsdHM6IHR5cGUgPT09IFwiZGVsZXRlXCIgPyBrZXlzIDogcmVxcy5tYXAocmVxID0+IHJlcS5yZXN1bHQpLFxuICAgICAgICAgICAgbGFzdFJlc3VsdFxuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICBcbiAgICAgICAgcmVxLm9uZXJyb3IgPSBldmVudCA9PiB7IC8vIHdyYXAoKSBub3QgbmVlZGVkLiBBbGwgcGF0aHMgY2FsbGluZyBvdXRzaWRlIHdpbGwgd3JhcCFcbiAgICAgICAgICBlcnJvckhhbmRsZXIoZXZlbnQpO1xuICAgICAgICAgIGRvbmUoZXZlbnQpO1xuICAgICAgICB9O1xuICBcbiAgICAgICAgcmVxLm9uc3VjY2VzcyA9IGRvbmU7XG4gICAgICB9KTtcbiAgICB9XG4gICAgXG4gICAgZnVuY3Rpb24gb3BlbkN1cnNvciAoe3RyYW5zLCB2YWx1ZXMsIHF1ZXJ5LCByZXZlcnNlLCB1bmlxdWV9OiBEQkNvcmVPcGVuQ3Vyc29yUmVxdWVzdCk6IFByb21pc2U8REJDb3JlQ3Vyc29yPlxuICAgIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIHJlc29sdmUgPSB3cmFwKHJlc29sdmUpO1xuICAgICAgICBjb25zdCB7aW5kZXgsIHJhbmdlfSA9IHF1ZXJ5O1xuICAgICAgICBjb25zdCBzdG9yZSA9ICh0cmFucyBhcyBJREJUcmFuc2FjdGlvbikub2JqZWN0U3RvcmUodGFibGVOYW1lKTtcbiAgICAgICAgLy8gc291cmNlXG4gICAgICAgIGNvbnN0IHNvdXJjZSA9IGluZGV4LmlzUHJpbWFyeUtleSA/XG4gICAgICAgICAgc3RvcmUgOlxuICAgICAgICAgIHN0b3JlLmluZGV4KGluZGV4Lm5hbWUpO1xuICAgICAgICAvLyBkaXJlY3Rpb25cbiAgICAgICAgY29uc3QgZGlyZWN0aW9uID0gcmV2ZXJzZSA/XG4gICAgICAgICAgdW5pcXVlID9cbiAgICAgICAgICAgIFwicHJldnVuaXF1ZVwiIDpcbiAgICAgICAgICAgIFwicHJldlwiIDpcbiAgICAgICAgICB1bmlxdWUgP1xuICAgICAgICAgICAgXCJuZXh0dW5pcXVlXCIgOlxuICAgICAgICAgICAgXCJuZXh0XCI7XG4gICAgICAgIC8vIHJlcXVlc3RcbiAgICAgICAgY29uc3QgcmVxID0gdmFsdWVzIHx8ICEoJ29wZW5LZXlDdXJzb3InIGluIHNvdXJjZSkgP1xuICAgICAgICAgIHNvdXJjZS5vcGVuQ3Vyc29yKG1ha2VJREJLZXlSYW5nZShyYW5nZSksIGRpcmVjdGlvbikgOlxuICAgICAgICAgIHNvdXJjZS5vcGVuS2V5Q3Vyc29yKG1ha2VJREJLZXlSYW5nZShyYW5nZSksIGRpcmVjdGlvbik7XG4gICAgICAgICAgXG4gICAgICAgIC8vIGl0ZXJhdGlvblxuICAgICAgICByZXEub25lcnJvciA9IGV2ZW50UmVqZWN0SGFuZGxlcihyZWplY3QpO1xuICAgICAgICByZXEub25zdWNjZXNzID0gd3JhcChldiA9PiB7XG5cbiAgICAgICAgICBjb25zdCBjdXJzb3IgPSByZXEucmVzdWx0IGFzIHVua25vd24gYXMgREJDb3JlQ3Vyc29yO1xuICAgICAgICAgIGlmICghY3Vyc29yKSB7XG4gICAgICAgICAgICByZXNvbHZlKG51bGwpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICAoY3Vyc29yIGFzIGFueSkuX19faWQgPSArK19pZF9jb3VudGVyO1xuICAgICAgICAgIChjdXJzb3IgYXMgYW55KS5kb25lID0gZmFsc2U7XG4gICAgICAgICAgY29uc3QgX2N1cnNvckNvbnRpbnVlID0gY3Vyc29yLmNvbnRpbnVlLmJpbmQoY3Vyc29yKTtcbiAgICAgICAgICBsZXQgX2N1cnNvckNvbnRpbnVlUHJpbWFyeUtleSA9IGN1cnNvci5jb250aW51ZVByaW1hcnlLZXk7XG4gICAgICAgICAgaWYgKF9jdXJzb3JDb250aW51ZVByaW1hcnlLZXkpIF9jdXJzb3JDb250aW51ZVByaW1hcnlLZXkgPSBfY3Vyc29yQ29udGludWVQcmltYXJ5S2V5LmJpbmQoY3Vyc29yKTtcbiAgICAgICAgICBjb25zdCBfY3Vyc29yQWR2YW5jZSA9IGN1cnNvci5hZHZhbmNlLmJpbmQoY3Vyc29yKTtcbiAgICAgICAgICBjb25zdCBkb1Rocm93Q3Vyc29ySXNOb3RTdGFydGVkID0gKCk9Pnt0aHJvdyBuZXcgRXJyb3IoXCJDdXJzb3Igbm90IHN0YXJ0ZWRcIik7fVxuICAgICAgICAgIGNvbnN0IGRvVGhyb3dDdXJzb3JJc1N0b3BwZWQgPSAoKT0+e3Rocm93IG5ldyBFcnJvcihcIkN1cnNvciBub3Qgc3RvcHBlZFwiKTt9XG4gICAgICAgICAgKGN1cnNvciBhcyBhbnkpLnRyYW5zID0gdHJhbnM7XG4gICAgICAgICAgY3Vyc29yLnN0b3AgPSBjdXJzb3IuY29udGludWUgPSBjdXJzb3IuY29udGludWVQcmltYXJ5S2V5ID0gY3Vyc29yLmFkdmFuY2UgPSBkb1Rocm93Q3Vyc29ySXNOb3RTdGFydGVkO1xuICAgICAgICAgIGN1cnNvci5mYWlsID0gd3JhcChyZWplY3QpO1xuICAgICAgICAgIGN1cnNvci5uZXh0ID0gZnVuY3Rpb24gKHRoaXM6IERCQ29yZUN1cnNvcikge1xuICAgICAgICAgICAgLy8gbmV4dCgpIG11c3Qgd29yayB3aXRoIFwidGhpc1wiIHBvaW50ZXIgaW4gb3JkZXIgdG8gZnVuY3Rpb24gY29ycmVjdGx5IGZvciBQcm94eUN1cnNvcnMgKGRlcml2ZWQgb2JqZWN0cylcbiAgICAgICAgICAgIC8vIHdpdGhvdXQgaGF2aW5nIHRvIHJlLWRlZmluZSBuZXh0KCkgb24gZWFjaCBjaGlsZC5cbiAgICAgICAgICAgIGxldCBnb3RPbmUgPSAxO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnQoKCkgPT4gZ290T25lLS0gPyB0aGlzLmNvbnRpbnVlKCkgOiB0aGlzLnN0b3AoKSkudGhlbigoKSA9PiB0aGlzKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIGN1cnNvci5zdGFydCA9IChjYWxsYmFjaykgPT4ge1xuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIlN0YXJ0aW5nIGN1cnNvclwiLCAoY3Vyc29yIGFzIGFueSkuX19faWQpO1xuICAgICAgICAgICAgY29uc3QgaXRlcmF0aW9uUHJvbWlzZSA9IG5ldyBQcm9taXNlPHZvaWQ+KChyZXNvbHZlSXRlcmF0aW9uLCByZWplY3RJdGVyYXRpb24pID0+e1xuICAgICAgICAgICAgICByZXNvbHZlSXRlcmF0aW9uID0gd3JhcChyZXNvbHZlSXRlcmF0aW9uKTtcbiAgICAgICAgICAgICAgcmVxLm9uZXJyb3IgPSBldmVudFJlamVjdEhhbmRsZXIocmVqZWN0SXRlcmF0aW9uKTtcbiAgICAgICAgICAgICAgY3Vyc29yLmZhaWwgPSByZWplY3RJdGVyYXRpb247XG4gICAgICAgICAgICAgIGN1cnNvci5zdG9wID0gdmFsdWUgPT4ge1xuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJDdXJzb3Igc3RvcFwiLCBjdXJzb3IpO1xuICAgICAgICAgICAgICAgIGN1cnNvci5zdG9wID0gY3Vyc29yLmNvbnRpbnVlID0gY3Vyc29yLmNvbnRpbnVlUHJpbWFyeUtleSA9IGN1cnNvci5hZHZhbmNlID0gZG9UaHJvd0N1cnNvcklzU3RvcHBlZDtcbiAgICAgICAgICAgICAgICByZXNvbHZlSXRlcmF0aW9uKHZhbHVlKTtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gTm93IGNoYW5nZSByZXEub25zdWNjZXNzIHRvIGEgY2FsbGJhY2sgdGhhdCBkb2Vzbid0IGNhbGwgaW5pdEN1cnNvciBidXQganVzdCBvYnNlcnZlci5uZXh0KClcbiAgICAgICAgICAgIGNvbnN0IGd1YXJkZWRDYWxsYmFjayA9ICgpID0+IHtcbiAgICAgICAgICAgICAgaWYgKHJlcS5yZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiTmV4dCByZXN1bHRcIiwgY3Vyc29yKTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgIGN1cnNvci5mYWlsKGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIChjdXJzb3IgYXMgYW55KS5kb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjdXJzb3Iuc3RhcnQgPSAoKT0+e3Rocm93IG5ldyBFcnJvcihcIkN1cnNvciBiZWhpbmQgbGFzdCBlbnRyeVwiKTt9XG4gICAgICAgICAgICAgICAgY3Vyc29yLnN0b3AoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVxLm9uc3VjY2VzcyA9IHdyYXAoZXYgPT4ge1xuICAgICAgICAgICAgICAvL2N1cnNvci5jb250aW51ZSA9IF9jdXJzb3JDb250aW51ZTtcbiAgICAgICAgICAgICAgLy9jdXJzb3IuY29udGludWVQcmltYXJ5S2V5ID0gX2N1cnNvckNvbnRpbnVlUHJpbWFyeUtleTtcbiAgICAgICAgICAgICAgLy9jdXJzb3IuYWR2YW5jZSA9IF9jdXJzb3JBZHZhbmNlO1xuICAgICAgICAgICAgICByZXEub25zdWNjZXNzID0gZ3VhcmRlZENhbGxiYWNrO1xuICAgICAgICAgICAgICBndWFyZGVkQ2FsbGJhY2soKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY3Vyc29yLmNvbnRpbnVlID0gX2N1cnNvckNvbnRpbnVlO1xuICAgICAgICAgICAgY3Vyc29yLmNvbnRpbnVlUHJpbWFyeUtleSA9IF9jdXJzb3JDb250aW51ZVByaW1hcnlLZXk7XG4gICAgICAgICAgICBjdXJzb3IuYWR2YW5jZSA9IF9jdXJzb3JBZHZhbmNlO1xuICAgICAgICAgICAgZ3VhcmRlZENhbGxiYWNrKCk7XG4gICAgICAgICAgICByZXR1cm4gaXRlcmF0aW9uUHJvbWlzZTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIHJlc29sdmUoY3Vyc29yKTtcbiAgICAgICAgfSwgcmVqZWN0KTsgXG4gICAgICB9KTtcbiAgICB9XG4gIFxuICAgIGZ1bmN0aW9uIHF1ZXJ5IChoYXNHZXRBbGw6IGJvb2xlYW4pIHtcbiAgICAgIHJldHVybiAocmVxdWVzdDogREJDb3JlUXVlcnlSZXF1ZXN0KSA9PiB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZTxEQkNvcmVRdWVyeVJlc3BvbnNlPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgcmVzb2x2ZSA9IHdyYXAocmVzb2x2ZSk7XG4gICAgICAgICAgY29uc3Qge3RyYW5zLCB2YWx1ZXMsIGxpbWl0LCBxdWVyeX0gPSByZXF1ZXN0O1xuICAgICAgICAgIGNvbnN0IG5vbkluZmluaXRMaW1pdCA9IGxpbWl0ID09PSBJbmZpbml0eSA/IHVuZGVmaW5lZCA6IGxpbWl0O1xuICAgICAgICAgIGNvbnN0IHtpbmRleCwgcmFuZ2V9ID0gcXVlcnk7XG4gICAgICAgICAgY29uc3Qgc3RvcmUgPSAodHJhbnMgYXMgSURCVHJhbnNhY3Rpb24pLm9iamVjdFN0b3JlKHRhYmxlTmFtZSk7XG4gICAgICAgICAgY29uc3Qgc291cmNlID0gaW5kZXguaXNQcmltYXJ5S2V5ID8gc3RvcmUgOiBzdG9yZS5pbmRleChpbmRleC5uYW1lKTtcbiAgICAgICAgICBjb25zdCBpZGJLZXlSYW5nZSA9IG1ha2VJREJLZXlSYW5nZShyYW5nZSk7XG4gICAgICAgICAgaWYgKGxpbWl0ID09PSAwKSByZXR1cm4gcmVzb2x2ZSh7cmVzdWx0OiBbXX0pO1xuICAgICAgICAgIGlmIChoYXNHZXRBbGwpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlcSA9IHZhbHVlcyA/XG4gICAgICAgICAgICAgICAgKHNvdXJjZSBhcyBhbnkpLmdldEFsbChpZGJLZXlSYW5nZSwgbm9uSW5maW5pdExpbWl0KSA6XG4gICAgICAgICAgICAgICAgKHNvdXJjZSBhcyBhbnkpLmdldEFsbEtleXMoaWRiS2V5UmFuZ2UsIG5vbkluZmluaXRMaW1pdCk7XG4gICAgICAgICAgICByZXEub25zdWNjZXNzID0gZXZlbnQgPT4gcmVzb2x2ZSh7cmVzdWx0OiBldmVudC50YXJnZXQucmVzdWx0fSk7XG4gICAgICAgICAgICByZXEub25lcnJvciA9IGV2ZW50UmVqZWN0SGFuZGxlcihyZWplY3QpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgY291bnQgPSAwO1xuICAgICAgICAgICAgY29uc3QgcmVxID0gdmFsdWVzIHx8ICEoJ29wZW5LZXlDdXJzb3InIGluIHNvdXJjZSkgP1xuICAgICAgICAgICAgICBzb3VyY2Uub3BlbkN1cnNvcihpZGJLZXlSYW5nZSkgOlxuICAgICAgICAgICAgICBzb3VyY2Uub3BlbktleUN1cnNvcihpZGJLZXlSYW5nZSlcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgcmVxLm9uc3VjY2VzcyA9IGV2ZW50ID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgY3Vyc29yID0gcmVxLnJlc3VsdCBhcyBJREJDdXJzb3JXaXRoVmFsdWU7XG4gICAgICAgICAgICAgIGlmICghY3Vyc29yKSByZXR1cm4gcmVzb2x2ZSh7cmVzdWx0fSk7XG4gICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlcyA/IGN1cnNvci52YWx1ZSA6IGN1cnNvci5wcmltYXJ5S2V5KTtcbiAgICAgICAgICAgICAgaWYgKCsrY291bnQgPT09IGxpbWl0KSByZXR1cm4gcmVzb2x2ZSh7cmVzdWx0fSk7XG4gICAgICAgICAgICAgIGN1cnNvci5jb250aW51ZSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJlcS5vbmVycm9yID0gZXZlbnRSZWplY3RIYW5kbGVyKHJlamVjdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgfVxuICBcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogdGFibGVOYW1lLFxuICAgICAgc2NoZW1hOiB0YWJsZVNjaGVtYSxcbiAgICAgIFxuICAgICAgbXV0YXRlLFxuXG4gICAgICBnZXRNYW55ICh7dHJhbnMsIGtleXN9KSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZTxhbnlbXT4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgIHJlc29sdmUgPSB3cmFwKHJlc29sdmUpO1xuICAgICAgICAgIGNvbnN0IHN0b3JlID0gKHRyYW5zIGFzIElEQlRyYW5zYWN0aW9uKS5vYmplY3RTdG9yZSh0YWJsZU5hbWUpO1xuICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBBcnJheShsZW5ndGgpO1xuICAgICAgICAgIGxldCBrZXlDb3VudCA9IDA7XG4gICAgICAgICAgbGV0IGNhbGxiYWNrQ291bnQgPSAwO1xuICAgICAgICAgIGxldCB2YWx1ZUNvdW50ID0gMDtcbiAgICAgICAgICBsZXQgcmVxOiBJREJSZXF1ZXN0ICYge19wb3M/OiBudW1iZXJ9O1xuICAgIFxuICAgICAgICAgIGNvbnN0IHN1Y2Nlc3NIYW5kbGVyID0gZXZlbnQgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVxID0gZXZlbnQudGFyZ2V0O1xuICAgICAgICAgICAgaWYgKChyZXN1bHRbcmVxLl9wb3NdID0gcmVxLnJlc3VsdCkgIT0gbnVsbCkgKyt2YWx1ZUNvdW50O1xuICAgICAgICAgICAgaWYgKCsrY2FsbGJhY2tDb3VudCA9PT0ga2V5Q291bnQpIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIGNvbnN0IGVycm9ySGFuZGxlciA9IGV2ZW50UmVqZWN0SGFuZGxlcihyZWplY3QpO1xuICAgIFxuICAgICAgICAgIGZvciAobGV0IGk9MDsgaTxsZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICAgIGlmIChrZXkgIT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXEgPSBzdG9yZS5nZXQoa2V5c1tpXSk7XG4gICAgICAgICAgICAgIHJlcS5fcG9zID0gaTtcbiAgICAgICAgICAgICAgcmVxLm9uc3VjY2VzcyA9IHN1Y2Nlc3NIYW5kbGVyO1xuICAgICAgICAgICAgICByZXEub25lcnJvciA9IGVycm9ySGFuZGxlcjtcbiAgICAgICAgICAgICAgKytrZXlDb3VudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGtleUNvdW50ID09PSAwKSByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0pO1xuICAgICAgfSxcblxuICAgICAgZ2V0ICh7dHJhbnMsIGtleX0pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlPGFueT4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgIHJlc29sdmUgPSB3cmFwIChyZXNvbHZlKTtcbiAgICAgICAgICBjb25zdCBzdG9yZSA9ICh0cmFucyBhcyBJREJUcmFuc2FjdGlvbikub2JqZWN0U3RvcmUodGFibGVOYW1lKTtcbiAgICAgICAgICBjb25zdCByZXEgPSBzdG9yZS5nZXQoa2V5KTtcbiAgICAgICAgICByZXEub25zdWNjZXNzID0gZXZlbnQgPT4gcmVzb2x2ZSgoZXZlbnQudGFyZ2V0IGFzIGFueSkucmVzdWx0KTtcbiAgICAgICAgICByZXEub25lcnJvciA9IGV2ZW50UmVqZWN0SGFuZGxlcihyZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG5cbiAgICAgIHF1ZXJ5OiBxdWVyeShoYXNHZXRBbGwpLFxuICAgICAgXG4gICAgICBvcGVuQ3Vyc29yLFxuXG4gICAgICBjb3VudCAoe3F1ZXJ5LCB0cmFuc30pIHtcbiAgICAgICAgY29uc3Qge2luZGV4LCByYW5nZX0gPSBxdWVyeTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlPG51bWJlcj4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHN0b3JlID0gKHRyYW5zIGFzIElEQlRyYW5zYWN0aW9uKS5vYmplY3RTdG9yZSh0YWJsZU5hbWUpO1xuICAgICAgICAgIGNvbnN0IHNvdXJjZSA9IGluZGV4LmlzUHJpbWFyeUtleSA/IHN0b3JlIDogc3RvcmUuaW5kZXgoaW5kZXgubmFtZSk7XG4gICAgICAgICAgY29uc3QgaWRiS2V5UmFuZ2UgPSBtYWtlSURCS2V5UmFuZ2UocmFuZ2UpO1xuICAgICAgICAgIGNvbnN0IHJlcSA9IGlkYktleVJhbmdlID8gc291cmNlLmNvdW50KGlkYktleVJhbmdlKSA6IHNvdXJjZS5jb3VudCgpO1xuICAgICAgICAgIHJlcS5vbnN1Y2Nlc3MgPSB3cmFwKGV2ID0+IHJlc29sdmUoKGV2LnRhcmdldCBhcyBJREJSZXF1ZXN0KS5yZXN1bHQpKTtcbiAgICAgICAgICByZXEub25lcnJvciA9IGV2ZW50UmVqZWN0SGFuZGxlcihyZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgY29uc3Qge3NjaGVtYSwgaGFzR2V0QWxsfSA9IGV4dHJhY3RTY2hlbWEoZGIsIHRtcFRyYW5zKTtcbiAgY29uc3QgdGFibGVzID0gc2NoZW1hLnRhYmxlcy5tYXAodGFibGVTY2hlbWEgPT4gY3JlYXRlRGJDb3JlVGFibGUodGFibGVTY2hlbWEpKTtcbiAgY29uc3QgdGFibGVNYXA6IHtbbmFtZTogc3RyaW5nXTogREJDb3JlVGFibGV9ID0ge307XG4gIHRhYmxlcy5mb3JFYWNoKHRhYmxlID0+IHRhYmxlTWFwW3RhYmxlLm5hbWVdID0gdGFibGUpO1xuICByZXR1cm4ge1xuICAgIHN0YWNrOiBcImRiY29yZVwiLFxuICAgIFxuICAgIHRyYW5zYWN0aW9uOiBkYi50cmFuc2FjdGlvbi5iaW5kKGRiKSxcblxuICAgIHRhYmxlKG5hbWU6IHN0cmluZykge1xuICAgICAgY29uc3QgcmVzdWx0ID0gdGFibGVNYXBbbmFtZV07XG4gICAgICBpZiAoIXJlc3VsdCkgdGhyb3cgbmV3IEVycm9yKGBUYWJsZSAnJHtuYW1lfScgbm90IGZvdW5kYCk7XG4gICAgICByZXR1cm4gdGFibGVNYXBbbmFtZV07XG4gICAgfSxcblxuICAgIE1JTl9LRVk6IC1JbmZpbml0eSxcblxuICAgIE1BWF9LRVk6IGdldE1heEtleShJZGJLZXlSYW5nZSksXG5cbiAgICBzY2hlbWFcblxuICB9O1xufVxuIiwgImltcG9ydCB7IERleGllIH0gZnJvbSAnLi8nO1xuaW1wb3J0IHsgY3JlYXRlREJDb3JlIH0gZnJvbSAnLi4vLi4vZGJjb3JlL2RiY29yZS1pbmRleGVkZGInO1xuaW1wb3J0IHsgREJDb3JlIH0gZnJvbSAnLi4vLi4vcHVibGljL3R5cGVzL2RiY29yZSc7XG5pbXBvcnQgeyBEZXhpZURPTURlcGVuZGVuY2llcyB9IGZyb20gJy4uLy4uL3B1YmxpYy90eXBlcy9kZXhpZS1kb20tZGVwZW5kZW5jaWVzJztcbmltcG9ydCB7IERleGllU3RhY2tzLCBNaWRkbGV3YXJlIH0gZnJvbSAnLi4vLi4vcHVibGljL3R5cGVzL21pZGRsZXdhcmUnO1xuaW1wb3J0IHsgZXhjZXB0aW9ucyB9IGZyb20gJy4uLy4uL2Vycm9ycyc7XG5cbmZ1bmN0aW9uIGNyZWF0ZU1pZGRsZXdhcmVTdGFjazxUU3RhY2sgZXh0ZW5kcyB7c3RhY2s6IHN0cmluZ30+KFxuICBzdGFja0ltcGw6IHtzdGFjazogc3RyaW5nfSxcbiAgbWlkZGxld2FyZXM6IE1pZGRsZXdhcmU8e3N0YWNrOiBzdHJpbmd9PltdKTogVFN0YWNrIHtcbiAgcmV0dXJuIG1pZGRsZXdhcmVzLnJlZHVjZSgoZG93biwge2NyZWF0ZX0pID0+ICh7Li4uZG93biwgLi4uY3JlYXRlKGRvd24pfSksIHN0YWNrSW1wbCkgYXMgVFN0YWNrO1xufSBcblxuZnVuY3Rpb24gY3JlYXRlTWlkZGxld2FyZVN0YWNrcyhcbiAgbWlkZGxld2FyZXM6IHtbU3RhY2tOYW1lIGluIGtleW9mIERleGllU3RhY2tzXT86IE1pZGRsZXdhcmU8RGV4aWVTdGFja3NbU3RhY2tOYW1lXT5bXX0sXG4gIGlkYmRiOiBJREJEYXRhYmFzZSxcbiAge0lEQktleVJhbmdlLCBpbmRleGVkREJ9OiBEZXhpZURPTURlcGVuZGVuY2llcyxcbiAgdG1wVHJhbnM6IElEQlRyYW5zYWN0aW9uKToge1tTdGFja05hbWUgaW4ga2V5b2YgRGV4aWVTdGFja3NdPzogRGV4aWVTdGFja3NbU3RhY2tOYW1lXX1cbntcbiAgY29uc3QgZGJjb3JlID0gY3JlYXRlTWlkZGxld2FyZVN0YWNrPERCQ29yZT4oXG4gICAgY3JlYXRlREJDb3JlKGlkYmRiLCBJREJLZXlSYW5nZSwgdG1wVHJhbnMpLFxuICAgIG1pZGRsZXdhcmVzLmRiY29yZSk7XG4gIFxuICAvLyBUT0RPOiBDcmVhdGUgb3RoZXIgc3RhY2tzIHRoZSBzYW1lIHdheSBhcyBhYm92ZS4gVGhleSBtaWdodCBiZSBkZXBlbmRhbnQgb24gdGhlIHJlc3VsdFxuICAvLyBvZiBjcmVhdGluZyBkYmNvcmUgc3RhY2suXG5cbiAgcmV0dXJuIHtcbiAgICBkYmNvcmVcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlTWlkZGxld2FyZVN0YWNrcyh7X25vdmlwOiBkYn06IERleGllLCB0bXBUcmFuczogSURCVHJhbnNhY3Rpb24pIHtcbiAgY29uc3QgaWRiZGIgPSB0bXBUcmFucy5kYjtcbiAgY29uc3Qgc3RhY2tzID0gY3JlYXRlTWlkZGxld2FyZVN0YWNrcyhkYi5fbWlkZGxld2FyZXMsIGlkYmRiLCBkYi5fZGVwcywgdG1wVHJhbnMpO1xuICBkYi5jb3JlID0gc3RhY2tzLmRiY29yZSE7XG4gIGRiLnRhYmxlcy5mb3JFYWNoKHRhYmxlID0+IHtcbiAgICBjb25zdCB0YWJsZU5hbWUgPSB0YWJsZS5uYW1lO1xuICAgIGlmIChkYi5jb3JlLnNjaGVtYS50YWJsZXMuc29tZSh0YmwgPT4gdGJsLm5hbWUgPT09IHRhYmxlTmFtZSkpIHtcbiAgICAgIHRhYmxlLmNvcmUgPSBkYi5jb3JlLnRhYmxlKHRhYmxlTmFtZSk7XG4gICAgICBpZiAoZGJbdGFibGVOYW1lXSBpbnN0YW5jZW9mIGRiLlRhYmxlKSB7XG4gICAgICAgICAgZGJbdGFibGVOYW1lXS5jb3JlID0gdGFibGUuY29yZTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuIiwgImltcG9ydCB7IERleGllIH0gZnJvbSAnLi4vZGV4aWUnO1xuaW1wb3J0IHsgRGJTY2hlbWEgfSBmcm9tICcuLi8uLi9wdWJsaWMvdHlwZXMvZGItc2NoZW1hJztcbmltcG9ydCB7IF9nbG9iYWwgfSBmcm9tIFwiLi4vLi4vZ2xvYmFscy9nbG9iYWxcIjtcbmltcG9ydCB7IHNldFByb3AsIGtleXMsIHNsaWNlLCBpc0FycmF5LCBzaGFsbG93Q2xvbmUsIGlzQXN5bmNGdW5jdGlvbiwgZGVmaW5lUHJvcGVydHksIGdldFByb3BlcnR5RGVzY3JpcHRvciB9IGZyb20gJy4uLy4uL2Z1bmN0aW9ucy91dGlscyc7XG5pbXBvcnQgeyBUcmFuc2FjdGlvbiB9IGZyb20gJy4uL3RyYW5zYWN0aW9uJztcbmltcG9ydCB7IFZlcnNpb24gfSBmcm9tICcuL3ZlcnNpb24nO1xuaW1wb3J0IFByb21pc2UsIHsgUFNELCBuZXdTY29wZSwgTmF0aXZlUHJvbWlzZSwgZGVjcmVtZW50RXhwZWN0ZWRBd2FpdHMsIGluY3JlbWVudEV4cGVjdGVkQXdhaXRzIH0gZnJvbSAnLi4vLi4vaGVscGVycy9wcm9taXNlJztcbmltcG9ydCB7IGV4Y2VwdGlvbnMgfSBmcm9tICcuLi8uLi9lcnJvcnMnO1xuaW1wb3J0IHsgVGFibGVTY2hlbWEgfSBmcm9tICcuLi8uLi9wdWJsaWMvdHlwZXMvdGFibGUtc2NoZW1hJztcbmltcG9ydCB7IEluZGV4U3BlYyB9IGZyb20gJy4uLy4uL3B1YmxpYy90eXBlcy9pbmRleC1zcGVjJztcbmltcG9ydCB7IGhhc0lFRGVsZXRlT2JqZWN0U3RvcmVCdWcsIGlzSUVPckVkZ2UgfSBmcm9tICcuLi8uLi9nbG9iYWxzL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBzYWZhcmlNdWx0aVN0b3JlRml4IH0gZnJvbSAnLi4vLi4vZnVuY3Rpb25zL3F1aXJrcyc7XG5pbXBvcnQgeyBjcmVhdGVJbmRleFNwZWMsIG5hbWVGcm9tS2V5UGF0aCB9IGZyb20gJy4uLy4uL2hlbHBlcnMvaW5kZXgtc3BlYyc7XG5pbXBvcnQgeyBjcmVhdGVUYWJsZVNjaGVtYSB9IGZyb20gJy4uLy4uL2hlbHBlcnMvdGFibGUtc2NoZW1hJztcbmltcG9ydCB7IGdlbmVyYXRlTWlkZGxld2FyZVN0YWNrcyB9IGZyb20gJy4uL2RleGllL2dlbmVyYXRlLW1pZGRsZXdhcmUtc3RhY2tzJztcblxuZXhwb3J0IGZ1bmN0aW9uIHNldEFwaU9uUGxhY2Uoe19ub3ZpcDogZGJ9OiBEZXhpZSwgb2JqczogT2JqZWN0W10sIHRhYmxlTmFtZXM6IHN0cmluZ1tdLCBkYnNjaGVtYTogRGJTY2hlbWEpIHtcbiAgdGFibGVOYW1lcy5mb3JFYWNoKHRhYmxlTmFtZSA9PiB7XG4gICAgY29uc3Qgc2NoZW1hID0gZGJzY2hlbWFbdGFibGVOYW1lXTtcbiAgICBvYmpzLmZvckVhY2gob2JqID0+IHtcbiAgICAgIGNvbnN0IHByb3BEZXNjID0gZ2V0UHJvcGVydHlEZXNjcmlwdG9yKG9iaiwgdGFibGVOYW1lKTtcbiAgICAgIGlmICghcHJvcERlc2MgfHwgKFwidmFsdWVcIiBpbiBwcm9wRGVzYyAmJiBwcm9wRGVzYy52YWx1ZSA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICAvLyBFaXRoZXIgdGhlIHByb3AgaXMgbm90IGRlY2xhcmVkLCBvciBpdCBpcyBpbml0aWFsaXplZCB0byB1bmRlZmluZWQuXG4gICAgICAgIGlmIChvYmogPT09IGRiLlRyYW5zYWN0aW9uLnByb3RvdHlwZSB8fCBvYmogaW5zdGFuY2VvZiBkYi5UcmFuc2FjdGlvbikge1xuICAgICAgICAgIC8vIG9iaiBpcyBhIFRyYW5zYWN0aW9uIHByb3RvdHlwZSAob3IgcHJvdG90eXBlIG9mIGEgc3ViY2xhc3MgdG8gVHJhbnNhY3Rpb24pXG4gICAgICAgICAgLy8gTWFrZSB0aGUgQVBJIGEgZ2V0dGVyIHRoYXQgcmV0dXJucyB0aGlzLnRhYmxlKHRhYmxlTmFtZSlcbiAgICAgICAgICBzZXRQcm9wKG9iaiwgdGFibGVOYW1lLCB7XG4gICAgICAgICAgICBnZXQodGhpczogVHJhbnNhY3Rpb24pIHsgcmV0dXJuIHRoaXMudGFibGUodGFibGVOYW1lKTsgfSxcbiAgICAgICAgICAgIHNldCh2YWx1ZTogYW55KSB7XG4gICAgICAgICAgICAgIC8vIElzc3VlICMxMDM5XG4gICAgICAgICAgICAgIC8vIExldCBcInRoaXMuc2NoZW1hID0gZGJzY2hlbWE7XCIgYW5kIG90aGVyIHByb3BzIGluIHRyYW5zYWN0aW9uIGNvbnN0cnVjdG9yIHdvcmsgZXZlbiBpZiB0aGVyZSdzIGEgbmFtZSBjb2xsaXNpb24gd2l0aCB0aGUgdGFibGUgbmFtZS5cbiAgICAgICAgICAgICAgZGVmaW5lUHJvcGVydHkodGhpcywgdGFibGVOYW1lLCB7dmFsdWUsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIGVudW1lcmFibGU6IHRydWV9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBUYWJsZSB3aWxsIG5vdCBiZSBib3VuZCB0byBhIHRyYW5zYWN0aW9uICh3aWxsIHVzZSBEZXhpZS5jdXJyZW50VHJhbnNhY3Rpb24pXG4gICAgICAgICAgb2JqW3RhYmxlTmFtZV0gPSBuZXcgZGIuVGFibGUodGFibGVOYW1lLCBzY2hlbWEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlVGFibGVzQXBpKHtfbm92aXA6IGRifTogRGV4aWUsIG9ianM6IE9iamVjdFtdKSB7XG4gIG9ianMuZm9yRWFjaChvYmogPT4ge1xuICAgIGZvciAobGV0IGtleSBpbiBvYmopIHtcbiAgICAgIGlmIChvYmpba2V5XSBpbnN0YW5jZW9mIGRiLlRhYmxlKSBkZWxldGUgb2JqW2tleV07XG4gICAgfVxuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxvd2VyVmVyc2lvbkZpcnN0KGE6IFZlcnNpb24sIGI6IFZlcnNpb24pIHtcbiAgcmV0dXJuIGEuX2NmZy52ZXJzaW9uIC0gYi5fY2ZnLnZlcnNpb247XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBydW5VcGdyYWRlcnMoZGI6IERleGllLCBvbGRWZXJzaW9uOiBudW1iZXIsIGlkYlVwZ3JhZGVUcmFuczogSURCVHJhbnNhY3Rpb24sIHJlamVjdCkge1xuICBjb25zdCBnbG9iYWxTY2hlbWEgPSBkYi5fZGJTY2hlbWE7XG4gIGNvbnN0IHRyYW5zID0gZGIuX2NyZWF0ZVRyYW5zYWN0aW9uKCdyZWFkd3JpdGUnLCBkYi5fc3RvcmVOYW1lcywgZ2xvYmFsU2NoZW1hKTtcbiAgdHJhbnMuY3JlYXRlKGlkYlVwZ3JhZGVUcmFucyk7XG4gIHRyYW5zLl9jb21wbGV0aW9uLmNhdGNoKHJlamVjdCk7XG4gIGNvbnN0IHJlamVjdFRyYW5zYWN0aW9uID0gdHJhbnMuX3JlamVjdC5iaW5kKHRyYW5zKTtcbiAgY29uc3QgdHJhbnNsZXNzID0gUFNELnRyYW5zbGVzcyB8fCBQU0Q7XG4gIG5ld1Njb3BlKCgpID0+IHtcbiAgICBQU0QudHJhbnMgPSB0cmFucztcbiAgICBQU0QudHJhbnNsZXNzID0gdHJhbnNsZXNzO1xuICAgIGlmIChvbGRWZXJzaW9uID09PSAwKSB7XG4gICAgICAvLyBDcmVhdGUgdGFibGVzOlxuICAgICAga2V5cyhnbG9iYWxTY2hlbWEpLmZvckVhY2godGFibGVOYW1lID0+IHtcbiAgICAgICAgY3JlYXRlVGFibGUoaWRiVXBncmFkZVRyYW5zLCB0YWJsZU5hbWUsIGdsb2JhbFNjaGVtYVt0YWJsZU5hbWVdLnByaW1LZXksIGdsb2JhbFNjaGVtYVt0YWJsZU5hbWVdLmluZGV4ZXMpO1xuICAgICAgfSk7XG4gICAgICBnZW5lcmF0ZU1pZGRsZXdhcmVTdGFja3MoZGIsIGlkYlVwZ3JhZGVUcmFucyk7XG4gICAgICBQcm9taXNlLmZvbGxvdygoKSA9PiBkYi5vbi5wb3B1bGF0ZS5maXJlKHRyYW5zKSkuY2F0Y2gocmVqZWN0VHJhbnNhY3Rpb24pO1xuICAgIH0gZWxzZVxuICAgICAgdXBkYXRlVGFibGVzQW5kSW5kZXhlcyhkYiwgb2xkVmVyc2lvbiwgdHJhbnMsIGlkYlVwZ3JhZGVUcmFucykuY2F0Y2gocmVqZWN0VHJhbnNhY3Rpb24pO1xuICB9KTtcbn1cblxuZXhwb3J0IHR5cGUgVXBncmFkZVF1ZXVlSXRlbSA9IChpZGJ0cmFuczogSURCVHJhbnNhY3Rpb24pID0+IFByb21pc2VMaWtlPGFueT4gfCB2b2lkO1xuXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlVGFibGVzQW5kSW5kZXhlcyhcbiAge19ub3ZpcDogZGJ9OiBEZXhpZSxcbiAgb2xkVmVyc2lvbjogbnVtYmVyLFxuICB0cmFuczogVHJhbnNhY3Rpb24sXG4gIGlkYlVwZ3JhZGVUcmFuczogSURCVHJhbnNhY3Rpb24pXG57XG4gIC8vIFVwZ3JhZGUgdmVyc2lvbiB0byB2ZXJzaW9uLCBzdGVwLWJ5LXN0ZXAgZnJvbSBvbGRlc3QgdG8gbmV3ZXN0IHZlcnNpb24uXG4gIC8vIEVhY2ggdHJhbnNhY3Rpb24gb2JqZWN0IHdpbGwgY29udGFpbiB0aGUgdGFibGUgc2V0IHRoYXQgd2FzIGN1cnJlbnQgaW4gdGhhdCB2ZXJzaW9uIChidXQgYWxzbyBub3QteWV0LWRlbGV0ZWQgdGFibGVzIGZyb20gaXRzIHByZXZpb3VzIHZlcnNpb24pXG4gIGNvbnN0IHF1ZXVlOiBVcGdyYWRlUXVldWVJdGVtW10gPSBbXTtcbiAgY29uc3QgdmVyc2lvbnMgPSBkYi5fdmVyc2lvbnM7XG4gIGxldCBnbG9iYWxTY2hlbWEgPSBkYi5fZGJTY2hlbWEgPSBidWlsZEdsb2JhbFNjaGVtYShkYiwgZGIuaWRiZGIsIGlkYlVwZ3JhZGVUcmFucyk7XG4gIGxldCBhbnlDb250ZW50VXBncmFkZXJIYXNSdW4gPSBmYWxzZTtcblxuICBjb25zdCB2ZXJzVG9SdW4gPSB2ZXJzaW9ucy5maWx0ZXIodiA9PiB2Ll9jZmcudmVyc2lvbiA+PSBvbGRWZXJzaW9uKTtcbiAgdmVyc1RvUnVuLmZvckVhY2godmVyc2lvbiA9PiB7XG4gICAgcXVldWUucHVzaCgoKSA9PiB7XG4gICAgICBjb25zdCBvbGRTY2hlbWEgPSBnbG9iYWxTY2hlbWE7XG4gICAgICBjb25zdCBuZXdTY2hlbWEgPSB2ZXJzaW9uLl9jZmcuZGJzY2hlbWE7XG4gICAgICBhZGp1c3RUb0V4aXN0aW5nSW5kZXhOYW1lcyhkYiwgb2xkU2NoZW1hLCBpZGJVcGdyYWRlVHJhbnMpO1xuICAgICAgYWRqdXN0VG9FeGlzdGluZ0luZGV4TmFtZXMoZGIsIG5ld1NjaGVtYSwgaWRiVXBncmFkZVRyYW5zKTtcblxuICAgICAgZ2xvYmFsU2NoZW1hID0gZGIuX2RiU2NoZW1hID0gbmV3U2NoZW1hO1xuXG4gICAgICBjb25zdCBkaWZmID0gZ2V0U2NoZW1hRGlmZihvbGRTY2hlbWEsIG5ld1NjaGVtYSk7XG4gICAgICAvLyBBZGQgdGFibGVzICAgICAgICAgICBcbiAgICAgIGRpZmYuYWRkLmZvckVhY2godHVwbGUgPT4ge1xuICAgICAgICBjcmVhdGVUYWJsZShpZGJVcGdyYWRlVHJhbnMsIHR1cGxlWzBdLCB0dXBsZVsxXS5wcmltS2V5LCB0dXBsZVsxXS5pbmRleGVzKTtcbiAgICAgIH0pO1xuICAgICAgLy8gQ2hhbmdlIHRhYmxlc1xuICAgICAgZGlmZi5jaGFuZ2UuZm9yRWFjaChjaGFuZ2UgPT4ge1xuICAgICAgICBpZiAoY2hhbmdlLnJlY3JlYXRlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuVXBncmFkZShcIk5vdCB5ZXQgc3VwcG9ydCBmb3IgY2hhbmdpbmcgcHJpbWFyeSBrZXlcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3Qgc3RvcmUgPSBpZGJVcGdyYWRlVHJhbnMub2JqZWN0U3RvcmUoY2hhbmdlLm5hbWUpO1xuICAgICAgICAgIC8vIEFkZCBpbmRleGVzXG4gICAgICAgICAgY2hhbmdlLmFkZC5mb3JFYWNoKGlkeCA9PiBhZGRJbmRleChzdG9yZSwgaWR4KSk7XG4gICAgICAgICAgLy8gVXBkYXRlIGluZGV4ZXNcbiAgICAgICAgICBjaGFuZ2UuY2hhbmdlLmZvckVhY2goaWR4ID0+IHtcbiAgICAgICAgICAgIHN0b3JlLmRlbGV0ZUluZGV4KGlkeC5uYW1lKTtcbiAgICAgICAgICAgIGFkZEluZGV4KHN0b3JlLCBpZHgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIC8vIERlbGV0ZSBpbmRleGVzXG4gICAgICAgICAgY2hhbmdlLmRlbC5mb3JFYWNoKGlkeE5hbWUgPT4gc3RvcmUuZGVsZXRlSW5kZXgoaWR4TmFtZSkpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgY29udGVudFVwZ3JhZGUgPSB2ZXJzaW9uLl9jZmcuY29udGVudFVwZ3JhZGU7XG5cbiAgICAgIGlmIChjb250ZW50VXBncmFkZSAmJiB2ZXJzaW9uLl9jZmcudmVyc2lvbiA+IG9sZFZlcnNpb24pIHtcbiAgICAgICAgLy8gVXBkYXRlIGRiLmNvcmUgd2l0aCBuZXcgdGFibGVzIGFuZCBpbmRleGVzOlxuICAgICAgICBnZW5lcmF0ZU1pZGRsZXdhcmVTdGFja3MoZGIsIGlkYlVwZ3JhZGVUcmFucyk7XG4gICAgICAgIHRyYW5zLl9tZW1vaXplZFRhYmxlcyA9IHt9OyAvLyBJbnZhbGlkYXRlIG1lbW9pemF0aW9uIGFzIHRyYW5zYWN0aW9uIHNoYXBlIG1heSBjaGFuZ2UgYmV0d2VlbiB2ZXJzaW9ucy5cblxuICAgICAgICBhbnlDb250ZW50VXBncmFkZXJIYXNSdW4gPSB0cnVlO1xuXG4gICAgICAgIC8vIEFkZCB0by1iZS1kZWxldGVkIHRhYmxlcyB0byBjb250ZW50VXBncmFkZSB0cmFuc2FjdGlvblxuICAgICAgICBsZXQgdXBncmFkZVNjaGVtYSA9IHNoYWxsb3dDbG9uZShuZXdTY2hlbWEpO1xuICAgICAgICBkaWZmLmRlbC5mb3JFYWNoKHRhYmxlID0+IHtcbiAgICAgICAgICB1cGdyYWRlU2NoZW1hW3RhYmxlXSA9IG9sZFNjaGVtYVt0YWJsZV07XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFNhZmUgdG8gYWZmZWN0IFRyYW5zYWN0aW9uLnByb3RvdHlwZSBnbG9iYWxseSBpbiB0aGlzIG1vbWVudCxcbiAgICAgICAgLy8gYmVjYXVzZSB3aGVuIHRoaXMgY29kZSBydW5zLCB0aGVyZSBtYXkgbm90IGJlIGFueSBvdGhlciBjb2RlXG4gICAgICAgIC8vIHRoYXQgY2FuIGFjY2VzcyBhbnkgdHJhbnNhY3Rpb24gaW5zdGFuY2UsIGVsc2UgdGhhbiB0aGlzIHBhcnRpY3VsYXJcbiAgICAgICAgLy8gdXBncmFkZXIgZnVuY3Rpb24uXG4gICAgICAgIHJlbW92ZVRhYmxlc0FwaShkYiwgW2RiLlRyYW5zYWN0aW9uLnByb3RvdHlwZV0pO1xuICAgICAgICBzZXRBcGlPblBsYWNlKGRiLCBbZGIuVHJhbnNhY3Rpb24ucHJvdG90eXBlXSwga2V5cyh1cGdyYWRlU2NoZW1hKSwgdXBncmFkZVNjaGVtYSk7XG4gICAgICAgIHRyYW5zLnNjaGVtYSA9IHVwZ3JhZGVTY2hlbWE7XG5cbiAgICAgICAgLy8gU3VwcG9ydCBmb3IgbmF0aXZlIGFzeW5jIGF3YWl0LlxuICAgICAgICBjb25zdCBjb250ZW50VXBncmFkZUlzQXN5bmMgPSBpc0FzeW5jRnVuY3Rpb24oY29udGVudFVwZ3JhZGUpO1xuICAgICAgICBpZiAoY29udGVudFVwZ3JhZGVJc0FzeW5jKSB7XG4gICAgICAgICAgaW5jcmVtZW50RXhwZWN0ZWRBd2FpdHMoKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgbGV0IHJldHVyblZhbHVlOiBhbnk7XG4gICAgICAgIGNvbnN0IHByb21pc2VGb2xsb3dlZCA9IFByb21pc2UuZm9sbG93KCgpID0+IHtcbiAgICAgICAgICAvLyBGaW5hbGx5LCBjYWxsIHRoZSBzY29wZSBmdW5jdGlvbiB3aXRoIG91ciB0YWJsZSBhbmQgdHJhbnNhY3Rpb24gYXJndW1lbnRzLlxuICAgICAgICAgIHJldHVyblZhbHVlID0gY29udGVudFVwZ3JhZGUodHJhbnMpO1xuICAgICAgICAgIGlmIChyZXR1cm5WYWx1ZSkge1xuICAgICAgICAgICAgaWYgKGNvbnRlbnRVcGdyYWRlSXNBc3luYykge1xuICAgICAgICAgICAgICAvLyBjb250ZW50VXBncmFkZSBpcyBhIG5hdGl2ZSBhc3luYyBmdW5jdGlvbiAtIHdlIGtub3cgZm9yIHN1cmUgcmV0dXJuVmFsdWUgaXMgbmF0aXZlIHByb21pc2UuXG4gICAgICAgICAgICAgIHZhciBkZWNyZW1lbnRvciA9IGRlY3JlbWVudEV4cGVjdGVkQXdhaXRzLmJpbmQobnVsbCwgbnVsbCk7XG4gICAgICAgICAgICAgIHJldHVyblZhbHVlLnRoZW4oZGVjcmVtZW50b3IsIGRlY3JlbWVudG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gKHJldHVyblZhbHVlICYmIHR5cGVvZiByZXR1cm5WYWx1ZS50aGVuID09PSAnZnVuY3Rpb24nID9cbiAgICAgICAgICBQcm9taXNlLnJlc29sdmUocmV0dXJuVmFsdWUpIDogcHJvbWlzZUZvbGxvd2VkLnRoZW4oKCk9PnJldHVyblZhbHVlKSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcXVldWUucHVzaChpZGJ0cmFucyA9PiB7XG4gICAgICBpZiAoIWFueUNvbnRlbnRVcGdyYWRlckhhc1J1biB8fCAhaGFzSUVEZWxldGVPYmplY3RTdG9yZUJ1ZykgeyAvLyBEb250IGRlbGV0ZSBvbGQgdGFibGVzIGlmIGllQnVnIGlzIHByZXNlbnQgYW5kIGEgY29udGVudCB1cGdyYWRlciBoYXMgcnVuLiBMZXQgdGFibGVzIGJlIGxlZnQgaW4gREIgc28gZmFyLiBUaGlzIG5lZWRzIHRvIGJlIHRha2VuIGNhcmUgb2YuXG4gICAgICAgIGNvbnN0IG5ld1NjaGVtYSA9IHZlcnNpb24uX2NmZy5kYnNjaGVtYTtcbiAgICAgICAgLy8gRGVsZXRlIG9sZCB0YWJsZXNcbiAgICAgICAgZGVsZXRlUmVtb3ZlZFRhYmxlcyhuZXdTY2hlbWEsIGlkYnRyYW5zKTtcbiAgICAgIH1cbiAgICAgIC8vIFJlc3RvcmUgdGhlIGZpbmFsIEFQSVxuICAgICAgcmVtb3ZlVGFibGVzQXBpKGRiLCBbZGIuVHJhbnNhY3Rpb24ucHJvdG90eXBlXSk7XG4gICAgICBzZXRBcGlPblBsYWNlKGRiLCBbZGIuVHJhbnNhY3Rpb24ucHJvdG90eXBlXSwgZGIuX3N0b3JlTmFtZXMsIGRiLl9kYlNjaGVtYSk7XG4gICAgICB0cmFucy5zY2hlbWEgPSBkYi5fZGJTY2hlbWE7XG4gICAgfSk7XG4gIH0pO1xuXG4gIC8vIE5vdywgY3JlYXRlIGEgcXVldWUgZXhlY3V0aW9uIGVuZ2luZVxuICBmdW5jdGlvbiBydW5RdWV1ZSgpIHtcbiAgICByZXR1cm4gcXVldWUubGVuZ3RoID8gUHJvbWlzZS5yZXNvbHZlKHF1ZXVlLnNoaWZ0KCkodHJhbnMuaWRidHJhbnMpKS50aGVuKHJ1blF1ZXVlKSA6XG4gICAgICBQcm9taXNlLnJlc29sdmUoKTtcbiAgfVxuXG4gIHJldHVybiBydW5RdWV1ZSgpLnRoZW4oKCkgPT4ge1xuICAgIGNyZWF0ZU1pc3NpbmdUYWJsZXMoZ2xvYmFsU2NoZW1hLCBpZGJVcGdyYWRlVHJhbnMpOyAvLyBBdCBsYXN0LCBtYWtlIHN1cmUgdG8gY3JlYXRlIGFueSBtaXNzaW5nIHRhYmxlcy4gKE5lZWRlZCBieSBhZGRvbnMgdGhhdCBhZGQgc3RvcmVzIHRvIERCIHdpdGhvdXQgc3BlY2lmeWluZyB2ZXJzaW9uKVxuICB9KTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTY2hlbWFEaWZmIHtcbiAgZGVsOiBzdHJpbmdbXSxcbiAgYWRkOiBbc3RyaW5nLCBUYWJsZVNjaGVtYV1bXTtcbiAgY2hhbmdlOiBUYWJsZVNjaGVtYURpZmZbXTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUYWJsZVNjaGVtYURpZmYge1xuICBuYW1lOiBzdHJpbmcsXG4gIHJlY3JlYXRlOiBib29sZWFuLFxuICBkZWw6IHN0cmluZ1tdLFxuICBhZGQ6IEluZGV4U3BlY1tdLFxuICBjaGFuZ2U6IEluZGV4U3BlY1tdXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRTY2hlbWFEaWZmKG9sZFNjaGVtYTogRGJTY2hlbWEsIG5ld1NjaGVtYTogRGJTY2hlbWEpOiBTY2hlbWFEaWZmIHtcbiAgY29uc3QgZGlmZjogU2NoZW1hRGlmZiA9IHtcbiAgICBkZWw6IFtdLCAvLyBBcnJheSBvZiB0YWJsZSBuYW1lc1xuICAgIGFkZDogW10sIC8vIEFycmF5IG9mIFt0YWJsZU5hbWUsIG5ld0RlZmluaXRpb25dXG4gICAgY2hhbmdlOiBbXSAvLyBBcnJheSBvZiB7bmFtZTogdGFibGVOYW1lLCByZWNyZWF0ZTogbmV3RGVmaW5pdGlvbiwgZGVsOiBkZWxJbmRleE5hbWVzLCBhZGQ6IG5ld0luZGV4RGVmcywgY2hhbmdlOiBjaGFuZ2VkSW5kZXhEZWZzfVxuICB9O1xuICBsZXQgdGFibGU6IHN0cmluZztcbiAgZm9yICh0YWJsZSBpbiBvbGRTY2hlbWEpIHtcbiAgICBpZiAoIW5ld1NjaGVtYVt0YWJsZV0pIGRpZmYuZGVsLnB1c2godGFibGUpO1xuICB9XG4gIGZvciAodGFibGUgaW4gbmV3U2NoZW1hKSB7XG4gICAgY29uc3Qgb2xkRGVmID0gb2xkU2NoZW1hW3RhYmxlXSxcbiAgICAgIG5ld0RlZiA9IG5ld1NjaGVtYVt0YWJsZV07XG4gICAgaWYgKCFvbGREZWYpIHtcbiAgICAgIGRpZmYuYWRkLnB1c2goW3RhYmxlLCBuZXdEZWZdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgY2hhbmdlID0ge1xuICAgICAgICBuYW1lOiB0YWJsZSxcbiAgICAgICAgZGVmOiBuZXdEZWYsXG4gICAgICAgIHJlY3JlYXRlOiBmYWxzZSxcbiAgICAgICAgZGVsOiBbXSxcbiAgICAgICAgYWRkOiBbXSxcbiAgICAgICAgY2hhbmdlOiBbXVxuICAgICAgfTtcbiAgICAgIGlmIChcbiAgICAgICAgICAoXG4gICAgICAgICAgICAgLy8gY29tcGFyZSBrZXlQYXRocyBubyBtYXR0ZXIgaWYgc3RyaW5nIG9yIHN0cmluZ1tdXG4gICAgICAgICAgICAgLy8gY29tcGFyZSBmYWxzeSBrZXlwYXRocyBzYW1lIG5vIG1hdHRlciBpZiB0aGV5IGFyZSBudWxsIG9yIGVtcHR5IHN0cmluZy5cbiAgICAgICAgICAgICcnKyhvbGREZWYucHJpbUtleS5rZXlQYXRofHwnJylcbiAgICAgICAgICApICE9PSAoXG4gICAgICAgICAgICAnJysobmV3RGVmLnByaW1LZXkua2V5UGF0aHx8JycpXG4gICAgICAgICAgKSB8fFxuICAgICAgICAgICAgLy8gQ29tcGFyZSB0aGUgYXV0b0luY3JlbWVudCBmbGFnIGFsc29cbiAgICAgICAgICAob2xkRGVmLnByaW1LZXkuYXV0byAhPT0gbmV3RGVmLnByaW1LZXkuYXV0byAmJiAhaXNJRU9yRWRnZSkpIC8vIElFIGhhcyBidWcgcmVhZGluZyBhdXRvSW5jcmVtZW50IHByb3AuXG4gICAgICB7XG4gICAgICAgIC8vIFByaW1hcnkga2V5IGhhcyBjaGFuZ2VkLiBSZW1vdmUgYW5kIHJlLWFkZCB0YWJsZS5cbiAgICAgICAgY2hhbmdlLnJlY3JlYXRlID0gdHJ1ZTtcbiAgICAgICAgZGlmZi5jaGFuZ2UucHVzaChjaGFuZ2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gU2FtZSBwcmltYXJ5IGtleS4gSnVzdCBmaW5kIG91dCB3aGF0IGRpZmZlcnM6XG4gICAgICAgIGNvbnN0IG9sZEluZGV4ZXMgPSBvbGREZWYuaWR4QnlOYW1lO1xuICAgICAgICBjb25zdCBuZXdJbmRleGVzID0gbmV3RGVmLmlkeEJ5TmFtZTtcbiAgICAgICAgbGV0IGlkeE5hbWU6IHN0cmluZztcbiAgICAgICAgZm9yIChpZHhOYW1lIGluIG9sZEluZGV4ZXMpIHtcbiAgICAgICAgICBpZiAoIW5ld0luZGV4ZXNbaWR4TmFtZV0pIGNoYW5nZS5kZWwucHVzaChpZHhOYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGlkeE5hbWUgaW4gbmV3SW5kZXhlcykge1xuICAgICAgICAgIGNvbnN0IG9sZElkeCA9IG9sZEluZGV4ZXNbaWR4TmFtZV0sXG4gICAgICAgICAgICBuZXdJZHggPSBuZXdJbmRleGVzW2lkeE5hbWVdO1xuICAgICAgICAgIGlmICghb2xkSWR4KSBjaGFuZ2UuYWRkLnB1c2gobmV3SWR4KTtcbiAgICAgICAgICBlbHNlIGlmIChvbGRJZHguc3JjICE9PSBuZXdJZHguc3JjKSBjaGFuZ2UuY2hhbmdlLnB1c2gobmV3SWR4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhbmdlLmRlbC5sZW5ndGggPiAwIHx8IGNoYW5nZS5hZGQubGVuZ3RoID4gMCB8fCBjaGFuZ2UuY2hhbmdlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBkaWZmLmNoYW5nZS5wdXNoKGNoYW5nZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRpZmY7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVUYWJsZShcbiAgaWRidHJhbnM6IElEQlRyYW5zYWN0aW9uLFxuICB0YWJsZU5hbWU6IHN0cmluZyxcbiAgcHJpbUtleTogSW5kZXhTcGVjLFxuICBpbmRleGVzOiBJbmRleFNwZWNbXVxuKSB7XG4gIGNvbnN0IHN0b3JlID0gaWRidHJhbnMuZGIuY3JlYXRlT2JqZWN0U3RvcmUoXG4gICAgdGFibGVOYW1lLFxuICAgIHByaW1LZXkua2V5UGF0aCA/XG4gICAgICB7IGtleVBhdGg6IHByaW1LZXkua2V5UGF0aCwgYXV0b0luY3JlbWVudDogcHJpbUtleS5hdXRvIH0gOlxuICAgICAgeyBhdXRvSW5jcmVtZW50OiBwcmltS2V5LmF1dG8gfVxuICApO1xuICBpbmRleGVzLmZvckVhY2goaWR4ID0+IGFkZEluZGV4KHN0b3JlLCBpZHgpKTtcbiAgcmV0dXJuIHN0b3JlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlTWlzc2luZ1RhYmxlcyhuZXdTY2hlbWE6IERiU2NoZW1hLCBpZGJ0cmFuczogSURCVHJhbnNhY3Rpb24pIHtcbiAga2V5cyhuZXdTY2hlbWEpLmZvckVhY2godGFibGVOYW1lID0+IHtcbiAgICBpZiAoIWlkYnRyYW5zLmRiLm9iamVjdFN0b3JlTmFtZXMuY29udGFpbnModGFibGVOYW1lKSkge1xuICAgICAgY3JlYXRlVGFibGUoaWRidHJhbnMsIHRhYmxlTmFtZSwgbmV3U2NoZW1hW3RhYmxlTmFtZV0ucHJpbUtleSwgbmV3U2NoZW1hW3RhYmxlTmFtZV0uaW5kZXhlcyk7XG4gICAgfVxuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlbGV0ZVJlbW92ZWRUYWJsZXMobmV3U2NoZW1hOiBEYlNjaGVtYSwgaWRidHJhbnM6IElEQlRyYW5zYWN0aW9uKSB7XG4gIFtdLnNsaWNlLmNhbGwoaWRidHJhbnMuZGIub2JqZWN0U3RvcmVOYW1lcykuZm9yRWFjaChzdG9yZU5hbWUgPT5cbiAgICBuZXdTY2hlbWFbc3RvcmVOYW1lXSA9PSBudWxsICYmIGlkYnRyYW5zLmRiLmRlbGV0ZU9iamVjdFN0b3JlKHN0b3JlTmFtZSkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYWRkSW5kZXgoc3RvcmU6IElEQk9iamVjdFN0b3JlLCBpZHg6IEluZGV4U3BlYykge1xuICBzdG9yZS5jcmVhdGVJbmRleChpZHgubmFtZSwgaWR4LmtleVBhdGgsIHsgdW5pcXVlOiBpZHgudW5pcXVlLCBtdWx0aUVudHJ5OiBpZHgubXVsdGkgfSk7XG59XG5cbmZ1bmN0aW9uIGJ1aWxkR2xvYmFsU2NoZW1hKFxuICBkYjogRGV4aWUsXG4gIGlkYmRiOiBJREJEYXRhYmFzZSxcbiAgdG1wVHJhbnM6IElEQlRyYW5zYWN0aW9uXG4pIHtcbiAgY29uc3QgZ2xvYmFsU2NoZW1hID0ge307XG4gIGNvbnN0IGRiU3RvcmVOYW1lcyA9IHNsaWNlKGlkYmRiLm9iamVjdFN0b3JlTmFtZXMsIDApO1xuICBkYlN0b3JlTmFtZXMuZm9yRWFjaChzdG9yZU5hbWUgPT4ge1xuICAgIGNvbnN0IHN0b3JlID0gdG1wVHJhbnMub2JqZWN0U3RvcmUoc3RvcmVOYW1lKTtcbiAgICBsZXQga2V5UGF0aCA9IHN0b3JlLmtleVBhdGg7XG4gICAgY29uc3QgcHJpbUtleSA9IGNyZWF0ZUluZGV4U3BlYyhcbiAgICAgIG5hbWVGcm9tS2V5UGF0aChrZXlQYXRoKSxcbiAgICAgIGtleVBhdGggfHwgXCJcIixcbiAgICAgIGZhbHNlLFxuICAgICAgZmFsc2UsXG4gICAgICAhIXN0b3JlLmF1dG9JbmNyZW1lbnQsXG4gICAgICBrZXlQYXRoICYmIHR5cGVvZiBrZXlQYXRoICE9PSBcInN0cmluZ1wiLFxuICAgICAgdHJ1ZVxuICAgICk7XG4gICAgY29uc3QgaW5kZXhlczogSW5kZXhTcGVjW10gPSBbXTtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IHN0b3JlLmluZGV4TmFtZXMubGVuZ3RoOyArK2opIHtcbiAgICAgIGNvbnN0IGlkYmluZGV4ID0gc3RvcmUuaW5kZXgoc3RvcmUuaW5kZXhOYW1lc1tqXSk7XG4gICAgICBrZXlQYXRoID0gaWRiaW5kZXgua2V5UGF0aDtcbiAgICAgIHZhciBpbmRleCA9IGNyZWF0ZUluZGV4U3BlYyhcbiAgICAgICAgaWRiaW5kZXgubmFtZSxcbiAgICAgICAga2V5UGF0aCxcbiAgICAgICAgISFpZGJpbmRleC51bmlxdWUsXG4gICAgICAgICEhaWRiaW5kZXgubXVsdGlFbnRyeSxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIGtleVBhdGggJiYgdHlwZW9mIGtleVBhdGggIT09IFwic3RyaW5nXCIsXG4gICAgICAgIGZhbHNlXG4gICAgICApO1xuICAgICAgaW5kZXhlcy5wdXNoKGluZGV4KTtcbiAgICB9XG4gICAgZ2xvYmFsU2NoZW1hW3N0b3JlTmFtZV0gPSBjcmVhdGVUYWJsZVNjaGVtYShzdG9yZU5hbWUsIHByaW1LZXksIGluZGV4ZXMpO1xuICB9KTtcbiAgcmV0dXJuIGdsb2JhbFNjaGVtYTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlYWRHbG9iYWxTY2hlbWEoe19ub3ZpcDogZGJ9OiBEZXhpZSwgaWRiZGI6IElEQkRhdGFiYXNlLCB0bXBUcmFuczogSURCVHJhbnNhY3Rpb24pIHtcbiAgZGIudmVybm8gPSBpZGJkYi52ZXJzaW9uIC8gMTA7XG4gIGNvbnN0IGdsb2JhbFNjaGVtYSA9IGRiLl9kYlNjaGVtYSA9IGJ1aWxkR2xvYmFsU2NoZW1hKGRiLCBpZGJkYiwgdG1wVHJhbnMpO1xuICBkYi5fc3RvcmVOYW1lcyA9IHNsaWNlKGlkYmRiLm9iamVjdFN0b3JlTmFtZXMsIDApO1xuICBzZXRBcGlPblBsYWNlKGRiLCBbZGIuX2FsbFRhYmxlc10sIGtleXMoZ2xvYmFsU2NoZW1hKSwgZ2xvYmFsU2NoZW1hKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHZlcmlmeUluc3RhbGxlZFNjaGVtYShkYjogRGV4aWUsIHRtcFRyYW5zOiBJREJUcmFuc2FjdGlvbik6IGJvb2xlYW4ge1xuICBjb25zdCBpbnN0YWxsZWRTY2hlbWEgPSBidWlsZEdsb2JhbFNjaGVtYShkYiwgZGIuaWRiZGIsIHRtcFRyYW5zKTtcbiAgY29uc3QgZGlmZiA9IGdldFNjaGVtYURpZmYoaW5zdGFsbGVkU2NoZW1hLCBkYi5fZGJTY2hlbWEpO1xuICByZXR1cm4gIShkaWZmLmFkZC5sZW5ndGggfHwgZGlmZi5jaGFuZ2Uuc29tZShjaCA9PiBjaC5hZGQubGVuZ3RoIHx8IGNoLmNoYW5nZS5sZW5ndGgpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFkanVzdFRvRXhpc3RpbmdJbmRleE5hbWVzKHtfbm92aXA6IGRifTogRGV4aWUsIHNjaGVtYTogRGJTY2hlbWEsIGlkYnRyYW5zOiBJREJUcmFuc2FjdGlvbikge1xuICAvLyBJc3N1ZSAjMzAgUHJvYmxlbSB3aXRoIGV4aXN0aW5nIGRiIC0gYWRqdXN0IHRvIGV4aXN0aW5nIGluZGV4IG5hbWVzIHdoZW4gbWlncmF0aW5nIGZyb20gbm9uLWRleGllIGRiXG4gIGNvbnN0IHN0b3JlTmFtZXMgPSBpZGJ0cmFucy5kYi5vYmplY3RTdG9yZU5hbWVzO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RvcmVOYW1lcy5sZW5ndGg7ICsraSkge1xuICAgIGNvbnN0IHN0b3JlTmFtZSA9IHN0b3JlTmFtZXNbaV07XG4gICAgY29uc3Qgc3RvcmUgPSBpZGJ0cmFucy5vYmplY3RTdG9yZShzdG9yZU5hbWUpO1xuICAgIGRiLl9oYXNHZXRBbGwgPSAnZ2V0QWxsJyBpbiBzdG9yZTtcblxuICAgIGZvciAobGV0IGogPSAwOyBqIDwgc3RvcmUuaW5kZXhOYW1lcy5sZW5ndGg7ICsraikge1xuICAgICAgY29uc3QgaW5kZXhOYW1lID0gc3RvcmUuaW5kZXhOYW1lc1tqXTtcbiAgICAgIGNvbnN0IGtleVBhdGggPSBzdG9yZS5pbmRleChpbmRleE5hbWUpLmtleVBhdGg7XG4gICAgICBjb25zdCBkZXhpZU5hbWUgPSB0eXBlb2Yga2V5UGF0aCA9PT0gJ3N0cmluZycgPyBrZXlQYXRoIDogXCJbXCIgKyBzbGljZShrZXlQYXRoKS5qb2luKCcrJykgKyBcIl1cIjtcbiAgICAgIGlmIChzY2hlbWFbc3RvcmVOYW1lXSkge1xuICAgICAgICBjb25zdCBpbmRleFNwZWMgPSBzY2hlbWFbc3RvcmVOYW1lXS5pZHhCeU5hbWVbZGV4aWVOYW1lXTtcbiAgICAgICAgaWYgKGluZGV4U3BlYykge1xuICAgICAgICAgIGluZGV4U3BlYy5uYW1lID0gaW5kZXhOYW1lO1xuICAgICAgICAgIGRlbGV0ZSBzY2hlbWFbc3RvcmVOYW1lXS5pZHhCeU5hbWVbZGV4aWVOYW1lXTtcbiAgICAgICAgICBzY2hlbWFbc3RvcmVOYW1lXS5pZHhCeU5hbWVbaW5kZXhOYW1lXSA9IGluZGV4U3BlYztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIEJ1ZyB3aXRoIGdldEFsbCgpIG9uIFNhZmFyaSB2ZXI8NjA0IG9uIFdvcmtlcnMgb25seSwgc2VlIGRpc2N1c3Npb24gZm9sbG93aW5nIFBSICM1NzlcbiAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIC9TYWZhcmkvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiZcbiAgICAhLyhDaHJvbWVcXC98RWRnZVxcLykvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiZcbiAgICBfZ2xvYmFsLldvcmtlckdsb2JhbFNjb3BlICYmIF9nbG9iYWwgaW5zdGFuY2VvZiBfZ2xvYmFsLldvcmtlckdsb2JhbFNjb3BlICYmXG4gICAgW10uY29uY2F0KG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL1NhZmFyaVxcLyhcXGQqKS8pKVsxXSA8IDYwNClcbiAge1xuICAgIGRiLl9oYXNHZXRBbGwgPSBmYWxzZTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VJbmRleFN5bnRheChwcmltS2V5QW5kSW5kZXhlczogc3RyaW5nKTogSW5kZXhTcGVjW10ge1xuICByZXR1cm4gcHJpbUtleUFuZEluZGV4ZXMuc3BsaXQoJywnKS5tYXAoKGluZGV4LCBpbmRleE51bSkgPT4ge1xuICAgIGluZGV4ID0gaW5kZXgudHJpbSgpO1xuICAgIGNvbnN0IG5hbWUgPSBpbmRleC5yZXBsYWNlKC8oWyYqXXxcXCtcXCspL2csIFwiXCIpOyAvLyBSZW1vdmUgXCImXCIsIFwiKytcIiBhbmQgXCIqXCJcbiAgICAvLyBMZXQga2V5UGF0aCBvZiBcIlthK2JdXCIgYmUgW1wiYVwiLFwiYlwiXTpcbiAgICBjb25zdCBrZXlQYXRoID0gL15cXFsvLnRlc3QobmFtZSkgPyBuYW1lLm1hdGNoKC9eXFxbKC4qKVxcXSQvKVsxXS5zcGxpdCgnKycpIDogbmFtZTtcblxuICAgIHJldHVybiBjcmVhdGVJbmRleFNwZWMoXG4gICAgICBuYW1lLFxuICAgICAga2V5UGF0aCB8fCBudWxsLFxuICAgICAgL1xcJi8udGVzdChpbmRleCksXG4gICAgICAvXFwqLy50ZXN0KGluZGV4KSxcbiAgICAgIC9cXCtcXCsvLnRlc3QoaW5kZXgpLFxuICAgICAgaXNBcnJheShrZXlQYXRoKSxcbiAgICAgIGluZGV4TnVtID09PSAwXG4gICAgKTtcbiAgfSk7XG59XG4iLCAiaW1wb3J0IHsgVmVyc2lvbiBhcyBJVmVyc2lvbiB9IGZyb20gJy4uLy4uL3B1YmxpYy90eXBlcy92ZXJzaW9uJztcbmltcG9ydCB7IERiU2NoZW1hIH0gZnJvbSAnLi4vLi4vcHVibGljL3R5cGVzL2RiLXNjaGVtYSc7XG5pbXBvcnQgeyBleHRlbmQsIGtleXMgfSBmcm9tICcuLi8uLi9mdW5jdGlvbnMvdXRpbHMnO1xuaW1wb3J0IHsgRGV4aWUgfSBmcm9tICcuLi9kZXhpZSc7XG5pbXBvcnQgeyBUcmFuc2FjdGlvbiB9IGZyb20gJy4uL3RyYW5zYWN0aW9uJztcbmltcG9ydCB7IHJlbW92ZVRhYmxlc0FwaSwgc2V0QXBpT25QbGFjZSwgcGFyc2VJbmRleFN5bnRheCB9IGZyb20gJy4vc2NoZW1hLWhlbHBlcnMnO1xuaW1wb3J0IHsgZXhjZXB0aW9ucyB9IGZyb20gJy4uLy4uL2Vycm9ycyc7XG5pbXBvcnQgeyBjcmVhdGVUYWJsZVNjaGVtYSB9IGZyb20gJy4uLy4uL2hlbHBlcnMvdGFibGUtc2NoZW1hJztcbmltcG9ydCB7IG5vcCwgcHJvbWlzYWJsZUNoYWluIH0gZnJvbSAnLi4vLi4vZnVuY3Rpb25zL2NoYWluaW5nLWZ1bmN0aW9ucyc7XG5cbi8qKiBjbGFzcyBWZXJzaW9uXG4gKlxuICogaHR0cHM6Ly9kZXhpZS5vcmcvZG9jcy9WZXJzaW9uL1ZlcnNpb25cbiAqL1xuZXhwb3J0IGNsYXNzIFZlcnNpb24gaW1wbGVtZW50cyBJVmVyc2lvbiB7XG4gIGRiOiBEZXhpZTtcbiAgX2NmZzoge1xuICAgIHZlcnNpb246IG51bWJlcixcbiAgICBzdG9yZXNTb3VyY2U6IHsgW3RhYmxlTmFtZTogc3RyaW5nXTogc3RyaW5nIHwgbnVsbCB9LFxuICAgIGRic2NoZW1hOiBEYlNjaGVtYSxcbiAgICB0YWJsZXM6IHt9LFxuICAgIGNvbnRlbnRVcGdyYWRlOiBGdW5jdGlvbiB8IG51bGxcbiAgfVxuXG4gIF9wYXJzZVN0b3Jlc1NwZWMoc3RvcmVzOiB7IFt0YWJsZU5hbWU6IHN0cmluZ106IHN0cmluZyB8IG51bGwgfSwgb3V0U2NoZW1hOiBEYlNjaGVtYSk6IGFueSB7XG4gICAga2V5cyhzdG9yZXMpLmZvckVhY2godGFibGVOYW1lID0+IHtcbiAgICAgIGlmIChzdG9yZXNbdGFibGVOYW1lXSAhPT0gbnVsbCkge1xuICAgICAgICAgIHZhciBpbmRleGVzID0gcGFyc2VJbmRleFN5bnRheChzdG9yZXNbdGFibGVOYW1lXSk7XG4gICAgICAgICAgdmFyIHByaW1LZXkgPSBpbmRleGVzLnNoaWZ0KCk7XG4gICAgICAgICAgaWYgKHByaW1LZXkubXVsdGkpIHRocm93IG5ldyBleGNlcHRpb25zLlNjaGVtYShcIlByaW1hcnkga2V5IGNhbm5vdCBiZSBtdWx0aS12YWx1ZWRcIik7XG4gICAgICAgICAgaW5kZXhlcy5mb3JFYWNoKGlkeCA9PiB7XG4gICAgICAgICAgICAgIGlmIChpZHguYXV0bykgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuU2NoZW1hKFwiT25seSBwcmltYXJ5IGtleSBjYW4gYmUgbWFya2VkIGFzIGF1dG9JbmNyZW1lbnQgKCsrKVwiKTtcbiAgICAgICAgICAgICAgaWYgKCFpZHgua2V5UGF0aCkgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuU2NoZW1hKFwiSW5kZXggbXVzdCBoYXZlIGEgbmFtZSBhbmQgY2Fubm90IGJlIGFuIGVtcHR5IHN0cmluZ1wiKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBvdXRTY2hlbWFbdGFibGVOYW1lXSA9IGNyZWF0ZVRhYmxlU2NoZW1hKHRhYmxlTmFtZSwgcHJpbUtleSwgaW5kZXhlcyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBzdG9yZXMoc3RvcmVzOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB8IG51bGw7IH0pOiBJVmVyc2lvbiB7XG4gICAgY29uc3QgZGIgPSB0aGlzLmRiO1xuICAgIHRoaXMuX2NmZy5zdG9yZXNTb3VyY2UgPSB0aGlzLl9jZmcuc3RvcmVzU291cmNlID9cbiAgICAgIGV4dGVuZCh0aGlzLl9jZmcuc3RvcmVzU291cmNlLCBzdG9yZXMpIDpcbiAgICAgIHN0b3JlcztcbiAgICBjb25zdCB2ZXJzaW9ucyA9IGRiLl92ZXJzaW9ucztcblxuICAgIC8vIERlcml2ZSBzdG9yZXMgZnJvbSBlYXJsaWVyIHZlcnNpb25zIGlmIHRoZXkgYXJlIG5vdCBleHBsaWNpdGVseSBzcGVjaWZpZWQgYXMgbnVsbCBvciBhIG5ldyBzeW50YXguXG4gICAgY29uc3Qgc3RvcmVzU3BlYzogeyBba2V5OiBzdHJpbmddOiBzdHJpbmc7IH0gPSB7fTtcbiAgICBsZXQgZGJzY2hlbWEgPSB7fTtcbiAgICB2ZXJzaW9ucy5mb3JFYWNoKHZlcnNpb24gPT4geyAvLyAndmVyc2lvbnMnIGlzIGFsd2F5cyBzb3J0ZWQgYnkgbG93ZXN0IHZlcnNpb24gZmlyc3QuXG4gICAgICBleHRlbmQoc3RvcmVzU3BlYywgdmVyc2lvbi5fY2ZnLnN0b3Jlc1NvdXJjZSk7XG4gICAgICBkYnNjaGVtYSA9ICh2ZXJzaW9uLl9jZmcuZGJzY2hlbWEgPSB7fSk7XG4gICAgICB2ZXJzaW9uLl9wYXJzZVN0b3Jlc1NwZWMoc3RvcmVzU3BlYywgZGJzY2hlbWEpO1xuICAgIH0pO1xuICAgIC8vIFVwZGF0ZSB0aGUgbGF0ZXN0IHNjaGVtYSB0byB0aGlzIHZlcnNpb25cbiAgICBkYi5fZGJTY2hlbWEgPSBkYnNjaGVtYTtcbiAgICAvLyBVcGRhdGUgQVBJc1xuICAgIHJlbW92ZVRhYmxlc0FwaShkYiwgW2RiLl9hbGxUYWJsZXMsIGRiLCBkYi5UcmFuc2FjdGlvbi5wcm90b3R5cGVdKTtcbiAgICBzZXRBcGlPblBsYWNlKGRiLCBbZGIuX2FsbFRhYmxlcywgZGIsIGRiLlRyYW5zYWN0aW9uLnByb3RvdHlwZSwgdGhpcy5fY2ZnLnRhYmxlc10sIGtleXMoZGJzY2hlbWEpLCBkYnNjaGVtYSk7XG4gICAgZGIuX3N0b3JlTmFtZXMgPSBrZXlzKGRic2NoZW1hKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHVwZ3JhZGUodXBncmFkZUZ1bmN0aW9uOiAodHJhbnM6IFRyYW5zYWN0aW9uKSA9PiBQcm9taXNlTGlrZTxhbnk+IHwgdm9pZCk6IFZlcnNpb24ge1xuICAgIHRoaXMuX2NmZy5jb250ZW50VXBncmFkZSA9IHByb21pc2FibGVDaGFpbih0aGlzLl9jZmcuY29udGVudFVwZ3JhZGUgfHwgbm9wLCB1cGdyYWRlRnVuY3Rpb24pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG59XG4iLCAiaW1wb3J0IHsgRGV4aWUgfSBmcm9tICcuLi9kZXhpZSc7XG5pbXBvcnQgeyBtYWtlQ2xhc3NDb25zdHJ1Y3RvciB9IGZyb20gJy4uLy4uL2Z1bmN0aW9ucy9tYWtlLWNsYXNzLWNvbnN0cnVjdG9yJztcbmltcG9ydCB7IFZlcnNpb24gfSBmcm9tICcuL3ZlcnNpb24nO1xuXG5leHBvcnQgaW50ZXJmYWNlIFZlcnNpb25Db25zdHJ1Y3RvciB7XG4gIG5ldyh2ZXJzaW9uTnVtYmVyOiBudW1iZXIpOiBWZXJzaW9uO1xuICBwcm90b3R5cGU6IFZlcnNpb247XG59XG5cbi8qKiBHZW5lcmF0ZXMgYSBWZXJzaW9uIGNvbnN0cnVjdG9yIGJvdW5kIHRvIGdpdmVuIERleGllIGluc3RhbmNlLlxuICogXG4gKiBUaGUgcHVycG9zZSBvZiBoYXZpbmcgZHluYW1pY2FsbHkgY3JlYXRlZCBjb25zdHJ1Y3RvcnMsIGlzIHRvIGFsbG93XG4gKiBhZGRvbnMgdG8gZXh0ZW5kIGNsYXNzZXMgZm9yIGEgY2VydGFpbiBEZXhpZSBpbnN0YW5jZSB3aXRob3V0IGFmZmVjdGluZ1xuICogb3RoZXIgZGIgaW5zdGFuY2VzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlVmVyc2lvbkNvbnN0cnVjdG9yKGRiOiBEZXhpZSkge1xuICByZXR1cm4gbWFrZUNsYXNzQ29uc3RydWN0b3I8VmVyc2lvbkNvbnN0cnVjdG9yPihcbiAgICBWZXJzaW9uLnByb3RvdHlwZSxcblxuICAgIGZ1bmN0aW9uIFZlcnNpb24odGhpczogVmVyc2lvbiwgdmVyc2lvbk51bWJlcjogbnVtYmVyKSB7XG4gICAgICB0aGlzLmRiID0gZGI7XG4gICAgICB0aGlzLl9jZmcgPSB7XG4gICAgICAgIHZlcnNpb246IHZlcnNpb25OdW1iZXIsXG4gICAgICAgIHN0b3Jlc1NvdXJjZTogbnVsbCxcbiAgICAgICAgZGJzY2hlbWE6IHt9LFxuICAgICAgICB0YWJsZXM6IHt9LFxuICAgICAgICBjb250ZW50VXBncmFkZTogbnVsbFxuICAgICAgfTtcbiAgICB9KTtcblxufVxuIiwgImltcG9ydCB7IERleGllIH0gZnJvbSBcIi4uL2NsYXNzZXMvZGV4aWUvZGV4aWVcIjtcbmltcG9ydCB7IFRhYmxlIH0gZnJvbSBcIi4uL3B1YmxpYy90eXBlcy90YWJsZVwiO1xuaW1wb3J0IHsgREJOQU1FU19EQiB9IGZyb20gXCIuLi9nbG9iYWxzL2NvbnN0YW50c1wiO1xuaW1wb3J0IHsgRGV4aWVET01EZXBlbmRlbmNpZXMgfSBmcm9tIFwiLi4vcHVibGljL3R5cGVzL2RleGllLWRvbS1kZXBlbmRlbmNpZXNcIjtcbmltcG9ydCB7IG5vcCB9IGZyb20gXCIuLi9mdW5jdGlvbnMvY2hhaW5pbmctZnVuY3Rpb25zXCI7XG5cbnR5cGUgSURCS2V5TmFtZXNWYXIgPSB0eXBlb2YgSURCS2V5UmFuZ2U7XG5cbmZ1bmN0aW9uIGdldERiTmFtZXNUYWJsZShpbmRleGVkREI6IElEQkZhY3RvcnksIElEQktleVJhbmdlOiBJREJLZXlOYW1lc1Zhcikge1xuICBsZXQgZGJOYW1lc0RCID0gaW5kZXhlZERCW1wiX2RiTmFtZXNEQlwiXTtcbiAgaWYgKCFkYk5hbWVzREIpIHtcbiAgICBkYk5hbWVzREIgPSBpbmRleGVkREJbXCJfZGJOYW1lc0RCXCJdID0gbmV3IERleGllKERCTkFNRVNfREIsIHtcbiAgICAgIGFkZG9uczogW10sXG4gICAgICBpbmRleGVkREIsXG4gICAgICBJREJLZXlSYW5nZSxcbiAgICB9KTtcbiAgICBkYk5hbWVzREIudmVyc2lvbigxKS5zdG9yZXMoeyBkYm5hbWVzOiBcIm5hbWVcIiB9KTtcbiAgfVxuICByZXR1cm4gZGJOYW1lc0RCLnRhYmxlKFwiZGJuYW1lc1wiKSBhcyBUYWJsZTx7IG5hbWU6IHN0cmluZyB9LCBzdHJpbmc+O1xufVxuXG5mdW5jdGlvbiBoYXNEYXRhYmFzZXNOYXRpdmUoaW5kZXhlZERCOiBJREJGYWN0b3J5KSB7XG4gIHJldHVybiBpbmRleGVkREIgJiYgdHlwZW9mIGluZGV4ZWREQi5kYXRhYmFzZXMgPT09IFwiZnVuY3Rpb25cIjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldERhdGFiYXNlTmFtZXMoe1xuICBpbmRleGVkREIsXG4gIElEQktleVJhbmdlLFxufTogRGV4aWVET01EZXBlbmRlbmNpZXMpIHtcbiAgcmV0dXJuIGhhc0RhdGFiYXNlc05hdGl2ZShpbmRleGVkREIpXG4gICAgPyBQcm9taXNlLnJlc29sdmUoaW5kZXhlZERCLmRhdGFiYXNlcygpKS50aGVuKChpbmZvcykgPT5cbiAgICAgICAgaW5mb3NcbiAgICAgICAgICAvLyBTZWxlY3QgbmFtZSBwcm9wIG9mIGluZm9zOlxuICAgICAgICAgIC5tYXAoKGluZm8pID0+IGluZm8ubmFtZSlcbiAgICAgICAgICAvLyBGaWx0ZXIgb3V0IERCTkFNRVNfREIgYXMgcHJldmlvdXMgRGV4aWUgb3IgYnJvd3NlciB2ZXJzaW9uIHdvdWxkIG5vdCBoYXZlIGluY2x1ZGVkIGl0IGluIHRoZSByZXN1bHQuXG4gICAgICAgICAgLmZpbHRlcigobmFtZSkgPT4gbmFtZSAhPT0gREJOQU1FU19EQilcbiAgICAgIClcbiAgICA6IGdldERiTmFtZXNUYWJsZShpbmRleGVkREIsIElEQktleVJhbmdlKS50b0NvbGxlY3Rpb24oKS5wcmltYXJ5S2V5cygpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX29uRGF0YWJhc2VDcmVhdGVkKFxuICB7IGluZGV4ZWREQiwgSURCS2V5UmFuZ2UgfTogRGV4aWVET01EZXBlbmRlbmNpZXMsXG4gIG5hbWU6IHN0cmluZ1xuKSB7XG4gICFoYXNEYXRhYmFzZXNOYXRpdmUoaW5kZXhlZERCKSAmJlxuICAgIG5hbWUgIT09IERCTkFNRVNfREIgJiZcbiAgICBnZXREYk5hbWVzVGFibGUoaW5kZXhlZERCLCBJREJLZXlSYW5nZSkucHV0KHtuYW1lfSkuY2F0Y2gobm9wKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9vbkRhdGFiYXNlRGVsZXRlZChcbiAgeyBpbmRleGVkREIsIElEQktleVJhbmdlIH06IERleGllRE9NRGVwZW5kZW5jaWVzLFxuICBuYW1lOiBzdHJpbmdcbikge1xuICAhaGFzRGF0YWJhc2VzTmF0aXZlKGluZGV4ZWREQikgJiZcbiAgICBuYW1lICE9PSBEQk5BTUVTX0RCICYmXG4gICAgZ2V0RGJOYW1lc1RhYmxlKGluZGV4ZWREQiwgSURCS2V5UmFuZ2UpLmRlbGV0ZShuYW1lKS5jYXRjaChub3ApO1xufVxuIiwgImltcG9ydCB7IG5ld1Njb3BlIH0gZnJvbSAnLi4vLi4vaGVscGVycy9wcm9taXNlJztcbmltcG9ydCB7IFBTRCB9IGZyb20gJy4uLy4uL2hlbHBlcnMvcHJvbWlzZSc7XG5cbmV4cG9ydCBmdW5jdGlvbiB2aXAgKGZuKSB7XG4gIC8vIFRvIGJlIHVzZWQgYnkgc3Vic2NyaWJlcnMgdG8gdGhlIG9uKCdyZWFkeScpIGV2ZW50LlxuICAvLyBUaGlzIHdpbGwgbGV0IGNhbGxlciB0aHJvdWdoIHRvIGFjY2VzcyBEQiBldmVuIHdoZW4gaXQgaXMgYmxvY2tlZCB3aGlsZSB0aGUgZGIucmVhZHkoKSBzdWJzY3JpYmVycyBhcmUgZmlyaW5nLlxuICAvLyBUaGlzIHdvdWxkIGhhdmUgd29ya2VkIGF1dG9tYXRpY2FsbHkgaWYgd2Ugd2VyZSBjZXJ0YWluIHRoYXQgdGhlIFByb3ZpZGVyIHdhcyB1c2luZyBEZXhpZS5Qcm9taXNlIGZvciBhbGwgYXN5bmNyb25pYyBvcGVyYXRpb25zLiBUaGUgcHJvbWlzZSBQU0RcbiAgLy8gZnJvbSB0aGUgcHJvdmlkZXIuY29ubmVjdCgpIGNhbGwgd291bGQgdGhlbiBiZSBkZXJpdmVkIGFsbCB0aGUgd2F5IHRvIHdoZW4gcHJvdmlkZXIgd291bGQgY2FsbCBsb2NhbERhdGFiYXNlLmFwcGx5Q2hhbmdlcygpLiBCdXQgc2luY2VcbiAgLy8gdGhlIHByb3ZpZGVyIG1vcmUgbGlrZWx5IGlzIHVzaW5nIG5vbi1wcm9taXNlIGFzeW5jIEFQSXMgb3Igb3RoZXIgdGhlbmFibGUgaW1wbGVtZW50YXRpb25zLCB3ZSBjYW5ub3QgYXNzdW1lIHRoYXQuXG4gIC8vIE5vdGUgdGhhdCB0aGlzIG1ldGhvZCBpcyBvbmx5IHVzZWZ1bCBmb3Igb24oJ3JlYWR5Jykgc3Vic2NyaWJlcnMgdGhhdCBpcyByZXR1cm5pbmcgYSBQcm9taXNlIGZyb20gdGhlIGV2ZW50LiBJZiBub3QgdXNpbmcgdmlwKClcbiAgLy8gdGhlIGRhdGFiYXNlIGNvdWxkIGRlYWRsb2NrIHNpbmNlIGl0IHdvbnQgb3BlbiB1bnRpbCB0aGUgcmV0dXJuZWQgUHJvbWlzZSBpcyByZXNvbHZlZCwgYW5kIGFueSBub24tVklQZWQgb3BlcmF0aW9uIHN0YXJ0ZWQgYnlcbiAgLy8gdGhlIGNhbGxlciB3aWxsIG5vdCByZXNvbHZlIHVudGlsIGRhdGFiYXNlIGlzIG9wZW5lZC5cbiAgcmV0dXJuIG5ld1Njb3BlKGZ1bmN0aW9uICgpIHtcbiAgICBQU0QubGV0VGhyb3VnaCA9IHRydWU7IC8vIE1ha2Ugc3VyZSB3ZSBhcmUgbGV0IHRocm91Z2ggaWYgc3RpbGwgYmxvY2tpbmcgZGIgZHVlIHRvIG9ucmVhZHkgaXMgZmlyaW5nLlxuICAgIHJldHVybiBmbigpO1xuICB9KTtcbn1cblxuIiwgIi8qKlxuICogV29yayBhcm91bmQgU2FmYXJpIDE0IEluZGV4ZWREQiBvcGVuIGJ1Zy5cbiAqXG4gKiBTYWZhcmkgaGFzIGEgaG9ycmlibGUgYnVnIHdoZXJlIElEQiByZXF1ZXN0cyBjYW4gaGFuZyB3aGlsZSB0aGUgYnJvd3NlciBpcyBzdGFydGluZyB1cC4gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTIyNjU0N1xuICogVGhlIG9ubHkgc29sdXRpb24gaXMgdG8ga2VlcCBudWRnaW5nIGl0IHVudGlsIGl0J3MgYXdha2UuXG4gKi9cbmZ1bmN0aW9uIGlkYlJlYWR5KCkge1xuICAgIHZhciBpc1NhZmFyaSA9ICFuYXZpZ2F0b3IudXNlckFnZW50RGF0YSAmJlxuICAgICAgICAvU2FmYXJpXFwvLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICYmXG4gICAgICAgICEvQ2hyb20oZXxpdW0pXFwvLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICAgIC8vIE5vIHBvaW50IHB1dHRpbmcgb3RoZXIgYnJvd3NlcnMgb3Igb2xkZXIgdmVyc2lvbnMgb2YgU2FmYXJpIHRocm91Z2ggdGhpcyBtZXNzLlxuICAgIGlmICghaXNTYWZhcmkgfHwgIWluZGV4ZWREQi5kYXRhYmFzZXMpXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB2YXIgaW50ZXJ2YWxJZDtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgdmFyIHRyeUlkYiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4ZWREQi5kYXRhYmFzZXMoKS5maW5hbGx5KHJlc29sdmUpOyB9O1xuICAgICAgICBpbnRlcnZhbElkID0gc2V0SW50ZXJ2YWwodHJ5SWRiLCAxMDApO1xuICAgICAgICB0cnlJZGIoKTtcbiAgICB9KS5maW5hbGx5KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWxJZCk7IH0pO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpZGJSZWFkeTtcbiIsICJpbXBvcnQgeyBEZXhpZSB9IGZyb20gJy4vZGV4aWUnO1xuaW1wb3J0ICogYXMgRGVidWcgZnJvbSAnLi4vLi4vaGVscGVycy9kZWJ1Zyc7XG5pbXBvcnQgeyByZWplY3Rpb24gfSBmcm9tICcuLi8uLi9oZWxwZXJzL3Byb21pc2UnO1xuaW1wb3J0IHsgZXhjZXB0aW9ucyB9IGZyb20gJy4uLy4uL2Vycm9ycyc7XG5pbXBvcnQgeyBldmVudFJlamVjdEhhbmRsZXIsIHByZXZlbnREZWZhdWx0IH0gZnJvbSAnLi4vLi4vZnVuY3Rpb25zL2V2ZW50LXdyYXBwZXJzJztcbmltcG9ydCBQcm9taXNlLCB7IHdyYXAgfSBmcm9tICcuLi8uLi9oZWxwZXJzL3Byb21pc2UnO1xuaW1wb3J0IHsgY29ubmVjdGlvbnMgfSBmcm9tICcuLi8uLi9nbG9iYWxzL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBydW5VcGdyYWRlcnMsIHJlYWRHbG9iYWxTY2hlbWEsIGFkanVzdFRvRXhpc3RpbmdJbmRleE5hbWVzLCB2ZXJpZnlJbnN0YWxsZWRTY2hlbWEgfSBmcm9tICcuLi92ZXJzaW9uL3NjaGVtYS1oZWxwZXJzJztcbmltcG9ydCB7IHNhZmFyaU11bHRpU3RvcmVGaXggfSBmcm9tICcuLi8uLi9mdW5jdGlvbnMvcXVpcmtzJztcbmltcG9ydCB7IF9vbkRhdGFiYXNlQ3JlYXRlZCB9IGZyb20gJy4uLy4uL2hlbHBlcnMvZGF0YWJhc2UtZW51bWVyYXRvcic7XG5pbXBvcnQgeyB2aXAgfSBmcm9tICcuL3ZpcCc7XG5pbXBvcnQgeyBwcm9taXNhYmxlQ2hhaW4sIG5vcCB9IGZyb20gJy4uLy4uL2Z1bmN0aW9ucy9jaGFpbmluZy1mdW5jdGlvbnMnO1xuaW1wb3J0IHsgZ2VuZXJhdGVNaWRkbGV3YXJlU3RhY2tzIH0gZnJvbSAnLi9nZW5lcmF0ZS1taWRkbGV3YXJlLXN0YWNrcyc7XG5pbXBvcnQgeyBzbGljZSB9IGZyb20gJy4uLy4uL2Z1bmN0aW9ucy91dGlscyc7XG5pbXBvcnQgc2FmYXJpMTRXb3JrYXJvdW5kIGZyb20gJ3NhZmFyaS0xNC1pZGItZml4JztcblxuZXhwb3J0IGZ1bmN0aW9uIGRleGllT3BlbiAoZGI6IERleGllKSB7XG4gIGNvbnN0IHN0YXRlID0gZGIuX3N0YXRlO1xuICBjb25zdCB7aW5kZXhlZERCfSA9IGRiLl9kZXBzO1xuICBpZiAoc3RhdGUuaXNCZWluZ09wZW5lZCB8fCBkYi5pZGJkYilcbiAgICAgIHJldHVybiBzdGF0ZS5kYlJlYWR5UHJvbWlzZS50aGVuPERleGllPigoKSA9PiBzdGF0ZS5kYk9wZW5FcnJvciA/XG4gICAgICAgIHJlamVjdGlvbiAoc3RhdGUuZGJPcGVuRXJyb3IpIDpcbiAgICAgICAgZGIpO1xuICBEZWJ1Zy5kZWJ1ZyAmJiAoc3RhdGUub3BlbkNhbmNlbGxlci5fc3RhY2tIb2xkZXIgPSBEZWJ1Zy5nZXRFcnJvcldpdGhTdGFjaygpKTsgLy8gTGV0IHN0YWNrcyBwb2ludCB0byB3aGVuIG9wZW4oKSB3YXMgY2FsbGVkIHJhdGhlciB0aGFuIHdoZXJlIG5ldyBEZXhpZSgpIHdhcyBjYWxsZWQuXG4gIHN0YXRlLmlzQmVpbmdPcGVuZWQgPSB0cnVlO1xuICBzdGF0ZS5kYk9wZW5FcnJvciA9IG51bGw7XG4gIHN0YXRlLm9wZW5Db21wbGV0ZSA9IGZhbHNlO1xuICBjb25zdCBvcGVuQ2FuY2VsbGVyID0gc3RhdGUub3BlbkNhbmNlbGxlcjtcblxuICBmdW5jdGlvbiB0aHJvd0lmQ2FuY2VsbGVkKCkge1xuICAgIC8vIElmIHN0YXRlLm9wZW5DYW5jZWxsZXIgb2JqZWN0IHJlZmVyZW5jZSBpcyByZXBsYWNlZCwgaXQgbWVhbnMgZGIuY2xvc2UoKSBoYXMgYmVlbiBjYWxsZWQsXG4gICAgLy8gbWVhbmluZyB0aGlzIG9wZW4gZmxvdyBzaG91bGQgYmUgY2FuY2VsbGVkLlxuICAgIGlmIChzdGF0ZS5vcGVuQ2FuY2VsbGVyICE9PSBvcGVuQ2FuY2VsbGVyKSB0aHJvdyBuZXcgZXhjZXB0aW9ucy5EYXRhYmFzZUNsb3NlZCgnZGIub3BlbigpIHdhcyBjYW5jZWxsZWQnKTtcbiAgfVxuICBcbiAgLy8gRnVuY3Rpb24gcG9pbnRlcnMgdG8gY2FsbCB3aGVuIHRoZSBjb3JlIG9wZW5pbmcgcHJvY2VzcyBjb21wbGV0ZXMuXG4gIGxldCByZXNvbHZlRGJSZWFkeSA9IHN0YXRlLmRiUmVhZHlSZXNvbHZlLFxuICAgICAgLy8gdXBncmFkZVRyYW5zYWN0aW9uIHRvIGFib3J0IG9uIGZhaWx1cmUuXG4gICAgICB1cGdyYWRlVHJhbnNhY3Rpb246IChJREJUcmFuc2FjdGlvbiB8IG51bGwpID0gbnVsbCxcbiAgICAgIHdhc0NyZWF0ZWQgPSBmYWxzZTtcblxuICBjb25zdCB0cnlPcGVuREIgPSAoKSA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgLy8gTXVsdGlwbHkgZGIudmVybm8gd2l0aCAxMCB3aWxsIGJlIG5lZWRlZCB0byB3b3JrYXJvdW5kIHVwZ3JhZGluZyBidWcgaW4gSUU6XG4gICAgLy8gSUUgZmFpbHMgd2hlbiBkZWxldGluZyBvYmplY3RTdG9yZSBhZnRlciByZWFkaW5nIGZyb20gaXQuXG4gICAgLy8gQSBmdXR1cmUgdmVyc2lvbiBvZiBEZXhpZS5qcyB3aWxsIHN0b3BvdmVyIGFuIGludGVybWVkaWF0ZSB2ZXJzaW9uIHRvIHdvcmthcm91bmQgdGhpcy5cbiAgICAvLyBBdCB0aGF0IHBvaW50LCB3ZSB3YW50IHRvIGJlIGJhY2t3YXJkIGNvbXBhdGlibGUuIENvdWxkIGhhdmUgYmVlbiBtdWx0aXBsaWVkIHdpdGggMiwgYnV0IGJ5IHVzaW5nIDEwLCBpdCBpcyBlYXNpZXIgdG8gbWFwIHRoZSBudW1iZXIgdG8gdGhlIHJlYWwgdmVyc2lvbiBudW1iZXIuXG4gICAgXG4gICAgdGhyb3dJZkNhbmNlbGxlZCgpO1xuICAgIC8vIElmIG5vIEFQSSwgdGhyb3chXG4gICAgaWYgKCFpbmRleGVkREIpIHRocm93IG5ldyBleGNlcHRpb25zLk1pc3NpbmdBUEkoKTtcbiAgICBjb25zdCBkYk5hbWUgPSBkYi5uYW1lO1xuICAgIFxuICAgIGNvbnN0IHJlcSA9IHN0YXRlLmF1dG9TY2hlbWEgP1xuICAgICAgaW5kZXhlZERCLm9wZW4oZGJOYW1lKSA6XG4gICAgICBpbmRleGVkREIub3BlbihkYk5hbWUsIE1hdGgucm91bmQoZGIudmVybm8gKiAxMCkpO1xuICAgIGlmICghcmVxKSB0aHJvdyBuZXcgZXhjZXB0aW9ucy5NaXNzaW5nQVBJKCk7IC8vIE1heSBoYXBwZW4gaW4gU2FmYXJpIHByaXZhdGUgbW9kZSwgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9kZmFobGFuZGVyL0RleGllLmpzL2lzc3Vlcy8xMzRcbiAgICByZXEub25lcnJvciA9IGV2ZW50UmVqZWN0SGFuZGxlcihyZWplY3QpO1xuICAgIHJlcS5vbmJsb2NrZWQgPSB3cmFwKGRiLl9maXJlT25CbG9ja2VkKTtcbiAgICByZXEub251cGdyYWRlbmVlZGVkID0gd3JhcCAoZSA9PiB7XG4gICAgICAgIHVwZ3JhZGVUcmFuc2FjdGlvbiA9IHJlcS50cmFuc2FjdGlvbjtcbiAgICAgICAgaWYgKHN0YXRlLmF1dG9TY2hlbWEgJiYgIWRiLl9vcHRpb25zLmFsbG93RW1wdHlEQikgeyAvLyBVbmxlc3MgYW4gYWRkb24gaGFzIHNwZWNpZmllZCBkYi5fYWxsb3dFbXB0eURCLCBsZXRzIG1ha2UgdGhlIGNhbGwgZmFpbC5cbiAgICAgICAgICAgIC8vIENhbGxlciBkaWQgbm90IHNwZWNpZnkgYSB2ZXJzaW9uIG9yIHNjaGVtYS4gRG9pbmcgdGhhdCBpcyBvbmx5IGFjY2VwdGFibGUgZm9yIG9wZW5pbmcgYWxyZWFkIGV4aXN0aW5nIGRhdGFiYXNlcy5cbiAgICAgICAgICAgIC8vIElmIG9udXBncmFkZW5lZWRlZCBpcyBjYWxsZWQgaXQgbWVhbnMgZGF0YWJhc2UgZGlkIG5vdCBleGlzdC4gUmVqZWN0IHRoZSBvcGVuKCkgcHJvbWlzZSBhbmQgbWFrZSBzdXJlIHRoYXQgd2VcbiAgICAgICAgICAgIC8vIGRvIG5vdCBjcmVhdGUgYSBuZXcgZGF0YWJhc2UgYnkgYWNjaWRlbnQgaGVyZS5cbiAgICAgICAgICAgIHJlcS5vbmVycm9yID0gcHJldmVudERlZmF1bHQ7IC8vIFByb2hpYml0IG9uYWJvcnQgZXJyb3IgZnJvbSBmaXJpbmcgYmVmb3JlIHdlJ3JlIGRvbmUhXG4gICAgICAgICAgICB1cGdyYWRlVHJhbnNhY3Rpb24uYWJvcnQoKTsgLy8gQWJvcnQgdHJhbnNhY3Rpb24gKHdvdWxkIGhvcGUgdGhhdCB0aGlzIHdvdWxkIG1ha2UgREIgZGlzYXBwZWFyIGJ1dCBpdCBkb2VzbnQuKVxuICAgICAgICAgICAgLy8gQ2xvc2UgZGF0YWJhc2UgYW5kIGRlbGV0ZSBpdC5cbiAgICAgICAgICAgIHJlcS5yZXN1bHQuY2xvc2UoKTtcbiAgICAgICAgICAgIGNvbnN0IGRlbHJlcSA9IGluZGV4ZWREQi5kZWxldGVEYXRhYmFzZShkYk5hbWUpOyAvLyBUaGUgdXBncmFkZSB0cmFuc2FjdGlvbiBpcyBhdG9taWMsIGFuZCBqYXZhc2NyaXB0IGlzIHNpbmdsZSB0aHJlYWRlZCAtIG1lYW5pbmcgdGhhdCB0aGVyZSBpcyBubyByaXNrIHRoYXQgd2UgZGVsZXRlIHNvbWVvbmUgZWxzZXMgZGF0YWJhc2UgaGVyZSFcbiAgICAgICAgICAgIGRlbHJlcS5vbnN1Y2Nlc3MgPSBkZWxyZXEub25lcnJvciA9IHdyYXAoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJlamVjdCAobmV3IGV4Y2VwdGlvbnMuTm9TdWNoRGF0YWJhc2UoYERhdGFiYXNlICR7ZGJOYW1lfSBkb2VzbnQgZXhpc3RgKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHVwZ3JhZGVUcmFuc2FjdGlvbi5vbmVycm9yID0gZXZlbnRSZWplY3RIYW5kbGVyKHJlamVjdCk7XG4gICAgICAgICAgICB2YXIgb2xkVmVyID0gZS5vbGRWZXJzaW9uID4gTWF0aC5wb3coMiwgNjIpID8gMCA6IGUub2xkVmVyc2lvbjsgLy8gU2FmYXJpIDggZml4LlxuICAgICAgICAgICAgd2FzQ3JlYXRlZCA9IG9sZFZlciA8IDE7XG4gICAgICAgICAgICBkYi5fbm92aXAuaWRiZGIgPSByZXEucmVzdWx0Oy8vIGRiLl9ub3ZpcCBpcyBiZWNhdXNlIGRiIGNhbiBiZSBhbiBPYmplY3QuY3JlYXRlKG9yaWdEYikuXG4gICAgICAgICAgICBydW5VcGdyYWRlcnMoZGIsIG9sZFZlciAvIDEwLCB1cGdyYWRlVHJhbnNhY3Rpb24sIHJlamVjdCk7XG4gICAgICAgIH1cbiAgICB9LCByZWplY3QpO1xuICAgIFxuICAgIHJlcS5vbnN1Y2Nlc3MgPSB3cmFwICgoKSA9PiB7XG4gICAgICAgIC8vIENvcmUgb3BlbmluZyBwcm9jZWR1cmUgY29tcGxldGUuIE5vdyBsZXQncyBqdXN0IHJlY29yZCBzb21lIHN0dWZmLlxuICAgICAgICB1cGdyYWRlVHJhbnNhY3Rpb24gPSBudWxsO1xuICAgICAgICBjb25zdCBpZGJkYiA9IGRiLl9ub3ZpcC5pZGJkYiA9IHJlcS5yZXN1bHQ7IC8vIGRiLl9ub3ZpcCBpcyBiZWNhdXNlIGRiIGNhbiBiZSBhbiBPYmplY3QuY3JlYXRlKG9yaWdEYikuXG5cbiAgICAgICAgY29uc3Qgb2JqZWN0U3RvcmVOYW1lcyA9IHNsaWNlKGlkYmRiLm9iamVjdFN0b3JlTmFtZXMpO1xuICAgICAgICBpZiAob2JqZWN0U3RvcmVOYW1lcy5sZW5ndGggPiAwKSB0cnkge1xuICAgICAgICAgIGNvbnN0IHRtcFRyYW5zID0gaWRiZGIudHJhbnNhY3Rpb24oc2FmYXJpTXVsdGlTdG9yZUZpeChvYmplY3RTdG9yZU5hbWVzKSwgJ3JlYWRvbmx5Jyk7XG4gICAgICAgICAgaWYgKHN0YXRlLmF1dG9TY2hlbWEpIHJlYWRHbG9iYWxTY2hlbWEoZGIsIGlkYmRiLCB0bXBUcmFucyk7XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGFkanVzdFRvRXhpc3RpbmdJbmRleE5hbWVzKGRiLCBkYi5fZGJTY2hlbWEsIHRtcFRyYW5zKTtcbiAgICAgICAgICAgICAgaWYgKCF2ZXJpZnlJbnN0YWxsZWRTY2hlbWEoZGIsIHRtcFRyYW5zKSkge1xuICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBEZXhpZSBTY2hlbWFEaWZmOiBTY2hlbWEgd2FzIGV4dGVuZGVkIHdpdGhvdXQgaW5jcmVhc2luZyB0aGUgbnVtYmVyIHBhc3NlZCB0byBkYi52ZXJzaW9uKCkuIFNvbWUgcXVlcmllcyBtYXkgZmFpbC5gKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBnZW5lcmF0ZU1pZGRsZXdhcmVTdGFja3MoZGIsIHRtcFRyYW5zKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIC8vIFNhZmFyaSA4IG1heSBiYWlsIG91dCBpZiA+IDEgc3RvcmUgbmFtZXMuIEhvd2V2ZXIsIHRoaXMgc2hvdWxkbnQgYmUgYSBzaG93c3RvcHBlci4gSXNzdWUgIzEyMC5cbiAgICAgICAgICAvLyBCVUdCVUc6IEl0IHdpbGwgYmFpbCBvdXQgYW55d2F5IGFzIG9mIERleGllIDMuXG4gICAgICAgICAgLy8gU2hvdWxkIHdlIHN1cHBvcnQgU2FmYXJpIDggYW55bW9yZT8gQmVsaWV2ZSBhbGxcbiAgICAgICAgICAvLyBEZXhpZSB1c2VycyB1c2UgdGhlIHNoaW0gZm9yIHRoYXQgcGxhdGZvcm0gYW55d2F5PyFcbiAgICAgICAgICAvLyBJZiByZW1vdmluZyBTYWZhcmkgOCBzdXBwb3J0LCBnbyBhaGVhZCBhbmQgcmVtb3ZlIHRoZSBzYWZhcmlNdWx0aVN0b3JlRml4KCkgZnVuY3Rpb25cbiAgICAgICAgICAvLyBhcyB3ZWxsIGFzIGFic3VyZCB1cGdyYWRlIHZlcnNpb24gcXVpcmsgZm9yIFNhZmFyaS5cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgY29ubmVjdGlvbnMucHVzaChkYik7IC8vIFVzZWQgZm9yIGVtdWxhdGluZyB2ZXJzaW9uY2hhbmdlIGV2ZW50IG9uIElFL0VkZ2UvU2FmYXJpLlxuICAgICAgICBcbiAgICAgICAgaWRiZGIub252ZXJzaW9uY2hhbmdlID0gd3JhcChldiA9PiB7XG4gICAgICAgICAgICBzdGF0ZS52Y0ZpcmVkID0gdHJ1ZTsgLy8gZGV0ZWN0IGltcGxlbWVudGF0aW9ucyB0aGF0IG5vdCBzdXBwb3J0IHZlcnNpb25jaGFuZ2UgKElFL0VkZ2UvU2FmYXJpKVxuICAgICAgICAgICAgZGIub24oXCJ2ZXJzaW9uY2hhbmdlXCIpLmZpcmUoZXYpO1xuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIGlkYmRiLm9uY2xvc2UgPSB3cmFwKGV2ID0+IHtcbiAgICAgICAgICAgIGRiLm9uKFwiY2xvc2VcIikuZmlyZShldik7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICh3YXNDcmVhdGVkKSBfb25EYXRhYmFzZUNyZWF0ZWQoZGIuX2RlcHMsIGRiTmFtZSk7XG5cbiAgICAgICAgcmVzb2x2ZSgpO1xuXG4gICAgfSwgcmVqZWN0KTtcbiAgfSkuY2F0Y2goZXJyID0+IHtcbiAgICBpZiAoZXJyICYmIGVyci5uYW1lID09PSAnVW5rbm93bkVycm9yJyAmJiBzdGF0ZS5QUjEzOThfbWF4TG9vcCA+IDApIHtcbiAgICAgIC8vIEJ1ZyBpbiBDaHJvbWUgYWZ0ZXIgY2xlYXJpbmcgc2l0ZSBkYXRhXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZGV4aWUvRGV4aWUuanMvaXNzdWVzLzU0MyNpc3N1ZWNvbW1lbnQtMTc5NTczNjY5NVxuICAgICAgc3RhdGUuUFIxMzk4X21heExvb3AtLTtcbiAgICAgIGNvbnNvbGUud2FybignRGV4aWU6IFdvcmthcm91bmQgZm9yIENocm9tZSBVbmtub3duRXJyb3Igb24gb3BlbigpJyk7XG4gICAgICByZXR1cm4gdHJ5T3BlbkRCKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnIpO1xuICAgIH1cbiAgfSk7XG4gIFxuICAvLyBzYWZhcmkxNFdvcmthcm91bmQgPSBXb3JrYXJvdW5kIGJ5IGpha2VhcmNoaWJhbGQgZm9yIG5ldyBuYXN0eSBidWcgaW4gc2FmYXJpIDE0LlxuICByZXR1cm4gUHJvbWlzZS5yYWNlKFtcbiAgICBvcGVuQ2FuY2VsbGVyLFxuICAgICh0eXBlb2YgbmF2aWdhdG9yID09PSAndW5kZWZpbmVkJyA/IFByb21pc2UucmVzb2x2ZSgpIDogc2FmYXJpMTRXb3JrYXJvdW5kKCkpLnRoZW4odHJ5T3BlbkRCKVxuICBdKS50aGVuKCgpID0+IHtcbiAgICAgIC8vIEJlZm9yZSBmaW5hbGx5IHJlc29sdmluZyB0aGUgZGJSZWFkeVByb21pc2UgYW5kIHRoaXMgcHJvbWlzZSxcbiAgICAgIC8vIGNhbGwgYW5kIGF3YWl0IGFsbCBvbigncmVhZHknKSBzdWJzY3JpYmVyczpcbiAgICAgIC8vIERleGllLnZpcCgpIG1ha2VzIHN1YnNjcmliZXJzIGFibGUgdG8gdXNlIHRoZSBkYXRhYmFzZSB3aGlsZSBiZWluZyBvcGVuZWQuXG4gICAgICAvLyBUaGlzIGlzIGEgbXVzdCBzaW5jZSB0aGVzZSBzdWJzY3JpYmVycyB0YWtlIHBhcnQgb2YgdGhlIG9wZW5pbmcgcHJvY2VkdXJlLlxuICAgICAgdGhyb3dJZkNhbmNlbGxlZCgpO1xuICAgICAgc3RhdGUub25SZWFkeUJlaW5nRmlyZWQgPSBbXTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmlwKCgpPT5kYi5vbi5yZWFkeS5maXJlKGRiLnZpcCkpKS50aGVuKGZ1bmN0aW9uIGZpcmVSZW1haW5kZXJzKCkge1xuICAgICAgICAgIGlmIChzdGF0ZS5vblJlYWR5QmVpbmdGaXJlZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIC8vIEluIGNhc2UgYWRkaXRpb25hbCBzdWJzY3JpYmVycyB0byBkYi5vbigncmVhZHknKSB3ZXJlIGFkZGVkIGR1cmluZyB0aGUgdGltZSBkYi5vbi5yZWFkeS5maXJlIHdhcyBleGVjdXRlZC5cbiAgICAgICAgICAgICAgbGV0IHJlbWFpbmRlcnMgPSBzdGF0ZS5vblJlYWR5QmVpbmdGaXJlZC5yZWR1Y2UocHJvbWlzYWJsZUNoYWluLCBub3ApO1xuICAgICAgICAgICAgICBzdGF0ZS5vblJlYWR5QmVpbmdGaXJlZCA9IFtdO1xuICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZpcCgoKT0+cmVtYWluZGVycyhkYi52aXApKSkudGhlbihmaXJlUmVtYWluZGVycylcbiAgICAgICAgICB9XG4gICAgICB9KTtcbiAgfSkuZmluYWxseSgoKT0+e1xuICAgICAgc3RhdGUub25SZWFkeUJlaW5nRmlyZWQgPSBudWxsO1xuICAgICAgc3RhdGUuaXNCZWluZ09wZW5lZCA9IGZhbHNlO1xuICB9KS50aGVuKCgpPT57XG4gICAgICAvLyBSZXNvbHZlIHRoZSBkYi5vcGVuKCkgd2l0aCB0aGUgZGIgaW5zdGFuY2UuXG4gICAgICByZXR1cm4gZGI7XG4gIH0pLmNhdGNoKGVyciA9PiB7XG4gICAgICBzdGF0ZS5kYk9wZW5FcnJvciA9IGVycjsgLy8gUmVjb3JkIHRoZSBlcnJvci4gSXQgd2lsbCBiZSB1c2VkIHRvIHJlamVjdCBmdXJ0aGVyIHByb21pc2VzIG9mIGRiIG9wZXJhdGlvbnMuXG4gICAgICB0cnkge1xuICAgICAgICAvLyBEaWQgd2UgZmFpbCB3aXRoaW4gb251cGdyYWRlbmVlZGVkPyBNYWtlIHN1cmUgdG8gYWJvcnQgdGhlIHVwZ3JhZGUgdHJhbnNhY3Rpb24gc28gaXQgZG9lc250IGNvbW1pdC5cbiAgICAgICAgdXBncmFkZVRyYW5zYWN0aW9uICYmIHVwZ3JhZGVUcmFuc2FjdGlvbi5hYm9ydCgpO1xuICAgICAgfSBjYXRjaCB7IH1cbiAgICAgIGlmIChvcGVuQ2FuY2VsbGVyID09PSBzdGF0ZS5vcGVuQ2FuY2VsbGVyKSB7XG4gICAgICAgIC8vIFN0aWxsIGluIHRoZSBzYW1lIG9wZW4gZmxvdyAtIFRoZSBlcnJvciByZWFzb24gd2FzIG5vdCBkdWUgdG8gZXh0ZXJuYWwgY2FsbCB0byBkYi5jbG9zZSgpLlxuICAgICAgICAvLyBNYWtlIHN1cmUgdG8gY2FsbCBkYi5jbG9zZSgpIHRvIGZpbmFsaXplIHJlc291cmNlcy5cbiAgICAgICAgZGIuX2Nsb3NlKCk7IC8vIENsb3NlcyBhbmQgcmVzZXRzIGlkYmRiLCByZW1vdmVzIGNvbm5lY3Rpb25zLCByZXNldHMgZGJSZWFkeVByb21pc2UgYW5kIG9wZW5DYW5jZWxsZXIgc28gdGhhdCBhIGxhdGVyIGRiLm9wZW4oKSBpcyBmcmVzaC5cbiAgICAgIH1cbiAgICAgIHJldHVybiByZWplY3Rpb24gKGVycik7XG4gIH0pLmZpbmFsbHkoKCk9PntcbiAgICAgIHN0YXRlLm9wZW5Db21wbGV0ZSA9IHRydWU7XG4gICAgICByZXNvbHZlRGJSZWFkeSgpOyAvLyBkYlJlYWR5UHJvbWlzZSBpcyByZXNvbHZlZCBubyBtYXR0ZXIgaWYgb3BlbigpIHJlamVjdHMgb3IgcmVzb2x2ZWQuIEl0J3MganVzdCB0byB3YWtlIHVwIHdhaXRlcnMuXG4gIH0pO1xufVxuIiwgImltcG9ydCB7IGlzQXJyYXkgfSBmcm9tICcuLi9mdW5jdGlvbnMvdXRpbHMnO1xuXG5leHBvcnQgZnVuY3Rpb24gYXdhaXRJdGVyYXRvciAoaXRlcmF0b3I6IEl0ZXJhdG9yPGFueT4pIHtcbiAgdmFyIGNhbGxOZXh0ID0gcmVzdWx0ID0+IGl0ZXJhdG9yLm5leHQocmVzdWx0KSxcbiAgICAgIGRvVGhyb3cgPSBlcnJvciA9PiBpdGVyYXRvci50aHJvdyhlcnJvciksXG4gICAgICBvblN1Y2Nlc3MgPSBzdGVwKGNhbGxOZXh0KSxcbiAgICAgIG9uRXJyb3IgPSBzdGVwKGRvVGhyb3cpO1xuXG4gIGZ1bmN0aW9uIHN0ZXAoZ2V0TmV4dDogKGFueSk9PmFueSkge1xuICAgICAgcmV0dXJuICh2YWw/KSA9PiB7XG4gICAgICAgICAgdmFyIG5leHQgPSBnZXROZXh0KHZhbCksXG4gICAgICAgICAgICAgIHZhbHVlID0gbmV4dC52YWx1ZTtcblxuICAgICAgICAgIHJldHVybiBuZXh0LmRvbmUgPyB2YWx1ZSA6XG4gICAgICAgICAgICAgICghdmFsdWUgfHwgdHlwZW9mIHZhbHVlLnRoZW4gIT09ICdmdW5jdGlvbicgP1xuICAgICAgICAgICAgICAgICAgaXNBcnJheSh2YWx1ZSkgPyBQcm9taXNlLmFsbCh2YWx1ZSkudGhlbihvblN1Y2Nlc3MsIG9uRXJyb3IpIDogb25TdWNjZXNzKHZhbHVlKSA6XG4gICAgICAgICAgICAgICAgICB2YWx1ZS50aGVuKG9uU3VjY2Vzcywgb25FcnJvcikpO1xuICAgICAgfTtcbiAgfVxuXG4gIHJldHVybiBzdGVwKGNhbGxOZXh0KSgpO1xufVxuIiwgImltcG9ydCB7IFRyYW5zYWN0aW9uTW9kZSB9IGZyb20gJy4uLy4uL3B1YmxpYy90eXBlcy90cmFuc2FjdGlvbi1tb2RlJztcbmltcG9ydCB7IGVycm5hbWVzLCBleGNlcHRpb25zIH0gZnJvbSAnLi4vLi4vZXJyb3JzJztcbmltcG9ydCB7IGZsYXR0ZW4sIGlzQXN5bmNGdW5jdGlvbiB9IGZyb20gJy4uLy4uL2Z1bmN0aW9ucy91dGlscyc7XG5pbXBvcnQgeyBEZXhpZSB9IGZyb20gJy4vZGV4aWUnO1xuaW1wb3J0IHsgVHJhbnNhY3Rpb24gfSBmcm9tICcuLi90cmFuc2FjdGlvbic7XG5pbXBvcnQgeyBhd2FpdEl0ZXJhdG9yIH0gZnJvbSAnLi4vLi4vaGVscGVycy95aWVsZC1zdXBwb3J0JztcbmltcG9ydCBQcm9taXNlLCB7XG4gIFBTRCxcbiAgTmF0aXZlUHJvbWlzZSxcbiAgZGVjcmVtZW50RXhwZWN0ZWRBd2FpdHMsXG4gIHJlamVjdGlvbixcbiAgaW5jcmVtZW50RXhwZWN0ZWRBd2FpdHNcbn0gZnJvbSAnLi4vLi4vaGVscGVycy9wcm9taXNlJztcblxuZXhwb3J0IGZ1bmN0aW9uIGV4dHJhY3RUcmFuc2FjdGlvbkFyZ3MobW9kZTogVHJhbnNhY3Rpb25Nb2RlLCBfdGFibGVBcmdzXywgc2NvcGVGdW5jKSB7XG4gIC8vIExldCB0YWJsZSBhcmd1bWVudHMgYmUgYWxsIGFyZ3VtZW50cyBiZXR3ZWVuIG1vZGUgYW5kIGxhc3QgYXJndW1lbnQuXG4gIHZhciBpID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgaWYgKGkgPCAyKSB0aHJvdyBuZXcgZXhjZXB0aW9ucy5JbnZhbGlkQXJndW1lbnQoXCJUb28gZmV3IGFyZ3VtZW50c1wiKTtcbiAgLy8gUHJldmVudCBvcHRpbXphdGlvbiBraWxsZXIgKGh0dHBzOi8vZ2l0aHViLmNvbS9wZXRrYWFudG9ub3YvYmx1ZWJpcmQvd2lraS9PcHRpbWl6YXRpb24ta2lsbGVycyMzMi1sZWFraW5nLWFyZ3VtZW50cylcbiAgLy8gYW5kIGNsb25lIGFyZ3VtZW50cyBleGNlcHQgdGhlIGZpcnN0IG9uZSBpbnRvIGxvY2FsIHZhciAnYXJncycuXG4gIHZhciBhcmdzID0gbmV3IEFycmF5KGkgLSAxKTtcbiAgd2hpbGUgKC0taSkgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gIC8vIExldCBzY29wZUZ1bmMgYmUgdGhlIGxhc3QgYXJndW1lbnQgYW5kIHBvcCBpdCBzbyB0aGF0IGFyZ3Mgbm93IG9ubHkgY29udGFpbiB0aGUgdGFibGUgYXJndW1lbnRzLlxuICBzY29wZUZ1bmMgPSBhcmdzLnBvcCgpO1xuICB2YXIgdGFibGVzID0gZmxhdHRlbihhcmdzKTsgLy8gU3VwcG9ydCB1c2luZyBhcnJheSBhcyBtaWRkbGUgYXJndW1lbnQsIG9yIGEgbWl4IG9mIGFycmF5cyBhbmQgbm9uLWFycmF5cy5cbiAgcmV0dXJuIFttb2RlLCB0YWJsZXMsIHNjb3BlRnVuY107XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlbnRlclRyYW5zYWN0aW9uU2NvcGUoXG4gIGRiOiBEZXhpZSxcbiAgbW9kZTogSURCVHJhbnNhY3Rpb25Nb2RlLFxuICBzdG9yZU5hbWVzOiBzdHJpbmdbXSxcbiAgcGFyZW50VHJhbnNhY3Rpb246IFRyYW5zYWN0aW9uIHwgdW5kZWZpbmVkLFxuICBzY29wZUZ1bmM6ICgpPT5Qcm9taXNlTGlrZTxhbnk+IHwgYW55XG4pIHtcbiAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuICAgIC8vIEtlZXAgYSBwb2ludGVyIHRvIGxhc3Qgbm9uLXRyYW5zYWN0aW9uYWwgUFNEIHRvIHVzZSBpZiBzb21lb25lIGNhbGxzIERleGllLmlnbm9yZVRyYW5zYWN0aW9uKCkuXG4gICAgY29uc3QgdHJhbnNsZXNzID0gUFNELnRyYW5zbGVzcyB8fCBQU0Q7XG4gICAgLy8gT3VyIHRyYW5zYWN0aW9uLlxuICAgIC8vcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb25zdCB0cmFucyA9IGRiLl9jcmVhdGVUcmFuc2FjdGlvbihtb2RlLCBzdG9yZU5hbWVzLCBkYi5fZGJTY2hlbWEsIHBhcmVudFRyYW5zYWN0aW9uKTtcbiAgICAvLyBMZXQgdGhlIHRyYW5zYWN0aW9uIGluc3RhbmNlIGJlIHBhcnQgb2YgYSBQcm9taXNlLXNwZWNpZmljIGRhdGEgKFBTRCkgdmFsdWUuXG4gICAgY29uc3Qgem9uZVByb3BzID0ge1xuICAgICAgdHJhbnM6IHRyYW5zLFxuICAgICAgdHJhbnNsZXNzOiB0cmFuc2xlc3NcbiAgICB9O1xuXG4gICAgaWYgKHBhcmVudFRyYW5zYWN0aW9uKSB7XG4gICAgICAvLyBFbXVsYXRlIHRyYW5zYWN0aW9uIGNvbW1pdCBhd2FyZW5lc3MgZm9yIGlubmVyIHRyYW5zYWN0aW9uIChtdXN0ICdjb21taXQnIHdoZW4gdGhlIGlubmVyIHRyYW5zYWN0aW9uIGhhcyBubyBtb3JlIG9wZXJhdGlvbnMgb25nb2luZylcbiAgICAgIHRyYW5zLmlkYnRyYW5zID0gcGFyZW50VHJhbnNhY3Rpb24uaWRidHJhbnM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRyYW5zLmNyZWF0ZSgpOyAvLyBDcmVhdGUgdGhlIG5hdGl2ZSB0cmFuc2FjdGlvbiBzbyB0aGF0IGNvbXBsZXRlKCkgb3IgZXJyb3IoKSB3aWxsIHRyaWdnZXIgZXZlbiBpZiBubyBvcGVyYXRpb24gaXMgbWFkZSB1cG9uIGl0LlxuICAgICAgICBkYi5fc3RhdGUuUFIxMzk4X21heExvb3AgPSAzO1xuICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgaWYgKGV4Lm5hbWUgPT09IGVycm5hbWVzLkludmFsaWRTdGF0ZSAmJiBkYi5pc09wZW4oKSAmJiAtLWRiLl9zdGF0ZS5QUjEzOThfbWF4TG9vcCA+IDApIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ0RleGllOiBOZWVkIHRvIHJlb3BlbiBkYicpO1xuICAgICAgICAgIGRiLl9jbG9zZSgpO1xuICAgICAgICAgIHJldHVybiBkYi5vcGVuKCkudGhlbigoKSA9PiBlbnRlclRyYW5zYWN0aW9uU2NvcGUoXG4gICAgICAgICAgICBkYixcbiAgICAgICAgICAgIG1vZGUsXG4gICAgICAgICAgICBzdG9yZU5hbWVzLFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIHNjb3BlRnVuY1xuICAgICAgICAgICkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZWplY3Rpb24oZXgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFN1cHBvcnQgZm9yIG5hdGl2ZSBhc3luYyBhd2FpdC5cbiAgICBjb25zdCBzY29wZUZ1bmNJc0FzeW5jID0gaXNBc3luY0Z1bmN0aW9uKHNjb3BlRnVuYyk7XG4gICAgaWYgKHNjb3BlRnVuY0lzQXN5bmMpIHtcbiAgICAgIGluY3JlbWVudEV4cGVjdGVkQXdhaXRzKCk7XG4gICAgfVxuXG4gICAgbGV0IHJldHVyblZhbHVlO1xuICAgIGNvbnN0IHByb21pc2VGb2xsb3dlZCA9IFByb21pc2UuZm9sbG93KCgpID0+IHtcbiAgICAgIC8vIEZpbmFsbHksIGNhbGwgdGhlIHNjb3BlIGZ1bmN0aW9uIHdpdGggb3VyIHRhYmxlIGFuZCB0cmFuc2FjdGlvbiBhcmd1bWVudHMuXG4gICAgICByZXR1cm5WYWx1ZSA9IHNjb3BlRnVuYy5jYWxsKHRyYW5zLCB0cmFucyk7XG4gICAgICBpZiAocmV0dXJuVmFsdWUpIHtcbiAgICAgICAgaWYgKHNjb3BlRnVuY0lzQXN5bmMpIHtcbiAgICAgICAgICAvLyBzY29wZUZ1bmMgaXMgYSBuYXRpdmUgYXN5bmMgZnVuY3Rpb24gLSB3ZSBrbm93IGZvciBzdXJlIHJldHVyblZhbHVlIGlzIG5hdGl2ZSBwcm9taXNlLlxuICAgICAgICAgIHZhciBkZWNyZW1lbnRvciA9IGRlY3JlbWVudEV4cGVjdGVkQXdhaXRzLmJpbmQobnVsbCwgbnVsbCk7XG4gICAgICAgICAgcmV0dXJuVmFsdWUudGhlbihkZWNyZW1lbnRvciwgZGVjcmVtZW50b3IpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiByZXR1cm5WYWx1ZS5uZXh0ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiByZXR1cm5WYWx1ZS50aHJvdyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIC8vIHNjb3BlRnVuYyByZXR1cm5lZCBhbiBpdGVyYXRvciB3aXRoIHRocm93LXN1cHBvcnQuIEhhbmRsZSB5aWVsZCBhcyBhd2FpdC5cbiAgICAgICAgICByZXR1cm5WYWx1ZSA9IGF3YWl0SXRlcmF0b3IocmV0dXJuVmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgem9uZVByb3BzKTtcbiAgICByZXR1cm4gKHJldHVyblZhbHVlICYmIHR5cGVvZiByZXR1cm5WYWx1ZS50aGVuID09PSAnZnVuY3Rpb24nID9cbiAgICAgIC8vIFByb21pc2UgcmV0dXJuZWQuIFVzZXIgdXNlcyBwcm9taXNlLXN0eWxlIHRyYW5zYWN0aW9ucy5cbiAgICAgIFByb21pc2UucmVzb2x2ZShyZXR1cm5WYWx1ZSkudGhlbih4ID0+IHRyYW5zLmFjdGl2ZSA/XG4gICAgICAgIHggLy8gVHJhbnNhY3Rpb24gc3RpbGwgYWN0aXZlLiBDb250aW51ZS5cbiAgICAgICAgOiByZWplY3Rpb24obmV3IGV4Y2VwdGlvbnMuUHJlbWF0dXJlQ29tbWl0KFxuICAgICAgICAgIFwiVHJhbnNhY3Rpb24gY29tbWl0dGVkIHRvbyBlYXJseS4gU2VlIGh0dHA6Ly9iaXQubHkvMmtkY2tNblwiKSkpXG4gICAgICAvLyBObyBwcm9taXNlIHJldHVybmVkLiBXYWl0IGZvciBhbGwgb3V0c3RhbmRpbmcgcHJvbWlzZXMgYmVmb3JlIGNvbnRpbnVpbmcuIFxuICAgICAgOiBwcm9taXNlRm9sbG93ZWQudGhlbigoKSA9PiByZXR1cm5WYWx1ZSlcbiAgICApLnRoZW4oeCA9PiB7XG4gICAgICAvLyBzdWIgdHJhbnNhY3Rpb25zIGRvbid0IHJlYWN0IHRvIGlkYnRyYW5zLm9uY29tcGxldGUuIFdlIG11c3QgdHJpZ2dlciBhIGNvbXBsZXRpb246XG4gICAgICBpZiAocGFyZW50VHJhbnNhY3Rpb24pIHRyYW5zLl9yZXNvbHZlKCk7XG4gICAgICAvLyB3YWl0IGZvciB0cmFucy5fY29tcGxldGlvblxuICAgICAgLy8gKGlmIHJvb3QgdHJhbnNhY3Rpb24sIHRoaXMgbWVhbnMgJ2NvbXBsZXRlJyBldmVudC4gSWYgc3ViLXRyYW5zYWN0aW9uLCB3ZSd2ZSBqdXN0IGZpcmVkIGl0IG91cnNlbHZlcylcbiAgICAgIHJldHVybiB0cmFucy5fY29tcGxldGlvbi50aGVuKCgpID0+IHgpO1xuICAgIH0pLmNhdGNoKGUgPT4ge1xuICAgICAgdHJhbnMuX3JlamVjdChlKTsgLy8gWWVzLCBhYm92ZSB0aGVuLWhhbmRsZXIgd2VyZSBtYXliZSBub3QgY2FsbGVkIGJlY2F1c2Ugb2YgYW4gdW5oYW5kbGVkIHJlamVjdGlvbiBpbiBzY29wZUZ1bmMhXG4gICAgICByZXR1cm4gcmVqZWN0aW9uKGUpO1xuICAgIH0pO1xuICB9KTtcbn1cbiIsICJpbXBvcnQge1xuICBEQkNvcmUsXG4gIERCQ29yZUluZGV4LFxuICBEQkNvcmVLZXlSYW5nZSxcbiAgREJDb3JlUXVlcnlSZXF1ZXN0LFxuICBEQkNvcmVSYW5nZVR5cGUsXG4gIERCQ29yZU9wZW5DdXJzb3JSZXF1ZXN0LFxuICBEQkNvcmVDb3VudFJlcXVlc3QsXG4gIERCQ29yZUN1cnNvcixcbiAgREJDb3JlVGFibGUsXG59IGZyb20gXCIuLi9wdWJsaWMvdHlwZXMvZGJjb3JlXCI7XG5pbXBvcnQgeyBpc0FycmF5IH0gZnJvbSAnLi4vZnVuY3Rpb25zL3V0aWxzJztcbmltcG9ydCB7IGdldEtleUV4dHJhY3RvciB9IGZyb20gJy4vZ2V0LWtleS1leHRyYWN0b3InO1xuaW1wb3J0IHsgZ2V0S2V5UGF0aEFsaWFzIH0gZnJvbSAnLi9kYmNvcmUtaW5kZXhlZGRiJztcbmltcG9ydCB7IE1pZGRsZXdhcmUgfSBmcm9tICcuLi9wdWJsaWMvdHlwZXMvbWlkZGxld2FyZSc7XG5cbmludGVyZmFjZSBWaXJ0dWFsSW5kZXggZXh0ZW5kcyBEQkNvcmVJbmRleCB7XG4gIC8qKiBUcnVlIGlmIHRoaXMgaW5kZXggaXMgdmlydHVhbCwgaS5lLiByZXByZXNlbnRzIGEgY29tcG91bmQgaW5kZXggaW50ZXJuYWxseSxcbiAgICogYnV0IG1ha2VzIGl0IGFjdCBhcyBhcyBoYXZpbmcgYSBzdWJzZXQgb2YgaXRzIGtleVBhdGhzLlxuICAgKi9cbiAgaXNWaXJ0dWFsOiBib29sZWFuO1xuXG4gIC8qKiBOdW1iZXIgb2Yga2V5cGF0aHMgdGhhdCB0aGlzIGluZGV4IGNvbXByaXNlcy4gQ2FuIGJlIDAuLk4uXG4gICAqIE5vdGU6IFRoaXMgaXMgdGhlIGxlbmd0aCBvZiB0aGUgKnZpcnR1YWwgaW5kZXgqLCBub3QgdGhlIHJlYWwgaW5kZXguXG4gICAqL1xuICBrZXlMZW5ndGg6IG51bWJlcjtcblxuICAvKiogTnVtYmVyIG9mIHBvcHBlZCBrZXlwYXRocyBmcm9tIHRoZSByZWFsIGluZGV4LlxuICAgKi9cbiAga2V5VGFpbDogbnVtYmVyO1xufVxuXG4vLyBNb3ZlIGludG8gc29tZSB1dGlsOlxuZXhwb3J0IGZ1bmN0aW9uIHBhZCAoYTogYW55IHwgYW55W10sIHZhbHVlOiBhbnksIGNvdW50OiBudW1iZXIpIHtcbiAgY29uc3QgcmVzdWx0ID0gaXNBcnJheShhKSA/IGEuc2xpY2UoKSA6IFthXTtcbiAgZm9yIChsZXQgaT0wOyBpPGNvdW50OyArK2kpIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlVmlydHVhbEluZGV4TWlkZGxld2FyZSAoZG93bjogREJDb3JlKSA6IERCQ29yZSB7XG4gIHJldHVybiB7XG4gICAgLi4uZG93bixcbiAgICB0YWJsZSh0YWJsZU5hbWU6IHN0cmluZykge1xuICAgICAgY29uc3QgdGFibGUgPSBkb3duLnRhYmxlKHRhYmxlTmFtZSk7XG4gICAgICBjb25zdCB7c2NoZW1hfSA9IHRhYmxlO1xuICAgICAgY29uc3QgaW5kZXhMb29rdXA6IHtbaW5kZXhBbGlhczogc3RyaW5nXTogVmlydHVhbEluZGV4W119ID0ge307XG4gICAgICBjb25zdCBhbGxWaXJ0dWFsSW5kZXhlczogVmlydHVhbEluZGV4W10gPSBbXTtcblxuICAgICAgZnVuY3Rpb24gYWRkVmlydHVhbEluZGV4ZXMgKGtleVBhdGg6IG51bGwgfCBzdHJpbmcgfCBzdHJpbmdbXSwga2V5VGFpbDogbnVtYmVyLCBsb3dMZXZlbEluZGV4OiBEQkNvcmVJbmRleCk6IFZpcnR1YWxJbmRleCB7XG4gICAgICAgIGNvbnN0IGtleVBhdGhBbGlhcyA9IGdldEtleVBhdGhBbGlhcyhrZXlQYXRoKTtcbiAgICAgICAgY29uc3QgaW5kZXhMaXN0ID0gKGluZGV4TG9va3VwW2tleVBhdGhBbGlhc10gPSBpbmRleExvb2t1cFtrZXlQYXRoQWxpYXNdIHx8IFtdKTtcbiAgICAgICAgY29uc3Qga2V5TGVuZ3RoID0ga2V5UGF0aCA9PSBudWxsID8gMDogdHlwZW9mIGtleVBhdGggPT09ICdzdHJpbmcnID8gMSA6IGtleVBhdGgubGVuZ3RoO1xuICAgICAgICBjb25zdCBpc1ZpcnR1YWwgPSBrZXlUYWlsID4gMDtcbiAgICAgICAgY29uc3QgdmlydHVhbEluZGV4ID0ge1xuICAgICAgICAgIC4uLmxvd0xldmVsSW5kZXgsXG4gICAgICAgICAgaXNWaXJ0dWFsLFxuICAgICAgICAgIGtleVRhaWwsXG4gICAgICAgICAga2V5TGVuZ3RoLFxuICAgICAgICAgIGV4dHJhY3RLZXk6IGdldEtleUV4dHJhY3RvcihrZXlQYXRoKSxcbiAgICAgICAgICB1bmlxdWU6ICFpc1ZpcnR1YWwgJiYgbG93TGV2ZWxJbmRleC51bmlxdWVcbiAgICAgICAgfTtcbiAgICAgICAgaW5kZXhMaXN0LnB1c2godmlydHVhbEluZGV4KTtcbiAgICAgICAgaWYgKCF2aXJ0dWFsSW5kZXguaXNQcmltYXJ5S2V5KSB7XG4gICAgICAgICAgYWxsVmlydHVhbEluZGV4ZXMucHVzaCh2aXJ0dWFsSW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChrZXlMZW5ndGggPiAxKSB7XG4gICAgICAgICAgY29uc3QgdmlydHVhbEtleVBhdGggPSBrZXlMZW5ndGggPT09IDIgP1xuICAgICAgICAgICAga2V5UGF0aFswXSA6IC8vIFRoaXMgaXMgYSBjb21wb3VuZCBbYSwgYl0uIEFkZCBhIHZpcnR1YWwgbm9ybWFsIGluZGV4IGEuXG4gICAgICAgICAgICBrZXlQYXRoLnNsaWNlKDAsIGtleUxlbmd0aCAtIDEpOyAvLyBUaGlzIGlzIGNvbXBvdW5kIFthLGIsY10uIEFkZCB2aXJ0dWFsIGNvbXBvdW5kIFthLGJdLlxuICAgICAgICAgIGFkZFZpcnR1YWxJbmRleGVzKHZpcnR1YWxLZXlQYXRoLCBrZXlUYWlsICsgMSwgbG93TGV2ZWxJbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgaW5kZXhMaXN0LnNvcnQoKGEsYikgPT4gYS5rZXlUYWlsIC0gYi5rZXlUYWlsKTsgLy8gU2hvcnRlc3Qga2V5VGFpbCBpcyB0aGUgYmVzdCBvbmUgKHJlcHJlc2VudHMgcmVhbCBpbmRleClcbiAgICAgICAgcmV0dXJuIHZpcnR1YWxJbmRleDtcbiAgICAgIH1cbiAgICBcbiAgICAgIGNvbnN0IHByaW1hcnlLZXkgPSBhZGRWaXJ0dWFsSW5kZXhlcyhzY2hlbWEucHJpbWFyeUtleS5rZXlQYXRoLCAwLCBzY2hlbWEucHJpbWFyeUtleSk7XG4gICAgICBpbmRleExvb2t1cFtcIjppZFwiXSA9IFtwcmltYXJ5S2V5XTtcbiAgICAgIGZvciAoY29uc3QgaW5kZXggb2Ygc2NoZW1hLmluZGV4ZXMpIHtcbiAgICAgICAgYWRkVmlydHVhbEluZGV4ZXMoaW5kZXgua2V5UGF0aCwgMCwgaW5kZXgpO1xuICAgICAgfVxuICAgIFxuICAgICAgZnVuY3Rpb24gZmluZEJlc3RJbmRleChrZXlQYXRoOiBudWxsIHwgc3RyaW5nIHwgc3RyaW5nW10pOiBWaXJ0dWFsSW5kZXgge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBpbmRleExvb2t1cFtnZXRLZXlQYXRoQWxpYXMoa2V5UGF0aCldO1xuICAgICAgICByZXR1cm4gcmVzdWx0ICYmIHJlc3VsdFswXTtcbiAgICAgIH1cbiAgICBcbiAgICAgIGZ1bmN0aW9uIHRyYW5zbGF0ZVJhbmdlIChyYW5nZTogREJDb3JlS2V5UmFuZ2UsIGtleVRhaWw6IG51bWJlcik6IERCQ29yZUtleVJhbmdlIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiByYW5nZS50eXBlID09PSBEQkNvcmVSYW5nZVR5cGUuRXF1YWwgP1xuICAgICAgICAgICAgREJDb3JlUmFuZ2VUeXBlLlJhbmdlIDpcbiAgICAgICAgICAgIHJhbmdlLnR5cGUsXG4gICAgICAgICAgbG93ZXI6IHBhZChyYW5nZS5sb3dlciwgcmFuZ2UubG93ZXJPcGVuID8gZG93bi5NQVhfS0VZIDogZG93bi5NSU5fS0VZLCBrZXlUYWlsKSxcbiAgICAgICAgICBsb3dlck9wZW46IHRydWUsIC8vIGRvZXNuJ3QgbWF0dGVyIHRydWUgb3IgZmFsc2VcbiAgICAgICAgICB1cHBlcjogcGFkKHJhbmdlLnVwcGVyLCByYW5nZS51cHBlck9wZW4gPyBkb3duLk1JTl9LRVkgOiBkb3duLk1BWF9LRVksIGtleVRhaWwpLFxuICAgICAgICAgIHVwcGVyT3BlbjogdHJ1ZSAvLyBkb2Vzbid0IG1hdHRlciB0cnVlIG9yIGZhbHNlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgXG4gICAgICBmdW5jdGlvbiB0cmFuc2xhdGVSZXF1ZXN0IChyZXE6IERCQ29yZVF1ZXJ5UmVxdWVzdCk6IERCQ29yZVF1ZXJ5UmVxdWVzdDtcbiAgICAgIGZ1bmN0aW9uIHRyYW5zbGF0ZVJlcXVlc3QgKHJlcTogREJDb3JlT3BlbkN1cnNvclJlcXVlc3QpOiBEQkNvcmVPcGVuQ3Vyc29yUmVxdWVzdDtcbiAgICAgIGZ1bmN0aW9uIHRyYW5zbGF0ZVJlcXVlc3QgKHJlcTogREJDb3JlQ291bnRSZXF1ZXN0KTogREJDb3JlQ291bnRSZXF1ZXN0IHtcbiAgICAgICAgY29uc3QgaW5kZXggPSByZXEucXVlcnkuaW5kZXggYXMgVmlydHVhbEluZGV4O1xuICAgICAgICByZXR1cm4gaW5kZXguaXNWaXJ0dWFsID8ge1xuICAgICAgICAgIC4uLnJlcSxcbiAgICAgICAgICBxdWVyeToge1xuICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICByYW5nZTogdHJhbnNsYXRlUmFuZ2UocmVxLnF1ZXJ5LnJhbmdlLCBpbmRleC5rZXlUYWlsKVxuICAgICAgICAgIH1cbiAgICAgICAgfSA6IHJlcTtcbiAgICAgIH1cbiAgICBcbiAgICAgIGNvbnN0IHJlc3VsdDogREJDb3JlVGFibGUgPSB7XG4gICAgICAgIC4uLnRhYmxlLFxuICAgICAgICBzY2hlbWE6IHtcbiAgICAgICAgICAuLi5zY2hlbWEsXG4gICAgICAgICAgcHJpbWFyeUtleSxcbiAgICAgICAgICBpbmRleGVzOiBhbGxWaXJ0dWFsSW5kZXhlcyxcbiAgICAgICAgICBnZXRJbmRleEJ5S2V5UGF0aDogZmluZEJlc3RJbmRleFxuICAgICAgICB9LFxuXG4gICAgICAgIGNvdW50KHJlcSkge1xuICAgICAgICAgIHJldHVybiB0YWJsZS5jb3VudCh0cmFuc2xhdGVSZXF1ZXN0KHJlcSkpO1xuICAgICAgICB9LCAgICBcbiAgICBcbiAgICAgICAgcXVlcnkocmVxKSB7XG4gICAgICAgICAgcmV0dXJuIHRhYmxlLnF1ZXJ5KHRyYW5zbGF0ZVJlcXVlc3QocmVxKSk7XG4gICAgICAgIH0sXG4gICAgXG4gICAgICAgIG9wZW5DdXJzb3IocmVxKSB7XG4gICAgICAgICAgY29uc3Qge2tleVRhaWwsIGlzVmlydHVhbCwga2V5TGVuZ3RofSA9IChyZXEucXVlcnkuaW5kZXggYXMgVmlydHVhbEluZGV4KTtcbiAgICAgICAgICBpZiAoIWlzVmlydHVhbCkgcmV0dXJuIHRhYmxlLm9wZW5DdXJzb3IocmVxKTtcbiAgICBcbiAgICAgICAgICBmdW5jdGlvbiBjcmVhdGVWaXJ0dWFsQ3Vyc29yKGN1cnNvcjogREJDb3JlQ3Vyc29yKSA6IERCQ29yZUN1cnNvciB7XG4gICAgICAgICAgICBmdW5jdGlvbiBfY29udGludWUgKGtleT86IGFueSkge1xuICAgICAgICAgICAgICBrZXkgIT0gbnVsbCA/XG4gICAgICAgICAgICAgICAgY3Vyc29yLmNvbnRpbnVlKHBhZChrZXksIHJlcS5yZXZlcnNlID8gZG93bi5NQVhfS0VZIDogZG93bi5NSU5fS0VZLCBrZXlUYWlsKSkgOlxuICAgICAgICAgICAgICAgIHJlcS51bmlxdWUgP1xuICAgICAgICAgICAgICAgICAgY3Vyc29yLmNvbnRpbnVlKFxuICAgICAgICAgICAgICAgICAgICBjdXJzb3Iua2V5LnNsaWNlKDAsIGtleUxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgICAuY29uY2F0KHJlcS5yZXZlcnNlXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGRvd24uTUlOX0tFWVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBkb3duLk1BWF9LRVksIGtleVRhaWwpXG4gICAgICAgICAgICAgICAgICApIDpcbiAgICAgICAgICAgICAgICAgIGN1cnNvci5jb250aW51ZSgpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB2aXJ0dWFsQ3Vyc29yID0gT2JqZWN0LmNyZWF0ZShjdXJzb3IsIHtcbiAgICAgICAgICAgICAgY29udGludWU6IHt2YWx1ZTogX2NvbnRpbnVlfSxcbiAgICAgICAgICAgICAgY29udGludWVQcmltYXJ5S2V5OiB7XG4gICAgICAgICAgICAgICAgdmFsdWUoa2V5OiBhbnksIHByaW1hcnlLZXk6IGFueSkge1xuICAgICAgICAgICAgICAgICAgY3Vyc29yLmNvbnRpbnVlUHJpbWFyeUtleShwYWQoa2V5LCBkb3duLk1BWF9LRVksIGtleVRhaWwpLCBwcmltYXJ5S2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHByaW1hcnlLZXk6IHtcbiAgICAgICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gY3Vyc29yLnByaW1hcnlLZXk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBrZXk6IHtcbiAgICAgICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBjdXJzb3Iua2V5IGFzIGFueVtdOyAvLyBBIHZpcnR1YWwgY3Vyc29yIGFsd2F5cyBvcGVyYXRlcyBvbiBjb21wb3VuZCBrZXlcbiAgICAgICAgICAgICAgICAgIHJldHVybiBrZXlMZW5ndGggPT09IDEgP1xuICAgICAgICAgICAgICAgICAgICBrZXlbMF0gOiAvLyBDdXJzb3Iua2V5IHNob3VsZCBub3QgYmUgYW4gYXJyYXkuXG4gICAgICAgICAgICAgICAgICAgIGtleS5zbGljZSgwLCBrZXlMZW5ndGgpOyAvLyBDdXJzb3Iua2V5IHNob3VsZCBiZSBmaXJzdCBwYXJ0IG9mIGFycmF5LlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gY3Vyc29yLnZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdmlydHVhbEN1cnNvcjtcbiAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgcmV0dXJuIHRhYmxlLm9wZW5DdXJzb3IodHJhbnNsYXRlUmVxdWVzdChyZXEpKVxuICAgICAgICAgICAgLnRoZW4oY3Vyc29yID0+IGN1cnNvciAmJiBjcmVhdGVWaXJ0dWFsQ3Vyc29yKGN1cnNvcikpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHZpcnR1YWxJbmRleE1pZGRsZXdhcmUgOiBNaWRkbGV3YXJlPERCQ29yZT4gPSB7XG4gIHN0YWNrOiBcImRiY29yZVwiLFxuICBuYW1lOiBcIlZpcnR1YWxJbmRleE1pZGRsZXdhcmVcIixcbiAgbGV2ZWw6IDEsXG4gIGNyZWF0ZTogY3JlYXRlVmlydHVhbEluZGV4TWlkZGxld2FyZVxufTtcblxuIiwgImltcG9ydCB7IGtleXMsIGhhc093biwgdG9TdHJpbmdUYWcgfSBmcm9tICcuL3V0aWxzJztcblxuZXhwb3J0IGZ1bmN0aW9uIGdldE9iamVjdERpZmYoYTogYW55LCBiOiBhbnksIHJ2PzogYW55LCBwcmZ4Pzogc3RyaW5nKSB7XG4gIC8vIENvbXBhcmVzIG9iamVjdHMgYSBhbmQgYiBhbmQgcHJvZHVjZXMgYSBkaWZmIG9iamVjdC5cbiAgcnYgPSBydiB8fCB7fTtcbiAgcHJmeCA9IHByZnggfHwgJyc7XG4gIGtleXMoYSkuZm9yRWFjaCgocHJvcCkgPT4ge1xuICAgIGlmICghaGFzT3duKGIsIHByb3ApKSB7XG4gICAgICAvLyBQcm9wZXJ0eSByZW1vdmVkXG4gICAgICBydltwcmZ4ICsgcHJvcF0gPSB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBhcCA9IGFbcHJvcF0sXG4gICAgICAgIGJwID0gYltwcm9wXTtcbiAgICAgIGlmICh0eXBlb2YgYXAgPT09ICdvYmplY3QnICYmIHR5cGVvZiBicCA9PT0gJ29iamVjdCcgJiYgYXAgJiYgYnApIHtcbiAgICAgICAgY29uc3QgYXBUeXBlTmFtZSA9IHRvU3RyaW5nVGFnKGFwKTtcbiAgICAgICAgY29uc3QgYnBUeXBlTmFtZSA9IHRvU3RyaW5nVGFnKGJwKTtcblxuICAgICAgICBpZiAoYXBUeXBlTmFtZSAhPT0gYnBUeXBlTmFtZSkge1xuICAgICAgICAgIHJ2W3ByZnggKyBwcm9wXSA9IGJbcHJvcF07IC8vIFByb3BlcnR5IGNoYW5nZWQgdG8gb3RoZXIgdHlwZVxuICAgICAgICB9IGVsc2UgaWYgKGFwVHlwZU5hbWUgPT09ICdPYmplY3QnKSB7XG4gICAgICAgICAgLy8gUG9qbyBvYmplY3RzIChub3QgRGF0ZSwgQXJyYXlCdWZmZXIsIEFycmF5IGV0YykuIEdvIGRlZXAuXG4gICAgICAgICAgZ2V0T2JqZWN0RGlmZihhcCwgYnAsIHJ2LCBwcmZ4ICsgcHJvcCArICcuJyk7XG4gICAgICAgIH0gZWxzZSBpZiAoYXAgIT09IGJwKSB7XG4gICAgICAgICAgLy8gVmFsdWVzIGRpZmZlci5cbiAgICAgICAgICAvLyBDb3VsZCBoYXZlIGNoZWNrZWQgaWYgRGF0ZSwgYXJyYXlzIG9yIGJpbmFyeSB0eXBlcyBoYXZlIHNhbWVcbiAgICAgICAgICAvLyBjb250ZW50IGhlcmUgYnV0IEkgdGhpbmsgdGhhdCB3b3VsZCBiZSBhIHN1Ym9wdGltYXRpb24uXG4gICAgICAgICAgLy8gUHJlZmVyIHNpbXBsaWNpdHkuXG4gICAgICAgICAgcnZbcHJmeCArIHByb3BdID0gYltwcm9wXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChhcCAhPT0gYnApIHJ2W3ByZnggKyBwcm9wXSA9IGJbcHJvcF07IC8vIFByaW1pdGl2ZSB2YWx1ZSBjaGFuZ2VkXG4gICAgfVxuICB9KTtcbiAga2V5cyhiKS5mb3JFYWNoKChwcm9wKSA9PiB7XG4gICAgaWYgKCFoYXNPd24oYSwgcHJvcCkpIHtcbiAgICAgIHJ2W3ByZnggKyBwcm9wXSA9IGJbcHJvcF07IC8vIFByb3BlcnR5IGFkZGVkXG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJ2O1xufVxuIiwgImltcG9ydCB7XG4gIERCQ29yZUFkZFJlcXVlc3QsXG4gIERCQ29yZVB1dFJlcXVlc3QsXG4gIERCQ29yZURlbGV0ZVJlcXVlc3QsXG4gIERCQ29yZUluZGV4LFxuICBEQkNvcmVUYWJsZSxcbn0gZnJvbSBcIi4uL3B1YmxpYy90eXBlcy9kYmNvcmVcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldEVmZmVjdGl2ZUtleXMgKFxuICBwcmltYXJ5S2V5OiBEQkNvcmVJbmRleCxcbiAgcmVxOiAoUGljazxEQkNvcmVBZGRSZXF1ZXN0IHwgREJDb3JlUHV0UmVxdWVzdCwgXCJ0eXBlXCIgfCBcInZhbHVlc1wiPiAmIHtrZXlzPzogYW55W119KSB8IFBpY2s8REJDb3JlRGVsZXRlUmVxdWVzdCwgXCJrZXlzXCIgfCBcInR5cGVcIj4pXG57XG4gIC8vY29uc3Qge291dGJvdW5kfSA9IHByaW1hcnlLZXk7XG4gIGlmIChyZXEudHlwZSA9PT0gJ2RlbGV0ZScpIHJldHVybiByZXEua2V5cztcbiAgcmV0dXJuIHJlcS5rZXlzIHx8IHJlcS52YWx1ZXMubWFwKHByaW1hcnlLZXkuZXh0cmFjdEtleSlcbn1cbiIsICJpbXBvcnQge1xuICBEQkNvcmUsXG4gIERCQ29yZVRhYmxlLFxuICBEQkNvcmVNdXRhdGVSZXNwb25zZSxcbiAgREJDb3JlRGVsZXRlUmFuZ2VSZXF1ZXN0LFxuICBEQkNvcmVBZGRSZXF1ZXN0LFxuICBEQkNvcmVQdXRSZXF1ZXN0LFxuICBEQkNvcmVEZWxldGVSZXF1ZXN0LFxuICBEQkNvcmVUcmFuc2FjdGlvbixcbiAgREJDb3JlS2V5UmFuZ2Vcbn0gZnJvbSBcIi4uL3B1YmxpYy90eXBlcy9kYmNvcmVcIjtcbmltcG9ydCB7IG5vcCB9IGZyb20gJy4uL2Z1bmN0aW9ucy9jaGFpbmluZy1mdW5jdGlvbnMnO1xuaW1wb3J0IHsgaGFzT3duLCBzZXRCeUtleVBhdGggfSBmcm9tICcuLi9mdW5jdGlvbnMvdXRpbHMnO1xuaW1wb3J0IHsgZ2V0T2JqZWN0RGlmZiB9IGZyb20gXCIuLi9mdW5jdGlvbnMvZ2V0LW9iamVjdC1kaWZmXCI7XG5pbXBvcnQgeyBQU0QgfSBmcm9tICcuLi9oZWxwZXJzL3Byb21pc2UnO1xuLy9pbXBvcnQgeyBMb2NrYWJsZVRhYmxlTWlkZGxld2FyZSB9IGZyb20gJy4uL2RiY29yZS9sb2NrYWJsZS10YWJsZS1taWRkbGV3YXJlJztcbmltcG9ydCB7IGdldEVmZmVjdGl2ZUtleXMgfSBmcm9tICcuLi9kYmNvcmUvZ2V0LWVmZmVjdGl2ZS1rZXlzJztcbmltcG9ydCB7IE1pZGRsZXdhcmUgfSBmcm9tICcuLi9wdWJsaWMvdHlwZXMvbWlkZGxld2FyZSc7XG5pbXBvcnQgeyBUcmFuc2FjdGlvbiB9IGZyb20gJy4uL2NsYXNzZXMvdHJhbnNhY3Rpb24nO1xuXG5leHBvcnQgY29uc3QgaG9va3NNaWRkbGV3YXJlOiBNaWRkbGV3YXJlPERCQ29yZT4gID0ge1xuICBzdGFjazogXCJkYmNvcmVcIixcbiAgbmFtZTogXCJIb29rc01pZGRsZXdhcmVcIixcbiAgbGV2ZWw6IDIsXG4gIGNyZWF0ZTogKGRvd25Db3JlOiBEQkNvcmUpID0+ICh7XG4gICAgLi4uZG93bkNvcmUsXG4gICAgdGFibGUodGFibGVOYW1lOiBzdHJpbmcpIHtcbiAgICAgIGNvbnN0IGRvd25UYWJsZSA9IGRvd25Db3JlLnRhYmxlKHRhYmxlTmFtZSk7XG4gICAgICBjb25zdCB7cHJpbWFyeUtleX0gPSBkb3duVGFibGUuc2NoZW1hO1xuICBcbiAgICAgIGNvbnN0IHRhYmxlTWlkZGxld2FyZTogREJDb3JlVGFibGUgPSB7XG4gICAgICAgIC4uLmRvd25UYWJsZSxcbiAgICAgICAgbXV0YXRlKHJlcSk6UHJvbWlzZTxEQkNvcmVNdXRhdGVSZXNwb25zZT4ge1xuICAgICAgICAgIGNvbnN0IGR4VHJhbnMgPSBQU0QudHJhbnMgYXMgVHJhbnNhY3Rpb247XG4gICAgICAgICAgLy8gSG9va3MgY2FuIGJlIHRyYW5zYWN0aW9uLWJvdW5kLiBOZWVkIHRvIGdyYWIgdGhlbSBmcm9tIHRyYW5zYWN0aW9uLnRhYmxlIGFuZCBub3RcbiAgICAgICAgICAvLyBkYi50YWJsZSFcbiAgICAgICAgICBjb25zdCB7ZGVsZXRpbmcsIGNyZWF0aW5nLCB1cGRhdGluZ30gPSBkeFRyYW5zLnRhYmxlKHRhYmxlTmFtZSkuaG9vaztcbiAgICAgICAgICBzd2l0Y2ggKHJlcS50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdhZGQnOlxuICAgICAgICAgICAgICBpZiAoY3JlYXRpbmcuZmlyZSA9PT0gbm9wKSBicmVhaztcbiAgICAgICAgICAgICAgcmV0dXJuIGR4VHJhbnMuX3Byb21pc2UoJ3JlYWR3cml0ZScsICgpPT5hZGRQdXRPckRlbGV0ZShyZXEpLCB0cnVlKTtcbiAgICAgICAgICAgIGNhc2UgJ3B1dCc6XG4gICAgICAgICAgICAgIGlmIChjcmVhdGluZy5maXJlID09PSBub3AgJiYgdXBkYXRpbmcuZmlyZSA9PT0gbm9wKSBicmVhaztcbiAgICAgICAgICAgICAgcmV0dXJuIGR4VHJhbnMuX3Byb21pc2UoJ3JlYWR3cml0ZScsICgpPT5hZGRQdXRPckRlbGV0ZShyZXEpLCB0cnVlKTtcbiAgICAgICAgICAgIGNhc2UgJ2RlbGV0ZSc6XG4gICAgICAgICAgICAgIGlmIChkZWxldGluZy5maXJlID09PSBub3ApIGJyZWFrO1xuICAgICAgICAgICAgICByZXR1cm4gZHhUcmFucy5fcHJvbWlzZSgncmVhZHdyaXRlJywgKCk9PmFkZFB1dE9yRGVsZXRlKHJlcSksIHRydWUpO1xuICAgICAgICAgICAgY2FzZSAnZGVsZXRlUmFuZ2UnOlxuICAgICAgICAgICAgICBpZiAoZGVsZXRpbmcuZmlyZSA9PT0gbm9wKSBicmVhaztcbiAgICAgICAgICAgICAgcmV0dXJuIGR4VHJhbnMuX3Byb21pc2UoJ3JlYWR3cml0ZScsICgpPT5kZWxldGVSYW5nZShyZXEpLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gQW55IG9mIHRoZSBicmVha3MgYWJvdmUgaGFwcGVuZWQgKG5vIGhvb2tzKSAtIGRvIHRoZSBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBkb3duVGFibGUubXV0YXRlKHJlcSk7XG5cblxuICAgICAgICAgIGZ1bmN0aW9uIGFkZFB1dE9yRGVsZXRlKHJlcTogREJDb3JlQWRkUmVxdWVzdCB8IERCQ29yZVB1dFJlcXVlc3QgfCBEQkNvcmVEZWxldGVSZXF1ZXN0KTogUHJvbWlzZTxEQkNvcmVNdXRhdGVSZXNwb25zZT4ge1xuICAgICAgICAgICAgY29uc3QgZHhUcmFucyA9IFBTRC50cmFucztcbiAgICAgICAgICAgIGNvbnN0IGtleXMgPSByZXEua2V5cyB8fCBnZXRFZmZlY3RpdmVLZXlzKHByaW1hcnlLZXksIHJlcSk7XG4gICAgICAgICAgICBpZiAoIWtleXMpIHRocm93IG5ldyBFcnJvcihcIktleXMgbWlzc2luZ1wiKTtcbiAgICAgICAgICAgIC8vIENsb25lIFJlcXVlc3QgYW5kIHNldCBrZXlzIGFyZ1xuICAgICAgICAgICAgcmVxID0gcmVxLnR5cGUgPT09ICdhZGQnIHx8IHJlcS50eXBlID09PSAncHV0JyA/XG4gICAgICAgICAgICAgIHsuLi5yZXEsIGtleXN9IDpcbiAgICAgICAgICAgICAgey4uLnJlcX07XG4gICAgICAgICAgICBpZiAocmVxLnR5cGUgIT09ICdkZWxldGUnKSByZXEudmFsdWVzID0gWy4uLnJlcS52YWx1ZXNdO1xuICAgICAgICAgICAgaWYgKHJlcS5rZXlzKSByZXEua2V5cyA9IFsuLi5yZXEua2V5c107XG4gIFxuICAgICAgICAgICAgcmV0dXJuIGdldEV4aXN0aW5nVmFsdWVzKGRvd25UYWJsZSwgcmVxLCBrZXlzKS50aGVuIChleGlzdGluZ1ZhbHVlcyA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IGNvbnRleHRzID0ga2V5cy5tYXAoKGtleSwgaSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nVmFsdWUgPSBleGlzdGluZ1ZhbHVlc1tpXTtcbiAgICAgICAgICAgICAgICBjb25zdCBjdHggPSB7IG9uZXJyb3I6IG51bGwsIG9uc3VjY2VzczogbnVsbCB9O1xuICAgICAgICAgICAgICAgIGlmIChyZXEudHlwZSA9PT0gJ2RlbGV0ZScpIHtcbiAgICAgICAgICAgICAgICAgIC8vIGRlbGV0ZSBvcGVyYXRpb25cbiAgICAgICAgICAgICAgICAgIGRlbGV0aW5nLmZpcmUuY2FsbChjdHgsIGtleSwgZXhpc3RpbmdWYWx1ZSwgZHhUcmFucyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChyZXEudHlwZSA9PT0gJ2FkZCcgfHwgZXhpc3RpbmdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAvLyBUaGUgYWRkKCkgb3IgcHV0KCkgcmVzdWx0ZWQgaW4gYSBjcmVhdGVcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGdlbmVyYXRlZFByaW1hcnlLZXkgPSBjcmVhdGluZy5maXJlLmNhbGwoY3R4LCBrZXksIHJlcS52YWx1ZXNbaV0sIGR4VHJhbnMpO1xuICAgICAgICAgICAgICAgICAgaWYgKGtleSA9PSBudWxsICYmIGdlbmVyYXRlZFByaW1hcnlLZXkgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBrZXkgPSBnZW5lcmF0ZWRQcmltYXJ5S2V5O1xuICAgICAgICAgICAgICAgICAgICByZXEua2V5c1tpXSA9IGtleTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwcmltYXJ5S2V5Lm91dGJvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgc2V0QnlLZXlQYXRoKHJlcS52YWx1ZXNbaV0sIHByaW1hcnlLZXkua2V5UGF0aCwga2V5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAvLyBUaGUgcHV0KCkgb3BlcmF0aW9uIHJlc3VsdGVkIGluIGFuIHVwZGF0ZVxuICAgICAgICAgICAgICAgICAgY29uc3Qgb2JqZWN0RGlmZiA9IGdldE9iamVjdERpZmYoZXhpc3RpbmdWYWx1ZSwgcmVxLnZhbHVlc1tpXSk7XG4gICAgICAgICAgICAgICAgICBjb25zdCBhZGRpdGlvbmFsQ2hhbmdlcyA9IHVwZGF0aW5nLmZpcmUuY2FsbChjdHgsIG9iamVjdERpZmYsIGtleSwgZXhpc3RpbmdWYWx1ZSwgZHhUcmFucyk7XG4gICAgICAgICAgICAgICAgICBpZiAoYWRkaXRpb25hbENoYW5nZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVxdWVzdGVkVmFsdWUgPSByZXEudmFsdWVzW2ldO1xuICAgICAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhhZGRpdGlvbmFsQ2hhbmdlcykuZm9yRWFjaChrZXlQYXRoID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFzT3duKHJlcXVlc3RlZFZhbHVlLCBrZXlQYXRoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8ga2V5UGF0aCBpcyBhbHJlYWR5IHByZXNlbnQgYXMgYSBsaXRlcmFsIHByb3BlcnR5IG9mIHRoZSBvYmplY3RcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RlZFZhbHVlW2tleVBhdGhdID0gYWRkaXRpb25hbENoYW5nZXNba2V5UGF0aF07XG4gICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGtleVBhdGggcmVwcmVzZW50cyBhIG5ldyBvciBleGlzdGluZyBwYXRoIGludG8gdGhlIG9iamVjdFxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0QnlLZXlQYXRoKHJlcXVlc3RlZFZhbHVlLCBrZXlQYXRoLCBhZGRpdGlvbmFsQ2hhbmdlc1trZXlQYXRoXSk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGN0eDtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHJldHVybiBkb3duVGFibGUubXV0YXRlKHJlcSkudGhlbigoe2ZhaWx1cmVzLCByZXN1bHRzLCBudW1GYWlsdXJlcywgbGFzdFJlc3VsdH0pID0+IHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpPTA7IGk8a2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgY29uc3QgcHJpbUtleSA9IHJlc3VsdHMgPyByZXN1bHRzW2ldIDoga2V5c1tpXTtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGN0eCA9IGNvbnRleHRzW2ldO1xuICAgICAgICAgICAgICAgICAgaWYgKHByaW1LZXkgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjdHgub25lcnJvciAmJiBjdHgub25lcnJvcihmYWlsdXJlc1tpXSk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjdHgub25zdWNjZXNzICYmIGN0eC5vbnN1Y2Nlc3MoXG4gICAgICAgICAgICAgICAgICAgICAgcmVxLnR5cGUgPT09ICdwdXQnICYmIGV4aXN0aW5nVmFsdWVzW2ldID8gLy8gdGhlIHB1dCByZXN1bHRlZCBpbiBhbiB1cGRhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcS52YWx1ZXNbaV0gOiAvLyB1cGRhdGUgaG9va3MgZXhwZWN0cyBleGlzdGluZyB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgcHJpbUtleSAvLyBjcmVhdGUgaG9va3MgZXhwZWN0cyBwcmltYXJ5IGtleVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4ge2ZhaWx1cmVzLCByZXN1bHRzLCBudW1GYWlsdXJlcywgbGFzdFJlc3VsdH07XG4gICAgICAgICAgICAgIH0pLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgICAgICAgICBjb250ZXh0cy5mb3JFYWNoKGN0eCA9PiBjdHgub25lcnJvciAmJiBjdHgub25lcnJvcihlcnJvcikpO1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICBcbiAgICAgICAgICBmdW5jdGlvbiBkZWxldGVSYW5nZShyZXE6IERCQ29yZURlbGV0ZVJhbmdlUmVxdWVzdCk6IFByb21pc2U8REJDb3JlTXV0YXRlUmVzcG9uc2U+IHtcbiAgICAgICAgICAgIHJldHVybiBkZWxldGVOZXh0Q2h1bmsocmVxLnRyYW5zLCByZXEucmFuZ2UsIDEwMDAwKTtcbiAgICAgICAgICB9XG4gIFxuICAgICAgICAgIGZ1bmN0aW9uIGRlbGV0ZU5leHRDaHVuayh0cmFuczogREJDb3JlVHJhbnNhY3Rpb24sIHJhbmdlOiBEQkNvcmVLZXlSYW5nZSwgbGltaXQ6IG51bWJlcikge1xuICAgICAgICAgICAgLy8gUXVlcnkgd2hhdCBrZXlzIGluIHRoZSBEQiB3aXRoaW4gdGhlIGdpdmVuIHJhbmdlXG4gICAgICAgICAgICByZXR1cm4gZG93blRhYmxlLnF1ZXJ5KHt0cmFucywgdmFsdWVzOiBmYWxzZSwgcXVlcnk6IHtpbmRleDogcHJpbWFyeUtleSwgcmFuZ2V9LCBsaW1pdH0pXG4gICAgICAgICAgICAudGhlbigoe3Jlc3VsdH0pID0+IHtcbiAgICAgICAgICAgICAgLy8gR2l2ZW4gYSBzZXQgb2Yga2V5cywgYnVsayBkZWxldGUgdGhvc2UgdXNpbmcgdGhlIHNhbWUgcHJvY2VkdXJlIGFzIGluIGFkZFB1dE9yRGVsZXRlKCkuXG4gICAgICAgICAgICAgIC8vIFRoaXMgd2lsbCBtYWtlIHN1cmUgdGhhdCBkZWxldGluZyBob29rIGlzIGNhbGxlZC5cbiAgICAgICAgICAgICAgcmV0dXJuIGFkZFB1dE9yRGVsZXRlKHt0eXBlOiAnZGVsZXRlJywga2V5czogcmVzdWx0LCB0cmFuc30pLnRoZW4ocmVzID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocmVzLm51bUZhaWx1cmVzID4gMCkgcmV0dXJuIFByb21pc2UucmVqZWN0KHJlcy5mYWlsdXJlc1swXSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPCBsaW1pdCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHtmYWlsdXJlczogW10sIG51bUZhaWx1cmVzOiAwLCBsYXN0UmVzdWx0OiB1bmRlZmluZWR9IGFzIERCQ29yZU11dGF0ZVJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZGVsZXRlTmV4dENodW5rKHRyYW5zLCB7Li4ucmFuZ2UsIGxvd2VyOiByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdLCBsb3dlck9wZW46IHRydWV9LCBsaW1pdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgLy9jb25zdCB7bG9jaywgbG9ja2FibGVNaWRkbGV3YXJlfSA9IExvY2thYmxlVGFibGVNaWRkbGV3YXJlKHRhYmxlTWlkZGxld2FyZSk7XG5cbiAgICAgIHJldHVybiB0YWJsZU1pZGRsZXdhcmU7XG4gICAgfSxcbiAgfSkgYXMgREJDb3JlXG59O1xuXG5mdW5jdGlvbiBnZXRFeGlzdGluZ1ZhbHVlcyhcbiAgdGFibGU6IERCQ29yZVRhYmxlLFxuICByZXE6IERCQ29yZUFkZFJlcXVlc3QgfCBEQkNvcmVQdXRSZXF1ZXN0IHwgREJDb3JlRGVsZXRlUmVxdWVzdCxcbiAgZWZmZWN0aXZlS2V5czogYW55W11cbikge1xuICByZXR1cm4gcmVxLnR5cGUgPT09IFwiYWRkXCJcbiAgICA/IFByb21pc2UucmVzb2x2ZShbXSlcbiAgICA6IHRhYmxlLmdldE1hbnkoeyB0cmFuczogcmVxLnRyYW5zLCBrZXlzOiBlZmZlY3RpdmVLZXlzLCBjYWNoZTogXCJpbW11dGFibGVcIiB9KTtcbn1cbiIsICJpbXBvcnQgeyBkZWVwQ2xvbmUgfSBmcm9tIFwiLi4vZnVuY3Rpb25zL3V0aWxzXCI7XG5pbXBvcnQgeyBEQkNvcmUgfSBmcm9tIFwiLi4vcHVibGljL3R5cGVzL2RiY29yZVwiO1xuaW1wb3J0IHsgTWlkZGxld2FyZSB9IGZyb20gXCIuLi9wdWJsaWMvdHlwZXMvbWlkZGxld2FyZVwiO1xuaW1wb3J0IFByb21pc2UgZnJvbSBcIi4uL2hlbHBlcnMvcHJvbWlzZVwiO1xuaW1wb3J0IHsgY21wIH0gZnJvbSAnLi4vZnVuY3Rpb25zL2NtcCc7XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRGcm9tVHJhbnNhY3Rpb25DYWNoZShcbiAga2V5czogYW55W10sXG4gIGNhY2hlOiB7IGtleXM6IGFueVtdOyB2YWx1ZXM6IGFueVtdIH0gfCB1bmRlZmluZWQgfCBudWxsLFxuICBjbG9uZT86IGJvb2xlYW5cbikge1xuICB0cnkge1xuICAgIGlmICghY2FjaGUpIHJldHVybiBudWxsO1xuICAgIGlmIChjYWNoZS5rZXlzLmxlbmd0aCA8IGtleXMubGVuZ3RoKSByZXR1cm4gbnVsbDtcbiAgICBjb25zdCByZXN1bHQ6IGFueVtdID0gW107XG4gICAgLy8gQ29tcGFyZSBpZiB0aGUgZXhhY3Qgc2FtZSBvcmRlciBvZiBrZXlzIHdhcyByZXRyaWV2ZWQgaW4gc2FtZSB0cmFuc2FjdGlvbjpcbiAgICAvLyBBbGxvdyBzb21lIGNhY2hlZCBrZXlzIHRvIGJlIG9taXR0ZWQgZnJvbSBwcm92aWRlZCBzZXQgb2Yga2V5c1xuICAgIC8vIFVzZSBjYXNlOiAxLiBnZXRNYW55KGtleXMpIDIuIHVwZGF0ZSBhIHN1YnNldCBvZiB0aG9zZSAzLiBjYWxsIHB1dCB3aXRoIHRoZSB1cGRhdGVkIG9uZXMgPT0+IG1pZGRsZXdhcmVzIHNob3VsZCBiZSBhYmxlIHRvIGZpbmQgb2xkIHZhbHVlc1xuICAgIGZvciAobGV0IGkgPSAwLCBqID0gMDsgaSA8IGNhY2hlLmtleXMubGVuZ3RoICYmIGogPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICBpZiAoY21wKGNhY2hlLmtleXNbaV0sIGtleXNbal0pICE9PSAwKSBjb250aW51ZTtcbiAgICAgIHJlc3VsdC5wdXNoKGNsb25lID8gZGVlcENsb25lKGNhY2hlLnZhbHVlc1tpXSkgOiBjYWNoZS52YWx1ZXNbaV0pO1xuICAgICAgKytqO1xuICAgIH1cbiAgICAvLyBJZiBnb3QgYWxsIGtleXMgY2FsbGVyIHdhcyBsb29raW5nIGZvciwgcmV0dXJuIHJlc3VsdC5cbiAgICByZXR1cm4gcmVzdWx0Lmxlbmd0aCA9PT0ga2V5cy5sZW5ndGggPyByZXN1bHQgOiBudWxsO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgY2FjaGVFeGlzdGluZ1ZhbHVlc01pZGRsZXdhcmU6IE1pZGRsZXdhcmU8REJDb3JlPiA9IHtcbiAgc3RhY2s6IFwiZGJjb3JlXCIsXG4gIGxldmVsOiAtMSxcbiAgY3JlYXRlOiAoY29yZSkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICB0YWJsZTogKHRhYmxlTmFtZSkgPT4ge1xuICAgICAgICBjb25zdCB0YWJsZSA9IGNvcmUudGFibGUodGFibGVOYW1lKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi50YWJsZSxcbiAgICAgICAgICBnZXRNYW55OiAocmVxKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXJlcS5jYWNoZSkge1xuICAgICAgICAgICAgICByZXR1cm4gdGFibGUuZ2V0TWFueShyZXEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY2FjaGVkUmVzdWx0ID0gZ2V0RnJvbVRyYW5zYWN0aW9uQ2FjaGUoXG4gICAgICAgICAgICAgIHJlcS5rZXlzLFxuICAgICAgICAgICAgICByZXEudHJhbnNbXCJfY2FjaGVcIl0sXG4gICAgICAgICAgICAgIHJlcS5jYWNoZSA9PT0gXCJjbG9uZVwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKGNhY2hlZFJlc3VsdCkge1xuICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGNhY2hlZFJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGFibGUuZ2V0TWFueShyZXEpLnRoZW4oKHJlcykgPT4ge1xuICAgICAgICAgICAgICByZXEudHJhbnNbXCJfY2FjaGVcIl0gPSB7XG4gICAgICAgICAgICAgICAga2V5czogcmVxLmtleXMsXG4gICAgICAgICAgICAgICAgdmFsdWVzOiByZXEuY2FjaGUgPT09IFwiY2xvbmVcIiA/IGRlZXBDbG9uZShyZXMpIDogcmVzLFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBtdXRhdGU6IChyZXEpID0+IHtcbiAgICAgICAgICAgIC8vIEludmFsaWRhdGUgY2FjaGUgb24gYW55IG11dGF0ZSBleGNlcHQgXCJhZGRcIiB3aGljaCBjYW4ndCBjaGFuZ2UgZXhpc3RpbmcgdmFsdWVzOlxuICAgICAgICAgICAgaWYgKHJlcS50eXBlICE9PSBcImFkZFwiKSByZXEudHJhbnNbXCJfY2FjaGVcIl0gPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIHRhYmxlLm11dGF0ZShyZXEpO1xuICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgIH07XG4gIH0sXG59O1xuIiwgImltcG9ydCB7IGNtcCB9IGZyb20gXCIuLi9mdW5jdGlvbnMvY21wXCI7XG5pbXBvcnQgeyBleHRlbmQsIGl0ZXJhdG9yU3ltYm9sLCBwcm9wcyB9IGZyb20gJy4uL2Z1bmN0aW9ucy91dGlscyc7XG5pbXBvcnQgeyBJbmRleGFibGVUeXBlIH0gZnJvbSAnLi4vcHVibGljJztcbmltcG9ydCB7XG4gIEVtcHR5UmFuZ2UsXG4gIEludGVydmFsVHJlZSxcbiAgSW50ZXJ2YWxUcmVlTm9kZSxcbiAgUmFuZ2VTZXRDb25zdHJ1Y3RvcixcbiAgUmFuZ2VTZXRQcm90b3R5cGUsXG59IGZyb20gXCIuLi9wdWJsaWMvdHlwZXMvcmFuZ2VzZXRcIjtcblxuLyogQW4gaW50ZXJ2YWwgdHJlZSBpbXBsZW1lbnRhdGlvbiB0byBlZmZpY2llbnRseSBkZXRlY3Qgb3ZlcmxhcHBpbmcgcmFuZ2VzIG9mIHF1ZXJpZWQgaW5kZXhlcy5cbiAqXG4gKiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JbnRlcnZhbF90cmVlXG4gKiBcbiAqL1xuXG5mdW5jdGlvbiBpc0VtcHR5UmFuZ2Uobm9kZTogSW50ZXJ2YWxUcmVlIHwge2Zyb206IEluZGV4YWJsZVR5cGUsIHRvOiBJbmRleGFibGVUeXBlfSk6IG5vZGUgaXMgRW1wdHlSYW5nZSB7XG4gIHJldHVybiAhKFwiZnJvbVwiIGluIG5vZGUpO1xufVxuXG5leHBvcnQgdHlwZSBSYW5nZVNldCA9IFJhbmdlU2V0UHJvdG90eXBlICYgSW50ZXJ2YWxUcmVlO1xuXG5leHBvcnQgY29uc3QgUmFuZ2VTZXQgPSBmdW5jdGlvbihmcm9tT3JUcmVlOiBhbnksIHRvPzogYW55KSB7XG4gIGlmICh0aGlzKSB7XG4gICAgLy8gQ2FsbGVkIHdpdGggbmV3KClcbiAgICBleHRlbmQodGhpcywgYXJndW1lbnRzLmxlbmd0aCA/IHtkOjEsIGZyb206IGZyb21PclRyZWUsIHRvOiBhcmd1bWVudHMubGVuZ3RoID4gMSA/IHRvIDogZnJvbU9yVHJlZX0gOiB7ZDowfSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gQ2FsbGVkIHdpdGhvdXQgbmV3KClcbiAgICBjb25zdCBydiA9IG5ldyBSYW5nZVNldCgpO1xuICAgIGlmIChmcm9tT3JUcmVlICYmIChcImRcIiBpbiBmcm9tT3JUcmVlKSkge1xuICAgICAgZXh0ZW5kKHJ2LCBmcm9tT3JUcmVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHJ2O1xuICB9XG59IGFzIFJhbmdlU2V0Q29uc3RydWN0b3I7XG5cbnByb3BzKFJhbmdlU2V0LnByb3RvdHlwZSwge1xuICBhZGQocmFuZ2VTZXQ6IEludGVydmFsVHJlZSB8IHtmcm9tOiBJbmRleGFibGVUeXBlLCB0bzogSW5kZXhhYmxlVHlwZX0pIHtcbiAgICBtZXJnZVJhbmdlcyh0aGlzLCByYW5nZVNldCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGFkZEtleShrZXk6IEluZGV4YWJsZVR5cGUpIHtcbiAgICBhZGRSYW5nZSh0aGlzLCBrZXksIGtleSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGFkZEtleXMoa2V5czogSW5kZXhhYmxlVHlwZVtdKSB7XG4gICAga2V5cy5mb3JFYWNoKGtleSA9PiBhZGRSYW5nZSh0aGlzLCBrZXksIGtleSkpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIFtpdGVyYXRvclN5bWJvbF0oKTogSXRlcmF0b3I8SW50ZXJ2YWxUcmVlTm9kZSwgdW5kZWZpbmVkLCBJbmRleGFibGVUeXBlIHwgdW5kZWZpbmVkPiB7XG4gICAgcmV0dXJuIGdldFJhbmdlU2V0SXRlcmF0b3IodGhpcyk7XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBhZGRSYW5nZSh0YXJnZXQ6IEludGVydmFsVHJlZSwgZnJvbTogSW5kZXhhYmxlVHlwZSwgdG86IEluZGV4YWJsZVR5cGUpIHtcbiAgY29uc3QgZGlmZiA9IGNtcChmcm9tLCB0byk7XG4gIC8vIGNtcCgpIHJldHVybnMgTmFOIGlmIG9uZSBvZiB0aGUgYXJncyBhcmUgSURCLWludmFsaWQga2V5cy5cbiAgLy8gQXZvaWQgc3RvcmluZyBpbnZhbGlkIGtleXMgaW4gcmFuZ2VzZXQ6XG4gIGlmIChpc05hTihkaWZmKSkgcmV0dXJuO1xuXG4gIC8vIENhbGxlciBpcyB0cnlpbmcgdG8gYWRkIGEgcmFuZ2Ugd2hlcmUgZnJvbSBpcyBncmVhdGVyIHRoYW4gdG86XG4gIGlmIChkaWZmID4gMCkgdGhyb3cgUmFuZ2VFcnJvcigpO1xuICBcbiAgaWYgKGlzRW1wdHlSYW5nZSh0YXJnZXQpKSByZXR1cm4gZXh0ZW5kKHRhcmdldCwgeyBmcm9tLCB0bywgZDogMSB9KTtcbiAgY29uc3QgbGVmdCA9IHRhcmdldC5sO1xuICBjb25zdCByaWdodCA9IHRhcmdldC5yO1xuICBpZiAoY21wKHRvLCB0YXJnZXQuZnJvbSkgPCAwKSB7XG4gICAgbGVmdFxuICAgICAgPyBhZGRSYW5nZShsZWZ0LCBmcm9tLCB0bylcbiAgICAgIDogKHRhcmdldC5sID0geyBmcm9tLCB0bywgZDogMSwgbDogbnVsbCwgcjogbnVsbCB9KTtcbiAgICByZXR1cm4gcmViYWxhbmNlKHRhcmdldCk7XG4gIH1cbiAgaWYgKGNtcChmcm9tLCB0YXJnZXQudG8pID4gMCkge1xuICAgIHJpZ2h0XG4gICAgICA/IGFkZFJhbmdlKHJpZ2h0LCBmcm9tLCB0bylcbiAgICAgIDogKHRhcmdldC5yID0geyBmcm9tLCB0bywgZDogMSwgbDogbnVsbCwgcjogbnVsbCB9KTtcbiAgICByZXR1cm4gcmViYWxhbmNlKHRhcmdldCk7XG4gIH1cbiAgLy8gTm93IHdlIGhhdmUgc29tZSBraW5kIG9mIG92ZXJsYXAuIFdlIHdpbGwgYmUgYWJsZSB0byBtZXJnZSB0aGUgbmV3IHJhbmdlIGludG8gdGhlIG5vZGUgb3IgbGV0IGl0IGJlIHN3YWxsb3dlZC5cblxuICAvLyBHcm93IGxlZnQ/XG4gIGlmIChjbXAoZnJvbSwgdGFyZ2V0LmZyb20pIDwgMCkge1xuICAgIHRhcmdldC5mcm9tID0gZnJvbTtcbiAgICB0YXJnZXQubCA9IG51bGw7IC8vIEN1dCBvZmYgZm9yIG5vdy4gUmUtYWRkIGxhdGVyLlxuICAgIHRhcmdldC5kID0gcmlnaHQgPyByaWdodC5kICsgMSA6IDE7XG4gIH1cbiAgLy8gR3JvdyByaWdodD9cbiAgaWYgKGNtcCh0bywgdGFyZ2V0LnRvKSA+IDApIHtcbiAgICB0YXJnZXQudG8gPSB0bztcbiAgICB0YXJnZXQuciA9IG51bGw7IC8vIEN1dCBvZmYgZm9yIG5vdy4gUmUtYWRkIGxhdGVyLlxuICAgIHRhcmdldC5kID0gdGFyZ2V0LmwgPyB0YXJnZXQubC5kICsgMSA6IDE7XG4gIH1cbiAgY29uc3QgcmlnaHRXYXNDdXRPZmYgPSAhdGFyZ2V0LnI7XG4gIC8vIFJlLWFkZCBsZWZ0P1xuICBpZiAobGVmdCAmJiAhdGFyZ2V0LmwpIHtcbiAgICAvL1JhbmdlcyB0byB0aGUgbGVmdCBtYXkgYmUgc3dhbGxvd2VkLiBDdXQgaXQgb2YgYW5kIHJlLWFkZCBhbGwuXG4gICAgLy9Db3VsZCBwcm9iYWJseSBiZSBkb25lIG1vcmUgZWZmaWNpZW50bHkhXG4gICAgbWVyZ2VSYW5nZXModGFyZ2V0LCBsZWZ0KTtcbiAgfVxuICAvLyBSZS1hZGQgcmlnaHQ/XG4gIGlmIChyaWdodCAmJiByaWdodFdhc0N1dE9mZikge1xuICAgIC8vUmFuZ2VzIHRvIHRoZSByaWdodCBtYXkgYmUgc3dhbGxvd2VkLiBDdXQgaXQgb2YgYW5kIHJlLWFkZCBhbGwuXG4gICAgLy9Db3VsZCBwcm9iYWJseSBiZSBkb25lIG1vcmUgZWZmaWNpZW50bHkhXG4gICAgbWVyZ2VSYW5nZXModGFyZ2V0LCByaWdodCk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlUmFuZ2VzKHRhcmdldDogSW50ZXJ2YWxUcmVlLCBuZXdTZXQ6IEludGVydmFsVHJlZSB8IHtmcm9tOiBJbmRleGFibGVUeXBlLCB0bzogSW5kZXhhYmxlVHlwZX0pIHtcbiAgZnVuY3Rpb24gX2FkZFJhbmdlU2V0KFxuICAgIHRhcmdldDogSW50ZXJ2YWxUcmVlLFxuICAgIHsgZnJvbSwgdG8sIGwsIHIgfTogSW50ZXJ2YWxUcmVlTm9kZSB8IHtmcm9tOiBJbmRleGFibGVUeXBlLCB0bzogSW5kZXhhYmxlVHlwZSwgbD86IHVuZGVmaW5lZCwgcj86IHVuZGVmaW5lZH1cbiAgKSB7XG4gICAgYWRkUmFuZ2UodGFyZ2V0LCBmcm9tLCB0byk7XG4gICAgaWYgKGwpIF9hZGRSYW5nZVNldCh0YXJnZXQsIGwpO1xuICAgIGlmIChyKSBfYWRkUmFuZ2VTZXQodGFyZ2V0LCByKTtcbiAgfVxuXG4gIGlmKCFpc0VtcHR5UmFuZ2UobmV3U2V0KSkgX2FkZFJhbmdlU2V0KHRhcmdldCwgbmV3U2V0KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJhbmdlc092ZXJsYXAoXG4gIHJhbmdlU2V0MTogSW50ZXJ2YWxUcmVlLFxuICByYW5nZVNldDI6IEludGVydmFsVHJlZVxuKTogYm9vbGVhbiB7XG4gICAgLy8gU3RhcnQgaXRlcmF0aW5nIG90aGVyIGZyb20gc2NyYXRjaC5cbiAgICBjb25zdCBpMSA9IGdldFJhbmdlU2V0SXRlcmF0b3IocmFuZ2VTZXQyKTtcbiAgICBsZXQgbmV4dFJlc3VsdDEgPSBpMS5uZXh0KCk7XG4gICAgaWYgKG5leHRSZXN1bHQxLmRvbmUpIHJldHVybiBmYWxzZTtcbiAgICBsZXQgYSA9IG5leHRSZXN1bHQxLnZhbHVlO1xuXG4gICAgLy8gU3RhcnQgaXRlcmF0aW5nIHRoaXMgZnJvbSBzdGFydCBvZiBvdGhlclxuICAgIGNvbnN0IGkyID0gZ2V0UmFuZ2VTZXRJdGVyYXRvcihyYW5nZVNldDEpO1xuICAgIGxldCBuZXh0UmVzdWx0MiA9IGkyLm5leHQoYS5mcm9tKTsgLy8gU3RhcnQgZnJvbSBiZWdpbm5pbmcgb2Ygb3RoZXIgcmFuZ2VcbiAgICBsZXQgYiA9IG5leHRSZXN1bHQyLnZhbHVlO1xuXG4gICAgd2hpbGUgKCFuZXh0UmVzdWx0MS5kb25lICYmICFuZXh0UmVzdWx0Mi5kb25lKSB7XG4gICAgICBpZiAoY21wKGIhLmZyb20sIGEudG8pIDw9IDAgJiYgY21wKGIhLnRvLCBhLmZyb20pID49IDApIHJldHVybiB0cnVlO1xuICAgICAgY21wKGEuZnJvbSwgYiEuZnJvbSkgPCAwXG4gICAgICAgID8gKGEgPSAobmV4dFJlc3VsdDEgPSBpMS5uZXh0KGIhLmZyb20pKS52YWx1ZSEpIC8vIGEgaXMgYmVoaW5kLiBmb3J3YXJkIGl0IHRvIGJlZ2lubmluZyBvZiBuZXh0IGItcmFuZ2VcbiAgICAgICAgOiAoYiA9IChuZXh0UmVzdWx0MiA9IGkyLm5leHQoYS5mcm9tKSkudmFsdWUpOyAvLyBiIGlzIGJlaGluZC4gZm9yd2FyZCBpdCB0byBiZWdpbm5pbmcgb2YgbmV4dCBhLXJhbmdlXG4gICAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbnR5cGUgUmFuZ2VTZXRJdGVyYXRvclN0YXRlID1cbiAgfCB7XG4gICAgICB1cD86IFJhbmdlU2V0SXRlcmF0b3JTdGF0ZTtcbiAgICAgIG46IEludGVydmFsVHJlZU5vZGU7XG4gICAgICBzOiAwIHwgMSB8IDIgfCAzO1xuICAgIH1cbiAgfCB1bmRlZmluZWRcbiAgfCBudWxsO1xuZXhwb3J0IGZ1bmN0aW9uIGdldFJhbmdlU2V0SXRlcmF0b3IoXG4gIG5vZGU6IEVtcHR5UmFuZ2UgfCBJbnRlcnZhbFRyZWVOb2RlXG4pOiBHZW5lcmF0b3I8SW50ZXJ2YWxUcmVlTm9kZSwgdW5kZWZpbmVkLCBJbmRleGFibGVUeXBlIHwgdW5kZWZpbmVkPiB7XG4gIGxldCBzdGF0ZTogUmFuZ2VTZXRJdGVyYXRvclN0YXRlID0gaXNFbXB0eVJhbmdlKG5vZGUpID8gbnVsbCA6IHsgczogMCwgbjogbm9kZSB9O1xuXG4gIHJldHVybiB7XG4gICAgbmV4dChrZXk/KSB7XG4gICAgICBjb25zdCBrZXlQcm92aWRlZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwO1xuICAgICAgd2hpbGUgKHN0YXRlKSB7XG4gICAgICAgIHN3aXRjaCAoc3RhdGUucykge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIC8vIEluaXRpYWwgc3RhdGUgZm9yIG5vZGUuXG4gICAgICAgICAgICAvLyBGYXN0IGZvcndhcmQgdG8gbGVmdG1vc3Qgbm9kZS5cbiAgICAgICAgICAgIHN0YXRlLnMgPSAxO1xuICAgICAgICAgICAgaWYgKGtleVByb3ZpZGVkKSB7XG4gICAgICAgICAgICAgIHdoaWxlIChzdGF0ZS5uLmwgJiYgY21wKGtleSwgc3RhdGUubi5mcm9tKSA8IDApXG4gICAgICAgICAgICAgICAgc3RhdGUgPSB7IHVwOiBzdGF0ZSwgbjogc3RhdGUubi5sLCBzOiAxIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB3aGlsZSAoc3RhdGUubi5sKSBzdGF0ZSA9IHsgdXA6IHN0YXRlLCBuOiBzdGF0ZS5uLmwsIHM6IDEgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAvLyBpbnRlbnRpb25hbGx5IGZhbGwgaW50byBjYXNlIDE6XG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgLy8gV2UncmUgb24gYSBub2RlIHdoZXJlIGl0J3MgbGVmdCBwYXJ0IGlzIGFscmVhZHkgaGFuZGxlZCBvciBkb2VzIG5vdCBleGlzdC5cbiAgICAgICAgICAgIHN0YXRlLnMgPSAyO1xuICAgICAgICAgICAgaWYgKCFrZXlQcm92aWRlZCB8fCBjbXAoa2V5LCBzdGF0ZS5uLnRvKSA8PSAwKVxuICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogc3RhdGUubiwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAvLyBXZSd2ZSBlbWl0dGVkIG91ciBub2RlIGFuZCBzaG91bGQgY29udGludWUgd2l0aCB0aGUgcmlnaHQgcGFydCBvciBsZXQgcGFyZW50IHRha2Ugb3ZlciBmcm9tIGl0J3Mgc3RhdGUgMVxuICAgICAgICAgICAgaWYgKHN0YXRlLm4ucikge1xuICAgICAgICAgICAgICBzdGF0ZS5zID0gMzsgLy8gU28gd2hlbiBjaGlsZCBpcyBkb25lLCB3ZSBrbm93IHdlJ3JlIGRvbmUuXG4gICAgICAgICAgICAgIHN0YXRlID0geyB1cDogc3RhdGUsIG46IHN0YXRlLm4uciwgczogMCB9O1xuICAgICAgICAgICAgICBjb250aW51ZTsgLy8gV2lsbCBmYWxsIGluIHRvIGNhc2UgMCB3aXRoIGZhc3QgZm9yd2FyZCB0byBsZWZ0IGxlYWYgb2YgdGhpcyBzdWJ0cmVlLlxuICAgICAgICAgICAgfVxuICAgICAgICAgIC8vIGludGVudGlvbmFsbHkgZmFsbCBpbnRvIGNhc2UgMzpcbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBzdGF0ZSA9IHN0YXRlLnVwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4geyBkb25lOiB0cnVlIH07XG4gICAgfSxcbiAgfSBhcyBHZW5lcmF0b3I8SW50ZXJ2YWxUcmVlTm9kZSwgdW5kZWZpbmVkLCBJbmRleGFibGVUeXBlPjtcbn1cblxuZnVuY3Rpb24gcmViYWxhbmNlKHRhcmdldDogSW50ZXJ2YWxUcmVlTm9kZSkge1xuICBjb25zdCBkaWZmID0gKHRhcmdldC5yPy5kIHx8IDApIC0gKHRhcmdldC5sPy5kIHx8IDApO1xuICBjb25zdCByID0gZGlmZiA+IDEgPyBcInJcIiA6IGRpZmYgPCAtMSA/IFwibFwiIDogXCJcIjtcbiAgaWYgKHIpIHtcblxuICAgIC8vIFJvdGF0ZSAoaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVHJlZV9yb3RhdGlvbilcbiAgICAvL1xuICAgIC8vIFxuICAgIC8vICAgICAgICAgICAgICAgICAgICBbT0xEUk9PVF1cbiAgICAvLyAgICAgICBbT0xEUk9PVC5MXSAgICAgICAgICAgIFtORVdST09UXVxuICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgW05FV1JPT1QuTF0gW05FV1JPT1QuUl1cbiAgICAvL1xuICAgIC8vIElzIGdvaW5nIHRvIGJlY29tZTpcbiAgICAvL1xuICAgIC8vIFxuICAgIC8vICAgICAgICAgICAgICAgICAgICBbTkVXUk9PVF1cbiAgICAvLyAgICAgICAgW09MRFJPT1RdICAgICAgICAgICAgIFtORVdST09ULlJdXG4gICAgLy8gW09MRFJPT1QuTF0gW05FV1JPT1QuTF0gIFxuXG4gICAgLy8gKiBjbG9uZSBub3cgaGFzIHRoZSBwcm9wcyBvZiBPTERST09UXG4gICAgLy8gUGxhbjpcbiAgICAvLyAqIHRhcmdldCBtdXN0IGJlIGdpdmVuIHRoZSBwcm9wcyBvZiBORVdST09UXG4gICAgLy8gKiB0YXJnZXRbbF0gbXVzdCBwb2ludCB0byBhIG5ldyBPTERST09UXG4gICAgLy8gKiB0YXJnZXRbcl0gbXVzdCBwb2ludCB0byBORVdST09ULlJcbiAgICAvLyAqIE9MRFJPT1Rbcl0gbXVzdCBwb2ludCB0byBORVdST09ULkxcbiAgICBjb25zdCBsID0gciA9PT0gXCJyXCIgPyBcImxcIiA6IFwiclwiOyAvLyBTdXBwb3J0IGJvdGggbGVmdC9yaWdodCByb3RhdGlvblxuICAgIGNvbnN0IHJvb3RDbG9uZSA9IHsgLi4udGFyZ2V0IH07XG4gICAgLy8gV2UncmUgZ29ubmEgY29weSBwcm9wcyBmcm9tIHRhcmdldCdzIHJpZ2h0IG5vZGUgaW50byB0YXJnZXQgc28gdGhhdCB0YXJnZXQgd2lsbFxuICAgIC8vIGhhdmUgc2FtZSByYW5nZSBhcyBvbGQgdGFyZ2V0W3JdIChpbnN0ZWFkIG9mIGNoYW5naW5nIHBvaW50ZXJzLCB3ZSBjb3B5IHZhbHVlcy5cbiAgICAvLyB0aGF0IHdheSB3ZSBkbyBub3QgbmVlZCB0byBhZGp1c3QgcG9pbnRlcnMgaW4gcGFyZW50cykuXG4gICAgY29uc3Qgb2xkUm9vdFJpZ2h0ID0gdGFyZ2V0W3JdOyBcbiAgICB0YXJnZXQuZnJvbSA9IG9sZFJvb3RSaWdodC5mcm9tO1xuICAgIHRhcmdldC50byA9IG9sZFJvb3RSaWdodC50bztcbiAgICB0YXJnZXRbcl0gPSBvbGRSb290UmlnaHRbcl07XG4gICAgcm9vdENsb25lW3JdID0gb2xkUm9vdFJpZ2h0W2xdO1xuICAgIHRhcmdldFtsXSA9IHJvb3RDbG9uZTtcbiAgICByb290Q2xvbmUuZCA9IGNvbXB1dGVEZXB0aChyb290Q2xvbmUpO1xuICB9XG4gIHRhcmdldC5kID0gY29tcHV0ZURlcHRoKHRhcmdldCk7XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVEZXB0aCh7IHIsIGwgfTogUGljazxJbnRlcnZhbFRyZWVOb2RlLCBcImxcIiB8IFwiclwiPikge1xuICByZXR1cm4gKHIgPyAobCA/IE1hdGgubWF4KHIuZCwgbC5kKSA6IHIuZCkgOiBsID8gbC5kIDogMCkgKyAxO1xufVxuIiwgImltcG9ydCB7IGdldEZyb21UcmFuc2FjdGlvbkNhY2hlIH0gZnJvbSBcIi4uL2RiY29yZS9jYWNoZS1leGlzdGluZy12YWx1ZXMtbWlkZGxld2FyZVwiO1xuaW1wb3J0IHsgY21wIH0gZnJvbSBcIi4uL2Z1bmN0aW9ucy9jbXBcIjtcbmltcG9ydCB7IGlzQXJyYXksIGtleXMgfSBmcm9tIFwiLi4vZnVuY3Rpb25zL3V0aWxzXCI7XG5pbXBvcnQgeyBQU0QgfSBmcm9tIFwiLi4vaGVscGVycy9wcm9taXNlXCI7XG5pbXBvcnQgeyBSYW5nZVNldCB9IGZyb20gXCIuLi9oZWxwZXJzL3Jhbmdlc2V0XCI7XG5pbXBvcnQgeyBPYnNlcnZhYmlsaXR5U2V0IH0gZnJvbSBcIi4uL3B1YmxpYy90eXBlcy9kYi1ldmVudHNcIjtcbmltcG9ydCB7XG4gIERCQ29yZSxcbiAgREJDb3JlQ291bnRSZXF1ZXN0LFxuICBEQkNvcmVDdXJzb3IsXG4gIERCQ29yZUdldE1hbnlSZXF1ZXN0LFxuICBEQkNvcmVHZXRSZXF1ZXN0LFxuICBEQkNvcmVJbmRleCxcbiAgREJDb3JlT3BlbkN1cnNvclJlcXVlc3QsXG4gIERCQ29yZVF1ZXJ5UmVxdWVzdCxcbiAgREJDb3JlUXVlcnlSZXNwb25zZSxcbiAgREJDb3JlVGFibGUsXG4gIERCQ29yZVRhYmxlU2NoZW1hLFxuICBEQkNvcmVUcmFuc2FjdGlvbixcbn0gZnJvbSBcIi4uL3B1YmxpYy90eXBlcy9kYmNvcmVcIjtcbmltcG9ydCB7IE1pZGRsZXdhcmUgfSBmcm9tIFwiLi4vcHVibGljL3R5cGVzL21pZGRsZXdhcmVcIjtcblxuZXhwb3J0IGNvbnN0IG9ic2VydmFiaWxpdHlNaWRkbGV3YXJlOiBNaWRkbGV3YXJlPERCQ29yZT4gPSB7XG4gIHN0YWNrOiBcImRiY29yZVwiLFxuICBsZXZlbDogMCxcbiAgY3JlYXRlOiAoY29yZSkgPT4ge1xuICAgIGNvbnN0IGRiTmFtZSA9IGNvcmUuc2NoZW1hLm5hbWU7XG4gICAgY29uc3QgRlVMTF9SQU5HRSA9IG5ldyBSYW5nZVNldChjb3JlLk1JTl9LRVksIGNvcmUuTUFYX0tFWSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgLi4uY29yZSxcbiAgICAgIHRhYmxlOiAodGFibGVOYW1lKSA9PiB7XG4gICAgICAgIGNvbnN0IHRhYmxlID0gY29yZS50YWJsZSh0YWJsZU5hbWUpO1xuICAgICAgICBjb25zdCB7IHNjaGVtYSB9ID0gdGFibGU7XG4gICAgICAgIGNvbnN0IHsgcHJpbWFyeUtleSB9ID0gc2NoZW1hO1xuICAgICAgICBjb25zdCB7IGV4dHJhY3RLZXksIG91dGJvdW5kIH0gPSBwcmltYXJ5S2V5O1xuICAgICAgICBjb25zdCB0YWJsZUNsb25lOiBEQkNvcmVUYWJsZSA9IHtcbiAgICAgICAgICAuLi50YWJsZSxcbiAgICAgICAgICBtdXRhdGU6IChyZXEpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zID0gcmVxLnRyYW5zIGFzIERCQ29yZVRyYW5zYWN0aW9uICYge1xuICAgICAgICAgICAgICBtdXRhdGVkUGFydHM/OiBPYnNlcnZhYmlsaXR5U2V0O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IG11dGF0ZWRQYXJ0cyA9XG4gICAgICAgICAgICAgIHRyYW5zLm11dGF0ZWRQYXJ0cyB8fCAodHJhbnMubXV0YXRlZFBhcnRzID0ge30pO1xuICAgICAgICAgICAgY29uc3QgZ2V0UmFuZ2VTZXQgPSAoaW5kZXhOYW1lOiBzdHJpbmcpID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgcGFydCA9IGBpZGI6Ly8ke2RiTmFtZX0vJHt0YWJsZU5hbWV9LyR7aW5kZXhOYW1lfWA7XG4gICAgICAgICAgICAgIHJldHVybiAobXV0YXRlZFBhcnRzW3BhcnRdIHx8XG4gICAgICAgICAgICAgICAgKG11dGF0ZWRQYXJ0c1twYXJ0XSA9IG5ldyBSYW5nZVNldCgpKSkgYXMgUmFuZ2VTZXQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgcGtSYW5nZVNldCA9IGdldFJhbmdlU2V0KFwiXCIpO1xuICAgICAgICAgICAgY29uc3QgZGVsc1JhbmdlU2V0ID0gZ2V0UmFuZ2VTZXQoXCI6ZGVsc1wiKTtcblxuICAgICAgICAgICAgY29uc3QgeyB0eXBlIH0gPSByZXE7XG4gICAgICAgICAgICBsZXQgW2tleXMsIG5ld09ianNdID1cbiAgICAgICAgICAgICAgcmVxLnR5cGUgPT09IFwiZGVsZXRlUmFuZ2VcIlxuICAgICAgICAgICAgICAgID8gW3JlcS5yYW5nZV0gLy8ga2V5cyB3aWxsIGJlIGFuIERCQ29yZUtleVJhbmdlIG9iamVjdCAtIHRyYW5zZm9ybWVkIGxhdGVyIG9uIHRvIGEgW2Zyb20sdG9dLXN0eWxlIHJhbmdlLlxuICAgICAgICAgICAgICAgIDogcmVxLnR5cGUgPT09IFwiZGVsZXRlXCJcbiAgICAgICAgICAgICAgICA/IFtyZXEua2V5c10gLy8ga2V5cyBrbm93biBhbHJlYWR5IGhlcmUuIG5ld09ianMgd2lsbCBiZSB1bmRlZmluZWQuXG4gICAgICAgICAgICAgICAgOiByZXEudmFsdWVzLmxlbmd0aCA8IDUwXG4gICAgICAgICAgICAgICAgPyBbW10sIHJlcS52YWx1ZXNdIC8vIGtleXMgPSBlbXB0eSBhcnJheSAtIHdpbGwgYmUgcmVzb2x2ZWQgaW4gbXV0YXRlKCkudGhlbiguLi4pLlxuICAgICAgICAgICAgICAgIDogW107IC8vIGtleXMgYW5kIG5ld09ianMgd2lsbCBib3RoIGJlIHVuZGVmaW5lZCAtIGNoYW5nZVNwZWMgd2lsbCBiZWNvbWUgdHJ1ZSAoY2hhbmdlZCBmb3IgZW50aXJlIHRhYmxlKVxuICAgICAgICAgICAgY29uc3Qgb2xkQ2FjaGUgPSByZXEudHJhbnNbXCJfY2FjaGVcIl07XG4gICAgICAgICAgICByZXR1cm4gdGFibGUubXV0YXRlKHJlcSkudGhlbigocmVzKSA9PiB7XG4gICAgICAgICAgICAgIC8vIEFkZCB0aGUgbXV0YXRlZCB0YWJsZSBhbmQgb3B0aW9uYWxseSBrZXlzIHRvIHRoZSBtdXRhdGVkVGFibGVzIHNldCBvbiB0aGUgdHJhbnNhY3Rpb24uXG4gICAgICAgICAgICAgIC8vIFVzZWQgYnkgc3Vic2NyaWJlcnMgdG8gdHhjb21taXQgZXZlbnQgYW5kIGZvciBDb2xsZWN0aW9uLnByb3RvdHlwZS5zdWJzY3JpYmUoKS5cbiAgICAgICAgICAgICAgaWYgKGlzQXJyYXkoa2V5cykpIHtcbiAgICAgICAgICAgICAgICAvLyBrZXlzIGlzIGFuIGFycmF5IC0gZGVsZXRlLCBhZGQgb3IgcHV0IG9mIGxlc3MgdGhhbiA1MCByb3dzLlxuICAgICAgICAgICAgICAgIGlmICh0eXBlICE9PSBcImRlbGV0ZVwiKSBrZXlzID0gcmVzLnJlc3VsdHM7XG4gICAgICAgICAgICAgICAgLy8gaW5kaXZpZHVhbCBrZXlzIChhZGQgcHV0IG9yIGRlbGV0ZSlcbiAgICAgICAgICAgICAgICBwa1JhbmdlU2V0LmFkZEtleXMoa2V5cyk7XG4gICAgICAgICAgICAgICAgLy8gT25seSBnZXQgb2xkT2JqcyBpZiB0aGV5IGhhdmUgYmVlbiBjYWNoZWQgcmVjZW50bHlcbiAgICAgICAgICAgICAgICAvLyAoVGhpcyBhcHBsaWVzIHRvIENvbGxlY3Rpb24ubW9kaWZ5KCkgb25seSwgYnV0IGFsc28gaWYgdXBkYXRpbmcvZGVsZXRpbmcgaG9va3MgaGF2ZSBzdWJzY3JpYmVycylcbiAgICAgICAgICAgICAgICBjb25zdCBvbGRPYmpzID0gZ2V0RnJvbVRyYW5zYWN0aW9uQ2FjaGUoa2V5cywgb2xkQ2FjaGUpO1xuXG4gICAgICAgICAgICAgICAgLy8gU3VwcGx5IGRldGFpbGVkIHZhbHVlcyBwZXIgaW5kZXggZm9yIGJvdGggb2xkIGFuZCBuZXcgb2JqZWN0czpcbiAgICAgICAgICAgICAgICBpZiAoIW9sZE9ianMgJiYgdHlwZSAhPT0gXCJhZGRcIikge1xuICAgICAgICAgICAgICAgICAgLy8gZGVsZXRlIG9yIHB1dCBhbmQgd2UgZG9uJ3Qga25vdyBvbGQgdmFsdWVzLlxuICAgICAgICAgICAgICAgICAgLy8gSW5kaWNhdGUgdGhpcyBpbiB0aGUgXCI6ZGVsc1wiIHBhcnQsIGZvciB0aGUgc2FrZSBvZiBjb3VudCgpIHF1ZXJpZXMgb25seSFcbiAgICAgICAgICAgICAgICAgIGRlbHNSYW5nZVNldC5hZGRLZXlzKGtleXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAob2xkT2JqcyB8fCBuZXdPYmpzKSB7XG4gICAgICAgICAgICAgICAgICAvLyBObyBtYXR0ZXIgaWYga25vd25pbmcgb2xkT2JqcyBvciBub3QsIHRyYWNrIHRoZSBpbmRpY2VzIGlmIGl0J3MgYSBwdXQsIGFkZCBvciBkZWxldGUuXG4gICAgICAgICAgICAgICAgICB0cmFja0FmZmVjdGVkSW5kZXhlcyhnZXRSYW5nZVNldCwgc2NoZW1hLCBvbGRPYmpzLCBuZXdPYmpzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoa2V5cykge1xuICAgICAgICAgICAgICAgIC8vIEFzIHdlIGNhbid0IGtub3cgZGVsZXRlZCBpbmRleCByYW5nZXMsIG1hcmsgaW5kZXgtYmFzZWQgc3Vic2NyaXB0aW9ucyBtdXN0IHRyaWdnZXIuXG4gICAgICAgICAgICAgICAgY29uc3QgcmFuZ2UgPSB7IGZyb206IGtleXMubG93ZXIsIHRvOiBrZXlzLnVwcGVyIH07XG4gICAgICAgICAgICAgICAgZGVsc1JhbmdlU2V0LmFkZChyYW5nZSk7XG4gICAgICAgICAgICAgICAgLy8gZGVsZXRlUmFuZ2UuIGtleXMgaXMgYSBEQkNvcmVLZXlSYW5nZSBvYmplY3RzLiBUcmFuc2Zvcm0gaXQgdG8gW2Zyb20sdG9dLXN0eWxlIHJhbmdlLlxuICAgICAgICAgICAgICAgIHBrUmFuZ2VTZXQuYWRkKHJhbmdlKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBUb28gbWFueSByZXF1ZXN0cyB0byByZWNvcmQgdGhlIGRldGFpbHMgd2l0aG91dCBzbG93aW5nIGRvd24gd3JpdGUgcGVyZm9ybWFuY2UuXG4gICAgICAgICAgICAgICAgLy8gTGV0J3MganVzdCByZWNvcmQgYSBnZW5lcmljIGxhcmdlIHJhbmdlIG9uIHByaW1hcnkga2V5LCB0aGUgdmlydHVhbCA6ZGVscyBpbmRleCBhbmRcbiAgICAgICAgICAgICAgICAvLyBhbGwgc2Vjb25kYXJ5IGluZGljZXM6XG4gICAgICAgICAgICAgICAgcGtSYW5nZVNldC5hZGQoRlVMTF9SQU5HRSk7XG4gICAgICAgICAgICAgICAgZGVsc1JhbmdlU2V0LmFkZChGVUxMX1JBTkdFKTtcbiAgICAgICAgICAgICAgICBzY2hlbWEuaW5kZXhlcy5mb3JFYWNoKGlkeCA9PiBnZXRSYW5nZVNldChpZHgubmFtZSkuYWRkKEZVTExfUkFOR0UpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBnZXRSYW5nZTogKHJlcTogYW55KSA9PiBbREJDb3JlSW5kZXgsIFJhbmdlU2V0XSA9ICh7XG4gICAgICAgICAgcXVlcnk6IHsgaW5kZXgsIHJhbmdlIH0sXG4gICAgICAgIH06XG4gICAgICAgICAgfCBEQkNvcmVRdWVyeVJlcXVlc3RcbiAgICAgICAgICB8IERCQ29yZUNvdW50UmVxdWVzdFxuICAgICAgICAgIHwgREJDb3JlT3BlbkN1cnNvclJlcXVlc3QpID0+IFtcbiAgICAgICAgICBpbmRleCxcbiAgICAgICAgICBuZXcgUmFuZ2VTZXQocmFuZ2UubG93ZXIgPz8gY29yZS5NSU5fS0VZLCByYW5nZS51cHBlciA/PyBjb3JlLk1BWF9LRVkpLFxuICAgICAgICBdO1xuXG4gICAgICAgIGNvbnN0IHJlYWRTdWJzY3JpYmVyczoge1ttZXRob2QgaW5cbiAgICAgICAgICBFeGNsdWRlPGtleW9mIERCQ29yZVRhYmxlLCBcIm5hbWVcIiB8IFwic2NoZW1hXCIgfCBcIm11dGF0ZVwiPl06IFxuICAgICAgICAgIChyZXE6IGFueSkgPT4gW0RCQ29yZUluZGV4LCBSYW5nZVNldF1cbiAgICAgICAgfSA9IHtcbiAgICAgICAgICBnZXQ6IChyZXEpID0+IFtwcmltYXJ5S2V5LCBuZXcgUmFuZ2VTZXQocmVxLmtleSldLFxuICAgICAgICAgIGdldE1hbnk6IChyZXEpID0+IFtwcmltYXJ5S2V5LCBuZXcgUmFuZ2VTZXQoKS5hZGRLZXlzKHJlcS5rZXlzKV0sXG4gICAgICAgICAgY291bnQ6IGdldFJhbmdlLFxuICAgICAgICAgIHF1ZXJ5OiBnZXRSYW5nZSxcbiAgICAgICAgICBvcGVuQ3Vyc29yOiBnZXRSYW5nZSxcbiAgICAgICAgfVxuXG4gICAgICAgIGtleXMocmVhZFN1YnNjcmliZXJzKS5mb3JFYWNoKG1ldGhvZCA9PiB7XG4gICAgICAgICAgdGFibGVDbG9uZVttZXRob2RdID0gZnVuY3Rpb24gKFxuICAgICAgICAgICAgcmVxOlxuICAgICAgICAgICAgICB8IERCQ29yZUdldFJlcXVlc3RcbiAgICAgICAgICAgICAgfCBEQkNvcmVHZXRNYW55UmVxdWVzdFxuICAgICAgICAgICAgICB8IERCQ29yZVF1ZXJ5UmVxdWVzdFxuICAgICAgICAgICAgICB8IERCQ29yZUNvdW50UmVxdWVzdFxuICAgICAgICAgICAgICB8IERCQ29yZU9wZW5DdXJzb3JSZXF1ZXN0XG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBjb25zdCB7IHN1YnNjciB9ID0gUFNEO1xuICAgICAgICAgICAgaWYgKHN1YnNjcikge1xuICAgICAgICAgICAgICAvLyBDdXJyZW50IHpvbmUgd2FudCdzIHRvIHRyYWNrIGFsbCBxdWVyaWVzIHNvIHRoZXkgY2FuIGJlIHN1YnNjcmliZWQgdG8uXG4gICAgICAgICAgICAgIC8vIChUaGUgcXVlcnkgaXMgZXhlY3V0ZWQgd2l0aGluIGEgXCJsaXZlUXVlcnlcIiB6b25lKVxuICAgICAgICAgICAgICAvLyBDaGVjayB3aGV0aGVyIHRoZSBxdWVyeSBhcHBsaWVzIHRvIGEgY2VydGFpbiBzZXQgb2YgcmFuZ2VzOlxuICAgICAgICAgICAgICAvLyBUcmFjayB3aGF0IHdlIHNob3VsZCBiZSBvYnNlcnZpbmc6XG4gICAgICAgICAgICAgIGNvbnN0IGdldFJhbmdlU2V0ID0gKGluZGV4TmFtZTogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFydCA9IGBpZGI6Ly8ke2RiTmFtZX0vJHt0YWJsZU5hbWV9LyR7aW5kZXhOYW1lfWA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChzdWJzY3JbcGFydF0gfHxcbiAgICAgICAgICAgICAgICAgIChzdWJzY3JbcGFydF0gPSBuZXcgUmFuZ2VTZXQoKSkpIGFzIFJhbmdlU2V0O1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBjb25zdCBwa1JhbmdlU2V0ID0gZ2V0UmFuZ2VTZXQoXCJcIik7XG4gICAgICAgICAgICAgIGNvbnN0IGRlbHNSYW5nZVNldCA9IGdldFJhbmdlU2V0KFwiOmRlbHNcIik7XG4gICAgICAgICAgICAgIGNvbnN0IFtxdWVyaWVkSW5kZXgsIHF1ZXJpZWRSYW5nZXNdID0gcmVhZFN1YnNjcmliZXJzW21ldGhvZF0ocmVxKTtcbiAgICAgICAgICAgICAgLy8gQSBnZW5lcmljIHJ1bGUgaGVyZTogcXVlcmllZCByYW5nZXMgc2hvdWxkIGFsd2F5cyBiZSBzdWJzY3JpYmVkIHRvLlxuICAgICAgICAgICAgICBnZXRSYW5nZVNldChxdWVyaWVkSW5kZXgubmFtZSB8fCBcIlwiKS5hZGQocXVlcmllZFJhbmdlcyk7XG4gICAgICAgICAgICAgIGlmICghcXVlcmllZEluZGV4LmlzUHJpbWFyeUtleSkge1xuICAgICAgICAgICAgICAgIC8vIE9ubHkgY291bnQoKSwgcXVlcnkoKSBhbmQgb3BlbkN1cnNvcigpIG9wZXJhdGVzIG9uIHNlY29uZGFyeSBpbmRpY2VzLlxuICAgICAgICAgICAgICAgIC8vIFNpbmNlIHB1dCgpLCBkZWxldGUoKSBhbmQgZGVsZXRlUmFuZ2UoKSBtdXRhdGlvbnMgbWF5IGhhcHBlbiB3aXRob3V0IGtub3dpbmcgb2xkT2JqcyxcbiAgICAgICAgICAgICAgICAvLyB0aGUgbXV0YXRlKCkgbWV0aG9kIHdpbGwgYmUgbWlzc2luZyB3aGF0IHNlY29uZGFyeSBpbmRpY2VzIHRoYXQgYXJlIGJlaW5nIGRlbGV0ZWQgZnJvbVxuICAgICAgICAgICAgICAgIC8vIHRoZSBzdWJzY3JpYmVkIHJhbmdlLiBXZSBhcmUgd29ya2luZyBhcm91bmQgdGhpcyBpc3N1ZSBieSByZWNvcmRpbmcgYWxsIHRoZSByZXN1bHRpbmdcbiAgICAgICAgICAgICAgICAvLyBwcmltYXJ5IGtleXMgZnJvbSB0aGUgcXVlcmllcy4gVGhpcyBvbmx5IHdvcmtzIGZvciB0aG9zZSBraW5kcyBvZiBxdWVyaWVzIHdoZXJlIHdlIGNhblxuICAgICAgICAgICAgICAgIC8vIGRlcml2ZSB0aGUgcHJpbWFyeSBrZXkgZnJvbSB0aGUgcmVzdWx0LlxuICAgICAgICAgICAgICAgIC8vIEluIHRoaXMgYmxvY2sgd2UgYXJlIGFjY29tcGxpc2hpbmcgdGhpcyB1c2luZyB2YXJpb3VzIHN0cmF0ZWdpZXMgZGVwZW5kaW5nIG9uIHRoZSBwcm9wZXJ0aWVzXG4gICAgICAgICAgICAgICAgLy8gb2YgdGhlIHF1ZXJ5IHJlc3VsdC5cblxuICAgICAgICAgICAgICAgIGlmIChtZXRob2QgPT09IFwiY291bnRcIikge1xuICAgICAgICAgICAgICAgICAgLy8gV2UndmUgZ290IGEgcHJvYmxlbSEgRGVsZXRlIGFuZCBwdXQgbXV0YXRpb25zIGhhcHBlbiB3aXRob3V0IGtub3duIHRoZSBvbGRPYmpzLlxuICAgICAgICAgICAgICAgICAgLy8gVGhvc2UgbXV0YXRpb24gY291bGQgY2hhbmdlIHRoZSBjb3VudC5cbiAgICAgICAgICAgICAgICAgIC8vIFNvbHV0aW9uOiBEZWRpY2F0ZWQgXCI6ZGVsc1wiIHVybCByZXByZXNlbmRzIGEgc3Vic2NyaXB0aW9uIHRvIGFsbCBtdXRhdGlvbnMgd2l0aG91dCBvbGRPYmpzXG4gICAgICAgICAgICAgICAgICAvLyAoc3BlY2lhbGx5IHRyaWdnZXJlZCBpbiB0aGUgbXV0YXRvcnMgcHV0KCksIGRlbGV0ZSgpIGFuZCBkZWxldGVSYW5nZSgpIHdoZW4gdGhleSBkb24ndCBrbm93IG9sZE9iamVjdClcbiAgICAgICAgICAgICAgICAgIGRlbHNSYW5nZVNldC5hZGQoRlVMTF9SQU5HRSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIC8vIG9wZW5DdXJzb3IoKSBvciBxdWVyeSgpXG5cbiAgICAgICAgICAgICAgICAgIC8vIFByZXBhcmUgYSBrZXlzUHJvbWlzZSBpbiBjYXNlIHRoZSB3ZSdyZSBkb2luZyBhbiBJREJJbmRleC5nZXRBbGwoKSBvbiBhIHN0b3JlIHdpdGggb3V0Ym91bmQga2V5cy5cbiAgICAgICAgICAgICAgICAgIGNvbnN0IGtleXNQcm9taXNlID1cbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kID09PSBcInF1ZXJ5XCIgJiZcbiAgICAgICAgICAgICAgICAgICAgb3V0Ym91bmQgJiZcbiAgICAgICAgICAgICAgICAgICAgKHJlcSBhcyBEQkNvcmVRdWVyeVJlcXVlc3QpLnZhbHVlcyAmJlxuICAgICAgICAgICAgICAgICAgICB0YWJsZS5xdWVyeSh7XG4gICAgICAgICAgICAgICAgICAgICAgLi4uKHJlcSBhcyBEQkNvcmVRdWVyeVJlcXVlc3QpLFxuICAgICAgICAgICAgICAgICAgICAgIHZhbHVlczogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICByZXR1cm4gdGFibGVbbWV0aG9kXS5hcHBseSh0aGlzLCBhcmd1bWVudHMpLnRoZW4oKHJlcykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAobWV0aG9kID09PSBcInF1ZXJ5XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAob3V0Ym91bmQgJiYgKHJlcSBhcyBEQkNvcmVRdWVyeVJlcXVlc3QpLnZhbHVlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYga2V5cyBhcmUgb3V0Ym91bmQsIHdlIGNhbid0IHVzZSBleHRyYWN0S2V5IHRvIG1hcCB3aGF0IGtleXMgdG8gb2JzZXJ2ZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlJ3ZlIHF1ZXJpZWQgYW4gaW5kZXggKGxpa2UgJ2RhdGVUaW1lJykgb24gYW4gb3V0Ym91bmQgdGFibGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFuZCByZXRyaWV2ZSBhIGxpc3Qgb2Ygb2JqZWN0c1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZnJvbSB3aG8gd2UgY2Fubm90IGtub3cgdGhlaXIgcHJpbWFyeSBrZXlzLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gXCJMdWNraWx5XCIgdGhvdWdoLCB3ZSd2ZSBwcmVwYXJlZCB0aGUga2V5c1Byb21pc2UgdG8gYXNzaXN0IHVzIGluIGV4YWN0IHRoaXMgY29uZGl0aW9uLlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGtleXNQcm9taXNlLnRoZW4oXG4gICAgICAgICAgICAgICAgICAgICAgICAgICh7IHJlc3VsdDogcmVzdWx0aW5nS2V5cyB9OiBEQkNvcmVRdWVyeVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGtSYW5nZVNldC5hZGRLZXlzKHJlc3VsdGluZ0tleXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIC8vIHF1ZXJ5KCkgaW5ib3VuZCB2YWx1ZXMsIGtleXMgb3Igb3V0Ym91bmQga2V5cy4gU2Vjb25kYXJ5IGluZGV4ZXMgb25seSBzaW5jZVxuICAgICAgICAgICAgICAgICAgICAgIC8vIGZvciBwcmltYXJ5IGtleXMgd2Ugd291bGQgb25seSBhZGQgcmVzdWx0cyB3aXRoaW4gdGhlIGFscmVhZHkgcmVnaXN0ZXJlZCByYW5nZS5cbiAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwS2V5cyA9IChyZXEgYXMgREJDb3JlUXVlcnlSZXF1ZXN0KS52YWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgICAgID8gKHJlcyBhcyBEQkNvcmVRdWVyeVJlc3BvbnNlKS5yZXN1bHQubWFwKGV4dHJhY3RLZXkpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IChyZXMgYXMgREJDb3JlUXVlcnlSZXNwb25zZSkucmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgIGlmICgocmVxIGFzIERCQ29yZVF1ZXJ5UmVxdWVzdCkudmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTdWJzY3JpYmUgdG8gYW55IG11dGF0aW9uIG1hZGUgb24gdGhlIHJldHVybmVkIGtleXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzbyB0aGF0IHdlIGRldGVjdCBib3RoIGRlbGV0aW9ucyBhbmQgdXBkYXRlZCBwcm9wZXJ0aWVzLlxuICAgICAgICAgICAgICAgICAgICAgICAgcGtSYW5nZVNldC5hZGRLZXlzKHBLZXlzKTtcbiAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3Vic2NyaWJlIG9ubHkgdG8gbXV0YXRpb25zIG9uIHRoZSByZXR1cm5lZCBrZXlzXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpbiBjYXNlIHRoZSBtdXRhdG9yIHdhcyB1bmFibGUgdG8ga25vdyBvbGRPYmpzLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgaXQgaGFzIG9sZE9iaiwgdGhlIG11dGF0b3Igd29uJ3QgcHV0IGFueXRoaW5nIGluIFwiOmRlbHNcIiBiZWNhdXNlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpdCBjYW4gbW9yZSBmaW5lLWdyYWluZWQgcHV0IHRoZSBleGFjdCByZW1vdmVkIGFuZCBhZGRlZCBpbmRleCB2YWx1ZSBpbiB0aGUgY29ycmVjdFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW5kZXggcmFuZ2UgdGhhdCB3ZSBzdWJzY3JpYmUgdG8gaW4gdGhlIHF1ZXJpZWQgcmFuZ2Ugc2V0cy5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGRvbid0IGxvYWQgdmFsdWVzIHNvIGEgY2hhbmdlIG9uIGEgcHJvcGVydHkgb3V0c2lkZSBvdXIgaW5kZXggd2lsbCBub3RcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlcXVpcmUgdXMgdG8gcmUtZXhlY3V0ZSB0aGUgcXVlcnkuXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxzUmFuZ2VTZXQuYWRkS2V5cyhwS2V5cyk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG1ldGhvZCA9PT0gXCJvcGVuQ3Vyc29yXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBDYWxsZXIgcmVxdWVzdHMgYSBjdXJzb3IuXG4gICAgICAgICAgICAgICAgICAgICAgLy8gRm9yIHRoZSBzYW1lIHJlYXNvbiBhcyB3aGVuIG1ldGhvZD09PVwicXVlcnlcIiwgd2Ugb25seSBuZWVkIHRvIG9ic2VydmVcbiAgICAgICAgICAgICAgICAgICAgICAvLyB0aG9zZSBrZXlzIHdob3NlIHZhbHVlcyBhcmUgcG9zc2libHkgdXNlZCBvciByZW5kZXJlZCAtIHdoaWNoIGNvdWxkXG4gICAgICAgICAgICAgICAgICAgICAgLy8gb25seSBoYXBwZW4gb24ga2V5cyB3aGVyZSB0aGV5IGdldCB0aGUgY3Vyc29yJ3Mga2V5LCBwcmltYXJ5S2V5IG9yIHZhbHVlLlxuICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1cnNvcjogREJDb3JlQ3Vyc29yIHwgbnVsbCA9IHJlcztcbiAgICAgICAgICAgICAgICAgICAgICBjb25zdCB3YW50VmFsdWVzID0gKHJlcSBhcyBEQkNvcmVPcGVuQ3Vyc29yUmVxdWVzdCkudmFsdWVzO1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3IgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5jcmVhdGUoY3Vyc29yLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGtleToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbHNSYW5nZVNldC5hZGRLZXkoY3Vyc29yLnByaW1hcnlLZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN1cnNvci5rZXk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcHJpbWFyeUtleToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBrZXkgPSBjdXJzb3IucHJpbWFyeUtleTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbHNSYW5nZVNldC5hZGRLZXkocGtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGtleTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhbnRWYWx1ZXMgJiYgcGtSYW5nZVNldC5hZGRLZXkoY3Vyc29yLnByaW1hcnlLZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN1cnNvci52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0YWJsZVttZXRob2RdLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0YWJsZUNsb25lO1xuICAgICAgfSxcbiAgICB9O1xuICB9LFxufTtcblxuZnVuY3Rpb24gdHJhY2tBZmZlY3RlZEluZGV4ZXMoXG4gIGdldFJhbmdlU2V0OiAoaW5kZXg6IHN0cmluZykgPT4gUmFuZ2VTZXQsXG4gIHNjaGVtYTogREJDb3JlVGFibGVTY2hlbWEsXG4gIG9sZE9ianM6IGFueVtdIHwgdW5kZWZpbmVkLFxuICBuZXdPYmpzOiBhbnlbXSB8IHVuZGVmaW5lZFxuKSB7XG4gIGZ1bmN0aW9uIGFkZEFmZmVjdGVkSW5kZXgoaXg6IERCQ29yZUluZGV4KSB7XG4gICAgY29uc3QgcmFuZ2VTZXQgPSBnZXRSYW5nZVNldChpeC5uYW1lIHx8IFwiXCIpO1xuICAgIGZ1bmN0aW9uIGV4dHJhY3RLZXkob2JqOiBhbnkpIHtcbiAgICAgIHJldHVybiBvYmogIT0gbnVsbCA/IGl4LmV4dHJhY3RLZXkob2JqKSA6IG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGFkZEtleU9yS2V5cyA9IChrZXk6IGFueSkgPT4gaXgubXVsdGlFbnRyeSAmJiBpc0FycmF5KGtleSlcbiAgICAgIC8vIG11bHRpRW50cnkgYW5kIHRoZSBvbGQgcHJvcGVydHkgd2FzIGFuIGFycmF5IC0gYWRkIGVhY2ggYXJyYXkgZW50cnkgdG8gdGhlIHJhbmdlU2V0OlxuICAgICAgPyBrZXkuZm9yRWFjaChrZXkgPT4gcmFuZ2VTZXQuYWRkS2V5KGtleSkpXG4gICAgICAvLyBOb3QgbXVsdGlFbnRyeSBvciB0aGUgb2xkIHByb3BlcnR5IHdhcyBub3QgYW4gYXJyYXkgLSBhZGQgZWFjaCBhcnJheSBlbnRyeSB0byB0aGUgcmFuZ2VTZXQ6XG4gICAgICA6IHJhbmdlU2V0LmFkZEtleShrZXkpO1xuXG4gICAgKG9sZE9ianMgfHwgbmV3T2JqcykuZm9yRWFjaCgoXywgaSkgPT4ge1xuICAgICAgY29uc3Qgb2xkS2V5ID0gb2xkT2JqcyAmJiBleHRyYWN0S2V5KG9sZE9ianNbaV0pO1xuICAgICAgY29uc3QgbmV3S2V5ID0gbmV3T2JqcyAmJiBleHRyYWN0S2V5KG5ld09ianNbaV0pO1xuICAgICAgaWYgKGNtcChvbGRLZXksIG5ld0tleSkgIT09IDApIHtcbiAgICAgICAgLy8gVGhlIGluZGV4IGhhcyBjaGFuZ2VkLiBBZGQgYm90aCBvbGQgYW5kIG5ldyB2YWx1ZSBvZiB0aGUgaW5kZXguXG4gICAgICAgIGlmIChvbGRLZXkgIT0gbnVsbCkgYWRkS2V5T3JLZXlzKG9sZEtleSk7IC8vIElmIG9sZEtleSBpcyBpbnZhbGlkIGtleSwgYWRkS2V5KCkgd2lsbCBiZSBhIG5vb3AuXG4gICAgICAgIGlmIChuZXdLZXkgIT0gbnVsbCkgYWRkS2V5T3JLZXlzKG5ld0tleSk7IC8vIElmIG5ld0tleSBpcyBpbnZhbGlkIGtleSwgYWRkS2V5KCkgd2lsbCBiZSBhIG5vb3AuXG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgc2NoZW1hLmluZGV4ZXMuZm9yRWFjaChhZGRBZmZlY3RlZEluZGV4KTtcbn1cbiIsICIvLyBJbXBvcnQgdHlwZXMgZnJvbSB0aGUgcHVibGljIEFQSVxuaW1wb3J0IHsgRGV4aWUgYXMgSURleGllIH0gZnJvbSBcIi4uLy4uL3B1YmxpYy90eXBlcy9kZXhpZVwiO1xuaW1wb3J0IHsgRGV4aWVPcHRpb25zLCBEZXhpZUNvbnN0cnVjdG9yIH0gZnJvbSBcIi4uLy4uL3B1YmxpYy90eXBlcy9kZXhpZS1jb25zdHJ1Y3RvclwiO1xuaW1wb3J0IHsgRGJFdmVudHMgfSBmcm9tIFwiLi4vLi4vcHVibGljL3R5cGVzL2RiLWV2ZW50c1wiO1xuLy9pbXBvcnQgeyBQcm9taXNlRXh0ZW5kZWQsIFByb21pc2VFeHRlbmRlZENvbnN0cnVjdG9yIH0gZnJvbSAnLi4vLi4vcHVibGljL3R5cGVzL3Byb21pc2UtZXh0ZW5kZWQnO1xuaW1wb3J0IHsgVGFibGUgYXMgSVRhYmxlIH0gZnJvbSAnLi4vLi4vcHVibGljL3R5cGVzL3RhYmxlJztcbmltcG9ydCB7IFRhYmxlU2NoZW1hIH0gZnJvbSBcIi4uLy4uL3B1YmxpYy90eXBlcy90YWJsZS1zY2hlbWFcIjtcbmltcG9ydCB7IERiU2NoZW1hIH0gZnJvbSAnLi4vLi4vcHVibGljL3R5cGVzL2RiLXNjaGVtYSc7XG5cbi8vIEludGVybmFsIGltcG9ydHNcbmltcG9ydCB7IFRhYmxlLCBUYWJsZUNvbnN0cnVjdG9yLCBjcmVhdGVUYWJsZUNvbnN0cnVjdG9yIH0gZnJvbSBcIi4uL3RhYmxlXCI7XG5pbXBvcnQgeyBDb2xsZWN0aW9uLCBDb2xsZWN0aW9uQ29uc3RydWN0b3IsIGNyZWF0ZUNvbGxlY3Rpb25Db25zdHJ1Y3RvciB9IGZyb20gJy4uL2NvbGxlY3Rpb24nO1xuaW1wb3J0IHsgV2hlcmVDbGF1c2UgfSBmcm9tICcuLi93aGVyZS1jbGF1c2Uvd2hlcmUtY2xhdXNlJztcbmltcG9ydCB7IFdoZXJlQ2xhdXNlQ29uc3RydWN0b3IsIGNyZWF0ZVdoZXJlQ2xhdXNlQ29uc3RydWN0b3IgfSBmcm9tICcuLi93aGVyZS1jbGF1c2Uvd2hlcmUtY2xhdXNlLWNvbnN0cnVjdG9yJztcbmltcG9ydCB7IFRyYW5zYWN0aW9uIH0gZnJvbSAnLi4vdHJhbnNhY3Rpb24nO1xuaW1wb3J0IHsgVHJhbnNhY3Rpb25Db25zdHJ1Y3RvciwgY3JlYXRlVHJhbnNhY3Rpb25Db25zdHJ1Y3RvciB9IGZyb20gJy4uL3RyYW5zYWN0aW9uL3RyYW5zYWN0aW9uLWNvbnN0cnVjdG9yJztcbmltcG9ydCB7IFZlcnNpb24gfSBmcm9tIFwiLi4vdmVyc2lvbi92ZXJzaW9uXCI7XG5pbXBvcnQgeyBWZXJzaW9uQ29uc3RydWN0b3IsIGNyZWF0ZVZlcnNpb25Db25zdHJ1Y3RvciB9IGZyb20gJy4uL3ZlcnNpb24vdmVyc2lvbi1jb25zdHJ1Y3Rvcic7XG5cbi8vIE90aGVyIGltcG9ydHMuLi5cbmltcG9ydCB7IERleGllRXZlbnRTZXQgfSBmcm9tICcuLi8uLi9wdWJsaWMvdHlwZXMvZGV4aWUtZXZlbnQtc2V0JztcbmltcG9ydCB7IERleGllRXhjZXB0aW9uQ2xhc3NlcyB9IGZyb20gJy4uLy4uL3B1YmxpYy90eXBlcy9lcnJvcnMnO1xuaW1wb3J0IHsgRGV4aWVET01EZXBlbmRlbmNpZXMgfSBmcm9tICcuLi8uLi9wdWJsaWMvdHlwZXMvZGV4aWUtZG9tLWRlcGVuZGVuY2llcyc7XG5pbXBvcnQgeyBub3AsIHByb21pc2FibGVDaGFpbiB9IGZyb20gJy4uLy4uL2Z1bmN0aW9ucy9jaGFpbmluZy1mdW5jdGlvbnMnO1xuaW1wb3J0IFByb21pc2UsIHsgUFNEIH0gZnJvbSAnLi4vLi4vaGVscGVycy9wcm9taXNlJztcbmltcG9ydCB7IGV4dGVuZCwgb3ZlcnJpZGUsIGtleXMsIGhhc093biB9IGZyb20gJy4uLy4uL2Z1bmN0aW9ucy91dGlscyc7XG5pbXBvcnQgRXZlbnRzIGZyb20gJy4uLy4uL2hlbHBlcnMvRXZlbnRzJztcbmltcG9ydCB7IG1heFN0cmluZywgY29ubmVjdGlvbnMsIFJFQURPTkxZLCBSRUFEV1JJVEUgfSBmcm9tICcuLi8uLi9nbG9iYWxzL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBnZXRNYXhLZXkgfSBmcm9tICcuLi8uLi9mdW5jdGlvbnMvcXVpcmtzJztcbmltcG9ydCB7IGV4Y2VwdGlvbnMgfSBmcm9tICcuLi8uLi9lcnJvcnMnO1xuaW1wb3J0IHsgbG93ZXJWZXJzaW9uRmlyc3QgfSBmcm9tICcuLi92ZXJzaW9uL3NjaGVtYS1oZWxwZXJzJztcbmltcG9ydCB7IGRleGllT3BlbiB9IGZyb20gJy4vZGV4aWUtb3Blbic7XG5pbXBvcnQgeyB3cmFwIH0gZnJvbSAnLi4vLi4vaGVscGVycy9wcm9taXNlJztcbmltcG9ydCB7IF9vbkRhdGFiYXNlRGVsZXRlZCB9IGZyb20gJy4uLy4uL2hlbHBlcnMvZGF0YWJhc2UtZW51bWVyYXRvcic7XG5pbXBvcnQgeyBldmVudFJlamVjdEhhbmRsZXIgfSBmcm9tICcuLi8uLi9mdW5jdGlvbnMvZXZlbnQtd3JhcHBlcnMnO1xuaW1wb3J0IHsgZXh0cmFjdFRyYW5zYWN0aW9uQXJncywgZW50ZXJUcmFuc2FjdGlvblNjb3BlIH0gZnJvbSAnLi90cmFuc2FjdGlvbi1oZWxwZXJzJztcbmltcG9ydCB7IFRyYW5zYWN0aW9uTW9kZSB9IGZyb20gJy4uLy4uL3B1YmxpYy90eXBlcy90cmFuc2FjdGlvbi1tb2RlJztcbmltcG9ydCB7IHJlamVjdGlvbiB9IGZyb20gJy4uLy4uL2hlbHBlcnMvcHJvbWlzZSc7XG5pbXBvcnQgeyB1c2VQU0QgfSBmcm9tICcuLi8uLi9oZWxwZXJzL3Byb21pc2UnO1xuaW1wb3J0IHsgREJDb3JlIH0gZnJvbSAnLi4vLi4vcHVibGljL3R5cGVzL2RiY29yZSc7XG5pbXBvcnQgeyBNaWRkbGV3YXJlLCBEZXhpZVN0YWNrcyB9IGZyb20gJy4uLy4uL3B1YmxpYy90eXBlcy9taWRkbGV3YXJlJztcbmltcG9ydCB7IHZpcnR1YWxJbmRleE1pZGRsZXdhcmUgfSBmcm9tICcuLi8uLi9kYmNvcmUvdmlydHVhbC1pbmRleC1taWRkbGV3YXJlJztcbmltcG9ydCB7IGhvb2tzTWlkZGxld2FyZSB9IGZyb20gJy4uLy4uL2hvb2tzL2hvb2tzLW1pZGRsZXdhcmUnO1xuaW1wb3J0IHsgSW5kZXhhYmxlVHlwZSB9IGZyb20gJy4uLy4uL3B1YmxpYyc7XG5pbXBvcnQgeyBvYnNlcnZhYmlsaXR5TWlkZGxld2FyZSB9IGZyb20gJy4uLy4uL2xpdmUtcXVlcnkvb2JzZXJ2YWJpbGl0eS1taWRkbGV3YXJlJztcbmltcG9ydCB7IGNhY2hlRXhpc3RpbmdWYWx1ZXNNaWRkbGV3YXJlIH0gZnJvbSAnLi4vLi4vZGJjb3JlL2NhY2hlLWV4aXN0aW5nLXZhbHVlcy1taWRkbGV3YXJlJztcblxuZXhwb3J0IGludGVyZmFjZSBEYlJlYWR5U3RhdGUge1xuICBkYk9wZW5FcnJvcjogYW55O1xuICBpc0JlaW5nT3BlbmVkOiBib29sZWFuO1xuICBvblJlYWR5QmVpbmdGaXJlZDogdW5kZWZpbmVkIHwgRnVuY3Rpb25bXTtcbiAgb3BlbkNvbXBsZXRlOiBib29sZWFuO1xuICBkYlJlYWR5UmVzb2x2ZTogKCkgPT4gdm9pZDtcbiAgZGJSZWFkeVByb21pc2U6IFByb21pc2U8YW55PjtcbiAgY2FuY2VsT3BlbjogKHJlYXNvbj86IEVycm9yKSA9PiB2b2lkO1xuICBvcGVuQ2FuY2VsbGVyOiBQcm9taXNlPGFueT4gJiB7IF9zdGFja0hvbGRlcj86IEVycm9yIH07XG4gIGF1dG9TY2hlbWE6IGJvb2xlYW47XG4gIHZjRmlyZWQ/OiBib29sZWFuO1xuICBQUjEzOThfbWF4TG9vcD86IG51bWJlcjtcbn1cblxuZXhwb3J0IGNsYXNzIERleGllIGltcGxlbWVudHMgSURleGllIHtcbiAgX29wdGlvbnM6IERleGllT3B0aW9ucztcbiAgX3N0YXRlOiBEYlJlYWR5U3RhdGU7XG4gIF92ZXJzaW9uczogVmVyc2lvbltdO1xuICBfc3RvcmVOYW1lczogc3RyaW5nW107XG4gIF9kZXBzOiBEZXhpZURPTURlcGVuZGVuY2llcztcbiAgX2FsbFRhYmxlczogeyBbbmFtZTogc3RyaW5nXTogVGFibGU7IH07XG4gIF9jcmVhdGVUcmFuc2FjdGlvbjogKHRoaXM6IERleGllLCBtb2RlOiBJREJUcmFuc2FjdGlvbk1vZGUsIHN0b3JlTmFtZXM6IEFycmF5TGlrZTxzdHJpbmc+LCBkYnNjaGVtYTogeyBbdGFibGVOYW1lOiBzdHJpbmddOiBUYWJsZVNjaGVtYTsgfSwgcGFyZW50VHJhbnNhY3Rpb24/OiBUcmFuc2FjdGlvbikgPT4gVHJhbnNhY3Rpb247XG4gIF9kYlNjaGVtYTogeyBbdGFibGVOYW1lOiBzdHJpbmddOiBUYWJsZVNjaGVtYTsgfTtcbiAgX2hhc0dldEFsbD86IGJvb2xlYW47XG4gIF9tYXhLZXk6IEluZGV4YWJsZVR5cGU7XG4gIF9maXJlT25CbG9ja2VkOiAoZXY6IEV2ZW50KSA9PiB2b2lkO1xuICBfbWlkZGxld2FyZXM6IHtbU3RhY2tOYW1lIGluIGtleW9mIERleGllU3RhY2tzXT86IE1pZGRsZXdhcmU8RGV4aWVTdGFja3NbU3RhY2tOYW1lXT5bXX0gPSB7fTtcbiAgX3ZpcD86IGJvb2xlYW47XG4gIF9ub3ZpcD86IERleGllOy8vIGRiLl9ub3ZpcCBpcyB0byBlc2NhcGUgdG8gb3JpZyBkYiBmcm9tIGRiLnZpcC5cbiAgY29yZTogREJDb3JlO1xuXG4gIG5hbWU6IHN0cmluZztcbiAgdmVybm86IG51bWJlciA9IDA7XG4gIGlkYmRiOiBJREJEYXRhYmFzZSB8IG51bGw7XG4gIHZpcDogRGV4aWU7XG4gIG9uOiBEYkV2ZW50cztcblxuICBUYWJsZTogVGFibGVDb25zdHJ1Y3RvcjtcbiAgV2hlcmVDbGF1c2U6IFdoZXJlQ2xhdXNlQ29uc3RydWN0b3I7XG4gIENvbGxlY3Rpb246IENvbGxlY3Rpb25Db25zdHJ1Y3RvcjtcbiAgVmVyc2lvbjogVmVyc2lvbkNvbnN0cnVjdG9yO1xuICBUcmFuc2FjdGlvbjogVHJhbnNhY3Rpb25Db25zdHJ1Y3RvcjtcblxuICBjb25zdHJ1Y3RvcihuYW1lOiBzdHJpbmcsIG9wdGlvbnM/OiBEZXhpZU9wdGlvbnMpIHtcbiAgICBjb25zdCBkZXBzID0gKERleGllIGFzIGFueSBhcyBEZXhpZUNvbnN0cnVjdG9yKS5kZXBlbmRlbmNpZXM7XG4gICAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnMgPSB7XG4gICAgICAvLyBEZWZhdWx0IE9wdGlvbnNcbiAgICAgIGFkZG9uczogKERleGllIGFzIGFueSBhcyBEZXhpZUNvbnN0cnVjdG9yKS5hZGRvbnMsIC8vIFBpY2sgc3RhdGljYWxseSByZWdpc3RlcmVkIGFkZG9ucyBieSBkZWZhdWx0XG4gICAgICBhdXRvT3BlbjogdHJ1ZSwgICAgICAgICAgICAgICAgIC8vIERvbid0IHJlcXVpcmUgZGIub3BlbigpIGV4cGxpY2l0ZWx5LlxuICAgICAgLy8gRGVmYXVsdCBET00gZGVwZW5kZW5jeSBpbXBsZW1lbnRhdGlvbnMgZnJvbSBzdGF0aWMgcHJvcC5cbiAgICAgIGluZGV4ZWREQjogZGVwcy5pbmRleGVkREIsICAgICAgLy8gQmFja2VuZCBJbmRleGVkREIgYXBpLiBEZWZhdWx0IHRvIGJyb3dzZXIgZW52LlxuICAgICAgSURCS2V5UmFuZ2U6IGRlcHMuSURCS2V5UmFuZ2UsICAvLyBCYWNrZW5kIElEQktleVJhbmdlIGFwaS4gRGVmYXVsdCB0byBicm93c2VyIGVudi5cbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9O1xuICAgIHRoaXMuX2RlcHMgPSB7XG4gICAgICBpbmRleGVkREI6IG9wdGlvbnMuaW5kZXhlZERCIGFzIElEQkZhY3RvcnksXG4gICAgICBJREJLZXlSYW5nZTogb3B0aW9ucy5JREJLZXlSYW5nZSBhcyB0eXBlb2YgSURCS2V5UmFuZ2VcbiAgICB9O1xuICAgIGNvbnN0IHtcbiAgICAgIGFkZG9ucyxcbiAgICB9ID0gb3B0aW9ucztcbiAgICB0aGlzLl9kYlNjaGVtYSA9IHt9O1xuICAgIHRoaXMuX3ZlcnNpb25zID0gW107XG4gICAgdGhpcy5fc3RvcmVOYW1lcyA9IFtdO1xuICAgIHRoaXMuX2FsbFRhYmxlcyA9IHt9O1xuICAgIHRoaXMuaWRiZGIgPSBudWxsO1xuICAgIHRoaXMuX25vdmlwID0gdGhpcztcbiAgICBjb25zdCBzdGF0ZTogRGJSZWFkeVN0YXRlID0ge1xuICAgICAgZGJPcGVuRXJyb3I6IG51bGwsXG4gICAgICBpc0JlaW5nT3BlbmVkOiBmYWxzZSxcbiAgICAgIG9uUmVhZHlCZWluZ0ZpcmVkOiBudWxsLFxuICAgICAgb3BlbkNvbXBsZXRlOiBmYWxzZSxcbiAgICAgIGRiUmVhZHlSZXNvbHZlOiBub3AsXG4gICAgICBkYlJlYWR5UHJvbWlzZTogbnVsbCBhcyBQcm9taXNlLFxuICAgICAgY2FuY2VsT3Blbjogbm9wLFxuICAgICAgb3BlbkNhbmNlbGxlcjogbnVsbCBhcyBQcm9taXNlLFxuICAgICAgYXV0b1NjaGVtYTogdHJ1ZSxcbiAgICAgIFBSMTM5OF9tYXhMb29wOiAzXG4gICAgfTtcbiAgICBzdGF0ZS5kYlJlYWR5UHJvbWlzZSA9IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgc3RhdGUuZGJSZWFkeVJlc29sdmUgPSByZXNvbHZlO1xuICAgIH0pO1xuICAgIHN0YXRlLm9wZW5DYW5jZWxsZXIgPSBuZXcgUHJvbWlzZSgoXywgcmVqZWN0KSA9PiB7XG4gICAgICBzdGF0ZS5jYW5jZWxPcGVuID0gcmVqZWN0O1xuICAgIH0pO1xuICAgIHRoaXMuX3N0YXRlID0gc3RhdGU7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLm9uID0gRXZlbnRzKHRoaXMsIFwicG9wdWxhdGVcIiwgXCJibG9ja2VkXCIsIFwidmVyc2lvbmNoYW5nZVwiLCBcImNsb3NlXCIsIHsgcmVhZHk6IFtwcm9taXNhYmxlQ2hhaW4sIG5vcF0gfSkgYXMgRGJFdmVudHM7XG4gICAgdGhpcy5vbi5yZWFkeS5zdWJzY3JpYmUgPSBvdmVycmlkZSh0aGlzLm9uLnJlYWR5LnN1YnNjcmliZSwgc3Vic2NyaWJlID0+IHtcbiAgICAgIHJldHVybiAoc3Vic2NyaWJlciwgYlN0aWNreSkgPT4ge1xuICAgICAgICAoRGV4aWUgYXMgYW55IGFzIERleGllQ29uc3RydWN0b3IpLnZpcCgoKSA9PiB7XG4gICAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLl9zdGF0ZTtcbiAgICAgICAgICBpZiAoc3RhdGUub3BlbkNvbXBsZXRlKSB7XG4gICAgICAgICAgICAvLyBEYXRhYmFzZSBhbHJlYWR5IG9wZW4uIENhbGwgc3Vic2NyaWJlciBhc2FwLlxuICAgICAgICAgICAgaWYgKCFzdGF0ZS5kYk9wZW5FcnJvcikgUHJvbWlzZS5yZXNvbHZlKCkudGhlbihzdWJzY3JpYmVyKTtcbiAgICAgICAgICAgIC8vIGJTdGlja3k6IEFsc28gc3Vic2NyaWJlIHRvIGZ1dHVyZSBvcGVuIHN1Y2Vzc2VzIChhZnRlciBjbG9zZSAvIHJlb3BlbikgXG4gICAgICAgICAgICBpZiAoYlN0aWNreSkgc3Vic2NyaWJlKHN1YnNjcmliZXIpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc3RhdGUub25SZWFkeUJlaW5nRmlyZWQpIHtcbiAgICAgICAgICAgIC8vIGRiLm9uKCdyZWFkeScpIHN1YnNjcmliZXJzIGFyZSBjdXJyZW50bHkgYmVpbmcgZXhlY3V0ZWQgYW5kIGhhdmUgbm90IHlldCByZXNvbHZlZCBvciByZWplY3RlZFxuICAgICAgICAgICAgc3RhdGUub25SZWFkeUJlaW5nRmlyZWQucHVzaChzdWJzY3JpYmVyKTtcbiAgICAgICAgICAgIGlmIChiU3RpY2t5KSBzdWJzY3JpYmUoc3Vic2NyaWJlcik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIERhdGFiYXNlIG5vdCB5ZXQgb3Blbi4gU3Vic2NyaWJlIHRvIGl0LlxuICAgICAgICAgICAgc3Vic2NyaWJlKHN1YnNjcmliZXIpO1xuICAgICAgICAgICAgLy8gSWYgYlN0aWNreSBpcyBmYWxzeSwgbWFrZSBzdXJlIHRvIHVuc3Vic2NyaWJlIHN1YnNjcmliZXIgd2hlbiBmaXJlZCBvbmNlLlxuICAgICAgICAgICAgY29uc3QgZGIgPSB0aGlzO1xuICAgICAgICAgICAgaWYgKCFiU3RpY2t5KSBzdWJzY3JpYmUoZnVuY3Rpb24gdW5zdWJzY3JpYmUoKSB7XG4gICAgICAgICAgICAgIGRiLm9uLnJlYWR5LnVuc3Vic2NyaWJlKHN1YnNjcmliZXIpO1xuICAgICAgICAgICAgICBkYi5vbi5yZWFkeS51bnN1YnNjcmliZSh1bnN1YnNjcmliZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gQ3JlYXRlIGRlcml2ZWQgY2xhc3NlcyBib3VuZCB0byB0aGlzIGluc3RhbmNlIG9mIERleGllOlxuICAgIHRoaXMuQ29sbGVjdGlvbiA9IGNyZWF0ZUNvbGxlY3Rpb25Db25zdHJ1Y3Rvcih0aGlzKTtcbiAgICB0aGlzLlRhYmxlID0gY3JlYXRlVGFibGVDb25zdHJ1Y3Rvcih0aGlzKTtcbiAgICB0aGlzLlRyYW5zYWN0aW9uID0gY3JlYXRlVHJhbnNhY3Rpb25Db25zdHJ1Y3Rvcih0aGlzKTtcbiAgICB0aGlzLlZlcnNpb24gPSBjcmVhdGVWZXJzaW9uQ29uc3RydWN0b3IodGhpcyk7XG4gICAgdGhpcy5XaGVyZUNsYXVzZSA9IGNyZWF0ZVdoZXJlQ2xhdXNlQ29uc3RydWN0b3IodGhpcyk7XG5cbiAgICAvLyBEZWZhdWx0IHN1YnNjcmliZXJzIHRvIFwidmVyc2lvbmNoYW5nZVwiIGFuZCBcImJsb2NrZWRcIi5cbiAgICAvLyBDYW4gYmUgb3ZlcnJpZGRlbiBieSBjdXN0b20gaGFuZGxlcnMuIElmIGN1c3RvbSBoYW5kbGVycyByZXR1cm4gZmFsc2UsIHRoZXNlIGRlZmF1bHRcbiAgICAvLyBiZWhhdmlvdXJzIHdpbGwgYmUgcHJldmVudGVkLlxuICAgIHRoaXMub24oXCJ2ZXJzaW9uY2hhbmdlXCIsIGV2ID0+IHtcbiAgICAgIC8vIERlZmF1bHQgYmVoYXZpb3IgZm9yIHZlcnNpb25jaGFuZ2UgZXZlbnQgaXMgdG8gY2xvc2UgZGF0YWJhc2UgY29ubmVjdGlvbi5cbiAgICAgIC8vIENhbGxlciBjYW4gb3ZlcnJpZGUgdGhpcyBiZWhhdmlvciBieSBkb2luZyBkYi5vbihcInZlcnNpb25jaGFuZ2VcIiwgZnVuY3Rpb24oKXsgcmV0dXJuIGZhbHNlOyB9KTtcbiAgICAgIC8vIExldCdzIG5vdCBibG9jayB0aGUgb3RoZXIgd2luZG93IGZyb20gbWFraW5nIGl0J3MgZGVsZXRlKCkgb3Igb3BlbigpIGNhbGwuXG4gICAgICAvLyBOT1RFISBUaGlzIGV2ZW50IGlzIG5ldmVyIGZpcmVkIGluIElFLEVkZ2Ugb3IgU2FmYXJpLlxuICAgICAgaWYgKGV2Lm5ld1ZlcnNpb24gPiAwKVxuICAgICAgICBjb25zb2xlLndhcm4oYEFub3RoZXIgY29ubmVjdGlvbiB3YW50cyB0byB1cGdyYWRlIGRhdGFiYXNlICcke3RoaXMubmFtZX0nLiBDbG9zaW5nIGRiIG5vdyB0byByZXN1bWUgdGhlIHVwZ3JhZGUuYCk7XG4gICAgICBlbHNlXG4gICAgICAgIGNvbnNvbGUud2FybihgQW5vdGhlciBjb25uZWN0aW9uIHdhbnRzIHRvIGRlbGV0ZSBkYXRhYmFzZSAnJHt0aGlzLm5hbWV9Jy4gQ2xvc2luZyBkYiBub3cgdG8gcmVzdW1lIHRoZSBkZWxldGUgcmVxdWVzdC5gKTtcbiAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgIC8vIEluIG1hbnkgd2ViIGFwcGxpY2F0aW9ucywgaXQgd291bGQgYmUgcmVjb21tZW5kZWQgdG8gZm9yY2Ugd2luZG93LnJlbG9hZCgpXG4gICAgICAvLyB3aGVuIHRoaXMgZXZlbnQgb2NjdXJzLiBUbyBkbyB0aGF0LCBzdWJzY3JpYmUgdG8gdGhlIHZlcnNpb25jaGFuZ2UgZXZlbnRcbiAgICAgIC8vIGFuZCBjYWxsIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQodHJ1ZSkgaWYgZXYubmV3VmVyc2lvbiA+IDAgKG5vdCBhIGRlbGV0aW9uKVxuICAgICAgLy8gVGhlIHJlYXNvbiBmb3IgdGhpcyBpcyB0aGF0IHlvdXIgY3VycmVudCB3ZWIgYXBwIG9idmlvdXNseSBoYXMgb2xkIHNjaGVtYSBjb2RlIHRoYXQgbmVlZHNcbiAgICAgIC8vIHRvIGJlIHVwZGF0ZWQuIEFub3RoZXIgd2luZG93IGdvdCBhIG5ld2VyIHZlcnNpb24gb2YgdGhlIGFwcCBhbmQgbmVlZHMgdG8gdXBncmFkZSBEQiBidXRcbiAgICAgIC8vIHlvdXIgd2luZG93IGlzIGJsb2NraW5nIGl0IHVubGVzcyB3ZSBjbG9zZSBpdCBoZXJlLlxuICAgIH0pO1xuICAgIHRoaXMub24oXCJibG9ja2VkXCIsIGV2ID0+IHtcbiAgICAgIGlmICghZXYubmV3VmVyc2lvbiB8fCBldi5uZXdWZXJzaW9uIDwgZXYub2xkVmVyc2lvbilcbiAgICAgICAgY29uc29sZS53YXJuKGBEZXhpZS5kZWxldGUoJyR7dGhpcy5uYW1lfScpIHdhcyBibG9ja2VkYCk7XG4gICAgICBlbHNlXG4gICAgICAgIGNvbnNvbGUud2FybihgVXBncmFkZSAnJHt0aGlzLm5hbWV9JyBibG9ja2VkIGJ5IG90aGVyIGNvbm5lY3Rpb24gaG9sZGluZyB2ZXJzaW9uICR7ZXYub2xkVmVyc2lvbiAvIDEwfWApO1xuICAgIH0pO1xuXG4gICAgdGhpcy5fbWF4S2V5ID0gZ2V0TWF4S2V5KG9wdGlvbnMuSURCS2V5UmFuZ2UgYXMgdHlwZW9mIElEQktleVJhbmdlKTtcblxuICAgIHRoaXMuX2NyZWF0ZVRyYW5zYWN0aW9uID0gKFxuICAgICAgbW9kZTogSURCVHJhbnNhY3Rpb25Nb2RlLFxuICAgICAgc3RvcmVOYW1lczogc3RyaW5nW10sXG4gICAgICBkYnNjaGVtYTogRGJTY2hlbWEsXG4gICAgICBwYXJlbnRUcmFuc2FjdGlvbj86IFRyYW5zYWN0aW9uKSA9PiBuZXcgdGhpcy5UcmFuc2FjdGlvbihtb2RlLCBzdG9yZU5hbWVzLCBkYnNjaGVtYSwgdGhpcy5fb3B0aW9ucy5jaHJvbWVUcmFuc2FjdGlvbkR1cmFiaWxpdHksIHBhcmVudFRyYW5zYWN0aW9uKTtcblxuICAgIHRoaXMuX2ZpcmVPbkJsb2NrZWQgPSBldiA9PiB7XG4gICAgICB0aGlzLm9uKFwiYmxvY2tlZFwiKS5maXJlKGV2KTtcbiAgICAgIC8vIFdvcmthcm91bmQgKG5vdCBmdWxseSopIGZvciBtaXNzaW5nIFwidmVyc2lvbmNoYW5nZVwiIGV2ZW50IGluIElFLEVkZ2UgYW5kIFNhZmFyaTpcbiAgICAgIGNvbm5lY3Rpb25zXG4gICAgICAgIC5maWx0ZXIoYyA9PiBjLm5hbWUgPT09IHRoaXMubmFtZSAmJiBjICE9PSB0aGlzICYmICFjLl9zdGF0ZS52Y0ZpcmVkKVxuICAgICAgICAubWFwKGMgPT4gYy5vbihcInZlcnNpb25jaGFuZ2VcIikuZmlyZShldikpO1xuICAgIH1cblxuICAgIC8vIERlZmF1bHQgbWlkZGxld2FyZXM6XG4gICAgdGhpcy51c2UodmlydHVhbEluZGV4TWlkZGxld2FyZSk7XG4gICAgdGhpcy51c2UoaG9va3NNaWRkbGV3YXJlKTtcbiAgICB0aGlzLnVzZShvYnNlcnZhYmlsaXR5TWlkZGxld2FyZSk7XG4gICAgdGhpcy51c2UoY2FjaGVFeGlzdGluZ1ZhbHVlc01pZGRsZXdhcmUpO1xuXG4gICAgdGhpcy52aXAgPSBPYmplY3QuY3JlYXRlKHRoaXMsIHtfdmlwOiB7dmFsdWU6IHRydWV9fSkgYXMgRGV4aWU7XG5cbiAgICAvLyBDYWxsIGVhY2ggYWRkb246XG4gICAgYWRkb25zLmZvckVhY2goYWRkb24gPT4gYWRkb24odGhpcykpO1xuICB9XG5cbiAgdmVyc2lvbih2ZXJzaW9uTnVtYmVyOiBudW1iZXIpOiBWZXJzaW9uIHtcbiAgICBpZiAoaXNOYU4odmVyc2lvbk51bWJlcikgfHwgdmVyc2lvbk51bWJlciA8IDAuMSkgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuVHlwZShgR2l2ZW4gdmVyc2lvbiBpcyBub3QgYSBwb3NpdGl2ZSBudW1iZXJgKTtcbiAgICB2ZXJzaW9uTnVtYmVyID0gTWF0aC5yb3VuZCh2ZXJzaW9uTnVtYmVyICogMTApIC8gMTA7XG4gICAgaWYgKHRoaXMuaWRiZGIgfHwgdGhpcy5fc3RhdGUuaXNCZWluZ09wZW5lZClcbiAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLlNjaGVtYShcIkNhbm5vdCBhZGQgdmVyc2lvbiB3aGVuIGRhdGFiYXNlIGlzIG9wZW5cIik7XG4gICAgdGhpcy52ZXJubyA9IE1hdGgubWF4KHRoaXMudmVybm8sIHZlcnNpb25OdW1iZXIpO1xuICAgIGNvbnN0IHZlcnNpb25zID0gdGhpcy5fdmVyc2lvbnM7XG4gICAgdmFyIHZlcnNpb25JbnN0YW5jZSA9IHZlcnNpb25zLmZpbHRlcihcbiAgICAgIHYgPT4gdi5fY2ZnLnZlcnNpb24gPT09IHZlcnNpb25OdW1iZXIpWzBdO1xuICAgIGlmICh2ZXJzaW9uSW5zdGFuY2UpIHJldHVybiB2ZXJzaW9uSW5zdGFuY2U7XG4gICAgdmVyc2lvbkluc3RhbmNlID0gbmV3IHRoaXMuVmVyc2lvbih2ZXJzaW9uTnVtYmVyKTtcbiAgICB2ZXJzaW9ucy5wdXNoKHZlcnNpb25JbnN0YW5jZSk7XG4gICAgdmVyc2lvbnMuc29ydChsb3dlclZlcnNpb25GaXJzdCk7XG4gICAgdmVyc2lvbkluc3RhbmNlLnN0b3Jlcyh7fSk7IC8vIERlcml2ZSBlYXJsaWVyIHNjaGVtYXMgYnkgZGVmYXVsdC5cbiAgICAvLyBEaXNhYmxlIGF1dG9zY2hlbWEgbW9kZSwgYXMgYXQgbGVhc3Qgb25lIHZlcnNpb24gaXMgc3BlY2lmaWVkLlxuICAgIHRoaXMuX3N0YXRlLmF1dG9TY2hlbWEgPSBmYWxzZTtcbiAgICByZXR1cm4gdmVyc2lvbkluc3RhbmNlO1xuICB9XG5cbiAgX3doZW5SZWFkeTxUPihmbjogKCkgPT4gUHJvbWlzZTxUPik6IFByb21pc2U8VD4ge1xuICAgIHJldHVybiAodGhpcy5pZGJkYiAmJiAodGhpcy5fc3RhdGUub3BlbkNvbXBsZXRlIHx8IFBTRC5sZXRUaHJvdWdoIHx8IHRoaXMuX3ZpcCkpID8gZm4oKSA6IG5ldyBQcm9taXNlPFQ+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGlmICh0aGlzLl9zdGF0ZS5vcGVuQ29tcGxldGUpIHtcbiAgICAgICAgLy8gaWRiZGIgaXMgZmFsc3kgYnV0IG9wZW5Db21wbGV0ZSBpcyB0cnVlLiBNdXN0IGhhdmUgYmVlbiBhbiBleGNlcHRpb24gZHVyaW4gb3Blbi5cbiAgICAgICAgLy8gRG9uJ3Qgd2FpdCBmb3Igb3BlbkNvbXBsZXRlIGFzIGl0IHdvdWxkIGxlYWQgdG8gaW5maW5pdGUgbG9vcC5cbiAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgZXhjZXB0aW9ucy5EYXRhYmFzZUNsb3NlZCh0aGlzLl9zdGF0ZS5kYk9wZW5FcnJvcikpO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLl9zdGF0ZS5pc0JlaW5nT3BlbmVkKSB7XG4gICAgICAgIGlmICghdGhpcy5fb3B0aW9ucy5hdXRvT3Blbikge1xuICAgICAgICAgIHJlamVjdChuZXcgZXhjZXB0aW9ucy5EYXRhYmFzZUNsb3NlZCgpKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vcGVuKCkuY2F0Y2gobm9wKTsgLy8gT3BlbiBpbiBiYWNrZ3JvdW5kLiBJZiBpZiBmYWlscywgaXQgd2lsbCBiZSBjYXRjaGVkIGJ5IHRoZSBmaW5hbCBwcm9taXNlIGFueXdheS5cbiAgICAgIH1cbiAgICAgIHRoaXMuX3N0YXRlLmRiUmVhZHlQcm9taXNlLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICB9KS50aGVuKGZuKTtcbiAgfVxuXG4gIHVzZSh7c3RhY2ssIGNyZWF0ZSwgbGV2ZWwsIG5hbWV9OiBNaWRkbGV3YXJlPERCQ29yZT4pOiB0aGlzIHtcbiAgICBpZiAobmFtZSkgdGhpcy51bnVzZSh7c3RhY2ssIG5hbWV9KTsgLy8gQmUgYWJsZSB0byByZXBsYWNlIGV4aXN0aW5nIG1pZGRsZXdhcmUuXG4gICAgY29uc3QgbWlkZGxld2FyZXMgPSB0aGlzLl9taWRkbGV3YXJlc1tzdGFja10gfHwgKHRoaXMuX21pZGRsZXdhcmVzW3N0YWNrXSA9IFtdKTtcbiAgICBtaWRkbGV3YXJlcy5wdXNoKHtzdGFjaywgY3JlYXRlLCBsZXZlbDogbGV2ZWwgPT0gbnVsbCA/IDEwIDogbGV2ZWwsIG5hbWV9KTtcbiAgICBtaWRkbGV3YXJlcy5zb3J0KChhLCBiKSA9PiBhLmxldmVsIC0gYi5sZXZlbCk7XG4gICAgLy8gVG9kbyB1cGRhdGUgZGIuY29yZSBhbmQgZGIudGFibGVzLi4uY29yZSA/IE9yIHNob3VsZCBiZSBleHBlY3QgdGhpcyB0byBoYXZlIGVmZmVjdFxuICAgIC8vIG9ubHkgYWZ0ZXIgbmV4dCBvcGVuKCk/XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB1bnVzZSh7c3RhY2ssIGNyZWF0ZX06IE1pZGRsZXdhcmU8e3N0YWNrOiBrZXlvZiBEZXhpZVN0YWNrc30+KTogdGhpcztcbiAgdW51c2Uoe3N0YWNrLCBuYW1lfToge3N0YWNrOiBrZXlvZiBEZXhpZVN0YWNrcywgbmFtZTogc3RyaW5nfSk6IHRoaXM7XG4gIHVudXNlKHtzdGFjaywgbmFtZSwgY3JlYXRlfToge3N0YWNrOiBrZXlvZiBEZXhpZVN0YWNrcywgbmFtZT86IHN0cmluZywgY3JlYXRlPzogRnVuY3Rpb259KSB7XG4gICAgaWYgKHN0YWNrICYmIHRoaXMuX21pZGRsZXdhcmVzW3N0YWNrXSkge1xuICAgICAgdGhpcy5fbWlkZGxld2FyZXNbc3RhY2tdID0gdGhpcy5fbWlkZGxld2FyZXNbc3RhY2tdLmZpbHRlcihtdyA9PlxuICAgICAgICBjcmVhdGUgPyBtdy5jcmVhdGUgIT09IGNyZWF0ZSA6IC8vIEdpdmVuIG1pZGRsZXdhcmUgaGFzIGEgY3JlYXRlIG1ldGhvZC4gTWF0Y2ggdGhhdCBleGFjdGx5LlxuICAgICAgICBuYW1lID8gbXcubmFtZSAhPT0gbmFtZSA6IC8vIEdpdmVuIG1pZGRsZXdhcmUgc3BlYyBcbiAgICAgICAgZmFsc2UpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIG9wZW4oKSB7XG4gICAgcmV0dXJuIGRleGllT3Blbih0aGlzKTtcbiAgfVxuXG4gIF9jbG9zZSgpOiB2b2lkIHtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuX3N0YXRlO1xuICAgIGNvbnN0IGlkeCA9IGNvbm5lY3Rpb25zLmluZGV4T2YodGhpcyk7XG4gICAgaWYgKGlkeCA+PSAwKSBjb25uZWN0aW9ucy5zcGxpY2UoaWR4LCAxKTtcbiAgICBpZiAodGhpcy5pZGJkYikge1xuICAgICAgdHJ5IHsgdGhpcy5pZGJkYi5jbG9zZSgpOyB9IGNhdGNoIChlKSB7IH1cbiAgICAgIHRoaXMuX25vdmlwLmlkYmRiID0gbnVsbDsgLy8gZGIuX25vdmlwIGlzIGJlY2F1c2UgZGIgY2FuIGJlIGFuIE9iamVjdC5jcmVhdGUob3JpZ0RiKS5cbiAgICB9ICAgIFxuICAgIC8vIFJlc2V0IGRiUmVhZHlQcm9taXNlIHByb21pc2U6XG4gICAgc3RhdGUuZGJSZWFkeVByb21pc2UgPSBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIHN0YXRlLmRiUmVhZHlSZXNvbHZlID0gcmVzb2x2ZTtcbiAgICB9KTtcbiAgICBzdGF0ZS5vcGVuQ2FuY2VsbGVyID0gbmV3IFByb21pc2UoKF8sIHJlamVjdCkgPT4ge1xuICAgICAgc3RhdGUuY2FuY2VsT3BlbiA9IHJlamVjdDtcbiAgICB9KTtcbiAgfVxuXG4gIGNsb3NlKCk6IHZvaWQge1xuICAgIHRoaXMuX2Nsb3NlKCk7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLl9zdGF0ZTtcbiAgICB0aGlzLl9vcHRpb25zLmF1dG9PcGVuID0gZmFsc2U7XG4gICAgc3RhdGUuZGJPcGVuRXJyb3IgPSBuZXcgZXhjZXB0aW9ucy5EYXRhYmFzZUNsb3NlZCgpO1xuICAgIGlmIChzdGF0ZS5pc0JlaW5nT3BlbmVkKVxuICAgICAgc3RhdGUuY2FuY2VsT3BlbihzdGF0ZS5kYk9wZW5FcnJvcik7XG4gIH1cblxuICBkZWxldGUoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3QgaGFzQXJndW1lbnRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDA7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLl9zdGF0ZTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgZG9EZWxldGUgPSAoKSA9PiB7XG4gICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgdmFyIHJlcSA9IHRoaXMuX2RlcHMuaW5kZXhlZERCLmRlbGV0ZURhdGFiYXNlKHRoaXMubmFtZSk7XG4gICAgICAgIHJlcS5vbnN1Y2Nlc3MgPSB3cmFwKCgpID0+IHtcbiAgICAgICAgICBfb25EYXRhYmFzZURlbGV0ZWQodGhpcy5fZGVwcywgdGhpcy5uYW1lKTtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXEub25lcnJvciA9IGV2ZW50UmVqZWN0SGFuZGxlcihyZWplY3QpO1xuICAgICAgICByZXEub25ibG9ja2VkID0gdGhpcy5fZmlyZU9uQmxvY2tlZDtcbiAgICAgIH1cblxuICAgICAgaWYgKGhhc0FyZ3VtZW50cykgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuSW52YWxpZEFyZ3VtZW50KFwiQXJndW1lbnRzIG5vdCBhbGxvd2VkIGluIGRiLmRlbGV0ZSgpXCIpO1xuICAgICAgaWYgKHN0YXRlLmlzQmVpbmdPcGVuZWQpIHtcbiAgICAgICAgc3RhdGUuZGJSZWFkeVByb21pc2UudGhlbihkb0RlbGV0ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkb0RlbGV0ZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgYmFja2VuZERCKCkge1xuICAgIHJldHVybiB0aGlzLmlkYmRiO1xuICB9XG5cbiAgaXNPcGVuKCkge1xuICAgIHJldHVybiB0aGlzLmlkYmRiICE9PSBudWxsO1xuICB9XG5cbiAgaGFzQmVlbkNsb3NlZCgpIHtcbiAgICBjb25zdCBkYk9wZW5FcnJvciA9IHRoaXMuX3N0YXRlLmRiT3BlbkVycm9yO1xuICAgIHJldHVybiBkYk9wZW5FcnJvciAmJiAoZGJPcGVuRXJyb3IubmFtZSA9PT0gJ0RhdGFiYXNlQ2xvc2VkJyk7XG4gIH1cblxuICBoYXNGYWlsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXRlLmRiT3BlbkVycm9yICE9PSBudWxsO1xuICB9XG5cbiAgZHluYW1pY2FsbHlPcGVuZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXRlLmF1dG9TY2hlbWE7XG4gIH1cblxuICBnZXQgdGFibGVzICgpIHtcbiAgICByZXR1cm4ga2V5cyh0aGlzLl9hbGxUYWJsZXMpLm1hcChuYW1lID0+IHRoaXMuX2FsbFRhYmxlc1tuYW1lXSk7XG4gIH1cblxuICB0cmFuc2FjdGlvbigpOiBQcm9taXNlIHtcbiAgICBjb25zdCBhcmdzID0gZXh0cmFjdFRyYW5zYWN0aW9uQXJncy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHJldHVybiB0aGlzLl90cmFuc2FjdGlvbi5hcHBseSh0aGlzLCBhcmdzKTtcbiAgfVxuXG4gIF90cmFuc2FjdGlvbihtb2RlOiBUcmFuc2FjdGlvbk1vZGUsIHRhYmxlczogQXJyYXk8SVRhYmxlIHwgc3RyaW5nPiwgc2NvcGVGdW5jOiBGdW5jdGlvbikge1xuICAgIGxldCBwYXJlbnRUcmFuc2FjdGlvbiA9IFBTRC50cmFucyBhcyBUcmFuc2FjdGlvbiB8IHVuZGVmaW5lZDtcbiAgICAvLyBDaGVjayBpZiBwYXJlbnQgdHJhbnNhY3Rpb25zIGlzIGJvdW5kIHRvIHRoaXMgZGIgaW5zdGFuY2UsIGFuZCBpZiBjYWxsZXIgd2FudHMgdG8gcmV1c2UgaXRcbiAgICBpZiAoIXBhcmVudFRyYW5zYWN0aW9uIHx8IHBhcmVudFRyYW5zYWN0aW9uLmRiICE9PSB0aGlzIHx8IG1vZGUuaW5kZXhPZignIScpICE9PSAtMSkgcGFyZW50VHJhbnNhY3Rpb24gPSBudWxsO1xuICAgIGNvbnN0IG9ubHlJZkNvbXBhdGlibGUgPSBtb2RlLmluZGV4T2YoJz8nKSAhPT0gLTE7XG4gICAgbW9kZSA9IG1vZGUucmVwbGFjZSgnIScsICcnKS5yZXBsYWNlKCc/JywgJycpIGFzIFRyYW5zYWN0aW9uTW9kZTsgLy8gT2suIFdpbGwgY2hhbmdlIGFyZ3VtZW50c1swXSBhcyB3ZWxsIGJ1dCB3ZSB3b250IHRvdWNoIGFyZ3VtZW50cyBoZW5jZWZvcnRoLlxuICAgIGxldCBpZGJNb2RlOiBJREJUcmFuc2FjdGlvbk1vZGUsXG4gICAgICAgIHN0b3JlTmFtZXM7XG5cbiAgICB0cnkge1xuICAgICAgICAvL1xuICAgICAgICAvLyBHZXQgc3RvcmVOYW1lcyBmcm9tIGFyZ3VtZW50cy4gRWl0aGVyIHRocm91Z2ggZ2l2ZW4gdGFibGUgaW5zdGFuY2VzLCBvciB0aHJvdWdoIGdpdmVuIHRhYmxlIG5hbWVzLlxuICAgICAgICAvL1xuICAgICAgICBzdG9yZU5hbWVzID0gdGFibGVzLm1hcCh0YWJsZSA9PiB7XG4gICAgICAgICAgICB2YXIgc3RvcmVOYW1lID0gdGFibGUgaW5zdGFuY2VvZiB0aGlzLlRhYmxlID8gdGFibGUubmFtZSA6IHRhYmxlO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzdG9yZU5hbWUgIT09ICdzdHJpbmcnKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCB0YWJsZSBhcmd1bWVudCB0byBEZXhpZS50cmFuc2FjdGlvbigpLiBPbmx5IFRhYmxlIG9yIFN0cmluZyBhcmUgYWxsb3dlZFwiKTtcbiAgICAgICAgICAgIHJldHVybiBzdG9yZU5hbWU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFJlc29sdmUgbW9kZS4gQWxsb3cgc2hvcnRjdXRzIFwiclwiIGFuZCBcInJ3XCIuXG4gICAgICAgIC8vXG4gICAgICAgIGlmIChtb2RlID09IFwiclwiIHx8IG1vZGUgPT09IFJFQURPTkxZKVxuICAgICAgICAgIGlkYk1vZGUgPSBSRUFET05MWTtcbiAgICAgICAgZWxzZSBpZiAobW9kZSA9PSBcInJ3XCIgfHwgbW9kZSA9PSBSRUFEV1JJVEUpXG4gICAgICAgICAgaWRiTW9kZSA9IFJFQURXUklURTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuSW52YWxpZEFyZ3VtZW50KFwiSW52YWxpZCB0cmFuc2FjdGlvbiBtb2RlOiBcIiArIG1vZGUpO1xuXG4gICAgICAgIGlmIChwYXJlbnRUcmFuc2FjdGlvbikge1xuICAgICAgICAgICAgLy8gQmFzaWMgY2hlY2tzXG4gICAgICAgICAgICBpZiAocGFyZW50VHJhbnNhY3Rpb24ubW9kZSA9PT0gUkVBRE9OTFkgJiYgaWRiTW9kZSA9PT0gUkVBRFdSSVRFKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9ubHlJZkNvbXBhdGlibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU3Bhd24gbmV3IHRyYW5zYWN0aW9uIGluc3RlYWQuXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudFRyYW5zYWN0aW9uID0gbnVsbDsgXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuU3ViVHJhbnNhY3Rpb24oXCJDYW5ub3QgZW50ZXIgYSBzdWItdHJhbnNhY3Rpb24gd2l0aCBSRUFEV1JJVEUgbW9kZSB3aGVuIHBhcmVudCB0cmFuc2FjdGlvbiBpcyBSRUFET05MWVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXJlbnRUcmFuc2FjdGlvbikge1xuICAgICAgICAgICAgICAgIHN0b3JlTmFtZXMuZm9yRWFjaChzdG9yZU5hbWUgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50VHJhbnNhY3Rpb24gJiYgcGFyZW50VHJhbnNhY3Rpb24uc3RvcmVOYW1lcy5pbmRleE9mKHN0b3JlTmFtZSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob25seUlmQ29tcGF0aWJsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNwYXduIG5ldyB0cmFuc2FjdGlvbiBpbnN0ZWFkLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudFRyYW5zYWN0aW9uID0gbnVsbDsgXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHRocm93IG5ldyBleGNlcHRpb25zLlN1YlRyYW5zYWN0aW9uKFwiVGFibGUgXCIgKyBzdG9yZU5hbWUgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiIG5vdCBpbmNsdWRlZCBpbiBwYXJlbnQgdHJhbnNhY3Rpb24uXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob25seUlmQ29tcGF0aWJsZSAmJiBwYXJlbnRUcmFuc2FjdGlvbiAmJiAhcGFyZW50VHJhbnNhY3Rpb24uYWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgLy8gJz8nIG1vZGUgc2hvdWxkIG5vdCBrZWVwIHVzaW5nIGFuIGluYWN0aXZlIHRyYW5zYWN0aW9uLlxuICAgICAgICAgICAgICAgIHBhcmVudFRyYW5zYWN0aW9uID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIHBhcmVudFRyYW5zYWN0aW9uID9cbiAgICAgICAgICAgIHBhcmVudFRyYW5zYWN0aW9uLl9wcm9taXNlKG51bGwsIChfLCByZWplY3QpID0+IHtyZWplY3QoZSk7fSkgOlxuICAgICAgICAgICAgcmVqZWN0aW9uIChlKTtcbiAgICB9XG4gICAgLy8gSWYgdGhpcyBpcyBhIHN1Yi10cmFuc2FjdGlvbiwgbG9jayB0aGUgcGFyZW50IGFuZCB0aGVuIGxhdW5jaCB0aGUgc3ViLXRyYW5zYWN0aW9uLlxuICAgIGNvbnN0IGVudGVyVHJhbnNhY3Rpb24gPSBlbnRlclRyYW5zYWN0aW9uU2NvcGUuYmluZChudWxsLCB0aGlzLCBpZGJNb2RlLCBzdG9yZU5hbWVzLCBwYXJlbnRUcmFuc2FjdGlvbiwgc2NvcGVGdW5jKTtcbiAgICByZXR1cm4gKHBhcmVudFRyYW5zYWN0aW9uID9cbiAgICAgICAgcGFyZW50VHJhbnNhY3Rpb24uX3Byb21pc2UoaWRiTW9kZSwgZW50ZXJUcmFuc2FjdGlvbiwgXCJsb2NrXCIpIDpcbiAgICAgICAgUFNELnRyYW5zID9cbiAgICAgICAgICAgIC8vIG5vIHBhcmVudCB0cmFuc2FjdGlvbiBkZXNwaXRlIFBTRC50cmFucyBleGlzdHMuIE1ha2Ugc3VyZSBhbHNvXG4gICAgICAgICAgICAvLyB0aGF0IHRoZSB6b25lIHdlIGNyZWF0ZSBpcyBub3QgYSBzdWItem9uZSBvZiBjdXJyZW50LCBiZWNhdXNlXG4gICAgICAgICAgICAvLyBQcm9taXNlLmZvbGxvdygpIHNob3VsZCBub3Qgd2FpdCBmb3IgaXQgaWYgc28uXG4gICAgICAgICAgICB1c2VQU0QoUFNELnRyYW5zbGVzcywgKCk9PnRoaXMuX3doZW5SZWFkeShlbnRlclRyYW5zYWN0aW9uKSkgOlxuICAgICAgICAgICAgdGhpcy5fd2hlblJlYWR5IChlbnRlclRyYW5zYWN0aW9uKSk7XG4gIH1cblxuICB0YWJsZSh0YWJsZU5hbWU6IHN0cmluZyk6IFRhYmxlO1xuICB0YWJsZTxULCBUS2V5IGV4dGVuZHMgSW5kZXhhYmxlVHlwZT1JbmRleGFibGVUeXBlPih0YWJsZU5hbWU6IHN0cmluZyk6IElUYWJsZTxULCBUS2V5PjtcbiAgdGFibGUodGFibGVOYW1lOiBzdHJpbmcpOiBUYWJsZSB7XG4gICAgaWYgKCFoYXNPd24odGhpcy5fYWxsVGFibGVzLCB0YWJsZU5hbWUpKSB7XG4gICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5JbnZhbGlkVGFibGUoYFRhYmxlICR7dGFibGVOYW1lfSBkb2VzIG5vdCBleGlzdGApOyB9XG4gICAgcmV0dXJuIHRoaXMuX2FsbFRhYmxlc1t0YWJsZU5hbWVdO1xuICB9XG59XG4iLCAiaW1wb3J0IHtcbiAgT2JzZXJ2YWJsZSBhcyBJT2JzZXJ2YWJsZSxcbiAgT2JzZXJ2ZXIsXG4gIFN1YnNjcmlwdGlvbixcbn0gZnJvbSBcIi4uLy4uL3B1YmxpYy90eXBlcy9vYnNlcnZhYmxlXCI7XG5cbmNvbnN0IHN5bWJvbE9ic2VydmFibGU6IHR5cGVvZiBTeW1ib2wub2JzZXJ2YWJsZSA9XG4gIHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgXCJvYnNlcnZhYmxlXCIgaW4gU3ltYm9sXG4gICAgPyBTeW1ib2wub2JzZXJ2YWJsZVxuICAgIDogXCJAQG9ic2VydmFibGVcIiBhcyBhbnk7XG5cbmV4cG9ydCBjbGFzcyBPYnNlcnZhYmxlPFQ+IGltcGxlbWVudHMgSU9ic2VydmFibGU8VD4ge1xuICBwcml2YXRlIF9zdWJzY3JpYmU6IChvYnNlcnZlcjogT2JzZXJ2ZXI8VD4pID0+IFN1YnNjcmlwdGlvbjtcbiAgaGFzVmFsdWU/OiAoKT0+Ym9vbGVhbjtcbiAgZ2V0VmFsdWU/OiAoKT0+VDtcblxuICBjb25zdHJ1Y3RvcihzdWJzY3JpYmU6IChvYnNlcnZlcjogT2JzZXJ2ZXI8VD4pID0+IFN1YnNjcmlwdGlvbikge1xuICAgIHRoaXMuX3N1YnNjcmliZSA9IHN1YnNjcmliZTtcbiAgfVxuXG4gIHN1YnNjcmliZShcbiAgICBvbk5leHQ/OiAoKHZhbHVlOiBUKSA9PiB2b2lkKSB8wqBudWxsLFxuICAgIG9uRXJyb3I/OiAoKGVycm9yOiBhbnkpID0+IHZvaWQpIHwgbnVsbCxcbiAgICBvbkNvbXBsZXRlPzogKCgpID0+IHZvaWQpIHwgbnVsbFxuICApOiBTdWJzY3JpcHRpb247XG4gIHN1YnNjcmliZShvYnNlcnZlcj86IE9ic2VydmVyPFQ+IHwgbnVsbCk6IFN1YnNjcmlwdGlvbjtcbiAgc3Vic2NyaWJlKHg/OiBhbnksIGVycm9yPzogYW55LCBjb21wbGV0ZT86IGFueSk6IFN1YnNjcmlwdGlvbiB7XG4gICAgcmV0dXJuIHRoaXMuX3N1YnNjcmliZShcbiAgICAgICF4IHx8IHR5cGVvZiB4ID09PSBcImZ1bmN0aW9uXCIgPyB7IG5leHQ6IHgsIGVycm9yLCBjb21wbGV0ZSB9IDogeFxuICAgICk7XG4gIH1cblxuICBbc3ltYm9sT2JzZXJ2YWJsZV0oKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn1cbiIsICJpbXBvcnQgeyBkZWVwQ2xvbmUsIGtleXMgfSBmcm9tIFwiLi4vZnVuY3Rpb25zL3V0aWxzXCI7XG5pbXBvcnQgeyBtZXJnZVJhbmdlcywgUmFuZ2VTZXQgfSBmcm9tIFwiLi4vaGVscGVycy9yYW5nZXNldFwiO1xuaW1wb3J0IHsgT2JzZXJ2YWJpbGl0eVNldCB9IGZyb20gXCIuLi9wdWJsaWMvdHlwZXMvZGItZXZlbnRzXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBleHRlbmRPYnNlcnZhYmlsaXR5U2V0KFxuICB0YXJnZXQ6IE9ic2VydmFiaWxpdHlTZXQsXG4gIG5ld1NldDogT2JzZXJ2YWJpbGl0eVNldFxuKTogT2JzZXJ2YWJpbGl0eVNldCB7XG4gIGtleXMobmV3U2V0KS5mb3JFYWNoKHBhcnQgPT4ge1xuICAgIGNvbnN0IHJhbmdlU2V0ID0gdGFyZ2V0W3BhcnRdIHx8ICh0YXJnZXRbcGFydF0gPSBuZXcgUmFuZ2VTZXQoKSk7XG4gICAgbWVyZ2VSYW5nZXMocmFuZ2VTZXQsIG5ld1NldFtwYXJ0XSk7XG4gIH0pO1xuICByZXR1cm4gdGFyZ2V0O1xufVxuIiwgImltcG9ydCB7IGlzQXN5bmNGdW5jdGlvbiwga2V5cyB9IGZyb20gXCIuLi9mdW5jdGlvbnMvdXRpbHNcIjtcbmltcG9ydCB7IGdsb2JhbEV2ZW50cywgREVYSUVfU1RPUkFHRV9NVVRBVEVEX0VWRU5UX05BTUUgfSBmcm9tIFwiLi4vZ2xvYmFscy9nbG9iYWwtZXZlbnRzXCI7XG5pbXBvcnQge1xuICBkZWNyZW1lbnRFeHBlY3RlZEF3YWl0cyxcbiAgaW5jcmVtZW50RXhwZWN0ZWRBd2FpdHMsXG4gIG5ld1Njb3BlLFxuICBQU0QsXG4gIHVzZVBTRCxcbn0gZnJvbSBcIi4uL2hlbHBlcnMvcHJvbWlzZVwiO1xuaW1wb3J0IHsgT2JzZXJ2YWJpbGl0eVNldCB9IGZyb20gXCIuLi9wdWJsaWMvdHlwZXMvZGItZXZlbnRzXCI7XG5pbXBvcnQge1xuICBPYnNlcnZhYmxlIGFzIElPYnNlcnZhYmxlLFxuICBTdWJzY3JpcHRpb24sXG59IGZyb20gXCIuLi9wdWJsaWMvdHlwZXMvb2JzZXJ2YWJsZVwiO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gXCIuLi9jbGFzc2VzL29ic2VydmFibGUvb2JzZXJ2YWJsZVwiO1xuaW1wb3J0IHsgZXh0ZW5kT2JzZXJ2YWJpbGl0eVNldCB9IGZyb20gXCIuL2V4dGVuZC1vYnNlcnZhYmlsaXR5LXNldFwiO1xuaW1wb3J0IHsgcmFuZ2VzT3ZlcmxhcCB9IGZyb20gXCIuLi9oZWxwZXJzL3Jhbmdlc2V0XCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBsaXZlUXVlcnk8VD4ocXVlcmllcjogKCkgPT4gVCB8IFByb21pc2U8VD4pOiBJT2JzZXJ2YWJsZTxUPiB7XG4gIGxldCBoYXNWYWx1ZSA9IGZhbHNlO1xuICBsZXQgY3VycmVudFZhbHVlOiBUID0gdW5kZWZpbmVkIGFzIGFueTtcbiAgY29uc3Qgb2JzZXJ2YWJsZSA9IG5ldyBPYnNlcnZhYmxlPFQ+KChvYnNlcnZlcikgPT4ge1xuICAgIGNvbnN0IHNjb3BlRnVuY0lzQXN5bmMgPSBpc0FzeW5jRnVuY3Rpb24ocXVlcmllcik7XG4gICAgZnVuY3Rpb24gZXhlY3V0ZShzdWJzY3I6IE9ic2VydmFiaWxpdHlTZXQpIHtcbiAgICAgIGlmIChzY29wZUZ1bmNJc0FzeW5jKSB7XG4gICAgICAgIGluY3JlbWVudEV4cGVjdGVkQXdhaXRzKCk7XG4gICAgICB9XG4gICAgICBjb25zdCBleGVjID0gKCkgPT4gbmV3U2NvcGUocXVlcmllciwgeyBzdWJzY3IsIHRyYW5zOiBudWxsIH0pO1xuICAgICAgY29uc3QgcnYgPSBQU0QudHJhbnNcbiAgICAgICAgPyAvLyBJZ25vcmUgY3VycmVudCB0cmFuc2FjdGlvbiBpZiBhY3RpdmUgd2hlbiBjYWxsaW5nIHN1YnNjcmliZSgpLlxuICAgICAgICAgIHVzZVBTRChQU0QudHJhbnNsZXNzLCBleGVjKVxuICAgICAgICA6IGV4ZWMoKTtcbiAgICAgIGlmIChzY29wZUZ1bmNJc0FzeW5jKSB7XG4gICAgICAgIChydiBhcyBQcm9taXNlPGFueT4pLnRoZW4oXG4gICAgICAgICAgZGVjcmVtZW50RXhwZWN0ZWRBd2FpdHMsXG4gICAgICAgICAgZGVjcmVtZW50RXhwZWN0ZWRBd2FpdHNcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBydjtcbiAgICB9XG5cbiAgICBsZXQgY2xvc2VkID0gZmFsc2U7XG5cbiAgICBsZXQgYWNjdW1NdXRzOiBPYnNlcnZhYmlsaXR5U2V0ID0ge307XG4gICAgbGV0IGN1cnJlbnRPYnM6IE9ic2VydmFiaWxpdHlTZXQgPSB7fTtcblxuICAgIGNvbnN0IHN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uID0ge1xuICAgICAgZ2V0IGNsb3NlZCgpIHtcbiAgICAgICAgcmV0dXJuIGNsb3NlZDtcbiAgICAgIH0sXG4gICAgICB1bnN1YnNjcmliZTogKCkgPT4ge1xuICAgICAgICBjbG9zZWQgPSB0cnVlO1xuICAgICAgICBnbG9iYWxFdmVudHMuc3RvcmFnZW11dGF0ZWQudW5zdWJzY3JpYmUobXV0YXRpb25MaXN0ZW5lcik7XG4gICAgICB9LFxuICAgIH07XG5cbiAgICBvYnNlcnZlci5zdGFydCAmJiBvYnNlcnZlci5zdGFydChzdWJzY3JpcHRpb24pOyAvLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1vYnNlcnZhYmxlXG5cbiAgICBsZXQgcXVlcnlpbmcgPSBmYWxzZSxcbiAgICAgIHN0YXJ0ZWRMaXN0ZW5pbmcgPSBmYWxzZTtcblxuICAgIGZ1bmN0aW9uIHNob3VsZE5vdGlmeSgpIHtcbiAgICAgIHJldHVybiBrZXlzKGN1cnJlbnRPYnMpLnNvbWUoXG4gICAgICAgIChrZXkpID0+XG4gICAgICAgICAgYWNjdW1NdXRzW2tleV0gJiYgcmFuZ2VzT3ZlcmxhcChhY2N1bU11dHNba2V5XSwgY3VycmVudE9ic1trZXldKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBjb25zdCBtdXRhdGlvbkxpc3RlbmVyID0gKHBhcnRzOiBPYnNlcnZhYmlsaXR5U2V0KSA9PiB7XG4gICAgICBleHRlbmRPYnNlcnZhYmlsaXR5U2V0KGFjY3VtTXV0cywgcGFydHMpO1xuICAgICAgaWYgKHNob3VsZE5vdGlmeSgpKSB7XG4gICAgICAgIGRvUXVlcnkoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3QgZG9RdWVyeSA9ICgpID0+IHtcbiAgICAgIGlmIChxdWVyeWluZyB8fCBjbG9zZWQpIHJldHVybjtcbiAgICAgIGFjY3VtTXV0cyA9IHt9O1xuICAgICAgY29uc3Qgc3Vic2NyOiBPYnNlcnZhYmlsaXR5U2V0ID0ge307XG4gICAgICBjb25zdCByZXQgPSBleGVjdXRlKHN1YnNjcik7XG4gICAgICBpZiAoIXN0YXJ0ZWRMaXN0ZW5pbmcpIHtcbiAgICAgICAgZ2xvYmFsRXZlbnRzKERFWElFX1NUT1JBR0VfTVVUQVRFRF9FVkVOVF9OQU1FLCBtdXRhdGlvbkxpc3RlbmVyKTtcbiAgICAgICAgc3RhcnRlZExpc3RlbmluZyA9IHRydWU7XG4gICAgICB9XG4gICAgICBxdWVyeWluZyA9IHRydWU7XG4gICAgICBQcm9taXNlLnJlc29sdmUocmV0KS50aGVuKFxuICAgICAgICAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgaGFzVmFsdWUgPSB0cnVlO1xuICAgICAgICAgIGN1cnJlbnRWYWx1ZSA9IHJlc3VsdDtcbiAgICAgICAgICBxdWVyeWluZyA9IGZhbHNlO1xuICAgICAgICAgIGlmIChjbG9zZWQpIHJldHVybjtcbiAgICAgICAgICBpZiAoc2hvdWxkTm90aWZ5KCkpIHtcbiAgICAgICAgICAgIC8vIE11dGF0aW9ucyBoYXMgaGFwcGVuZWQgd2hpbGUgd2Ugd2VyZSBxdWVyeWluZy4gUmVkbyBxdWVyeS5cbiAgICAgICAgICAgIGRvUXVlcnkoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWNjdW1NdXRzID0ge307XG4gICAgICAgICAgICAvLyBVcGRhdGUgd2hhdCB3ZSBhcmUgc3Vic2NyaWJpbmcgZm9yIGJhc2VkIG9uIHRoaXMgbGFzdCBydW46XG4gICAgICAgICAgICBjdXJyZW50T2JzID0gc3Vic2NyO1xuICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dCAmJiBvYnNlcnZlci5uZXh0KHJlc3VsdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAoZXJyKSA9PiB7XG4gICAgICAgICAgcXVlcnlpbmcgPSBmYWxzZTtcbiAgICAgICAgICBoYXNWYWx1ZSA9IGZhbHNlO1xuICAgICAgICAgIG9ic2VydmVyLmVycm9yICYmIG9ic2VydmVyLmVycm9yKGVycik7XG4gICAgICAgICAgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfTtcblxuICAgIGRvUXVlcnkoKTtcbiAgICByZXR1cm4gc3Vic2NyaXB0aW9uO1xuICB9KTtcbiAgb2JzZXJ2YWJsZS5oYXNWYWx1ZSA9ICgpID0+IGhhc1ZhbHVlO1xuICBvYnNlcnZhYmxlLmdldFZhbHVlID0gKCkgPT4gY3VycmVudFZhbHVlO1xuICByZXR1cm4gb2JzZXJ2YWJsZTtcbn1cbiIsICJpbXBvcnQgeyBfZ2xvYmFsIH0gZnJvbSAnLi4vLi4vZ2xvYmFscy9nbG9iYWwnO1xuaW1wb3J0IHsgRGV4aWVET01EZXBlbmRlbmNpZXMgfSBmcm9tICcuLi8uLi9wdWJsaWMvdHlwZXMvZGV4aWUtZG9tLWRlcGVuZGVuY2llcyc7XG5cbmV4cG9ydCBsZXQgZG9tRGVwczogRGV4aWVET01EZXBlbmRlbmNpZXNcblxudHJ5IHtcbiAgZG9tRGVwcyA9IHtcbiAgICAvLyBSZXF1aXJlZDpcbiAgICBpbmRleGVkREI6IF9nbG9iYWwuaW5kZXhlZERCIHx8IF9nbG9iYWwubW96SW5kZXhlZERCIHx8IF9nbG9iYWwud2Via2l0SW5kZXhlZERCIHx8IF9nbG9iYWwubXNJbmRleGVkREIsXG4gICAgSURCS2V5UmFuZ2U6IF9nbG9iYWwuSURCS2V5UmFuZ2UgfHwgX2dsb2JhbC53ZWJraXRJREJLZXlSYW5nZVxuICB9O1xufSBjYXRjaCAoZSkge1xuICBkb21EZXBzID0geyBpbmRleGVkREI6IG51bGwsIElEQktleVJhbmdlOiBudWxsIH07XG59XG4iLCAiaW1wb3J0IHsgRGV4aWUgYXMgX0RleGllIH0gZnJvbSAnLi9kZXhpZSc7XG5pbXBvcnQgeyBfZ2xvYmFsIH0gZnJvbSAnLi4vLi4vZ2xvYmFscy9nbG9iYWwnO1xuaW1wb3J0IHsgcHJvcHMsIGRlcml2ZSwgZXh0ZW5kLCBvdmVycmlkZSwgZ2V0QnlLZXlQYXRoLCBzZXRCeUtleVBhdGgsIGRlbEJ5S2V5UGF0aCwgc2hhbGxvd0Nsb25lLCBkZWVwQ2xvbmUsIGFzYXAgfSBmcm9tICcuLi8uLi9mdW5jdGlvbnMvdXRpbHMnO1xuaW1wb3J0IHsgZ2V0T2JqZWN0RGlmZiB9IGZyb20gXCIuLi8uLi9mdW5jdGlvbnMvZ2V0LW9iamVjdC1kaWZmXCI7XG5pbXBvcnQgeyBmdWxsTmFtZUV4Y2VwdGlvbnMgfSBmcm9tICcuLi8uLi9lcnJvcnMnO1xuaW1wb3J0IHsgRGV4aWVDb25zdHJ1Y3RvciB9IGZyb20gJy4uLy4uL3B1YmxpYy90eXBlcy9kZXhpZS1jb25zdHJ1Y3Rvcic7XG5pbXBvcnQgeyBnZXREYXRhYmFzZU5hbWVzIH0gZnJvbSAnLi4vLi4vaGVscGVycy9kYXRhYmFzZS1lbnVtZXJhdG9yJztcbmltcG9ydCB7IFBTRCB9IGZyb20gJy4uLy4uL2hlbHBlcnMvcHJvbWlzZSc7XG5pbXBvcnQgeyB1c2VQU0QgfSBmcm9tICcuLi8uLi9oZWxwZXJzL3Byb21pc2UnO1xuaW1wb3J0IHsgbmV3U2NvcGUgfSBmcm9tICcuLi8uLi9oZWxwZXJzL3Byb21pc2UnO1xuaW1wb3J0IHsgcmVqZWN0aW9uIH0gZnJvbSAnLi4vLi4vaGVscGVycy9wcm9taXNlJztcbmltcG9ydCB7IGF3YWl0SXRlcmF0b3IgfSBmcm9tICcuLi8uLi9oZWxwZXJzL3lpZWxkLXN1cHBvcnQnO1xuaW1wb3J0IFByb21pc2UgZnJvbSAnLi4vLi4vaGVscGVycy9wcm9taXNlJztcbmltcG9ydCAqIGFzIERlYnVnIGZyb20gJy4uLy4uL2hlbHBlcnMvZGVidWcnO1xuaW1wb3J0IHsgZGV4aWVTdGFja0ZyYW1lRmlsdGVyLCBtaW5LZXksIGNvbm5lY3Rpb25zLCBERVhJRV9WRVJTSU9OIH0gZnJvbSAnLi4vLi4vZ2xvYmFscy9jb25zdGFudHMnO1xuaW1wb3J0IEV2ZW50cyBmcm9tICcuLi8uLi9oZWxwZXJzL0V2ZW50cyc7XG5pbXBvcnQgeyBleGNlcHRpb25zIH0gZnJvbSAnLi4vLi4vZXJyb3JzJztcbmltcG9ydCB7IGVycm5hbWVzIH0gZnJvbSAnLi4vLi4vZXJyb3JzJztcbmltcG9ydCB7IGdldE1heEtleSB9IGZyb20gJy4uLy4uL2Z1bmN0aW9ucy9xdWlya3MnO1xuaW1wb3J0IHsgdmlwIH0gZnJvbSAnLi92aXAnO1xuaW1wb3J0IHsgZ2xvYmFsRXZlbnRzIH0gZnJvbSAnLi4vLi4vZ2xvYmFscy9nbG9iYWwtZXZlbnRzJztcbmltcG9ydCB7IGxpdmVRdWVyeSB9IGZyb20gJy4uLy4uL2xpdmUtcXVlcnkvbGl2ZS1xdWVyeSc7XG5pbXBvcnQgeyBleHRlbmRPYnNlcnZhYmlsaXR5U2V0IH0gZnJvbSAnLi4vLi4vbGl2ZS1xdWVyeS9leHRlbmQtb2JzZXJ2YWJpbGl0eS1zZXQnO1xuaW1wb3J0IHsgZG9tRGVwcyB9IGZyb20gJy4vZGV4aWUtZG9tLWRlcGVuZGVuY2llcyc7XG5pbXBvcnQgeyBjbXAgfSBmcm9tICcuLi8uLi9mdW5jdGlvbnMvY21wJztcblxuLyogKERleGllKSBpcyBhbiBpbnN0YW5jZSBvZiBEZXhpZUNvbnN0cnVjdG9yLCBhcyBkZWZpbmVkIGluIHB1YmxpYy90eXBlcy9kZXhpZS1jb25zdHJ1Y3Rvci5kLnRzXG4qICAobmV3IERleGllKCkpIGlzIGFuIGluc3RhbmNlIG9mIERleGllLCBhcyBkZWZpbmVkIGluIHB1YmxpYy90eXBlcy9kZXhpZS5kLnRzXG4qIFxuKiBXaHkgd2UncmUgZG9pbmcgdGhpcz9cblxuKiBCZWNhdXNlIHdlJ3ZlIGNob29zZW4gdG8gZGVmaW5lIHRoZSBwdWJsaWMgRGV4aWUgQVBJIHVzaW5nIGEgRGV4aWVDb25zdHJ1Y3RvciBpbnRlcmZhY2VcbiogcmF0aGVyIHRoYW4gZGVjbGFyaW5nIGEgY2xhc3MuIE9uIHRoYXQgaW50ZXJmYWNlLCBhbGwgc3RhdGljIHByb3BzIGFyZSBkZWZpbmVkLlxuKiBJbiBwcmFjdGljZSwgY2xhc3MgRGV4aWUncyBjb25zdHJ1Y3RvciBpbXBsZW1lbnRzIERleGllQ29uc3RydWN0b3IgYW5kIGFsbCBtZW1iZXIgcHJvcHNcbiogYXJlIGRlZmluZWQgaW4gaW50ZXJmYWNlIERleGllLiBXZSBjb3VsZCBzYXksIGl0J3MgYSB0eXBlc2NyaXB0IGxpbWl0YXRpb24gb2Ygbm90IGJlaW5nXG4qIGFibGUgdG8gZGVmaW5lIGEgc3RhdGljIGludGVyZmFjZSB0aGF0IGZvcmNlcyB1cyB0byBkbyB0aGUgY2FzdCBiZWxvdy5cbiovXG5jb25zdCBEZXhpZSA9IF9EZXhpZSBhcyBhbnkgYXMgRGV4aWVDb25zdHJ1Y3RvcjtcblxuLy9cbi8vIFNldCBhbGwgc3RhdGljIG1ldGhvZHMgYW5kIHByb3BlcnRpZXMgb250byBEZXhpZTpcbi8vIFxucHJvcHMoRGV4aWUsIHtcblxuICAvLyBEZXhpZS5CdWxrRXJyb3IgPSBjbGFzcyBCdWxrRXJyb3Igey4uLn07XG4gIC8vIERleGllLlhYWEVycm9yID0gY2xhc3MgWFhYRXJyb3Igey4uLn07XG4gIC4uLmZ1bGxOYW1lRXhjZXB0aW9ucyxcblxuICAvL1xuICAvLyBTdGF0aWMgZGVsZXRlKCkgbWV0aG9kLlxuICAvL1xuICBkZWxldGUoZGF0YWJhc2VOYW1lOiBzdHJpbmcpIHtcbiAgICBjb25zdCBkYiA9IG5ldyBEZXhpZShkYXRhYmFzZU5hbWUsIHthZGRvbnM6IFtdfSk7XG4gICAgcmV0dXJuIGRiLmRlbGV0ZSgpO1xuICB9LFxuXG4gIC8vXG4gIC8vIFN0YXRpYyBleGlzdHMoKSBtZXRob2QuXG4gIC8vXG4gIGV4aXN0cyhuYW1lOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gbmV3IERleGllKG5hbWUsIHsgYWRkb25zOiBbXSB9KS5vcGVuKCkudGhlbihkYiA9PiB7XG4gICAgICBkYi5jbG9zZSgpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSkuY2F0Y2goJ05vU3VjaERhdGFiYXNlRXJyb3InLCAoKSA9PiBmYWxzZSk7XG4gIH0sXG5cbiAgLy9cbiAgLy8gU3RhdGljIG1ldGhvZCBmb3IgcmV0cmlldmluZyBhIGxpc3Qgb2YgYWxsIGV4aXN0aW5nIGRhdGFiYXNlcyBhdCBjdXJyZW50IGhvc3QuXG4gIC8vXG4gIGdldERhdGFiYXNlTmFtZXMoY2IpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGdldERhdGFiYXNlTmFtZXMoRGV4aWUuZGVwZW5kZW5jaWVzKS50aGVuKGNiKTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiByZWplY3Rpb24obmV3IGV4Y2VwdGlvbnMuTWlzc2luZ0FQSSgpKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqIEBkZXByZWNhdGVkICovXG4gIGRlZmluZUNsYXNzKCkge1xuICAgIGZ1bmN0aW9uIENsYXNzKGNvbnRlbnQpIHtcbiAgICAgIGV4dGVuZCh0aGlzLCBjb250ZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIENsYXNzO1xuICB9LFxuXG4gIGlnbm9yZVRyYW5zYWN0aW9uKHNjb3BlRnVuYykge1xuICAgIC8vIEluIGNhc2UgY2FsbGVyIGlzIHdpdGhpbiBhIHRyYW5zYWN0aW9uIGJ1dCBuZWVkcyB0byBjcmVhdGUgYSBzZXBhcmF0ZSB0cmFuc2FjdGlvbi5cbiAgICAvLyBFeGFtcGxlIG9mIHVzYWdlOlxuICAgIC8vXG4gICAgLy8gTGV0J3Mgc2F5IHdlIGhhdmUgYSBsb2dnZXIgZnVuY3Rpb24gaW4gb3VyIGFwcC4gT3RoZXIgYXBwbGljYXRpb24tbG9naWMgc2hvdWxkIGJlIHVuYXdhcmUgb2YgdGhlXG4gICAgLy8gbG9nZ2VyIGZ1bmN0aW9uIGFuZCBub3QgbmVlZCB0byBpbmNsdWRlIHRoZSAnbG9nZW50cmllcycgdGFibGUgaW4gYWxsIHRyYW5zYWN0aW9uIGl0IHBlcmZvcm1zLlxuICAgIC8vIFRoZSBsb2dnaW5nIHNob3VsZCBhbHdheXMgYmUgZG9uZSBpbiBhIHNlcGFyYXRlIHRyYW5zYWN0aW9uIGFuZCBub3QgYmUgZGVwZW5kYW50IG9uIHRoZSBjdXJyZW50XG4gICAgLy8gcnVubmluZyB0cmFuc2FjdGlvbiBjb250ZXh0LiBUaGVuIHlvdSBjb3VsZCB1c2UgRGV4aWUuaWdub3JlVHJhbnNhY3Rpb24oKSB0byBydW4gY29kZSB0aGF0IHN0YXJ0cyBhIG5ldyB0cmFuc2FjdGlvbi5cbiAgICAvL1xuICAgIC8vICAgICBEZXhpZS5pZ25vcmVUcmFuc2FjdGlvbihmdW5jdGlvbigpIHtcbiAgICAvLyAgICAgICAgIGRiLmxvZ2VudHJpZXMuYWRkKG5ld0xvZ0VudHJ5KTtcbiAgICAvLyAgICAgfSk7XG4gICAgLy9cbiAgICAvLyBVbmxlc3MgdXNpbmcgRGV4aWUuaWdub3JlVHJhbnNhY3Rpb24oKSwgdGhlIGFib3ZlIGV4YW1wbGUgd291bGQgdHJ5IHRvIHJldXNlIHRoZSBjdXJyZW50IHRyYW5zYWN0aW9uXG4gICAgLy8gaW4gY3VycmVudCBQcm9taXNlLXNjb3BlLlxuICAgIC8vXG4gICAgLy8gQW4gYWx0ZXJuYXRpdmUgdG8gRGV4aWUuaWdub3JlVHJhbnNhY3Rpb24oKSB3b3VsZCBiZSBzZXRJbW1lZGlhdGUoKSBvciBzZXRUaW1lb3V0KCkuIFRoZSByZWFzb24gd2Ugc3RpbGwgcHJvdmlkZSBhblxuICAgIC8vIEFQSSBmb3IgdGhpcyBiZWNhdXNlXG4gICAgLy8gIDEpIFRoZSBpbnRlbnRpb24gb2Ygd3JpdGluZyB0aGUgc3RhdGVtZW50IGNvdWxkIGJlIHVuY2xlYXIgaWYgdXNpbmcgc2V0SW1tZWRpYXRlKCkgb3Igc2V0VGltZW91dCgpLlxuICAgIC8vICAyKSBzZXRUaW1lb3V0KCkgd291bGQgd2FpdCB1bm5lc2Nlc3NhcnkgdW50aWwgZmlyaW5nLiBUaGlzIGlzIGhvd2V2ZXIgbm90IHRoZSBjYXNlIHdpdGggc2V0SW1tZWRpYXRlKCkuXG4gICAgLy8gIDMpIHNldEltbWVkaWF0ZSgpIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhlIEVTIHN0YW5kYXJkLlxuICAgIC8vICA0KSBZb3UgbWlnaHQgd2FudCB0byBrZWVwIG90aGVyIFBTRCBzdGF0ZSB0aGF0IHdhcyBzZXQgaW4gYSBwYXJlbnQgUFNELCBzdWNoIGFzIFBTRC5sZXRUaHJvdWdoLlxuICAgIHJldHVybiBQU0QudHJhbnMgP1xuICAgICAgdXNlUFNEKFBTRC50cmFuc2xlc3MsIHNjb3BlRnVuYykgOiAvLyBVc2UgdGhlIGNsb3Nlc3QgcGFyZW50IHRoYXQgd2FzIG5vbi10cmFuc2FjdGlvbmFsLlxuICAgICAgc2NvcGVGdW5jKCk7IC8vIE5vIG5lZWQgdG8gY2hhbmdlIHNjb3BlIGJlY2F1c2UgdGhlcmUgaXMgbm8gb25nb2luZyB0cmFuc2FjdGlvbi5cbiAgfSxcblxuICB2aXAsXG5cbiAgYXN5bmM6IGZ1bmN0aW9uIChnZW5lcmF0b3JGbjogRnVuY3Rpb24pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHJ2ID0gYXdhaXRJdGVyYXRvcihnZW5lcmF0b3JGbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgICAgICAgaWYgKCFydiB8fCB0eXBlb2YgcnYudGhlbiAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJ2KTtcbiAgICAgICAgcmV0dXJuIHJ2O1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gcmVqZWN0aW9uKGUpO1xuICAgICAgfVxuICAgIH07XG4gIH0sXG5cbiAgc3Bhd246IGZ1bmN0aW9uIChnZW5lcmF0b3JGbiwgYXJncywgdGhpeikge1xuICAgIHRyeSB7XG4gICAgICB2YXIgcnYgPSBhd2FpdEl0ZXJhdG9yKGdlbmVyYXRvckZuLmFwcGx5KHRoaXosIGFyZ3MgfHwgW10pKTtcbiAgICAgIGlmICghcnYgfHwgdHlwZW9mIHJ2LnRoZW4gIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocnYpO1xuICAgICAgcmV0dXJuIHJ2O1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiByZWplY3Rpb24oZSk7XG4gICAgfVxuICB9LFxuXG4gIC8vIERleGllLmN1cnJlbnRUcmFuc2FjdGlvbiBwcm9wZXJ0eVxuICBjdXJyZW50VHJhbnNhY3Rpb246IHtcbiAgICBnZXQ6ICgpID0+IFBTRC50cmFucyB8fCBudWxsXG4gIH0sXG5cbiAgd2FpdEZvcjogZnVuY3Rpb24gKHByb21pc2VPckZ1bmN0aW9uLCBvcHRpb25hbFRpbWVvdXQpIHtcbiAgICAvLyBJZiBhIGZ1bmN0aW9uIGlzIHByb3ZpZGVkLCBpbnZva2UgaXQgYW5kIHBhc3MgdGhlIHJldHVybmluZyB2YWx1ZSB0byBUcmFuc2FjdGlvbi53YWl0Rm9yKClcbiAgICBjb25zdCBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKFxuICAgICAgdHlwZW9mIHByb21pc2VPckZ1bmN0aW9uID09PSAnZnVuY3Rpb24nID9cbiAgICAgICAgRGV4aWUuaWdub3JlVHJhbnNhY3Rpb24ocHJvbWlzZU9yRnVuY3Rpb24pIDpcbiAgICAgICAgcHJvbWlzZU9yRnVuY3Rpb24pXG4gICAgICAudGltZW91dChvcHRpb25hbFRpbWVvdXQgfHwgNjAwMDApOyAvLyBEZWZhdWx0IHRoZSB0aW1lb3V0IHRvIG9uZSBtaW51dGUuIENhbGxlciBtYXkgc3BlY2lmeSBJbmZpbml0eSBpZiByZXF1aXJlZC4gICAgICAgXG5cbiAgICAvLyBSdW4gZ2l2ZW4gcHJvbWlzZSBvbiBjdXJyZW50IHRyYW5zYWN0aW9uLiBJZiBubyBjdXJyZW50IHRyYW5zYWN0aW9uLCBqdXN0IHJldHVybiBhIERleGllIHByb21pc2UgYmFzZWRcbiAgICAvLyBvbiBnaXZlbiB2YWx1ZS5cbiAgICByZXR1cm4gUFNELnRyYW5zID9cbiAgICAgIFBTRC50cmFucy53YWl0Rm9yKHByb21pc2UpIDpcbiAgICAgIHByb21pc2U7XG4gIH0sXG5cbiAgLy8gRXhwb3J0IG91ciBQcm9taXNlIGltcGxlbWVudGF0aW9uIHNpbmNlIGl0IGNhbiBiZSBoYW5keSBhcyBhIHN0YW5kYWxvbmUgUHJvbWlzZSBpbXBsZW1lbnRhdGlvblxuICBQcm9taXNlOiBQcm9taXNlLFxuXG4gIC8vIERleGllLmRlYnVnIHByb3B0ZXJ5OlxuICAvLyBEZXhpZS5kZWJ1ZyA9IGZhbHNlXG4gIC8vIERleGllLmRlYnVnID0gdHJ1ZVxuICAvLyBEZXhpZS5kZWJ1ZyA9IFwiZGV4aWVcIiAtIGRvbid0IGhpZGUgZGV4aWUncyBzdGFjayBmcmFtZXMuXG4gIGRlYnVnOiB7XG4gICAgZ2V0OiAoKSA9PiBEZWJ1Zy5kZWJ1ZyxcbiAgICBzZXQ6IHZhbHVlID0+IHtcbiAgICAgIERlYnVnLnNldERlYnVnKHZhbHVlLCB2YWx1ZSA9PT0gJ2RleGllJyA/ICgpID0+IHRydWUgOiBkZXhpZVN0YWNrRnJhbWVGaWx0ZXIpO1xuICAgIH1cbiAgfSxcblxuICAvLyBFeHBvcnQgb3VyIGRlcml2ZS9leHRlbmQvb3ZlcnJpZGUgbWV0aG9kb2xvZ3lcbiAgZGVyaXZlOiBkZXJpdmUsIC8vIERlcHJlY2F0ZT9cbiAgZXh0ZW5kOiBleHRlbmQsIC8vIERlcHJlY2F0ZT9cbiAgcHJvcHM6IHByb3BzLFxuICBvdmVycmlkZTogb3ZlcnJpZGUsIC8vIERlcHJlY2F0ZT9cbiAgLy8gRXhwb3J0IG91ciBFdmVudHMoKSBmdW5jdGlvbiAtIGNhbiBiZSBoYW5keSBhcyBhIHRvb2xraXRcbiAgRXZlbnRzOiBFdmVudHMsXG4gIG9uOiBnbG9iYWxFdmVudHMsXG4gIGxpdmVRdWVyeSxcbiAgZXh0ZW5kT2JzZXJ2YWJpbGl0eVNldCxcbiAgLy8gVXRpbGl0aWVzXG4gIGdldEJ5S2V5UGF0aDogZ2V0QnlLZXlQYXRoLFxuICBzZXRCeUtleVBhdGg6IHNldEJ5S2V5UGF0aCxcbiAgZGVsQnlLZXlQYXRoOiBkZWxCeUtleVBhdGgsXG4gIHNoYWxsb3dDbG9uZTogc2hhbGxvd0Nsb25lLFxuICBkZWVwQ2xvbmU6IGRlZXBDbG9uZSxcbiAgZ2V0T2JqZWN0RGlmZjogZ2V0T2JqZWN0RGlmZixcbiAgY21wLFxuICBhc2FwOiBhc2FwLFxuICAvL21heEtleTogbmV3IERleGllKCcnLHthZGRvbnM6W119KS5fbWF4S2V5LFxuICBtaW5LZXk6IG1pbktleSxcbiAgLy8gQWRkb24gcmVnaXN0cnlcbiAgYWRkb25zOiBbXSxcbiAgLy8gR2xvYmFsIERCIGNvbm5lY3Rpb24gbGlzdFxuICBjb25uZWN0aW9uczogY29ubmVjdGlvbnMsXG5cbiAgLy9NdWx0aU1vZGlmeUVycm9yOiBleGNlcHRpb25zLk1vZGlmeSwgLy8gT2Jzb2xldGUhXG4gIGVycm5hbWVzOiBlcnJuYW1lcyxcblxuICAvLyBFeHBvcnQgb3RoZXIgc3RhdGljIGNsYXNzZXNcbiAgLy9JbmRleFNwZWM6IEluZGV4U3BlYywgT2Jzb2xldGUhXG4gIC8vVGFibGVTY2hlbWE6IFRhYmxlU2NoZW1hLCBPYnNvbGV0ZSFcblxuICAvL1xuICAvLyBEZXBlbmRlbmNpZXNcbiAgLy9cbiAgLy8gVGhlc2Ugd2lsbCBhdXRvbWF0aWNhbGx5IHdvcmsgaW4gYnJvd3NlcnMgd2l0aCBpbmRleGVkREIgc3VwcG9ydCwgb3Igd2hlcmUgYW4gaW5kZXhlZERCIHBvbHlmaWxsIGhhcyBiZWVuIGluY2x1ZGVkLlxuICAvL1xuICAvLyBJbiBub2RlLmpzLCBob3dldmVyLCB0aGVzZSBwcm9wZXJ0aWVzIG11c3QgYmUgc2V0IFwibWFudWFsbHlcIiBiZWZvcmUgaW5zdGFuc2lhdGluZyBhIG5ldyBEZXhpZSgpLlxuICAvLyBGb3Igbm9kZS5qcywgeW91IG5lZWQgdG8gcmVxdWlyZSBpbmRleGVkZGItanMgb3Igc2ltaWxhciBhbmQgdGhlbiBzZXQgdGhlc2UgZGVwcy5cbiAgLy9cbiAgZGVwZW5kZW5jaWVzOiBkb21EZXBzLFxuXG4gIC8vIEFQSSBWZXJzaW9uIE51bWJlcjogVHlwZSBOdW1iZXIsIG1ha2Ugc3VyZSB0byBhbHdheXMgc2V0IGEgdmVyc2lvbiBudW1iZXIgdGhhdCBjYW4gYmUgY29tcGFyYWJsZSBjb3JyZWN0bHkuIEV4YW1wbGU6IDAuOSwgMC45MSwgMC45MiwgMS4wLCAxLjAxLCAxLjEsIDEuMiwgMS4yMSwgZXRjLlxuICBzZW1WZXI6IERFWElFX1ZFUlNJT04sXG4gIHZlcnNpb246IERFWElFX1ZFUlNJT04uc3BsaXQoJy4nKVxuICAgIC5tYXAobiA9PiBwYXJzZUludChuKSlcbiAgICAucmVkdWNlKChwLCBjLCBpKSA9PiBwICsgKGMgLyBNYXRoLnBvdygxMCwgaSAqIDIpKSksXG5cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2RmYWhsYW5kZXIvRGV4aWUuanMvaXNzdWVzLzE4NlxuICAvLyB0eXBlc2NyaXB0IGNvbXBpbGVyIHRzYyBpbiBtb2RlIHRzLS0+ZXM1ICYgY29tbW9uSlMsIHdpbGwgZXhwZWN0IHJlcXVpcmUoKSB0byByZXR1cm5cbiAgLy8geC5kZWZhdWx0LiBXb3JrYXJvdW5kOiBTZXQgRGV4aWUuZGVmYXVsdCA9IERleGllLlxuICAvLyBkZWZhdWx0OiBEZXhpZSwgLy8gQ29tbWVudGVkIGJlY2F1c2Ugc29sdmVkIGluIGluZGV4LXVtZC50cyBpbnN0ZWFkLlxuICAvLyBNYWtlIGl0IHBvc3NpYmxlIHRvIGltcG9ydCB7RGV4aWV9IChub24tZGVmYXVsdCBpbXBvcnQpXG4gIC8vIFJlYXNvbiAxOiBNYXkgc3dpdGNoIHRvIHRoYXQgaW4gZnV0dXJlLlxuICAvLyBSZWFzb24gMjogV2UgZGVjbGFyZSBpdCBib3RoIGRlZmF1bHQgYW5kIG5hbWVkIGV4cG9ydGVkIGluIGQudHMgdG8gbWFrZSBpdCBwb3NzaWJsZVxuICAvLyB0byBsZXQgYWRkb25zIGV4dGVuZCB0aGUgRGV4aWUgaW50ZXJmYWNlIHdpdGggVHlwZXNjcmlwdCAyLjEgKHdvcmtzIG9ubHkgd2hlbiBleHBsaWNpdGVseVxuICAvLyBleHBvcnRpbmcgdGhlIHN5bWJvbCwgbm90IGp1c3QgZGVmYXVsdCBleHBvcnRpbmcpXG4gIC8vIERleGllOiBEZXhpZSAvLyBDb21tZW50ZWQgYmVjYXVzZSBzb2x2ZWQgaW4gaW5kZXgtdW1kLnRzIGluc3RlYWQuXG59KTtcblxuRGV4aWUubWF4S2V5ID0gZ2V0TWF4S2V5KERleGllLmRlcGVuZGVuY2llcy5JREJLZXlSYW5nZSk7XG4iLCAiaW1wb3J0IHsgaXNJRU9yRWRnZSB9IGZyb20gJy4uL2dsb2JhbHMvY29uc3RhbnRzJztcbmltcG9ydCB7IGdsb2JhbEV2ZW50cywgREVYSUVfU1RPUkFHRV9NVVRBVEVEX0VWRU5UX05BTUUsIFNUT1JBR0VfTVVUQVRFRF9ET01fRVZFTlRfTkFNRSB9IGZyb20gJy4uL2dsb2JhbHMvZ2xvYmFsLWV2ZW50cyc7XG5pbXBvcnQgeyBPYnNlcnZhYmlsaXR5U2V0IH0gZnJvbSBcIi4uL3B1YmxpYy90eXBlcy9kYi1ldmVudHNcIjtcblxuaWYgKHR5cGVvZiBkaXNwYXRjaEV2ZW50ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgYWRkRXZlbnRMaXN0ZW5lciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgZ2xvYmFsRXZlbnRzKERFWElFX1NUT1JBR0VfTVVUQVRFRF9FVkVOVF9OQU1FLCB1cGRhdGVkUGFydHMgPT4ge1xuICAgIGlmICghcHJvcGFnYXRpbmdMb2NhbGx5KSB7XG4gICAgICBsZXQgZXZlbnQ6IEN1c3RvbUV2ZW50PE9ic2VydmFiaWxpdHlTZXQ+O1xuICAgICAgaWYgKGlzSUVPckVkZ2UpIHtcbiAgICAgICAgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnQ3VzdG9tRXZlbnQnKTtcbiAgICAgICAgZXZlbnQuaW5pdEN1c3RvbUV2ZW50KFNUT1JBR0VfTVVUQVRFRF9ET01fRVZFTlRfTkFNRSwgdHJ1ZSwgdHJ1ZSwgdXBkYXRlZFBhcnRzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KFNUT1JBR0VfTVVUQVRFRF9ET01fRVZFTlRfTkFNRSwge1xuICAgICAgICAgIGRldGFpbDogdXBkYXRlZFBhcnRzXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcHJvcGFnYXRpbmdMb2NhbGx5ID0gdHJ1ZTtcbiAgICAgIGRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgICAgcHJvcGFnYXRpbmdMb2NhbGx5ID0gZmFsc2U7XG4gICAgfVxuICB9KTtcbiAgYWRkRXZlbnRMaXN0ZW5lcihTVE9SQUdFX01VVEFURURfRE9NX0VWRU5UX05BTUUsICh7ZGV0YWlsfTogQ3VzdG9tRXZlbnQ8T2JzZXJ2YWJpbGl0eVNldD4pID0+IHtcbiAgICBpZiAoIXByb3BhZ2F0aW5nTG9jYWxseSkge1xuICAgICAgcHJvcGFnYXRlTG9jYWxseShkZXRhaWwpO1xuICAgIH1cbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwcm9wYWdhdGVMb2NhbGx5KHVwZGF0ZVBhcnRzOiBPYnNlcnZhYmlsaXR5U2V0KSB7XG4gIGxldCB3YXNNZSA9IHByb3BhZ2F0aW5nTG9jYWxseTtcbiAgdHJ5IHtcbiAgICBwcm9wYWdhdGluZ0xvY2FsbHkgPSB0cnVlO1xuICAgIGdsb2JhbEV2ZW50cy5zdG9yYWdlbXV0YXRlZC5maXJlKHVwZGF0ZVBhcnRzKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBwcm9wYWdhdGluZ0xvY2FsbHkgPSB3YXNNZTtcbiAgfVxufVxuXG5leHBvcnQgbGV0IHByb3BhZ2F0aW5nTG9jYWxseSA9IGZhbHNlO1xuIiwgImltcG9ydCB7XG4gIGdsb2JhbEV2ZW50cyxcbiAgU1RPUkFHRV9NVVRBVEVEX0RPTV9FVkVOVF9OQU1FLFxuICBERVhJRV9TVE9SQUdFX01VVEFURURfRVZFTlRfTkFNRSxcbn0gZnJvbSAnLi4vZ2xvYmFscy9nbG9iYWwtZXZlbnRzJztcbmltcG9ydCB7IHByb3BhZ2F0ZUxvY2FsbHksIHByb3BhZ2F0aW5nTG9jYWxseSB9IGZyb20gJy4vcHJvcGFnYXRlLWxvY2FsbHknO1xuXG5pZiAodHlwZW9mIEJyb2FkY2FzdENoYW5uZWwgIT09ICd1bmRlZmluZWQnKSB7XG4gIGNvbnN0IGJjID0gbmV3IEJyb2FkY2FzdENoYW5uZWwoU1RPUkFHRV9NVVRBVEVEX0RPTV9FVkVOVF9OQU1FKTtcblxuICAvKipcbiAgICAgKiBUaGUgTm9kZS5qcyBCcm9hZGNhc3RDaGFubmVsIHdpbGwgcHJldmVudCB0aGUgbm9kZSBwcm9jZXNzIGZyb20gZXhpdGluZ1xuICAgICAqIGlmIHRoZSBCcm9hZGNhc3RDaGFubmVsIGlzIG5vdCBjbG9zZWQuXG4gICAgICogVGhlcmVmb3JlIHdlIGhhdmUgdG8gY2FsbCB1bnJlZigpIHdoaWNoIGFsbG93cyB0aGUgcHJvY2VzcyB0byBmaW5pc2hcbiAgICAgKiBwcm9wZXJseSBldmVuIHdoZW4gdGhlIEJyb2FkY2FzdENoYW5uZWwgaXMgbmV2ZXIgY2xvc2VkLlxuICAgICAqIEBsaW5rIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvd29ya2VyX3RocmVhZHMuaHRtbCNicm9hZGNhc3RjaGFubmVsdW5yZWZcbiAgICAgKiBAbGluayBodHRwczovL2dpdGh1Yi5jb20vZGV4aWUvRGV4aWUuanMvcHVsbC8xNTc2XG4gICAgICovXG4gIGlmICh0eXBlb2YgKGJjIGFzIGFueSkudW5yZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAoYmMgYXMgYW55KS51bnJlZigpO1xuICB9IFxuICAgXG4gIC8vXG4gIC8vIFByb3BhZ2F0ZSBsb2NhbCBjaGFuZ2VzIHRvIHJlbW90ZSB0YWJzLCB3aW5kb3dzIGFuZCB3b3JrZXJzIHZpYSBCcm9hZGNhc3RDaGFubmVsXG4gIC8vXG4gIGdsb2JhbEV2ZW50cyhERVhJRV9TVE9SQUdFX01VVEFURURfRVZFTlRfTkFNRSwgKGNoYW5nZWRQYXJ0cykgPT4ge1xuICAgIGlmICghcHJvcGFnYXRpbmdMb2NhbGx5KSB7XG4gICAgICBiYy5wb3N0TWVzc2FnZShjaGFuZ2VkUGFydHMpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy9cbiAgLy8gUHJvcGFnYXRlIHJlbW90ZSBjaGFuZ2VzIGxvY2FsbHkgdmlhIHN0b3JhZ2UgZXZlbnQ6XG4gIC8vXG4gIGJjLm9ubWVzc2FnZSA9IChldikgPT4ge1xuICAgIGlmIChldi5kYXRhKSBwcm9wYWdhdGVMb2NhbGx5KGV2LmRhdGEpO1xuICB9O1xufSBlbHNlIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgLy8gRE9NIHZlcmlmaWVkIC0gd2hlbiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiwgd2UgYXJlIGEgd2luZG93IG9yIHdvcmtlci4gTm90IGEgTm9kZSBwcm9jZXNzLlxuXG4gIC8vXG4gIC8vIFByb3BhZ2F0ZSBsb2NhbCBjaGFuZ2VzIHRvIHJlbW90ZSB0YWJzL3dpbmRvd3MgdmlhIHN0b3JhZ2UgZXZlbnQgYW5kIHNlcnZpY2Ugd29ya2VyXG4gIC8vIHZpYSBtZXNzYWdlcy4gV2UgaGF2ZSB0aGlzIGNvZGUgaGVyZSBiZWNhdXNlIG9mIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xNjE0NzIuXG4gIC8vXG4gIGdsb2JhbEV2ZW50cyhERVhJRV9TVE9SQUdFX01VVEFURURfRVZFTlRfTkFNRSwgKGNoYW5nZWRQYXJ0cykgPT4ge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIXByb3BhZ2F0aW5nTG9jYWxseSkge1xuICAgICAgICBpZiAodHlwZW9mIGxvY2FsU3RvcmFnZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAvLyBXZSdyZSBhIGJyb3dzaW5nIHdpbmRvdyBvciB0YWIuIFByb3BhZ2F0ZSB0byBvdGhlciB3aW5kb3dzL3RhYnMgdmlhIHN0b3JhZ2UgZXZlbnQ6XG4gICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oXG4gICAgICAgICAgICBTVE9SQUdFX01VVEFURURfRE9NX0VWRU5UX05BTUUsXG4gICAgICAgICAgICBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgIHRyaWc6IE1hdGgucmFuZG9tKCksXG4gICAgICAgICAgICAgIGNoYW5nZWRQYXJ0cyxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHNlbGZbJ2NsaWVudHMnXSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAvLyBXZSdyZSBhIHNlcnZpY2Ugd29ya2VyLiBQcm9wYWdhdGUgdG8gb3VyIGJyb3dzZXIgY2xpZW50cy5cbiAgICAgICAgICBbLi4uc2VsZlsnY2xpZW50cyddLm1hdGNoQWxsKHsgaW5jbHVkZVVuY29udHJvbGxlZDogdHJ1ZSB9KV0uZm9yRWFjaChcbiAgICAgICAgICAgIChjbGllbnQpID0+XG4gICAgICAgICAgICAgIGNsaWVudC5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgdHlwZTogU1RPUkFHRV9NVVRBVEVEX0RPTV9FVkVOVF9OQU1FLFxuICAgICAgICAgICAgICAgIGNoYW5nZWRQYXJ0cyxcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCB7fVxuICB9KTtcblxuICAvL1xuICAvLyBQcm9wYWdhdGUgcmVtb3RlIGNoYW5nZXMgbG9jYWxseSB2aWEgc3RvcmFnZSBldmVudDpcbiAgLy9cbiAgaWYgKHR5cGVvZiBhZGRFdmVudExpc3RlbmVyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgYWRkRXZlbnRMaXN0ZW5lcignc3RvcmFnZScsIChldjogU3RvcmFnZUV2ZW50KSA9PiB7XG4gICAgICBpZiAoZXYua2V5ID09PSBTVE9SQUdFX01VVEFURURfRE9NX0VWRU5UX05BTUUpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IEpTT04ucGFyc2UoZXYubmV3VmFsdWUpO1xuICAgICAgICBpZiAoZGF0YSkgcHJvcGFnYXRlTG9jYWxseShkYXRhLmNoYW5nZWRQYXJ0cyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvL1xuICAvLyBQcm9wYWdhdGUgbWVzc2FnZXMgZnJvbSBzZXJ2aWNlIHdvcmtlclxuICAvL1xuICBjb25zdCBzd0NvbnRhaW5lciA9IHNlbGYuZG9jdW1lbnQgJiYgbmF2aWdhdG9yLnNlcnZpY2VXb3JrZXI7IC8vIHNlbGYuZG9jdW1lbnQgaXMgdG8gdmVyaWZ5IHdlJ3JlIG5vdCB0aGUgU1cgb3Vyc2VsZlxuICBpZiAoc3dDb250YWluZXIpIHtcbiAgICAvLyBXZSdyZSBhIGJyb3dzZXIgd2luZG93IGFuZCB3YW50IHRvIHByb3BhZ2F0ZSBtZXNzYWdlIGZyb20gdGhlIFNXOlxuICAgIHN3Q29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBwcm9wYWdhdGVNZXNzYWdlTG9jYWxseSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvcGFnYXRlTWVzc2FnZUxvY2FsbHkoeyBkYXRhIH06IE1lc3NhZ2VFdmVudCkge1xuICBpZiAoZGF0YSAmJiBkYXRhLnR5cGUgPT09IFNUT1JBR0VfTVVUQVRFRF9ET01fRVZFTlRfTkFNRSkge1xuICAgIHByb3BhZ2F0ZUxvY2FsbHkoZGF0YS5jaGFuZ2VkUGFydHMpO1xuICB9XG59XG4iLCAiaW1wb3J0IHsgRGV4aWUgfSBmcm9tICcuL2NsYXNzZXMvZGV4aWUnO1xuaW1wb3J0IHsgRGV4aWVDb25zdHJ1Y3RvciB9IGZyb20gJy4vcHVibGljL3R5cGVzL2RleGllLWNvbnN0cnVjdG9yJztcbmltcG9ydCB7IERleGllUHJvbWlzZSB9IGZyb20gJy4vaGVscGVycy9wcm9taXNlJztcbmltcG9ydCB7IG1hcEVycm9yIH0gZnJvbSAnLi9lcnJvcnMnO1xuaW1wb3J0ICogYXMgRGVidWcgZnJvbSAnLi9oZWxwZXJzL2RlYnVnJztcbmltcG9ydCB7IGRleGllU3RhY2tGcmFtZUZpbHRlciB9IGZyb20gJy4vZ2xvYmFscy9jb25zdGFudHMnO1xuXG4vLyBHZW5lcmF0ZSBhbGwgc3RhdGljIHByb3BlcnRpZXMgc3VjaCBhcyBEZXhpZS5tYXhLZXkgZXRjXG4vLyAoaW1wbGVtZW50IGludGVyZmFjZSBEZXhpZUNvbnN0cnVjdG9yKTpcbmltcG9ydCAnLi9jbGFzc2VzL2RleGllL2RleGllLXN0YXRpYy1wcm9wcyc7XG5pbXBvcnQgJy4vbGl2ZS1xdWVyeS9lbmFibGUtYnJvYWRjYXN0JztcbmltcG9ydCB7IGxpdmVRdWVyeSB9IGZyb20gJy4vbGl2ZS1xdWVyeS9saXZlLXF1ZXJ5JztcblxuLy8gU2V0IHJlamVjdGlvbk1hcHBlciBvZiBEZXhpZVByb21pc2Ugc28gdGhhdCBpdCBnZW5lcmFsbHkgdHJpZXMgdG8gbWFwXG4vLyBET01FcnJvcnMgYW5kIERPTUV4Y2VwdGlvbnMgdG8gYSBEZXhpZUVycm9yIGluc3RhbmNlIHdpdGggc2FtZSBuYW1lIGJ1dCB3aXRoXG4vLyBhc3luYyBzdGFjayBzdXBwb3J0IGFuZCB3aXRoIGEgcHJvdG90eXBhbCBpbmhlcml0YW5jZSBmcm9tIERleGllRXJyb3IgYW5kIEVycm9yLlxuLy8gb2YgTWFwIERPTUVycm9ycyBhbmQgRE9NRXhjZXB0aW9ucyB0byBjb3JyZXNwb25kaW5nIERleGllIGVycm9ycy5cbkRleGllUHJvbWlzZS5yZWplY3Rpb25NYXBwZXIgPSBtYXBFcnJvcjtcblxuLy8gTGV0IHRoZSBhc3luYyBzdGFjayBmaWx0ZXIgZm9jdXMgb24gYXBwIGNvZGUgYW5kIGZpbHRlciBhd2F5IGZyYW1lcyBmcm9tIGRleGllLm1pbi5qczpcbkRlYnVnLnNldERlYnVnKERlYnVnLmRlYnVnLCBkZXhpZVN0YWNrRnJhbWVGaWx0ZXIpO1xuXG5leHBvcnQgeyBSYW5nZVNldCwgbWVyZ2VSYW5nZXMsIHJhbmdlc092ZXJsYXAgfSBmcm9tIFwiLi9oZWxwZXJzL3Jhbmdlc2V0XCI7XG5leHBvcnQgeyBEZXhpZSwgbGl2ZVF1ZXJ5IH07IC8vIENvbXBseSB3aXRoIHB1YmxpYy9pbmRleC5kLnRzLlxuZXhwb3J0IGRlZmF1bHQgRGV4aWU7XG4iLCAiaW1wb3J0IERleGllLCB7IFRhYmxlIH0gZnJvbSBcImRleGllXCJcbmltcG9ydCB7IFNoYXJlZERvY3VtZW50IH0gZnJvbSBcIi4vc2hhcmVkRW50aXRpZXMvc2hhcmVkRG9jdW1lbnRcIlxuaW1wb3J0IHsgY3JlYXRlUmFuZG9tSWQgfSBmcm9tIFwiLi90b29sc1wiXG5pbXBvcnQgeyBTaGFyZWRFbnRpdHkgfSBmcm9tIFwiLi9zaGFyZWRFbnRpdGllcy9zaGFyZWRFbnRpdHlcIlxuaW1wb3J0IHsgU2hhcmVkRm9sZGVyIH0gZnJvbSBcIi4vc2hhcmVkRW50aXRpZXMvc2hhcmVkRm9sZGVyXCJcblxuXG5leHBvcnQgaW50ZXJmYWNlIFBlcm1hbmVudFNoYXJlRG9jdW1lbnQge1xuICBwYXRoOiBzdHJpbmcsIHBlcnNpc3RlbmNlSWQ6IHN0cmluZywgc2hhcmVJZDogc3RyaW5nIFxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFBlcm1hbmVudFNoYXJlRm9sZGVyIHtcbiAgcGF0aDogc3RyaW5nLCBwZXJzaXN0ZW5jZUlkOiBzdHJpbmcsIHNoYXJlSWQ6IHN0cmluZyBcbn1cblxuZXhwb3J0IGNsYXNzIFBlcm1hbmVudFNoYXJlU3RvcmVJbmRleGVkREIge1xuXG4gIG9pZDogc3RyaW5nXG4gIHByaXZhdGUgZG9jdW1lbnRUYWJsZTogVGFibGU8UGVybWFuZW50U2hhcmVEb2N1bWVudCwgc3RyaW5nPlxuICBwcml2YXRlIGZvbGRlclRhYmxlOiBUYWJsZTxQZXJtYW5lbnRTaGFyZUZvbGRlciwgc3RyaW5nPlxuICBwcml2YXRlIGRiOiBEZXhpZVxuXG4gIGtlZXBPcGVuOiBib29sZWFuID0gdHJ1ZVxuXG4gIGNvbnN0cnVjdG9yKG9pZDogc3RyaW5nKSB7XG4gICAgdGhpcy5vaWQgPSBvaWRcbiAgICB0aGlzLmRiID0gbmV3IERleGllKCdwZWVyZHJhZnRfJyArIHRoaXMub2lkKVxuICAgIHRoaXMuZGIudmVyc2lvbigyKS5zdG9yZXMoe1xuICAgICAgc2hhcmVkRG9jczogXCJwYXRoLHBlcnNpc3RlbmNlSWQsc2hhcmVJZFwiLFxuICAgICAgc2hhcmVkRm9sZGVyczogXCJwYXRoLHBlcnNpc3RlbmNlSWQsc2hhcmVJZFwiXG4gICAgfSlcbiAgICB0aGlzLmRiLm9uKFwiY2xvc2VcIiwgKCkgPT4ge1xuICAgICAgaWYodGhpcy5rZWVwT3Blbikge1xuICAgICAgICB0aGlzLmRiLm9wZW4oKVxuICAgICAgfVxuICAgIH0pXG4gICAgdGhpcy5kb2N1bWVudFRhYmxlID0gdGhpcy5kYi5fYWxsVGFibGVzW1wic2hhcmVkRG9jc1wiXSBhcyBUYWJsZTxQZXJtYW5lbnRTaGFyZURvY3VtZW50LCBzdHJpbmc+XG4gICAgdGhpcy5mb2xkZXJUYWJsZSA9IHRoaXMuZGIuX2FsbFRhYmxlc1tcInNoYXJlZEZvbGRlcnNcIl0gYXMgVGFibGU8UGVybWFuZW50U2hhcmVGb2xkZXIsIHN0cmluZz5cbiAgfVxuXG4gIGNsb3NlKCl7XG4gICAgdGhpcy5rZWVwT3BlbiA9IGZhbHNlXG4gICAgdGhpcy5kYi5jbG9zZSgpXG4gIH1cblxuICBhZGQoZG9jOiBTaGFyZWRFbnRpdHkpIHtcbiAgICBpZihkb2MgaW5zdGFuY2VvZiBTaGFyZWREb2N1bWVudCl7XG4gICAgICByZXR1cm4gdGhpcy5kb2N1bWVudFRhYmxlLmFkZCh7XG4gICAgICAgIHBhdGg6IGRvYy5wYXRoLFxuICAgICAgICBzaGFyZUlkOiBkb2Muc2hhcmVJZCxcbiAgICAgICAgcGVyc2lzdGVuY2VJZDogY3JlYXRlUmFuZG9tSWQoKVxuICAgICAgfSlcbiAgICB9XG4gICAgaWYoZG9jIGluc3RhbmNlb2YgU2hhcmVkRm9sZGVyKXtcbiAgICAgIHJldHVybiB0aGlzLmZvbGRlclRhYmxlLmFkZCh7XG4gICAgICAgIHBhdGg6IGRvYy5wYXRoLFxuICAgICAgICBzaGFyZUlkOiBkb2Muc2hhcmVJZCxcbiAgICAgICAgcGVyc2lzdGVuY2VJZDogY3JlYXRlUmFuZG9tSWQoKVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICByZW1vdmVEb2MocGF0aDogc3RyaW5nKSB7XG4gICAgcmV0dXJuIHRoaXMuZG9jdW1lbnRUYWJsZS5kZWxldGUocGF0aClcbiAgfVxuXG4gIGFzeW5jIGdldERvY0J5UGF0aChwYXRoOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gdGhpcy5kb2N1bWVudFRhYmxlLmdldChwYXRoKVxuICB9XG5cbiAgZ2V0QWxsRG9jcygpIHtcbiAgICByZXR1cm4gdGhpcy5kb2N1bWVudFRhYmxlLnRvQXJyYXkoKVxuICB9XG5cbiAgcmVtb3ZlRm9sZGVyKHBhdGg6IHN0cmluZykge1xuICAgIHJldHVybiB0aGlzLmZvbGRlclRhYmxlLmRlbGV0ZShwYXRoKVxuICB9XG5cbiAgZ2V0QWxsRm9sZGVycygpIHtcbiAgICByZXR1cm4gdGhpcy5mb2xkZXJUYWJsZS50b0FycmF5KClcbiAgfVxuXG4gIGFzeW5jIGdldEZvbGRlckJ5UGF0aChwYXRoOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gdGhpcy5mb2xkZXJUYWJsZS5nZXQocGF0aClcbiAgfVxuXG5cbiAgYXN5bmMgZGVsZXRlREIoKSB7XG4gICAgd2luZG93LmluZGV4ZWREQi5kZWxldGVEYXRhYmFzZSh0aGlzLmZvbGRlclRhYmxlLm5hbWUpXG4gICAgd2luZG93LmluZGV4ZWREQi5kZWxldGVEYXRhYmFzZSh0aGlzLmRvY3VtZW50VGFibGUubmFtZSlcbiAgfVxuXG59IiwgImltcG9ydCB7IFNoYXJlZERvY3VtZW50IH0gZnJvbSBcIi4vc2hhcmVkRW50aXRpZXMvc2hhcmVkRG9jdW1lbnRcIlxuaW1wb3J0IHsgY3JlYXRlUmFuZG9tSWQgfSBmcm9tIFwiLi90b29sc1wiXG5pbXBvcnQgeyBTaGFyZWRFbnRpdHkgfSBmcm9tIFwiLi9zaGFyZWRFbnRpdGllcy9zaGFyZWRFbnRpdHlcIlxuaW1wb3J0IHsgU2hhcmVkRm9sZGVyIH0gZnJvbSBcIi4vc2hhcmVkRW50aXRpZXMvc2hhcmVkRm9sZGVyXCJcbmltcG9ydCBQZWVyZHJhZnRQbHVnaW4gZnJvbSBcIi4vcGVlcmRyYWZ0UGx1Z2luXCJcbmltcG9ydCB7IHNhdmVTZXR0aW5ncyB9IGZyb20gXCIuL3NldHRpbmdzXCJcbmltcG9ydCB7IG5vcm1hbGl6ZVBhdGggfSBmcm9tIFwib2JzaWRpYW5cIlxuXG5leHBvcnQgaW50ZXJmYWNlIFBlcm1hbmVudFNoYXJlRG9jdW1lbnQge1xuICBwYXRoOiBzdHJpbmcsIHBlcnNpc3RlbmNlSWQ6IHN0cmluZywgc2hhcmVJZDogc3RyaW5nXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUGVybWFuZW50U2hhcmVGb2xkZXIge1xuICBwYXRoOiBzdHJpbmcsIHBlcnNpc3RlbmNlSWQ6IHN0cmluZywgc2hhcmVJZDogc3RyaW5nXG59XG5cblxuZXhwb3J0IGNvbnN0IGFkZCA9IGFzeW5jIChkb2M6IFNoYXJlZEVudGl0eSwgcGx1Z2luOiBQZWVyZHJhZnRQbHVnaW4pID0+IHtcbiAgaWYgKGRvYyBpbnN0YW5jZW9mIFNoYXJlZERvY3VtZW50KSB7XG4gICAgcGx1Z2luLnNldHRpbmdzLnNlcnZlclNoYXJlcy5maWxlcy5zZXQoZG9jLnBhdGgsIHtcbiAgICAgIHNoYXJlSWQ6IGRvYy5zaGFyZUlkLFxuICAgICAgcGVyc2lzdGVuY2VJZDogY3JlYXRlUmFuZG9tSWQoKVxuICAgIH0pXG4gIH1cbiAgaWYgKGRvYyBpbnN0YW5jZW9mIFNoYXJlZEZvbGRlcikge1xuICAgIHBsdWdpbi5zZXR0aW5ncy5zZXJ2ZXJTaGFyZXMuZm9sZGVycy5zZXQoZG9jLnBhdGgsIHtcbiAgICAgIHNoYXJlSWQ6IGRvYy5zaGFyZUlkLFxuICAgICAgcGVyc2lzdGVuY2VJZDogY3JlYXRlUmFuZG9tSWQoKVxuICAgIH0pXG4gIH1cbiAgc2F2ZVNldHRpbmdzKHBsdWdpbi5zZXR0aW5ncywgcGx1Z2luKVxufVxuXG5leHBvcnQgY29uc3QgcmVtb3ZlRG9jID0gYXN5bmMgKHBhdGg6IHN0cmluZywgcGx1Z2luOiBQZWVyZHJhZnRQbHVnaW4pID0+IHtcbiAgcGx1Z2luLnNldHRpbmdzLnNlcnZlclNoYXJlcy5maWxlcy5kZWxldGUobm9ybWFsaXplUGF0aChwYXRoKSlcbiAgc2F2ZVNldHRpbmdzKHBsdWdpbi5zZXR0aW5ncywgcGx1Z2luKVxufVxuXG5leHBvcnQgY29uc3QgZ2V0RG9jQnlQYXRoID0gKHBhdGg6IHN0cmluZywgcGx1Z2luOiBQZWVyZHJhZnRQbHVnaW4pID0+IHtcbiAgcmV0dXJuIHBsdWdpbi5zZXR0aW5ncy5zZXJ2ZXJTaGFyZXMuZmlsZXMuZ2V0KHBhdGgpXG59XG5cbmV4cG9ydCBjb25zdCBtb3ZlRG9jID0gYXN5bmMgKG9sZFBhdGg6IHN0cmluZywgbmV3UGF0aDogc3RyaW5nLCBwbHVnaW46IFBlZXJkcmFmdFBsdWdpbikgPT4ge1xuICBjb25zdCBmaWxlcyA9IHBsdWdpbi5zZXR0aW5ncy5zZXJ2ZXJTaGFyZXMuZmlsZXNcbiAgY29uc3QgZW50cnkgPSBmaWxlcy5nZXQob2xkUGF0aClcbiAgaWYgKGVudHJ5KSB7XG4gICAgZmlsZXMuZGVsZXRlKG9sZFBhdGgpXG4gICAgZmlsZXMuc2V0KG5ld1BhdGgsIGVudHJ5KVxuICAgIHNhdmVTZXR0aW5ncyhwbHVnaW4uc2V0dGluZ3MsIHBsdWdpbilcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgcmVtb3ZlRm9sZGVyID0gYXN5bmMgKHBhdGg6IHN0cmluZywgcGx1Z2luOiBQZWVyZHJhZnRQbHVnaW4pID0+IHtcbiAgcGx1Z2luLnNldHRpbmdzLnNlcnZlclNoYXJlcy5mb2xkZXJzLmRlbGV0ZShwYXRoKVxuICBzYXZlU2V0dGluZ3MocGx1Z2luLnNldHRpbmdzLCBwbHVnaW4pXG59XG5cbmV4cG9ydCBjb25zdCBnZXRGb2xkZXJCeVBhdGggPSAocGF0aDogc3RyaW5nLCBwbHVnaW46IFBlZXJkcmFmdFBsdWdpbikgPT4gIHtcbiAgcmV0dXJuIHBsdWdpbi5zZXR0aW5ncy5zZXJ2ZXJTaGFyZXMuZm9sZGVycy5nZXQocGF0aClcbn1cblxuZXhwb3J0IGNvbnN0IG1vdmVGb2xkZXIgPSBhc3luYyAob2xkUGF0aDogc3RyaW5nLCBuZXdQYXRoOiBzdHJpbmcsIHBsdWdpbjogUGVlcmRyYWZ0UGx1Z2luKSA9PiB7XG4gIGNvbnN0IG9sZFBhdGhOb3JtYWxpemVkID0gbm9ybWFsaXplUGF0aChvbGRQYXRoKVxuICBjb25zdCBuZXdQYXRoTm9ybWFsaXplZCA9IG5vcm1hbGl6ZVBhdGgobmV3UGF0aClcbiAgY29uc3QgZmlsZXMgPSBwbHVnaW4uc2V0dGluZ3Muc2VydmVyU2hhcmVzLmZvbGRlcnNcbiAgY29uc3QgZW50cnkgPSBmaWxlcy5nZXQob2xkUGF0aE5vcm1hbGl6ZWQpXG4gIGlmIChlbnRyeSkge1xuICAgIGZpbGVzLmRlbGV0ZShvbGRQYXRoTm9ybWFsaXplZClcbiAgICBmaWxlcy5zZXQobmV3UGF0aE5vcm1hbGl6ZWQsIGVudHJ5KVxuICAgIHNhdmVTZXR0aW5ncyhwbHVnaW4uc2V0dGluZ3MsIHBsdWdpbilcbiAgfVxufSIsICJjb25zdCBFX1RJTUVPVVQgPSBuZXcgRXJyb3IoJ3RpbWVvdXQgd2hpbGUgd2FpdGluZyBmb3IgbXV0ZXggdG8gYmVjb21lIGF2YWlsYWJsZScpO1xuY29uc3QgRV9BTFJFQURZX0xPQ0tFRCA9IG5ldyBFcnJvcignbXV0ZXggYWxyZWFkeSBsb2NrZWQnKTtcbmNvbnN0IEVfQ0FOQ0VMRUQgPSBuZXcgRXJyb3IoJ3JlcXVlc3QgZm9yIGxvY2sgY2FuY2VsZWQnKTtcblxudmFyIF9fYXdhaXRlciQyID0gKHVuZGVmaW5lZCAmJiB1bmRlZmluZWQuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5jbGFzcyBTZW1hcGhvcmUge1xuICAgIGNvbnN0cnVjdG9yKF92YWx1ZSwgX2NhbmNlbEVycm9yID0gRV9DQU5DRUxFRCkge1xuICAgICAgICB0aGlzLl92YWx1ZSA9IF92YWx1ZTtcbiAgICAgICAgdGhpcy5fY2FuY2VsRXJyb3IgPSBfY2FuY2VsRXJyb3I7XG4gICAgICAgIHRoaXMuX3F1ZXVlID0gW107XG4gICAgICAgIHRoaXMuX3dlaWdodGVkV2FpdGVycyA9IFtdO1xuICAgIH1cbiAgICBhY3F1aXJlKHdlaWdodCA9IDEsIHByaW9yaXR5ID0gMCkge1xuICAgICAgICBpZiAod2VpZ2h0IDw9IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgd2VpZ2h0ICR7d2VpZ2h0fTogbXVzdCBiZSBwb3NpdGl2ZWApO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdGFzayA9IHsgcmVzb2x2ZSwgcmVqZWN0LCB3ZWlnaHQsIHByaW9yaXR5IH07XG4gICAgICAgICAgICBjb25zdCBpID0gZmluZEluZGV4RnJvbUVuZCh0aGlzLl9xdWV1ZSwgKG90aGVyKSA9PiBwcmlvcml0eSA8PSBvdGhlci5wcmlvcml0eSk7XG4gICAgICAgICAgICBpZiAoaSA9PT0gLTEgJiYgd2VpZ2h0IDw9IHRoaXMuX3ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgLy8gTmVlZHMgaW1tZWRpYXRlIGRpc3BhdGNoLCBza2lwIHRoZSBxdWV1ZVxuICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3BhdGNoSXRlbSh0YXNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3F1ZXVlLnNwbGljZShpICsgMSwgMCwgdGFzayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBydW5FeGNsdXNpdmUoY2FsbGJhY2tfMSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyJDIodGhpcywgYXJndW1lbnRzLCB2b2lkIDAsIGZ1bmN0aW9uKiAoY2FsbGJhY2ssIHdlaWdodCA9IDEsIHByaW9yaXR5ID0gMCkge1xuICAgICAgICAgICAgY29uc3QgW3ZhbHVlLCByZWxlYXNlXSA9IHlpZWxkIHRoaXMuYWNxdWlyZSh3ZWlnaHQsIHByaW9yaXR5KTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkIGNhbGxiYWNrKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHJlbGVhc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHdhaXRGb3JVbmxvY2sod2VpZ2h0ID0gMSwgcHJpb3JpdHkgPSAwKSB7XG4gICAgICAgIGlmICh3ZWlnaHQgPD0gMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCB3ZWlnaHQgJHt3ZWlnaHR9OiBtdXN0IGJlIHBvc2l0aXZlYCk7XG4gICAgICAgIGlmICh0aGlzLl9jb3VsZExvY2tJbW1lZGlhdGVseSh3ZWlnaHQsIHByaW9yaXR5KSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl93ZWlnaHRlZFdhaXRlcnNbd2VpZ2h0IC0gMV0pXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3dlaWdodGVkV2FpdGVyc1t3ZWlnaHQgLSAxXSA9IFtdO1xuICAgICAgICAgICAgICAgIGluc2VydFNvcnRlZCh0aGlzLl93ZWlnaHRlZFdhaXRlcnNbd2VpZ2h0IC0gMV0sIHsgcmVzb2x2ZSwgcHJpb3JpdHkgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpc0xvY2tlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlIDw9IDA7XG4gICAgfVxuICAgIGdldFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG4gICAgfVxuICAgIHNldFZhbHVlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3ZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMuX2Rpc3BhdGNoUXVldWUoKTtcbiAgICB9XG4gICAgcmVsZWFzZSh3ZWlnaHQgPSAxKSB7XG4gICAgICAgIGlmICh3ZWlnaHQgPD0gMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCB3ZWlnaHQgJHt3ZWlnaHR9OiBtdXN0IGJlIHBvc2l0aXZlYCk7XG4gICAgICAgIHRoaXMuX3ZhbHVlICs9IHdlaWdodDtcbiAgICAgICAgdGhpcy5fZGlzcGF0Y2hRdWV1ZSgpO1xuICAgIH1cbiAgICBjYW5jZWwoKSB7XG4gICAgICAgIHRoaXMuX3F1ZXVlLmZvckVhY2goKGVudHJ5KSA9PiBlbnRyeS5yZWplY3QodGhpcy5fY2FuY2VsRXJyb3IpKTtcbiAgICAgICAgdGhpcy5fcXVldWUgPSBbXTtcbiAgICB9XG4gICAgX2Rpc3BhdGNoUXVldWUoKSB7XG4gICAgICAgIHRoaXMuX2RyYWluVW5sb2NrV2FpdGVycygpO1xuICAgICAgICB3aGlsZSAodGhpcy5fcXVldWUubGVuZ3RoID4gMCAmJiB0aGlzLl9xdWV1ZVswXS53ZWlnaHQgPD0gdGhpcy5fdmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2Rpc3BhdGNoSXRlbSh0aGlzLl9xdWV1ZS5zaGlmdCgpKTtcbiAgICAgICAgICAgIHRoaXMuX2RyYWluVW5sb2NrV2FpdGVycygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9kaXNwYXRjaEl0ZW0oaXRlbSkge1xuICAgICAgICBjb25zdCBwcmV2aW91c1ZhbHVlID0gdGhpcy5fdmFsdWU7XG4gICAgICAgIHRoaXMuX3ZhbHVlIC09IGl0ZW0ud2VpZ2h0O1xuICAgICAgICBpdGVtLnJlc29sdmUoW3ByZXZpb3VzVmFsdWUsIHRoaXMuX25ld1JlbGVhc2VyKGl0ZW0ud2VpZ2h0KV0pO1xuICAgIH1cbiAgICBfbmV3UmVsZWFzZXIod2VpZ2h0KSB7XG4gICAgICAgIGxldCBjYWxsZWQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIGlmIChjYWxsZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMucmVsZWFzZSh3ZWlnaHQpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBfZHJhaW5VbmxvY2tXYWl0ZXJzKCkge1xuICAgICAgICBpZiAodGhpcy5fcXVldWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBmb3IgKGxldCB3ZWlnaHQgPSB0aGlzLl92YWx1ZTsgd2VpZ2h0ID4gMDsgd2VpZ2h0LS0pIHtcbiAgICAgICAgICAgICAgICBjb25zdCB3YWl0ZXJzID0gdGhpcy5fd2VpZ2h0ZWRXYWl0ZXJzW3dlaWdodCAtIDFdO1xuICAgICAgICAgICAgICAgIGlmICghd2FpdGVycylcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgd2FpdGVycy5mb3JFYWNoKCh3YWl0ZXIpID0+IHdhaXRlci5yZXNvbHZlKCkpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3dlaWdodGVkV2FpdGVyc1t3ZWlnaHQgLSAxXSA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcXVldWVkUHJpb3JpdHkgPSB0aGlzLl9xdWV1ZVswXS5wcmlvcml0eTtcbiAgICAgICAgICAgIGZvciAobGV0IHdlaWdodCA9IHRoaXMuX3ZhbHVlOyB3ZWlnaHQgPiAwOyB3ZWlnaHQtLSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHdhaXRlcnMgPSB0aGlzLl93ZWlnaHRlZFdhaXRlcnNbd2VpZ2h0IC0gMV07XG4gICAgICAgICAgICAgICAgaWYgKCF3YWl0ZXJzKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjb25zdCBpID0gd2FpdGVycy5maW5kSW5kZXgoKHdhaXRlcikgPT4gd2FpdGVyLnByaW9yaXR5IDw9IHF1ZXVlZFByaW9yaXR5KTtcbiAgICAgICAgICAgICAgICAoaSA9PT0gLTEgPyB3YWl0ZXJzIDogd2FpdGVycy5zcGxpY2UoMCwgaSkpXG4gICAgICAgICAgICAgICAgICAgIC5mb3JFYWNoKCh3YWl0ZXIgPT4gd2FpdGVyLnJlc29sdmUoKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIF9jb3VsZExvY2tJbW1lZGlhdGVseSh3ZWlnaHQsIHByaW9yaXR5KSB7XG4gICAgICAgIHJldHVybiAodGhpcy5fcXVldWUubGVuZ3RoID09PSAwIHx8IHRoaXMuX3F1ZXVlWzBdLnByaW9yaXR5IDwgcHJpb3JpdHkpICYmXG4gICAgICAgICAgICB3ZWlnaHQgPD0gdGhpcy5fdmFsdWU7XG4gICAgfVxufVxuZnVuY3Rpb24gaW5zZXJ0U29ydGVkKGEsIHYpIHtcbiAgICBjb25zdCBpID0gZmluZEluZGV4RnJvbUVuZChhLCAob3RoZXIpID0+IHYucHJpb3JpdHkgPD0gb3RoZXIucHJpb3JpdHkpO1xuICAgIGEuc3BsaWNlKGkgKyAxLCAwLCB2KTtcbn1cbmZ1bmN0aW9uIGZpbmRJbmRleEZyb21FbmQoYSwgcHJlZGljYXRlKSB7XG4gICAgZm9yIChsZXQgaSA9IGEubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgaWYgKHByZWRpY2F0ZShhW2ldKSkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xufVxuXG52YXIgX19hd2FpdGVyJDEgPSAodW5kZWZpbmVkICYmIHVuZGVmaW5lZC5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbmNsYXNzIE11dGV4IHtcbiAgICBjb25zdHJ1Y3RvcihjYW5jZWxFcnJvcikge1xuICAgICAgICB0aGlzLl9zZW1hcGhvcmUgPSBuZXcgU2VtYXBob3JlKDEsIGNhbmNlbEVycm9yKTtcbiAgICB9XG4gICAgYWNxdWlyZSgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlciQxKHRoaXMsIGFyZ3VtZW50cywgdm9pZCAwLCBmdW5jdGlvbiogKHByaW9yaXR5ID0gMCkge1xuICAgICAgICAgICAgY29uc3QgWywgcmVsZWFzZXJdID0geWllbGQgdGhpcy5fc2VtYXBob3JlLmFjcXVpcmUoMSwgcHJpb3JpdHkpO1xuICAgICAgICAgICAgcmV0dXJuIHJlbGVhc2VyO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcnVuRXhjbHVzaXZlKGNhbGxiYWNrLCBwcmlvcml0eSA9IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NlbWFwaG9yZS5ydW5FeGNsdXNpdmUoKCkgPT4gY2FsbGJhY2soKSwgMSwgcHJpb3JpdHkpO1xuICAgIH1cbiAgICBpc0xvY2tlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NlbWFwaG9yZS5pc0xvY2tlZCgpO1xuICAgIH1cbiAgICB3YWl0Rm9yVW5sb2NrKHByaW9yaXR5ID0gMCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2VtYXBob3JlLndhaXRGb3JVbmxvY2soMSwgcHJpb3JpdHkpO1xuICAgIH1cbiAgICByZWxlYXNlKCkge1xuICAgICAgICBpZiAodGhpcy5fc2VtYXBob3JlLmlzTG9ja2VkKCkpXG4gICAgICAgICAgICB0aGlzLl9zZW1hcGhvcmUucmVsZWFzZSgpO1xuICAgIH1cbiAgICBjYW5jZWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zZW1hcGhvcmUuY2FuY2VsKCk7XG4gICAgfVxufVxuXG52YXIgX19hd2FpdGVyID0gKHVuZGVmaW5lZCAmJiB1bmRlZmluZWQuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5mdW5jdGlvbiB3aXRoVGltZW91dChzeW5jLCB0aW1lb3V0LCB0aW1lb3V0RXJyb3IgPSBFX1RJTUVPVVQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBhY3F1aXJlOiAod2VpZ2h0T3JQcmlvcml0eSwgcHJpb3JpdHkpID0+IHtcbiAgICAgICAgICAgIGxldCB3ZWlnaHQ7XG4gICAgICAgICAgICBpZiAoaXNTZW1hcGhvcmUoc3luYykpIHtcbiAgICAgICAgICAgICAgICB3ZWlnaHQgPSB3ZWlnaHRPclByaW9yaXR5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgd2VpZ2h0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHByaW9yaXR5ID0gd2VpZ2h0T3JQcmlvcml0eTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh3ZWlnaHQgIT09IHVuZGVmaW5lZCAmJiB3ZWlnaHQgPD0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCB3ZWlnaHQgJHt3ZWlnaHR9OiBtdXN0IGJlIHBvc2l0aXZlYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIGxldCBpc1RpbWVvdXQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBjb25zdCBoYW5kbGUgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaXNUaW1lb3V0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KHRpbWVvdXRFcnJvcik7XG4gICAgICAgICAgICAgICAgfSwgdGltZW91dCk7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGlja2V0ID0geWllbGQgKGlzU2VtYXBob3JlKHN5bmMpXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHN5bmMuYWNxdWlyZSh3ZWlnaHQsIHByaW9yaXR5KVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBzeW5jLmFjcXVpcmUocHJpb3JpdHkpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzVGltZW91dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVsZWFzZSA9IEFycmF5LmlzQXJyYXkodGlja2V0KSA/IHRpY2tldFsxXSA6IHRpY2tldDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbGVhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChoYW5kbGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh0aWNrZXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNUaW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSxcbiAgICAgICAgcnVuRXhjbHVzaXZlKGNhbGxiYWNrLCB3ZWlnaHQsIHByaW9yaXR5KSB7XG4gICAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIGxldCByZWxlYXNlID0gKCkgPT4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRpY2tldCA9IHlpZWxkIHRoaXMuYWNxdWlyZSh3ZWlnaHQsIHByaW9yaXR5KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGlja2V0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVsZWFzZSA9IHRpY2tldFsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCBjYWxsYmFjayh0aWNrZXRbMF0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVsZWFzZSA9IHRpY2tldDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCBjYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICByZWxlYXNlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlbGVhc2Uod2VpZ2h0KSB7XG4gICAgICAgICAgICBzeW5jLnJlbGVhc2Uod2VpZ2h0KTtcbiAgICAgICAgfSxcbiAgICAgICAgY2FuY2VsKCkge1xuICAgICAgICAgICAgcmV0dXJuIHN5bmMuY2FuY2VsKCk7XG4gICAgICAgIH0sXG4gICAgICAgIHdhaXRGb3JVbmxvY2s6ICh3ZWlnaHRPclByaW9yaXR5LCBwcmlvcml0eSkgPT4ge1xuICAgICAgICAgICAgbGV0IHdlaWdodDtcbiAgICAgICAgICAgIGlmIChpc1NlbWFwaG9yZShzeW5jKSkge1xuICAgICAgICAgICAgICAgIHdlaWdodCA9IHdlaWdodE9yUHJpb3JpdHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB3ZWlnaHQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgcHJpb3JpdHkgPSB3ZWlnaHRPclByaW9yaXR5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHdlaWdodCAhPT0gdW5kZWZpbmVkICYmIHdlaWdodCA8PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIHdlaWdodCAke3dlaWdodH06IG11c3QgYmUgcG9zaXRpdmVgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgaGFuZGxlID0gc2V0VGltZW91dCgoKSA9PiByZWplY3QodGltZW91dEVycm9yKSwgdGltZW91dCk7XG4gICAgICAgICAgICAgICAgKGlzU2VtYXBob3JlKHN5bmMpXG4gICAgICAgICAgICAgICAgICAgID8gc3luYy53YWl0Rm9yVW5sb2NrKHdlaWdodCwgcHJpb3JpdHkpXG4gICAgICAgICAgICAgICAgICAgIDogc3luYy53YWl0Rm9yVW5sb2NrKHByaW9yaXR5KSkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChoYW5kbGUpO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgaXNMb2NrZWQ6ICgpID0+IHN5bmMuaXNMb2NrZWQoKSxcbiAgICAgICAgZ2V0VmFsdWU6ICgpID0+IHN5bmMuZ2V0VmFsdWUoKSxcbiAgICAgICAgc2V0VmFsdWU6ICh2YWx1ZSkgPT4gc3luYy5zZXRWYWx1ZSh2YWx1ZSksXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGlzU2VtYXBob3JlKHN5bmMpIHtcbiAgICByZXR1cm4gc3luYy5nZXRWYWx1ZSAhPT0gdW5kZWZpbmVkO1xufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpc25lIEB0eXBlc2NyaXB0LWVzbGludC9leHBsaWNpdC1tb2R1bGUtYm91bmRhcnktdHlwZXNcbmZ1bmN0aW9uIHRyeUFjcXVpcmUoc3luYywgYWxyZWFkeUFjcXVpcmVkRXJyb3IgPSBFX0FMUkVBRFlfTE9DS0VEKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICByZXR1cm4gd2l0aFRpbWVvdXQoc3luYywgMCwgYWxyZWFkeUFjcXVpcmVkRXJyb3IpO1xufVxuXG5leHBvcnQgeyBFX0FMUkVBRFlfTE9DS0VELCBFX0NBTkNFTEVELCBFX1RJTUVPVVQsIE11dGV4LCBTZW1hcGhvcmUsIHRyeUFjcXVpcmUsIHdpdGhUaW1lb3V0IH07XG4iLCAiY29uc3QgZGVmYXVsdE9wdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmZyZWV6ZSh7XG4gIGRpZmZUaW1lb3V0OiAxLFxuICBkaWZmRWRpdENvc3Q6IDQsXG4gIG1hdGNoVGhyZXNob2xkOiAwLjUsXG4gIG1hdGNoRGlzdGFuY2U6IDFlMyxcbiAgcGF0Y2hEZWxldGVUaHJlc2hvbGQ6IDAuNSxcbiAgcGF0Y2hNYXJnaW46IDQsXG4gIG1hdGNoTWF4Qml0czogMzJcbn0pO1xuZnVuY3Rpb24gcmVzb2x2ZU9wdGlvbnMob3B0aW9ucykge1xuICBpZiAob3B0aW9ucz8uX19yZXNvbHZlZClcbiAgICByZXR1cm4gb3B0aW9ucztcbiAgY29uc3QgcmVzb2x2ZWQgPSB7XG4gICAgLi4uZGVmYXVsdE9wdGlvbnMsXG4gICAgLi4ub3B0aW9uc1xuICB9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVzb2x2ZWQsIFwiX19yZXNvbHZlZFwiLCB7IHZhbHVlOiB0cnVlLCBlbnVtZXJhYmxlOiBmYWxzZSB9KTtcbiAgcmV0dXJuIHJlc29sdmVkO1xufVxuXG5jb25zdCBESUZGX0RFTEVURSA9IC0xO1xuY29uc3QgRElGRl9JTlNFUlQgPSAxO1xuY29uc3QgRElGRl9FUVVBTCA9IDA7XG5mdW5jdGlvbiBjcmVhdGVEaWZmKG9wLCB0ZXh0KSB7XG4gIHJldHVybiBbb3AsIHRleHRdO1xufVxuZnVuY3Rpb24gZGlmZk1haW4odGV4dDEsIHRleHQyLCBvcHRpb25zLCBvcHRfY2hlY2tsaW5lcyA9IHRydWUsIG9wdF9kZWFkbGluZSkge1xuICBjb25zdCByZXNvbHZlZCA9IHJlc29sdmVPcHRpb25zKG9wdGlvbnMpO1xuICBpZiAodHlwZW9mIG9wdF9kZWFkbGluZSA9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgaWYgKHJlc29sdmVkLmRpZmZUaW1lb3V0IDw9IDApXG4gICAgICBvcHRfZGVhZGxpbmUgPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgIGVsc2VcbiAgICAgIG9wdF9kZWFkbGluZSA9ICgvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSkuZ2V0VGltZSgpICsgcmVzb2x2ZWQuZGlmZlRpbWVvdXQgKiAxZTM7XG4gIH1cbiAgY29uc3QgZGVhZGxpbmUgPSBvcHRfZGVhZGxpbmU7XG4gIGlmICh0ZXh0MSA9PSBudWxsIHx8IHRleHQyID09IG51bGwpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTnVsbCBpbnB1dC4gKGRpZmZfbWFpbilcIik7XG4gIGlmICh0ZXh0MSA9PT0gdGV4dDIpIHtcbiAgICBpZiAodGV4dDEpXG4gICAgICByZXR1cm4gW2NyZWF0ZURpZmYoRElGRl9FUVVBTCwgdGV4dDEpXTtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgY29uc3QgY2hlY2tsaW5lcyA9IG9wdF9jaGVja2xpbmVzO1xuICBsZXQgY29tbW9ubGVuZ3RoID0gZGlmZkNvbW1vblByZWZpeCh0ZXh0MSwgdGV4dDIpO1xuICBjb25zdCBjb21tb25wcmVmaXggPSB0ZXh0MS5zdWJzdHJpbmcoMCwgY29tbW9ubGVuZ3RoKTtcbiAgdGV4dDEgPSB0ZXh0MS5zdWJzdHJpbmcoY29tbW9ubGVuZ3RoKTtcbiAgdGV4dDIgPSB0ZXh0Mi5zdWJzdHJpbmcoY29tbW9ubGVuZ3RoKTtcbiAgY29tbW9ubGVuZ3RoID0gZGlmZkNvbW1vblN1ZmZpeCh0ZXh0MSwgdGV4dDIpO1xuICBjb25zdCBjb21tb25zdWZmaXggPSB0ZXh0MS5zdWJzdHJpbmcodGV4dDEubGVuZ3RoIC0gY29tbW9ubGVuZ3RoKTtcbiAgdGV4dDEgPSB0ZXh0MS5zdWJzdHJpbmcoMCwgdGV4dDEubGVuZ3RoIC0gY29tbW9ubGVuZ3RoKTtcbiAgdGV4dDIgPSB0ZXh0Mi5zdWJzdHJpbmcoMCwgdGV4dDIubGVuZ3RoIC0gY29tbW9ubGVuZ3RoKTtcbiAgY29uc3QgZGlmZnMgPSBkaWZmQ29tcHV0ZSh0ZXh0MSwgdGV4dDIsIHJlc29sdmVkLCBjaGVja2xpbmVzLCBkZWFkbGluZSk7XG4gIGlmIChjb21tb25wcmVmaXgpXG4gICAgZGlmZnMudW5zaGlmdChjcmVhdGVEaWZmKERJRkZfRVFVQUwsIGNvbW1vbnByZWZpeCkpO1xuICBpZiAoY29tbW9uc3VmZml4KVxuICAgIGRpZmZzLnB1c2goY3JlYXRlRGlmZihESUZGX0VRVUFMLCBjb21tb25zdWZmaXgpKTtcbiAgZGlmZkNsZWFudXBNZXJnZShkaWZmcyk7XG4gIHJldHVybiBkaWZmcztcbn1cbmZ1bmN0aW9uIGRpZmZDb21wdXRlKHRleHQxLCB0ZXh0Miwgb3B0aW9ucywgY2hlY2tsaW5lcywgZGVhZGxpbmUpIHtcbiAgbGV0IGRpZmZzO1xuICBpZiAoIXRleHQxKSB7XG4gICAgcmV0dXJuIFtjcmVhdGVEaWZmKERJRkZfSU5TRVJULCB0ZXh0MildO1xuICB9XG4gIGlmICghdGV4dDIpIHtcbiAgICByZXR1cm4gW2NyZWF0ZURpZmYoRElGRl9ERUxFVEUsIHRleHQxKV07XG4gIH1cbiAgY29uc3QgbG9uZ3RleHQgPSB0ZXh0MS5sZW5ndGggPiB0ZXh0Mi5sZW5ndGggPyB0ZXh0MSA6IHRleHQyO1xuICBjb25zdCBzaG9ydHRleHQgPSB0ZXh0MS5sZW5ndGggPiB0ZXh0Mi5sZW5ndGggPyB0ZXh0MiA6IHRleHQxO1xuICBjb25zdCBpID0gbG9uZ3RleHQuaW5kZXhPZihzaG9ydHRleHQpO1xuICBpZiAoaSAhPT0gLTEpIHtcbiAgICBkaWZmcyA9IFtjcmVhdGVEaWZmKERJRkZfSU5TRVJULCBsb25ndGV4dC5zdWJzdHJpbmcoMCwgaSkpLCBjcmVhdGVEaWZmKERJRkZfRVFVQUwsIHNob3J0dGV4dCksIGNyZWF0ZURpZmYoRElGRl9JTlNFUlQsIGxvbmd0ZXh0LnN1YnN0cmluZyhpICsgc2hvcnR0ZXh0Lmxlbmd0aCkpXTtcbiAgICBpZiAodGV4dDEubGVuZ3RoID4gdGV4dDIubGVuZ3RoKVxuICAgICAgZGlmZnNbMF1bMF0gPSBkaWZmc1syXVswXSA9IERJRkZfREVMRVRFO1xuICAgIHJldHVybiBkaWZmcztcbiAgfVxuICBpZiAoc2hvcnR0ZXh0Lmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBbY3JlYXRlRGlmZihESUZGX0RFTEVURSwgdGV4dDEpLCBjcmVhdGVEaWZmKERJRkZfSU5TRVJULCB0ZXh0MildO1xuICB9XG4gIGNvbnN0IGhtID0gZGlmZkhhbGZNYXRjaCh0ZXh0MSwgdGV4dDIsIG9wdGlvbnMpO1xuICBpZiAoaG0pIHtcbiAgICBjb25zdCB0ZXh0MV9hID0gaG1bMF07XG4gICAgY29uc3QgdGV4dDFfYiA9IGhtWzFdO1xuICAgIGNvbnN0IHRleHQyX2EgPSBobVsyXTtcbiAgICBjb25zdCB0ZXh0Ml9iID0gaG1bM107XG4gICAgY29uc3QgbWlkX2NvbW1vbiA9IGhtWzRdO1xuICAgIGNvbnN0IGRpZmZzX2EgPSBkaWZmTWFpbih0ZXh0MV9hLCB0ZXh0Ml9hLCBvcHRpb25zLCBjaGVja2xpbmVzLCBkZWFkbGluZSk7XG4gICAgY29uc3QgZGlmZnNfYiA9IGRpZmZNYWluKHRleHQxX2IsIHRleHQyX2IsIG9wdGlvbnMsIGNoZWNrbGluZXMsIGRlYWRsaW5lKTtcbiAgICByZXR1cm4gZGlmZnNfYS5jb25jYXQoW2NyZWF0ZURpZmYoRElGRl9FUVVBTCwgbWlkX2NvbW1vbildLCBkaWZmc19iKTtcbiAgfVxuICBpZiAoY2hlY2tsaW5lcyAmJiB0ZXh0MS5sZW5ndGggPiAxMDAgJiYgdGV4dDIubGVuZ3RoID4gMTAwKVxuICAgIHJldHVybiBkaWZmTGluZU1vZGUodGV4dDEsIHRleHQyLCBvcHRpb25zLCBkZWFkbGluZSk7XG4gIHJldHVybiBkaWZmQmlzZWN0KHRleHQxLCB0ZXh0Miwgb3B0aW9ucywgZGVhZGxpbmUpO1xufVxuZnVuY3Rpb24gZGlmZkxpbmVNb2RlKHRleHQxLCB0ZXh0Miwgb3B0aW9ucywgZGVhZGxpbmUpIHtcbiAgY29uc3QgYSA9IGRpZmZMaW5lc1RvQ2hhcnModGV4dDEsIHRleHQyKTtcbiAgdGV4dDEgPSBhLmNoYXJzMTtcbiAgdGV4dDIgPSBhLmNoYXJzMjtcbiAgY29uc3QgbGluZWFycmF5ID0gYS5saW5lQXJyYXk7XG4gIGNvbnN0IGRpZmZzID0gZGlmZk1haW4odGV4dDEsIHRleHQyLCBvcHRpb25zLCBmYWxzZSwgZGVhZGxpbmUpO1xuICBkaWZmQ2hhcnNUb0xpbmVzKGRpZmZzLCBsaW5lYXJyYXkpO1xuICBkaWZmQ2xlYW51cFNlbWFudGljKGRpZmZzKTtcbiAgZGlmZnMucHVzaChjcmVhdGVEaWZmKERJRkZfRVFVQUwsIFwiXCIpKTtcbiAgbGV0IHBvaW50ZXIgPSAwO1xuICBsZXQgY291bnRfZGVsZXRlID0gMDtcbiAgbGV0IGNvdW50X2luc2VydCA9IDA7XG4gIGxldCB0ZXh0X2RlbGV0ZSA9IFwiXCI7XG4gIGxldCB0ZXh0X2luc2VydCA9IFwiXCI7XG4gIHdoaWxlIChwb2ludGVyIDwgZGlmZnMubGVuZ3RoKSB7XG4gICAgc3dpdGNoIChkaWZmc1twb2ludGVyXVswXSkge1xuICAgICAgY2FzZSBESUZGX0lOU0VSVDpcbiAgICAgICAgY291bnRfaW5zZXJ0Kys7XG4gICAgICAgIHRleHRfaW5zZXJ0ICs9IGRpZmZzW3BvaW50ZXJdWzFdO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRElGRl9ERUxFVEU6XG4gICAgICAgIGNvdW50X2RlbGV0ZSsrO1xuICAgICAgICB0ZXh0X2RlbGV0ZSArPSBkaWZmc1twb2ludGVyXVsxXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERJRkZfRVFVQUw6XG4gICAgICAgIGlmIChjb3VudF9kZWxldGUgPj0gMSAmJiBjb3VudF9pbnNlcnQgPj0gMSkge1xuICAgICAgICAgIGRpZmZzLnNwbGljZShwb2ludGVyIC0gY291bnRfZGVsZXRlIC0gY291bnRfaW5zZXJ0LCBjb3VudF9kZWxldGUgKyBjb3VudF9pbnNlcnQpO1xuICAgICAgICAgIHBvaW50ZXIgPSBwb2ludGVyIC0gY291bnRfZGVsZXRlIC0gY291bnRfaW5zZXJ0O1xuICAgICAgICAgIGNvbnN0IHN1YkRpZmYgPSBkaWZmTWFpbih0ZXh0X2RlbGV0ZSwgdGV4dF9pbnNlcnQsIG9wdGlvbnMsIGZhbHNlLCBkZWFkbGluZSk7XG4gICAgICAgICAgZm9yIChsZXQgaiA9IHN1YkRpZmYubGVuZ3RoIC0gMTsgaiA+PSAwOyBqLS0pXG4gICAgICAgICAgICBkaWZmcy5zcGxpY2UocG9pbnRlciwgMCwgc3ViRGlmZltqXSk7XG4gICAgICAgICAgcG9pbnRlciA9IHBvaW50ZXIgKyBzdWJEaWZmLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBjb3VudF9pbnNlcnQgPSAwO1xuICAgICAgICBjb3VudF9kZWxldGUgPSAwO1xuICAgICAgICB0ZXh0X2RlbGV0ZSA9IFwiXCI7XG4gICAgICAgIHRleHRfaW5zZXJ0ID0gXCJcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHBvaW50ZXIrKztcbiAgfVxuICBkaWZmcy5wb3AoKTtcbiAgcmV0dXJuIGRpZmZzO1xufVxuZnVuY3Rpb24gZGlmZkJpc2VjdCh0ZXh0MSwgdGV4dDIsIG9wdGlvbnMsIGRlYWRsaW5lKSB7XG4gIGNvbnN0IHRleHQxX2xlbmd0aCA9IHRleHQxLmxlbmd0aDtcbiAgY29uc3QgdGV4dDJfbGVuZ3RoID0gdGV4dDIubGVuZ3RoO1xuICBjb25zdCBtYXhfZCA9IE1hdGguY2VpbCgodGV4dDFfbGVuZ3RoICsgdGV4dDJfbGVuZ3RoKSAvIDIpO1xuICBjb25zdCB2X29mZnNldCA9IG1heF9kO1xuICBjb25zdCB2X2xlbmd0aCA9IDIgKiBtYXhfZDtcbiAgY29uc3QgdjEgPSBuZXcgQXJyYXkodl9sZW5ndGgpO1xuICBjb25zdCB2MiA9IG5ldyBBcnJheSh2X2xlbmd0aCk7XG4gIGZvciAobGV0IHggPSAwOyB4IDwgdl9sZW5ndGg7IHgrKykge1xuICAgIHYxW3hdID0gLTE7XG4gICAgdjJbeF0gPSAtMTtcbiAgfVxuICB2MVt2X29mZnNldCArIDFdID0gMDtcbiAgdjJbdl9vZmZzZXQgKyAxXSA9IDA7XG4gIGNvbnN0IGRlbHRhID0gdGV4dDFfbGVuZ3RoIC0gdGV4dDJfbGVuZ3RoO1xuICBjb25zdCBmcm9udCA9IGRlbHRhICUgMiAhPT0gMDtcbiAgbGV0IGsxc3RhcnQgPSAwO1xuICBsZXQgazFlbmQgPSAwO1xuICBsZXQgazJzdGFydCA9IDA7XG4gIGxldCBrMmVuZCA9IDA7XG4gIGZvciAobGV0IGQgPSAwOyBkIDwgbWF4X2Q7IGQrKykge1xuICAgIGlmICgoLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCkpLmdldFRpbWUoKSA+IGRlYWRsaW5lKVxuICAgICAgYnJlYWs7XG4gICAgZm9yIChsZXQgazEgPSAtZCArIGsxc3RhcnQ7IGsxIDw9IGQgLSBrMWVuZDsgazEgKz0gMikge1xuICAgICAgY29uc3QgazFfb2Zmc2V0ID0gdl9vZmZzZXQgKyBrMTtcbiAgICAgIGxldCB4MTtcbiAgICAgIGlmIChrMSA9PT0gLWQgfHwgazEgIT09IGQgJiYgdjFbazFfb2Zmc2V0IC0gMV0gPCB2MVtrMV9vZmZzZXQgKyAxXSlcbiAgICAgICAgeDEgPSB2MVtrMV9vZmZzZXQgKyAxXTtcbiAgICAgIGVsc2VcbiAgICAgICAgeDEgPSB2MVtrMV9vZmZzZXQgLSAxXSArIDE7XG4gICAgICBsZXQgeTEgPSB4MSAtIGsxO1xuICAgICAgd2hpbGUgKHgxIDwgdGV4dDFfbGVuZ3RoICYmIHkxIDwgdGV4dDJfbGVuZ3RoICYmIHRleHQxLmNoYXJBdCh4MSkgPT09IHRleHQyLmNoYXJBdCh5MSkpIHtcbiAgICAgICAgeDErKztcbiAgICAgICAgeTErKztcbiAgICAgIH1cbiAgICAgIHYxW2sxX29mZnNldF0gPSB4MTtcbiAgICAgIGlmICh4MSA+IHRleHQxX2xlbmd0aCkge1xuICAgICAgICBrMWVuZCArPSAyO1xuICAgICAgfSBlbHNlIGlmICh5MSA+IHRleHQyX2xlbmd0aCkge1xuICAgICAgICBrMXN0YXJ0ICs9IDI7XG4gICAgICB9IGVsc2UgaWYgKGZyb250KSB7XG4gICAgICAgIGNvbnN0IGsyX29mZnNldCA9IHZfb2Zmc2V0ICsgZGVsdGEgLSBrMTtcbiAgICAgICAgaWYgKGsyX29mZnNldCA+PSAwICYmIGsyX29mZnNldCA8IHZfbGVuZ3RoICYmIHYyW2syX29mZnNldF0gIT09IC0xKSB7XG4gICAgICAgICAgY29uc3QgeDIgPSB0ZXh0MV9sZW5ndGggLSB2MltrMl9vZmZzZXRdO1xuICAgICAgICAgIGlmICh4MSA+PSB4Mikge1xuICAgICAgICAgICAgcmV0dXJuIGRpZmZCaXNlY3RTcGxpdCh0ZXh0MSwgdGV4dDIsIG9wdGlvbnMsIHgxLCB5MSwgZGVhZGxpbmUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGxldCBrMiA9IC1kICsgazJzdGFydDsgazIgPD0gZCAtIGsyZW5kOyBrMiArPSAyKSB7XG4gICAgICBjb25zdCBrMl9vZmZzZXQgPSB2X29mZnNldCArIGsyO1xuICAgICAgbGV0IHgyO1xuICAgICAgaWYgKGsyID09PSAtZCB8fCBrMiAhPT0gZCAmJiB2MltrMl9vZmZzZXQgLSAxXSA8IHYyW2syX29mZnNldCArIDFdKVxuICAgICAgICB4MiA9IHYyW2syX29mZnNldCArIDFdO1xuICAgICAgZWxzZVxuICAgICAgICB4MiA9IHYyW2syX29mZnNldCAtIDFdICsgMTtcbiAgICAgIGxldCB5MiA9IHgyIC0gazI7XG4gICAgICB3aGlsZSAoeDIgPCB0ZXh0MV9sZW5ndGggJiYgeTIgPCB0ZXh0Ml9sZW5ndGggJiYgdGV4dDEuY2hhckF0KHRleHQxX2xlbmd0aCAtIHgyIC0gMSkgPT09IHRleHQyLmNoYXJBdCh0ZXh0Ml9sZW5ndGggLSB5MiAtIDEpKSB7XG4gICAgICAgIHgyKys7XG4gICAgICAgIHkyKys7XG4gICAgICB9XG4gICAgICB2MltrMl9vZmZzZXRdID0geDI7XG4gICAgICBpZiAoeDIgPiB0ZXh0MV9sZW5ndGgpIHtcbiAgICAgICAgazJlbmQgKz0gMjtcbiAgICAgIH0gZWxzZSBpZiAoeTIgPiB0ZXh0Ml9sZW5ndGgpIHtcbiAgICAgICAgazJzdGFydCArPSAyO1xuICAgICAgfSBlbHNlIGlmICghZnJvbnQpIHtcbiAgICAgICAgY29uc3QgazFfb2Zmc2V0ID0gdl9vZmZzZXQgKyBkZWx0YSAtIGsyO1xuICAgICAgICBpZiAoazFfb2Zmc2V0ID49IDAgJiYgazFfb2Zmc2V0IDwgdl9sZW5ndGggJiYgdjFbazFfb2Zmc2V0XSAhPT0gLTEpIHtcbiAgICAgICAgICBjb25zdCB4MSA9IHYxW2sxX29mZnNldF07XG4gICAgICAgICAgY29uc3QgeTEgPSB2X29mZnNldCArIHgxIC0gazFfb2Zmc2V0O1xuICAgICAgICAgIHgyID0gdGV4dDFfbGVuZ3RoIC0geDI7XG4gICAgICAgICAgaWYgKHgxID49IHgyKSB7XG4gICAgICAgICAgICByZXR1cm4gZGlmZkJpc2VjdFNwbGl0KHRleHQxLCB0ZXh0Miwgb3B0aW9ucywgeDEsIHkxLCBkZWFkbGluZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBbY3JlYXRlRGlmZihESUZGX0RFTEVURSwgdGV4dDEpLCBjcmVhdGVEaWZmKERJRkZfSU5TRVJULCB0ZXh0MildO1xufVxuZnVuY3Rpb24gZGlmZkJpc2VjdFNwbGl0KHRleHQxLCB0ZXh0Miwgb3B0aW9ucywgeCwgeSwgZGVhZGxpbmUpIHtcbiAgY29uc3QgdGV4dDFhID0gdGV4dDEuc3Vic3RyaW5nKDAsIHgpO1xuICBjb25zdCB0ZXh0MmEgPSB0ZXh0Mi5zdWJzdHJpbmcoMCwgeSk7XG4gIGNvbnN0IHRleHQxYiA9IHRleHQxLnN1YnN0cmluZyh4KTtcbiAgY29uc3QgdGV4dDJiID0gdGV4dDIuc3Vic3RyaW5nKHkpO1xuICBjb25zdCBkaWZmcyA9IGRpZmZNYWluKHRleHQxYSwgdGV4dDJhLCBvcHRpb25zLCBmYWxzZSwgZGVhZGxpbmUpO1xuICBjb25zdCBkaWZmc2IgPSBkaWZmTWFpbih0ZXh0MWIsIHRleHQyYiwgb3B0aW9ucywgZmFsc2UsIGRlYWRsaW5lKTtcbiAgcmV0dXJuIGRpZmZzLmNvbmNhdChkaWZmc2IpO1xufVxuZnVuY3Rpb24gZGlmZkxpbmVzVG9DaGFycyh0ZXh0MSwgdGV4dDIpIHtcbiAgY29uc3QgbGluZUFycmF5ID0gW107XG4gIGNvbnN0IGxpbmVIYXNoID0ge307XG4gIGxldCBtYXhMaW5lcyA9IDRlNDtcbiAgbGluZUFycmF5WzBdID0gXCJcIjtcbiAgZnVuY3Rpb24gZGlmZkxpbmVzVG9DaGFyc011bmdlKHRleHQpIHtcbiAgICBsZXQgY2hhcnMgPSBcIlwiO1xuICAgIGxldCBsaW5lU3RhcnQgPSAwO1xuICAgIGxldCBsaW5lRW5kID0gLTE7XG4gICAgbGV0IGxpbmVBcnJheUxlbmd0aCA9IGxpbmVBcnJheS5sZW5ndGg7XG4gICAgd2hpbGUgKGxpbmVFbmQgPCB0ZXh0Lmxlbmd0aCAtIDEpIHtcbiAgICAgIGxpbmVFbmQgPSB0ZXh0LmluZGV4T2YoXCJcXG5cIiwgbGluZVN0YXJ0KTtcbiAgICAgIGlmIChsaW5lRW5kID09PSAtMSlcbiAgICAgICAgbGluZUVuZCA9IHRleHQubGVuZ3RoIC0gMTtcbiAgICAgIGxldCBsaW5lID0gdGV4dC5zdWJzdHJpbmcobGluZVN0YXJ0LCBsaW5lRW5kICsgMSk7XG4gICAgICBpZiAobGluZUhhc2guaGFzT3duUHJvcGVydHkgPyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobGluZUhhc2gsIGxpbmUpIDogbGluZUhhc2hbbGluZV0gIT09IHZvaWQgMCkge1xuICAgICAgICBjaGFycyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGxpbmVIYXNoW2xpbmVdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChsaW5lQXJyYXlMZW5ndGggPT09IG1heExpbmVzKSB7XG4gICAgICAgICAgbGluZSA9IHRleHQuc3Vic3RyaW5nKGxpbmVTdGFydCk7XG4gICAgICAgICAgbGluZUVuZCA9IHRleHQubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGNoYXJzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUobGluZUFycmF5TGVuZ3RoKTtcbiAgICAgICAgbGluZUhhc2hbbGluZV0gPSBsaW5lQXJyYXlMZW5ndGg7XG4gICAgICAgIGxpbmVBcnJheVtsaW5lQXJyYXlMZW5ndGgrK10gPSBsaW5lO1xuICAgICAgfVxuICAgICAgbGluZVN0YXJ0ID0gbGluZUVuZCArIDE7XG4gICAgfVxuICAgIHJldHVybiBjaGFycztcbiAgfVxuICBjb25zdCBjaGFyczEgPSBkaWZmTGluZXNUb0NoYXJzTXVuZ2UodGV4dDEpO1xuICBtYXhMaW5lcyA9IDY1NTM1O1xuICBjb25zdCBjaGFyczIgPSBkaWZmTGluZXNUb0NoYXJzTXVuZ2UodGV4dDIpO1xuICByZXR1cm4geyBjaGFyczEsIGNoYXJzMiwgbGluZUFycmF5IH07XG59XG5mdW5jdGlvbiBkaWZmQ2hhcnNUb0xpbmVzKGRpZmZzLCBsaW5lQXJyYXkpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBkaWZmcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGNoYXJzID0gZGlmZnNbaV1bMV07XG4gICAgY29uc3QgdGV4dCA9IFtdO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgY2hhcnMubGVuZ3RoOyBqKyspXG4gICAgICB0ZXh0W2pdID0gbGluZUFycmF5W2NoYXJzLmNoYXJDb2RlQXQoaildO1xuICAgIGRpZmZzW2ldWzFdID0gdGV4dC5qb2luKFwiXCIpO1xuICB9XG59XG5mdW5jdGlvbiBkaWZmQ29tbW9uUHJlZml4KHRleHQxLCB0ZXh0Mikge1xuICBpZiAoIXRleHQxIHx8ICF0ZXh0MiB8fCB0ZXh0MS5jaGFyQXQoMCkgIT09IHRleHQyLmNoYXJBdCgwKSlcbiAgICByZXR1cm4gMDtcbiAgbGV0IHBvaW50ZXJtaW4gPSAwO1xuICBsZXQgcG9pbnRlcm1heCA9IE1hdGgubWluKHRleHQxLmxlbmd0aCwgdGV4dDIubGVuZ3RoKTtcbiAgbGV0IHBvaW50ZXJtaWQgPSBwb2ludGVybWF4O1xuICBsZXQgcG9pbnRlcnN0YXJ0ID0gMDtcbiAgd2hpbGUgKHBvaW50ZXJtaW4gPCBwb2ludGVybWlkKSB7XG4gICAgaWYgKHRleHQxLnN1YnN0cmluZyhwb2ludGVyc3RhcnQsIHBvaW50ZXJtaWQpID09PSB0ZXh0Mi5zdWJzdHJpbmcocG9pbnRlcnN0YXJ0LCBwb2ludGVybWlkKSkge1xuICAgICAgcG9pbnRlcm1pbiA9IHBvaW50ZXJtaWQ7XG4gICAgICBwb2ludGVyc3RhcnQgPSBwb2ludGVybWluO1xuICAgIH0gZWxzZSB7XG4gICAgICBwb2ludGVybWF4ID0gcG9pbnRlcm1pZDtcbiAgICB9XG4gICAgcG9pbnRlcm1pZCA9IE1hdGguZmxvb3IoKHBvaW50ZXJtYXggLSBwb2ludGVybWluKSAvIDIgKyBwb2ludGVybWluKTtcbiAgfVxuICByZXR1cm4gcG9pbnRlcm1pZDtcbn1cbmZ1bmN0aW9uIGRpZmZDb21tb25TdWZmaXgodGV4dDEsIHRleHQyKSB7XG4gIGlmICghdGV4dDEgfHwgIXRleHQyIHx8IHRleHQxLmNoYXJBdCh0ZXh0MS5sZW5ndGggLSAxKSAhPT0gdGV4dDIuY2hhckF0KHRleHQyLmxlbmd0aCAtIDEpKVxuICAgIHJldHVybiAwO1xuICBsZXQgcG9pbnRlcm1pbiA9IDA7XG4gIGxldCBwb2ludGVybWF4ID0gTWF0aC5taW4odGV4dDEubGVuZ3RoLCB0ZXh0Mi5sZW5ndGgpO1xuICBsZXQgcG9pbnRlcm1pZCA9IHBvaW50ZXJtYXg7XG4gIGxldCBwb2ludGVyZW5kID0gMDtcbiAgd2hpbGUgKHBvaW50ZXJtaW4gPCBwb2ludGVybWlkKSB7XG4gICAgaWYgKHRleHQxLnN1YnN0cmluZyh0ZXh0MS5sZW5ndGggLSBwb2ludGVybWlkLCB0ZXh0MS5sZW5ndGggLSBwb2ludGVyZW5kKSA9PT0gdGV4dDIuc3Vic3RyaW5nKHRleHQyLmxlbmd0aCAtIHBvaW50ZXJtaWQsIHRleHQyLmxlbmd0aCAtIHBvaW50ZXJlbmQpKSB7XG4gICAgICBwb2ludGVybWluID0gcG9pbnRlcm1pZDtcbiAgICAgIHBvaW50ZXJlbmQgPSBwb2ludGVybWluO1xuICAgIH0gZWxzZSB7XG4gICAgICBwb2ludGVybWF4ID0gcG9pbnRlcm1pZDtcbiAgICB9XG4gICAgcG9pbnRlcm1pZCA9IE1hdGguZmxvb3IoKHBvaW50ZXJtYXggLSBwb2ludGVybWluKSAvIDIgKyBwb2ludGVybWluKTtcbiAgfVxuICByZXR1cm4gcG9pbnRlcm1pZDtcbn1cbmZ1bmN0aW9uIGRpZmZDb21tb25PdmVybGFwKHRleHQxLCB0ZXh0Mikge1xuICBjb25zdCB0ZXh0MV9sZW5ndGggPSB0ZXh0MS5sZW5ndGg7XG4gIGNvbnN0IHRleHQyX2xlbmd0aCA9IHRleHQyLmxlbmd0aDtcbiAgaWYgKHRleHQxX2xlbmd0aCA9PT0gMCB8fCB0ZXh0Ml9sZW5ndGggPT09IDApXG4gICAgcmV0dXJuIDA7XG4gIGlmICh0ZXh0MV9sZW5ndGggPiB0ZXh0Ml9sZW5ndGgpXG4gICAgdGV4dDEgPSB0ZXh0MS5zdWJzdHJpbmcodGV4dDFfbGVuZ3RoIC0gdGV4dDJfbGVuZ3RoKTtcbiAgZWxzZSBpZiAodGV4dDFfbGVuZ3RoIDwgdGV4dDJfbGVuZ3RoKVxuICAgIHRleHQyID0gdGV4dDIuc3Vic3RyaW5nKDAsIHRleHQxX2xlbmd0aCk7XG4gIGNvbnN0IHRleHRfbGVuZ3RoID0gTWF0aC5taW4odGV4dDFfbGVuZ3RoLCB0ZXh0Ml9sZW5ndGgpO1xuICBpZiAodGV4dDEgPT09IHRleHQyKVxuICAgIHJldHVybiB0ZXh0X2xlbmd0aDtcbiAgbGV0IGJlc3QgPSAwO1xuICBsZXQgbGVuZ3RoID0gMTtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBjb25zdCBwYXR0ZXJuID0gdGV4dDEuc3Vic3RyaW5nKHRleHRfbGVuZ3RoIC0gbGVuZ3RoKTtcbiAgICBjb25zdCBmb3VuZCA9IHRleHQyLmluZGV4T2YocGF0dGVybik7XG4gICAgaWYgKGZvdW5kID09PSAtMSlcbiAgICAgIHJldHVybiBiZXN0O1xuICAgIGxlbmd0aCArPSBmb3VuZDtcbiAgICBpZiAoZm91bmQgPT09IDAgfHwgdGV4dDEuc3Vic3RyaW5nKHRleHRfbGVuZ3RoIC0gbGVuZ3RoKSA9PT0gdGV4dDIuc3Vic3RyaW5nKDAsIGxlbmd0aCkpIHtcbiAgICAgIGJlc3QgPSBsZW5ndGg7XG4gICAgICBsZW5ndGgrKztcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGRpZmZIYWxmTWF0Y2godGV4dDEsIHRleHQyLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zLmRpZmZUaW1lb3V0IDw9IDApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBsb25ndGV4dCA9IHRleHQxLmxlbmd0aCA+IHRleHQyLmxlbmd0aCA/IHRleHQxIDogdGV4dDI7XG4gIGNvbnN0IHNob3J0dGV4dCA9IHRleHQxLmxlbmd0aCA+IHRleHQyLmxlbmd0aCA/IHRleHQyIDogdGV4dDE7XG4gIGlmIChsb25ndGV4dC5sZW5ndGggPCA0IHx8IHNob3J0dGV4dC5sZW5ndGggKiAyIDwgbG9uZ3RleHQubGVuZ3RoKVxuICAgIHJldHVybiBudWxsO1xuICBmdW5jdGlvbiBkaWZmSGFsZk1hdGNoSShsb25ndGV4dDIsIHNob3J0dGV4dDIsIGkpIHtcbiAgICBjb25zdCBzZWVkID0gbG9uZ3RleHQyLnN1YnN0cmluZyhpLCBpICsgTWF0aC5mbG9vcihsb25ndGV4dDIubGVuZ3RoIC8gNCkpO1xuICAgIGxldCBqID0gLTE7XG4gICAgbGV0IGJlc3RfY29tbW9uID0gXCJcIjtcbiAgICBsZXQgYmVzdF9sb25ndGV4dF9hLCBiZXN0X2xvbmd0ZXh0X2IsIGJlc3Rfc2hvcnR0ZXh0X2EsIGJlc3Rfc2hvcnR0ZXh0X2I7XG4gICAgd2hpbGUgKChqID0gc2hvcnR0ZXh0Mi5pbmRleE9mKHNlZWQsIGogKyAxKSkgIT09IC0xKSB7XG4gICAgICBjb25zdCBwcmVmaXhMZW5ndGggPSBkaWZmQ29tbW9uUHJlZml4KGxvbmd0ZXh0Mi5zdWJzdHJpbmcoaSksIHNob3J0dGV4dDIuc3Vic3RyaW5nKGopKTtcbiAgICAgIGNvbnN0IHN1ZmZpeExlbmd0aCA9IGRpZmZDb21tb25TdWZmaXgobG9uZ3RleHQyLnN1YnN0cmluZygwLCBpKSwgc2hvcnR0ZXh0Mi5zdWJzdHJpbmcoMCwgaikpO1xuICAgICAgaWYgKGJlc3RfY29tbW9uLmxlbmd0aCA8IHN1ZmZpeExlbmd0aCArIHByZWZpeExlbmd0aCkge1xuICAgICAgICBiZXN0X2NvbW1vbiA9IHNob3J0dGV4dDIuc3Vic3RyaW5nKGogLSBzdWZmaXhMZW5ndGgsIGopICsgc2hvcnR0ZXh0Mi5zdWJzdHJpbmcoaiwgaiArIHByZWZpeExlbmd0aCk7XG4gICAgICAgIGJlc3RfbG9uZ3RleHRfYSA9IGxvbmd0ZXh0Mi5zdWJzdHJpbmcoMCwgaSAtIHN1ZmZpeExlbmd0aCk7XG4gICAgICAgIGJlc3RfbG9uZ3RleHRfYiA9IGxvbmd0ZXh0Mi5zdWJzdHJpbmcoaSArIHByZWZpeExlbmd0aCk7XG4gICAgICAgIGJlc3Rfc2hvcnR0ZXh0X2EgPSBzaG9ydHRleHQyLnN1YnN0cmluZygwLCBqIC0gc3VmZml4TGVuZ3RoKTtcbiAgICAgICAgYmVzdF9zaG9ydHRleHRfYiA9IHNob3J0dGV4dDIuc3Vic3RyaW5nKGogKyBwcmVmaXhMZW5ndGgpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYmVzdF9jb21tb24ubGVuZ3RoICogMiA+PSBsb25ndGV4dDIubGVuZ3RoKVxuICAgICAgcmV0dXJuIFtiZXN0X2xvbmd0ZXh0X2EsIGJlc3RfbG9uZ3RleHRfYiwgYmVzdF9zaG9ydHRleHRfYSwgYmVzdF9zaG9ydHRleHRfYiwgYmVzdF9jb21tb25dO1xuICAgIGVsc2VcbiAgICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IGhtMSA9IGRpZmZIYWxmTWF0Y2hJKGxvbmd0ZXh0LCBzaG9ydHRleHQsIE1hdGguY2VpbChsb25ndGV4dC5sZW5ndGggLyA0KSk7XG4gIGNvbnN0IGhtMiA9IGRpZmZIYWxmTWF0Y2hJKGxvbmd0ZXh0LCBzaG9ydHRleHQsIE1hdGguY2VpbChsb25ndGV4dC5sZW5ndGggLyAyKSk7XG4gIGxldCBobTtcbiAgaWYgKCFobTEgJiYgIWhtMikge1xuICAgIHJldHVybiBudWxsO1xuICB9IGVsc2UgaWYgKCFobTIpIHtcbiAgICBobSA9IGhtMTtcbiAgfSBlbHNlIGlmICghaG0xKSB7XG4gICAgaG0gPSBobTI7XG4gIH0gZWxzZSB7XG4gICAgaG0gPSBobTFbNF0ubGVuZ3RoID4gaG0yWzRdLmxlbmd0aCA/IGhtMSA6IGhtMjtcbiAgfVxuICBsZXQgdGV4dDFfYSwgdGV4dDFfYiwgdGV4dDJfYSwgdGV4dDJfYjtcbiAgaWYgKHRleHQxLmxlbmd0aCA+IHRleHQyLmxlbmd0aCkge1xuICAgIHRleHQxX2EgPSBobVswXTtcbiAgICB0ZXh0MV9iID0gaG1bMV07XG4gICAgdGV4dDJfYSA9IGhtWzJdO1xuICAgIHRleHQyX2IgPSBobVszXTtcbiAgfSBlbHNlIHtcbiAgICB0ZXh0Ml9hID0gaG1bMF07XG4gICAgdGV4dDJfYiA9IGhtWzFdO1xuICAgIHRleHQxX2EgPSBobVsyXTtcbiAgICB0ZXh0MV9iID0gaG1bM107XG4gIH1cbiAgY29uc3QgbWlkX2NvbW1vbiA9IGhtWzRdO1xuICByZXR1cm4gW3RleHQxX2EsIHRleHQxX2IsIHRleHQyX2EsIHRleHQyX2IsIG1pZF9jb21tb25dO1xufVxuZnVuY3Rpb24gZGlmZkNsZWFudXBTZW1hbnRpYyhkaWZmcykge1xuICBsZXQgY2hhbmdlcyA9IGZhbHNlO1xuICBjb25zdCBlcXVhbGl0aWVzID0gW107XG4gIGxldCBlcXVhbGl0aWVzTGVuZ3RoID0gMDtcbiAgbGV0IGxhc3RFcXVhbGl0eSA9IG51bGw7XG4gIGxldCBwb2ludGVyID0gMDtcbiAgbGV0IGxlbmd0aF9pbnNlcnRpb25zMSA9IDA7XG4gIGxldCBsZW5ndGhfZGVsZXRpb25zMSA9IDA7XG4gIGxldCBsZW5ndGhfaW5zZXJ0aW9uczIgPSAwO1xuICBsZXQgbGVuZ3RoX2RlbGV0aW9uczIgPSAwO1xuICB3aGlsZSAocG9pbnRlciA8IGRpZmZzLmxlbmd0aCkge1xuICAgIGlmIChkaWZmc1twb2ludGVyXVswXSA9PT0gRElGRl9FUVVBTCkge1xuICAgICAgZXF1YWxpdGllc1tlcXVhbGl0aWVzTGVuZ3RoKytdID0gcG9pbnRlcjtcbiAgICAgIGxlbmd0aF9pbnNlcnRpb25zMSA9IGxlbmd0aF9pbnNlcnRpb25zMjtcbiAgICAgIGxlbmd0aF9kZWxldGlvbnMxID0gbGVuZ3RoX2RlbGV0aW9uczI7XG4gICAgICBsZW5ndGhfaW5zZXJ0aW9uczIgPSAwO1xuICAgICAgbGVuZ3RoX2RlbGV0aW9uczIgPSAwO1xuICAgICAgbGFzdEVxdWFsaXR5ID0gZGlmZnNbcG9pbnRlcl1bMV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChkaWZmc1twb2ludGVyXVswXSA9PT0gRElGRl9JTlNFUlQpXG4gICAgICAgIGxlbmd0aF9pbnNlcnRpb25zMiArPSBkaWZmc1twb2ludGVyXVsxXS5sZW5ndGg7XG4gICAgICBlbHNlXG4gICAgICAgIGxlbmd0aF9kZWxldGlvbnMyICs9IGRpZmZzW3BvaW50ZXJdWzFdLmxlbmd0aDtcbiAgICAgIGlmIChsYXN0RXF1YWxpdHkgJiYgbGFzdEVxdWFsaXR5Lmxlbmd0aCA8PSBNYXRoLm1heChsZW5ndGhfaW5zZXJ0aW9uczEsIGxlbmd0aF9kZWxldGlvbnMxKSAmJiBsYXN0RXF1YWxpdHkubGVuZ3RoIDw9IE1hdGgubWF4KGxlbmd0aF9pbnNlcnRpb25zMiwgbGVuZ3RoX2RlbGV0aW9uczIpKSB7XG4gICAgICAgIGRpZmZzLnNwbGljZShlcXVhbGl0aWVzW2VxdWFsaXRpZXNMZW5ndGggLSAxXSwgMCwgY3JlYXRlRGlmZihESUZGX0RFTEVURSwgbGFzdEVxdWFsaXR5KSk7XG4gICAgICAgIGRpZmZzW2VxdWFsaXRpZXNbZXF1YWxpdGllc0xlbmd0aCAtIDFdICsgMV1bMF0gPSBESUZGX0lOU0VSVDtcbiAgICAgICAgZXF1YWxpdGllc0xlbmd0aC0tO1xuICAgICAgICBlcXVhbGl0aWVzTGVuZ3RoLS07XG4gICAgICAgIHBvaW50ZXIgPSBlcXVhbGl0aWVzTGVuZ3RoID4gMCA/IGVxdWFsaXRpZXNbZXF1YWxpdGllc0xlbmd0aCAtIDFdIDogLTE7XG4gICAgICAgIGxlbmd0aF9pbnNlcnRpb25zMSA9IDA7XG4gICAgICAgIGxlbmd0aF9kZWxldGlvbnMxID0gMDtcbiAgICAgICAgbGVuZ3RoX2luc2VydGlvbnMyID0gMDtcbiAgICAgICAgbGVuZ3RoX2RlbGV0aW9uczIgPSAwO1xuICAgICAgICBsYXN0RXF1YWxpdHkgPSBudWxsO1xuICAgICAgICBjaGFuZ2VzID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcG9pbnRlcisrO1xuICB9XG4gIGlmIChjaGFuZ2VzKVxuICAgIGRpZmZDbGVhbnVwTWVyZ2UoZGlmZnMpO1xuICBkaWZmQ2xlYW51cFNlbWFudGljTG9zc2xlc3MoZGlmZnMpO1xuICBwb2ludGVyID0gMTtcbiAgd2hpbGUgKHBvaW50ZXIgPCBkaWZmcy5sZW5ndGgpIHtcbiAgICBpZiAoZGlmZnNbcG9pbnRlciAtIDFdWzBdID09PSBESUZGX0RFTEVURSAmJiBkaWZmc1twb2ludGVyXVswXSA9PT0gRElGRl9JTlNFUlQpIHtcbiAgICAgIGNvbnN0IGRlbGV0aW9uID0gZGlmZnNbcG9pbnRlciAtIDFdWzFdO1xuICAgICAgY29uc3QgaW5zZXJ0aW9uID0gZGlmZnNbcG9pbnRlcl1bMV07XG4gICAgICBjb25zdCBvdmVybGFwX2xlbmd0aDEgPSBkaWZmQ29tbW9uT3ZlcmxhcChkZWxldGlvbiwgaW5zZXJ0aW9uKTtcbiAgICAgIGNvbnN0IG92ZXJsYXBfbGVuZ3RoMiA9IGRpZmZDb21tb25PdmVybGFwKGluc2VydGlvbiwgZGVsZXRpb24pO1xuICAgICAgaWYgKG92ZXJsYXBfbGVuZ3RoMSA+PSBvdmVybGFwX2xlbmd0aDIpIHtcbiAgICAgICAgaWYgKG92ZXJsYXBfbGVuZ3RoMSA+PSBkZWxldGlvbi5sZW5ndGggLyAyIHx8IG92ZXJsYXBfbGVuZ3RoMSA+PSBpbnNlcnRpb24ubGVuZ3RoIC8gMikge1xuICAgICAgICAgIGRpZmZzLnNwbGljZShwb2ludGVyLCAwLCBjcmVhdGVEaWZmKERJRkZfRVFVQUwsIGluc2VydGlvbi5zdWJzdHJpbmcoMCwgb3ZlcmxhcF9sZW5ndGgxKSkpO1xuICAgICAgICAgIGRpZmZzW3BvaW50ZXIgLSAxXVsxXSA9IGRlbGV0aW9uLnN1YnN0cmluZygwLCBkZWxldGlvbi5sZW5ndGggLSBvdmVybGFwX2xlbmd0aDEpO1xuICAgICAgICAgIGRpZmZzW3BvaW50ZXIgKyAxXVsxXSA9IGluc2VydGlvbi5zdWJzdHJpbmcob3ZlcmxhcF9sZW5ndGgxKTtcbiAgICAgICAgICBwb2ludGVyKys7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChvdmVybGFwX2xlbmd0aDIgPj0gZGVsZXRpb24ubGVuZ3RoIC8gMiB8fCBvdmVybGFwX2xlbmd0aDIgPj0gaW5zZXJ0aW9uLmxlbmd0aCAvIDIpIHtcbiAgICAgICAgICBkaWZmcy5zcGxpY2UocG9pbnRlciwgMCwgY3JlYXRlRGlmZihESUZGX0VRVUFMLCBkZWxldGlvbi5zdWJzdHJpbmcoMCwgb3ZlcmxhcF9sZW5ndGgyKSkpO1xuICAgICAgICAgIGRpZmZzW3BvaW50ZXIgLSAxXVswXSA9IERJRkZfSU5TRVJUO1xuICAgICAgICAgIGRpZmZzW3BvaW50ZXIgLSAxXVsxXSA9IGluc2VydGlvbi5zdWJzdHJpbmcoMCwgaW5zZXJ0aW9uLmxlbmd0aCAtIG92ZXJsYXBfbGVuZ3RoMik7XG4gICAgICAgICAgZGlmZnNbcG9pbnRlciArIDFdWzBdID0gRElGRl9ERUxFVEU7XG4gICAgICAgICAgZGlmZnNbcG9pbnRlciArIDFdWzFdID0gZGVsZXRpb24uc3Vic3RyaW5nKG92ZXJsYXBfbGVuZ3RoMik7XG4gICAgICAgICAgcG9pbnRlcisrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBwb2ludGVyKys7XG4gICAgfVxuICAgIHBvaW50ZXIrKztcbiAgfVxufVxuY29uc3Qgbm9uQWxwaGFOdW1lcmljUmVnZXhfID0gL1teYS16QS1aMC05XS87XG5jb25zdCB3aGl0ZXNwYWNlUmVnZXhfID0gL1xccy87XG5jb25zdCBsaW5lYnJlYWtSZWdleF8gPSAvW1xcclxcbl0vO1xuY29uc3QgYmxhbmtsaW5lRW5kUmVnZXhfID0gL1xcblxccj9cXG4kLztcbmNvbnN0IGJsYW5rbGluZVN0YXJ0UmVnZXhfID0gL15cXHI/XFxuXFxyP1xcbi87XG5mdW5jdGlvbiBkaWZmQ2xlYW51cFNlbWFudGljTG9zc2xlc3MoZGlmZnMpIHtcbiAgZnVuY3Rpb24gZGlmZkNsZWFudXBTZW1hbnRpY1Njb3JlKG9uZSwgdHdvKSB7XG4gICAgaWYgKCFvbmUgfHwgIXR3bykge1xuICAgICAgcmV0dXJuIDY7XG4gICAgfVxuICAgIGNvbnN0IGNoYXIxID0gb25lLmNoYXJBdChvbmUubGVuZ3RoIC0gMSk7XG4gICAgY29uc3QgY2hhcjIgPSB0d28uY2hhckF0KDApO1xuICAgIGNvbnN0IG5vbkFscGhhTnVtZXJpYzEgPSBjaGFyMS5tYXRjaChub25BbHBoYU51bWVyaWNSZWdleF8pO1xuICAgIGNvbnN0IG5vbkFscGhhTnVtZXJpYzIgPSBjaGFyMi5tYXRjaChub25BbHBoYU51bWVyaWNSZWdleF8pO1xuICAgIGNvbnN0IHdoaXRlc3BhY2UxID0gbm9uQWxwaGFOdW1lcmljMSAmJiBjaGFyMS5tYXRjaCh3aGl0ZXNwYWNlUmVnZXhfKTtcbiAgICBjb25zdCB3aGl0ZXNwYWNlMiA9IG5vbkFscGhhTnVtZXJpYzIgJiYgY2hhcjIubWF0Y2god2hpdGVzcGFjZVJlZ2V4Xyk7XG4gICAgY29uc3QgbGluZUJyZWFrMSA9IHdoaXRlc3BhY2UxICYmIGNoYXIxLm1hdGNoKGxpbmVicmVha1JlZ2V4Xyk7XG4gICAgY29uc3QgbGluZUJyZWFrMiA9IHdoaXRlc3BhY2UyICYmIGNoYXIyLm1hdGNoKGxpbmVicmVha1JlZ2V4Xyk7XG4gICAgY29uc3QgYmxhbmtMaW5lMSA9IGxpbmVCcmVhazEgJiYgb25lLm1hdGNoKGJsYW5rbGluZUVuZFJlZ2V4Xyk7XG4gICAgY29uc3QgYmxhbmtMaW5lMiA9IGxpbmVCcmVhazIgJiYgdHdvLm1hdGNoKGJsYW5rbGluZVN0YXJ0UmVnZXhfKTtcbiAgICBpZiAoYmxhbmtMaW5lMSB8fCBibGFua0xpbmUyKSB7XG4gICAgICByZXR1cm4gNTtcbiAgICB9IGVsc2UgaWYgKGxpbmVCcmVhazEgfHwgbGluZUJyZWFrMikge1xuICAgICAgcmV0dXJuIDQ7XG4gICAgfSBlbHNlIGlmIChub25BbHBoYU51bWVyaWMxICYmICF3aGl0ZXNwYWNlMSAmJiB3aGl0ZXNwYWNlMikge1xuICAgICAgcmV0dXJuIDM7XG4gICAgfSBlbHNlIGlmICh3aGl0ZXNwYWNlMSB8fCB3aGl0ZXNwYWNlMikge1xuICAgICAgcmV0dXJuIDI7XG4gICAgfSBlbHNlIGlmIChub25BbHBoYU51bWVyaWMxIHx8IG5vbkFscGhhTnVtZXJpYzIpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfVxuICBsZXQgcG9pbnRlciA9IDE7XG4gIHdoaWxlIChwb2ludGVyIDwgZGlmZnMubGVuZ3RoIC0gMSkge1xuICAgIGlmIChkaWZmc1twb2ludGVyIC0gMV1bMF0gPT09IERJRkZfRVFVQUwgJiYgZGlmZnNbcG9pbnRlciArIDFdWzBdID09PSBESUZGX0VRVUFMKSB7XG4gICAgICBsZXQgZXF1YWxpdHkxID0gZGlmZnNbcG9pbnRlciAtIDFdWzFdO1xuICAgICAgbGV0IGVkaXQgPSBkaWZmc1twb2ludGVyXVsxXTtcbiAgICAgIGxldCBlcXVhbGl0eTIgPSBkaWZmc1twb2ludGVyICsgMV1bMV07XG4gICAgICBjb25zdCBjb21tb25PZmZzZXQgPSBkaWZmQ29tbW9uU3VmZml4KGVxdWFsaXR5MSwgZWRpdCk7XG4gICAgICBpZiAoY29tbW9uT2Zmc2V0KSB7XG4gICAgICAgIGNvbnN0IGNvbW1vblN0cmluZyA9IGVkaXQuc3Vic3RyaW5nKGVkaXQubGVuZ3RoIC0gY29tbW9uT2Zmc2V0KTtcbiAgICAgICAgZXF1YWxpdHkxID0gZXF1YWxpdHkxLnN1YnN0cmluZygwLCBlcXVhbGl0eTEubGVuZ3RoIC0gY29tbW9uT2Zmc2V0KTtcbiAgICAgICAgZWRpdCA9IGNvbW1vblN0cmluZyArIGVkaXQuc3Vic3RyaW5nKDAsIGVkaXQubGVuZ3RoIC0gY29tbW9uT2Zmc2V0KTtcbiAgICAgICAgZXF1YWxpdHkyID0gY29tbW9uU3RyaW5nICsgZXF1YWxpdHkyO1xuICAgICAgfVxuICAgICAgbGV0IGJlc3RFcXVhbGl0eTEgPSBlcXVhbGl0eTE7XG4gICAgICBsZXQgYmVzdEVkaXQgPSBlZGl0O1xuICAgICAgbGV0IGJlc3RFcXVhbGl0eTIgPSBlcXVhbGl0eTI7XG4gICAgICBsZXQgYmVzdFNjb3JlID0gZGlmZkNsZWFudXBTZW1hbnRpY1Njb3JlKGVxdWFsaXR5MSwgZWRpdCkgKyBkaWZmQ2xlYW51cFNlbWFudGljU2NvcmUoZWRpdCwgZXF1YWxpdHkyKTtcbiAgICAgIHdoaWxlIChlZGl0LmNoYXJBdCgwKSA9PT0gZXF1YWxpdHkyLmNoYXJBdCgwKSkge1xuICAgICAgICBlcXVhbGl0eTEgKz0gZWRpdC5jaGFyQXQoMCk7XG4gICAgICAgIGVkaXQgPSBlZGl0LnN1YnN0cmluZygxKSArIGVxdWFsaXR5Mi5jaGFyQXQoMCk7XG4gICAgICAgIGVxdWFsaXR5MiA9IGVxdWFsaXR5Mi5zdWJzdHJpbmcoMSk7XG4gICAgICAgIGNvbnN0IHNjb3JlID0gZGlmZkNsZWFudXBTZW1hbnRpY1Njb3JlKGVxdWFsaXR5MSwgZWRpdCkgKyBkaWZmQ2xlYW51cFNlbWFudGljU2NvcmUoZWRpdCwgZXF1YWxpdHkyKTtcbiAgICAgICAgaWYgKHNjb3JlID49IGJlc3RTY29yZSkge1xuICAgICAgICAgIGJlc3RTY29yZSA9IHNjb3JlO1xuICAgICAgICAgIGJlc3RFcXVhbGl0eTEgPSBlcXVhbGl0eTE7XG4gICAgICAgICAgYmVzdEVkaXQgPSBlZGl0O1xuICAgICAgICAgIGJlc3RFcXVhbGl0eTIgPSBlcXVhbGl0eTI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChkaWZmc1twb2ludGVyIC0gMV1bMV0gIT09IGJlc3RFcXVhbGl0eTEpIHtcbiAgICAgICAgaWYgKGJlc3RFcXVhbGl0eTEpIHtcbiAgICAgICAgICBkaWZmc1twb2ludGVyIC0gMV1bMV0gPSBiZXN0RXF1YWxpdHkxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRpZmZzLnNwbGljZShwb2ludGVyIC0gMSwgMSk7XG4gICAgICAgICAgcG9pbnRlci0tO1xuICAgICAgICB9XG4gICAgICAgIGRpZmZzW3BvaW50ZXJdWzFdID0gYmVzdEVkaXQ7XG4gICAgICAgIGlmIChiZXN0RXF1YWxpdHkyKSB7XG4gICAgICAgICAgZGlmZnNbcG9pbnRlciArIDFdWzFdID0gYmVzdEVxdWFsaXR5MjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkaWZmcy5zcGxpY2UocG9pbnRlciArIDEsIDEpO1xuICAgICAgICAgIHBvaW50ZXItLTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBwb2ludGVyKys7XG4gIH1cbn1cbmZ1bmN0aW9uIGRpZmZDbGVhbnVwRWZmaWNpZW5jeShkaWZmcywgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHtcbiAgICBkaWZmRWRpdENvc3QgPSBkZWZhdWx0T3B0aW9ucy5kaWZmRWRpdENvc3RcbiAgfSA9IG9wdGlvbnM7XG4gIGxldCBjaGFuZ2VzID0gZmFsc2U7XG4gIGNvbnN0IGVxdWFsaXRpZXMgPSBbXTtcbiAgbGV0IGVxdWFsaXRpZXNMZW5ndGggPSAwO1xuICBsZXQgbGFzdEVxdWFsaXR5ID0gbnVsbDtcbiAgbGV0IHBvaW50ZXIgPSAwO1xuICBsZXQgcHJlX2lucyA9IGZhbHNlO1xuICBsZXQgcHJlX2RlbCA9IGZhbHNlO1xuICBsZXQgcG9zdF9pbnMgPSBmYWxzZTtcbiAgbGV0IHBvc3RfZGVsID0gZmFsc2U7XG4gIHdoaWxlIChwb2ludGVyIDwgZGlmZnMubGVuZ3RoKSB7XG4gICAgaWYgKGRpZmZzW3BvaW50ZXJdWzBdID09PSBESUZGX0VRVUFMKSB7XG4gICAgICBpZiAoZGlmZnNbcG9pbnRlcl1bMV0ubGVuZ3RoIDwgZGlmZkVkaXRDb3N0ICYmIChwb3N0X2lucyB8fCBwb3N0X2RlbCkpIHtcbiAgICAgICAgZXF1YWxpdGllc1tlcXVhbGl0aWVzTGVuZ3RoKytdID0gcG9pbnRlcjtcbiAgICAgICAgcHJlX2lucyA9IHBvc3RfaW5zO1xuICAgICAgICBwcmVfZGVsID0gcG9zdF9kZWw7XG4gICAgICAgIGxhc3RFcXVhbGl0eSA9IGRpZmZzW3BvaW50ZXJdWzFdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXF1YWxpdGllc0xlbmd0aCA9IDA7XG4gICAgICAgIGxhc3RFcXVhbGl0eSA9IG51bGw7XG4gICAgICB9XG4gICAgICBwb3N0X2lucyA9IHBvc3RfZGVsID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBib29sZWFuQ291bnQgPSBmdW5jdGlvbiguLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiBhcmdzLmZpbHRlcihCb29sZWFuKS5sZW5ndGg7XG4gICAgICB9O1xuICAgICAgaWYgKGRpZmZzW3BvaW50ZXJdWzBdID09PSBESUZGX0RFTEVURSlcbiAgICAgICAgcG9zdF9kZWwgPSB0cnVlO1xuICAgICAgZWxzZVxuICAgICAgICBwb3N0X2lucyA9IHRydWU7XG4gICAgICBpZiAobGFzdEVxdWFsaXR5ICYmIChwcmVfaW5zICYmIHByZV9kZWwgJiYgcG9zdF9pbnMgJiYgcG9zdF9kZWwgfHwgbGFzdEVxdWFsaXR5Lmxlbmd0aCA8IGRpZmZFZGl0Q29zdCAvIDIgJiYgYm9vbGVhbkNvdW50KHByZV9pbnMsIHByZV9kZWwsIHBvc3RfaW5zLCBwb3N0X2RlbCkgPT09IDMpKSB7XG4gICAgICAgIGRpZmZzLnNwbGljZShlcXVhbGl0aWVzW2VxdWFsaXRpZXNMZW5ndGggLSAxXSwgMCwgY3JlYXRlRGlmZihESUZGX0RFTEVURSwgbGFzdEVxdWFsaXR5KSk7XG4gICAgICAgIGRpZmZzW2VxdWFsaXRpZXNbZXF1YWxpdGllc0xlbmd0aCAtIDFdICsgMV1bMF0gPSBESUZGX0lOU0VSVDtcbiAgICAgICAgZXF1YWxpdGllc0xlbmd0aC0tO1xuICAgICAgICBsYXN0RXF1YWxpdHkgPSBudWxsO1xuICAgICAgICBpZiAocHJlX2lucyAmJiBwcmVfZGVsKSB7XG4gICAgICAgICAgcG9zdF9pbnMgPSBwb3N0X2RlbCA9IHRydWU7XG4gICAgICAgICAgZXF1YWxpdGllc0xlbmd0aCA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZXF1YWxpdGllc0xlbmd0aC0tO1xuICAgICAgICAgIHBvaW50ZXIgPSBlcXVhbGl0aWVzTGVuZ3RoID4gMCA/IGVxdWFsaXRpZXNbZXF1YWxpdGllc0xlbmd0aCAtIDFdIDogLTE7XG4gICAgICAgICAgcG9zdF9pbnMgPSBwb3N0X2RlbCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNoYW5nZXMgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBwb2ludGVyKys7XG4gIH1cbiAgaWYgKGNoYW5nZXMpXG4gICAgZGlmZkNsZWFudXBNZXJnZShkaWZmcyk7XG59XG5mdW5jdGlvbiBkaWZmQ2xlYW51cE1lcmdlKGRpZmZzKSB7XG4gIGRpZmZzLnB1c2goY3JlYXRlRGlmZihESUZGX0VRVUFMLCBcIlwiKSk7XG4gIGxldCBwb2ludGVyID0gMDtcbiAgbGV0IGNvdW50X2RlbGV0ZSA9IDA7XG4gIGxldCBjb3VudF9pbnNlcnQgPSAwO1xuICBsZXQgdGV4dF9kZWxldGUgPSBcIlwiO1xuICBsZXQgdGV4dF9pbnNlcnQgPSBcIlwiO1xuICBsZXQgY29tbW9ubGVuZ3RoO1xuICB3aGlsZSAocG9pbnRlciA8IGRpZmZzLmxlbmd0aCkge1xuICAgIHN3aXRjaCAoZGlmZnNbcG9pbnRlcl1bMF0pIHtcbiAgICAgIGNhc2UgRElGRl9JTlNFUlQ6XG4gICAgICAgIGNvdW50X2luc2VydCsrO1xuICAgICAgICB0ZXh0X2luc2VydCArPSBkaWZmc1twb2ludGVyXVsxXTtcbiAgICAgICAgcG9pbnRlcisrO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRElGRl9ERUxFVEU6XG4gICAgICAgIGNvdW50X2RlbGV0ZSsrO1xuICAgICAgICB0ZXh0X2RlbGV0ZSArPSBkaWZmc1twb2ludGVyXVsxXTtcbiAgICAgICAgcG9pbnRlcisrO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRElGRl9FUVVBTDpcbiAgICAgICAgaWYgKGNvdW50X2RlbGV0ZSArIGNvdW50X2luc2VydCA+IDEpIHtcbiAgICAgICAgICBpZiAoY291bnRfZGVsZXRlICE9PSAwICYmIGNvdW50X2luc2VydCAhPT0gMCkge1xuICAgICAgICAgICAgY29tbW9ubGVuZ3RoID0gZGlmZkNvbW1vblByZWZpeCh0ZXh0X2luc2VydCwgdGV4dF9kZWxldGUpO1xuICAgICAgICAgICAgaWYgKGNvbW1vbmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgICBpZiAocG9pbnRlciAtIGNvdW50X2RlbGV0ZSAtIGNvdW50X2luc2VydCA+IDAgJiYgZGlmZnNbcG9pbnRlciAtIGNvdW50X2RlbGV0ZSAtIGNvdW50X2luc2VydCAtIDFdWzBdID09PSBESUZGX0VRVUFMKSB7XG4gICAgICAgICAgICAgICAgZGlmZnNbcG9pbnRlciAtIGNvdW50X2RlbGV0ZSAtIGNvdW50X2luc2VydCAtIDFdWzFdICs9IHRleHRfaW5zZXJ0LnN1YnN0cmluZygwLCBjb21tb25sZW5ndGgpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRpZmZzLnNwbGljZSgwLCAwLCBjcmVhdGVEaWZmKERJRkZfRVFVQUwsIHRleHRfaW5zZXJ0LnN1YnN0cmluZygwLCBjb21tb25sZW5ndGgpKSk7XG4gICAgICAgICAgICAgICAgcG9pbnRlcisrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRleHRfaW5zZXJ0ID0gdGV4dF9pbnNlcnQuc3Vic3RyaW5nKGNvbW1vbmxlbmd0aCk7XG4gICAgICAgICAgICAgIHRleHRfZGVsZXRlID0gdGV4dF9kZWxldGUuc3Vic3RyaW5nKGNvbW1vbmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb21tb25sZW5ndGggPSBkaWZmQ29tbW9uU3VmZml4KHRleHRfaW5zZXJ0LCB0ZXh0X2RlbGV0ZSk7XG4gICAgICAgICAgICBpZiAoY29tbW9ubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAgIGRpZmZzW3BvaW50ZXJdWzFdID0gdGV4dF9pbnNlcnQuc3Vic3RyaW5nKHRleHRfaW5zZXJ0Lmxlbmd0aCAtIGNvbW1vbmxlbmd0aCkgKyBkaWZmc1twb2ludGVyXVsxXTtcbiAgICAgICAgICAgICAgdGV4dF9pbnNlcnQgPSB0ZXh0X2luc2VydC5zdWJzdHJpbmcoMCwgdGV4dF9pbnNlcnQubGVuZ3RoIC0gY29tbW9ubGVuZ3RoKTtcbiAgICAgICAgICAgICAgdGV4dF9kZWxldGUgPSB0ZXh0X2RlbGV0ZS5zdWJzdHJpbmcoMCwgdGV4dF9kZWxldGUubGVuZ3RoIC0gY29tbW9ubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcG9pbnRlciAtPSBjb3VudF9kZWxldGUgKyBjb3VudF9pbnNlcnQ7XG4gICAgICAgICAgZGlmZnMuc3BsaWNlKHBvaW50ZXIsIGNvdW50X2RlbGV0ZSArIGNvdW50X2luc2VydCk7XG4gICAgICAgICAgaWYgKHRleHRfZGVsZXRlLmxlbmd0aCkge1xuICAgICAgICAgICAgZGlmZnMuc3BsaWNlKHBvaW50ZXIsIDAsIGNyZWF0ZURpZmYoRElGRl9ERUxFVEUsIHRleHRfZGVsZXRlKSk7XG4gICAgICAgICAgICBwb2ludGVyKys7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0ZXh0X2luc2VydC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGRpZmZzLnNwbGljZShwb2ludGVyLCAwLCBjcmVhdGVEaWZmKERJRkZfSU5TRVJULCB0ZXh0X2luc2VydCkpO1xuICAgICAgICAgICAgcG9pbnRlcisrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwb2ludGVyKys7XG4gICAgICAgIH0gZWxzZSBpZiAocG9pbnRlciAhPT0gMCAmJiBkaWZmc1twb2ludGVyIC0gMV1bMF0gPT09IERJRkZfRVFVQUwpIHtcbiAgICAgICAgICBkaWZmc1twb2ludGVyIC0gMV1bMV0gKz0gZGlmZnNbcG9pbnRlcl1bMV07XG4gICAgICAgICAgZGlmZnMuc3BsaWNlKHBvaW50ZXIsIDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBvaW50ZXIrKztcbiAgICAgICAgfVxuICAgICAgICBjb3VudF9pbnNlcnQgPSAwO1xuICAgICAgICBjb3VudF9kZWxldGUgPSAwO1xuICAgICAgICB0ZXh0X2RlbGV0ZSA9IFwiXCI7XG4gICAgICAgIHRleHRfaW5zZXJ0ID0gXCJcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGlmIChkaWZmc1tkaWZmcy5sZW5ndGggLSAxXVsxXSA9PT0gXCJcIilcbiAgICBkaWZmcy5wb3AoKTtcbiAgbGV0IGNoYW5nZXMgPSBmYWxzZTtcbiAgcG9pbnRlciA9IDE7XG4gIHdoaWxlIChwb2ludGVyIDwgZGlmZnMubGVuZ3RoIC0gMSkge1xuICAgIGlmIChkaWZmc1twb2ludGVyIC0gMV1bMF0gPT09IERJRkZfRVFVQUwgJiYgZGlmZnNbcG9pbnRlciArIDFdWzBdID09PSBESUZGX0VRVUFMKSB7XG4gICAgICBpZiAoZGlmZnNbcG9pbnRlcl1bMV0uc3Vic3RyaW5nKGRpZmZzW3BvaW50ZXJdWzFdLmxlbmd0aCAtIGRpZmZzW3BvaW50ZXIgLSAxXVsxXS5sZW5ndGgpID09PSBkaWZmc1twb2ludGVyIC0gMV1bMV0pIHtcbiAgICAgICAgZGlmZnNbcG9pbnRlcl1bMV0gPSBkaWZmc1twb2ludGVyIC0gMV1bMV0gKyBkaWZmc1twb2ludGVyXVsxXS5zdWJzdHJpbmcoMCwgZGlmZnNbcG9pbnRlcl1bMV0ubGVuZ3RoIC0gZGlmZnNbcG9pbnRlciAtIDFdWzFdLmxlbmd0aCk7XG4gICAgICAgIGRpZmZzW3BvaW50ZXIgKyAxXVsxXSA9IGRpZmZzW3BvaW50ZXIgLSAxXVsxXSArIGRpZmZzW3BvaW50ZXIgKyAxXVsxXTtcbiAgICAgICAgZGlmZnMuc3BsaWNlKHBvaW50ZXIgLSAxLCAxKTtcbiAgICAgICAgY2hhbmdlcyA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGRpZmZzW3BvaW50ZXJdWzFdLnN1YnN0cmluZygwLCBkaWZmc1twb2ludGVyICsgMV1bMV0ubGVuZ3RoKSA9PT0gZGlmZnNbcG9pbnRlciArIDFdWzFdKSB7XG4gICAgICAgIGRpZmZzW3BvaW50ZXIgLSAxXVsxXSArPSBkaWZmc1twb2ludGVyICsgMV1bMV07XG4gICAgICAgIGRpZmZzW3BvaW50ZXJdWzFdID0gZGlmZnNbcG9pbnRlcl1bMV0uc3Vic3RyaW5nKGRpZmZzW3BvaW50ZXIgKyAxXVsxXS5sZW5ndGgpICsgZGlmZnNbcG9pbnRlciArIDFdWzFdO1xuICAgICAgICBkaWZmcy5zcGxpY2UocG9pbnRlciArIDEsIDEpO1xuICAgICAgICBjaGFuZ2VzID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcG9pbnRlcisrO1xuICB9XG4gIGlmIChjaGFuZ2VzKVxuICAgIGRpZmZDbGVhbnVwTWVyZ2UoZGlmZnMpO1xufVxuZnVuY3Rpb24gZGlmZlhJbmRleChkaWZmcywgbG9jKSB7XG4gIGxldCBjaGFyczEgPSAwO1xuICBsZXQgY2hhcnMyID0gMDtcbiAgbGV0IGxhc3RfY2hhcnMxID0gMDtcbiAgbGV0IGxhc3RfY2hhcnMyID0gMDtcbiAgbGV0IHg7XG4gIGZvciAoeCA9IDA7IHggPCBkaWZmcy5sZW5ndGg7IHgrKykge1xuICAgIGlmIChkaWZmc1t4XVswXSAhPT0gRElGRl9JTlNFUlQpIHtcbiAgICAgIGNoYXJzMSArPSBkaWZmc1t4XVsxXS5sZW5ndGg7XG4gICAgfVxuICAgIGlmIChkaWZmc1t4XVswXSAhPT0gRElGRl9ERUxFVEUpIHtcbiAgICAgIGNoYXJzMiArPSBkaWZmc1t4XVsxXS5sZW5ndGg7XG4gICAgfVxuICAgIGlmIChjaGFyczEgPiBsb2MpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBsYXN0X2NoYXJzMSA9IGNoYXJzMTtcbiAgICBsYXN0X2NoYXJzMiA9IGNoYXJzMjtcbiAgfVxuICBpZiAoZGlmZnMubGVuZ3RoICE9PSB4ICYmIGRpZmZzW3hdWzBdID09PSBESUZGX0RFTEVURSlcbiAgICByZXR1cm4gbGFzdF9jaGFyczI7XG4gIHJldHVybiBsYXN0X2NoYXJzMiArIChsb2MgLSBsYXN0X2NoYXJzMSk7XG59XG5mdW5jdGlvbiBkaWZmUHJldHR5SHRtbChkaWZmcykge1xuICBjb25zdCBodG1sID0gW107XG4gIGNvbnN0IHBhdHRlcm5fYW1wID0gLyYvZztcbiAgY29uc3QgcGF0dGVybl9sdCA9IC88L2c7XG4gIGNvbnN0IHBhdHRlcm5fZ3QgPSAvPi9nO1xuICBjb25zdCBwYXR0ZXJuX3BhcmEgPSAvXFxuL2c7XG4gIGZvciAobGV0IHggPSAwOyB4IDwgZGlmZnMubGVuZ3RoOyB4KyspIHtcbiAgICBjb25zdCBvcCA9IGRpZmZzW3hdWzBdO1xuICAgIGNvbnN0IGRhdGEgPSBkaWZmc1t4XVsxXTtcbiAgICBjb25zdCB0ZXh0ID0gZGF0YS5yZXBsYWNlKHBhdHRlcm5fYW1wLCBcIiZhbXA7XCIpLnJlcGxhY2UocGF0dGVybl9sdCwgXCImbHQ7XCIpLnJlcGxhY2UocGF0dGVybl9ndCwgXCImZ3Q7XCIpLnJlcGxhY2UocGF0dGVybl9wYXJhLCBcIiZwYXJhOzxicj5cIik7XG4gICAgc3dpdGNoIChvcCkge1xuICAgICAgY2FzZSBESUZGX0lOU0VSVDpcbiAgICAgICAgaHRtbFt4XSA9IGA8aW5zIHN0eWxlPVwiYmFja2dyb3VuZDojZTZmZmU2O1wiPiR7dGV4dH08L2lucz5gO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRElGRl9ERUxFVEU6XG4gICAgICAgIGh0bWxbeF0gPSBgPGRlbCBzdHlsZT1cImJhY2tncm91bmQ6I2ZmZTZlNjtcIj4ke3RleHR9PC9kZWw+YDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERJRkZfRVFVQUw6XG4gICAgICAgIGh0bWxbeF0gPSBgPHNwYW4+JHt0ZXh0fTwvc3Bhbj5gO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGh0bWwuam9pbihcIlwiKTtcbn1cbmZ1bmN0aW9uIGRpZmZUZXh0MShkaWZmcykge1xuICBjb25zdCB0ZXh0ID0gW107XG4gIGZvciAobGV0IHggPSAwOyB4IDwgZGlmZnMubGVuZ3RoOyB4KyspIHtcbiAgICBpZiAoZGlmZnNbeF1bMF0gIT09IERJRkZfSU5TRVJUKVxuICAgICAgdGV4dFt4XSA9IGRpZmZzW3hdWzFdO1xuICB9XG4gIHJldHVybiB0ZXh0LmpvaW4oXCJcIik7XG59XG5mdW5jdGlvbiBkaWZmVGV4dDIoZGlmZnMpIHtcbiAgY29uc3QgdGV4dCA9IFtdO1xuICBmb3IgKGxldCB4ID0gMDsgeCA8IGRpZmZzLmxlbmd0aDsgeCsrKSB7XG4gICAgaWYgKGRpZmZzW3hdWzBdICE9PSBESUZGX0RFTEVURSlcbiAgICAgIHRleHRbeF0gPSBkaWZmc1t4XVsxXTtcbiAgfVxuICByZXR1cm4gdGV4dC5qb2luKFwiXCIpO1xufVxuZnVuY3Rpb24gZGlmZkxldmVuc2h0ZWluKGRpZmZzKSB7XG4gIGxldCBsZXZlbnNodGVpbiA9IDA7XG4gIGxldCBpbnNlcnRpb25zID0gMDtcbiAgbGV0IGRlbGV0aW9ucyA9IDA7XG4gIGZvciAobGV0IHggPSAwOyB4IDwgZGlmZnMubGVuZ3RoOyB4KyspIHtcbiAgICBjb25zdCBvcCA9IGRpZmZzW3hdWzBdO1xuICAgIGNvbnN0IGRhdGEgPSBkaWZmc1t4XVsxXTtcbiAgICBzd2l0Y2ggKG9wKSB7XG4gICAgICBjYXNlIERJRkZfSU5TRVJUOlxuICAgICAgICBpbnNlcnRpb25zICs9IGRhdGEubGVuZ3RoO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRElGRl9ERUxFVEU6XG4gICAgICAgIGRlbGV0aW9ucyArPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERJRkZfRVFVQUw6XG4gICAgICAgIGxldmVuc2h0ZWluICs9IE1hdGgubWF4KGluc2VydGlvbnMsIGRlbGV0aW9ucyk7XG4gICAgICAgIGluc2VydGlvbnMgPSAwO1xuICAgICAgICBkZWxldGlvbnMgPSAwO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgbGV2ZW5zaHRlaW4gKz0gTWF0aC5tYXgoaW5zZXJ0aW9ucywgZGVsZXRpb25zKTtcbiAgcmV0dXJuIGxldmVuc2h0ZWluO1xufVxuZnVuY3Rpb24gZGlmZlRvRGVsdGEoZGlmZnMpIHtcbiAgY29uc3QgdGV4dCA9IFtdO1xuICBmb3IgKGxldCB4ID0gMDsgeCA8IGRpZmZzLmxlbmd0aDsgeCsrKSB7XG4gICAgc3dpdGNoIChkaWZmc1t4XVswXSkge1xuICAgICAgY2FzZSBESUZGX0lOU0VSVDpcbiAgICAgICAgdGV4dFt4XSA9IGArJHtlbmNvZGVVUkkoZGlmZnNbeF1bMV0pfWA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBESUZGX0RFTEVURTpcbiAgICAgICAgdGV4dFt4XSA9IGAtJHtkaWZmc1t4XVsxXS5sZW5ndGh9YDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERJRkZfRVFVQUw6XG4gICAgICAgIHRleHRbeF0gPSBgPSR7ZGlmZnNbeF1bMV0ubGVuZ3RofWA7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGV4dC5qb2luKFwiXHRcIikucmVwbGFjZSgvJTIwL2csIFwiIFwiKTtcbn1cbmZ1bmN0aW9uIGRpZmZGcm9tRGVsdGEodGV4dDEsIGRlbHRhKSB7XG4gIGNvbnN0IGRpZmZzID0gW107XG4gIGxldCBkaWZmc0xlbmd0aCA9IDA7XG4gIGxldCBwb2ludGVyID0gMDtcbiAgY29uc3QgdG9rZW5zID0gZGVsdGEuc3BsaXQoL1xcdC9nKTtcbiAgZm9yIChsZXQgeCA9IDA7IHggPCB0b2tlbnMubGVuZ3RoOyB4KyspIHtcbiAgICBjb25zdCBwYXJhbSA9IHRva2Vuc1t4XS5zdWJzdHJpbmcoMSk7XG4gICAgc3dpdGNoICh0b2tlbnNbeF0uY2hhckF0KDApKSB7XG4gICAgICBjYXNlIFwiK1wiOlxuICAgICAgICB0cnkge1xuICAgICAgICAgIGRpZmZzW2RpZmZzTGVuZ3RoKytdID0gY3JlYXRlRGlmZihESUZGX0lOU0VSVCwgZGVjb2RlVVJJKHBhcmFtKSk7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbGxlZ2FsIGVzY2FwZSBpbiBkaWZmX2Zyb21EZWx0YTogJHtwYXJhbX1gKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCItXCI6XG4gICAgICBjYXNlIFwiPVwiOiB7XG4gICAgICAgIGNvbnN0IG4gPSBOdW1iZXIucGFyc2VJbnQocGFyYW0sIDEwKTtcbiAgICAgICAgaWYgKE51bWJlci5pc05hTihuKSB8fCBuIDwgMClcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgbnVtYmVyIGluIGRpZmZfZnJvbURlbHRhOiAke3BhcmFtfWApO1xuICAgICAgICBjb25zdCB0ZXh0ID0gdGV4dDEuc3Vic3RyaW5nKHBvaW50ZXIsIHBvaW50ZXIgKz0gbik7XG4gICAgICAgIGlmICh0b2tlbnNbeF0uY2hhckF0KDApID09PSBcIj1cIilcbiAgICAgICAgICBkaWZmc1tkaWZmc0xlbmd0aCsrXSA9IGNyZWF0ZURpZmYoRElGRl9FUVVBTCwgdGV4dCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBkaWZmc1tkaWZmc0xlbmd0aCsrXSA9IGNyZWF0ZURpZmYoRElGRl9ERUxFVEUsIHRleHQpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmICh0b2tlbnNbeF0pXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGRpZmYgb3BlcmF0aW9uIGluIGRpZmZfZnJvbURlbHRhOiAke3Rva2Vuc1t4XX1gKTtcbiAgICB9XG4gIH1cbiAgaWYgKHBvaW50ZXIgIT09IHRleHQxLmxlbmd0aClcbiAgICB0aHJvdyBuZXcgRXJyb3IoYERlbHRhIGxlbmd0aCAoJHtwb2ludGVyfSkgZG9lcyBub3QgZXF1YWwgc291cmNlIHRleHQgbGVuZ3RoICgke3RleHQxLmxlbmd0aH0pLmApO1xuICByZXR1cm4gZGlmZnM7XG59XG5cbmZ1bmN0aW9uIG1hdGNoTWFpbih0ZXh0LCBwYXR0ZXJuLCBsb2MsIG9wdGlvbnMpIHtcbiAgaWYgKHRleHQgPT0gbnVsbCB8fCBwYXR0ZXJuID09IG51bGwgfHwgbG9jID09IG51bGwpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTnVsbCBpbnB1dC4gKG1hdGNoX21haW4pXCIpO1xuICBsb2MgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihsb2MsIHRleHQubGVuZ3RoKSk7XG4gIGlmICh0ZXh0ID09PSBwYXR0ZXJuKSB7XG4gICAgcmV0dXJuIDA7XG4gIH0gZWxzZSBpZiAoIXRleHQubGVuZ3RoKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9IGVsc2UgaWYgKHRleHQuc3Vic3RyaW5nKGxvYywgbG9jICsgcGF0dGVybi5sZW5ndGgpID09PSBwYXR0ZXJuKSB7XG4gICAgcmV0dXJuIGxvYztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbWF0Y2hCaXRhcCh0ZXh0LCBwYXR0ZXJuLCBsb2MsIG9wdGlvbnMpO1xuICB9XG59XG5mdW5jdGlvbiBtYXRjaEJpdGFwKHRleHQsIHBhdHRlcm4sIGxvYywgb3B0aW9ucykge1xuICBjb25zdCByZXNvbHZlZCA9IHJlc29sdmVPcHRpb25zKG9wdGlvbnMpO1xuICBpZiAocGF0dGVybi5sZW5ndGggPiByZXNvbHZlZC5tYXRjaE1heEJpdHMpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiUGF0dGVybiB0b28gbG9uZyBmb3IgdGhpcyBicm93c2VyLlwiKTtcbiAgY29uc3QgcyA9IG1hdGNoQWxwaGFiZXQocGF0dGVybik7XG4gIGZ1bmN0aW9uIG1hdGNoQml0YXBTY29yZShlLCB4KSB7XG4gICAgY29uc3QgYWNjdXJhY3kgPSBlIC8gcGF0dGVybi5sZW5ndGg7XG4gICAgY29uc3QgcHJveGltaXR5ID0gTWF0aC5hYnMobG9jIC0geCk7XG4gICAgaWYgKCFyZXNvbHZlZC5tYXRjaERpc3RhbmNlKSB7XG4gICAgICByZXR1cm4gcHJveGltaXR5ID8gMSA6IGFjY3VyYWN5O1xuICAgIH1cbiAgICByZXR1cm4gYWNjdXJhY3kgKyBwcm94aW1pdHkgLyByZXNvbHZlZC5tYXRjaERpc3RhbmNlO1xuICB9XG4gIGxldCBzY29yZV90aHJlc2hvbGQgPSByZXNvbHZlZC5tYXRjaFRocmVzaG9sZDtcbiAgbGV0IGJlc3RfbG9jID0gdGV4dC5pbmRleE9mKHBhdHRlcm4sIGxvYyk7XG4gIGlmIChiZXN0X2xvYyAhPT0gLTEpIHtcbiAgICBzY29yZV90aHJlc2hvbGQgPSBNYXRoLm1pbihtYXRjaEJpdGFwU2NvcmUoMCwgYmVzdF9sb2MpLCBzY29yZV90aHJlc2hvbGQpO1xuICAgIGJlc3RfbG9jID0gdGV4dC5sYXN0SW5kZXhPZihwYXR0ZXJuLCBsb2MgKyBwYXR0ZXJuLmxlbmd0aCk7XG4gICAgaWYgKGJlc3RfbG9jICE9PSAtMSlcbiAgICAgIHNjb3JlX3RocmVzaG9sZCA9IE1hdGgubWluKG1hdGNoQml0YXBTY29yZSgwLCBiZXN0X2xvYyksIHNjb3JlX3RocmVzaG9sZCk7XG4gIH1cbiAgY29uc3QgbWF0Y2htYXNrID0gMSA8PCBwYXR0ZXJuLmxlbmd0aCAtIDE7XG4gIGJlc3RfbG9jID0gLTE7XG4gIGxldCBiaW5fbWluLCBiaW5fbWlkO1xuICBsZXQgYmluX21heCA9IHBhdHRlcm4ubGVuZ3RoICsgdGV4dC5sZW5ndGg7XG4gIGxldCBsYXN0X3JkID0gW107XG4gIGZvciAobGV0IGQgPSAwOyBkIDwgcGF0dGVybi5sZW5ndGg7IGQrKykge1xuICAgIGJpbl9taW4gPSAwO1xuICAgIGJpbl9taWQgPSBiaW5fbWF4O1xuICAgIHdoaWxlIChiaW5fbWluIDwgYmluX21pZCkge1xuICAgICAgaWYgKG1hdGNoQml0YXBTY29yZShkLCBsb2MgKyBiaW5fbWlkKSA8PSBzY29yZV90aHJlc2hvbGQpXG4gICAgICAgIGJpbl9taW4gPSBiaW5fbWlkO1xuICAgICAgZWxzZVxuICAgICAgICBiaW5fbWF4ID0gYmluX21pZDtcbiAgICAgIGJpbl9taWQgPSBNYXRoLmZsb29yKChiaW5fbWF4IC0gYmluX21pbikgLyAyICsgYmluX21pbik7XG4gICAgfVxuICAgIGJpbl9tYXggPSBiaW5fbWlkO1xuICAgIGxldCBzdGFydCA9IE1hdGgubWF4KDEsIGxvYyAtIGJpbl9taWQgKyAxKTtcbiAgICBjb25zdCBmaW5pc2ggPSBNYXRoLm1pbihsb2MgKyBiaW5fbWlkLCB0ZXh0Lmxlbmd0aCkgKyBwYXR0ZXJuLmxlbmd0aDtcbiAgICBjb25zdCByZCA9IEFycmF5KGZpbmlzaCArIDIpO1xuICAgIHJkW2ZpbmlzaCArIDFdID0gKDEgPDwgZCkgLSAxO1xuICAgIGZvciAobGV0IGogPSBmaW5pc2g7IGogPj0gc3RhcnQ7IGotLSkge1xuICAgICAgY29uc3QgY2hhck1hdGNoID0gc1t0ZXh0LmNoYXJBdChqIC0gMSldO1xuICAgICAgaWYgKGQgPT09IDApIHtcbiAgICAgICAgcmRbal0gPSAocmRbaiArIDFdIDw8IDEgfCAxKSAmIGNoYXJNYXRjaDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJkW2pdID0gKHJkW2ogKyAxXSA8PCAxIHwgMSkgJiBjaGFyTWF0Y2ggfCAoKGxhc3RfcmRbaiArIDFdIHwgbGFzdF9yZFtqXSkgPDwgMSB8IDEpIHwgbGFzdF9yZFtqICsgMV07XG4gICAgICB9XG4gICAgICBpZiAocmRbal0gJiBtYXRjaG1hc2spIHtcbiAgICAgICAgY29uc3Qgc2NvcmUgPSBtYXRjaEJpdGFwU2NvcmUoZCwgaiAtIDEpO1xuICAgICAgICBpZiAoc2NvcmUgPD0gc2NvcmVfdGhyZXNob2xkKSB7XG4gICAgICAgICAgc2NvcmVfdGhyZXNob2xkID0gc2NvcmU7XG4gICAgICAgICAgYmVzdF9sb2MgPSBqIC0gMTtcbiAgICAgICAgICBpZiAoYmVzdF9sb2MgPiBsb2MpIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gTWF0aC5tYXgoMSwgMiAqIGxvYyAtIGJlc3RfbG9jKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChtYXRjaEJpdGFwU2NvcmUoZCArIDEsIGxvYykgPiBzY29yZV90aHJlc2hvbGQpXG4gICAgICBicmVhaztcbiAgICBsYXN0X3JkID0gcmQ7XG4gIH1cbiAgcmV0dXJuIGJlc3RfbG9jO1xufVxuZnVuY3Rpb24gbWF0Y2hBbHBoYWJldChwYXR0ZXJuKSB7XG4gIGNvbnN0IHMgPSB7fTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXR0ZXJuLmxlbmd0aDsgaSsrKVxuICAgIHNbcGF0dGVybi5jaGFyQXQoaSldID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXR0ZXJuLmxlbmd0aDsgaSsrKVxuICAgIHNbcGF0dGVybi5jaGFyQXQoaSldIHw9IDEgPDwgcGF0dGVybi5sZW5ndGggLSBpIC0gMTtcbiAgcmV0dXJuIHM7XG59XG5cbmZ1bmN0aW9uIHBhdGNoQWRkQ29udGV4dChwYXRjaCwgdGV4dCwgb3B0aW9ucykge1xuICBpZiAodGV4dC5sZW5ndGggPT09IDApXG4gICAgcmV0dXJuO1xuICBpZiAocGF0Y2guc3RhcnQyID09PSBudWxsKVxuICAgIHRocm93IG5ldyBFcnJvcihcInBhdGNoIG5vdCBpbml0aWFsaXplZFwiKTtcbiAgY29uc3Qge1xuICAgIG1hdGNoTWF4Qml0cyA9IGRlZmF1bHRPcHRpb25zLm1hdGNoTWF4Qml0cyxcbiAgICBwYXRjaE1hcmdpbiA9IGRlZmF1bHRPcHRpb25zLnBhdGNoTWFyZ2luXG4gIH0gPSBvcHRpb25zO1xuICBsZXQgcGF0dGVybiA9IHRleHQuc3Vic3RyaW5nKHBhdGNoLnN0YXJ0MiwgcGF0Y2guc3RhcnQyICsgcGF0Y2gubGVuZ3RoMSk7XG4gIGxldCBwYWRkaW5nID0gMDtcbiAgd2hpbGUgKHRleHQuaW5kZXhPZihwYXR0ZXJuKSAhPT0gdGV4dC5sYXN0SW5kZXhPZihwYXR0ZXJuKSAmJiBwYXR0ZXJuLmxlbmd0aCA8IG1hdGNoTWF4Qml0cyAtIHBhdGNoTWFyZ2luIC0gcGF0Y2hNYXJnaW4pIHtcbiAgICBwYWRkaW5nICs9IHBhdGNoTWFyZ2luO1xuICAgIHBhdHRlcm4gPSB0ZXh0LnN1YnN0cmluZyhwYXRjaC5zdGFydDIgLSBwYWRkaW5nLCBwYXRjaC5zdGFydDIgKyBwYXRjaC5sZW5ndGgxICsgcGFkZGluZyk7XG4gIH1cbiAgcGFkZGluZyArPSBwYXRjaE1hcmdpbjtcbiAgY29uc3QgcHJlZml4ID0gdGV4dC5zdWJzdHJpbmcocGF0Y2guc3RhcnQyIC0gcGFkZGluZywgcGF0Y2guc3RhcnQyKTtcbiAgaWYgKHByZWZpeClcbiAgICBwYXRjaC5kaWZmcy51bnNoaWZ0KGNyZWF0ZURpZmYoRElGRl9FUVVBTCwgcHJlZml4KSk7XG4gIGNvbnN0IHN1ZmZpeCA9IHRleHQuc3Vic3RyaW5nKHBhdGNoLnN0YXJ0MiArIHBhdGNoLmxlbmd0aDEsIHBhdGNoLnN0YXJ0MiArIHBhdGNoLmxlbmd0aDEgKyBwYWRkaW5nKTtcbiAgaWYgKHN1ZmZpeClcbiAgICBwYXRjaC5kaWZmcy5wdXNoKGNyZWF0ZURpZmYoRElGRl9FUVVBTCwgc3VmZml4KSk7XG4gIHBhdGNoLnN0YXJ0MSAtPSBwcmVmaXgubGVuZ3RoO1xuICBwYXRjaC5zdGFydDIgLT0gcHJlZml4Lmxlbmd0aDtcbiAgcGF0Y2gubGVuZ3RoMSArPSBwcmVmaXgubGVuZ3RoICsgc3VmZml4Lmxlbmd0aDtcbiAgcGF0Y2gubGVuZ3RoMiArPSBwcmVmaXgubGVuZ3RoICsgc3VmZml4Lmxlbmd0aDtcbn1cbmZ1bmN0aW9uIHBhdGNoTWFrZShhLCBvcHRfYiwgb3B0X2MsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCByZXNvbHZlZCA9IHtcbiAgICAuLi5kZWZhdWx0T3B0aW9ucyxcbiAgICAuLi5vcHRpb25zXG4gIH07XG4gIGxldCB0ZXh0MSwgZGlmZnM7XG4gIGlmICh0eXBlb2YgYSA9PSBcInN0cmluZ1wiICYmIHR5cGVvZiBvcHRfYiA9PSBcInN0cmluZ1wiICYmIHR5cGVvZiBvcHRfYyA9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdGV4dDEgPSBhO1xuICAgIGRpZmZzID0gZGlmZk1haW4odGV4dDEsIG9wdF9iLCByZXNvbHZlZCwgdHJ1ZSk7XG4gICAgaWYgKGRpZmZzLmxlbmd0aCA+IDIpIHtcbiAgICAgIGRpZmZDbGVhbnVwU2VtYW50aWMoZGlmZnMpO1xuICAgICAgZGlmZkNsZWFudXBFZmZpY2llbmN5KGRpZmZzKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoYSAmJiB0eXBlb2YgYSA9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBvcHRfYiA9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBvcHRfYyA9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgZGlmZnMgPSAvKiogQHR5cGUge0RpZmZbXX0gKi9cbiAgICBhO1xuICAgIHRleHQxID0gZGlmZlRleHQxKGRpZmZzKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgYSA9PSBcInN0cmluZ1wiICYmIG9wdF9iICYmIHR5cGVvZiBvcHRfYiA9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBvcHRfYyA9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdGV4dDEgPSAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgICBhO1xuICAgIGRpZmZzID0gLyoqIEB0eXBlIHtEaWZmW119ICovXG4gICAgb3B0X2I7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGEgPT0gXCJzdHJpbmdcIiAmJiB0eXBlb2Ygb3B0X2IgPT0gXCJzdHJpbmdcIiAmJiBvcHRfYyAmJiB0eXBlb2Ygb3B0X2MgPT0gXCJvYmplY3RcIikge1xuICAgIHRleHQxID0gLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgYTtcbiAgICBkaWZmcyA9IC8qKiBAdHlwZSB7RGlmZltdfSAqL1xuICAgIG9wdF9jO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gY2FsbCBmb3JtYXQgdG8gcGF0Y2hfbWFrZS5cIik7XG4gIH1cbiAgaWYgKGRpZmZzLmxlbmd0aCA9PT0gMClcbiAgICByZXR1cm4gW107XG4gIGNvbnN0IHBhdGNoZXMgPSBbXTtcbiAgbGV0IHBhdGNoID0gY3JlYXRlUGF0Y2goKTtcbiAgbGV0IHBhdGNoRGlmZkxlbmd0aCA9IDA7XG4gIGxldCBjaGFyX2NvdW50MSA9IDA7XG4gIGxldCBjaGFyX2NvdW50MiA9IDA7XG4gIGxldCBwcmVwYXRjaF90ZXh0ID0gdGV4dDE7XG4gIGxldCBwb3N0cGF0Y2hfdGV4dCA9IHRleHQxO1xuICBmb3IgKGxldCB4ID0gMDsgeCA8IGRpZmZzLmxlbmd0aDsgeCsrKSB7XG4gICAgY29uc3QgZGlmZl90eXBlID0gZGlmZnNbeF1bMF07XG4gICAgY29uc3QgZGlmZl90ZXh0ID0gZGlmZnNbeF1bMV07XG4gICAgaWYgKCFwYXRjaERpZmZMZW5ndGggJiYgZGlmZl90eXBlICE9PSBESUZGX0VRVUFMKSB7XG4gICAgICBwYXRjaC5zdGFydDEgPSBjaGFyX2NvdW50MTtcbiAgICAgIHBhdGNoLnN0YXJ0MiA9IGNoYXJfY291bnQyO1xuICAgIH1cbiAgICBzd2l0Y2ggKGRpZmZfdHlwZSkge1xuICAgICAgY2FzZSBESUZGX0lOU0VSVDpcbiAgICAgICAgcGF0Y2guZGlmZnNbcGF0Y2hEaWZmTGVuZ3RoKytdID0gZGlmZnNbeF07XG4gICAgICAgIHBhdGNoLmxlbmd0aDIgKz0gZGlmZl90ZXh0Lmxlbmd0aDtcbiAgICAgICAgcG9zdHBhdGNoX3RleHQgPSBwb3N0cGF0Y2hfdGV4dC5zdWJzdHJpbmcoMCwgY2hhcl9jb3VudDIpICsgZGlmZl90ZXh0ICsgcG9zdHBhdGNoX3RleHQuc3Vic3RyaW5nKGNoYXJfY291bnQyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERJRkZfREVMRVRFOlxuICAgICAgICBwYXRjaC5sZW5ndGgxICs9IGRpZmZfdGV4dC5sZW5ndGg7XG4gICAgICAgIHBhdGNoLmRpZmZzW3BhdGNoRGlmZkxlbmd0aCsrXSA9IGRpZmZzW3hdO1xuICAgICAgICBwb3N0cGF0Y2hfdGV4dCA9IHBvc3RwYXRjaF90ZXh0LnN1YnN0cmluZygwLCBjaGFyX2NvdW50MikgKyBwb3N0cGF0Y2hfdGV4dC5zdWJzdHJpbmcoY2hhcl9jb3VudDIgKyBkaWZmX3RleHQubGVuZ3RoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERJRkZfRVFVQUw6XG4gICAgICAgIGlmIChkaWZmX3RleHQubGVuZ3RoIDw9IDIgKiByZXNvbHZlZC5wYXRjaE1hcmdpbiAmJiBwYXRjaERpZmZMZW5ndGggJiYgZGlmZnMubGVuZ3RoICE9PSB4ICsgMSkge1xuICAgICAgICAgIHBhdGNoLmRpZmZzW3BhdGNoRGlmZkxlbmd0aCsrXSA9IGRpZmZzW3hdO1xuICAgICAgICAgIHBhdGNoLmxlbmd0aDEgKz0gZGlmZl90ZXh0Lmxlbmd0aDtcbiAgICAgICAgICBwYXRjaC5sZW5ndGgyICs9IGRpZmZfdGV4dC5sZW5ndGg7XG4gICAgICAgIH0gZWxzZSBpZiAoZGlmZl90ZXh0Lmxlbmd0aCA+PSAyICogcmVzb2x2ZWQucGF0Y2hNYXJnaW4pIHtcbiAgICAgICAgICBpZiAocGF0Y2hEaWZmTGVuZ3RoKSB7XG4gICAgICAgICAgICBwYXRjaEFkZENvbnRleHQocGF0Y2gsIHByZXBhdGNoX3RleHQsIHJlc29sdmVkKTtcbiAgICAgICAgICAgIHBhdGNoZXMucHVzaChwYXRjaCk7XG4gICAgICAgICAgICBwYXRjaCA9IGNyZWF0ZVBhdGNoKCk7XG4gICAgICAgICAgICBwYXRjaERpZmZMZW5ndGggPSAwO1xuICAgICAgICAgICAgcHJlcGF0Y2hfdGV4dCA9IHBvc3RwYXRjaF90ZXh0O1xuICAgICAgICAgICAgY2hhcl9jb3VudDEgPSBjaGFyX2NvdW50MjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmIChkaWZmX3R5cGUgIT09IERJRkZfSU5TRVJUKVxuICAgICAgY2hhcl9jb3VudDEgKz0gZGlmZl90ZXh0Lmxlbmd0aDtcbiAgICBpZiAoZGlmZl90eXBlICE9PSBESUZGX0RFTEVURSlcbiAgICAgIGNoYXJfY291bnQyICs9IGRpZmZfdGV4dC5sZW5ndGg7XG4gIH1cbiAgaWYgKHBhdGNoRGlmZkxlbmd0aCkge1xuICAgIHBhdGNoQWRkQ29udGV4dChwYXRjaCwgcHJlcGF0Y2hfdGV4dCwgcmVzb2x2ZWQpO1xuICAgIHBhdGNoZXMucHVzaChwYXRjaCk7XG4gIH1cbiAgcmV0dXJuIHBhdGNoZXM7XG59XG5mdW5jdGlvbiBwYXRjaERlZXBDb3B5KHBhdGNoZXMpIHtcbiAgY29uc3QgcGF0Y2hlc0NvcHkgPSBbXTtcbiAgZm9yIChsZXQgeCA9IDA7IHggPCBwYXRjaGVzLmxlbmd0aDsgeCsrKSB7XG4gICAgY29uc3QgcGF0Y2ggPSBwYXRjaGVzW3hdO1xuICAgIGNvbnN0IHBhdGNoQ29weSA9IGNyZWF0ZVBhdGNoKCk7XG4gICAgcGF0Y2hDb3B5LmRpZmZzID0gW107XG4gICAgZm9yIChsZXQgeSA9IDA7IHkgPCBwYXRjaC5kaWZmcy5sZW5ndGg7IHkrKykge1xuICAgICAgcGF0Y2hDb3B5LmRpZmZzW3ldID0gY3JlYXRlRGlmZihwYXRjaC5kaWZmc1t5XVswXSwgcGF0Y2guZGlmZnNbeV1bMV0pO1xuICAgIH1cbiAgICBwYXRjaENvcHkuc3RhcnQxID0gcGF0Y2guc3RhcnQxO1xuICAgIHBhdGNoQ29weS5zdGFydDIgPSBwYXRjaC5zdGFydDI7XG4gICAgcGF0Y2hDb3B5Lmxlbmd0aDEgPSBwYXRjaC5sZW5ndGgxO1xuICAgIHBhdGNoQ29weS5sZW5ndGgyID0gcGF0Y2gubGVuZ3RoMjtcbiAgICBwYXRjaGVzQ29weVt4XSA9IHBhdGNoQ29weTtcbiAgfVxuICByZXR1cm4gcGF0Y2hlc0NvcHk7XG59XG5mdW5jdGlvbiBwYXRjaEFwcGx5KHBhdGNoZXMsIHRleHQsIG9wdGlvbnMpIHtcbiAgaWYgKHBhdGNoZXMubGVuZ3RoID09PSAwKVxuICAgIHJldHVybiBbdGV4dCwgW11dO1xuICBwYXRjaGVzID0gcGF0Y2hEZWVwQ29weShwYXRjaGVzKTtcbiAgY29uc3QgcmVzb2x2ZWQgPSByZXNvbHZlT3B0aW9ucyhvcHRpb25zKTtcbiAgY29uc3QgbnVsbFBhZGRpbmcgPSBwYXRjaEFkZFBhZGRpbmcocGF0Y2hlcywgcmVzb2x2ZWQpO1xuICB0ZXh0ID0gbnVsbFBhZGRpbmcgKyB0ZXh0ICsgbnVsbFBhZGRpbmc7XG4gIHBhdGNoU3BsaXRNYXgocGF0Y2hlcywgcmVzb2x2ZWQpO1xuICBsZXQgZGVsdGEgPSAwO1xuICBjb25zdCByZXN1bHRzID0gW107XG4gIGZvciAobGV0IHggPSAwOyB4IDwgcGF0Y2hlcy5sZW5ndGg7IHgrKykge1xuICAgIGNvbnN0IGV4cGVjdGVkX2xvYyA9IHBhdGNoZXNbeF0uc3RhcnQyICsgZGVsdGE7XG4gICAgY29uc3QgdGV4dDEgPSBkaWZmVGV4dDEocGF0Y2hlc1t4XS5kaWZmcyk7XG4gICAgbGV0IHN0YXJ0X2xvYztcbiAgICBsZXQgZW5kX2xvYyA9IC0xO1xuICAgIGlmICh0ZXh0MS5sZW5ndGggPiByZXNvbHZlZC5tYXRjaE1heEJpdHMpIHtcbiAgICAgIHN0YXJ0X2xvYyA9IG1hdGNoTWFpbihcbiAgICAgICAgdGV4dCxcbiAgICAgICAgdGV4dDEuc3Vic3RyaW5nKDAsIHJlc29sdmVkLm1hdGNoTWF4Qml0cyksXG4gICAgICAgIGV4cGVjdGVkX2xvYyxcbiAgICAgICAgb3B0aW9uc1xuICAgICAgKTtcbiAgICAgIGlmIChzdGFydF9sb2MgIT09IC0xKSB7XG4gICAgICAgIGVuZF9sb2MgPSBtYXRjaE1haW4oXG4gICAgICAgICAgdGV4dCxcbiAgICAgICAgICB0ZXh0MS5zdWJzdHJpbmcodGV4dDEubGVuZ3RoIC0gcmVzb2x2ZWQubWF0Y2hNYXhCaXRzKSxcbiAgICAgICAgICBleHBlY3RlZF9sb2MgKyB0ZXh0MS5sZW5ndGggLSByZXNvbHZlZC5tYXRjaE1heEJpdHMsXG4gICAgICAgICAgb3B0aW9uc1xuICAgICAgICApO1xuICAgICAgICBpZiAoZW5kX2xvYyA9PT0gLTEgfHwgc3RhcnRfbG9jID49IGVuZF9sb2MpIHtcbiAgICAgICAgICBzdGFydF9sb2MgPSAtMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdGFydF9sb2MgPSBtYXRjaE1haW4odGV4dCwgdGV4dDEsIGV4cGVjdGVkX2xvYywgb3B0aW9ucyk7XG4gICAgfVxuICAgIGlmIChzdGFydF9sb2MgPT09IC0xKSB7XG4gICAgICByZXN1bHRzW3hdID0gZmFsc2U7XG4gICAgICBkZWx0YSAtPSBwYXRjaGVzW3hdLmxlbmd0aDIgLSBwYXRjaGVzW3hdLmxlbmd0aDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdHNbeF0gPSB0cnVlO1xuICAgICAgZGVsdGEgPSBzdGFydF9sb2MgLSBleHBlY3RlZF9sb2M7XG4gICAgICBsZXQgdGV4dDI7XG4gICAgICBpZiAoZW5kX2xvYyA9PT0gLTEpXG4gICAgICAgIHRleHQyID0gdGV4dC5zdWJzdHJpbmcoc3RhcnRfbG9jLCBzdGFydF9sb2MgKyB0ZXh0MS5sZW5ndGgpO1xuICAgICAgZWxzZVxuICAgICAgICB0ZXh0MiA9IHRleHQuc3Vic3RyaW5nKHN0YXJ0X2xvYywgZW5kX2xvYyArIHJlc29sdmVkLm1hdGNoTWF4Qml0cyk7XG4gICAgICBpZiAodGV4dDEgPT09IHRleHQyKSB7XG4gICAgICAgIHRleHQgPSB0ZXh0LnN1YnN0cmluZygwLCBzdGFydF9sb2MpICsgZGlmZlRleHQyKHBhdGNoZXNbeF0uZGlmZnMpICsgdGV4dC5zdWJzdHJpbmcoc3RhcnRfbG9jICsgdGV4dDEubGVuZ3RoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGRpZmZzID0gZGlmZk1haW4odGV4dDEsIHRleHQyLCBvcHRpb25zLCBmYWxzZSk7XG4gICAgICAgIGlmICh0ZXh0MS5sZW5ndGggPiByZXNvbHZlZC5tYXRjaE1heEJpdHMgJiYgZGlmZkxldmVuc2h0ZWluKGRpZmZzKSAvIHRleHQxLmxlbmd0aCA+IHJlc29sdmVkLnBhdGNoRGVsZXRlVGhyZXNob2xkKSB7XG4gICAgICAgICAgcmVzdWx0c1t4XSA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRpZmZDbGVhbnVwU2VtYW50aWNMb3NzbGVzcyhkaWZmcyk7XG4gICAgICAgICAgbGV0IGluZGV4MSA9IDA7XG4gICAgICAgICAgbGV0IGluZGV4MiA9IDA7XG4gICAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCBwYXRjaGVzW3hdLmRpZmZzLmxlbmd0aDsgeSsrKSB7XG4gICAgICAgICAgICBjb25zdCBtb2QgPSBwYXRjaGVzW3hdLmRpZmZzW3ldO1xuICAgICAgICAgICAgaWYgKG1vZFswXSAhPT0gRElGRl9FUVVBTClcbiAgICAgICAgICAgICAgaW5kZXgyID0gZGlmZlhJbmRleChkaWZmcywgaW5kZXgxKTtcbiAgICAgICAgICAgIGlmIChtb2RbMF0gPT09IERJRkZfSU5TRVJUKSB7XG4gICAgICAgICAgICAgIHRleHQgPSB0ZXh0LnN1YnN0cmluZygwLCBzdGFydF9sb2MgKyBpbmRleDIpICsgbW9kWzFdICsgdGV4dC5zdWJzdHJpbmcoc3RhcnRfbG9jICsgaW5kZXgyKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobW9kWzBdID09PSBESUZGX0RFTEVURSkge1xuICAgICAgICAgICAgICB0ZXh0ID0gdGV4dC5zdWJzdHJpbmcoMCwgc3RhcnRfbG9jICsgaW5kZXgyKSArIHRleHQuc3Vic3RyaW5nKHN0YXJ0X2xvYyArIGRpZmZYSW5kZXgoZGlmZnMsIGluZGV4MSArIG1vZFsxXS5sZW5ndGgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtb2RbMF0gIT09IERJRkZfREVMRVRFKVxuICAgICAgICAgICAgICBpbmRleDEgKz0gbW9kWzFdLmxlbmd0aDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdGV4dCA9IHRleHQuc3Vic3RyaW5nKG51bGxQYWRkaW5nLmxlbmd0aCwgdGV4dC5sZW5ndGggLSBudWxsUGFkZGluZy5sZW5ndGgpO1xuICByZXR1cm4gW3RleHQsIHJlc3VsdHNdO1xufVxuZnVuY3Rpb24gcGF0Y2hBZGRQYWRkaW5nKHBhdGNoZXMsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgcGF0Y2hNYXJnaW46IHBhZGRpbmdMZW5ndGggPSBkZWZhdWx0T3B0aW9ucy5wYXRjaE1hcmdpblxuICB9ID0gb3B0aW9ucztcbiAgbGV0IG51bGxQYWRkaW5nID0gXCJcIjtcbiAgZm9yIChsZXQgeCA9IDE7IHggPD0gcGFkZGluZ0xlbmd0aDsgeCsrKVxuICAgIG51bGxQYWRkaW5nICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoeCk7XG4gIGZvciAobGV0IHggPSAwOyB4IDwgcGF0Y2hlcy5sZW5ndGg7IHgrKykge1xuICAgIHBhdGNoZXNbeF0uc3RhcnQxICs9IHBhZGRpbmdMZW5ndGg7XG4gICAgcGF0Y2hlc1t4XS5zdGFydDIgKz0gcGFkZGluZ0xlbmd0aDtcbiAgfVxuICBsZXQgcGF0Y2ggPSBwYXRjaGVzWzBdO1xuICBsZXQgZGlmZnMgPSBwYXRjaC5kaWZmcztcbiAgaWYgKGRpZmZzLmxlbmd0aCA9PT0gMCB8fCBkaWZmc1swXVswXSAhPT0gRElGRl9FUVVBTCkge1xuICAgIGRpZmZzLnVuc2hpZnQoY3JlYXRlRGlmZihESUZGX0VRVUFMLCBudWxsUGFkZGluZykpO1xuICAgIHBhdGNoLnN0YXJ0MSAtPSBwYWRkaW5nTGVuZ3RoO1xuICAgIHBhdGNoLnN0YXJ0MiAtPSBwYWRkaW5nTGVuZ3RoO1xuICAgIHBhdGNoLmxlbmd0aDEgKz0gcGFkZGluZ0xlbmd0aDtcbiAgICBwYXRjaC5sZW5ndGgyICs9IHBhZGRpbmdMZW5ndGg7XG4gIH0gZWxzZSBpZiAocGFkZGluZ0xlbmd0aCA+IGRpZmZzWzBdWzFdLmxlbmd0aCkge1xuICAgIGNvbnN0IGV4dHJhTGVuZ3RoID0gcGFkZGluZ0xlbmd0aCAtIGRpZmZzWzBdWzFdLmxlbmd0aDtcbiAgICBkaWZmc1swXVsxXSA9IG51bGxQYWRkaW5nLnN1YnN0cmluZyhkaWZmc1swXVsxXS5sZW5ndGgpICsgZGlmZnNbMF1bMV07XG4gICAgcGF0Y2guc3RhcnQxIC09IGV4dHJhTGVuZ3RoO1xuICAgIHBhdGNoLnN0YXJ0MiAtPSBleHRyYUxlbmd0aDtcbiAgICBwYXRjaC5sZW5ndGgxICs9IGV4dHJhTGVuZ3RoO1xuICAgIHBhdGNoLmxlbmd0aDIgKz0gZXh0cmFMZW5ndGg7XG4gIH1cbiAgcGF0Y2ggPSBwYXRjaGVzW3BhdGNoZXMubGVuZ3RoIC0gMV07XG4gIGRpZmZzID0gcGF0Y2guZGlmZnM7XG4gIGlmIChkaWZmcy5sZW5ndGggPT09IDAgfHwgZGlmZnNbZGlmZnMubGVuZ3RoIC0gMV1bMF0gIT09IERJRkZfRVFVQUwpIHtcbiAgICBkaWZmcy5wdXNoKGNyZWF0ZURpZmYoRElGRl9FUVVBTCwgbnVsbFBhZGRpbmcpKTtcbiAgICBwYXRjaC5sZW5ndGgxICs9IHBhZGRpbmdMZW5ndGg7XG4gICAgcGF0Y2gubGVuZ3RoMiArPSBwYWRkaW5nTGVuZ3RoO1xuICB9IGVsc2UgaWYgKHBhZGRpbmdMZW5ndGggPiBkaWZmc1tkaWZmcy5sZW5ndGggLSAxXVsxXS5sZW5ndGgpIHtcbiAgICBjb25zdCBleHRyYUxlbmd0aCA9IHBhZGRpbmdMZW5ndGggLSBkaWZmc1tkaWZmcy5sZW5ndGggLSAxXVsxXS5sZW5ndGg7XG4gICAgZGlmZnNbZGlmZnMubGVuZ3RoIC0gMV1bMV0gKz0gbnVsbFBhZGRpbmcuc3Vic3RyaW5nKDAsIGV4dHJhTGVuZ3RoKTtcbiAgICBwYXRjaC5sZW5ndGgxICs9IGV4dHJhTGVuZ3RoO1xuICAgIHBhdGNoLmxlbmd0aDIgKz0gZXh0cmFMZW5ndGg7XG4gIH1cbiAgcmV0dXJuIG51bGxQYWRkaW5nO1xufVxuZnVuY3Rpb24gcGF0Y2hTcGxpdE1heChwYXRjaGVzLCBvcHRpb25zKSB7XG4gIGNvbnN0IHJlc29sdmVkID0gcmVzb2x2ZU9wdGlvbnMob3B0aW9ucyk7XG4gIGZvciAobGV0IHggPSAwOyB4IDwgcGF0Y2hlcy5sZW5ndGg7IHgrKykge1xuICAgIGlmIChwYXRjaGVzW3hdLmxlbmd0aDEgPD0gcmVzb2x2ZWQubWF0Y2hNYXhCaXRzKVxuICAgICAgY29udGludWU7XG4gICAgY29uc3QgYmlncGF0Y2ggPSBwYXRjaGVzW3hdO1xuICAgIHBhdGNoZXMuc3BsaWNlKHgtLSwgMSk7XG4gICAgbGV0IHN0YXJ0MSA9IGJpZ3BhdGNoLnN0YXJ0MTtcbiAgICBsZXQgc3RhcnQyID0gYmlncGF0Y2guc3RhcnQyO1xuICAgIGxldCBwcmVjb250ZXh0ID0gXCJcIjtcbiAgICB3aGlsZSAoYmlncGF0Y2guZGlmZnMubGVuZ3RoICE9PSAwKSB7XG4gICAgICBjb25zdCBwYXRjaCA9IGNyZWF0ZVBhdGNoKCk7XG4gICAgICBsZXQgZW1wdHkgPSB0cnVlO1xuICAgICAgcGF0Y2guc3RhcnQxID0gc3RhcnQxIC0gcHJlY29udGV4dC5sZW5ndGg7XG4gICAgICBwYXRjaC5zdGFydDIgPSBzdGFydDIgLSBwcmVjb250ZXh0Lmxlbmd0aDtcbiAgICAgIGlmIChwcmVjb250ZXh0ICE9PSBcIlwiKSB7XG4gICAgICAgIHBhdGNoLmxlbmd0aDEgPSBwYXRjaC5sZW5ndGgyID0gcHJlY29udGV4dC5sZW5ndGg7XG4gICAgICAgIHBhdGNoLmRpZmZzLnB1c2goY3JlYXRlRGlmZihESUZGX0VRVUFMLCBwcmVjb250ZXh0KSk7XG4gICAgICB9XG4gICAgICB3aGlsZSAoYmlncGF0Y2guZGlmZnMubGVuZ3RoICE9PSAwICYmIHBhdGNoLmxlbmd0aDEgPCByZXNvbHZlZC5tYXRjaE1heEJpdHMgLSByZXNvbHZlZC5wYXRjaE1hcmdpbikge1xuICAgICAgICBjb25zdCBkaWZmX3R5cGUgPSBiaWdwYXRjaC5kaWZmc1swXVswXTtcbiAgICAgICAgbGV0IGRpZmZfdGV4dCA9IGJpZ3BhdGNoLmRpZmZzWzBdWzFdO1xuICAgICAgICBpZiAoZGlmZl90eXBlID09PSBESUZGX0lOU0VSVCkge1xuICAgICAgICAgIHBhdGNoLmxlbmd0aDIgKz0gZGlmZl90ZXh0Lmxlbmd0aDtcbiAgICAgICAgICBzdGFydDIgKz0gZGlmZl90ZXh0Lmxlbmd0aDtcbiAgICAgICAgICBwYXRjaC5kaWZmcy5wdXNoKGJpZ3BhdGNoLmRpZmZzLnNoaWZ0KCkpO1xuICAgICAgICAgIGVtcHR5ID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAoZGlmZl90eXBlID09PSBESUZGX0RFTEVURSAmJiBwYXRjaC5kaWZmcy5sZW5ndGggPT09IDEgJiYgcGF0Y2guZGlmZnNbMF1bMF0gPT09IERJRkZfRVFVQUwgJiYgZGlmZl90ZXh0Lmxlbmd0aCA+IDIgKiByZXNvbHZlZC5tYXRjaE1heEJpdHMpIHtcbiAgICAgICAgICBwYXRjaC5sZW5ndGgxICs9IGRpZmZfdGV4dC5sZW5ndGg7XG4gICAgICAgICAgc3RhcnQxICs9IGRpZmZfdGV4dC5sZW5ndGg7XG4gICAgICAgICAgZW1wdHkgPSBmYWxzZTtcbiAgICAgICAgICBwYXRjaC5kaWZmcy5wdXNoKGNyZWF0ZURpZmYoZGlmZl90eXBlLCBkaWZmX3RleHQpKTtcbiAgICAgICAgICBiaWdwYXRjaC5kaWZmcy5zaGlmdCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRpZmZfdGV4dCA9IGRpZmZfdGV4dC5zdWJzdHJpbmcoMCwgcmVzb2x2ZWQubWF0Y2hNYXhCaXRzIC0gcGF0Y2gubGVuZ3RoMSAtIHJlc29sdmVkLnBhdGNoTWFyZ2luKTtcbiAgICAgICAgICBwYXRjaC5sZW5ndGgxICs9IGRpZmZfdGV4dC5sZW5ndGg7XG4gICAgICAgICAgc3RhcnQxICs9IGRpZmZfdGV4dC5sZW5ndGg7XG4gICAgICAgICAgaWYgKGRpZmZfdHlwZSA9PT0gRElGRl9FUVVBTCkge1xuICAgICAgICAgICAgcGF0Y2gubGVuZ3RoMiArPSBkaWZmX3RleHQubGVuZ3RoO1xuICAgICAgICAgICAgc3RhcnQyICs9IGRpZmZfdGV4dC5sZW5ndGg7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVtcHR5ID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBhdGNoLmRpZmZzLnB1c2goY3JlYXRlRGlmZihkaWZmX3R5cGUsIGRpZmZfdGV4dCkpO1xuICAgICAgICAgIGlmIChkaWZmX3RleHQgPT09IGJpZ3BhdGNoLmRpZmZzWzBdWzFdKSB7XG4gICAgICAgICAgICBiaWdwYXRjaC5kaWZmcy5zaGlmdCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBiaWdwYXRjaC5kaWZmc1swXVsxXSA9IGJpZ3BhdGNoLmRpZmZzWzBdWzFdLnN1YnN0cmluZyhkaWZmX3RleHQubGVuZ3RoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHByZWNvbnRleHQgPSBkaWZmVGV4dDIocGF0Y2guZGlmZnMpO1xuICAgICAgcHJlY29udGV4dCA9IHByZWNvbnRleHQuc3Vic3RyaW5nKHByZWNvbnRleHQubGVuZ3RoIC0gcmVzb2x2ZWQucGF0Y2hNYXJnaW4pO1xuICAgICAgY29uc3QgcG9zdGNvbnRleHQgPSBkaWZmVGV4dDEoYmlncGF0Y2guZGlmZnMpLnN1YnN0cmluZygwLCByZXNvbHZlZC5wYXRjaE1hcmdpbik7XG4gICAgICBpZiAocG9zdGNvbnRleHQgIT09IFwiXCIpIHtcbiAgICAgICAgcGF0Y2gubGVuZ3RoMSArPSBwb3N0Y29udGV4dC5sZW5ndGg7XG4gICAgICAgIHBhdGNoLmxlbmd0aDIgKz0gcG9zdGNvbnRleHQubGVuZ3RoO1xuICAgICAgICBpZiAocGF0Y2guZGlmZnMubGVuZ3RoICE9PSAwICYmIHBhdGNoLmRpZmZzW3BhdGNoLmRpZmZzLmxlbmd0aCAtIDFdWzBdID09PSBESUZGX0VRVUFMKVxuICAgICAgICAgIHBhdGNoLmRpZmZzW3BhdGNoLmRpZmZzLmxlbmd0aCAtIDFdWzFdICs9IHBvc3Rjb250ZXh0O1xuICAgICAgICBlbHNlXG4gICAgICAgICAgcGF0Y2guZGlmZnMucHVzaChjcmVhdGVEaWZmKERJRkZfRVFVQUwsIHBvc3Rjb250ZXh0KSk7XG4gICAgICB9XG4gICAgICBpZiAoIWVtcHR5KVxuICAgICAgICBwYXRjaGVzLnNwbGljZSgrK3gsIDAsIHBhdGNoKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHBhdGNoVG9UZXh0KHBhdGNoZXMpIHtcbiAgY29uc3QgdGV4dCA9IFtdO1xuICBmb3IgKGxldCB4ID0gMDsgeCA8IHBhdGNoZXMubGVuZ3RoOyB4KyspXG4gICAgdGV4dFt4XSA9IHBhdGNoZXNbeF07XG4gIHJldHVybiB0ZXh0LmpvaW4oXCJcIik7XG59XG5mdW5jdGlvbiBwYXRjaEZyb21UZXh0KHRleHRsaW5lKSB7XG4gIGNvbnN0IHBhdGNoZXMgPSBbXTtcbiAgaWYgKCF0ZXh0bGluZSlcbiAgICByZXR1cm4gcGF0Y2hlcztcbiAgY29uc3QgdGV4dCA9IHRleHRsaW5lLnNwbGl0KFwiXFxuXCIpO1xuICBsZXQgdGV4dFBvaW50ZXIgPSAwO1xuICBjb25zdCBwYXRjaEhlYWRlciA9IC9eQEAgLShcXGQrKSw/KFxcZCopIFxcKyhcXGQrKSw/KFxcZCopIEBAJC87XG4gIHdoaWxlICh0ZXh0UG9pbnRlciA8IHRleHQubGVuZ3RoKSB7XG4gICAgY29uc3QgbSA9IHRleHRbdGV4dFBvaW50ZXJdLm1hdGNoKHBhdGNoSGVhZGVyKTtcbiAgICBpZiAoIW0pXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgcGF0Y2ggc3RyaW5nOiAke3RleHRbdGV4dFBvaW50ZXJdfWApO1xuICAgIGNvbnN0IHBhdGNoID0gY3JlYXRlUGF0Y2goKTtcbiAgICBwYXRjaGVzLnB1c2gocGF0Y2gpO1xuICAgIHBhdGNoLnN0YXJ0MSA9IE51bWJlci5wYXJzZUludChtWzFdLCAxMCk7XG4gICAgaWYgKG1bMl0gPT09IFwiXCIpIHtcbiAgICAgIHBhdGNoLnN0YXJ0MS0tO1xuICAgICAgcGF0Y2gubGVuZ3RoMSA9IDE7XG4gICAgfSBlbHNlIGlmIChtWzJdID09PSBcIjBcIikge1xuICAgICAgcGF0Y2gubGVuZ3RoMSA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhdGNoLnN0YXJ0MS0tO1xuICAgICAgcGF0Y2gubGVuZ3RoMSA9IE51bWJlci5wYXJzZUludChtWzJdLCAxMCk7XG4gICAgfVxuICAgIHBhdGNoLnN0YXJ0MiA9IE51bWJlci5wYXJzZUludChtWzNdLCAxMCk7XG4gICAgaWYgKG1bNF0gPT09IFwiXCIpIHtcbiAgICAgIHBhdGNoLnN0YXJ0Mi0tO1xuICAgICAgcGF0Y2gubGVuZ3RoMiA9IDE7XG4gICAgfSBlbHNlIGlmIChtWzRdID09PSBcIjBcIikge1xuICAgICAgcGF0Y2gubGVuZ3RoMiA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhdGNoLnN0YXJ0Mi0tO1xuICAgICAgcGF0Y2gubGVuZ3RoMiA9IE51bWJlci5wYXJzZUludChtWzRdLCAxMCk7XG4gICAgfVxuICAgIHRleHRQb2ludGVyKys7XG4gICAgd2hpbGUgKHRleHRQb2ludGVyIDwgdGV4dC5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IHNpZ24gPSB0ZXh0W3RleHRQb2ludGVyXS5jaGFyQXQoMCk7XG4gICAgICBsZXQgbGluZSA9IFwiXCI7XG4gICAgICB0cnkge1xuICAgICAgICBsaW5lID0gZGVjb2RlVVJJKHRleHRbdGV4dFBvaW50ZXJdLnN1YnN0cmluZygxKSk7XG4gICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYElsbGVnYWwgZXNjYXBlIGluIHBhdGNoX2Zyb21UZXh0OiAke2xpbmV9YCk7XG4gICAgICB9XG4gICAgICBpZiAoc2lnbiA9PT0gXCItXCIpIHtcbiAgICAgICAgcGF0Y2guZGlmZnMucHVzaChjcmVhdGVEaWZmKERJRkZfREVMRVRFLCBsaW5lKSk7XG4gICAgICB9IGVsc2UgaWYgKHNpZ24gPT09IFwiK1wiKSB7XG4gICAgICAgIHBhdGNoLmRpZmZzLnB1c2goY3JlYXRlRGlmZihESUZGX0lOU0VSVCwgbGluZSkpO1xuICAgICAgfSBlbHNlIGlmIChzaWduID09PSBcIiBcIikge1xuICAgICAgICBwYXRjaC5kaWZmcy5wdXNoKGNyZWF0ZURpZmYoRElGRl9FUVVBTCwgbGluZSkpO1xuICAgICAgfSBlbHNlIGlmIChzaWduID09PSBcIkBcIikge1xuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSBpZiAoc2lnbiA9PT0gXCJcIikgOyBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHBhdGNoIG1vZGUgXCIke3NpZ259XCIgaW46ICR7bGluZX1gKTtcbiAgICAgIH1cbiAgICAgIHRleHRQb2ludGVyKys7XG4gICAgfVxuICB9XG4gIHJldHVybiBwYXRjaGVzO1xufVxuZnVuY3Rpb24gY3JlYXRlUGF0Y2goKSB7XG4gIGNvbnN0IHBhdGNoID0ge1xuICAgIGRpZmZzOiBbXSxcbiAgICBzdGFydDE6IG51bGwsXG4gICAgc3RhcnQyOiBudWxsLFxuICAgIGxlbmd0aDE6IDAsXG4gICAgbGVuZ3RoMjogMFxuICB9O1xuICBwYXRjaC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIGxldCBjb29yZHMxLCBjb29yZHMyO1xuICAgIGlmICh0aGlzLmxlbmd0aDEgPT09IDApXG4gICAgICBjb29yZHMxID0gYCR7dGhpcy5zdGFydDF9LDBgO1xuICAgIGVsc2UgaWYgKHRoaXMubGVuZ3RoMSA9PT0gMSlcbiAgICAgIGNvb3JkczEgPSB0aGlzLnN0YXJ0MSArIDE7XG4gICAgZWxzZVxuICAgICAgY29vcmRzMSA9IGAke3RoaXMuc3RhcnQxICsgMX0sJHt0aGlzLmxlbmd0aDF9YDtcbiAgICBpZiAodGhpcy5sZW5ndGgyID09PSAwKVxuICAgICAgY29vcmRzMiA9IGAke3RoaXMuc3RhcnQyfSwwYDtcbiAgICBlbHNlIGlmICh0aGlzLmxlbmd0aDIgPT09IDEpXG4gICAgICBjb29yZHMyID0gdGhpcy5zdGFydDIgKyAxO1xuICAgIGVsc2VcbiAgICAgIGNvb3JkczIgPSBgJHt0aGlzLnN0YXJ0MiArIDF9LCR7dGhpcy5sZW5ndGgyfWA7XG4gICAgY29uc3QgdGV4dCA9IFtgQEAgLSR7Y29vcmRzMX0gKyR7Y29vcmRzMn0gQEBcbmBdO1xuICAgIGxldCBvcDtcbiAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHRoaXMuZGlmZnMubGVuZ3RoOyB4KyspIHtcbiAgICAgIHN3aXRjaCAodGhpcy5kaWZmc1t4XVswXSkge1xuICAgICAgICBjYXNlIERJRkZfSU5TRVJUOlxuICAgICAgICAgIG9wID0gXCIrXCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgRElGRl9ERUxFVEU6XG4gICAgICAgICAgb3AgPSBcIi1cIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBESUZGX0VRVUFMOlxuICAgICAgICAgIG9wID0gXCIgXCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICB0ZXh0W3ggKyAxXSA9IGAke29wICsgZW5jb2RlVVJJKHRoaXMuZGlmZnNbeF1bMV0pfVxuYDtcbiAgICB9XG4gICAgcmV0dXJuIHRleHQuam9pbihcIlwiKS5yZXBsYWNlKC8lMjAvZywgXCIgXCIpO1xuICB9O1xuICByZXR1cm4gcGF0Y2g7XG59XG5cbmV4cG9ydCB7IERJRkZfREVMRVRFLCBESUZGX0VRVUFMLCBESUZGX0lOU0VSVCwgZGVmYXVsdE9wdGlvbnMsIGRpZmZNYWluIGFzIGRpZmYsIGRpZmZDbGVhbnVwRWZmaWNpZW5jeSwgZGlmZkNsZWFudXBNZXJnZSwgZGlmZkNsZWFudXBTZW1hbnRpYywgZGlmZkNsZWFudXBTZW1hbnRpY0xvc3NsZXNzLCBkaWZmQ29tbW9uUHJlZml4LCBkaWZmQ29tbW9uU3VmZml4LCBkaWZmRnJvbURlbHRhLCBkaWZmTGV2ZW5zaHRlaW4sIGRpZmZNYWluLCBkaWZmUHJldHR5SHRtbCwgZGlmZlRleHQxLCBkaWZmVGV4dDIsIGRpZmZUb0RlbHRhLCBkaWZmWEluZGV4LCBtYXRjaE1haW4gYXMgbWF0Y2gsIG1hdGNoQWxwaGFiZXQsIG1hdGNoQml0YXAsIG1hdGNoTWFpbiwgcGF0Y2hNYWtlIGFzIHBhdGNoLCBwYXRjaEFkZFBhZGRpbmcsIHBhdGNoQXBwbHksIHBhdGNoRGVlcENvcHksIHBhdGNoRnJvbVRleHQsIHBhdGNoTWFrZSwgcGF0Y2hTcGxpdE1heCwgcGF0Y2hUb1RleHQsIHJlc29sdmVPcHRpb25zIH07XG4iLCAiaW1wb3J0ICogYXMgdGltZSBmcm9tICdsaWIwL3RpbWUnXG5pbXBvcnQgeyBPYnNlcnZhYmxlVjIgfSBmcm9tICdsaWIwL29ic2VydmFibGUnXG5pbXBvcnQgKiBhcyBtYXRoIGZyb20gJ2xpYjAvbWF0aCdcbmltcG9ydCB7IFNoYXJlZERvY3VtZW50IH0gZnJvbSAnLi9zaGFyZWRFbnRpdGllcy9zaGFyZWREb2N1bWVudCdcbmltcG9ydCB7IFNoYXJlZEZvbGRlciB9IGZyb20gJy4vc2hhcmVkRW50aXRpZXMvc2hhcmVkRm9sZGVyJ1xuXG50eXBlIENsaWVudE1lc3NhZ2UgPSB7XG4gIHR5cGU6IFwiYWRkXCIgfCBcInJlbW92ZVwiIHwgXCJmdWxsXCIsXG4gIGRvY3M6IEFycmF5PHN0cmluZz5cbn1cblxudHlwZSBTZXJ2ZXJNZXNzYWdlID0ge1xuICB0eXBlOiBcImFkZFwiIHwgXCJmdWxsXCIsXG4gIGRvY3M6IEFycmF5PHN0cmluZz5cbn1cblxudHlwZSBFdmVudHMgPSB7XG4gIFwiY29ubmVjdGlvbi1lcnJvclwiOiAoZXZlbnQ6IEV2ZW50LCBjbGllbnQ6IEFjdGl2ZVN0cmVhbUNsaWVudCkgPT4gdm9pZCxcbiAgXCJjb25uZWN0aW9uLWNsb3NlXCI6IChldmVudDogRXZlbnQsIGNsaWVudDogQWN0aXZlU3RyZWFtQ2xpZW50KSA9PiB2b2lkLFxuICBzdGF0dXM6IChzdGF0dXM6IHsgc3RhdHVzOiBzdHJpbmcgfSkgPT4gdm9pZFxufVxuXG5jb25zdCBtZXNzYWdlUmVjb25uZWN0VGltZW91dCA9IDMwMDAwXG5cbmNvbnN0IGhhbmRsZU1lc3NhZ2UgPSAoZGF0YTogc3RyaW5nKSA9PiB7XG4gIGNvbnN0IG1lc3NhZ2UgPSBKU09OLnBhcnNlKGRhdGEpIGFzIFNlcnZlck1lc3NhZ2VcbiAgZm9yIChjb25zdCBpZCBvZiBtZXNzYWdlLmRvY3MpIHtcbiAgICBTaGFyZWREb2N1bWVudC5maW5kQnlJZChpZCk/LnN0YXJ0V2ViUlRDU3luYygpXG4gICAgU2hhcmVkRm9sZGVyLmZpbmRCeUlkKGlkKT8uc3RhcnRXZWJSVENTeW5jKClcbiAgfVxufVxuXG5jb25zdCBzZXR1cFdTID0gKGNsaWVudDogQWN0aXZlU3RyZWFtQ2xpZW50KSA9PiB7XG4gIGlmIChjbGllbnQuc2hvdWxkQ29ubmVjdCAmJiBjbGllbnQud3MgPT09IG51bGwpIHtcbiAgICBjb25zdCB3ZWJzb2NrZXQgPSBuZXcgV2ViU29ja2V0KGNsaWVudC51cmwpXG4gICAgY2xpZW50LndzID0gd2Vic29ja2V0XG4gICAgY2xpZW50LndzY29ubmVjdGluZyA9IHRydWVcbiAgICBjbGllbnQud3Njb25uZWN0ZWQgPSBmYWxzZVxuXG4gICAgd2Vic29ja2V0Lm9ubWVzc2FnZSA9IChldmVudCkgPT4ge1xuICAgICAgY2xpZW50LndzTGFzdE1lc3NhZ2VSZWNlaXZlZCA9IHRpbWUuZ2V0VW5peFRpbWUoKVxuICAgICAgaGFuZGxlTWVzc2FnZShldmVudC5kYXRhKVxuICAgIH1cblxuICAgIHdlYnNvY2tldC5vbmVycm9yID0gKGV2ZW50KSA9PiB7XG4gICAgICBjbGllbnQuZW1pdCgnY29ubmVjdGlvbi1lcnJvcicsIFtldmVudCwgY2xpZW50XSlcbiAgICB9XG5cbiAgICB3ZWJzb2NrZXQub25jbG9zZSA9IChldmVudCkgPT4ge1xuICAgICAgY2xpZW50LmVtaXQoJ2Nvbm5lY3Rpb24tY2xvc2UnLCBbZXZlbnQsIGNsaWVudF0pXG4gICAgICBjbGllbnQud3MgPSBudWxsXG4gICAgICBjbGllbnQud3Njb25uZWN0aW5nID0gZmFsc2VcbiAgICAgIGlmIChjbGllbnQud3Njb25uZWN0ZWQpIHtcbiAgICAgICAgY2xpZW50LndzY29ubmVjdGVkID0gZmFsc2VcblxuICAgICAgICBjbGllbnQuZW1pdCgnc3RhdHVzJywgW3tcbiAgICAgICAgICBzdGF0dXM6ICdkaXNjb25uZWN0ZWQnXG4gICAgICAgIH1dKVxuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjbGllbnQud3NVbnN1Y2Nlc3NmdWxSZWNvbm5lY3RzKytcbiAgICAgIH1cbiAgICAgIC8vIFN0YXJ0IHdpdGggbm8gcmVjb25uZWN0IHRpbWVvdXQgYW5kIGluY3JlYXNlIHRpbWVvdXQgYnlcbiAgICAgIC8vIHVzaW5nIGV4cG9uZW50aWFsIGJhY2tvZmYgc3RhcnRpbmcgd2l0aCAxMDBtc1xuICAgICAgc2V0VGltZW91dChcbiAgICAgICAgc2V0dXBXUyxcbiAgICAgICAgbWF0aC5taW4oXG4gICAgICAgICAgbWF0aC5wb3coMiwgY2xpZW50LndzVW5zdWNjZXNzZnVsUmVjb25uZWN0cykgKiAxMDAsXG4gICAgICAgICAgY2xpZW50Lm1heEJhY2tvZmZUaW1lXG4gICAgICAgICksXG4gICAgICAgIGNsaWVudFxuICAgICAgKVxuICAgIH1cbiAgICB3ZWJzb2NrZXQub25vcGVuID0gKCkgPT4ge1xuICAgICAgY2xpZW50LndzTGFzdE1lc3NhZ2VSZWNlaXZlZCA9IHRpbWUuZ2V0VW5peFRpbWUoKVxuICAgICAgY2xpZW50LndzY29ubmVjdGluZyA9IGZhbHNlXG4gICAgICBjbGllbnQud3Njb25uZWN0ZWQgPSB0cnVlXG4gICAgICBjbGllbnQud3NVbnN1Y2Nlc3NmdWxSZWNvbm5lY3RzID0gMFxuICAgICAgY2xpZW50LmVtaXQoJ3N0YXR1cycsIFt7XG4gICAgICAgIHN0YXR1czogJ2Nvbm5lY3RlZCdcbiAgICAgIH1dKVxuXG4gICAgICBjbGllbnQuc2VuZChKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgIHR5cGU6IFwiZnVsbFwiLFxuICAgICAgICBkb2NzOiBBcnJheS5mcm9tKGNsaWVudC5kb2NJZHMpXG4gICAgICB9IHNhdGlzZmllcyBDbGllbnRNZXNzYWdlKSlcblxuICAgIH1cbiAgICBjbGllbnQuZW1pdCgnc3RhdHVzJywgW3tcbiAgICAgIHN0YXR1czogJ2Nvbm5lY3RpbmcnXG4gICAgfV0pXG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEFjdGl2ZVN0cmVhbUNsaWVudCBleHRlbmRzIE9ic2VydmFibGVWMjxFdmVudHM+IHtcblxuICBtYXhCYWNrb2ZmVGltZTogbnVtYmVyXG4gIHVybDogc3RyaW5nXG4gIHdzY29ubmVjdGVkOiBib29sZWFuXG4gIHdzY29ubmVjdGluZzogYm9vbGVhblxuICB3c1Vuc3VjY2Vzc2Z1bFJlY29ubmVjdHM6IG51bWJlclxuICB3czogV2ViU29ja2V0IHwgbnVsbFxuICB3c0xhc3RNZXNzYWdlUmVjZWl2ZWQ6IG51bWJlclxuICBzaG91bGRDb25uZWN0OiBib29sZWFuXG4gIF9yZXN5bmNJbnRlcnZhbDogbnVtYmVyXG5cbiAgZG9jSWRzOiBTZXQ8c3RyaW5nPlxuXG4gIGNvbnN0cnVjdG9yKHVybDogc3RyaW5nLCBvcHRzOiB7XG4gICAgY29ubmVjdDogYm9vbGVhbixcbiAgICByZXN5bmNJbnRlcnZhbDogbnVtYmVyLFxuICAgIG1heEJhY2tvZmZUaW1lOiBudW1iZXIsXG4gIH0gPSB7XG4gICAgICBjb25uZWN0OiB0cnVlLFxuICAgICAgcmVzeW5jSW50ZXJ2YWw6IC0xLFxuICAgICAgbWF4QmFja29mZlRpbWU6IDI1MDBcbiAgICB9KSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMubWF4QmFja29mZlRpbWUgPSBvcHRzLm1heEJhY2tvZmZUaW1lXG4gICAgdGhpcy51cmwgPSB1cmxcblxuICAgIHRoaXMud3Njb25uZWN0ZWQgPSBmYWxzZVxuICAgIHRoaXMud3Njb25uZWN0aW5nID0gZmFsc2VcbiAgICB0aGlzLndzVW5zdWNjZXNzZnVsUmVjb25uZWN0cyA9IDBcblxuICAgIHRoaXMud3MgPSBudWxsXG4gICAgdGhpcy53c0xhc3RNZXNzYWdlUmVjZWl2ZWQgPSAwXG4gICAgdGhpcy5zaG91bGRDb25uZWN0ID0gb3B0cy5jb25uZWN0XG4gICAgdGhpcy5fcmVzeW5jSW50ZXJ2YWwgPSAwXG5cbiAgICB0aGlzLmRvY0lkcyA9IG5ldyBTZXQ8c3RyaW5nPigpXG5cbiAgICBpZiAob3B0cy5yZXN5bmNJbnRlcnZhbCA+IDApIHtcbiAgICAgIHRoaXMuX3Jlc3luY0ludGVydmFsID0gKHdpbmRvdy5zZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLndzICYmIHRoaXMud3MucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0Lk9QRU4pIHtcbiAgICAgICAgICB0aGlzLnNlbmQoSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgdHlwZTogXCJmdWxsXCIsXG4gICAgICAgICAgICBkb2NzOiBBcnJheS5mcm9tKHRoaXMuZG9jSWRzKVxuICAgICAgICAgIH0gc2F0aXNmaWVzIENsaWVudE1lc3NhZ2UpKVxuICAgICAgICB9XG4gICAgICB9LCBvcHRzLnJlc3luY0ludGVydmFsKSlcbiAgICB9XG5cbiAgICBpZiAob3B0cy5jb25uZWN0KSB7XG4gICAgICB0aGlzLmNvbm5lY3QoKVxuICAgIH1cbiAgfVxuXG4gIHNlbmQoZGF0YTogc3RyaW5nKSB7XG4gICAgaWYgKHRoaXMud3MgJiYgdGhpcy53cy5yZWFkeVN0YXRlICE9PSB0aGlzLndzLkNPTk5FQ1RJTkcgJiYgdGhpcy53cy5yZWFkeVN0YXRlICE9PSB0aGlzLndzLk9QRU4pIHtcbiAgICAgIHRoaXMud3MuY2xvc2UoKVxuICAgIH1cbiAgICB0cnkge1xuICAgICAgdGhpcy53cz8uc2VuZChkYXRhKVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRoaXMud3M/LmNsb3NlKClcbiAgICB9XG4gIH1cblxuXG4gIGRlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMuX3Jlc3luY0ludGVydmFsICE9PSAwKSB7XG4gICAgICBjbGVhckludGVydmFsKHRoaXMuX3Jlc3luY0ludGVydmFsKVxuICAgIH1cbiAgICB0aGlzLmRpc2Nvbm5lY3QoKVxuICAgIHN1cGVyLmRlc3Ryb3koKVxuICB9XG5cbiAgZGlzY29ubmVjdCgpIHtcbiAgICB0aGlzLnNob3VsZENvbm5lY3QgPSBmYWxzZVxuICAgIGlmICh0aGlzLndzICE9PSBudWxsKSB7XG4gICAgICB0aGlzLndzLmNsb3NlKClcbiAgICB9XG4gIH1cblxuICBjb25uZWN0KCkge1xuICAgIHRoaXMuc2hvdWxkQ29ubmVjdCA9IHRydWVcbiAgICBpZiAoIXRoaXMud3Njb25uZWN0ZWQgJiYgdGhpcy53cyA9PT0gbnVsbCkge1xuICAgICAgc2V0dXBXUyh0aGlzKVxuICAgIH1cbiAgfVxuXG4gIGFkZChpZHM6IEFycmF5PHN0cmluZz4pIHtcbiAgICBmb3IgKGNvbnN0IGlkIG9mIGlkcykge1xuICAgICAgdGhpcy5kb2NJZHMuYWRkKGlkKVxuICAgIH1cbiAgICB0aGlzLnNlbmQoSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgdHlwZTogXCJhZGRcIixcbiAgICAgIGRvY3M6IGlkc1xuICAgIH0gc2F0aXNmaWVzIENsaWVudE1lc3NhZ2UpKVxuICB9XG5cbiAgcmVtb3ZlKGlkczogQXJyYXk8c3RyaW5nPikge1xuICAgIGZvciAoY29uc3QgaWQgb2YgaWRzKSB7XG4gICAgICB0aGlzLmRvY0lkcy5kZWxldGUoaWQpXG4gICAgfVxuICAgIHRoaXMuc2VuZChKU09OLnN0cmluZ2lmeSh7XG4gICAgICB0eXBlOiBcInJlbW92ZVwiLFxuICAgICAgZG9jczogaWRzXG4gICAgfSBzYXRpc2ZpZXMgQ2xpZW50TWVzc2FnZSkpXG4gIH1cbn1cbiIsICJpbXBvcnQgeyBQbGF0Zm9ybSwgUGx1Z2luIH0gZnJvbSBcIm9ic2lkaWFuXCI7XG5pbXBvcnQgeyBnZXRTZXR0aW5ncywgc2F2ZVNldHRpbmdzIH0gZnJvbSBcIi4vc2V0dGluZ3NcIjtcbmltcG9ydCB7IHNlc3Npb24gfSBmcm9tICdAZWxlY3Ryb24vcmVtb3RlJztcbmltcG9ydCBQZWVyZHJhZnRQbHVnaW4gZnJvbSBcIi4vbWFpblwiO1xuXG5leHBvcnQgY29uc3QgcHJlcGFyZUNvbW11bmljYXRpb24gPSBhc3luYyAocGx1Z2luOiBQZWVyZHJhZnRQbHVnaW4pID0+IHtcblxuICBpZiAoUGxhdGZvcm0uaXNEZXNrdG9wQXBwKSB7ICAgIFxuICAgIGF3YWl0IHNlc3Npb24uZGVmYXVsdFNlc3Npb24uY29va2llcy5zZXQoeyB1cmw6IFwiaHR0cHM6Ly93d3cucGVlcmRyYWZ0LmFwcFwiLCBcIm5hbWVcIjogXCJvaWRcIiwgXCJ2YWx1ZVwiOiBwbHVnaW4uc2V0dGluZ3Mub2lkLCBcImRvbWFpblwiOiBcInd3dy5wZWVyZHJhZnQuYXBwXCIsIFwicGF0aFwiOiBcIi9cIiwgXCJzZWN1cmVcIjogdHJ1ZSwgXCJodHRwT25seVwiOiB0cnVlLCBcInNhbWVTaXRlXCI6IFwibm9fcmVzdHJpY3Rpb25cIiB9KVxuICAgIGF3YWl0IHNlc3Npb24uZGVmYXVsdFNlc3Npb24uY29va2llcy5zZXQoeyB1cmw6IFwiaHR0cDovL2xvY2FsaG9zdDo1MTczXCIsIFwibmFtZVwiOiBcIm9pZFwiLCBcInZhbHVlXCI6IHBsdWdpbi5zZXR0aW5ncy5vaWQsIFwiZG9tYWluXCI6IFwibG9jYWxob3N0XCIsIFwicGF0aFwiOiBcIi9cIiwgXCJzZWN1cmVcIjogdHJ1ZSwgXCJodHRwT25seVwiOiB0cnVlLCBcInNhbWVTaXRlXCI6IFwibm9fcmVzdHJpY3Rpb25cIiB9KVxuICB9XG4gIGVsc2UgaWYgKFBsYXRmb3JtLmlzTW9iaWxlQXBwKSB7XG4gICAgY29uc3Qgc2lnbmFsaW5nVVJMID0gbmV3IFVSTChwbHVnaW4uc2V0dGluZ3Muc2lnbmFsaW5nKVxuICAgIHNpZ25hbGluZ1VSTC5zZWFyY2hQYXJhbXMuYXBwZW5kKCdvaWQnLCBwbHVnaW4uc2V0dGluZ3Mub2lkKVxuICAgIHBsdWdpbi5zZXR0aW5ncy5zaWduYWxpbmcgPSBzaWduYWxpbmdVUkwudG9TdHJpbmcoKVxuICB9XG59IiwgImltcG9ydCB7IHJlcXVlc3RVcmwgfSBmcm9tIFwib2JzaWRpYW5cIlxuaW1wb3J0IHsgc2hvd05vdGljZSB9IGZyb20gXCIuL3VpXCJcblxuZXhwb3J0IGNsYXNzIFNlcnZlckFQSSB7XG5cblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIG9wdHM6IHtcbiAgICAgIG9pZDogc3RyaW5nLFxuICAgICAgcGVybWFuZW50U2Vzc2lvblVybDogc3RyaW5nXG4gICAgfVxuICApe31cblxuICBhc3luYyBjcmVhdGVQZXJtYW5lbnRTZXNzaW9uICgpIHtcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVxdWVzdFVybCh7XG4gICAgICB1cmw6IHRoaXMub3B0cy5wZXJtYW5lbnRTZXNzaW9uVXJsLFxuICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICBjb250ZW50VHlwZTogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgIG9pZDogdGhpcy5vcHRzLm9pZFxuICAgICAgfSlcbiAgICB9KS5qc29uXG4gIFxuICAgIGlmICghZGF0YSB8fCAhZGF0YS5pZCkge1xuICAgICAgc2hvd05vdGljZShcIkVycm9yIGNyZWF0aW5nIHNoYXJlZCBmaWxlXCIpXG4gICAgICByZXR1cm4gXG4gICAgfVxuICAgIHJldHVybiBkYXRhIGFzIHtpZDogc3RyaW5nfVxuICB9XG5cbiAgYXN5bmMgaXNTZXNzaW9uUGVybWFuZW50IChpZDogc3RyaW5nKSB7XG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlcXVlc3RVcmwoe1xuICAgICAgdXJsOiB0aGlzLm9wdHMucGVybWFuZW50U2Vzc2lvblVybCArIFwiL1wiICsgaWQsXG4gICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgY29udGVudFR5cGU6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgIH0pLmpzb25cbiAgXG4gICAgaWYgKCFkYXRhKSB7XG4gICAgICBzaG93Tm90aWNlKFwiRXJyb3IgY3JlYXRpbmcgc2hhcmVkIGZpbGVcIilcbiAgICAgIHJldHVybiBcbiAgICB9XG4gICAgcmV0dXJuICEhZGF0YS5wZXJtYW5lbnRcbiAgfVxufVxuIiwgImltcG9ydCBQZWVyZHJhZnRQbHVnaW4gZnJvbSBcInNyYy9wZWVyZHJhZnRQbHVnaW5cIjtcbmltcG9ydCB7IFNoYXJlZEVudGl0eSB9IGZyb20gXCIuL3NoYXJlZEVudGl0eVwiO1xuaW1wb3J0IHsgU2hhcmVkRG9jdW1lbnQgfSBmcm9tIFwiLi9zaGFyZWREb2N1bWVudFwiO1xuaW1wb3J0IHsgU2hhcmVkRm9sZGVyIH0gZnJvbSBcIi4vc2hhcmVkRm9sZGVyXCI7XG5cbmV4cG9ydCBjb25zdCBmcm9tU2hhcmVVUkwgPSBhc3luYyAodXJsOiBzdHJpbmcsIHBsdWdpbjogUGVlcmRyYWZ0UGx1Z2luKTogUHJvbWlzZTxTaGFyZWRFbnRpdHkgfCB2b2lkPiA9PiB7XG4gIGNvbnN0IHNwbGl0dGVkVXJsID0gdXJsLnNwbGl0KCcvJylcbiAgaWYgKHNwbGl0dGVkVXJsPy5jb250YWlucygnY20nKSkge1xuICAgIHJldHVybiBTaGFyZWREb2N1bWVudC5mcm9tU2hhcmVVUkwodXJsLCBwbHVnaW4pXG4gIH1cbiAgaWYgKHNwbGl0dGVkVXJsPy5jb250YWlucygndGVhbScpKSB7XG4gICAgcmV0dXJuIFNoYXJlZEZvbGRlci5mcm9tU2hhcmVVUkwodXJsLCBwbHVnaW4pXG4gIH1cbn0iLCAiXG5pbXBvcnQgeyBBcHAsIE1vZGFsLCBTZXR0aW5nIH0gZnJvbSBcIm9ic2lkaWFuXCJcblxuY2xhc3MgQ2hvb3NlU2Vzc2lvblR5cGVNb2RhbCBleHRlbmRzIE1vZGFsIHtcblxuICBjYjogKHJlc3VsdDoge3Blcm1hbmVudDogYm9vbGVhbn0pID0+IGFueVxuXG4gIGNvbnN0cnVjdG9yKGFwcDogQXBwLCBjYjogKHJlc3VsdDoge3Blcm1hbmVudDogYm9vbGVhbn0pID0+IGFueSkge1xuICAgIHN1cGVyKGFwcClcbiAgICB0aGlzLmNiID0gY2JcbiAgfVxuXG4gIGFzeW5jIG9uT3BlbigpIHtcbiAgICBuZXcgU2V0dGluZyh0aGlzLmNvbnRlbnRFbCkuc2V0TmFtZShcIlN0YXJ0IHdvcmtpbmcgdG9nZXRoZXJcIikuc2V0SGVhZGluZygpXG5cbiAgICBuZXcgU2V0dGluZyh0aGlzLmNvbnRlbnRFbCkuYWRkQnV0dG9uKGJ1dHRvbiA9PiB7XG4gICAgICBidXR0b24uc2V0QnV0dG9uVGV4dChcIlN0YXJ0IGZsZWV0aW5nIHNlc3Npb25cIilcbiAgICAgIGJ1dHRvbi5zZXRDdGEoKVxuICAgICAgYnV0dG9uLm9uQ2xpY2soKCkgPT4ge1xuICAgICAgICB0aGlzLmNsb3NlKClcbiAgICAgICAgdGhpcy5jYih7XG4gICAgICAgICAgcGVybWFuZW50OiBmYWxzZVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9KS5zZXREZXNjKFwiQSBmbGVldGluZyBzZXNzaW9uIGF1dG9tYXRpY2FsbHkgY2xvc2VzIHdoZW4geW91IGNsb3NlIHRoZSBkb2N1bWVudCBvciBkaXNjb25uZWN0LlwiKVxuXG4gICAgbmV3IFNldHRpbmcodGhpcy5jb250ZW50RWwpLmFkZEJ1dHRvbihidXR0b24gPT4ge1xuICAgICAgYnV0dG9uLnNldEJ1dHRvblRleHQoXCJTaGFyZSBwZXJtYW5lbnRseVwiKVxuICAgICAgYnV0dG9uLnNldEN0YSgpXG4gICAgICBidXR0b24ub25DbGljaygoKSA9PiB7XG4gICAgICAgIHRoaXMuY2xvc2UoKVxuICAgICAgICB0aGlzLmNiKHtcbiAgICAgICAgICBwZXJtYW5lbnQ6IHRydWVcbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgfSkuc2V0RGVzYyhcIlRoZSBkb2N1bWVudCB3aWxsIGJlIHNoYXJlZCBwZXJtYW5lbnRseSB1bnRpbCB5b3UgZXhwbGljaXRlbHkgc3RvcCBzaGFyaW5nLiBUaGlzIGlzIHBlcnNpc3RlZCBldmVuIGlmIHlvdSBkaXNjb25uZWN0IG9yIGNsb3NlIE9ic2lkaWFuLlwiKVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBwcm9tcHRGb3JTZXNzaW9uVHlwZSA9IChhcHA6IEFwcCkgPT4ge1xuICByZXR1cm4gbmV3IFByb21pc2U8e3Blcm1hbmVudDogYm9vbGVhbn0gfCB2b2lkPigocmVzb2x2ZSkgPT4ge1xuICAgIG5ldyBDaG9vc2VTZXNzaW9uVHlwZU1vZGFsKGFwcCwgKHJlc3VsdCkgPT4ge1xuICAgICAgcmVzb2x2ZShyZXN1bHQpXG4gICAgfSkub3BlbigpXG4gIH0pXG59IiwgIlxuaW1wb3J0IHsgQXBwLCBNb2RhbCwgU2V0dGluZyB9IGZyb20gXCJvYnNpZGlhblwiXG5cbnR5cGUgT1BUUyA9IHtcbiAgaGVhZGVyOiBzdHJpbmcsXG4gIGRlc2NyaXB0aW9uOiBzdHJpbmcsXG4gIGluaXRpYWw6IFJFU1VMVFxufVxuXG50eXBlIFJFU1VMVCA9IHtcbiAgdGV4dDogc3RyaW5nXG59XG5cbmNsYXNzIEVudGVyVGV4dE1vZGFsIGV4dGVuZHMgTW9kYWwge1xuXG4gIGNiOiAocmVzdWx0OiB7IHRleHQ6IHN0cmluZyB9KSA9PiBhbnlcbiAgb3B0czogT1BUU1xuICByZXN1bHQ6IFJFU1VMVFxuXG4gIGNvbnN0cnVjdG9yKGFwcDogQXBwLCBvcHRzOiBPUFRTLCBjYjogKHJlc3VsdDogUkVTVUxUKSA9PiBhbnkpIHtcbiAgICBzdXBlcihhcHApXG4gICAgdGhpcy5jYiA9IGNiXG4gICAgdGhpcy5yZXN1bHQgPSBvcHRzLmluaXRpYWxcbiAgICB0aGlzLm9wdHMgPSBvcHRzXG4gIH1cblxuICBhc3luYyBvbk9wZW4oKSB7XG4gICAgbmV3IFNldHRpbmcodGhpcy5jb250ZW50RWwpLnNldE5hbWUodGhpcy5vcHRzLmhlYWRlcikuc2V0SGVhZGluZygpXG5cbiAgICBuZXcgU2V0dGluZyh0aGlzLmNvbnRlbnRFbCkuYWRkVGV4dCh0ZXh0ID0+IHtcbiAgICAgIHRleHQuc2V0VmFsdWUodGhpcy5yZXN1bHQudGV4dCksXG4gICAgICAgIHRleHQub25DaGFuZ2UoKHZhbHVlKSA9PiB7XG4gICAgICAgICAgdGhpcy5yZXN1bHQudGV4dCA9IHZhbHVlXG4gICAgICAgIH0pXG4gICAgICB0ZXh0LmlucHV0RWwub25rZXlkb3duID0gKGV2KSA9PiB7XG4gICAgICAgIGlmIChldi5rZXkgPT09IFwiRW50ZXJcIikge1xuICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KClcbiAgICAgICAgICB0aGlzLmNsb3NlKClcbiAgICAgICAgICB0aGlzLmNiKHRoaXMucmVzdWx0KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSkuc2V0RGVzYyh0aGlzLm9wdHMuZGVzY3JpcHRpb24pXG5cbiAgICBjb25zdCBidXR0b25zID0gbmV3IFNldHRpbmcodGhpcy5jb250ZW50RWwpXG5cbiAgICBidXR0b25zLmFkZEJ1dHRvbihidXR0b24gPT4ge1xuICAgICAgYnV0dG9uLnNldEJ1dHRvblRleHQoXCJDYW5jZWxcIilcbiAgICAgIGJ1dHRvbi5vbkNsaWNrKCgpID0+IHtcbiAgICAgICAgdGhpcy5jbG9zZSgpXG4gICAgICB9KVxuICAgIH0pXG5cbiAgICBidXR0b25zLmFkZEJ1dHRvbihidXR0b24gPT4ge1xuICAgICAgYnV0dG9uLnNldEJ1dHRvblRleHQoXCJPS1wiKVxuICAgICAgYnV0dG9uLnNldEN0YSgpXG4gICAgICBidXR0b24ub25DbGljaygoKSA9PiB7XG4gICAgICAgIHRoaXMuY2xvc2UoKVxuICAgICAgICB0aGlzLmNiKHRoaXMucmVzdWx0KVxuICAgICAgfSlcbiAgICB9KVxuXG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHByb21wdEZvclRleHQgPSAoYXBwOiBBcHAsIG9wdHM6IE9QVFMpID0+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlPFJFU1VMVCB8IHZvaWQ+KChyZXNvbHZlKSA9PiB7XG4gICAgbmV3IEVudGVyVGV4dE1vZGFsKGFwcCwgb3B0cywgKGNiKSA9PiB7XG4gICAgICByZXNvbHZlKGNiKVxuICAgIH0pLm9wZW4oKVxuICB9KVxufVxuXG5leHBvcnQgY29uc3QgcHJvbXB0Rm9yVVJMID0gKGFwcDogQXBwKSA9PiB7XG4gIHJldHVybiBwcm9tcHRGb3JUZXh0KGFwcCwge1xuICAgIGRlc2NyaXB0aW9uOiBcIkVudGVyIHRoZSBVUkwgeW91IHJlY2VpdmVkIHRvIHN0YXJ0IHdvcmtpbmcgdG9nZXRoZXIuXCIsXG4gICAgaGVhZGVyOiBcIkVudGVyIHlvdXIgUGVlcmRyYWZ0IFVSTFwiLFxuICAgIGluaXRpYWw6IHtcbiAgICAgIHRleHQ6IFwiXCJcbiAgICB9XG4gIH0pXG59XG5cbmV4cG9ydCBjb25zdCBwcm9tcHRGb3JOYW1lID0gKGFwcDogQXBwKSA9PiB7XG4gIHJldHVybiBwcm9tcHRGb3JUZXh0KGFwcCwge1xuICAgIGRlc2NyaXB0aW9uOiBcIlRoaXMgbmFtZSB3aWxsIGJlIHNob3duIHRvIHlvdXIgY29sbGFib3JhdG9yc1wiLFxuICAgIGhlYWRlcjogXCJXaGF0J3MgeW91ciBuYW1lP1wiLFxuICAgIGluaXRpYWw6IHtcbiAgICAgIHRleHQ6IFwiXCJcbiAgICB9XG4gIH0pXG59IiwgImltcG9ydCAqIGFzIFkgZnJvbSAneWpzJ1xuaW1wb3J0ICogYXMgdGltZSBmcm9tICdsaWIwL3RpbWUnXG5pbXBvcnQgKiBhcyBlbmNvZGluZyBmcm9tICdsaWIwL2VuY29kaW5nJ1xuaW1wb3J0ICogYXMgZGVjb2RpbmcgZnJvbSAnbGliMC9kZWNvZGluZydcbmltcG9ydCB7IE9ic2VydmFibGVWMiB9IGZyb20gJ2xpYjAvb2JzZXJ2YWJsZSdcbmltcG9ydCAqIGFzIG1hdGggZnJvbSAnbGliMC9tYXRoJ1xuaW1wb3J0IHsgU2hhcmVkRG9jdW1lbnQgfSBmcm9tICcuL3NoYXJlZEVudGl0aWVzL3NoYXJlZERvY3VtZW50J1xuaW1wb3J0IHsgU2hhcmVkRW50aXR5IH0gZnJvbSAnLi9zaGFyZWRFbnRpdGllcy9zaGFyZWRFbnRpdHknXG5pbXBvcnQgeyBTaGFyZWRGb2xkZXIgfSBmcm9tICcuL3NoYXJlZEVudGl0aWVzL3NoYXJlZEZvbGRlcidcbmltcG9ydCB7IGNhbGN1bGF0ZUhhc2gsIHNlcmlhbGl6ZSB9IGZyb20gJy4vdG9vbHMnXG5cbmV4cG9ydCBjb25zdCBNRVNTQUdFX1NZTkMgPSAwXG5leHBvcnQgY29uc3QgTUVTU0FHRV9RVUVSWV9BV0FSRU5FU1MgPSAzXG5leHBvcnQgY29uc3QgTUVTU0FHRV9BV0FSRU5FU1MgPSAxXG5leHBvcnQgY29uc3QgTUVTU0FHRV9BVVRIID0gMlxuXG5cbmV4cG9ydCBjb25zdCBNRVNTQUdFX01VTFRJUExFWF9TWU5DID0gNFxuXG5leHBvcnQgY29uc3QgU1lOQ19TVEVQXzEgPSAwXG5leHBvcnQgY29uc3QgU1lOQ19TVEVQXzIgPSAxXG5leHBvcnQgY29uc3QgVVBEQVRFID0gM1xuZXhwb3J0IGNvbnN0IE5FV19ET0NVTUVOVCA9IDRcbmV4cG9ydCBjb25zdCBORVdfRE9DVU1FTlRfQ09ORklSTUVEID0gNVxuZXhwb3J0IGNvbnN0IEdFVF9ET0NVTUVOVF9BU19VUERBVEUgPSA2XG5leHBvcnQgY29uc3QgU0VORF9ET0NVTUVOVF9BU19VUERBVEUgPSA3XG5cbmNvbnN0IG1lc3NhZ2VSZWNvbm5lY3RUaW1lb3V0ID0gMzAwMDBcblxuXG5cbmNvbnN0IHNldHVwV1MgPSAocHJvdmlkZXI6IFBlZXJkcmFmdFdlYnNvY2tldFByb3ZpZGVyKSA9PiB7XG4gIGlmIChwcm92aWRlci5zaG91bGRDb25uZWN0ICYmIHByb3ZpZGVyLndzID09PSBudWxsKSB7XG4gICAgY29uc3Qgd2Vic29ja2V0ID0gbmV3IFdlYlNvY2tldChwcm92aWRlci51cmwpXG4gICAgd2Vic29ja2V0LmJpbmFyeVR5cGUgPSAnYXJyYXlidWZmZXInXG4gICAgcHJvdmlkZXIud3MgPSB3ZWJzb2NrZXRcbiAgICBwcm92aWRlci53c2Nvbm5lY3RpbmcgPSB0cnVlXG4gICAgcHJvdmlkZXIud3Njb25uZWN0ZWQgPSBmYWxzZVxuXG4gICAgd2Vic29ja2V0Lm9ubWVzc2FnZSA9IChldmVudCkgPT4ge1xuICAgICAgcHJvdmlkZXIud3NMYXN0TWVzc2FnZVJlY2VpdmVkID0gdGltZS5nZXRVbml4VGltZSgpXG4gICAgICBjb25zdCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkoZXZlbnQuZGF0YSlcbiAgICAgIGlmIChkYXRhLmxlbmd0aCA9PSAwKSByZXR1cm5cbiAgICAgIGNvbnN0IGRlY29kZXIgPSBkZWNvZGluZy5jcmVhdGVEZWNvZGVyKGRhdGEpXG4gICAgICBjb25zdCBtZXNzYWdlVHlwZSA9IGRlY29kaW5nLnJlYWRWYXJVaW50KGRlY29kZXIpXG4gICAgICBpZiAobWVzc2FnZVR5cGUgPT09IE1FU1NBR0VfTVVMVElQTEVYX1NZTkMpIHtcbiAgICAgICAgY29uc3Qgc3luY01lc3NhZ2VUeXBlID0gZGVjb2RpbmcucmVhZFZhclVpbnQoZGVjb2RlcilcbiAgICAgICAgc3dpdGNoIChzeW5jTWVzc2FnZVR5cGUpIHtcbiAgICAgICAgICBjYXNlIE5FV19ET0NVTUVOVF9DT05GSVJNRUQ6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGNvbnN0IHRlbXBJZCA9IGRlY29kaW5nLnJlYWRWYXJTdHJpbmcoZGVjb2RlcilcbiAgICAgICAgICAgICAgY29uc3QgaWQgPSBkZWNvZGluZy5yZWFkVmFyU3RyaW5nKGRlY29kZXIpXG4gICAgICAgICAgICAgIGNvbnN0IGNoZWNrc3VtID0gZGVjb2RpbmcucmVhZFZhclN0cmluZyhkZWNvZGVyKVxuICAgICAgICAgICAgICBwcm92aWRlci5lbWl0KCduZXctZG9jLWNvbmZpcm1lZCcsIFt0ZW1wSWQsIGlkLCBjaGVja3N1bV0pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFNZTkNfU1RFUF8xOiB7XG4gICAgICAgICAgICBjb25zdCBpZCA9IGRlY29kaW5nLnJlYWRWYXJTdHJpbmcoZGVjb2RlcilcbiAgICAgICAgICAgIGNvbnN0IHZlY3RvciA9IGRlY29kaW5nLnJlYWRWYXJVaW50OEFycmF5KGRlY29kZXIpXG4gICAgICAgICAgICBjb25zdCBoYXNoID0gZGVjb2RpbmcucmVhZFZhclN0cmluZyhkZWNvZGVyKVxuICAgICAgICAgICAgY29uc3QgZG9jID0gU2hhcmVkRG9jdW1lbnQuZmluZEJ5SWQoaWQpID8/IFNoYXJlZEZvbGRlci5maW5kQnlJZChpZClcbiAgICAgICAgICAgIGlmIChkb2MgJiYgaGFzaCAhPSBkb2MuY2FsY3VsYXRlSGFzaCgpKSB7XG4gICAgICAgICAgICAgIHByb3ZpZGVyLnNlbmRTeW5jU3RlcDIoZG9jLCB2ZWN0b3IpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBicmVhaztcbiAgICAgICAgICBjYXNlIFNZTkNfU1RFUF8yOiB7XG4gICAgICAgICAgICBjb25zdCBpZCA9IGRlY29kaW5nLnJlYWRWYXJTdHJpbmcoZGVjb2RlcilcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZSA9IGRlY29kaW5nLnJlYWRWYXJVaW50OEFycmF5KGRlY29kZXIpXG4gICAgICAgICAgICBjb25zdCBoYXNoID0gZGVjb2RpbmcucmVhZFZhclN0cmluZyhkZWNvZGVyKVxuICAgICAgICAgICAgY29uc3QgZG9jID0gU2hhcmVkRG9jdW1lbnQuZmluZEJ5SWQoaWQpID8/IFNoYXJlZEZvbGRlci5maW5kQnlJZChpZClcbiAgICAgICAgICAgIGlmIChkb2MpIHtcbiAgICAgICAgICAgICAgWS5hcHBseVVwZGF0ZShkb2MueURvYywgdXBkYXRlLCBwcm92aWRlcilcbiAgICAgICAgICAgICAgcHJvdmlkZXIuZW1pdCgnc3luY2VkJywgW2lkLCBoYXNoXSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFNFTkRfRE9DVU1FTlRfQVNfVVBEQVRFOiB7XG4gICAgICAgICAgICBjb25zdCBpZCA9IGRlY29kaW5nLnJlYWRWYXJTdHJpbmcoZGVjb2RlcilcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZSA9IGRlY29kaW5nLnJlYWRWYXJVaW50OEFycmF5KGRlY29kZXIpXG4gICAgICAgICAgICBjb25zdCBjaGVja3N1bSA9IGRlY29kaW5nLnJlYWRWYXJTdHJpbmcoZGVjb2RlcilcbiAgICAgICAgICAgIHByb3ZpZGVyLmVtaXQoXCJkb2N1bWVudC1yZWNlaXZlZFwiLCBbaWQsIHVwZGF0ZSwgY2hlY2tzdW1dKVxuICAgICAgICAgIH0gYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwidW5yZWFjaGFibGVcIilcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgd2Vic29ja2V0Lm9uZXJyb3IgPSAoZXZlbnQpID0+IHtcbiAgICAgIHByb3ZpZGVyLmVtaXQoJ2Nvbm5lY3Rpb24tZXJyb3InLCBbZXZlbnQsIHByb3ZpZGVyXSlcbiAgICB9XG5cbiAgICB3ZWJzb2NrZXQub25jbG9zZSA9IChldmVudCkgPT4ge1xuICAgICAgcHJvdmlkZXIuZW1pdCgnY29ubmVjdGlvbi1jbG9zZScsIFtldmVudCwgcHJvdmlkZXJdKVxuICAgICAgcHJvdmlkZXIud3MgPSBudWxsXG4gICAgICBwcm92aWRlci53c2Nvbm5lY3RpbmcgPSBmYWxzZVxuICAgICAgaWYgKHByb3ZpZGVyLndzY29ubmVjdGVkKSB7XG4gICAgICAgIHByb3ZpZGVyLndzY29ubmVjdGVkID0gZmFsc2VcbiAgICAgICAgcHJvdmlkZXIuZW1pdCgnc3RhdHVzJywgW3tcbiAgICAgICAgICBzdGF0dXM6ICdkaXNjb25uZWN0ZWQnXG4gICAgICAgIH1dKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvdmlkZXIud3NVbnN1Y2Nlc3NmdWxSZWNvbm5lY3RzKytcbiAgICAgIH1cbiAgICAgIHNldFRpbWVvdXQoXG4gICAgICAgIHNldHVwV1MsXG4gICAgICAgIG1hdGgubWluKFxuICAgICAgICAgIG1hdGgucG93KDIsIHByb3ZpZGVyLndzVW5zdWNjZXNzZnVsUmVjb25uZWN0cykgKiAxMDAsXG4gICAgICAgICAgcHJvdmlkZXIubWF4QmFja29mZlRpbWVcbiAgICAgICAgKSxcbiAgICAgICAgcHJvdmlkZXJcbiAgICAgIClcbiAgICB9XG5cbiAgICB3ZWJzb2NrZXQub25vcGVuID0gYXN5bmMgKCkgPT4ge1xuICAgICAgcHJvdmlkZXIud3NMYXN0TWVzc2FnZVJlY2VpdmVkID0gdGltZS5nZXRVbml4VGltZSgpXG4gICAgICBwcm92aWRlci53c2Nvbm5lY3RpbmcgPSBmYWxzZVxuICAgICAgcHJvdmlkZXIud3Njb25uZWN0ZWQgPSB0cnVlXG4gICAgICBwcm92aWRlci53c1Vuc3VjY2Vzc2Z1bFJlY29ubmVjdHMgPSAwXG4gICAgICBwcm92aWRlci5lbWl0KCdzdGF0dXMnLCBbe1xuICAgICAgICBzdGF0dXM6ICdjb25uZWN0ZWQnXG4gICAgICB9XSlcblxuICAgICAgZm9yIChjb25zdCBmb2xkZXIgb2YgU2hhcmVkRm9sZGVyLmdldEFsbCgpKSB7XG4gICAgICAgIGlmIChmb2xkZXIuaW5kZXhlZERCUHJvdmlkZXIpIHtcbiAgICAgICAgICBpZiAoIWZvbGRlci5pbmRleGVkREJQcm92aWRlci5zeW5jZWQpIGF3YWl0IGZvbGRlci5pbmRleGVkREJQcm92aWRlci53aGVuU3luY2VkXG4gICAgICAgICAgZm9sZGVyLnN5bmNXaXRoU2VydmVyKClcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKGNvbnN0IGRvYyBvZiBTaGFyZWREb2N1bWVudC5nZXRBbGwoKSkge1xuICAgICAgICBpZiAoZG9jLmlzUGVybWFuZW50ICYmIGRvYy5pbmRleGVkREJQcm92aWRlcikge1xuICAgICAgICAgIGlmICghZG9jLmluZGV4ZWREQlByb3ZpZGVyLnN5bmNlZCkgYXdhaXQgZG9jLmluZGV4ZWREQlByb3ZpZGVyLndoZW5TeW5jZWRcbiAgICAgICAgICBkb2Muc3luY1dpdGhTZXJ2ZXIoKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICB9XG5cbiAgICBwcm92aWRlci5lbWl0KCdzdGF0dXMnLCBbe1xuICAgICAgc3RhdHVzOiAnY29ubmVjdGluZydcbiAgICB9XSlcbiAgfVxufVxuXG5cbnR5cGUgRXZlbnRzID0ge1xuICBzeW5jZWQ6IChpZDogc3RyaW5nLCBoYXNoOiBzdHJpbmcpID0+IHZvaWRcbiAgLy8gc3luYzogKHN0YXRlOiBib29sZWFuKSA9PiB2b2lkXG4gIFwiY29ubmVjdGlvbi1lcnJvclwiOiAoZXZlbnQ6IEV2ZW50LCBwcm92aWRlcjogUGVlcmRyYWZ0V2Vic29ja2V0UHJvdmlkZXIpID0+IHZvaWRcbiAgXCJjb25uZWN0aW9uLWNsb3NlXCI6IChldmVudDogRXZlbnQsIHByb3ZpZGVyOiBQZWVyZHJhZnRXZWJzb2NrZXRQcm92aWRlcikgPT4gdm9pZFxuICBzdGF0dXM6IChzdGF0dXM6IHsgc3RhdHVzOiBzdHJpbmcgfSkgPT4gdm9pZFxuICAnZG9jdW1lbnQtcmVjZWl2ZWQnOiAoaWQ6IHN0cmluZywgdXBkYXRlOiBVaW50OEFycmF5LCBjaGVja3N1bTogc3RyaW5nKSA9PiB2b2lkXG4gIC8vICdzeW5jLWNvbmZpcm1lZCc6IChpZDogc3RyaW5nLCBjaGVja3N1bTogc3RyaW5nKSA9PiB2b2lkXG4gICduZXctZG9jLWNvbmZpcm1lZCc6ICh0ZW1wSWQ6IHN0cmluZywgaWQ6IHN0cmluZywgY2hlY2tzdW06IHN0cmluZykgPT4gdm9pZFxuICAvLyAnbXktdXBkYXRlLXNlbnQnOiAoaWQ6IHN0cmluZywgdXBkYXRlOiBVaW50OEFycmF5LCBjaGVja3N1bTogc3RyaW5nKSA9PiB2b2lkXG4gIC8vICdvdGhlci1kb2N1bWVudC1yZWNlaXZlZC1pZi1jaGVja3N1bS1kaWZmZXJzJzogKGlkOiBzdHJpbmcsIG15Q2hlY2tzdW06IHN0cmluZywgeW91ckNoZWNrc3VtOiBzdHJpbmcsIHVwZGF0ZT86IFVpbnQ4QXJyYXkpID0+IHZvaWRcbn1cblxuZXhwb3J0IGNsYXNzIFBlZXJkcmFmdFdlYnNvY2tldFByb3ZpZGVyIGV4dGVuZHMgT2JzZXJ2YWJsZVYyPEV2ZW50cz4ge1xuXG4gIHBhcmFtcz86IHsgW3M6IHN0cmluZ106IHN0cmluZyB9O1xuICBXZWJTb2NrZXRQb2x5ZmlsbD86IHR5cGVvZiBXZWJTb2NrZXQ7XG4gIHJlc3luY0ludGVydmFsPzogbnVtYmVyO1xuICBtYXhCYWNrb2ZmVGltZTogbnVtYmVyO1xuICB1cmw6IHN0cmluZ1xuICB3c2Nvbm5lY3RlZDogYm9vbGVhblxuICB3c2Nvbm5lY3Rpbmc6IGJvb2xlYW5cbiAgd3NVbnN1Y2Nlc3NmdWxSZWNvbm5lY3RzOiBudW1iZXJcbiAgX3N5bmNlZDogYm9vbGVhblxuICB3czogV2ViU29ja2V0IHwgbnVsbFxuICB3c0xhc3RNZXNzYWdlUmVjZWl2ZWQ6IG51bWJlclxuICBzaG91bGRDb25uZWN0OiBib29sZWFuXG4gIF9yZXN5bmNJbnRlcnZhbDogbnVtYmVyXG4gIF91cGRhdGVIYW5kbGVyOiAodXBkYXRlOiBVaW50OEFycmF5LCBvcmlnaW46IGFueSkgPT4gdm9pZFxuICBfYXdhcmVuZXNzVXBkYXRlSGFuZGxlcjogKHsgYWRkZWQsIHVwZGF0ZWQsIHJlbW92ZWQgfTogYW55LCBfb3JpZ2luOiBhbnkpID0+IHZvaWRcbiAgX2V4aXRIYW5kbGVyOiAoKSA9PiB2b2lkXG4gIF9jaGVja0ludGVydmFsOiBudW1iZXJcblxuICBjb25zdHJ1Y3RvcihzZXJ2ZXJVcmw6IHN0cmluZywge1xuICAgIGNvbm5lY3QgPSB0cnVlLFxuICAgIHJlc3luY0ludGVydmFsID0gLTEsXG4gICAgbWF4QmFja29mZlRpbWUgPSAyNTAwLFxuICB9OiB7IGNvbm5lY3Q/OiBib29sZWFuOyBwYXJhbXM/OiB7IFtzOiBzdHJpbmddOiBzdHJpbmcgfTsgV2ViU29ja2V0UG9seWZpbGw/OiB0eXBlb2YgV2ViU29ja2V0OyByZXN5bmNJbnRlcnZhbD86IG51bWJlcjsgbWF4QmFja29mZlRpbWU/OiBudW1iZXI7IGRpc2FibGVCYz86IGJvb2xlYW4gfSA9IHt9KSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMudXJsID0gc2VydmVyVXJsXG4gICAgdGhpcy5tYXhCYWNrb2ZmVGltZSA9IG1heEJhY2tvZmZUaW1lXG4gICAgdGhpcy53c2Nvbm5lY3RlZCA9IGZhbHNlXG4gICAgdGhpcy53c2Nvbm5lY3RpbmcgPSBmYWxzZVxuICAgIHRoaXMuX3Jlc3luY0ludGVydmFsID0gcmVzeW5jSW50ZXJ2YWxcbiAgICB0aGlzLndzVW5zdWNjZXNzZnVsUmVjb25uZWN0cyA9IDBcbiAgICB0aGlzLl9zeW5jZWQgPSBmYWxzZVxuICAgIHRoaXMud3MgPSBudWxsXG4gICAgdGhpcy53c0xhc3RNZXNzYWdlUmVjZWl2ZWQgPSAwXG4gICAgdGhpcy5zaG91bGRDb25uZWN0ID0gY29ubmVjdFxuICAgIHRoaXMuX3Jlc3luY0ludGVydmFsID0gMFxuXG4gICAgdGhpcy5fY2hlY2tJbnRlcnZhbCA9ICh3aW5kb3cuc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgaWYgKFxuICAgICAgICB0aGlzLndzY29ubmVjdGVkICYmXG4gICAgICAgIG1lc3NhZ2VSZWNvbm5lY3RUaW1lb3V0IDxcbiAgICAgICAgdGltZS5nZXRVbml4VGltZSgpIC0gdGhpcy53c0xhc3RNZXNzYWdlUmVjZWl2ZWRcbiAgICAgICkge1xuICAgICAgICAodGhpcy53cyEpLmNsb3NlKClcbiAgICAgIH1cbiAgICB9LCBtZXNzYWdlUmVjb25uZWN0VGltZW91dCAvIDEwKSlcbiAgICBpZiAoY29ubmVjdCkge1xuICAgICAgdGhpcy5jb25uZWN0KClcbiAgICB9XG4gIH1cblxuICBzZW5kU3luY1N0ZXAxKGRvYzogU2hhcmVkRW50aXR5KSB7XG4gICAgY29uc3QgZW5jb2RlciA9IGVuY29kaW5nLmNyZWF0ZUVuY29kZXIoKVxuICAgIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyLCBNRVNTQUdFX01VTFRJUExFWF9TWU5DKVxuICAgIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyLCBTWU5DX1NURVBfMSlcbiAgICBlbmNvZGluZy53cml0ZVZhclN0cmluZyhlbmNvZGVyLCBkb2Muc2hhcmVJZClcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQ4QXJyYXkoZW5jb2RlciwgWS5lbmNvZGVTdGF0ZVZlY3Rvcihkb2MueURvYykpXG4gICAgZW5jb2Rpbmcud3JpdGVWYXJTdHJpbmcoZW5jb2RlciwgZG9jLmNhbGN1bGF0ZUhhc2goKSlcbiAgICB0aGlzLnNlbmRNZXNzYWdlKGVuY29kaW5nLnRvVWludDhBcnJheShlbmNvZGVyKSlcbiAgfVxuXG4gIHNlbmRTeW5jU3RlcDIoZG9jOiBTaGFyZWRFbnRpdHksIHZlY3Rvcj86IFVpbnQ4QXJyYXkpIHtcbiAgICBjb25zdCBlbmNvZGVyID0gZW5jb2RpbmcuY3JlYXRlRW5jb2RlcigpXG4gICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIsIE1FU1NBR0VfTVVMVElQTEVYX1NZTkMpXG4gICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIsIFNZTkNfU1RFUF8yKVxuICAgIGVuY29kaW5nLndyaXRlVmFyU3RyaW5nKGVuY29kZXIsIGRvYy5zaGFyZUlkKVxuICAgIGVuY29kaW5nLndyaXRlVmFyVWludDhBcnJheShlbmNvZGVyLCBZLmVuY29kZVN0YXRlQXNVcGRhdGUoZG9jLnlEb2MsIHZlY3RvcikpXG4gICAgZW5jb2Rpbmcud3JpdGVWYXJTdHJpbmcoZW5jb2RlciwgZG9jLmNhbGN1bGF0ZUhhc2goKSlcbiAgICB0aGlzLnNlbmRNZXNzYWdlKGVuY29kaW5nLnRvVWludDhBcnJheShlbmNvZGVyKSlcbiAgfVxuXG4gIHNlbmRVcGRhdGUoZG9jOiBTaGFyZWRFbnRpdHksIHVwZGF0ZTogVWludDhBcnJheSkge1xuICAgIGNvbnN0IGVuY29kZXIgPSBlbmNvZGluZy5jcmVhdGVFbmNvZGVyKClcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2RlciwgTUVTU0FHRV9NVUxUSVBMRVhfU1lOQylcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2RlciwgVVBEQVRFKVxuICAgIGVuY29kaW5nLndyaXRlVmFyU3RyaW5nKGVuY29kZXIsIGRvYy5zaGFyZUlkKVxuICAgIGVuY29kaW5nLndyaXRlVmFyVWludDhBcnJheShlbmNvZGVyLCB1cGRhdGUpXG4gICAgZW5jb2Rpbmcud3JpdGVWYXJTdHJpbmcoZW5jb2RlciwgZG9jLmNhbGN1bGF0ZUhhc2goKSlcbiAgICB0aGlzLnNlbmRNZXNzYWdlKGVuY29kaW5nLnRvVWludDhBcnJheShlbmNvZGVyKSlcbiAgfVxuXG4gIHNlbmRVcGRhdGVNZXNzYWdlKHNoYXJlSWQ6IHN0cmluZywgdXBkYXRlOiBVaW50OEFycmF5LCBjaGVja3N1bTogc3RyaW5nKSB7XG4gICAgY29uc3QgZW5jb2RlciA9IGVuY29kaW5nLmNyZWF0ZUVuY29kZXIoKVxuICAgIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyLCBNRVNTQUdFX01VTFRJUExFWF9TWU5DKVxuICAgIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyLCBVUERBVEUpXG4gICAgZW5jb2Rpbmcud3JpdGVWYXJTdHJpbmcoZW5jb2Rlciwgc2hhcmVJZClcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQ4QXJyYXkoZW5jb2RlciwgdXBkYXRlKVxuICAgIGVuY29kaW5nLndyaXRlVmFyU3RyaW5nKGVuY29kZXIsIGNoZWNrc3VtKVxuICAgIHRoaXMuc2VuZE1lc3NhZ2UoZW5jb2RpbmcudG9VaW50OEFycmF5KGVuY29kZXIpKVxuICB9XG5cbiAgc2VuZE5ld0RvY3VtZW50KGRvYzogU2hhcmVkRW50aXR5LCB0ZW1wSWQ6IHN0cmluZykge1xuICAgIGNvbnN0IGVuY29kZXIgPSBlbmNvZGluZy5jcmVhdGVFbmNvZGVyKClcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2RlciwgTUVTU0FHRV9NVUxUSVBMRVhfU1lOQylcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2RlciwgTkVXX0RPQ1VNRU5UKVxuICAgIGVuY29kaW5nLndyaXRlVmFyU3RyaW5nKGVuY29kZXIsIHRlbXBJZClcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQ4QXJyYXkoZW5jb2RlciwgWS5lbmNvZGVTdGF0ZUFzVXBkYXRlKGRvYy55RG9jKSlcbiAgICBlbmNvZGluZy53cml0ZVZhclN0cmluZyhlbmNvZGVyLCBkb2MuY2FsY3VsYXRlSGFzaCgpKVxuICAgIHRoaXMuc2VuZE1lc3NhZ2UoZW5jb2RpbmcudG9VaW50OEFycmF5KGVuY29kZXIpKVxuICB9XG5cbiAgc2VuZEdldERvY3VtZW50QXNVcGRhdGUoaWQ6IHN0cmluZykge1xuICAgIGNvbnN0IGVuY29kZXIgPSBlbmNvZGluZy5jcmVhdGVFbmNvZGVyKClcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2RlciwgTUVTU0FHRV9NVUxUSVBMRVhfU1lOQylcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2RlciwgR0VUX0RPQ1VNRU5UX0FTX1VQREFURSksXG4gICAgICBlbmNvZGluZy53cml0ZVZhclN0cmluZyhlbmNvZGVyLCBpZClcbiAgICB0aGlzLnNlbmRNZXNzYWdlKGVuY29kaW5nLnRvVWludDhBcnJheShlbmNvZGVyKSlcbiAgfVxuXG4gIHNlbmRNZXNzYWdlKGJ1ZjogQXJyYXlCdWZmZXIpIHtcbiAgICBpZiAodGhpcy53c2Nvbm5lY3RlZCAmJiB0aGlzLndzICYmIHRoaXMud3MucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0Lk9QRU4pIHtcbiAgICAgIHRoaXMud3Muc2VuZChidWYpXG4gICAgfVxuICB9XG5cbiAgcmVxdWVzdERvY3VtZW50KGRvY0lkOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2U8WS5Eb2M+KHJlc29sdmUgPT4ge1xuICAgICAgY29uc3QgaGFuZGxlciA9IChzZXJ2ZXJJZDogc3RyaW5nLCB1cGRhdGU6IFVpbnQ4QXJyYXksIGNoZWNrc3VtOiBzdHJpbmcpID0+IHtcbiAgICAgICAgaWYgKGRvY0lkID09IHNlcnZlcklkKSB7XG4gICAgICAgICAgdGhpcy5vZmYoJ2RvY3VtZW50LXJlY2VpdmVkJywgaGFuZGxlcilcbiAgICAgICAgICBjb25zdCBkb2MgPSBuZXcgWS5Eb2MoKVxuICAgICAgICAgIFkuYXBwbHlVcGRhdGUoZG9jLCB1cGRhdGUpXG5cbiAgICAgICAgICAvLyBjb3JyZWN0IGhhc2ggZm9yIGZvbGRlcnNcbiAgICAgICAgICBjb25zdCBkb2NzID0gQXJyYXkuZnJvbShkb2MuZ2V0TWFwKFwiZG9jdW1lbnRzXCIpKVxuICAgICAgICAgIGlmIChkb2NzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSBzZXJpYWxpemUoQXJyYXkuZnJvbShkb2NzKSlcbiAgICAgICAgICAgIGNvbnN0IGNhbGN1bGF0ZWRIYXNoID0gY2FsY3VsYXRlSGFzaChzZXJpYWxpemVkKVxuICAgICAgICAgICAgaWYgKGNhbGN1bGF0ZWRIYXNoICE9IGNoZWNrc3VtKSB7XG4gICAgICAgICAgICAgIHRoaXMuc2VuZFVwZGF0ZU1lc3NhZ2UoZG9jSWQsIFkuZW5jb2RlU3RhdGVBc1VwZGF0ZShkb2MpLCBjYWxjdWxhdGVkSGFzaClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzb2x2ZShkb2MpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMub24oJ2RvY3VtZW50LXJlY2VpdmVkJywgaGFuZGxlcilcbiAgICAgIHRoaXMuc2VuZEdldERvY3VtZW50QXNVcGRhdGUoZG9jSWQpXG4gICAgfSlcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMuX3Jlc3luY0ludGVydmFsICE9PSAwKSB7XG4gICAgICBjbGVhckludGVydmFsKHRoaXMuX3Jlc3luY0ludGVydmFsKVxuICAgIH1cbiAgICBjbGVhckludGVydmFsKHRoaXMuX2NoZWNrSW50ZXJ2YWwpXG4gICAgdGhpcy5kaXNjb25uZWN0KClcbiAgICBzdXBlci5kZXN0cm95KClcbiAgfVxuXG4gIGRpc2Nvbm5lY3QoKSB7XG4gICAgdGhpcy5zaG91bGRDb25uZWN0ID0gZmFsc2VcbiAgICBpZiAodGhpcy53cyAhPT0gbnVsbCkge1xuICAgICAgdGhpcy53cy5jbG9zZSgpXG4gICAgfVxuICB9XG5cbiAgY29ubmVjdCgpIHtcbiAgICB0aGlzLnNob3VsZENvbm5lY3QgPSB0cnVlXG4gICAgaWYgKCF0aGlzLndzY29ubmVjdGVkICYmIHRoaXMud3MgPT09IG51bGwpIHtcbiAgICAgIHNldHVwV1ModGhpcylcbiAgICB9XG4gIH1cbn1cbiJdLAogICJtYXBwaW5ncyI6ICI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUFBLDhDQUFBQSxTQUFBO0FBS0MsS0FBQyxTQUFVLE1BQU07QUFHakIsVUFBSSxrQkFBa0I7QUFBQSxRQUNyQixJQUFJLE9BQVEsS0FBSyxJQUFJLElBQUks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QUFRO0FBQUEsWUFDTCxLQUFLLE9BQU8sTUFBSSxDQUFDLEtBQUssSUFBSyxLQUFLLE9BQU8sR0FBRztBQUFBLFlBQ3pDLEtBQUssT0FBTyxNQUFJLENBQUMsS0FBSyxJQUFLLEtBQUssT0FBTyxNQUFJLENBQUM7QUFBQSxZQUM1QyxLQUFLLE9BQU8sTUFBSSxDQUFDLEtBQUssSUFBSyxLQUFLLE9BQU8sTUFBSSxDQUFDO0FBQUEsWUFDNUMsS0FBSyxPQUFPLE1BQUksQ0FBQyxLQUFLLElBQUssS0FBSyxPQUFPLE1BQUksQ0FBQztBQUFBLFVBQy9DO0FBQ0QsZUFBSyxHQUFHLElBQUssTUFBTSxTQUFTLFNBQVMsQ0FBRSxFQUFFLEtBQUssRUFBRSxFQUFFLFNBQVMsU0FBUztBQUNwRSxpQkFBTztBQUNQLGtCQUFRO0FBQUEsWUFDTCxLQUFLLE9BQU8sTUFBSSxDQUFDLEtBQUssSUFBSyxLQUFLLE9BQU8sR0FBRztBQUFBLFlBQ3pDLEtBQUssT0FBTyxNQUFJLENBQUMsS0FBSyxJQUFLLEtBQUssT0FBTyxNQUFJLENBQUM7QUFBQSxZQUM1QyxLQUFLLE9BQU8sTUFBSSxDQUFDLEtBQUssSUFBSyxLQUFLLE9BQU8sTUFBSSxDQUFDO0FBQUEsWUFDNUMsS0FBSyxPQUFPLE1BQUksQ0FBQyxLQUFLLElBQUssS0FBSyxPQUFPLE1BQUksQ0FBQztBQUFBLFVBQy9DO0FBQ0QsZUFBSyxHQUFHLElBQUssTUFBTSxTQUFTLFNBQVMsQ0FBRSxFQUFFLEtBQUssRUFBRSxFQUFFLFNBQVMsU0FBUztBQUNwRSxpQkFBTztBQUNQLGtCQUFRO0FBQUEsWUFDTCxLQUFLLE9BQU8sTUFBSSxDQUFDLEtBQUssSUFBSyxLQUFLLE9BQU8sR0FBRztBQUFBLFlBQ3pDLEtBQUssT0FBTyxNQUFJLENBQUMsS0FBSyxJQUFLLEtBQUssT0FBTyxNQUFJLENBQUM7QUFBQSxZQUM1QyxLQUFLLE9BQU8sTUFBSSxDQUFDLEtBQUssSUFBSyxLQUFLLE9BQU8sTUFBSSxDQUFDO0FBQUEsWUFDNUMsS0FBSyxPQUFPLE1BQUksQ0FBQyxLQUFL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QUFFLEVBQUVILEVBQUMsSUFBRTtBQUFFLHFCQUFPQztBQUFBLFlBQUMsR0FBRSxFQUFFLFVBQVUsWUFBVSxTQUFTRSxJQUFFSCxJQUFFO0FBQUMscUJBQU9HLFFBQUssR0FBRUgsTUFBRyxFQUFFRyxJQUFFLEdBQUUsS0FBSyxNQUFNLEdBQUUsS0FBS0EsRUFBQztBQUFBLFlBQUMsR0FBRSxFQUFFLFVBQVUsZUFBYSxTQUFTQSxJQUFFSCxJQUFFO0FBQUMscUJBQU9HLFFBQUssR0FBRUgsTUFBRyxFQUFFRyxJQUFFLEdBQUUsS0FBSyxNQUFNLEdBQUUsS0FBS0EsRUFBQyxJQUFFLEtBQUtBLEtBQUUsQ0FBQyxLQUFHO0FBQUEsWUFBQyxHQUFFLEVBQUUsVUFBVSxlQUFhLFNBQVNBLElBQUVILElBQUU7QUFBQyxxQkFBT0csUUFBSyxHQUFFSCxNQUFHLEVBQUVHLElBQUUsR0FBRSxLQUFLLE1BQU0sR0FBRSxLQUFLQSxFQUFDLEtBQUcsSUFBRSxLQUFLQSxLQUFFLENBQUM7QUFBQSxZQUFDLEdBQUUsRUFBRSxVQUFVLGVBQWEsU0FBU0EsSUFBRUgsSUFBRTtBQUFDLHFCQUFPRyxRQUFLLEdBQUVILE1BQUcsRUFBRUcsSUFBRSxHQUFFLEtBQUssTUFBTSxJQUFHLEtBQUtBLEVBQUMsSUFBRSxLQUFLQSxLQUFFLENBQUMsS0FBRyxJQUFFLEtBQUtBLEtBQUUsQ0FBQyxLQUFHLE1BQUksV0FBUyxLQUFLQSxLQUFFLENBQUM7QUFBQSxZQUFDLEdBQUUsRUFBRSxVQUFVLGVBQWEsU0FBU0EsSUFBRUgsSUFBRTtBQUFDLHFCQUFPRyxRQUFLLEdBQUVILE1BQUcsRUFBRUcsSUFBRSxHQUFFLEtBQUssTUFBTSxHQUFFLFdBQVMsS0FBS0EsRUFBQyxLQUFHLEtBQUtBLEtBQUUsQ0FBQyxLQUFHLEtBQUcsS0FBS0EsS0FBRSxDQUFDLEtBQUcsSUFBRSxLQUFLQSxLQUFFLENBQUM7QUFBQSxZQUFFLEdBQUUsRUFBRSxVQUFVLFlBQVUsU0FBU0EsSUFBRUgsSUFBRUQsSUFBRTtBQUFDLGNBQUFJLFFBQUssR0FBRUgs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QUFFLE1BQUtJLElBQUVILElBQUVELElBQUVLLEtBQUUsR0FBRSxDQUFDQSxFQUFDO0FBQUEsY0FBQztBQUFDLGtCQUFJQyxLQUFFTixLQUFFLEdBQUVPLEtBQUUsR0FBRUMsS0FBRTtBQUFFLG1CQUFJLEtBQUtQLEtBQUVLLEVBQUMsSUFBRSxNQUFJRixJQUFFLEtBQUcsRUFBRUUsT0FBSUMsTUFBRztBQUFNLG9CQUFFSCxNQUFHLE1BQUlJLE1BQUcsTUFBSSxLQUFLUCxLQUFFSyxLQUFFLENBQUMsTUFBSUUsS0FBRSxJQUFHLEtBQUtQLEtBQUVLLEVBQUMsSUFBRSxPQUFLRixLQUFFRyxNQUFHLEtBQUdDO0FBQUUscUJBQU9QLEtBQUVEO0FBQUEsWUFBQyxHQUFFLEVBQUUsVUFBVSxZQUFVLFNBQVNJLElBQUVILElBQUVELElBQUU7QUFBQyxxQkFBT0ksS0FBRSxDQUFDQSxJQUFFSCxRQUFLLEdBQUVELE1BQUcsRUFBRSxNQUFLSSxJQUFFSCxJQUFFLEdBQUUsS0FBSSxJQUFJLEdBQUUsSUFBRUcsT0FBSUEsS0FBRSxNQUFJQSxLQUFFLElBQUcsS0FBS0gsRUFBQyxJQUFFLE1BQUlHLElBQUVILEtBQUU7QUFBQSxZQUFDLEdBQUUsRUFBRSxVQUFVLGVBQWEsU0FBU0csSUFBRUgsSUFBRUQsSUFBRTtBQUFDLHFCQUFPSSxLQUFFLENBQUNBLElBQUVILFFBQUssR0FBRUQsTUFBRyxFQUFFLE1BQUtJLElBQUVILElBQUUsR0FBRSxPQUFNLE1BQU0sR0FBRSxLQUFLQSxFQUFDLElBQUUsTUFBSUcsSUFBRSxLQUFLSCxLQUFFLENBQUMsSUFBRUcsT0FBSSxHQUFFSCxLQUFFO0FBQUEsWUFBQyxHQUFFLEVBQUUsVUFBVSxlQUFhLFNBQVNHLElBQUVILElBQUVELElBQUU7QUFBQyxxQkFBT0ksS0FBRSxDQUFDQSxJQUFFSCxRQUFLLEdBQUVELE1BQUcsRUFBRSxNQUFLSSxJQUFFSCxJQUFFLEdBQUUsT0FBTSxNQUFNLEdBQUUsS0FBS0EsRUFBQyxJQUFFRyxPQUFJLEdBQUUsS0FBS0gsS0FBRSxDQUFDLElBQUUsTUFBSUcsSUFBRUgsS0FBRTtBQUFBLFlBQUMsR0FBRSxFQUFFLFVBQVUsZUFBYSxTQUFTRyxJQUFFSCxJQUFFRCxJQUFFO0FBQUMscUJBQU9JLEtBQUUsQ0FBQ0EsSUFBRUgsUUFBSyxHQUFFRCxNQUFHLEVBQUUsTUFBS0ksSUFBRUgsSUFBRSxHQUFFLFlBQVcsV0FBVyxHQUFFLEtBQUtBLEVBQUMsSUFBRSxNQUFJRyxJQUFFLEtBQUtILEtBQUUsQ0FBQyxJQUFFRyxPQUFJLEdBQUUsS0FBS0gsS0FBRSxDQUFDLElBQUVHLE9BQUksSUFBRyxLQUFLSCxLQUFFLENBQUMsSUFBRUcsT0FBSSxJQUFHSCxLQUFFO0FBQUEsWUFBQyxHQUFFLEVBQUUsVUFBVSxlQUFhLFNBQVNHLElBQUVILElBQUVELElBQUU7QUFBQyxxQkFBT0ksS0FBRSxDQUFDQSxJQUFFSCxRQUFLLEdBQUVELE1BQUcsRUFBRSxNQUFLSSxJQUFFSCxJQUFFLEdBQUUsWUFBVyxXQUFXLEdBQUUsSUFBRUcsT0FBSUEsS0FBRSxhQUFXQSxLQUFFLElBQUcsS0FBS0gsRUFBQyxJQUFFRyxPQUFJLElBQUcsS0FBS0gsS0FBRSxDQUFDLElBQUVHLE9BQUksSUFBRyxLQUFLSCxLQUFFLENBQUMsSUFBRUcsT0FBSSxHQUFFLEtBQUtILEtBQUUsQ0FBQyxJQUFFLE1BQUlHLElBQUVILEtBQUU7QUFBQSxZQUFDLEdBQUUsRUFBRSxVQUFVLGVBQWEsU0FBU0csSUFBRUgsSUFBRUQsSUFBRTtBQUFDLHFCQUFPLEVBQUUsTUFBS0ksSUFBRUgsSUFBRSxNQUFHRCxFQUFDO0FBQUEsWUFBQyxHQUFFLEVBQUUsVUFBVSxlQUFhLFNBQVNJLElBQUVILElBQUVELElBQUU7QUFBQyxxQkFBTyxFQUFFLE1BQUtJLElBQUVILElBQUUsT0FBR0QsRUFBQztBQUFBLFlBQUMsR0FBRSxFQUFFLFVBQVUsZ0JBQWMsU0FBU0ksSUFBRUgsSUFBRUQsSUFBRTtBQUFDLHFCQUFPLEVBQUUsTUFBS0ksSUFBRUgsSUFBRSxNQUFHRCxFQUFDO0FBQUEsWUFBQyxHQUFFLEVB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S0FBRyxHQUFFLE1BQUksQ0FBQyxHQUFFLEtBQUcsR0FBRSxJQUFFLEdBQUUsSUFBRSxNQUFJLElBQUVDLEdBQUVELEtBQUUsQ0FBQyxHQUFFLEtBQUcsR0FBRSxLQUFHO0FBQUU7QUFBQyxlQUFJLElBQUUsS0FBRyxLQUFHLENBQUMsS0FBRyxHQUFFLE1BQUksQ0FBQyxHQUFFLEtBQUdLLElBQUUsSUFBRSxHQUFFLElBQUUsTUFBSSxJQUFFSixHQUFFRCxLQUFFLENBQUMsR0FBRSxLQUFHLEdBQUUsS0FBRztBQUFFO0FBQUMsY0FBRyxNQUFJO0FBQUUsZ0JBQUUsSUFBRTtBQUFBLGVBQU07QUFBQyxnQkFBRyxNQUFJO0FBQUUscUJBQU8sSUFBRSxPQUFLLElBQUUsS0FBRyxNQUFJLElBQUU7QUFBRyxpQkFBRyxFQUFFLEdBQUVLLEVBQUMsR0FBRSxLQUFHO0FBQUEsVUFBQztBQUFDLGtCQUFPLElBQUUsS0FBRyxLQUFHLElBQUUsRUFBRSxHQUFFLElBQUVBLEVBQUM7QUFBQSxRQUFDLEdBQUUsRUFBRSxRQUFNLFNBQVNGLElBQUVFLElBQUUsR0FBRSxHQUFFLEdBQUUsR0FBRTtBQUFDLGNBQUksR0FBRSxHQUFFLEdBQUUsSUFBRSxLQUFLLEtBQUksSUFBRSxLQUFLLEtBQUksSUFBRSxJQUFFLElBQUUsSUFBRSxHQUFFLEtBQUcsS0FBRyxLQUFHLEdBQUUsSUFBRSxLQUFHLEdBQUUsSUFBRSxPQUFLLElBQUUsRUFBRSxHQUFFLEdBQUcsSUFBRSxFQUFFLEdBQUUsR0FBRyxJQUFFLEdBQUUsSUFBRSxJQUFFLElBQUUsSUFBRSxHQUFFLElBQUUsSUFBRSxJQUFFLElBQUcsSUFBRSxJQUFFQSxNQUFHLE1BQUlBLE1BQUcsSUFBRSxJQUFFQSxLQUFFLElBQUU7QUFBRSxlQUFJQSxLQUFFLEVBQUVBLEVBQUMsR0FBRSxNQUFNQSxFQUFDLEtBQUdBLE9BQUksSUFBRSxLQUFHLElBQUUsTUFBTUEsRUFBQyxJQUFFLElBQUUsR0FBRSxJQUFFLE1BQUksSUFBRSxFQUFFLEVBQUVBLEVBQUMsSUFBRSxDQUFDLEdBQUUsSUFBRUEsTUFBRyxJQUFFLEVBQUUsR0FBRSxDQUFDLENBQUMsT0FBSyxLQUFJLEtBQUcsSUFBR0EsTUFBRyxLQUFHLElBQUUsSUFBRSxJQUFFLElBQUUsSUFBRSxFQUFFLEdBQUUsSUFBRSxDQUFDLEdBQUUsS0FBR0EsS0FBRSxNQUFJLEtBQUksS0FBRyxJQUFHLElBQUUsS0FBRyxLQUFHLElBQUUsR0FBRSxJQUFFLEtBQUcsS0FBRyxJQUFFLEtBQUcsS0FBR0EsS0FBRSxJQUFFLEtBQUcsRUFBRSxHQUFFLENBQUMsR0FBRSxLQUFHLE1BQUksSUFBRUEsS0FBRSxFQUFFLEdBQUUsSUFBRSxDQUFDLElBQUUsRUFBRSxHQUFFLENBQUMsR0FBRSxJQUFFLEtBQUksS0FBRyxHQUFFRixHQUFFLElBQUUsQ0FBQyxJQUFFLE1BQUksR0FBRSxLQUFHLEdBQUUsS0FBRyxLQUFJLEtBQUc7QUFBRTtBQUFDLGVBQUksSUFBRSxLQUFHLElBQUUsR0FBRSxLQUFHLEdBQUUsSUFBRSxHQUFFQSxHQUFFLElBQUUsQ0FBQyxJQUFFLE1BQUksR0FBRSxLQUFHLEdBQUUsS0FBRyxLQUFJLEtBQUc7QUFBRTtBQUFDLFVBQUFBLEdBQUUsSUFBRSxJQUFFLENBQUMsS0FBRyxNQUFJO0FBQUEsUUFBQztBQUFBLE1BQUMsR0FBRSxDQUFDLENBQUMsR0FBRSxJQUFHLENBQUMsU0FBUyxHQUFFRixJQUFFO0FBQUMsUUFBQUEsR0FBRSxVQUFRLGNBQVksT0FBTyxPQUFPLFNBQU8sU0FBU0csSUFBRUgsSUFBRTtBQUFDLFVBQUFBLE9BQUlHLEdBQUUsU0FBT0gsSUFBRUcsR0FBRSxZQUFVLE9BQU8sT0FBT0gsR0FBRSxXQUFVLEVBQUMsYUFBWSxFQUFDLE9BQU1HLElBQUUsWUFBVyxPQUFHLFVBQVMsTUFBRyxjQUFhLEtBQUUsRUFBQyxDQUFDO0FBQUEsUUFBRSxJQUFFLFNBQVNBLElBQUVILElBQUU7QUFBQyxjQUFHQSxJQUFFO0FBQUMsWUFBQUcsR0FBRSxTQUFPSDtBQUFFLGdCQUFJRCxLQUFFLFdBQVU7QUFBQSxZQUFDO0FBQUUsWUFBQUEsR0FBRSxZQUFVQyxHQUFFLFdBQVVHLEdBQUUsWUFBVSxJQUFJSixNQUFFSSxHQUFFLFVBQVUsY0FBWUE7QUFBQSxVQUFDO0FBQUEsUUFBQztBQUFBLE1BQUMsR0FBRSxDQUFDLENBQUMsR0FBRSxJQUFHLENBQUMsU0FBUyxHQUFFSCxJQUFFO0FBQUMsWUFBSUMsS0FBRSxLQUFLO0FBQU0saUJBQVMsRUFBRUUsSUFBRTtBQUFDLGNBQUdBLE1BQUcsSUFBRyxFQUFFLE1BQUlBLEdBQUUsU0FBUTtBQUFDLGdCQUFJSCxLQUFFLG1JQUFtSSxLQUFLRyxFQUFDO0FBQUUsZ0JBQUdILElBQUU7QUFBQyxrQkFBSUMsS0FBRSxXQUFXRCxHQUFFLENBQUMsQ0FBQyxHQUFFRCxNQUFHQyxHQUFFLENBQUMsS0FBRyxNQUFNLFlBQVk7QUFBRSxxQkFBTSxZQUFVRCxNQUFHLFdBQVNBLE1BQUcsVUFBUUEsTUFBRyxTQUFPQSxNQUFHLFFBQU1BLEtBQUUsV0FBWUUsS0FBRSxZQUFVRixNQUFHLFdBQVNBLE1BQUcsUUFBTUEsS0FBRSxTQUFVRSxLQUFFLFdBQVNGLE1BQUcsVUFBUUEsTUFBRyxRQUFNQSxLQUFFLFFBQVNFLEtBQUUsWUFBVUYsTUFBRyxXQUFTQSxNQUFHLFVBQVFBLE1BQUcsU0FBT0EsTUFBRyxRQUFNQSxLQUFFLE9BQVFFLEtBQUUsY0FBWUYsTUFBRyxhQUFXQSxNQUFHLFdBQVNBLE1BQUcsVUFBUUEsTUFBRyxRQUFNQSxLQUFFLE1BQU1FLEtBQUUsY0FBWUYsTUFBRyxhQUFXQSxNQUFHLFdBQVNBLE1BQUcsVUFBUUEsTUFBRyxRQUFNQSxLQUFFLE1BQUtFLEtBQUUsbUJBQWlCRixNQUFHLGtCQUFnQkEsTUFBRyxZQUFVQSxNQUFHLFdBQVNBLE1BQUcsU0FBT0EsS0FBRUUsS0FBRTtBQUFBLFlBQU07QUFBQSxVQUFDO0FBQUEsUUFBQztBQUFDLGlCQUFTLEVBQUVFLElBQUU7QUFBQyxjQUFJSCxLQUFFLEVBQUVHLEVBQUM7QUFBRSxpQkFBTyxTQUFVSCxLQUFFQyxHQUFFRSxLQUFFLEtBQVEsSUFBRSxNQUFJLFFBQVNILEtBQUVDLEdBQUVFLEtBQUUsSUFBTyxJQUFFLE1BQUksT0FBT0gsS0FBRUMsR0FBRUUsS0FBRSxHQUFLLElBQUUsTUFBSSxPQUFNSCxLQUFFQyxHQUFFRSxLQUFFLEdBQUksSUFBRSxNQUFJQSxLQUFFO0FBQUEsUUFBSTtBQUFDLGlCQUFTLEVBQUVBLElBQUU7QUFBQyxjQUFJSCxLQUFFLEVBQUVHLEVBQUM7QUFBRSxpQkFBTyxTQUFVSCxLQUFFLEVBQUVHLElBQUVILElBQUUsT0FBUyxLQUFLLElBQUUsUUFBU0EsS0FBRSxFQUFFRyxJQUFFSCxJQUFFLE1BQVEsTUFBTSxJQUFFLE9BQU9BLEtBQUUsRUFBRUcsSUFBRUgsSUFBRSxLQUFNLFFBQVEsSUFBRSxPQUFNQSxLQUFFLEVBQUVHLElBQUVILElBQUUsS0FBSyxRQUFRLElBQUVHLEtBQUU7QUFBQSxRQUFLO0FBQUMsaUJBQVMsRUFBRUEsSUFBRUgsSUFBRUUsSUFBRUgsSUFBRTtBQUFDLGlCQUFPRSxHQUFFRSxLQUFFRCxFQUFDLElBQUUsTUFBSUgsTUFBR0MsTUFBRyxNQUFJRSxLQUFFLE1BQUk7QUFBQSxRQUFHO0FBQUMsWUFBSSxJQUFFLE1BQUksS0FBRztBQUFPLFFBQUFGLEdBQUUsVUFBUSxTQUFTRyxJQUFFSCxJQUFFO0FBQUMsVUFBQUEsS0FBRUEsTUFBRyxDQUFDO0FBQUUsY0FBSUQsS0FBRSxPQUFPSTtBQUFFLGNBQUcsWUFBVUosTUFBRyxJQUFFSSxHQUFFO0FBQU8sbUJBQU8sRUFBRUEsRUFBQztBQUFFLGNBQUcsYUFBV0osTUFBRyxTQUFTSSxFQUFDO0FBQUUsbUJBQU9ILEdBQUUsT0FBSyxFQUFFRyxFQUFDLElBQUUsRUFBRUEsRUFBQztBQUFFLGdCQUFNLElBQUksTUFBTSwwREFBd0QsS0FBSyxVQUFVQSxFQUFDLENBQUM7QUFBQSxRQUFDO0FBQUEsTUFBQyxHQUFFLENBQUMsQ0FBQyxHQUFFLElBQUcsQ0FBQyxTQUFTLEdBQUVILElBQUU7QUFBQyxpQkFBU0QsS0FBRztBQUFDLGdCQUFNLElBQUksTUFBTSxpQ0FBaUM7QUFBQSxRQUFDO0FBQUMsaUJBQVNFLEtBQUc7QUFBQyxnQkFBTSxJQUFJLE1BQU0sbUNBQW1DO0FBQUEsUUFBQztBQUFDLGlCQUFTLEVBQUVELElBQUU7QUFBQyxjQUFHLE1BQUk7QUFBVyxtQkFBTyxXQUFXQSxJQUFFLENBQUM7QUFBRSxlQUFJLE1BQUlELE1BQUcsQ0FBQyxNQUFJO0FBQVcsbUJBQU8sSUFBRSxZQUFXLFdBQVdDLElBQUUsQ0FBQztBQUFFLGNBQUc7QUFBQyxtQkFBTyxFQUFFQSxJQUFFLENBQUM7QUFBQSxVQUFDLFNBQU9ELElBQU47QUFBUyxnQkFBRztBQUFDLHFCQUFPLEVBQUUsS0FBSyxNQUFLQyxJQUFFLENBQUM7QUFBQSxZQUFDLFNBQU9ELElBQU47QUFBUyxxQkFBTyxFQUFFLEtBQUssTUFBS0MsSUFBRSxDQUFDO0FBQUEsWUFBQztBQUFBLFVBQUM7QUFBQSxRQUFDO0FBQUMsaUJBQVMsRUFBRUEsSUFBRTtBQUFDLGNBQUcsTUFBSTtBQUFhLG1CQUFPLGFBQWFBLEVBQUM7QUFBRSxlQUFJLE1BQUlDLE1BQUcsQ0FBQyxNQUFJO0FBQWEsbUJBQU8sSUFBRSxjQUFhLGFBQWFELEVBQUM7QUFBRSxjQUFHO0FBQUMsbUJBQU8sRUFBRUEsRUFBQztBQUFBLFVBQUMsU0FBT0QsSUFBTjtBQUFTLGdCQUFHO0FBQUMscUJBQU8sRUFBRSxLQUFLLE1BQUtDLEVBQUM7QUFBQSxZQUFDLFNBQU9ELElBQU47QUFBUyxxQkFBTyxFQUFFLEtBQUssTUFBS0MsRUFBQztBQUFBLFlBQUM7QUFBQSxVQUFDO0FBQUEsUUFBQztBQUFDLGlCQUFTLElBQUc7QUFBQyxlQUFHLE1BQUksSUFBRSxPQUFHLEVBQUUsU0FBTyxJQUFFLEVBQUUsT0FBTyxDQUFDLElBQUUsSUFBRSxJQUFHLEVBQUUsVUFBUSxFQUFFO0FBQUEsUUFBRTtBQUFDLGlCQUFTLElBQUc7QUFBQyxjQUFHLENBQUMsR0FBRTtBQUFDLGdCQUFJRyxLQUFFLEVBQUUsQ0FBQztBQUFFLGdCQUFFO0FBQUcscUJBQVFILEtBQUUsRUFBRSxRQUFPQSxNQUFHO0FBQUMsbUJBQUksSUFBRSxHQUFFLElBQUUsQ0FBQyxHQUFFLEVBQUUsSUFBRUE7QUFBRyxxQkFBRyxFQUFFLENBQUMsRUFBRSxJQUFJO0FBQUUsa0JBQUUsSUFBR0EsS0FBRSxFQUFFO0FBQUEsWUFBTTtBQUFDLGdCQUFFLE1BQUssSUFBRSxPQUFHLEVBQUVHLEVBQUM7QUFBQSxVQUFDO0FBQUEsUUFBQztBQUFDLGlCQUFTLEVBQUVBLElBQUVILElBQUU7QUFBQyxlQUFLLE1BQUlHLElBQUUsS0FBSyxRQUFNSDtBQUFBLFFBQUM7QUFBQyxpQkFBUyxJQUFHO0FBQUEsUUFBQztBQUFDLFlBQUksR0FBRSxHQUFFLElBQUVBLEdBQUUsVUFBUSxDQUFDO0FBQUUsU0FBQyxXQUFVO0FBQUMsY0FBRztBQUFDLGdCQUFFLGNBQVksT0FBTyxhQUFXLGFBQVdEO0FBQUEsVUFBQyxTQUFPQyxJQUFOO0FBQVMsZ0JBQUVEO0FBQUEsVUFBQztBQUFDLGNBQUc7QUFBQyxnQkFBRSxjQUFZLE9BQU8sZUFBYSxlQUFhRTtBQUFBLFVBQUMsU0FBT0QsSUFBTjtBQUFTLGdCQUFFQztBQUFBLFVBQUM7QUFBQSxRQUFDLEdBQUc7QUFBRSxZQUFJLEdBQUUsSUFBRSxDQUFDLEdBQUUsSUFBRSxPQUFHLElBQUU7QUFBRyxVQUFFLFdBQVMsU0FBU0UsSUFBRTtBQUFDLGNBQUlILEtBQUUsTUFBTSxVQUFVLFNBQU8sQ0FBQztBQUFFLGNBQUcsSUFBRSxVQUFVO0FBQU8scUJBQVFELEtBQUUsR0FBRUEsS0FBRSxVQUFVLFFBQU9BO0FBQUksY0FBQUMsR0FBRUQsS0FBRSxDQUFDLElBQUUsVUFBVUEsRUFBQztBQUFFLFlBQUUsS0FBSyxJQUFJLEVBQUVJLElBQUVILEVBQUMsQ0FBQyxHQUFFLE1BQUksRUFBRSxVQUFRLEtBQUcsRUFBRSxDQUFDO0FBQUEsUUFBQyxHQUFFLEVBQUUsVUFBVSxNQUFJLFdBQVU7QUFBQyxlQUFLLElBQUksTUFBTSxNQUFLLEtBQUssS0FBSztBQUFBLFFBQUMsR0FBRSxFQUFFLFFBQU0sV0FBVSxFQUFFLFVBQVEsTUFBRyxFQUFFLE1BQUksQ0FBQyxHQUFFLEVBQUUsT0FBSyxDQUFDLEdBQUUsRUFBRSxVQUFRLElBQUcsRUFBRSxXQUFTLENBQUMsR0FBRSxFQUFFLEtBQUcsR0FBRSxFQUFFLGNBQVksR0FBRSxFQUFFLE9BQUssR0FBRSxFQUFFLE1BQUksR0FBRSxFQUFFLGlCQUFlLEdBQUUsRUFBRSxxQkFBbUIsR0FBRSxFQUFFLE9BQUssR0FBRSxFQUFFLGtCQUFnQixHQUFFLEVBQUUsc0JBQW9CLEdBQUUsRUFBRSxZQUFVLFdBQVU7QUFBQyxpQkFBTSxDQUFDO0FBQUEsUUFBQyxHQUFFLEVBQUUsVUFBUSxXQUFVO0FBQUMsZ0JBQU0sSUFBSSxNQUFNLGtDQUFrQztBQUFBLFFBQUMsR0FBRSxFQUFFLE1BQUksV0FBVTtBQUFDLGlCQUFNO0FBQUEsUUFBRyxHQUFFLEVBQUUsUUFBTSxXQUFVO0FBQUMsZ0JBQU0sSUFBSSxNQUFNLGdDQUFnQztBQUFBLFFBQUMsR0FBRSxFQUFFLFFBQU0sV0FBVTtBQUFDLGlCQUFPO0FBQUEsUUFBQztBQUFBLE1BQUMsR0FBRSxDQUFDLENBQUMsR0FBRSxJQUFHLENBQUMsU0FBUyxHQUFFQSxJQUFFO0FBQUMsU0FBQyxTQUFTRyxJQUFFO0FBQUMsV0FBQyxXQUFVO0FBQXlGLGdCQUFJSjtBQUFFLFlBQUFDLEdBQUUsVUFBUSxjQUFZLE9BQU8saUJBQWUsZUFBZSxLQUFLLGVBQWEsT0FBTyxTQUFPRyxLQUFFLE1BQU0sSUFBRSxDQUFBQSxRQUFJSixPQUFJQSxLQUFFLFFBQVEsUUFBUSxJQUFJLEtBQUtJLEVBQUMsRUFBRSxNQUFNLENBQUFBLE9BQUcsV0FBVyxNQUFJO0FBQUMsb0JBQU1BO0FBQUEsWUFBQyxHQUFFLENBQUMsQ0FBQztBQUFBLFVBQUMsR0FBRyxLQUFLLElBQUk7QUFBQSxRQUFDLEdBQUcsS0FBSyxNQUFLLGVBQWEsT0FBTyxTQUFPLGVBQWEsT0FBTyxPQUFLLGVBQWEsT0FBTyxTQUFPLENBQUMsSUFBRSxTQUFPLE9BQUssTUFBTTtBQUFBLE1BQUMsR0FBRSxDQUFDLENBQUMsR0FBRSxJQUFHLENBQUMsU0FBUyxHQUFFSCxJQUFFO0FBQUMsU0FBQyxTQUFTRCxJQUFFRSxJQUFFO0FBQUMsV0FBQyxXQUFVO0FBQUM7QUFBYSxnQkFBSSxJQUFFLEVBQUUsYUFBYSxFQUFFLFFBQU8sSUFBRUEsR0FBRSxVQUFRQSxHQUFFO0FBQVMsWUFBQUQsR0FBRSxVQUFRLEtBQUcsRUFBRSxrQkFBZ0IsU0FBU0csSUFBRUgsSUFBRTtBQUFDLGtCQUFHRyxLQUFFO0FBQVcsc0JBQU0sSUFBSSxXQUFXLGlDQUFpQztBQUFFLGtCQUFJRixLQUFFLEVBQUUsWUFBWUUsRUFBQztBQUFFLGtCQUFHLElBQUVBO0FBQUUsb0JBQUcsUUFBTUE7QUFBRSwyQkFBUSxJQUFFLEdBQUUsSUFBRUEsSUFBRSxLQUFHO0FBQU0sc0JBQUUsZ0JBQWdCRixHQUFFLE1BQU0sR0FBRSxJQUFFLEtBQUssQ0FBQztBQUFBO0FBQU8sb0JBQUUsZ0JBQWdCQSxFQUFDO0FBQUUscUJBQU0sY0FBWSxPQUFPRCxLQUFFRCxHQUFFLFNBQVMsV0FBVTtBQUFDLGdCQUFBQyxHQUFFLE1BQUtDLEVBQUM7QUFBQSxjQUFDLENBQUMsSUFBRUE7QUFBQSxZQUFDLElBQUUsV0FBVTtBQUFDLG9CQUFNLElBQUksTUFBTSxnSEFBZ0g7QUFBQSxZQUFDO0FBQUEsVUFBQyxHQUFHLEtBQUssSUFBSTtBQUFBLFFBQUMsR0FBRyxLQUFLLE1BQUssRUFBRSxVQUFVLEdBQUUsZUFBYSxPQUFPLFNBQU8sZUFBYSxPQUFPLE9BQUssZUFBYSxPQUFPLFNBQU8sQ0FBQyxJQUFFLFNBQU8sT0FBSyxNQUFNO0FBQUEsTUFBQyxHQUFFLEVBQUMsVUFBUyxJQUFHLGVBQWMsR0FBRSxDQUFDLEdBQUUsSUFBRyxDQUFDLFNBQVMsR0FBRUQsSUFBRTtBQUFDO0FBQWEsaUJBQVNELEdBQUVJLElBQUVILElBQUU7QUFBQyxVQUFBRyxHQUFFLFlBQVUsT0FBTyxPQUFPSCxHQUFFLFNBQVMsR0FBRUcsR0FBRSxVQUFVLGNBQVlBLElBQUVBLEdBQUUsWUFBVUg7QUFBQSxRQUFDO0FBQUMsaUJBQVNDLEdBQUVFLElBQUVILElBQUVDLElBQUU7QUFBQyxtQkFBU0MsR0FBRUMsSUFBRUosSUFBRUUsSUFBRTtBQUFDLG1CQUFNLFlBQVUsT0FBT0QsS0FBRUEsS0FBRUEsR0FBRUcsSUFBRUosSUFBRUUsRUFBQztBQUFBLFVBQUM7QUFBQyxVQUFBQSxPQUFJQSxLQUFFO0FBQU8sY0FBSUcsS0FBRSxTQUFTRCxJQUFFO0FBQUMscUJBQVNILEdBQUVBLElBQUVELElBQUVFLElBQUU7QUFBQyxxQkFBT0UsR0FBRSxLQUFLLE1BQUtELEdBQUVGLElBQUVELElBQUVFLEVBQUMsQ0FBQyxLQUFHO0FBQUEsWUFBSTtBQUFDLG1CQUFPRixHQUFFQyxJQUFFRyxFQUFDLEdBQUVIO0FBQUEsVUFBQyxFQUFFQyxFQUFDO0FBQUUsVUFBQUcsR0FBRSxVQUFVLE9BQUtILEdBQUUsTUFBS0csR0FBRSxVQUFVLE9BQUtELElBQUUsRUFBRUEsRUFBQyxJQUFFQztBQUFBLFFBQUM7QUFBQyxpQkFBUyxFQUFFRCxJQUFFSCxJQUFFO0FBQUMsY0FBRyxNQUFNLFFBQVFHLEVBQUMsR0FBRTtBQUFDLGdCQUFJSixLQUFFSSxHQUFFO0FBQU8sbUJBQU9BLEtBQUVBLEdBQUUsSUFBSSxTQUFTQSxJQUFFO0FBQUMscUJBQU9BLEtBQUU7QUFBQSxZQUFFLENBQUMsR0FBRSxJQUFFSixLQUFFLFVBQVUsT0FBT0MsSUFBRSxHQUFHLEVBQUUsT0FBT0csR0FBRSxNQUFNLEdBQUVKLEtBQUUsQ0FBQyxFQUFFLEtBQUssSUFBSSxHQUFFLE9BQU8sSUFBRUksR0FBRUosS0FBRSxDQUFDLElBQUUsTUFBSUEsS0FBRSxVQUFVLE9BQU9DLElBQUUsR0FBRyxFQUFFLE9BQU9HLEdBQUUsQ0FBQyxHQUFFLE1BQU0sRUFBRSxPQUFPQSxHQUFFLENBQUMsQ0FBQyxJQUFFLE1BQU0sT0FBT0gsSUFBRSxHQUFHLEVBQUUsT0FBT0csR0FBRSxDQUFDLENBQUM7QUFBQSxVQUFDO0FBQUMsaUJBQU0sTUFBTSxPQUFPSCxJQUFFLEdBQUcsRUFBRSxPQUFPRyxLQUFFLEVBQUU7QUFBQSxRQUFDO0FBQUMsaUJBQVMsRUFBRUEsSUFBRUgsSUFBRUQsSUFBRTtBQUFDLGlCQUFPSSxHQUFFLE9BQU8sQ0FBQ0osTUFBRyxJQUFFQSxLQUFFLElBQUUsQ0FBQ0EsSUFBRUMsR0FBRSxNQUFNLE1BQUlBO0FBQUEsUUFBQztBQUFDLGlCQUFTLEVBQUVHLElBQUVILElBQUVELElBQUU7QUFBQyxrQkFBTyxXQUFTQSxNQUFHQSxLQUFFSSxHQUFFLFlBQVVKLEtBQUVJLEdBQUUsU0FBUUEsR0FBRSxVQUFVSixLQUFFQyxHQUFFLFFBQU9ELEVBQUMsTUFBSUM7QUFBQSxRQUFDO0FBQUMsaUJBQVMsRUFBRUcsSUFBRUgsSUFBRUQsSUFBRTtBQUFDLGlCQUFNLFlBQVUsT0FBT0EsT0FBSUEsS0FBRSxJQUFHLEVBQUVBLEtBQUVDLEdBQUUsU0FBT0csR0FBRSxXQUFTLE9BQUtBLEdBQUUsUUFBUUgsSUFBRUQsRUFBQztBQUFBLFFBQUM7QUFBQyxZQUFJLElBQUUsQ0FBQztBQUFFLFFBQUFFLEdBQUUseUJBQXdCLFNBQVNFLElBQUVILElBQUU7QUFBQyxpQkFBTSxnQkFBZUEsS0FBRSw4QkFBOEJHLEtBQUU7QUFBQSxRQUFJLEdBQUUsU0FBUyxHQUFFRixHQUFFLHdCQUF1QixTQUFTRSxJQUFFSCxJQUFFRCxJQUFFO0FBQUMsY0FBSUU7QUFBRSxzQkFBVSxPQUFPRCxNQUFHLEVBQUVBLElBQUUsTUFBTSxLQUFHQyxLQUFFLGVBQWNELEtBQUVBLEdBQUUsUUFBUSxTQUFRLEVBQUUsS0FBR0MsS0FBRTtBQUFVLGNBQUlLO0FBQUUsY0FBRyxFQUFFSCxJQUFFLFdBQVc7QUFBRSxZQUFBRyxLQUFFLE9BQU8sT0FBT0gsSUFBRSxHQUFHLEVBQUUsT0FBT0YsSUFBRSxHQUFHLEVBQUUsT0FBTyxFQUFFRCxJQUFFLE1BQU0sQ0FBQztBQUFBLGVBQU07QUFBQyxnQkFBSSxJQUFFLEVBQUVHLElBQUUsR0FBRyxJQUFFLGFBQVc7QUFBVyxZQUFBRyxLQUFFLFFBQVMsT0FBT0gsSUFBRSxJQUFLLEVBQUUsT0FBTyxHQUFFLEdBQUcsRUFBRSxPQUFPRixJQUFFLEdBQUcsRUFBRSxPQUFPLEVBQUVELElBQUUsTUFBTSxDQUFDO0FBQUEsVUFBQztBQUFDLGlCQUFPTSxNQUFHLG1CQUFtQixPQUFPLE9BQU9QLEVBQUMsR0FBRU87QUFBQSxRQUFDLEdBQUUsU0FBUyxHQUFFTCxHQUFFLDZCQUE0Qix5QkFBeUIsR0FBRUEsR0FBRSw4QkFBNkIsU0FBU0UsSUFBRTtBQUFDLGlCQUFNLFNBQU9BLEtBQUU7QUFBQSxRQUE0QixDQUFDLEdBQUVGLEdBQUUsOEJBQTZCLGlCQUFpQixHQUFFQSxHQUFFLHdCQUF1QixTQUFTRSxJQUFFO0FBQUMsaUJBQU0saUJBQWVBLEtBQUU7QUFBQSxRQUErQixDQUFDLEdBQUVGLEdBQUUseUJBQXdCLGdDQUFnQyxHQUFFQSxHQUFFLDBCQUF5QiwyQkFBMkIsR0FBRUEsR0FBRSw4QkFBNkIsaUJBQWlCLEdBQUVBLEdBQUUsMEJBQXlCLHVDQUFzQyxTQUFTLEdBQUVBLEdBQUUsd0JBQXVCLFNBQVNFLElBQUU7QUFBQyxpQkFBTSx1QkFBcUJBO0FBQUEsUUFBQyxHQUFFLFNBQVMsR0FBRUYsR0FBRSxzQ0FBcUMsa0NBQWtDLEdBQUVELEdBQUUsUUFBUSxRQUFNO0FBQUEsTUFBQyxHQUFFLENBQUMsQ0FBQyxHQUFFLElBQUcsQ0FBQyxTQUFTLEdBQUVBLElBQUU7QUFBQyxTQUFDLFNBQVNELElBQUU7QUFBQyxXQUFDLFdBQVU7QUFBQztBQUFhLHFCQUFTRSxHQUFFRSxJQUFFO0FBQUMscUJBQU8sZ0JBQWdCRixLQUFFLE1BQUssRUFBRSxLQUFLLE1BQUtFLEVBQUMsR0FBRSxFQUFFLEtBQUssTUFBS0EsRUFBQyxHQUFFLEtBQUssZ0JBQWMsTUFBR0EsT0FBSSxVQUFLQSxHQUFFLGFBQVcsS0FBSyxXQUFTLFFBQUksVUFBS0EsR0FBRSxhQUFXLEtBQUssV0FBUyxRQUFJLFVBQUtBLEdBQUUsa0JBQWdCLEtBQUssZ0JBQWMsT0FBRyxLQUFLLEtBQUssT0FBTSxDQUFDLE9BQUssSUFBSUYsR0FBRUUsRUFBQztBQUFBLFlBQUM7QUFBQyxxQkFBUyxJQUFHO0FBQUMsbUJBQUssZUFBZSxTQUFPSixHQUFFLFNBQVMsR0FBRSxJQUFJO0FBQUEsWUFBQztBQUFDLHFCQUFTLEVBQUVJLElBQUU7QUFBQyxjQUFBQSxHQUFFLElBQUk7QUFBQSxZQUFDO0FBQUMsZ0JBQUksSUFBRSxPQUFPLFFBQU0sU0FBU0EsSUFBRTtBQUFDLGtCQUFJSCxLQUFFLENBQUM7QUFBRSx1QkFBUUQsTUFBS0k7QUFBRSxnQkFBQUgsR0FBRSxLQUFLRCxFQUFDO0FBQUUscUJBQU9DO0FBQUEsWUFBQztBQUFFLFlBQUFBLEdBQUUsVUFBUUM7QUFBRSxnQkFBSSxJQUFFLEVBQUUsb0JBQW9CLEdBQUUsSUFBRSxFQUFFLG9CQUFvQjtBQUFFLGNBQUUsVUFBVSxFQUFFQSxJQUFFLENBQUM7QUFBRSxxQkFBUSxHQUFFLElBQUUsRUFBRSxFQUFFLFNBQVMsR0FBRSxJQUFFLEdBQUUsSUFBRSxFQUFFLFFBQU87QUFBSSxrQkFBRSxFQUFFLENBQUMsR0FBRUEsR0FBRSxVQUFVLENBQUMsTUFBSUEsR0FBRSxVQUFVLENBQUMsSUFBRSxFQUFFLFVBQVUsQ0FBQztBQUFHLG1CQUFPLGVBQWVBLEdBQUUsV0FBVSx5QkFBd0IsRUFBQyxZQUFXLE9BQUcsS0FBSSxXQUFVO0FBQUMscUJBQU8sS0FBSyxlQUFlO0FBQUEsWUFBYSxFQUFDLENBQUMsR0FBRSxPQUFPLGVBQWVBLEdBQUUsV0FBVSxrQkFBaUIsRUFBQyxZQUFXLE9BQUcsS0FBSSxXQUFVO0FBQUMscUJBQU8sS0FBSyxrQkFBZ0IsS0FBSyxlQUFlLFVBQVU7QUFBQSxZQUFDLEVBQUMsQ0FBQyxHQUFFLE9BQU8sZUFBZUEsR0FBRSxXQUFVLGtCQUFpQixFQUFDLFlBQVcsT0FBRyxLQUFJLFdBQVU7QUFBQyxxQkFBTyxLQUFLLGVBQWU7QUFBQSxZQUFNLEVBQUMsQ0FBQyxHQUFFLE9BQU8sZUFBZUEsR0FBRSxXQUFVLGFBQVksRUFBQyxZQUFXLE9BQUcsS0FBSSxXQUFVO0FBQUMscUJBQU8sV0FBUyxLQUFLLGtCQUFnQixXQUFTLEtBQUssa0JBQWdCLEtBQUssZUFBZSxhQUFXLEtBQUssZUFBZTtBQUFBLFlBQVMsR0FBRSxLQUFJLFNBQVNFLElBQUU7QUFBQyx5QkFBUyxLQUFLLGtCQUFnQixXQUFTLEtBQUssbUJBQWlCLEtBQUssZUFBZSxZQUFVQSxJQUFFLEtBQUssZUFBZSxZQUFVQTtBQUFBLFlBQUUsRUFBQyxDQUFDO0FBQUEsVUFBQyxHQUFHLEtBQUssSUFBSTtBQUFBLFFBQUMsR0FBRyxLQUFLLE1BQUssRUFBRSxVQUFVLENBQUM7QUFBQSxNQUFDLEdBQUUsRUFBQyxzQkFBcUIsSUFBRyxzQkFBcUIsSUFBRyxVQUFTLElBQUcsVUFBUyxHQUFFLENBQUMsR0FBRSxJQUFHLENBQUMsU0FBUyxHQUFFSCxJQUFFO0FBQUM7QUFBYSxpQkFBU0QsR0FBRUksSUFBRTtBQUFDLGlCQUFPLGdCQUFnQkosS0FBRSxLQUFLRSxHQUFFLEtBQUssTUFBS0UsRUFBQyxJQUFFLElBQUlKLEdBQUVJLEVBQUM7QUFBQSxRQUFDO0FBQUMsUUFBQUgsR0FBRSxVQUFRRDtBQUFFLFlBQUlFLEtBQUUsRUFBRSxxQkFBcUI7QUFBRSxVQUFFLFVBQVUsRUFBRUYsSUFBRUUsRUFBQyxHQUFFRixHQUFFLFVBQVUsYUFBVyxTQUFTSSxJQUFFSCxJQUFFRCxJQUFFO0FBQUMsVUFBQUEsR0FBRSxNQUFLSSxFQUFDO0FBQUEsUUFBQztBQUFBLE1BQUMsR0FBRSxFQUFDLHVCQUFzQixJQUFHLFVBQVMsR0FBRSxDQUFDLEdBQUUsSUFBRyxDQUFDLFNBQVMsR0FBRUgsSUFBRTtBQUFDLFNBQUMsU0FBU0QsSUFBRUUsSUFBRTtBQUFDLFdBQUMsV0FBVTtBQUFDO0FBQWEscUJBQVMsRUFBRUUsSUFBRTtBQUFDLHFCQUFPLEVBQUUsS0FBS0EsRUFBQztBQUFBLFlBQUM7QUFBQyxxQkFBUyxFQUFFQSxJQUFFO0FBQUMscUJBQU8sRUFBRSxTQUFTQSxFQUFDLEtBQUdBLGNBQWE7QUFBQSxZQUFDO0FBQUMscUJBQVMsRUFBRUEsSUFBRUgsSUFBRUQsSUFBRTtBQUFDLHFCQUFNLGNBQVksT0FBT0ksR0FBRSxrQkFBZ0JBLEdBQUUsZ0JBQWdCSCxJQUFFRCxFQUFDLElBQUUsTUFBS0ksR0FBRSxXQUFTQSxHQUFFLFFBQVFILEVBQUMsSUFBRSxNQUFNLFFBQVFHLEdBQUUsUUFBUUgsRUFBQyxDQUFDLElBQUVHLEdBQUUsUUFBUUgsRUFBQyxFQUFFLFFBQVFELEVBQUMsSUFBRUksR0FBRSxRQUFRSCxFQUFDLElBQUUsQ0FBQ0QsSUFBRUksR0FBRSxRQUFRSCxFQUFDLENBQUMsSUFBRUcsR0FBRSxHQUFHSCxJQUFFRCxFQUFDO0FBQUEsWUFBRTtBQUFDLHFCQUFTLEVBQUVDLElBQUVELElBQUVFLElBQUU7QUFBQyxrQkFBRSxLQUFHLEVBQUUsa0JBQWtCLEdBQUVELEtBQUVBLE1BQUcsQ0FBQyxHQUFFLGFBQVcsT0FBT0MsT0FBSUEsS0FBRUYsY0FBYSxJQUFHLEtBQUssYUFBVyxDQUFDLENBQUNDLEdBQUUsWUFBV0MsT0FBSSxLQUFLLGFBQVcsS0FBSyxjQUFZLENBQUMsQ0FBQ0QsR0FBRSxxQkFBb0IsS0FBSyxnQkFBYyxFQUFFLE1BQUtBLElBQUUseUJBQXdCQyxFQUFDLEdBQUUsS0FBSyxTQUFPLElBQUksS0FBRSxLQUFLLFNBQU8sR0FBRSxLQUFLLFFBQU0sTUFBSyxLQUFLLGFBQVcsR0FBRSxLQUFLLFVBQVEsTUFBSyxLQUFLLFFBQU0sT0FBRyxLQUFLLGFBQVcsT0FBRyxLQUFLLFVBQVEsT0FBRyxLQUFLLE9BQUssTUFBRyxLQUFLLGVBQWEsT0FBRyxLQUFLLGtCQUFnQixPQUFHLEtBQUssb0JBQWtCLE9BQUcsS0FBSyxrQkFBZ0IsT0FBRyxLQUFLLFNBQU8sTUFBRyxLQUFLLFlBQVUsVUFBS0QsR0FBRSxXQUFVLEtBQUssY0FBWSxDQUFDLENBQUNBLEdBQUUsYUFBWSxLQUFLLFlBQVUsT0FBRyxLQUFLLGtCQUFnQkEsR0FBRSxtQkFBaUIsUUFBTyxLQUFLLGFBQVcsR0FBRSxLQUFLLGNBQVksT0FBRyxLQUFLLFVBQVEsTUFBSyxLQUFLLFdBQVMsTUFBS0EsR0FBRSxhQUFXLENBQUMsTUFBSSxJQUFFLEVBQUUsaUJBQWlCLEVBQUUsZ0JBQWUsS0FBSyxVQUFRLElBQUksRUFBRUEsR0FBRSxRQUFRLEdBQUUsS0FBSyxXQUFTQSxHQUFFO0FBQUEsWUFBUztBQUFDLHFCQUFTLEVBQUVBLElBQUU7QUFBQyxrQkFBRyxJQUFFLEtBQUcsRUFBRSxrQkFBa0IsR0FBRSxFQUFFLGdCQUFnQjtBQUFHLHVCQUFPLElBQUksRUFBRUEsRUFBQztBQUFFLGtCQUFJRCxLQUFFLGdCQUFnQjtBQUFFLG1CQUFLLGlCQUFlLElBQUksRUFBRUMsSUFBRSxNQUFLRCxFQUFDLEdBQUUsS0FBSyxXQUFTLE1BQUdDLE9BQUksY0FBWSxPQUFPQSxHQUFFLFNBQU8sS0FBSyxRQUFNQSxHQUFFLE9BQU0sY0FBWSxPQUFPQSxHQUFFLFlBQVUsS0FBSyxXQUFTQSxHQUFFLFdBQVUsRUFBRSxLQUFLLElBQUk7QUFBQSxZQUFDO0FBQUMscUJBQVMsRUFBRUcsSUFBRUgsSUFBRUQsSUFBRUUsSUFBRUcsSUFBRTtBQUFDLGdCQUFFLG9CQUFtQkosRUFBQztBQUFFLGtCQUFJWSxLQUFFVCxHQUFFO0FBQWUsa0JBQUcsU0FBT0g7QUFBRSxnQkFBQVksR0FBRSxVQUFRLE9BQUcsRUFBRVQsSUFBRVMsRUFBQztBQUFBLG1CQUFNO0FBQUMsb0JBQUlQO0FBQUUsb0JBQUdELE9BQUlDLEtBQUUsRUFBRU8sSUFBRVosRUFBQyxJQUFHSztBQUFFLG9CQUFFRixJQUFFRSxFQUFDO0FBQUEseUJBQVUsRUFBRU8sR0FBRSxjQUFZWixNQUFHLElBQUVBLEdBQUU7QUFBUSxrQkFBQUMsT0FBSVcsR0FBRSxVQUFRLE9BQUcsRUFBRVQsSUFBRVMsRUFBQztBQUFBLHlCQUFXLFlBQVUsT0FBT1osTUFBR1ksR0FBRSxjQUFZLE9BQU8sZUFBZVosRUFBQyxNQUFJLEVBQUUsY0FBWUEsS0FBRSxFQUFFQSxFQUFDLElBQUdDO0FBQUUsa0JBQUFXLEdBQUUsYUFBVyxFQUFFVCxJQUFFLElBQUksR0FBQyxJQUFFLEVBQUVBLElBQUVTLElBQUVaLElBQUUsSUFBRTtBQUFBLHlCQUFVWSxHQUFFO0FBQU0sb0JBQUVULElBQUUsSUFBSSxHQUFDO0FBQUEscUJBQU07QUFBQyxzQkFBR1MsR0FBRTtBQUFVLDJCQUFNO0FBQUcsa0JBQUFBLEdBQUUsVUFBUSxPQUFHQSxHQUFFLFdBQVMsQ0FBQ2IsTUFBR0MsS0FBRVksR0FBRSxRQUFRLE1BQU1aLEVBQUMsR0FBRVksR0FBRSxjQUFZLE1BQUlaLEdBQUUsU0FBTyxFQUFFRyxJQUFFUyxJQUFFWixJQUFFLEtBQUUsSUFBRSxFQUFFRyxJQUFFUyxFQUFDLEtBQUcsRUFBRVQsSUFBRVMsSUFBRVosSUFBRSxLQUFFO0FBQUEsZ0JBQUM7QUFBQSxjQUFDO0FBQUMscUJBQU0sQ0FBQ1ksR0FBRSxVQUFRQSxHQUFFLFNBQU9BLEdBQUUsaUJBQWUsTUFBSUEsR0FBRTtBQUFBLFlBQU87QUFBQyxxQkFBUyxFQUFFVCxJQUFFSCxJQUFFRCxJQUFFRSxJQUFFO0FBQUMsY0FBQUQsR0FBRSxXQUFTLE1BQUlBLEdBQUUsVUFBUSxDQUFDQSxHQUFFLFFBQU1BLEdBQUUsYUFBVyxHQUFFRyxHQUFFLEtBQUssUUFBT0osRUFBQyxNQUFJQyxHQUFFLFVBQVFBLEdBQUUsYUFBVyxJQUFFRCxHQUFFLFFBQU9FLEtBQUVELEdBQUUsT0FBTyxRQUFRRCxFQUFDLElBQUVDLEdBQUUsT0FBTyxLQUFLRCxFQUFDLEdBQUVDLEdBQUUsZ0JBQWMsRUFBRUcsRUFBQyxJQUFHLEVBQUVBLElBQUVILEVBQUM7QUFBQSxZQUFDO0FBQUMscUJBQVMsRUFBRUcsSUFBRUgsSUFBRTtBQUFDLGtCQUFJRDtBQUFFLHFCQUFPLEVBQUVDLEVBQUMsS0FBRyxZQUFVLE9BQU9BLE1BQUcsV0FBU0EsTUFBR0csR0FBRSxlQUFhSixLQUFFLElBQUksRUFBRSxTQUFRLENBQUMsVUFBUyxVQUFTLFlBQVksR0FBRUMsRUFBQyxJQUFHRDtBQUFBLFlBQUM7QUFBQyxxQkFBUyxFQUFFSSxJQUFFO0FBQUMscUJBQU8sY0FBWUEsS0FBRUEsS0FBRSxjQUFZQSxNQUFJQSxNQUFHQSxPQUFJLEdBQUVBLE1BQUdBLE9BQUksR0FBRUEsTUFBR0EsT0FBSSxHQUFFQSxNQUFHQSxPQUFJLEdBQUVBLE1BQUdBLE9BQUksSUFBR0EsT0FBS0E7QUFBQSxZQUFDO0FBQUMscUJBQVMsRUFBRUEsSUFBRUgsSUFBRTtBQUFDLHFCQUFPLEtBQUdHLE1BQUcsTUFBSUgsR0FBRSxVQUFRQSxHQUFFLFFBQU0sSUFBRUEsR0FBRSxhQUFXLElBQUVHLE9BQUlBLE1BQUdBLEtBQUVILEdBQUUsa0JBQWdCQSxHQUFFLGdCQUFjLEVBQUVHLEVBQUMsSUFBR0EsTUFBR0gsR0FBRSxTQUFPRyxLQUFFSCxHQUFFLFFBQU1BLEdBQUUsVUFBUUEsR0FBRSxlQUFhLE1BQUcsTUFBSUEsR0FBRSxXQUFTQSxHQUFFLFNBQU9BLEdBQUUsT0FBTyxLQUFLLEtBQUssU0FBT0EsR0FBRTtBQUFBLFlBQU07QUFBQyxxQkFBUyxFQUFFRyxJQUFFSCxJQUFFO0FBQUMsa0JBQUcsRUFBRSxZQUFZLEdBQUUsQ0FBQ0EsR0FBRSxPQUFNO0FBQUMsb0JBQUdBLEdBQUUsU0FBUTtBQUFDLHNCQUFJRCxLQUFFQyxHQUFFLFFBQVEsSUFBSTtBQUFFLGtCQUFBRCxNQUFHQSxHQUFFLFdBQVNDLEdBQUUsT0FBTyxLQUFLRCxFQUFDLEdBQUVDLEdBQUUsVUFBUUEsR0FBRSxhQUFXLElBQUVELEdBQUU7QUFBQSxnQkFBTztBQUFDLGdCQUFBQyxHQUFFLFFBQU0sTUFBR0EsR0FBRSxPQUFLLEVBQUVHLEVBQUMsS0FBR0gsR0FBRSxlQUFhLE9BQUcsQ0FBQ0EsR0FBRSxvQkFBa0JBLEdBQUUsa0JBQWdCLE1BQUcsRUFBRUcsRUFBQztBQUFBLGNBQUc7QUFBQSxZQUFDO0FBQUMscUJBQVMsRUFBRUEsSUFBRTtBQUFDLGtCQUFJSCxLQUFFRyxHQUFFO0FBQWUsZ0JBQUUsZ0JBQWVILEdBQUUsY0FBYUEsR0FBRSxlQUFlLEdBQUVBLEdBQUUsZUFBYSxPQUFHQSxHQUFFLG9CQUFrQixFQUFFLGdCQUFlQSxHQUFFLE9BQU8sR0FBRUEsR0FBRSxrQkFBZ0IsTUFBR0QsR0FBRSxTQUFTLEdBQUVJLEVBQUM7QUFBQSxZQUFFO0FBQUMscUJBQVMsRUFBRUEsSUFBRTtBQUFDLGtCQUFJSCxLQUFFRyxHQUFFO0FBQWUsZ0JBQUUsaUJBQWdCSCxHQUFFLFdBQVVBLEdBQUUsUUFBT0EsR0FBRSxLQUFLLEdBQUUsQ0FBQ0EsR0FBRSxjQUFZQSxHQUFFLFVBQVFBLEdBQUUsV0FBU0csR0FBRSxLQUFLLFVBQVUsR0FBRUgsR0FBRSxrQkFBZ0IsUUFBSUEsR0FBRSxlQUFhLENBQUNBLEdBQUUsV0FBUyxDQUFDQSxHQUFFLFNBQU9BLEdBQUUsVUFBUUEsR0FBRSxlQUFjLEVBQUVHLEVBQUM7QUFBQSxZQUFDO0FBQUMscUJBQVMsRUFBRUEsSUFBRUgsSUFBRTtBQUFDLGNBQUFBLEdBQUUsZ0JBQWNBLEdBQUUsY0FBWSxNQUFHRCxHQUFFLFNBQVMsR0FBRUksSUFBRUgsRUFBQztBQUFBLFlBQUU7QUFBQyxxQkFBUyxFQUFFRyxJQUFFSCxJQUFFO0FBQUMscUJBQUssQ0FBQ0EsR0FBRSxXQUFTLENBQUNBLEdBQUUsVUFBUUEsR0FBRSxTQUFPQSxHQUFFLGlCQUFlQSxHQUFFLFdBQVMsTUFBSUEsR0FBRSxXQUFTO0FBQUMsb0JBQUlELEtBQUVDLEdBQUU7QUFBTyxvQkFBRyxFQUFFLHNCQUFzQixHQUFFRyxHQUFFLEtBQUssQ0FBQyxHQUFFSixPQUFJQyxHQUFFO0FBQU87QUFBQSxjQUFLO0FBQUMsY0FBQUEsR0FBRSxjQUFZO0FBQUEsWUFBRTtBQUFDLHFCQUFTLEVBQUVHLElBQUU7QUFBQyxxQkFBTyxXQUFVO0FBQUMsb0JBQUlILEtBQUVHLEdBQUU7QUFBZSxrQkFBRSxlQUFjSCxHQUFFLFVBQVUsR0FBRUEsR0FBRSxjQUFZQSxHQUFFLGNBQWEsTUFBSUEsR0FBRSxjQUFZLEVBQUVHLElBQUUsTUFBTSxNQUFJSCxHQUFFLFVBQVEsTUFBRyxFQUFFRyxFQUFDO0FBQUEsY0FBRTtBQUFBLFlBQUM7QUFBQyxxQkFBUyxFQUFFQSxJQUFFO0FBQUMsa0JBQUlILEtBQUVHLEdBQUU7QUFBZSxjQUFBSCxHQUFFLG9CQUFrQixJQUFFRyxHQUFFLGNBQWMsVUFBVSxHQUFFSCxHQUFFLG1CQUFpQixDQUFDQSxHQUFFLFNBQU9BLEdBQUUsVUFBUSxPQUFHLElBQUVHLEdBQUUsY0FBYyxNQUFNLEtBQUdBLEdBQUUsT0FBTztBQUFBLFlBQUM7QUFBQyxxQkFBUyxFQUFFQSxJQUFFO0FBQUMsZ0JBQUUsMEJBQTBCLEdBQUVBLEdBQUUsS0FBSyxDQUFDO0FBQUEsWUFBQztBQUFDLHFCQUFTLEVBQUVBLElBQUVILElBQUU7QUFBQyxjQUFBQSxHQUFFLG9CQUFrQkEsR0FBRSxrQkFBZ0IsTUFBR0QsR0FBRSxTQUFTLEdBQUVJLElBQUVILEVBQUM7QUFBQSxZQUFFO0FBQUMscUJBQVMsRUFBRUcsSUFBRUgsSUFBRTtBQUFDLGdCQUFFLFVBQVNBLEdBQUUsT0FBTyxHQUFFQSxHQUFFLFdBQVNHLEdBQUUsS0FBSyxDQUFDLEdBQUVILEdBQUUsa0JBQWdCLE9BQUdHLEdBQUUsS0FBSyxRQUFRLEdBQUUsRUFBRUEsRUFBQyxHQUFFSCxHQUFFLFdBQVMsQ0FBQ0EsR0FBRSxXQUFTRyxHQUFFLEtBQUssQ0FBQztBQUFBLFlBQUM7QUFBQyxxQkFBUyxFQUFFQSxJQUFFO0FBQUMsa0JBQUlILEtBQUVHLEdBQUU7QUFBZSxtQkFBSSxFQUFFLFFBQU9ILEdBQUUsT0FBTyxHQUFFQSxHQUFFLFdBQVMsU0FBT0csR0FBRSxLQUFLO0FBQUc7QUFBQSxZQUFDO0FBQUMscUJBQVMsRUFBRUEsSUFBRUgsSUFBRTtBQUFDLGtCQUFHLE1BQUlBLEdBQUU7QUFBTyx1QkFBTztBQUFLLGtCQUFJRDtBQUFFLHFCQUFPQyxHQUFFLGFBQVdELEtBQUVDLEdBQUUsT0FBTyxNQUFNLElBQUUsQ0FBQ0csTUFBR0EsTUFBR0gsR0FBRSxVQUFRRCxLQUFFQyxHQUFFLFVBQVFBLEdBQUUsT0FBTyxLQUFLLEVBQUUsSUFBRSxNQUFJQSxHQUFFLE9BQU8sU0FBT0EsR0FBRSxPQUFPLE1BQU0sSUFBRUEsR0FBRSxPQUFPLE9BQU9BLEdBQUUsTUFBTSxHQUFFQSxHQUFFLE9BQU8sTUFBTSxLQUFHRCxLQUFFQyxHQUFFLE9BQU8sUUFBUUcsSUFBRUgsR0FBRSxPQUFPLEdBQUVEO0FBQUEsWUFBQztBQUFDLHFCQUFTLEVBQUVJLElBQUU7QUFBQyxrQkFBSUgsS0FBRUcsR0FBRTtBQUFlLGdCQUFFLGVBQWNILEdBQUUsVUFBVSxHQUFFQSxHQUFFLGVBQWFBLEdBQUUsUUFBTSxNQUFHRCxHQUFFLFNBQVMsR0FBRUMsSUFBRUcsRUFBQztBQUFBLFlBQUU7QUFBQyxxQkFBUyxFQUFFQSxJQUFFSCxJQUFFO0FBQUMsa0JBQUcsRUFBRSxpQkFBZ0JHLEdBQUUsWUFBV0EsR0FBRSxNQUFNLEdBQUUsQ0FBQ0EsR0FBRSxjQUFZLE1BQUlBLEdBQUUsV0FBU0EsR0FBRSxhQUFXLE1BQUdILEdBQUUsV0FBUyxPQUFHQSxHQUFFLEtBQUssS0FBSyxHQUFFRyxHQUFFLGNBQWE7QUFBQyxvQkFBSUosS0FBRUMsR0FBRTtBQUFlLGlCQUFDLENBQUNELE1BQUdBLEdBQUUsZUFBYUEsR0FBRSxhQUFXQyxHQUFFLFFBQVE7QUFBQSxjQUFDO0FBQUEsWUFBQztBQUFDLHFCQUFTLEVBQUVHLElBQUVILElBQUU7QUFBQyx1QkFBUUQsS0FBRSxHQUFFRSxLQUFFRSxHQUFFLFFBQU9KLEtBQUVFLElBQUVGO0FBQUksb0JBQUdJLEdBQUVKLEVBQUMsTUFBSUM7QUFBRSx5QkFBT0Q7QUFBRSxxQkFBTTtBQUFBLFlBQUU7QUFBQyxZQUFBQyxHQUFFLFVBQVE7QUFBRSxnQkFBSTtBQUFFLGNBQUUsZ0JBQWM7QUFBRSxnQkFBSSxHQUFFLElBQUUsRUFBRSxRQUFRLEVBQUUsY0FBYSxJQUFFLFNBQVNHLElBQUVILElBQUU7QUFBQyxxQkFBT0csR0FBRSxVQUFVSCxFQUFDLEVBQUU7QUFBQSxZQUFNLEdBQUUsSUFBRSxFQUFFLDJCQUEyQixHQUFFLElBQUUsRUFBRSxRQUFRLEVBQUUsUUFBTyxJQUFFQyxHQUFFLGNBQVksV0FBVTtBQUFBLFlBQUMsR0FBRSxJQUFFLEVBQUUsTUFBTTtBQUFFLGdCQUFFLEtBQUcsRUFBRSxXQUFTLEVBQUUsU0FBUyxRQUFRLElBQUUsV0FBVTtBQUFBLFlBQUM7QUFBRSxnQkFBSSxHQUFFLEdBQUUsR0FBRSxJQUFFLEVBQUUsZ0NBQWdDLEdBQUUsSUFBRSxFQUFFLDRCQUE0QixHQUFFLElBQUUsRUFBRSwwQkFBMEIsR0FBRSxJQUFFLEVBQUUsa0JBQWlCLElBQUUsRUFBRSxXQUFXLEVBQUUsT0FBTSxJQUFFLEVBQUUsc0JBQXFCLElBQUUsRUFBRSwyQkFBMEIsSUFBRSxFQUFFLDRCQUEyQixJQUFFLEVBQUU7QUFBbUMsY0FBRSxVQUFVLEVBQUUsR0FBRSxDQUFDO0FBQUUsZ0JBQUksSUFBRSxFQUFFLGdCQUFlLElBQUUsQ0FBQyxTQUFRLFNBQVEsV0FBVSxTQUFRLFFBQVE7QUFBRSxtQkFBTyxlQUFlLEVBQUUsV0FBVSxhQUFZLEVBQUMsWUFBVyxPQUFHLEtBQUksV0FBVTtBQUFDLHFCQUFPLFdBQVMsS0FBSyxrQkFBZ0IsS0FBSyxlQUFlO0FBQUEsWUFBUyxHQUFFLEtBQUksU0FBU0UsSUFBRTtBQUFDLG1CQUFLLG1CQUFpQixLQUFLLGVBQWUsWUFBVUE7QUFBQSxZQUFFLEVBQUMsQ0FBQyxHQUFFLEVBQUUsVUFBVSxVQUFRLEVBQUUsU0FBUSxFQUFFLFVBQVUsYUFBVyxFQUFFLFdBQVUsRUFBRSxVQUFVLFdBQVMsU0FBU0EsSUFBRUgsSUFBRTtBQUFDLGNBQUFBLEdBQUVHLEVBQUM7QUFBQSxZQUFDLEdBQUUsRUFBRSxVQUFVLE9BQUssU0FBU0EsSUFBRUgsSUFBRTtBQUFDLGtCQUFJRCxJQUFFRSxLQUFFLEtBQUs7QUFBZSxxQkFBT0EsR0FBRSxhQUFXRixLQUFFLE9BQUcsWUFBVSxPQUFPSSxPQUFJSCxLQUFFQSxNQUFHQyxHQUFFLGlCQUFnQkQsT0FBSUMsR0FBRSxhQUFXRSxLQUFFLEVBQUUsS0FBS0EsSUFBRUgsRUFBQyxHQUFFQSxLQUFFLEtBQUlELEtBQUUsT0FBSSxFQUFFLE1BQUtJLElBQUVILElBQUUsT0FBR0QsRUFBQztBQUFBLFlBQUMsR0FBRSxFQUFFLFVBQVUsVUFBUSxTQUFTSSxJQUFFO0FBQUMscUJBQU8sRUFBRSxNQUFLQSxJQUFFLE1BQUssTUFBRyxLQUFFO0FBQUEsWUFBQyxHQUFFLEVBQUUsVUFBVSxXQUFTLFdBQVU7QUFBQyxxQkFBTSxVQUFLLEtBQUssZUFBZTtBQUFBLFlBQU8sR0FBRSxFQUFFLFVBQVUsY0FBWSxTQUFTSCxJQUFFO0FBQUMsb0JBQUksSUFBRSxFQUFFLGlCQUFpQixFQUFFO0FBQWUsa0JBQUlELEtBQUUsSUFBSSxFQUFFQyxFQUFDO0FBQUUsbUJBQUssZUFBZSxVQUFRRCxJQUFFLEtBQUssZUFBZSxXQUFTLEtBQUssZUFBZSxRQUFRO0FBQVMsdUJBQVFFLEtBQUUsS0FBSyxlQUFlLE9BQU8sTUFBS0MsS0FBRSxJQUFHLFNBQU9EO0FBQUcsZ0JBQUFDLE1BQUdILEdBQUUsTUFBTUUsR0FBRSxJQUFJLEdBQUVBLEtBQUVBLEdBQUU7QUFBSyxxQkFBTyxLQUFLLGVBQWUsT0FBTyxNQUFNLEdBQUUsT0FBS0MsTUFBRyxLQUFLLGVBQWUsT0FBTyxLQUFLQSxFQUFDLEdBQUUsS0FBSyxlQUFlLFNBQU9BLEdBQUUsUUFBTztBQUFBLFlBQUk7QUFBRSxjQUFFLFVBQVUsT0FBSyxTQUFTQyxJQUFFO0FBQUMsZ0JBQUUsUUFBT0EsRUFBQyxHQUFFQSxLQUFFLFNBQVNBLElBQUUsRUFBRTtBQUFFLGtCQUFJSCxLQUFFLEtBQUssZ0JBQWVDLEtBQUVFO0FBQUUsa0JBQUcsTUFBSUEsT0FBSUgsR0FBRSxrQkFBZ0IsUUFBSSxNQUFJRyxNQUFHSCxHQUFFLGtCQUFnQixNQUFJQSxHQUFFLGdCQUFjLElBQUVBLEdBQUUsU0FBT0EsR0FBRSxVQUFRQSxHQUFFLGtCQUFnQkEsR0FBRTtBQUFPLHVCQUFPLEVBQUUsc0JBQXFCQSxHQUFFLFFBQU9BLEdBQUUsS0FBSyxHQUFFLE1BQUlBLEdBQUUsVUFBUUEsR0FBRSxRQUFNLEVBQUUsSUFBSSxJQUFFLEVBQUUsSUFBSSxHQUFFO0FBQUssa0JBQUdHLEtBQUUsRUFBRUEsSUFBRUgsRUFBQyxHQUFFLE1BQUlHLE1BQUdILEdBQUU7QUFBTSx1QkFBTyxNQUFJQSxHQUFFLFVBQVEsRUFBRSxJQUFJLEdBQUU7QUFBSyxrQkFBSUUsS0FBRUYsR0FBRTtBQUFhLGdCQUFFLGlCQUFnQkUsRUFBQyxJQUFHLE1BQUlGLEdBQUUsVUFBUUEsR0FBRSxTQUFPRyxLQUFFSCxHQUFFLG1CQUFpQkUsS0FBRSxNQUFHLEVBQUUsOEJBQTZCQSxFQUFDLElBQUdGLEdBQUUsU0FBT0EsR0FBRSxXQUFTRSxLQUFFLE9BQUcsRUFBRSxvQkFBbUJBLEVBQUMsS0FBR0EsT0FBSSxFQUFFLFNBQVMsR0FBRUYsR0FBRSxVQUFRLE1BQUdBLEdBQUUsT0FBSyxNQUFHLE1BQUlBLEdBQUUsV0FBU0EsR0FBRSxlQUFhLE9BQUksS0FBSyxNQUFNQSxHQUFFLGFBQWEsR0FBRUEsR0FBRSxPQUFLLE9BQUcsQ0FBQ0EsR0FBRSxZQUFVRyxLQUFFLEVBQUVGLElBQUVELEVBQUM7QUFBSSxrQkFBSUk7QUFBRSxxQkFBT0EsS0FBRSxJQUFFRCxLQUFFLEVBQUVBLElBQUVILEVBQUMsSUFBRSxNQUFLLFNBQU9JLE1BQUdKLEdBQUUsZUFBYUEsR0FBRSxVQUFRQSxHQUFFLGVBQWNHLEtBQUUsTUFBSUgsR0FBRSxVQUFRRyxJQUFFSCxHQUFFLGFBQVcsSUFBRyxNQUFJQSxHQUFFLFdBQVMsQ0FBQ0EsR0FBRSxVQUFRQSxHQUFFLGVBQWEsT0FBSUMsT0FBSUUsTUFBR0gsR0FBRSxTQUFPLEVBQUUsSUFBSSxJQUFHLFNBQU9JLE1BQUcsS0FBSyxLQUFLLFFBQU9BLEVBQUMsR0FBRUE7QUFBQSxZQUFDLEdBQUUsRUFBRSxVQUFVLFFBQU0sV0FBVTtBQUFDLGdCQUFFLE1BQUssSUFBSSxFQUFFLFNBQVMsQ0FBQztBQUFBLFlBQUMsR0FBRSxFQUFFLFVBQVUsT0FBSyxTQUFTRCxJQUFFSCxJQUFFO0FBQUMsdUJBQVNDLEdBQUVFLElBQUVILElBQUU7QUFBQyxrQkFBRSxVQUFVLEdBQUVHLE9BQUlRLE1BQUdYLE1BQUcsVUFBS0EsR0FBRSxlQUFhQSxHQUFFLGFBQVcsTUFBR0ksR0FBRTtBQUFBLGNBQUU7QUFBQyx1QkFBU0YsS0FBRztBQUFDLGtCQUFFLE9BQU8sR0FBRUMsR0FBRSxJQUFJO0FBQUEsY0FBQztBQUFDLHVCQUFTQyxLQUFHO0FBQUMsa0JBQUUsU0FBUyxHQUFFRCxHQUFFLGVBQWUsU0FBUUksRUFBQyxHQUFFSixHQUFFLGVBQWUsVUFBU0ssRUFBQyxHQUFFTCxHQUFFLGVBQWUsU0FBUVUsRUFBQyxHQUFFVixHQUFFLGVBQWUsU0FBUUcsRUFBQyxHQUFFSCxHQUFFLGVBQWUsVUFBU0YsRUFBQyxHQUFFVSxHQUFFLGVBQWUsT0FBTVQsRUFBQyxHQUFFUyxHQUFFLGVBQWUsT0FBTUQsRUFBQyxHQUFFQyxHQUFFLGVBQWUsUUFBT04sRUFBQyxHQUFFUyxLQUFFLE1BQUdMLEdBQUUsZUFBYSxDQUFDTixHQUFFLGtCQUFnQkEsR0FBRSxlQUFlLGNBQVlVLEdBQUU7QUFBQSxjQUFDO0FBQUMsdUJBQVNSLEdBQUVMLElBQUU7QUFBQyxrQkFBRSxRQUFRO0FBQUUsb0JBQUlELEtBQUVJLEdBQUUsTUFBTUgsRUFBQztBQUFFLGtCQUFFLGNBQWFELEVBQUMsR0FBRSxVQUFLQSxRQUFLLE1BQUlVLEdBQUUsY0FBWUEsR0FBRSxVQUFRTixNQUFHLElBQUVNLEdBQUUsY0FBWSxPQUFLLEVBQUVBLEdBQUUsT0FBTU4sRUFBQyxNQUFJLENBQUNXLE9BQUksRUFBRSwrQkFBOEJMLEdBQUUsVUFBVSxHQUFFQSxHQUFFLGVBQWNFLEdBQUUsTUFBTTtBQUFBLGNBQUU7QUFBQyx1QkFBU0wsR0FBRU4sSUFBRTtBQUFDLGtCQUFFLFdBQVVBLEVBQUMsR0FBRVUsR0FBRSxHQUFFUCxHQUFFLGVBQWUsU0FBUUcsRUFBQyxHQUFFLE1BQUksRUFBRUgsSUFBRSxPQUFPLEtBQUcsRUFBRUEsSUFBRUgsRUFBQztBQUFBLGNBQUM7QUFBQyx1QkFBU08sS0FBRztBQUFDLGdCQUFBSixHQUFFLGVBQWUsVUFBU0ssRUFBQyxHQUFFRSxHQUFFO0FBQUEsY0FBQztBQUFDLHVCQUFTRixLQUFHO0FBQUMsa0JBQUUsVUFBVSxHQUFFTCxHQUFFLGVBQWUsU0FBUUksRUFBQyxHQUFFRyxHQUFFO0FBQUEsY0FBQztBQUFDLHVCQUFTQSxLQUFHO0FBQUMsa0JBQUUsUUFBUSxHQUFFQyxHQUFFLE9BQU9SLEVBQUM7QUFBQSxjQUFDO0FBQUMsa0JBQUlRLEtBQUUsTUFBS0YsS0FBRSxLQUFLO0FBQWUsc0JBQU9BLEdBQUUsWUFBVztBQUFBLGdCQUFDLEtBQUs7QUFBRSxrQkFBQUEsR0FBRSxRQUFNTjtBQUFFO0FBQUEsZ0JBQU0sS0FBSztBQUFFLGtCQUFBTSxHQUFFLFFBQU0sQ0FBQ0EsR0FBRSxPQUFNTixFQUFDO0FBQUU7QUFBQSxnQkFBTTtBQUFRLGtCQUFBTSxHQUFFLE1BQU0sS0FBS04sRUFBQztBQUFBLGNBQUU7QUFBQyxjQUFBTSxHQUFFLGNBQVksR0FBRSxFQUFFLHlCQUF3QkEsR0FBRSxZQUFXVCxFQUFDO0FBQUUsa0JBQUllLE1BQUcsQ0FBQ2YsTUFBRyxVQUFLQSxHQUFFLFFBQU1HLE9BQUlKLEdBQUUsVUFBUUksT0FBSUosR0FBRSxRQUFPaUIsS0FBRUQsS0FBRWIsS0FBRVE7QUFBRSxjQUFBRCxHQUFFLGFBQVdWLEdBQUUsU0FBU2lCLEVBQUMsSUFBRUwsR0FBRSxLQUFLLE9BQU1LLEVBQUMsR0FBRWIsR0FBRSxHQUFHLFVBQVNGLEVBQUM7QUFBRSxrQkFBSVksS0FBRSxFQUFFRixFQUFDO0FBQUUsY0FBQVIsR0FBRSxHQUFHLFNBQVFVLEVBQUM7QUFBRSxrQkFBSUMsS0FBRTtBQUFHLHFCQUFPSCxHQUFFLEdBQUcsUUFBT04sRUFBQyxHQUFFLEVBQUVGLElBQUUsU0FBUUcsRUFBQyxHQUFFSCxHQUFFLEtBQUssU0FBUUksRUFBQyxHQUFFSixHQUFFLEtBQUssVUFBU0ssRUFBQyxHQUFFTCxHQUFFLEtBQUssUUFBT1EsRUFBQyxHQUFFRixHQUFFLFlBQVUsRUFBRSxhQUFhLEdBQUVFLEdBQUUsT0FBTyxJQUFHUjtBQUFBLFlBQUMsR0FBRSxFQUFFLFVBQVUsU0FBTyxTQUFTQSxJQUFFO0FBQUMsa0JBQUlILEtBQUUsS0FBSyxnQkFBZUQsS0FBRSxFQUFDLFlBQVcsTUFBRTtBQUFFLGtCQUFHLE1BQUlDLEdBQUU7QUFBVyx1QkFBTztBQUFLLGtCQUFHLE1BQUlBLEdBQUU7QUFBVyx1QkFBT0csTUFBR0EsT0FBSUgsR0FBRSxRQUFNLFFBQU1HLE9BQUlBLEtBQUVILEdBQUUsUUFBT0EsR0FBRSxRQUFNLE1BQUtBLEdBQUUsYUFBVyxHQUFFQSxHQUFFLFVBQVEsT0FBR0csTUFBR0EsR0FBRSxLQUFLLFVBQVMsTUFBS0osRUFBQyxHQUFFO0FBQU0sa0JBQUcsQ0FBQ0ksSUFBRTtBQUFDLG9CQUFJRixLQUFFRCxHQUFFLE9BQU1FLEtBQUVGLEdBQUU7QUFBVyxnQkFBQUEsR0FBRSxRQUFNLE1BQUtBLEdBQUUsYUFBVyxHQUFFQSxHQUFFLFVBQVE7QUFBRyx5QkFBUUksS0FBRSxHQUFFQSxLQUFFRixJQUFFRTtBQUFJLGtCQUFBSCxHQUFFRyxFQUFDLEVBQUUsS0FBSyxVQUFTLE1BQUssRUFBQyxZQUFXLE1BQUUsQ0FBQztBQUFFLHVCQUFPO0FBQUEsY0FBSTtBQUFDLGtCQUFJQyxLQUFFLEVBQUVMLEdBQUUsT0FBTUcsRUFBQztBQUFFLHFCQUFNLE9BQUtFLEtBQUUsUUFBTUwsR0FBRSxNQUFNLE9BQU9LLElBQUUsQ0FBQyxHQUFFTCxHQUFFLGNBQVksR0FBRSxNQUFJQSxHQUFFLGVBQWFBLEdBQUUsUUFBTUEsR0FBRSxNQUFNLENBQUMsSUFBR0csR0FBRSxLQUFLLFVBQVMsTUFBS0osRUFBQyxHQUFFO0FBQUEsWUFBSyxHQUFFLEVBQUUsVUFBVSxLQUFHLFNBQVNJLElBQUVILElBQUU7QUFBQyxrQkFBSUMsS0FBRSxFQUFFLFVBQVUsR0FBRyxLQUFLLE1BQUtFLElBQUVILEVBQUMsR0FBRUUsS0FBRSxLQUFLO0FBQWUscUJBQU0sV0FBU0MsTUFBR0QsR0FBRSxvQkFBa0IsSUFBRSxLQUFLLGNBQWMsVUFBVSxHQUFFLFVBQUtBLEdBQUUsV0FBUyxLQUFLLE9BQU8sS0FBRyxjQUFZQyxNQUFHLENBQUNELEdBQUUsY0FBWSxDQUFDQSxHQUFFLHNCQUFvQkEsR0FBRSxvQkFBa0JBLEdBQUUsZUFBYSxNQUFHQSxHQUFFLFVBQVEsT0FBR0EsR0FBRSxrQkFBZ0IsT0FBRyxFQUFFLGVBQWNBLEdBQUUsUUFBT0EsR0FBRSxPQUFPLEdBQUVBLEdBQUUsU0FBTyxFQUFFLElBQUksSUFBRSxDQUFDQSxHQUFFLFdBQVNILEdBQUUsU0FBUyxHQUFFLElBQUksSUFBR0U7QUFBQSxZQUFDLEdBQUUsRUFBRSxVQUFVLGNBQVksRUFBRSxVQUFVLElBQUcsRUFBRSxVQUFVLGlCQUFlLFNBQVNFLElBQUVILElBQUU7QUFBQyxrQkFBSUMsS0FBRSxFQUFFLFVBQVUsZUFBZSxLQUFLLE1BQUtFLElBQUVILEVBQUM7QUFBRSxxQkFBTSxlQUFhRyxNQUFHSixHQUFFLFNBQVMsR0FBRSxJQUFJLEdBQUVFO0FBQUEsWUFBQyxHQUFFLEVBQUUsVUFBVSxxQkFBbUIsU0FBU0UsSUFBRTtBQUFDLGtCQUFJSCxLQUFFLEVBQUUsVUFBVSxtQkFBbUIsTUFBTSxNQUFLLFNBQVM7QUFBRSxzQkFBTyxlQUFhRyxNQUFHLFdBQVNBLE9BQUlKLEdBQUUsU0FBUyxHQUFFLElBQUksR0FBRUM7QUFBQSxZQUFDLEdBQUUsRUFBRSxVQUFVLFNBQU8sV0FBVTtBQUFDLGtCQUFJRyxLQUFFLEtBQUs7QUFBZSxxQkFBT0EsR0FBRSxZQUFVLEVBQUUsUUFBUSxHQUFFQSxHQUFFLFVBQVEsQ0FBQ0EsR0FBRSxtQkFBa0IsRUFBRSxNQUFLQSxFQUFDLElBQUdBLEdBQUUsU0FBTyxPQUFHO0FBQUEsWUFBSSxHQUFFLEVBQUUsVUFBVSxRQUFNLFdBQVU7QUFBQyxxQkFBTyxFQUFFLHlCQUF3QixLQUFLLGVBQWUsT0FBTyxHQUFFLFVBQUssS0FBSyxlQUFlLFlBQVUsRUFBRSxPQUFPLEdBQUUsS0FBSyxlQUFlLFVBQVEsT0FBRyxLQUFLLEtBQUssT0FBTyxJQUFHLEtBQUssZUFBZSxTQUFPLE1BQUc7QUFBQSxZQUFJLEdBQUUsRUFBRSxVQUFVLE9BQUssU0FBU0EsSUFBRTtBQUFDLGtCQUFJSCxLQUFFLE1BQUtDLEtBQUUsS0FBSyxnQkFBZUMsS0FBRTtBQUFHLHVCQUFRRSxNQUFLRCxHQUFFLEdBQUcsT0FBTSxXQUFVO0FBQUMsb0JBQUcsRUFBRSxhQUFhLEdBQUVGLEdBQUUsV0FBUyxDQUFDQSxHQUFFLE9BQU07QUFBQyxzQkFBSUUsS0FBRUYsR0FBRSxRQUFRLElBQUk7QUFBRSxrQkFBQUUsTUFBR0EsR0FBRSxVQUFRSCxHQUFFLEtBQUtHLEVBQUM7QUFBQSxnQkFBQztBQUFDLGdCQUFBSCxHQUFFLEtBQUssSUFBSTtBQUFBLGNBQUMsQ0FBQyxHQUFFRyxHQUFFLEdBQUcsUUFBTyxTQUFTSixJQUFFO0FBQUMscUJBQUksRUFBRSxjQUFjLEdBQUVFLEdBQUUsWUFBVUYsS0FBRUUsR0FBRSxRQUFRLE1BQU1GLEVBQUMsSUFBRyxFQUFFRSxHQUFFLGVBQWEsU0FBT0YsTUFBRyxXQUFTQSxVQUFPRSxHQUFFLGNBQVlGLE1BQUdBLEdBQUUsU0FBUTtBQUFDLHNCQUFJSyxLQUFFSixHQUFFLEtBQUtELEVBQUM7QUFBRSxrQkFBQUssT0FBSUYsS0FBRSxNQUFHQyxHQUFFLE1BQU07QUFBQSxnQkFBRTtBQUFBLGNBQUMsQ0FBQyxHQUFFQTtBQUFFLDJCQUFTLEtBQUtDLEVBQUMsS0FBRyxjQUFZLE9BQU9ELEdBQUVDLEVBQUMsTUFBSSxLQUFLQSxFQUFDLElBQUUsU0FBU0osSUFBRTtBQUFDLHlCQUFPLFdBQVU7QUFBQywyQkFBT0csR0FBRUgsRUFBQyxFQUFFLE1BQU1HLElBQUUsU0FBUztBQUFBLGtCQUFDO0FBQUEsZ0JBQUMsRUFBRUMsRUFBQztBQUFHLHVCQUFRUSxLQUFFLEdBQUVBLEtBQUUsRUFBRSxRQUFPQTtBQUFJLGdCQUFBVCxHQUFFLEdBQUcsRUFBRVMsRUFBQyxHQUFFLEtBQUssS0FBSyxLQUFLLE1BQUssRUFBRUEsRUFBQyxDQUFDLENBQUM7QUFBRSxxQkFBTyxLQUFLLFFBQU0sU0FBU1osSUFBRTtBQUFDLGtCQUFFLGlCQUFnQkEsRUFBQyxHQUFFRSxPQUFJQSxLQUFFLE9BQUdDLEdBQUUsT0FBTztBQUFBLGNBQUUsR0FBRTtBQUFBLFlBQUksR0FBRSxjQUFZLE9BQU8sV0FBUyxFQUFFLFVBQVUsT0FBTyxhQUFhLElBQUUsV0FBVTtBQUFDLHFCQUFPLFdBQVMsTUFBSSxJQUFFLEVBQUUsbUNBQW1DLElBQUcsRUFBRSxJQUFJO0FBQUEsWUFBQyxJQUFHLE9BQU8sZUFBZSxFQUFFLFdBQVUseUJBQXdCLEVBQUMsWUFBVyxPQUFHLEtBQUksV0FBVTtBQUFDLHFCQUFPLEtBQUssZUFBZTtBQUFBLFlBQWEsRUFBQyxDQUFDLEdBQUUsT0FBTyxlQUFlLEVBQUUsV0FBVSxrQkFBaUIsRUFBQyxZQUFXLE9BQUcsS0FBSSxXQUFVO0FBQUMscUJBQU8sS0FBSyxrQkFBZ0IsS0FBSyxlQUFlO0FBQUEsWUFBTSxFQUFDLENBQUMsR0FBRSxPQUFPLGVBQWUsRUFBRSxXQUFVLG1CQUFrQixFQUFDLFlBQVcsT0FBRyxLQUFJLFdBQVU7QUFBQyxxQkFBTyxLQUFLLGVBQWU7QUFBQSxZQUFPLEdBQUUsS0FBSSxTQUFTQSxJQUFFO0FBQUMsbUJBQUssbUJBQWlCLEtBQUssZUFBZSxVQUFRQTtBQUFBLFlBQUUsRUFBQyxDQUFDLEdBQUUsRUFBRSxZQUFVLEdBQUUsT0FBTyxlQUFlLEVBQUUsV0FBVSxrQkFBaUIsRUFBQyxZQUFXLE9BQUcsS0FBSSxXQUFVO0FBQUMscUJBQU8sS0FBSyxlQUFlO0FBQUEsWUFBTSxFQUFDLENBQUMsR0FBRSxjQUFZLE9BQU8sV0FBUyxFQUFFLE9BQUssU0FBU0gsSUFBRUQsSUFBRTtBQUFDLHFCQUFPLFdBQVMsTUFBSSxJQUFFLEVBQUUseUJBQXlCLElBQUcsRUFBRSxHQUFFQyxJQUFFRCxFQUFDO0FBQUEsWUFBQztBQUFBLFVBQUUsR0FBRyxLQUFLLElBQUk7QUFBQSxRQUFDLEdBQUcsS0FBSyxNQUFLLEVBQUUsVUFBVSxHQUFFLGVBQWEsT0FBTyxTQUFPLGVBQWEsT0FBTyxPQUFLLGVBQWEsT0FBTyxTQUFPLENBQUMsSUFBRSxTQUFPLE9BQUssTUFBTTtBQUFBLE1BQUMsR0FBRSxFQUFDLGFBQVksSUFBRyxvQkFBbUIsSUFBRyxxQ0FBb0MsSUFBRyxrQ0FBaUMsSUFBRyw4QkFBNkIsSUFBRywyQkFBMEIsSUFBRyw0QkFBMkIsSUFBRyw2QkFBNEIsSUFBRyxVQUFTLElBQUcsUUFBTyxHQUFFLFFBQU8sR0FBRSxVQUFTLElBQUcsbUJBQWtCLElBQUcsTUFBSyxFQUFDLENBQUMsR0FBRSxJQUFHLENBQUMsU0FBUyxHQUFFQyxJQUFFO0FBQUM7QUFBYSxpQkFBU0QsR0FBRUksSUFBRUgsSUFBRTtBQUFDLGNBQUlELEtBQUUsS0FBSztBQUFnQixVQUFBQSxHQUFFLGVBQWE7QUFBRyxjQUFJRSxLQUFFRixHQUFFO0FBQVEsY0FBRyxTQUFPRTtBQUFFLG1CQUFPLEtBQUssS0FBSyxTQUFRLElBQUksR0FBQztBQUFFLFVBQUFGLEdBQUUsYUFBVyxNQUFLQSxHQUFFLFVBQVEsTUFBSyxRQUFNQyxNQUFHLEtBQUssS0FBS0EsRUFBQyxHQUFFQyxHQUFFRSxFQUFDO0FBQUUsY0FBSUQsS0FBRSxLQUFLO0FBQWUsVUFBQUEsR0FBRSxVQUFRLFFBQUlBLEdBQUUsZ0JBQWNBLEdBQUUsU0FBT0EsR0FBRSxrQkFBZ0IsS0FBSyxNQUFNQSxHQUFFLGFBQWE7QUFBQSxRQUFDO0FBQUMsaUJBQVNELEdBQUVFLElBQUU7QUFBQyxpQkFBTyxnQkFBZ0JGLEtBQUUsTUFBSyxFQUFFLEtBQUssTUFBS0UsRUFBQyxHQUFFLEtBQUssa0JBQWdCLEVBQUMsZ0JBQWVKLEdBQUUsS0FBSyxJQUFJLEdBQUUsZUFBYyxPQUFHLGNBQWEsT0FBRyxTQUFRLE1BQUssWUFBVyxNQUFLLGVBQWMsS0FBSSxHQUFFLEtBQUssZUFBZSxlQUFhLE1BQUcsS0FBSyxlQUFlLE9BQUssT0FBR0ksT0FBSSxjQUFZLE9BQU9BLEdBQUUsY0FBWSxLQUFLLGFBQVdBLEdBQUUsWUFBVyxjQUFZLE9BQU9BLEdBQUUsVUFBUSxLQUFLLFNBQU9BLEdBQUUsU0FBUSxLQUFLLEdBQUcsYUFBWSxDQUFDLEtBQUcsSUFBSUYsR0FBRUUsRUFBQztBQUFBLFFBQUM7QUFBQyxpQkFBUyxJQUFHO0FBQUMsY0FBSUEsS0FBRTtBQUFLLHdCQUFZLE9BQU8sS0FBSyxVQUFRLEtBQUssZUFBZSxZQUFVLEVBQUUsTUFBSyxNQUFLLElBQUksSUFBRSxLQUFLLE9BQU8sU0FBU0gsSUFBRUQsSUFBRTtBQUFDLGNBQUVJLElBQUVILElBQUVELEVBQUM7QUFBQSxVQUFDLENBQUM7QUFBQSxRQUFDO0FBQUMsaUJBQVMsRUFBRUksSUFBRUgsSUFBRUQsSUFBRTtBQUFDLGNBQUdDO0FBQUUsbUJBQU9HLEdBQUUsS0FBSyxTQUFRSCxFQUFDO0FBQUUsY0FBRyxRQUFNRCxNQUFHSSxHQUFFLEtBQUtKLEVBQUMsR0FBRUksR0FBRSxlQUFlO0FBQU8sa0JBQU0sSUFBSTtBQUFFLGNBQUdBLEdBQUUsZ0JBQWdCO0FBQWEsa0JBQU0sSUFBSTtBQUFFLGlCQUFPQSxHQUFFLEtBQUssSUFBSTtBQUFBLFFBQUM7QUFBQyxRQUFBSCxHQUFFLFVBQVFDO0FBQUUsWUFBSSxJQUFFLEVBQUUsV0FBVyxFQUFFLE9BQU0sSUFBRSxFQUFFLDRCQUEyQixJQUFFLEVBQUUsdUJBQXNCLElBQUUsRUFBRSxvQ0FBbUMsSUFBRSxFQUFFLDZCQUE0QixJQUFFLEVBQUUsa0JBQWtCO0FBQUUsVUFBRSxVQUFVLEVBQUVBLElBQUUsQ0FBQyxHQUFFQSxHQUFFLFVBQVUsT0FBSyxTQUFTRSxJQUFFSCxJQUFFO0FBQUMsaUJBQU8sS0FBSyxnQkFBZ0IsZ0JBQWMsT0FBRyxFQUFFLFVBQVUsS0FBSyxLQUFLLE1BQUtHLElBQUVILEVBQUM7QUFBQSxRQUFDLEdBQUVDLEdBQUUsVUFBVSxhQUFXLFNBQVNFLElBQUVILElBQUVELElBQUU7QUFBQyxVQUFBQSxHQUFFLElBQUksRUFBRSxjQUFjLENBQUM7QUFBQSxRQUFDLEdBQUVFLEdBQUUsVUFBVSxTQUFPLFNBQVNFLElBQUVILElBQUVELElBQUU7QUFBQyxjQUFJRSxLQUFFLEtBQUs7QUFBZ0IsY0FBR0EsR0FBRSxVQUFRRixJQUFFRSxHQUFFLGFBQVdFLElBQUVGLEdBQUUsZ0JBQWNELElBQUUsQ0FBQ0MsR0FBRSxjQUFhO0FBQUMsZ0JBQUlDLEtBQUUsS0FBSztBQUFlLGFBQUNELEdBQUUsaUJBQWVDLEdBQUUsZ0JBQWNBLEdBQUUsU0FBT0EsR0FBRSxrQkFBZ0IsS0FBSyxNQUFNQSxHQUFFLGFBQWE7QUFBQSxVQUFDO0FBQUEsUUFBQyxHQUFFRCxHQUFFLFVBQVUsUUFBTSxXQUFVO0FBQUMsY0FBSUUsS0FBRSxLQUFLO0FBQWdCLG1CQUFPQSxHQUFFLGNBQVlBLEdBQUUsZUFBYUEsR0FBRSxnQkFBYyxRQUFJQSxHQUFFLGVBQWEsTUFBRyxLQUFLLFdBQVdBLEdBQUUsWUFBV0EsR0FBRSxlQUFjQSxHQUFFLGNBQWM7QUFBQSxRQUFFLEdBQUVGLEdBQUUsVUFBVSxXQUFTLFNBQVNFLElBQUVILElBQUU7QUFBQyxZQUFFLFVBQVUsU0FBUyxLQUFLLE1BQUtHLElBQUUsU0FBU0EsSUFBRTtBQUFDLFlBQUFILEdBQUVHLEVBQUM7QUFBQSxVQUFDLENBQUM7QUFBQSxRQUFDO0FBQUEsTUFBQyxHQUFFLEVBQUMsYUFBWSxJQUFHLG9CQUFtQixJQUFHLFVBQVMsR0FBRSxDQUFDLEdBQUUsSUFBRyxDQUFDLFNBQVMsR0FBRUgsSUFBRTtBQUFDLFNBQUMsU0FBU0QsSUFBRUUsSUFBRTtBQUFDLFdBQUMsV0FBVTtBQUFDO0FBQWEscUJBQVMsRUFBRUUsSUFBRTtBQUFDLGtCQUFJSCxLQUFFO0FBQUssbUJBQUssT0FBSyxNQUFLLEtBQUssUUFBTSxNQUFLLEtBQUssU0FBTyxXQUFVO0FBQUMsa0JBQUVBLElBQUVHLEVBQUM7QUFBQSxjQUFDO0FBQUEsWUFBQztBQUFDLHFCQUFTLEVBQUVBLElBQUU7QUFBQyxxQkFBTyxFQUFFLEtBQUtBLEVBQUM7QUFBQSxZQUFDO0FBQUMscUJBQVMsRUFBRUEsSUFBRTtBQUFDLHFCQUFPLEVBQUUsU0FBU0EsRUFBQyxLQUFHQSxjQUFhO0FBQUEsWUFBQztBQUFDLHFCQUFTLElBQUc7QUFBQSxZQUFDO0FBQUMscUJBQVMsRUFBRUgsSUFBRUQsSUFBRUUsSUFBRTtBQUFDLGtCQUFFLEtBQUcsRUFBRSxrQkFBa0IsR0FBRUQsS0FBRUEsTUFBRyxDQUFDLEdBQUUsYUFBVyxPQUFPQyxPQUFJQSxLQUFFRixjQUFhLElBQUcsS0FBSyxhQUFXLENBQUMsQ0FBQ0MsR0FBRSxZQUFXQyxPQUFJLEtBQUssYUFBVyxLQUFLLGNBQVksQ0FBQyxDQUFDRCxHQUFFLHFCQUFvQixLQUFLLGdCQUFjLEVBQUUsTUFBS0EsSUFBRSx5QkFBd0JDLEVBQUMsR0FBRSxLQUFLLGNBQVksT0FBRyxLQUFLLFlBQVUsT0FBRyxLQUFLLFNBQU8sT0FBRyxLQUFLLFFBQU0sT0FBRyxLQUFLLFdBQVMsT0FBRyxLQUFLLFlBQVU7QUFBRyxrQkFBSUcsS0FBRSxVQUFLSixHQUFFO0FBQWMsbUJBQUssZ0JBQWMsQ0FBQ0ksSUFBRSxLQUFLLGtCQUFnQkosR0FBRSxtQkFBaUIsUUFBTyxLQUFLLFNBQU8sR0FBRSxLQUFLLFVBQVEsT0FBRyxLQUFLLFNBQU8sR0FBRSxLQUFLLE9BQUssTUFBRyxLQUFLLG1CQUFpQixPQUFHLEtBQUssVUFBUSxTQUFTRyxJQUFFO0FBQUMsa0JBQUVKLElBQUVJLEVBQUM7QUFBQSxjQUFDLEdBQUUsS0FBSyxVQUFRLE1BQUssS0FBSyxXQUFTLEdBQUUsS0FBSyxrQkFBZ0IsTUFBSyxLQUFLLHNCQUFvQixNQUFLLEtBQUssWUFBVSxHQUFFLEtBQUssY0FBWSxPQUFHLEtBQUssZUFBYSxPQUFHLEtBQUssWUFBVSxVQUFLSCxHQUFFLFdBQVUsS0FBSyxjQUFZLENBQUMsQ0FBQ0EsR0FBRSxhQUFZLEtBQUssdUJBQXFCLEdBQUUsS0FBSyxxQkFBbUIsSUFBSSxFQUFFLElBQUk7QUFBQSxZQUFDO0FBQUMscUJBQVMsRUFBRUEsSUFBRTtBQUFDLGtCQUFFLEtBQUcsRUFBRSxrQkFBa0I7QUFBRSxrQkFBSUQsS0FBRSxnQkFBZ0I7QUFBRSxxQkFBT0EsTUFBRyxFQUFFLEtBQUssR0FBRSxJQUFJLElBQUUsTUFBSyxLQUFLLGlCQUFlLElBQUksRUFBRUMsSUFBRSxNQUFLRCxFQUFDLEdBQUUsS0FBSyxXQUFTLE1BQUdDLE9BQUksY0FBWSxPQUFPQSxHQUFFLFVBQVEsS0FBSyxTQUFPQSxHQUFFLFFBQU8sY0FBWSxPQUFPQSxHQUFFLFdBQVMsS0FBSyxVQUFRQSxHQUFFLFNBQVEsY0FBWSxPQUFPQSxHQUFFLFlBQVUsS0FBSyxXQUFTQSxHQUFFLFVBQVMsY0FBWSxPQUFPQSxHQUFFLFVBQVEsS0FBSyxTQUFPQSxHQUFFLFNBQVEsRUFBRSxLQUFLLElBQUksS0FBRyxJQUFJLEVBQUVBLEVBQUM7QUFBQSxZQUFDO0FBQUMscUJBQVMsRUFBRUcsSUFBRUgsSUFBRTtBQUFDLGtCQUFJQyxLQUFFLElBQUk7QUFBRSxnQkFBRUUsSUFBRUYsRUFBQyxHQUFFRixHQUFFLFNBQVNDLElBQUVDLEVBQUM7QUFBQSxZQUFDO0FBQUMscUJBQVMsRUFBRUUsSUFBRUgsSUFBRUMsSUFBRUMsSUFBRTtBQUFDLGtCQUFJRTtBQUFFLHFCQUFPLFNBQU9ILEtBQUVHLEtBQUUsSUFBSSxNQUFFLFlBQVUsT0FBT0gsTUFBRyxDQUFDRCxHQUFFLGVBQWFJLEtBQUUsSUFBSSxFQUFFLFNBQVEsQ0FBQyxVQUFTLFFBQVEsR0FBRUgsRUFBQyxJQUFHLENBQUNHLE9BQUksRUFBRUQsSUFBRUMsRUFBQyxHQUFFTCxHQUFFLFNBQVNHLElBQUVFLEVBQUMsR0FBRTtBQUFBLFlBQUc7QUFBQyxxQkFBUyxFQUFFRCxJQUFFSCxJQUFFRCxJQUFFO0FBQUMscUJBQU9JLEdBQUUsY0FBWSxVQUFLQSxHQUFFLGlCQUFlLFlBQVUsT0FBT0gsT0FBSUEsS0FBRSxFQUFFLEtBQUtBLElBQUVELEVBQUMsSUFBR0M7QUFBQSxZQUFDO0FBQUMscUJBQVMsRUFBRUcsSUFBRUgsSUFBRUQsSUFBRUUsSUFBRUMsSUFBRUUsSUFBRTtBQUFDLGtCQUFHLENBQUNMLElBQUU7QUFBQyxvQkFBSWEsS0FBRSxFQUFFWixJQUFFQyxJQUFFQyxFQUFDO0FBQUUsZ0JBQUFELE9BQUlXLE9BQUliLEtBQUUsTUFBR0csS0FBRSxVQUFTRCxLQUFFVztBQUFBLGNBQUU7QUFBQyxrQkFBSVAsS0FBRUwsR0FBRSxhQUFXLElBQUVDLEdBQUU7QUFBTyxjQUFBRCxHQUFFLFVBQVFLO0FBQUUsa0JBQUlDLEtBQUVOLEdBQUUsU0FBT0EsR0FBRTtBQUFjLGtCQUFHTSxPQUFJTixHQUFFLFlBQVUsT0FBSUEsR0FBRSxXQUFTQSxHQUFFLFFBQU87QUFBQyxvQkFBSU8sS0FBRVAsR0FBRTtBQUFvQixnQkFBQUEsR0FBRSxzQkFBb0IsRUFBQyxPQUFNQyxJQUFFLFVBQVNDLElBQUUsT0FBTUgsSUFBRSxVQUFTSyxJQUFFLE1BQUssS0FBSSxHQUFFRyxLQUFFQSxHQUFFLE9BQUtQLEdBQUUsc0JBQW9CQSxHQUFFLGtCQUFnQkEsR0FBRSxxQkFBb0JBLEdBQUUsd0JBQXNCO0FBQUEsY0FBQztBQUFNLGtCQUFFRyxJQUFFSCxJQUFFLE9BQUdLLElBQUVKLElBQUVDLElBQUVFLEVBQUM7QUFBRSxxQkFBT0U7QUFBQSxZQUFDO0FBQUMscUJBQVMsRUFBRUgsSUFBRUgsSUFBRUQsSUFBRUUsSUFBRUMsSUFBRUUsSUFBRVEsSUFBRTtBQUFDLGNBQUFaLEdBQUUsV0FBU0MsSUFBRUQsR0FBRSxVQUFRWSxJQUFFWixHQUFFLFVBQVEsTUFBR0EsR0FBRSxPQUFLLE1BQUdBLEdBQUUsWUFBVUEsR0FBRSxRQUFRLElBQUksRUFBRSxPQUFPLENBQUMsSUFBRUQsS0FBRUksR0FBRSxRQUFRRCxJQUFFRixHQUFFLE9BQU8sSUFBRUcsR0FBRSxPQUFPRCxJQUFFRSxJQUFFSixHQUFFLE9BQU8sR0FBRUEsR0FBRSxPQUFLO0FBQUEsWUFBRTtBQUFDLHFCQUFTLEVBQUVHLElBQUVILElBQUVDLElBQUVDLElBQUVFLElBQUU7QUFBQyxnQkFBRUosR0FBRSxXQUFVQyxNQUFHRixHQUFFLFNBQVNLLElBQUVGLEVBQUMsR0FBRUgsR0FBRSxTQUFTLEdBQUVJLElBQUVILEVBQUMsR0FBRUcsR0FBRSxlQUFlLGVBQWEsTUFBRyxFQUFFQSxJQUFFRCxFQUFDLE1BQUlFLEdBQUVGLEVBQUMsR0FBRUMsR0FBRSxlQUFlLGVBQWEsTUFBRyxFQUFFQSxJQUFFRCxFQUFDLEdBQUUsRUFBRUMsSUFBRUgsRUFBQztBQUFBLFlBQUU7QUFBQyxxQkFBUyxFQUFFRyxJQUFFO0FBQUMsY0FBQUEsR0FBRSxVQUFRLE9BQUdBLEdBQUUsVUFBUSxNQUFLQSxHQUFFLFVBQVFBLEdBQUUsVUFBU0EsR0FBRSxXQUFTO0FBQUEsWUFBQztBQUFDLHFCQUFTLEVBQUVBLElBQUVILElBQUU7QUFBQyxrQkFBSUMsS0FBRUUsR0FBRSxnQkFBZUQsS0FBRUQsR0FBRSxNQUFLRyxLQUFFSCxHQUFFO0FBQVEsa0JBQUcsY0FBWSxPQUFPRztBQUFFLHNCQUFNLElBQUk7QUFBRSxrQkFBRyxFQUFFSCxFQUFDLEdBQUVEO0FBQUUsa0JBQUVHLElBQUVGLElBQUVDLElBQUVGLElBQUVJLEVBQUM7QUFBQSxtQkFBTTtBQUFDLG9CQUFJUSxLQUFFLEVBQUVYLEVBQUMsS0FBR0UsR0FBRTtBQUFVLGdCQUFBUyxNQUFHWCxHQUFFLFVBQVFBLEdBQUUsb0JBQWtCLENBQUNBLEdBQUUsbUJBQWlCLEVBQUVFLElBQUVGLEVBQUMsR0FBRUMsS0FBRUgsR0FBRSxTQUFTLEdBQUVJLElBQUVGLElBQUVXLElBQUVSLEVBQUMsSUFBRSxFQUFFRCxJQUFFRixJQUFFVyxJQUFFUixFQUFDO0FBQUEsY0FBQztBQUFBLFlBQUM7QUFBQyxxQkFBUyxFQUFFRCxJQUFFSCxJQUFFRCxJQUFFRSxJQUFFO0FBQUMsY0FBQUYsTUFBRyxFQUFFSSxJQUFFSCxFQUFDLEdBQUVBLEdBQUUsYUFBWUMsR0FBRSxHQUFFLEVBQUVFLElBQUVILEVBQUM7QUFBQSxZQUFDO0FBQUMscUJBQVMsRUFBRUcsSUFBRUgsSUFBRTtBQUFDLG9CQUFJQSxHQUFFLFVBQVFBLEdBQUUsY0FBWUEsR0FBRSxZQUFVLE9BQUdHLEdBQUUsS0FBSyxPQUFPO0FBQUEsWUFBRTtBQUFDLHFCQUFTLEVBQUVBLElBQUVILElBQUU7QUFBQyxjQUFBQSxHQUFFLG1CQUFpQjtBQUFHLGtCQUFJRCxLQUFFQyxHQUFFO0FBQWdCLGtCQUFHRyxHQUFFLFdBQVNKLE1BQUdBLEdBQUUsTUFBSztBQUFDLG9CQUFJRSxLQUFFRCxHQUFFLHNCQUFxQkksS0FBRSxNQUFNSCxFQUFDLEdBQUVXLEtBQUVaLEdBQUU7QUFBbUIsZ0JBQUFZLEdBQUUsUUFBTWI7QUFBRSx5QkFBUU0sS0FBRSxHQUFFQyxLQUFFLE1BQUdQO0FBQUcsa0JBQUFLLEdBQUVDLEVBQUMsSUFBRU4sSUFBRUEsR0FBRSxVQUFRTyxLQUFFLFFBQUlQLEtBQUVBLEdBQUUsTUFBS00sTUFBRztBQUFFLGdCQUFBRCxHQUFFLGFBQVdFLElBQUUsRUFBRUgsSUFBRUgsSUFBRSxNQUFHQSxHQUFFLFFBQU9JLElBQUUsSUFBR1EsR0FBRSxNQUFNLEdBQUVaLEdBQUUsYUFBWUEsR0FBRSxzQkFBb0IsTUFBS1ksR0FBRSxRQUFNWixHQUFFLHFCQUFtQlksR0FBRSxNQUFLQSxHQUFFLE9BQUssUUFBTVosR0FBRSxxQkFBbUIsSUFBSSxFQUFFQSxFQUFDLEdBQUVBLEdBQUUsdUJBQXFCO0FBQUEsY0FBQyxPQUFLO0FBQUMsdUJBQUtELE1BQUc7QUFBQyxzQkFBSVEsS0FBRVIsR0FBRSxPQUFNUyxLQUFFVCxHQUFFLFVBQVNXLEtBQUVYLEdBQUUsVUFBU1ksS0FBRVgsR0FBRSxhQUFXLElBQUVPLEdBQUU7QUFBTyxzQkFBRyxFQUFFSixJQUFFSCxJQUFFLE9BQUdXLElBQUVKLElBQUVDLElBQUVFLEVBQUMsR0FBRVgsS0FBRUEsR0FBRSxNQUFLQyxHQUFFLHdCQUF1QkEsR0FBRTtBQUFRO0FBQUEsZ0JBQUs7QUFBQyx5QkFBT0QsT0FBSUMsR0FBRSxzQkFBb0I7QUFBQSxjQUFLO0FBQUMsY0FBQUEsR0FBRSxrQkFBZ0JELElBQUVDLEdBQUUsbUJBQWlCO0FBQUEsWUFBRTtBQUFDLHFCQUFTLEVBQUVHLElBQUU7QUFBQyxxQkFBT0EsR0FBRSxVQUFRLE1BQUlBLEdBQUUsVUFBUSxTQUFPQSxHQUFFLG1CQUFpQixDQUFDQSxHQUFFLFlBQVUsQ0FBQ0EsR0FBRTtBQUFBLFlBQU87QUFBQyxxQkFBUyxFQUFFQSxJQUFFSCxJQUFFO0FBQUMsY0FBQUcsR0FBRSxPQUFPLFNBQVNKLElBQUU7QUFBQyxnQkFBQUMsR0FBRSxhQUFZRCxNQUFHLEVBQUVJLElBQUVKLEVBQUMsR0FBRUMsR0FBRSxjQUFZLE1BQUdHLEdBQUUsS0FBSyxXQUFXLEdBQUUsRUFBRUEsSUFBRUgsRUFBQztBQUFBLGNBQUMsQ0FBQztBQUFBLFlBQUM7QUFBQyxxQkFBUyxFQUFFRyxJQUFFSCxJQUFFO0FBQUMsY0FBQUEsR0FBRSxlQUFhQSxHQUFFLGdCQUFjLGNBQVksT0FBT0csR0FBRSxVQUFRSCxHQUFFLGFBQVdBLEdBQUUsY0FBWSxNQUFHRyxHQUFFLEtBQUssV0FBVyxNQUFJSCxHQUFFLGFBQVlBLEdBQUUsY0FBWSxNQUFHRCxHQUFFLFNBQVMsR0FBRUksSUFBRUgsRUFBQztBQUFBLFlBQUc7QUFBQyxxQkFBUyxFQUFFRyxJQUFFSCxJQUFFO0FBQUMsa0JBQUlELEtBQUUsRUFBRUMsRUFBQztBQUFFLGtCQUFHRCxPQUFJLEVBQUVJLElBQUVILEVBQUMsR0FBRSxNQUFJQSxHQUFFLGNBQVlBLEdBQUUsV0FBUyxNQUFHRyxHQUFFLEtBQUssUUFBUSxHQUFFSCxHQUFFLGVBQWM7QUFBQyxvQkFBSUMsS0FBRUUsR0FBRTtBQUFlLGlCQUFDLENBQUNGLE1BQUdBLEdBQUUsZUFBYUEsR0FBRSxlQUFhRSxHQUFFLFFBQVE7QUFBQSxjQUFDO0FBQUMscUJBQU9KO0FBQUEsWUFBQztBQUFDLHFCQUFTLEVBQUVJLElBQUVILElBQUVDLElBQUU7QUFBQyxjQUFBRCxHQUFFLFNBQU8sTUFBRyxFQUFFRyxJQUFFSCxFQUFDLEdBQUVDLE9BQUlELEdBQUUsV0FBU0QsR0FBRSxTQUFTRSxFQUFDLElBQUVFLEdBQUUsS0FBSyxVQUFTRixFQUFDLElBQUdELEdBQUUsUUFBTSxNQUFHRyxHQUFFLFdBQVM7QUFBQSxZQUFFO0FBQUMscUJBQVMsRUFBRUEsSUFBRUgsSUFBRUQsSUFBRTtBQUFDLGtCQUFJRSxLQUFFRSxHQUFFO0FBQU0sbUJBQUlBLEdBQUUsUUFBTSxNQUFLRixNQUFHO0FBQUMsb0JBQUlDLEtBQUVELEdBQUU7QUFBUyxnQkFBQUQsR0FBRSxhQUFZRSxHQUFFSCxFQUFDLEdBQUVFLEtBQUVBLEdBQUU7QUFBQSxjQUFJO0FBQUMsY0FBQUQsR0FBRSxtQkFBbUIsT0FBS0c7QUFBQSxZQUFDO0FBQUMsWUFBQUgsR0FBRSxVQUFRO0FBQUUsZ0JBQUk7QUFBRSxjQUFFLGdCQUFjO0FBQUUsZ0JBQUksSUFBRSxFQUFDLFdBQVUsRUFBRSxnQkFBZ0IsRUFBQyxHQUFFLElBQUUsRUFBRSwyQkFBMkIsR0FBRSxJQUFFLEVBQUUsUUFBUSxFQUFFLFFBQU8sSUFBRUMsR0FBRSxjQUFZLFdBQVU7QUFBQSxZQUFDLEdBQUUsSUFBRSxFQUFFLDRCQUE0QixHQUFFLElBQUUsRUFBRSwwQkFBMEIsR0FBRSxJQUFFLEVBQUUsa0JBQWlCLElBQUUsRUFBRSxXQUFXLEVBQUUsT0FBTSxJQUFFLEVBQUUsc0JBQXFCLElBQUUsRUFBRSw0QkFBMkIsSUFBRSxFQUFFLHVCQUFzQixJQUFFLEVBQUUsd0JBQXVCLElBQUUsRUFBRSxzQkFBcUIsSUFBRSxFQUFFLHdCQUF1QixJQUFFLEVBQUUsNEJBQTJCLElBQUUsRUFBRSxzQkFBcUIsSUFBRSxFQUFFO0FBQWUsY0FBRSxVQUFVLEVBQUUsR0FBRSxDQUFDLEdBQUUsRUFBRSxVQUFVLFlBQVUsV0FBVTtBQUFDLHVCQUFRRSxLQUFFLEtBQUssaUJBQWdCSCxLQUFFLENBQUMsR0FBRUc7QUFBRyxnQkFBQUgsR0FBRSxLQUFLRyxFQUFDLEdBQUVBLEtBQUVBLEdBQUU7QUFBSyxxQkFBT0g7QUFBQSxZQUFDLEdBQUUsV0FBVTtBQUFDLGtCQUFHO0FBQUMsdUJBQU8sZUFBZSxFQUFFLFdBQVUsVUFBUyxFQUFDLEtBQUksRUFBRSxVQUFVLFdBQVU7QUFBQyx5QkFBTyxLQUFLLFVBQVU7QUFBQSxnQkFBQyxHQUFFLDhFQUE2RSxTQUFTLEVBQUMsQ0FBQztBQUFBLGNBQUMsU0FBT0csSUFBTjtBQUFBLGNBQVM7QUFBQSxZQUFDLEVBQUU7QUFBRSxnQkFBSTtBQUFFLDBCQUFZLE9BQU8sVUFBUSxPQUFPLGVBQWEsY0FBWSxPQUFPLFNBQVMsVUFBVSxPQUFPLFdBQVcsS0FBRyxJQUFFLFNBQVMsVUFBVSxPQUFPLFdBQVcsR0FBRSxPQUFPLGVBQWUsR0FBRSxPQUFPLGFBQVksRUFBQyxPQUFNLFNBQVNBLElBQUU7QUFBQyxxQkFBTSxDQUFDLENBQUMsRUFBRSxLQUFLLE1BQUtBLEVBQUMsS0FBRyxFQUFFLFNBQU8sTUFBSUEsTUFBR0EsR0FBRSwwQkFBMEI7QUFBQSxZQUFDLEVBQUMsQ0FBQyxLQUFHLElBQUUsU0FBU0EsSUFBRTtBQUFDLHFCQUFPQSxjQUFhO0FBQUEsWUFBSSxHQUFFLEVBQUUsVUFBVSxPQUFLLFdBQVU7QUFBQyxnQkFBRSxNQUFLLElBQUksR0FBQztBQUFBLFlBQUMsR0FBRSxFQUFFLFVBQVUsUUFBTSxTQUFTQSxJQUFFSCxJQUFFRCxJQUFFO0FBQUMsa0JBQUlFLEtBQUUsS0FBSyxnQkFBZUMsS0FBRSxPQUFHSSxLQUFFLENBQUNMLEdBQUUsY0FBWSxFQUFFRSxFQUFDO0FBQUUscUJBQU9HLE1BQUcsQ0FBQyxFQUFFLFNBQVNILEVBQUMsTUFBSUEsS0FBRSxFQUFFQSxFQUFDLElBQUcsY0FBWSxPQUFPSCxPQUFJRCxLQUFFQyxJQUFFQSxLQUFFLE9BQU1NLEtBQUVOLEtBQUUsV0FBUyxDQUFDQSxPQUFJQSxLQUFFQyxHQUFFLGtCQUFpQixjQUFZLE9BQU9GLE9BQUlBLEtBQUUsSUFBR0UsR0FBRSxTQUFPLEVBQUUsTUFBS0YsRUFBQyxLQUFHTyxNQUFHLEVBQUUsTUFBS0wsSUFBRUUsSUFBRUosRUFBQyxPQUFLRSxHQUFFLGFBQVlDLEtBQUUsRUFBRSxNQUFLRCxJQUFFSyxJQUFFSCxJQUFFSCxJQUFFRCxFQUFDLElBQUdHO0FBQUEsWUFBQyxHQUFFLEVBQUUsVUFBVSxPQUFLLFdBQVU7QUFBQyxtQkFBSyxlQUFlO0FBQUEsWUFBUSxHQUFFLEVBQUUsVUFBVSxTQUFPLFdBQVU7QUFBQyxrQkFBSUMsS0FBRSxLQUFLO0FBQWUsY0FBQUEsR0FBRSxXQUFTQSxHQUFFLFVBQVMsQ0FBQ0EsR0FBRSxXQUFTLENBQUNBLEdBQUUsVUFBUSxDQUFDQSxHQUFFLG9CQUFrQkEsR0FBRSxtQkFBaUIsRUFBRSxNQUFLQSxFQUFDO0FBQUEsWUFBRSxHQUFFLEVBQUUsVUFBVSxxQkFBbUIsU0FBU0EsSUFBRTtBQUFDLGtCQUFHLFlBQVUsT0FBT0EsT0FBSUEsS0FBRUEsR0FBRSxZQUFZLElBQUcsRUFBRSxLQUFHLENBQUMsT0FBTSxRQUFPLFNBQVEsU0FBUSxVQUFTLFVBQVMsUUFBTyxTQUFRLFdBQVUsWUFBVyxLQUFLLEVBQUUsU0FBU0EsS0FBRSxJQUFJLFlBQVksQ0FBQztBQUFHLHNCQUFNLElBQUksRUFBRUEsRUFBQztBQUFFLHFCQUFPLEtBQUssZUFBZSxrQkFBZ0JBLElBQUU7QUFBQSxZQUFJLEdBQUUsT0FBTyxlQUFlLEVBQUUsV0FBVSxrQkFBaUIsRUFBQyxZQUFXLE9BQUcsS0FBSSxXQUFVO0FBQUMscUJBQU8sS0FBSyxrQkFBZ0IsS0FBSyxlQUFlLFVBQVU7QUFBQSxZQUFDLEVBQUMsQ0FBQyxHQUFFLE9BQU8sZUFBZSxFQUFFLFdBQVUseUJBQXdCLEVBQUMsWUFBVyxPQUFHLEtBQUksV0FBVTtBQUFDLHFCQUFPLEtBQUssZUFBZTtBQUFBLFlBQWEsRUFBQyxDQUFDLEdBQUUsRUFBRSxVQUFVLFNBQU8sU0FBU0EsSUFBRUgsSUFBRUQsSUFBRTtBQUFDLGNBQUFBLEdBQUUsSUFBSSxFQUFFLFVBQVUsQ0FBQztBQUFBLFlBQUMsR0FBRSxFQUFFLFVBQVUsVUFBUSxNQUFLLEVBQUUsVUFBVSxNQUFJLFNBQVNJLElBQUVILElBQUVELElBQUU7QUFBQyxrQkFBSUUsS0FBRSxLQUFLO0FBQWUscUJBQU0sY0FBWSxPQUFPRSxNQUFHSixLQUFFSSxJQUFFQSxLQUFFLE1BQUtILEtBQUUsUUFBTSxjQUFZLE9BQU9BLE9BQUlELEtBQUVDLElBQUVBLEtBQUUsT0FBTSxTQUFPRyxNQUFHLFdBQVNBLE1BQUcsS0FBSyxNQUFNQSxJQUFFSCxFQUFDLEdBQUVDLEdBQUUsV0FBU0EsR0FBRSxTQUFPLEdBQUUsS0FBSyxPQUFPLElBQUdBLEdBQUUsVUFBUSxFQUFFLE1BQUtBLElBQUVGLEVBQUMsR0FBRTtBQUFBLFlBQUksR0FBRSxPQUFPLGVBQWUsRUFBRSxXQUFVLGtCQUFpQixFQUFDLFlBQVcsT0FBRyxLQUFJLFdBQVU7QUFBQyxxQkFBTyxLQUFLLGVBQWU7QUFBQSxZQUFNLEVBQUMsQ0FBQyxHQUFFLE9BQU8sZUFBZSxFQUFFLFdBQVUsYUFBWSxFQUFDLFlBQVcsT0FBRyxLQUFJLFdBQVU7QUFBQyxxQkFBTyxXQUFTLEtBQUssa0JBQWdCLEtBQUssZUFBZTtBQUFBLFlBQVMsR0FBRSxLQUFJLFNBQVNJLElBQUU7QUFBQyxtQkFBSyxtQkFBaUIsS0FBSyxlQUFlLFlBQVVBO0FBQUEsWUFBRSxFQUFDLENBQUMsR0FBRSxFQUFFLFVBQVUsVUFBUSxFQUFFLFNBQVEsRUFBRSxVQUFVLGFBQVcsRUFBRSxXQUFVLEVBQUUsVUFBVSxXQUFTLFNBQVNBLElBQUVILElBQUU7QUFBQyxjQUFBQSxHQUFFRyxFQUFDO0FBQUEsWUFBQztBQUFBLFVBQUMsR0FBRyxLQUFLLElBQUk7QUFBQSxRQUFDLEdBQUcsS0FBSyxNQUFLLEVBQUUsVUFBVSxHQUFFLGVBQWEsT0FBTyxTQUFPLGVBQWEsT0FBTyxPQUFLLGVBQWEsT0FBTyxTQUFPLENBQUMsSUFBRSxTQUFPLE9BQUssTUFBTTtBQUFBLE1BQUMsR0FBRSxFQUFDLGFBQVksSUFBRyxvQkFBbUIsSUFBRyw4QkFBNkIsSUFBRyw0QkFBMkIsSUFBRyw2QkFBNEIsSUFBRyxVQUFTLElBQUcsUUFBTyxHQUFFLFVBQVMsSUFBRyxrQkFBaUIsR0FBRSxDQUFDLEdBQUUsSUFBRyxDQUFDLFNBQVMsR0FBRUgsSUFBRTtBQUFDLFNBQUMsU0FBU0QsSUFBRTtBQUFDLFdBQUMsV0FBVTtBQUFDO0FBQWEscUJBQVNFLEdBQUVFLElBQUVILElBQUVELElBQUU7QUFBQyxxQkFBT0MsTUFBS0csS0FBRSxPQUFPLGVBQWVBLElBQUVILElBQUUsRUFBQyxPQUFNRCxJQUFFLFlBQVcsTUFBRyxjQUFhLE1BQUcsVUFBUyxLQUFFLENBQUMsSUFBRUksR0FBRUgsRUFBQyxJQUFFRCxJQUFFSTtBQUFBLFlBQUM7QUFBQyxxQkFBUyxFQUFFQSxJQUFFSCxJQUFFO0FBQUMscUJBQU0sRUFBQyxPQUFNRyxJQUFFLE1BQUtILEdBQUM7QUFBQSxZQUFDO0FBQUMscUJBQVMsRUFBRUcsSUFBRTtBQUFDLGtCQUFJSCxLQUFFRyxHQUFFLENBQUM7QUFBRSxrQkFBRyxTQUFPSCxJQUFFO0FBQUMsb0JBQUlELEtBQUVJLEdBQUUsQ0FBQyxFQUFFLEtBQUs7QUFBRSx5QkFBT0osT0FBSUksR0FBRSxDQUFDLElBQUUsTUFBS0EsR0FBRSxDQUFDLElBQUUsTUFBS0EsR0FBRSxDQUFDLElBQUUsTUFBS0gsR0FBRSxFQUFFRCxJQUFFLEtBQUUsQ0FBQztBQUFBLGNBQUU7QUFBQSxZQUFDO0FBQUMscUJBQVMsRUFBRUksSUFBRTtBQUFDLGNBQUFKLEdBQUUsU0FBUyxHQUFFSSxFQUFDO0FBQUEsWUFBQztBQUFDLHFCQUFTLEVBQUVBLElBQUVILElBQUU7QUFBQyxxQkFBTyxTQUFTRCxJQUFFRSxJQUFFO0FBQUMsZ0JBQUFFLEdBQUUsS0FBSyxXQUFVO0FBQUMseUJBQU9ILEdBQUUsQ0FBQyxJQUFFLEtBQUtELEdBQUUsRUFBRSxRQUFPLElBQUUsQ0FBQyxJQUFFLEtBQUtDLEdBQUUsQ0FBQyxFQUFFRCxJQUFFRSxFQUFDO0FBQUEsZ0JBQUMsR0FBRUEsRUFBQztBQUFBLGNBQUM7QUFBQSxZQUFDO0FBQUMsZ0JBQUksR0FBRSxJQUFFLEVBQUUsaUJBQWlCLEdBQUUsSUFBRSxPQUFPLGFBQWEsR0FBRSxJQUFFLE9BQU8sWUFBWSxHQUFFLElBQUUsT0FBTyxPQUFPLEdBQUUsSUFBRSxPQUFPLE9BQU8sR0FBRSxJQUFFLE9BQU8sYUFBYSxHQUFFLElBQUUsT0FBTyxlQUFlLEdBQUUsSUFBRSxPQUFPLFFBQVEsR0FBRSxJQUFFLE9BQU8sZUFBZSxXQUFVO0FBQUEsWUFBQyxDQUFDLEdBQUUsSUFBRSxPQUFPLGdCQUFnQixJQUFFLEVBQUMsSUFBSSxTQUFRO0FBQUMscUJBQU8sS0FBSyxDQUFDO0FBQUEsWUFBQyxHQUFFLE1BQUssV0FBVTtBQUFDLGtCQUFJRSxLQUFFLE1BQUtILEtBQUUsS0FBSyxDQUFDO0FBQUUsa0JBQUcsU0FBT0E7QUFBRSx1QkFBTyxRQUFRLE9BQU9BLEVBQUM7QUFBRSxrQkFBRyxLQUFLLENBQUM7QUFBRSx1QkFBTyxRQUFRLFFBQVEsRUFBRSxRQUFPLElBQUUsQ0FBQztBQUFFLGtCQUFHLEtBQUssQ0FBQyxFQUFFO0FBQVUsdUJBQU8sSUFBSSxRQUFRLFNBQVNBLElBQUVDLElBQUU7QUFBQyxrQkFBQUYsR0FBRSxTQUFTLFdBQVU7QUFBQyxvQkFBQUksR0FBRSxDQUFDLElBQUVGLEdBQUVFLEdBQUUsQ0FBQyxDQUFDLElBQUVILEdBQUUsRUFBRSxRQUFPLElBQUUsQ0FBQztBQUFBLGtCQUFDLENBQUM7QUFBQSxnQkFBQyxDQUFDO0FBQUUsa0JBQUlDLElBQUVHLEtBQUUsS0FBSyxDQUFDO0FBQUUsa0JBQUdBO0FBQUUsZ0JBQUFILEtBQUUsSUFBSSxRQUFRLEVBQUVHLElBQUUsSUFBSSxDQUFDO0FBQUEsbUJBQU07QUFBQyxvQkFBSVEsS0FBRSxLQUFLLENBQUMsRUFBRSxLQUFLO0FBQUUsb0JBQUcsU0FBT0E7QUFBRSx5QkFBTyxRQUFRLFFBQVEsRUFBRUEsSUFBRSxLQUFFLENBQUM7QUFBRSxnQkFBQVgsS0FBRSxJQUFJLFFBQVEsS0FBSyxDQUFDLENBQUM7QUFBQSxjQUFDO0FBQUMscUJBQU8sS0FBSyxDQUFDLElBQUVBLElBQUVBO0FBQUEsWUFBQyxFQUFDLEdBQUVBLEdBQUUsR0FBRSxPQUFPLGVBQWMsV0FBVTtBQUFDLHFCQUFPO0FBQUEsWUFBSSxDQUFDLEdBQUVBLEdBQUUsR0FBRSxVQUFTLFdBQVU7QUFBQyxrQkFBSUUsS0FBRTtBQUFLLHFCQUFPLElBQUksUUFBUSxTQUFTSCxJQUFFRCxJQUFFO0FBQUMsZ0JBQUFJLEdBQUUsQ0FBQyxFQUFFLFFBQVEsTUFBSyxTQUFTQSxJQUFFO0FBQUMseUJBQU9BLEtBQUUsS0FBS0osR0FBRUksRUFBQyxJQUFFLEtBQUtILEdBQUUsRUFBRSxRQUFPLElBQUUsQ0FBQztBQUFBLGdCQUFDLENBQUM7QUFBQSxjQUFDLENBQUM7QUFBQSxZQUFDLENBQUMsR0FBRSxJQUFHLENBQUM7QUFBRSxZQUFBQSxHQUFFLFVBQVEsU0FBU0csSUFBRTtBQUFDLGtCQUFJSCxJQUFFRCxLQUFFLE9BQU8sT0FBTyxJQUFHQyxLQUFFLENBQUMsR0FBRUMsR0FBRUQsSUFBRSxHQUFFLEVBQUMsT0FBTUcsSUFBRSxVQUFTLEtBQUUsQ0FBQyxHQUFFRixHQUFFRCxJQUFFLEdBQUUsRUFBQyxPQUFNLE1BQUssVUFBUyxLQUFFLENBQUMsR0FBRUMsR0FBRUQsSUFBRSxHQUFFLEVBQUMsT0FBTSxNQUFLLFVBQVMsS0FBRSxDQUFDLEdBQUVDLEdBQUVELElBQUUsR0FBRSxFQUFDLE9BQU0sTUFBSyxVQUFTLEtBQUUsQ0FBQyxHQUFFQyxHQUFFRCxJQUFFLEdBQUUsRUFBQyxPQUFNRyxHQUFFLGVBQWUsWUFBVyxVQUFTLEtBQUUsQ0FBQyxHQUFFRixHQUFFRCxJQUFFLEdBQUUsRUFBQyxPQUFNLFNBQVNHLElBQUVILElBQUU7QUFBQyxvQkFBSUMsS0FBRUYsR0FBRSxDQUFDLEVBQUUsS0FBSztBQUFFLGdCQUFBRSxNQUFHRixHQUFFLENBQUMsSUFBRSxNQUFLQSxHQUFFLENBQUMsSUFBRSxNQUFLQSxHQUFFLENBQUMsSUFBRSxNQUFLSSxHQUFFLEVBQUVGLElBQUUsS0FBRSxDQUFDLE1BQUlGLEdBQUUsQ0FBQyxJQUFFSSxJQUFFSixHQUFFLENBQUMsSUFBRUM7QUFBQSxjQUFFLEdBQUUsVUFBUyxLQUFFLENBQUMsR0FBRUEsR0FBRTtBQUFFLHFCQUFPRCxHQUFFLENBQUMsSUFBRSxNQUFLLEVBQUVJLElBQUUsU0FBU0EsSUFBRTtBQUFDLG9CQUFHQSxNQUFHLGlDQUErQkEsR0FBRSxNQUFLO0FBQUMsc0JBQUlILEtBQUVELEdBQUUsQ0FBQztBQUFFLHlCQUFPLFNBQU9DLE9BQUlELEdBQUUsQ0FBQyxJQUFFLE1BQUtBLEdBQUUsQ0FBQyxJQUFFLE1BQUtBLEdBQUUsQ0FBQyxJQUFFLE1BQUtDLEdBQUVHLEVBQUMsSUFBRyxNQUFLSixHQUFFLENBQUMsSUFBRUk7QUFBQSxnQkFBRTtBQUFDLG9CQUFJRixLQUFFRixHQUFFLENBQUM7QUFBRSx5QkFBT0UsT0FBSUYsR0FBRSxDQUFDLElBQUUsTUFBS0EsR0FBRSxDQUFDLElBQUUsTUFBS0EsR0FBRSxDQUFDLElBQUUsTUFBS0UsR0FBRSxFQUFFLFFBQU8sSUFBRSxDQUFDLElBQUdGLEdBQUUsQ0FBQyxJQUFFO0FBQUEsY0FBRSxDQUFDLEdBQUVJLEdBQUUsR0FBRyxZQUFXLEVBQUUsS0FBSyxNQUFLSixFQUFDLENBQUMsR0FBRUE7QUFBQSxZQUFDO0FBQUEsVUFBQyxHQUFHLEtBQUssSUFBSTtBQUFBLFFBQUMsR0FBRyxLQUFLLE1BQUssRUFBRSxVQUFVLENBQUM7QUFBQSxNQUFDLEdBQUUsRUFBQyxtQkFBa0IsSUFBRyxVQUFTLEdBQUUsQ0FBQyxHQUFFLElBQUcsQ0FBQyxTQUFTLEdBQUVDLElBQUU7QUFBQztBQUFhLGlCQUFTRCxHQUFFSSxJQUFFSCxJQUFFO0FBQUMsY0FBSUQsS0FBRSxPQUFPLEtBQUtJLEVBQUM7QUFBRSxjQUFHLE9BQU8sdUJBQXNCO0FBQUMsZ0JBQUlGLEtBQUUsT0FBTyxzQkFBc0JFLEVBQUM7QUFBRSxZQUFBSCxPQUFJQyxLQUFFQSxHQUFFLE9BQU8sU0FBU0QsSUFBRTtBQUFDLHFCQUFPLE9BQU8seUJBQXlCRyxJQUFFSCxFQUFDLEVBQUU7QUFBQSxZQUFVLENBQUMsSUFBR0QsR0FBRSxLQUFLLE1BQU1BLElBQUVFLEVBQUM7QUFBQSxVQUFDO0FBQUMsaUJBQU9GO0FBQUEsUUFBQztBQUFDLGlCQUFTRSxHQUFFRSxJQUFFO0FBQUMsbUJBQVFILElBQUVDLEtBQUUsR0FBRUEsS0FBRSxVQUFVLFFBQU9BO0FBQUksWUFBQUQsS0FBRSxRQUFNLFVBQVVDLEVBQUMsSUFBRSxDQUFDLElBQUUsVUFBVUEsRUFBQyxHQUFFQSxLQUFFLElBQUVGLEdBQUUsT0FBT0MsRUFBQyxHQUFFLElBQUUsRUFBRSxRQUFRLFNBQVNELElBQUU7QUFBQyxnQkFBRUksSUFBRUosSUFBRUMsR0FBRUQsRUFBQyxDQUFDO0FBQUEsWUFBQyxDQUFDLElBQUUsT0FBTyw0QkFBMEIsT0FBTyxpQkFBaUJJLElBQUUsT0FBTywwQkFBMEJILEVBQUMsQ0FBQyxJQUFFRCxHQUFFLE9BQU9DLEVBQUMsQ0FBQyxFQUFFLFFBQVEsU0FBU0QsSUFBRTtBQUFDLHFCQUFPLGVBQWVJLElBQUVKLElBQUUsT0FBTyx5QkFBeUJDLElBQUVELEVBQUMsQ0FBQztBQUFBLFlBQUMsQ0FBQztBQUFFLGlCQUFPSTtBQUFBLFFBQUM7QUFBQyxpQkFBUyxFQUFFQSxJQUFFSCxJQUFFRCxJQUFFO0FBQUMsaUJBQU9DLE1BQUtHLEtBQUUsT0FBTyxlQUFlQSxJQUFFSCxJQUFFLEVBQUMsT0FBTUQsSUFBRSxZQUFXLE1BQUcsY0FBYSxNQUFHLFVBQVMsS0FBRSxDQUFDLElBQUVJLEdBQUVILEVBQUMsSUFBRUQsSUFBRUk7QUFBQSxRQUFDO0FBQUMsaUJBQVMsRUFBRUEsSUFBRUgsSUFBRTtBQUFDLGNBQUcsRUFBRUcsY0FBYUg7QUFBRyxrQkFBTSxJQUFJLFVBQVUsbUNBQW1DO0FBQUEsUUFBQztBQUFDLGlCQUFTLEVBQUVHLElBQUVILElBQUU7QUFBQyxtQkFBUUQsSUFBRUUsS0FBRSxHQUFFQSxLQUFFRCxHQUFFLFFBQU9DO0FBQUksWUFBQUYsS0FBRUMsR0FBRUMsRUFBQyxHQUFFRixHQUFFLGFBQVdBLEdBQUUsY0FBWSxPQUFHQSxHQUFFLGVBQWEsTUFBRyxXQUFVQSxPQUFJQSxHQUFFLFdBQVMsT0FBSSxPQUFPLGVBQWVJLElBQUVKLEdBQUUsS0FBSUEsRUFBQztBQUFBLFFBQUM7QUFBQyxpQkFBUyxFQUFFSSxJQUFFSCxJQUFFRCxJQUFFO0FBQUMsaUJBQU9DLE1BQUcsRUFBRUcsR0FBRSxXQUFVSCxFQUFDLEdBQUVELE1BQUcsRUFBRUksSUFBRUosRUFBQyxHQUFFSTtBQUFBLFFBQUM7QUFBQyxpQkFBUyxFQUFFQSxJQUFFSCxJQUFFRCxJQUFFO0FBQUMsWUFBRSxVQUFVLEtBQUssS0FBS0ksSUFBRUgsSUFBRUQsRUFBQztBQUFBLFFBQUM7QUFBQyxZQUFJLElBQUUsRUFBRSxRQUFRLEdBQUUsSUFBRSxFQUFFLFFBQU8sSUFBRSxFQUFFLE1BQU0sR0FBRSxJQUFFLEVBQUUsU0FBUSxJQUFFLEtBQUcsRUFBRSxVQUFRO0FBQVUsUUFBQUMsR0FBRSxVQUFRLFdBQVU7QUFBQyxtQkFBU0csS0FBRztBQUFDLGNBQUUsTUFBS0EsRUFBQyxHQUFFLEtBQUssT0FBSyxNQUFLLEtBQUssT0FBSyxNQUFLLEtBQUssU0FBTztBQUFBLFVBQUM7QUFBQyxpQkFBTyxFQUFFQSxJQUFFLENBQUMsRUFBQyxLQUFJLFFBQU8sT0FBTSxTQUFTQSxJQUFFO0FBQUMsZ0JBQUlILEtBQUUsRUFBQyxNQUFLRyxJQUFFLE1BQUssS0FBSTtBQUFFLGdCQUFFLEtBQUssU0FBTyxLQUFLLEtBQUssT0FBS0gsS0FBRSxLQUFLLE9BQUtBLElBQUUsS0FBSyxPQUFLQSxJQUFFLEVBQUUsS0FBSztBQUFBLFVBQU0sRUFBQyxHQUFFLEVBQUMsS0FBSSxXQUFVLE9BQU0sU0FBU0csSUFBRTtBQUFDLGdCQUFJSCxLQUFFLEVBQUMsTUFBS0csSUFBRSxNQUFLLEtBQUssS0FBSTtBQUFFLGtCQUFJLEtBQUssV0FBUyxLQUFLLE9BQUtILEtBQUcsS0FBSyxPQUFLQSxJQUFFLEVBQUUsS0FBSztBQUFBLFVBQU0sRUFBQyxHQUFFLEVBQUMsS0FBSSxTQUFRLE9BQU0sV0FBVTtBQUFDLGdCQUFHLE1BQUksS0FBSyxRQUFPO0FBQUMsa0JBQUlHLEtBQUUsS0FBSyxLQUFLO0FBQUsscUJBQU8sS0FBSyxPQUFLLE1BQUksS0FBSyxTQUFPLEtBQUssT0FBSyxPQUFLLEtBQUssS0FBSyxNQUFLLEVBQUUsS0FBSyxRQUFPQTtBQUFBLFlBQUM7QUFBQSxVQUFDLEVBQUMsR0FBRSxFQUFDLEtBQUksU0FBUSxPQUFNLFdBQVU7QUFBQyxpQkFBSyxPQUFLLEtBQUssT0FBSyxNQUFLLEtBQUssU0FBTztBQUFBLFVBQUMsRUFBQyxHQUFFLEVBQUMsS0FBSSxRQUFPLE9BQU0sU0FBU0EsSUFBRTtBQUFDLGdCQUFHLE1BQUksS0FBSztBQUFPLHFCQUFNO0FBQUcscUJBQVFILEtBQUUsS0FBSyxNQUFLRCxLQUFFLEtBQUdDLEdBQUUsTUFBS0EsS0FBRUEsR0FBRTtBQUFNLGNBQUFELE1BQUdJLEtBQUVILEdBQUU7QUFBSyxtQkFBT0Q7QUFBQSxVQUFDLEVBQUMsR0FBRSxFQUFDLEtBQUksVUFBUyxPQUFNLFNBQVNJLElBQUU7QUFBQyxnQkFBRyxNQUFJLEtBQUs7QUFBTyxxQkFBTyxFQUFFLE1BQU0sQ0FBQztBQUFFLHFCQUFRSCxLQUFFLEVBQUUsWUFBWUcsT0FBSSxDQUFDLEdBQUVKLEtBQUUsS0FBSyxNQUFLRSxLQUFFLEdBQUVGO0FBQUcsZ0JBQUVBLEdBQUUsTUFBS0MsSUFBRUMsRUFBQyxHQUFFQSxNQUFHRixHQUFFLEtBQUssUUFBT0EsS0FBRUEsR0FBRTtBQUFLLG1CQUFPQztBQUFBLFVBQUMsRUFBQyxHQUFFLEVBQUMsS0FBSSxXQUFVLE9BQU0sU0FBU0csSUFBRUgsSUFBRTtBQUFDLGdCQUFJRDtBQUFFLG1CQUFPSSxLQUFFLEtBQUssS0FBSyxLQUFLLFVBQVFKLEtBQUUsS0FBSyxLQUFLLEtBQUssTUFBTSxHQUFFSSxFQUFDLEdBQUUsS0FBSyxLQUFLLE9BQUssS0FBSyxLQUFLLEtBQUssTUFBTUEsRUFBQyxLQUFHQSxPQUFJLEtBQUssS0FBSyxLQUFLLFNBQU9KLEtBQUUsS0FBSyxNQUFNLElBQUVBLEtBQUVDLEtBQUUsS0FBSyxXQUFXRyxFQUFDLElBQUUsS0FBSyxXQUFXQSxFQUFDLEdBQUVKO0FBQUEsVUFBQyxFQUFDLEdBQUUsRUFBQyxLQUFJLFNBQVEsT0FBTSxXQUFVO0FBQUMsbUJBQU8sS0FBSyxLQUFLO0FBQUEsVUFBSSxFQUFDLEdBQUUsRUFBQyxLQUFJLGNBQWEsT0FBTSxTQUFTSSxJQUFFO0FBQUMsZ0JBQUlILEtBQUUsS0FBSyxNQUFLQyxLQUFFLEdBQUVDLEtBQUVGLEdBQUU7QUFBSyxpQkFBSUcsTUFBR0QsR0FBRSxRQUFPRixLQUFFQSxHQUFFLFFBQU07QUFBQyxrQkFBSUksS0FBRUosR0FBRSxNQUFLWSxLQUFFVCxLQUFFQyxHQUFFLFNBQU9BLEdBQUUsU0FBT0Q7QUFBRSxrQkFBR0QsTUFBR1UsT0FBSVIsR0FBRSxTQUFPQSxLQUFFQSxHQUFFLE1BQU0sR0FBRUQsRUFBQyxHQUFFQSxNQUFHUyxJQUFFLE1BQUlULElBQUU7QUFBQyxnQkFBQVMsT0FBSVIsR0FBRSxVQUFRLEVBQUVILElBQUUsS0FBSyxPQUFLRCxHQUFFLE9BQUtBLEdBQUUsT0FBSyxLQUFLLE9BQUssU0FBTyxLQUFLLE9BQUtBLElBQUVBLEdBQUUsT0FBS0ksR0FBRSxNQUFNUSxFQUFDO0FBQUc7QUFBQSxjQUFLO0FBQUMsZ0JBQUVYO0FBQUEsWUFBQztBQUFDLG1CQUFPLEtBQUssVUFBUUEsSUFBRUM7QUFBQSxVQUFDLEVBQUMsR0FBRSxFQUFDLEtBQUksY0FBYSxPQUFNLFNBQVNDLElBQUU7QUFBQyxnQkFBSUgsS0FBRSxFQUFFLFlBQVlHLEVBQUMsR0FBRUYsS0FBRSxLQUFLLE1BQUtDLEtBQUU7QUFBRSxpQkFBSUQsR0FBRSxLQUFLLEtBQUtELEVBQUMsR0FBRUcsTUFBR0YsR0FBRSxLQUFLLFFBQU9BLEtBQUVBLEdBQUUsUUFBTTtBQUFDLGtCQUFJRyxLQUFFSCxHQUFFLE1BQUtXLEtBQUVULEtBQUVDLEdBQUUsU0FBT0EsR0FBRSxTQUFPRDtBQUFFLGtCQUFHQyxHQUFFLEtBQUtKLElBQUVBLEdBQUUsU0FBT0csSUFBRSxHQUFFUyxFQUFDLEdBQUVULE1BQUdTLElBQUUsTUFBSVQsSUFBRTtBQUFDLGdCQUFBUyxPQUFJUixHQUFFLFVBQVEsRUFBRUYsSUFBRSxLQUFLLE9BQUtELEdBQUUsT0FBS0EsR0FBRSxPQUFLLEtBQUssT0FBSyxTQUFPLEtBQUssT0FBS0EsSUFBRUEsR0FBRSxPQUFLRyxHQUFFLE1BQU1RLEVBQUM7QUFBRztBQUFBLGNBQUs7QUFBQyxnQkFBRVY7QUFBQSxZQUFDO0FBQUMsbUJBQU8sS0FBSyxVQUFRQSxJQUFFRjtBQUFBLFVBQUMsRUFBQyxHQUFFLEVBQUMsS0FBSSxHQUFFLE9BQU0sU0FBU0csSUFBRUgsSUFBRTtBQUFDLG1CQUFPLEVBQUUsTUFBS0MsR0FBRSxDQUFDLEdBQUVELElBQUUsRUFBQyxPQUFNLEdBQUUsZUFBYyxNQUFFLENBQUMsQ0FBQztBQUFBLFVBQUMsRUFBQyxDQUFDLENBQUMsR0FBRUc7QUFBQSxRQUFDLEVBQUU7QUFBQSxNQUFDLEdBQUUsRUFBQyxRQUFPLEdBQUUsTUFBSyxFQUFDLENBQUMsR0FBRSxJQUFHLENBQUMsU0FBUyxHQUFFSCxJQUFFO0FBQUMsU0FBQyxTQUFTRyxJQUFFO0FBQUMsV0FBQyxXQUFVO0FBQUM7QUFBYSxxQkFBU0osR0FBRUksSUFBRUgsSUFBRTtBQUFDLGdCQUFFRyxJQUFFSCxFQUFDLEdBQUVDLEdBQUVFLEVBQUM7QUFBQSxZQUFDO0FBQUMscUJBQVNGLEdBQUVFLElBQUU7QUFBQyxjQUFBQSxHQUFFLGtCQUFnQixDQUFDQSxHQUFFLGVBQWUsYUFBV0EsR0FBRSxrQkFBZ0IsQ0FBQ0EsR0FBRSxlQUFlLGFBQVdBLEdBQUUsS0FBSyxPQUFPO0FBQUEsWUFBQztBQUFDLHFCQUFTLEVBQUVBLElBQUVILElBQUU7QUFBQyxjQUFBRyxHQUFFLEtBQUssU0FBUUgsRUFBQztBQUFBLFlBQUM7QUFBQyxZQUFBQSxHQUFFLFVBQVEsRUFBQyxTQUFRLFNBQVNBLElBQUUsR0FBRTtBQUFDLGtCQUFJLElBQUUsTUFBSyxJQUFFLEtBQUssa0JBQWdCLEtBQUssZUFBZSxXQUFVLElBQUUsS0FBSyxrQkFBZ0IsS0FBSyxlQUFlO0FBQVUscUJBQU8sS0FBRyxLQUFHLElBQUUsRUFBRUEsRUFBQyxJQUFFQSxPQUFJLEtBQUssaUJBQWUsQ0FBQyxLQUFLLGVBQWUsaUJBQWUsS0FBSyxlQUFlLGVBQWEsTUFBR0csR0FBRSxTQUFTLEdBQUUsTUFBS0gsRUFBQyxLQUFHRyxHQUFFLFNBQVMsR0FBRSxNQUFLSCxFQUFDLElBQUcsU0FBTyxLQUFLLG1CQUFpQixLQUFLLGVBQWUsWUFBVSxPQUFJLEtBQUssbUJBQWlCLEtBQUssZUFBZSxZQUFVLE9BQUksS0FBSyxTQUFTQSxNQUFHLE1BQUssU0FBU0EsSUFBRTtBQUFDLGlCQUFDLEtBQUdBLEtBQUUsRUFBRSxpQkFBZSxFQUFFLGVBQWUsZUFBYUcsR0FBRSxTQUFTRixJQUFFLENBQUMsS0FBRyxFQUFFLGVBQWUsZUFBYSxNQUFHRSxHQUFFLFNBQVNKLElBQUUsR0FBRUMsRUFBQyxLQUFHRyxHQUFFLFNBQVNKLElBQUUsR0FBRUMsRUFBQyxJQUFFLEtBQUdHLEdBQUUsU0FBU0YsSUFBRSxDQUFDLEdBQUUsRUFBRUQsRUFBQyxLQUFHRyxHQUFFLFNBQVNGLElBQUUsQ0FBQztBQUFBLGNBQUMsQ0FBQyxHQUFFO0FBQUEsWUFBSyxHQUFFLFdBQVUsV0FBVTtBQUFDLG1CQUFLLG1CQUFpQixLQUFLLGVBQWUsWUFBVSxPQUFHLEtBQUssZUFBZSxVQUFRLE9BQUcsS0FBSyxlQUFlLFFBQU0sT0FBRyxLQUFLLGVBQWUsYUFBVyxRQUFJLEtBQUssbUJBQWlCLEtBQUssZUFBZSxZQUFVLE9BQUcsS0FBSyxlQUFlLFFBQU0sT0FBRyxLQUFLLGVBQWUsU0FBTyxPQUFHLEtBQUssZUFBZSxjQUFZLE9BQUcsS0FBSyxlQUFlLGNBQVksT0FBRyxLQUFLLGVBQWUsV0FBUyxPQUFHLEtBQUssZUFBZSxlQUFhO0FBQUEsWUFBRyxHQUFFLGdCQUFlLFNBQVNFLElBQUVILElBQUU7QUFBQyxrQkFBSUQsS0FBRUksR0FBRSxnQkFBZUYsS0FBRUUsR0FBRTtBQUFlLGNBQUFKLE1BQUdBLEdBQUUsZUFBYUUsTUFBR0EsR0FBRSxjQUFZRSxHQUFFLFFBQVFILEVBQUMsSUFBRUcsR0FBRSxLQUFLLFNBQVFILEVBQUM7QUFBQSxZQUFDLEVBQUM7QUFBQSxVQUFDLEdBQUcsS0FBSyxJQUFJO0FBQUEsUUFBQyxHQUFHLEtBQUssTUFBSyxFQUFFLFVBQVUsQ0FBQztBQUFBLE1BQUMsR0FBRSxFQUFDLFVBQVMsR0FBRSxDQUFDLEdBQUUsSUFBRyxDQUFDLFNBQVMsR0FBRUEsSUFBRTtBQUFDO0FBQWEsaUJBQVNELEdBQUVJLElBQUU7QUFBQyxjQUFJSCxLQUFFO0FBQUcsaUJBQU8sV0FBVTtBQUFDLGdCQUFHLENBQUNBLElBQUU7QUFBQyxjQUFBQSxLQUFFO0FBQUcsdUJBQVFELEtBQUUsVUFBVSxRQUFPRSxLQUFFLE1BQU1GLEVBQUMsR0FBRUcsS0FBRSxHQUFFQSxLQUFFSCxJQUFFRztBQUFJLGdCQUFBRCxHQUFFQyxFQUFDLElBQUUsVUFBVUEsRUFBQztBQUFFLGNBQUFDLEdBQUUsTUFBTSxNQUFLRixFQUFDO0FBQUEsWUFBQztBQUFBLFVBQUM7QUFBQSxRQUFDO0FBQUMsaUJBQVNBLEtBQUc7QUFBQSxRQUFDO0FBQUMsaUJBQVMsRUFBRUUsSUFBRTtBQUFDLGlCQUFPQSxHQUFFLGFBQVcsY0FBWSxPQUFPQSxHQUFFO0FBQUEsUUFBSztBQUFDLGlCQUFTLEVBQUVBLElBQUVILElBQUUsR0FBRTtBQUFDLGNBQUcsY0FBWSxPQUFPQTtBQUFFLG1CQUFPLEVBQUVHLElBQUUsTUFBS0gsRUFBQztBQUFFLFVBQUFBLE9BQUlBLEtBQUUsQ0FBQyxJQUFHLElBQUVELEdBQUUsS0FBR0UsRUFBQztBQUFFLGNBQUksSUFBRUQsR0FBRSxZQUFVLFVBQUtBLEdBQUUsWUFBVUcsR0FBRSxVQUFTLElBQUVILEdBQUUsWUFBVSxVQUFLQSxHQUFFLFlBQVVHLEdBQUUsVUFBUyxJQUFFLFdBQVU7QUFBQyxZQUFBQSxHQUFFLFlBQVUsRUFBRTtBQUFBLFVBQUMsR0FBRSxJQUFFQSxHQUFFLGtCQUFnQkEsR0FBRSxlQUFlLFVBQVMsSUFBRSxXQUFVO0FBQUMsZ0JBQUUsT0FBRyxJQUFFLE1BQUcsS0FBRyxFQUFFLEtBQUtBLEVBQUM7QUFBQSxVQUFDLEdBQUUsSUFBRUEsR0FBRSxrQkFBZ0JBLEdBQUUsZUFBZSxZQUFXLElBQUUsV0FBVTtBQUFDLGdCQUFFLE9BQUcsSUFBRSxNQUFHLEtBQUcsRUFBRSxLQUFLQSxFQUFDO0FBQUEsVUFBQyxHQUFFLElBQUUsU0FBU0gsSUFBRTtBQUFDLGNBQUUsS0FBS0csSUFBRUgsRUFBQztBQUFBLFVBQUMsR0FBRSxJQUFFLFdBQVU7QUFBQyxnQkFBSUE7QUFBRSxtQkFBTyxLQUFHLENBQUMsS0FBR0csR0FBRSxrQkFBZ0JBLEdBQUUsZUFBZSxVQUFRSCxLQUFFLElBQUksTUFBRyxFQUFFLEtBQUtHLElBQUVILEVBQUMsS0FBRyxLQUFHLENBQUMsS0FBR0csR0FBRSxrQkFBZ0JBLEdBQUUsZUFBZSxVQUFRSCxLQUFFLElBQUksTUFBRyxFQUFFLEtBQUtHLElBQUVILEVBQUMsS0FBRztBQUFBLFVBQU0sR0FBRSxJQUFFLFdBQVU7QUFBQyxZQUFBRyxHQUFFLElBQUksR0FBRyxVQUFTLENBQUM7QUFBQSxVQUFDO0FBQUUsaUJBQU8sRUFBRUEsRUFBQyxLQUFHQSxHQUFFLEdBQUcsWUFBVyxDQUFDLEdBQUVBLEdBQUUsR0FBRyxTQUFRLENBQUMsR0FBRUEsR0FBRSxNQUFJLEVBQUUsSUFBRUEsR0FBRSxHQUFHLFdBQVUsQ0FBQyxLQUFHLEtBQUcsQ0FBQ0EsR0FBRSxtQkFBaUJBLEdBQUUsR0FBRyxPQUFNLENBQUMsR0FBRUEsR0FBRSxHQUFHLFNBQVEsQ0FBQyxJQUFHQSxHQUFFLEdBQUcsT0FBTSxDQUFDLEdBQUVBLEdBQUUsR0FBRyxVQUFTLENBQUMsR0FBRSxVQUFLSCxHQUFFLFNBQU9HLEdBQUUsR0FBRyxTQUFRLENBQUMsR0FBRUEsR0FBRSxHQUFHLFNBQVEsQ0FBQyxHQUFFLFdBQVU7QUFBQyxZQUFBQSxHQUFFLGVBQWUsWUFBVyxDQUFDLEdBQUVBLEdBQUUsZUFBZSxTQUFRLENBQUMsR0FBRUEsR0FBRSxlQUFlLFdBQVUsQ0FBQyxHQUFFQSxHQUFFLE9BQUtBLEdBQUUsSUFBSSxlQUFlLFVBQVMsQ0FBQyxHQUFFQSxHQUFFLGVBQWUsT0FBTSxDQUFDLEdBQUVBLEdBQUUsZUFBZSxTQUFRLENBQUMsR0FBRUEsR0FBRSxlQUFlLFVBQVMsQ0FBQyxHQUFFQSxHQUFFLGVBQWUsT0FBTSxDQUFDLEdBQUVBLEdBQUUsZUFBZSxTQUFRLENBQUMsR0FBRUEsR0FBRSxlQUFlLFNBQVEsQ0FBQztBQUFBLFVBQUM7QUFBQSxRQUFDO0FBQUMsWUFBSSxJQUFFLEVBQUUsaUJBQWlCLEVBQUUsTUFBTTtBQUEyQixRQUFBSCxHQUFFLFVBQVE7QUFBQSxNQUFDLEdBQUUsRUFBQyxtQkFBa0IsR0FBRSxDQUFDLEdBQUUsSUFBRyxDQUFDLFNBQVMsR0FBRUEsSUFBRTtBQUFDLFFBQUFBLEdBQUUsVUFBUSxXQUFVO0FBQUMsZ0JBQU0sSUFBSSxNQUFNLCtDQUErQztBQUFBLFFBQUM7QUFBQSxNQUFDLEdBQUUsQ0FBQyxDQUFDLEdBQUUsSUFBRyxDQUFDLFNBQVMsR0FBRUEsSUFBRTtBQUFDO0FBQWEsaUJBQVNELEdBQUVJLElBQUU7QUFBQyxjQUFJSCxLQUFFO0FBQUcsaUJBQU8sV0FBVTtBQUFDLFlBQUFBLE9BQUlBLEtBQUUsTUFBR0csR0FBRSxNQUFNLFFBQU8sU0FBUztBQUFBLFVBQUU7QUFBQSxRQUFDO0FBQUMsaUJBQVNGLEdBQUVFLElBQUU7QUFBQyxjQUFHQTtBQUFFLGtCQUFNQTtBQUFBLFFBQUM7QUFBQyxpQkFBUyxFQUFFQSxJQUFFO0FBQUMsaUJBQU9BLEdBQUUsYUFBVyxjQUFZLE9BQU9BLEdBQUU7QUFBQSxRQUFLO0FBQUMsaUJBQVMsRUFBRUgsSUFBRUMsSUFBRUcsSUFBRVEsSUFBRTtBQUFDLFVBQUFBLEtBQUViLEdBQUVhLEVBQUM7QUFBRSxjQUFJUCxLQUFFO0FBQUcsVUFBQUwsR0FBRSxHQUFHLFNBQVEsV0FBVTtBQUFDLFlBQUFLLEtBQUU7QUFBQSxVQUFFLENBQUMsR0FBRSxNQUFJLFdBQVMsSUFBRSxFQUFFLGlCQUFpQixJQUFHLEVBQUVMLElBQUUsRUFBQyxVQUFTQyxJQUFFLFVBQVNHLEdBQUMsR0FBRSxTQUFTRCxJQUFFO0FBQUMsbUJBQU9BLEtBQUVTLEdBQUVULEVBQUMsSUFBRSxNQUFLRSxLQUFFLE1BQUdPLEdBQUU7QUFBQSxVQUFFLENBQUM7QUFBRSxjQUFJTixLQUFFO0FBQUcsaUJBQU8sU0FBU0gsSUFBRTtBQUFDLGdCQUFHLENBQUNFO0FBQUUscUJBQU9DLEtBQUUsVUFBUUEsS0FBRSxNQUFHLEVBQUVOLEVBQUMsSUFBRUEsR0FBRSxNQUFNLElBQUUsY0FBWSxPQUFPQSxHQUFFLFVBQVFBLEdBQUUsUUFBUSxJQUFFLEtBQUtZLEdBQUVULE1BQUcsSUFBSSxFQUFFLE1BQU0sQ0FBQztBQUFBLFVBQUU7QUFBQSxRQUFDO0FBQUMsaUJBQVMsRUFBRUEsSUFBRTtBQUFDLFVBQUFBLEdBQUU7QUFBQSxRQUFDO0FBQUMsaUJBQVMsRUFBRUEsSUFBRUgsSUFBRTtBQUFDLGlCQUFPRyxHQUFFLEtBQUtILEVBQUM7QUFBQSxRQUFDO0FBQUMsaUJBQVMsRUFBRUcsSUFBRTtBQUFDLGlCQUFPQSxHQUFFLFNBQU8sY0FBWSxPQUFPQSxHQUFFQSxHQUFFLFNBQU8sQ0FBQyxJQUFFQSxHQUFFLElBQUksSUFBRUYsS0FBRUE7QUFBQSxRQUFDO0FBQUMsWUFBSSxHQUFFLElBQUUsRUFBRSxpQkFBaUIsRUFBRSxPQUFNLElBQUUsRUFBRSxrQkFBaUIsSUFBRSxFQUFFO0FBQXFCLFFBQUFELEdBQUUsVUFBUSxXQUFVO0FBQUMsbUJBQVFHLEtBQUUsVUFBVSxRQUFPSCxLQUFFLE1BQU1HLEVBQUMsR0FBRUosS0FBRSxHQUFFQSxLQUFFSSxJQUFFSjtBQUFJLFlBQUFDLEdBQUVELEVBQUMsSUFBRSxVQUFVQSxFQUFDO0FBQUUsY0FBSUUsS0FBRSxFQUFFRCxFQUFDO0FBQUUsY0FBRyxNQUFNLFFBQVFBLEdBQUUsQ0FBQyxDQUFDLE1BQUlBLEtBQUVBLEdBQUUsQ0FBQyxJQUFHLElBQUVBLEdBQUU7QUFBTyxrQkFBTSxJQUFJLEVBQUUsU0FBUztBQUFFLGNBQUlFLElBQUVLLEtBQUVQLEdBQUUsSUFBSSxTQUFTRyxJQUFFSixJQUFFO0FBQUMsZ0JBQUlNLEtBQUVOLEtBQUVDLEdBQUUsU0FBTztBQUFFLG1CQUFPLEVBQUVHLElBQUVFLElBQUUsSUFBRU4sSUFBRSxTQUFTSSxJQUFFO0FBQUMsY0FBQUQsT0FBSUEsS0FBRUMsS0FBR0EsTUFBR0ksR0FBRSxRQUFRLENBQUMsR0FBRUYsT0FBSUUsR0FBRSxRQUFRLENBQUMsR0FBRU4sR0FBRUMsRUFBQztBQUFBLFlBQUUsQ0FBQztBQUFBLFVBQUMsQ0FBQztBQUFFLGlCQUFPRixHQUFFLE9BQU8sQ0FBQztBQUFBLFFBQUM7QUFBQSxNQUFDLEdBQUUsRUFBQyxtQkFBa0IsSUFBRyxtQkFBa0IsR0FBRSxDQUFDLEdBQUUsSUFBRyxDQUFDLFNBQVMsR0FBRUQsSUFBRTtBQUFDO0FBQWEsaUJBQVNFLEdBQUVFLElBQUVILElBQUVELElBQUU7QUFBQyxpQkFBTyxRQUFNSSxHQUFFLGdCQUFjSCxLQUFFRyxHQUFFSixFQUFDLElBQUUsT0FBS0ksR0FBRTtBQUFBLFFBQWE7QUFBQyxZQUFJLElBQUUsRUFBRSxpQkFBaUIsRUFBRSxNQUFNO0FBQXNCLFFBQUFKLEdBQUUsVUFBUSxFQUFDLGtCQUFpQixTQUFTSSxJQUFFSixJQUFFLEdBQUUsR0FBRTtBQUFDLGNBQUksSUFBRUUsR0FBRUYsSUFBRSxHQUFFLENBQUM7QUFBRSxjQUFHLFFBQU0sR0FBRTtBQUFDLGdCQUFHLEVBQUUsU0FBUyxDQUFDLEtBQUcsRUFBRSxDQUFDLE1BQUksTUFBSSxJQUFFLEdBQUU7QUFBQyxrQkFBSSxJQUFFLElBQUUsSUFBRTtBQUFnQixvQkFBTSxJQUFJLEVBQUUsR0FBRSxDQUFDO0FBQUEsWUFBQztBQUFDLG1CQUFPLEVBQUUsQ0FBQztBQUFBLFVBQUM7QUFBQyxpQkFBT0ksR0FBRSxhQUFXLEtBQUc7QUFBQSxRQUFLLEVBQUM7QUFBQSxNQUFDLEdBQUUsRUFBQyxtQkFBa0IsR0FBRSxDQUFDLEdBQUUsSUFBRyxDQUFDLFNBQVMsR0FBRUgsSUFBRTtBQUFDLFFBQUFBLEdBQUUsVUFBUSxFQUFFLFFBQVEsRUFBRTtBQUFBLE1BQVksR0FBRSxFQUFDLFFBQU8sRUFBQyxDQUFDLEdBQUUsSUFBRyxDQUFDLFNBQVMsR0FBRUEsSUFBRUQsSUFBRTtBQUFDLFFBQUFBLEtBQUVDLEdBQUUsVUFBUSxFQUFFLDJCQUEyQixHQUFFRCxHQUFFLFNBQU9BLElBQUVBLEdBQUUsV0FBU0EsSUFBRUEsR0FBRSxXQUFTLEVBQUUsMkJBQTJCLEdBQUVBLEdBQUUsU0FBTyxFQUFFLHlCQUF5QixHQUFFQSxHQUFFLFlBQVUsRUFBRSw0QkFBNEIsR0FBRUEsR0FBRSxjQUFZLEVBQUUsOEJBQThCLEdBQUVBLEdBQUUsV0FBUyxFQUFFLHlDQUF5QyxHQUFFQSxHQUFFLFdBQVMsRUFBRSxvQ0FBb0M7QUFBQSxNQUFDLEdBQUUsRUFBQywyQkFBMEIsSUFBRyxnQ0FBK0IsSUFBRyw2QkFBNEIsSUFBRyw4QkFBNkIsSUFBRyw2QkFBNEIsSUFBRywyQ0FBMEMsSUFBRyxzQ0FBcUMsR0FBRSxDQUFDLEdBQUUsSUFBRyxDQUFDLFNBQVMsR0FBRUMsSUFBRUQsSUFBRTtBQUFDLGlCQUFTRSxHQUFFRSxJQUFFSCxJQUFFO0FBQUMsbUJBQVFELE1BQUtJO0FBQUUsWUFBQUgsR0FBRUQsRUFBQyxJQUFFSSxHQUFFSixFQUFDO0FBQUEsUUFBQztBQUFDLGlCQUFTLEVBQUVJLElBQUVILElBQUVELElBQUU7QUFBQyxpQkFBTyxFQUFFSSxJQUFFSCxJQUFFRCxFQUFDO0FBQUEsUUFBQztBQUFxRixZQUFJLElBQUUsRUFBRSxRQUFRLEdBQUUsSUFBRSxFQUFFO0FBQU8sVUFBRSxRQUFNLEVBQUUsU0FBTyxFQUFFLGVBQWEsRUFBRSxrQkFBZ0JDLEdBQUUsVUFBUSxLQUFHQyxHQUFFLEdBQUVGLEVBQUMsR0FBRUEsR0FBRSxTQUFPLElBQUcsRUFBRSxZQUFVLE9BQU8sT0FBTyxFQUFFLFNBQVMsR0FBRUUsR0FBRSxHQUFFLENBQUMsR0FBRSxFQUFFLE9BQUssU0FBU0UsSUFBRUgsSUFBRUQsSUFBRTtBQUFDLGNBQUcsWUFBVSxPQUFPSTtBQUFFLGtCQUFNLElBQUksVUFBVSwrQkFBK0I7QUFBRSxpQkFBTyxFQUFFQSxJQUFFSCxJQUFFRCxFQUFDO0FBQUEsUUFBQyxHQUFFLEVBQUUsUUFBTSxTQUFTSSxJQUFFSCxJQUFFRCxJQUFFO0FBQUMsY0FBRyxZQUFVLE9BQU9JO0FBQUUsa0JBQU0sSUFBSSxVQUFVLDJCQUEyQjtBQUFFLGNBQUlGLEtBQUUsRUFBRUUsRUFBQztBQUFFLGlCQUFPLFdBQVNILEtBQUVDLEdBQUUsS0FBSyxDQUFDLElBQUUsWUFBVSxPQUFPRixLQUFFRSxHQUFFLEtBQUtELElBQUVELEVBQUMsSUFBRUUsR0FBRSxLQUFLRCxFQUFDLEdBQUVDO0FBQUEsUUFBQyxHQUFFLEVBQUUsY0FBWSxTQUFTRSxJQUFFO0FBQUMsY0FBRyxZQUFVLE9BQU9BO0FBQUUsa0JBQU0sSUFBSSxVQUFVLDJCQUEyQjtBQUFFLGlCQUFPLEVBQUVBLEVBQUM7QUFBQSxRQUFDLEdBQUUsRUFBRSxrQkFBZ0IsU0FBU0EsSUFBRTtBQUFDLGNBQUcsWUFBVSxPQUFPQTtBQUFFLGtCQUFNLElBQUksVUFBVSwyQkFBMkI7QUFBRSxpQkFBTyxFQUFFLFdBQVdBLEVBQUM7QUFBQSxRQUFDO0FBQUEsTUFBQyxHQUFFLEVBQUMsUUFBTyxFQUFDLENBQUMsR0FBRSxJQUFHLENBQUMsU0FBUyxHQUFFSCxJQUFFRCxJQUFFO0FBQUM7QUFBYSxpQkFBU0UsR0FBRUUsSUFBRTtBQUFDLGNBQUcsQ0FBQ0E7QUFBRSxtQkFBTTtBQUFPLG1CQUFRSDtBQUFJLG9CQUFPRyxJQUFFO0FBQUEsY0FBQyxLQUFJO0FBQUEsY0FBTyxLQUFJO0FBQVEsdUJBQU07QUFBQSxjQUFPLEtBQUk7QUFBQSxjQUFPLEtBQUk7QUFBQSxjQUFRLEtBQUk7QUFBQSxjQUFVLEtBQUk7QUFBVyx1QkFBTTtBQUFBLGNBQVUsS0FBSTtBQUFBLGNBQVMsS0FBSTtBQUFTLHVCQUFNO0FBQUEsY0FBUyxLQUFJO0FBQUEsY0FBUyxLQUFJO0FBQUEsY0FBUSxLQUFJO0FBQU0sdUJBQU9BO0FBQUEsY0FBRTtBQUFRLG9CQUFHSDtBQUFFO0FBQU8sZ0JBQUFHLE1BQUcsS0FBR0EsSUFBRyxZQUFZLEdBQUVILEtBQUU7QUFBQSxZQUFHO0FBQUEsUUFBQztBQUFDLGlCQUFTLEVBQUVHLElBQUU7QUFBQyxjQUFJSCxLQUFFQyxHQUFFRSxFQUFDO0FBQUUsY0FBRyxZQUFVLE9BQU9ILE9BQUksRUFBRSxlQUFhLEtBQUcsQ0FBQyxFQUFFRyxFQUFDO0FBQUcsa0JBQU0sSUFBSSxNQUFNLHVCQUFxQkEsRUFBQztBQUFFLGlCQUFPSCxNQUFHRztBQUFBLFFBQUM7QUFBQyxpQkFBUyxFQUFFQSxJQUFFO0FBQUMsZUFBSyxXQUFTLEVBQUVBLEVBQUM7QUFBRSxjQUFJSDtBQUFFLGtCQUFPLEtBQUssVUFBUztBQUFBLFlBQUMsS0FBSTtBQUFVLG1CQUFLLE9BQUssR0FBRSxLQUFLLE1BQUksR0FBRUEsS0FBRTtBQUFFO0FBQUEsWUFBTSxLQUFJO0FBQU8sbUJBQUssV0FBUyxHQUFFQSxLQUFFO0FBQUU7QUFBQSxZQUFNLEtBQUk7QUFBUyxtQkFBSyxPQUFLLEdBQUUsS0FBSyxNQUFJLEdBQUVBLEtBQUU7QUFBRTtBQUFBLFlBQU07QUFBUSxxQkFBTyxLQUFLLFFBQU0sR0FBRSxNQUFLLEtBQUssTUFBSTtBQUFBLFVBQUc7QUFBQyxlQUFLLFdBQVMsR0FBRSxLQUFLLFlBQVUsR0FBRSxLQUFLLFdBQVMsRUFBRSxZQUFZQSxFQUFDO0FBQUEsUUFBQztBQUFDLGlCQUFTLEVBQUVHLElBQUU7QUFBQyxjQUFHLE9BQUtBO0FBQUUsbUJBQU87QUFBRSxpQkFBTyxLQUFHQSxNQUFHLElBQUUsSUFBRSxNQUFJQSxNQUFHLElBQUUsSUFBRSxNQUFJQSxNQUFHLElBQUUsSUFBRSxLQUFHQSxNQUFHLElBQUUsS0FBRztBQUFBLFFBQUU7QUFBQyxpQkFBUyxFQUFFQSxJQUFFSCxJQUFFRCxJQUFFO0FBQUMsY0FBSUUsS0FBRUQsR0FBRSxTQUFPO0FBQUUsY0FBR0MsS0FBRUY7QUFBRSxtQkFBTztBQUFFLGNBQUlHLEtBQUUsRUFBRUYsR0FBRUMsRUFBQyxDQUFDO0FBQUUsaUJBQU8sS0FBR0MsTUFBRyxJQUFFQSxPQUFJQyxHQUFFLFdBQVNELEtBQUUsSUFBR0EsTUFBRyxFQUFFRCxLQUFFRixNQUFHLE9BQUtHLEtBQUUsS0FBR0EsS0FBRSxFQUFFRixHQUFFQyxFQUFDLENBQUMsR0FBRSxLQUFHQyxPQUFJLElBQUVBLE9BQUlDLEdBQUUsV0FBU0QsS0FBRSxJQUFHQSxNQUFHLEVBQUVELEtBQUVGLE1BQUcsT0FBS0csS0FBRSxLQUFHQSxLQUFFLEVBQUVGLEdBQUVDLEVBQUMsQ0FBQyxHQUFFLEtBQUdDLE1BQUcsSUFBRUEsT0FBSSxNQUFJQSxLQUFFQSxLQUFFLElBQUVDLEdBQUUsV0FBU0QsS0FBRSxJQUFHQSxNQUFHO0FBQUEsUUFBRTtBQUFDLGlCQUFTLEVBQUVDLElBQUVILElBQUU7QUFBQyxjQUFHLFFBQU0sTUFBSUEsR0FBRSxDQUFDO0FBQUcsbUJBQU9HLEdBQUUsV0FBUyxHQUFFO0FBQVMsY0FBRyxJQUFFQSxHQUFFLFlBQVUsSUFBRUgsR0FBRSxRQUFPO0FBQUMsZ0JBQUcsUUFBTSxNQUFJQSxHQUFFLENBQUM7QUFBRyxxQkFBT0csR0FBRSxXQUFTLEdBQUU7QUFBUyxnQkFBRyxJQUFFQSxHQUFFLFlBQVUsSUFBRUgsR0FBRSxVQUFRLFFBQU0sTUFBSUEsR0FBRSxDQUFDO0FBQUcscUJBQU9HLEdBQUUsV0FBUyxHQUFFO0FBQUEsVUFBUTtBQUFBLFFBQUM7QUFBQyxpQkFBUyxFQUFFQSxJQUFFO0FBQUMsY0FBSUgsS0FBRSxLQUFLLFlBQVUsS0FBSyxVQUFTRCxLQUFFLEVBQUUsTUFBS0ksSUFBRUgsRUFBQztBQUFFLGlCQUFPLFdBQVNELEtBQUUsS0FBSyxZQUFVSSxHQUFFLFVBQVFBLEdBQUUsS0FBSyxLQUFLLFVBQVNILElBQUUsR0FBRSxLQUFLLFFBQVEsR0FBRSxLQUFLLFNBQVMsU0FBUyxLQUFLLFVBQVMsR0FBRSxLQUFLLFNBQVMsS0FBRyxNQUFLRyxHQUFFLEtBQUssS0FBSyxVQUFTSCxJQUFFLEdBQUVHLEdBQUUsTUFBTSxHQUFFLEtBQUssWUFBVUEsR0FBRSxVQUFRSjtBQUFBLFFBQUM7QUFBQyxpQkFBUyxFQUFFSSxJQUFFSCxJQUFFO0FBQUMsY0FBRyxNQUFJRyxHQUFFLFNBQU9ILE1BQUcsR0FBRTtBQUFDLGdCQUFJRCxLQUFFSSxHQUFFLFNBQVMsV0FBVUgsRUFBQztBQUFFLGdCQUFHRCxJQUFFO0FBQUMsa0JBQUlFLEtBQUVGLEdBQUUsV0FBV0EsR0FBRSxTQUFPLENBQUM7QUFBRSxrQkFBRyxTQUFPRSxNQUFHLFNBQU9BO0FBQUUsdUJBQU8sS0FBSyxXQUFTLEdBQUUsS0FBSyxZQUFVLEdBQUUsS0FBSyxTQUFTLENBQUMsSUFBRUUsR0FBRUEsR0FBRSxTQUFPLENBQUMsR0FBRSxLQUFLLFNBQVMsQ0FBQyxJQUFFQSxHQUFFQSxHQUFFLFNBQU8sQ0FBQyxHQUFFSixHQUFFLE1BQU0sR0FBRSxFQUFFO0FBQUEsWUFBQztBQUFDLG1CQUFPQTtBQUFBLFVBQUM7QUFBQyxpQkFBTyxLQUFLLFdBQVMsR0FBRSxLQUFLLFlBQVUsR0FBRSxLQUFLLFNBQVMsQ0FBQyxJQUFFSSxHQUFFQSxHQUFFLFNBQU8sQ0FBQyxHQUFFQSxHQUFFLFNBQVMsV0FBVUgsSUFBRUcsR0FBRSxTQUFPLENBQUM7QUFBQSxRQUFDO0FBQUMsaUJBQVMsRUFBRUEsSUFBRTtBQUFDLGNBQUlILEtBQUVHLE1BQUdBLEdBQUUsU0FBTyxLQUFLLE1BQU1BLEVBQUMsSUFBRTtBQUFHLGNBQUcsS0FBSyxVQUFTO0FBQUMsZ0JBQUlKLEtBQUUsS0FBSyxZQUFVLEtBQUs7QUFBUyxtQkFBT0MsS0FBRSxLQUFLLFNBQVMsU0FBUyxXQUFVLEdBQUVELEVBQUM7QUFBQSxVQUFDO0FBQUMsaUJBQU9DO0FBQUEsUUFBQztBQUFDLGlCQUFTLEVBQUVHLElBQUVILElBQUU7QUFBQyxjQUFJQyxNQUFHRSxHQUFFLFNBQU9ILE1BQUc7QUFBRSxpQkFBTyxLQUFHQyxLQUFFRSxHQUFFLFNBQVMsVUFBU0gsRUFBQyxLQUFHLEtBQUssV0FBUyxJQUFFQyxJQUFFLEtBQUssWUFBVSxHQUFFLEtBQUdBLEtBQUUsS0FBSyxTQUFTLENBQUMsSUFBRUUsR0FBRUEsR0FBRSxTQUFPLENBQUMsS0FBRyxLQUFLLFNBQVMsQ0FBQyxJQUFFQSxHQUFFQSxHQUFFLFNBQU8sQ0FBQyxHQUFFLEtBQUssU0FBUyxDQUFDLElBQUVBLEdBQUVBLEdBQUUsU0FBTyxDQUFDLElBQUdBLEdBQUUsU0FBUyxVQUFTSCxJQUFFRyxHQUFFLFNBQU9GLEVBQUM7QUFBQSxRQUFFO0FBQUMsaUJBQVMsRUFBRUUsSUFBRTtBQUFDLGNBQUlILEtBQUVHLE1BQUdBLEdBQUUsU0FBTyxLQUFLLE1BQU1BLEVBQUMsSUFBRTtBQUFHLGlCQUFPLEtBQUssV0FBU0gsS0FBRSxLQUFLLFNBQVMsU0FBUyxVQUFTLEdBQUUsSUFBRSxLQUFLLFFBQVEsSUFBRUE7QUFBQSxRQUFDO0FBQUMsaUJBQVMsRUFBRUcsSUFBRTtBQUFDLGlCQUFPQSxHQUFFLFNBQVMsS0FBSyxRQUFRO0FBQUEsUUFBQztBQUFDLGlCQUFTLEVBQUVBLElBQUU7QUFBQyxpQkFBT0EsTUFBR0EsR0FBRSxTQUFPLEtBQUssTUFBTUEsRUFBQyxJQUFFO0FBQUEsUUFBRTtBQUFDLFlBQUksSUFBRSxFQUFFLGFBQWEsRUFBRSxRQUFPLElBQUUsRUFBRSxjQUFZLFNBQVNBLElBQUU7QUFBQyxrQkFBT0EsS0FBRSxLQUFHQSxJQUFFQSxNQUFHQSxHQUFFLFlBQVksR0FBRTtBQUFBLFlBQUMsS0FBSTtBQUFBLFlBQU0sS0FBSTtBQUFBLFlBQU8sS0FBSTtBQUFBLFlBQVEsS0FBSTtBQUFBLFlBQVEsS0FBSTtBQUFBLFlBQVMsS0FBSTtBQUFBLFlBQVMsS0FBSTtBQUFBLFlBQU8sS0FBSTtBQUFBLFlBQVEsS0FBSTtBQUFBLFlBQVUsS0FBSTtBQUFBLFlBQVcsS0FBSTtBQUFNLHFCQUFNO0FBQUEsWUFBRztBQUFRLHFCQUFNO0FBQUEsVUFBRztBQUFBLFFBQUM7QUFBRSxRQUFBSixHQUFFLGdCQUFjLEdBQUUsRUFBRSxVQUFVLFFBQU0sU0FBU0ksSUFBRTtBQUFDLGNBQUcsTUFBSUEsR0FBRTtBQUFPLG1CQUFNO0FBQUcsY0FBSUgsSUFBRUQ7QUFBRSxjQUFHLEtBQUssVUFBUztBQUFDLGdCQUFHQyxLQUFFLEtBQUssU0FBU0csRUFBQyxHQUFFLFdBQVNIO0FBQUUscUJBQU07QUFBRyxZQUFBRCxLQUFFLEtBQUssVUFBUyxLQUFLLFdBQVM7QUFBQSxVQUFDO0FBQU0sWUFBQUEsS0FBRTtBQUFFLGlCQUFPQSxLQUFFSSxHQUFFLFNBQU9ILEtBQUVBLEtBQUUsS0FBSyxLQUFLRyxJQUFFSixFQUFDLElBQUUsS0FBSyxLQUFLSSxJQUFFSixFQUFDLElBQUVDLE1BQUc7QUFBQSxRQUFFLEdBQUUsRUFBRSxVQUFVLE1BQUksU0FBU0csSUFBRTtBQUFDLGNBQUlILEtBQUVHLE1BQUdBLEdBQUUsU0FBTyxLQUFLLE1BQU1BLEVBQUMsSUFBRTtBQUFHLGlCQUFPLEtBQUssV0FBU0gsS0FBRSxXQUFTQTtBQUFBLFFBQUMsR0FBRSxFQUFFLFVBQVUsT0FBSyxTQUFTRyxJQUFFSCxJQUFFO0FBQUMsY0FBSUQsS0FBRSxFQUFFLE1BQUtJLElBQUVILEVBQUM7QUFBRSxjQUFHLENBQUMsS0FBSztBQUFTLG1CQUFPRyxHQUFFLFNBQVMsUUFBT0gsRUFBQztBQUFFLGVBQUssWUFBVUQ7QUFBRSxjQUFJRSxLQUFFRSxHQUFFLFVBQVFKLEtBQUUsS0FBSztBQUFVLGlCQUFPSSxHQUFFLEtBQUssS0FBSyxVQUFTLEdBQUVGLEVBQUMsR0FBRUUsR0FBRSxTQUFTLFFBQU9ILElBQUVDLEVBQUM7QUFBQSxRQUFDLEdBQUUsRUFBRSxVQUFVLFdBQVMsU0FBU0UsSUFBRTtBQUFDLGlCQUFPLEtBQUssWUFBVUEsR0FBRSxVQUFRQSxHQUFFLEtBQUssS0FBSyxVQUFTLEtBQUssWUFBVSxLQUFLLFVBQVMsR0FBRSxLQUFLLFFBQVEsR0FBRSxLQUFLLFNBQVMsU0FBUyxLQUFLLFVBQVMsR0FBRSxLQUFLLFNBQVMsS0FBRyxNQUFLQSxHQUFFLEtBQUssS0FBSyxVQUFTLEtBQUssWUFBVSxLQUFLLFVBQVMsR0FBRUEsR0FBRSxNQUFNLEdBQUUsS0FBSyxZQUFVQSxHQUFFO0FBQUEsUUFBTztBQUFBLE1BQUMsR0FBRSxFQUFDLGVBQWMsR0FBRSxDQUFDLEdBQUUsSUFBRyxDQUFDLFNBQVMsR0FBRUgsSUFBRTtBQUFDLFNBQUMsU0FBU0csSUFBRTtBQUFDLFdBQUMsV0FBVTtBQUFDLHFCQUFTSixHQUFFQyxJQUFFO0FBQUMsa0JBQUc7QUFBQyxvQkFBRyxDQUFDRyxHQUFFO0FBQWEseUJBQU07QUFBQSxjQUFFLFNBQU9BLElBQU47QUFBUyx1QkFBTTtBQUFBLGNBQUU7QUFBQyxrQkFBSUosS0FBRUksR0FBRSxhQUFhSCxFQUFDO0FBQUUscUJBQU8sUUFBTUQsTUFBRyxZQUFVQSxLQUFFLElBQUksWUFBWTtBQUFBLFlBQUM7QUFBQyxZQUFBQyxHQUFFLFVBQVEsU0FBU0csSUFBRUgsSUFBRTtBQUFDLHVCQUFTQyxLQUFHO0FBQUMsb0JBQUcsQ0FBQyxHQUFFO0FBQUMsc0JBQUdGLEdBQUUsa0JBQWtCO0FBQUUsMEJBQU0sSUFBSSxNQUFNQyxFQUFDO0FBQUE7QUFBTyxvQkFBQUQsR0FBRSxrQkFBa0IsSUFBRSxRQUFRLE1BQU1DLEVBQUMsSUFBRSxRQUFRLEtBQUtBLEVBQUM7QUFBRSxzQkFBRTtBQUFBLGdCQUFFO0FBQUMsdUJBQU9HLEdBQUUsTUFBTSxNQUFLLFNBQVM7QUFBQSxjQUFDO0FBQUMsa0JBQUdKLEdBQUUsZUFBZTtBQUFFLHVCQUFPSTtBQUFFLGtCQUFJLElBQUU7QUFBRyxxQkFBT0Y7QUFBQSxZQUFDO0FBQUEsVUFBQyxHQUFHLEtBQUssSUFBSTtBQUFBLFFBQUMsR0FBRyxLQUFLLE1BQUssZUFBYSxPQUFPLFNBQU8sZUFBYSxPQUFPLE9BQUssZUFBYSxPQUFPLFNBQU8sQ0FBQyxJQUFFLFNBQU8sT0FBSyxNQUFNO0FBQUEsTUFBQyxHQUFFLENBQUMsQ0FBQyxHQUFFLEtBQUksQ0FBQyxTQUFTLEdBQUVELElBQUU7QUFBQyxpQkFBU0QsR0FBRUksSUFBRTtBQUFDLGlCQUFPQSxHQUFFLFFBQVEsOEJBQTZCLEVBQUU7QUFBQSxRQUFDO0FBQUMsaUJBQVNGLEdBQUVFLElBQUU7QUFBQyxrQkFBUSxLQUFLQSxFQUFDO0FBQUEsUUFBQztBQUFxRixjQUFNLElBQUUsRUFBRSxPQUFPLEVBQUUsYUFBYSxHQUFFLElBQUUsRUFBRSxpQkFBaUIsR0FBRSxJQUFFLEVBQUUsYUFBYSxHQUFFLElBQUUsRUFBRSxpQkFBaUIsR0FBRSxJQUFFLEVBQUUsaUJBQWlCLEdBQUUsSUFBRSxFQUFFLFVBQVUsR0FBRSxFQUFDLFFBQU8sRUFBQyxJQUFFLEVBQUUsUUFBUSxHQUFFLElBQUU7QUFBTSxjQUFNLFVBQVUsRUFBRSxPQUFNO0FBQUEsVUFBQyxZQUFZQSxJQUFFO0FBQUMsZ0JBQUdBLEtBQUUsT0FBTyxPQUFPLEVBQUMsZUFBYyxNQUFFLEdBQUVBLEVBQUMsR0FBRSxNQUFNQSxFQUFDLEdBQUUsS0FBSyxNQUFJLEVBQUUsQ0FBQyxFQUFFLFNBQVMsS0FBSyxFQUFFLE1BQU0sR0FBRSxDQUFDLEdBQUUsS0FBSyxPQUFPLGVBQWNBLEVBQUMsR0FBRSxLQUFLLGNBQVlBLEdBQUUsWUFBVUEsR0FBRSxlQUFhLEVBQUUsRUFBRSxFQUFFLFNBQVMsS0FBSyxJQUFFLE1BQUssS0FBSyxZQUFVQSxHQUFFLGFBQVcsT0FBRyxLQUFLLGdCQUFjQSxHQUFFLGlCQUFlLEVBQUUsZUFBYyxLQUFLLG9CQUFrQixLQUFLLGNBQWMsWUFBVyxLQUFLLFNBQU8sT0FBTyxPQUFPLENBQUMsR0FBRSxFQUFFLFFBQU9BLEdBQUUsTUFBTSxHQUFFLEtBQUssZUFBYUEsR0FBRSxnQkFBYyxDQUFDLEdBQUUsS0FBSyxnQkFBY0EsR0FBRSxpQkFBZSxDQUFDLEdBQUUsS0FBSyxlQUFhQSxHQUFFLGlCQUFlLENBQUFBLE9BQUdBLEtBQUcsS0FBSyxVQUFRQSxHQUFFLFlBQVVBLEdBQUUsU0FBTyxDQUFDQSxHQUFFLE1BQU0sSUFBRSxDQUFDLElBQUcsS0FBSyxVQUFRLFdBQVNBLEdBQUUsV0FBU0EsR0FBRSxTQUFRLEtBQUssbUJBQWlCLFdBQVNBLEdBQUUsb0JBQWtCQSxHQUFFLGtCQUFpQixLQUFLLHFCQUFtQkEsR0FBRSxzQkFBb0IsS0FBSyxLQUFLLFlBQVUsT0FBRyxLQUFLLGFBQVcsT0FBRyxLQUFLLGFBQVcsT0FBRyxLQUFLLGdCQUFjLFFBQU8sS0FBSyxlQUFhLFFBQU8sS0FBSyxhQUFXLFFBQU8sS0FBSyxlQUFhLFFBQU8sS0FBSyxjQUFZLFFBQU8sS0FBSyxZQUFVLFFBQU8sS0FBSyxRQUFNQSxHQUFFLFFBQU0sWUFBVSxPQUFPQSxHQUFFLE9BQUtBLEdBQUUsT0FBSyxFQUFFLEdBQUUsQ0FBQyxLQUFLO0FBQU0sa0JBQUcsZUFBYSxPQUFPO0FBQU8sc0JBQU0sRUFBRSxJQUFJLE1BQU0sbUVBQW1FLEdBQUUsb0JBQW9CO0FBQUE7QUFBTyxzQkFBTSxFQUFFLElBQUksTUFBTSw0Q0FBNEMsR0FBRSxvQkFBb0I7QUFBRSxpQkFBSyxXQUFTLE9BQUcsS0FBSyxnQkFBYyxPQUFHLEtBQUssZUFBYSxPQUFHLEtBQUssb0JBQWtCLE1BQUssS0FBSyxXQUFTLE1BQUssS0FBSyxxQkFBbUIsQ0FBQyxHQUFFLEtBQUssaUJBQWUsT0FBRyxLQUFLLG9CQUFrQixNQUFHLEtBQUssc0JBQW9CLE9BQUcsS0FBSyxxQkFBbUIsT0FBRyxLQUFLLHlCQUF1QixDQUFDLEdBQUUsS0FBSyxhQUFXLG9CQUFJLE9BQUksS0FBSyxtQkFBaUIsTUFBSyxLQUFLLGdCQUFjLENBQUMsR0FBRSxLQUFLLGlCQUFlLENBQUMsR0FBRSxLQUFLLFNBQU8sTUFBSyxLQUFLLE1BQUksTUFBSyxLQUFLLFlBQVU7QUFBSyxnQkFBRztBQUFDLG1CQUFLLE1BQUksSUFBSSxLQUFLLE1BQU0sa0JBQWtCLEtBQUssTUFBTTtBQUFBLFlBQUMsU0FBT0EsSUFBTjtBQUFTLHFCQUFPLEtBQUssS0FBSyxRQUFRLEVBQUVBLElBQUUsb0JBQW9CLENBQUM7QUFBQSxZQUFDO0FBQUMsaUJBQUssdUJBQXFCLFlBQVUsT0FBTyxLQUFLLElBQUksbUJBQWtCLEtBQUssSUFBSSw2QkFBMkIsTUFBSTtBQUFDLG1CQUFLLGtCQUFrQjtBQUFBLFlBQUMsR0FBRSxLQUFLLElBQUksNEJBQTBCLE1BQUk7QUFBQyxtQkFBSyxrQkFBa0I7QUFBQSxZQUFDLEdBQUUsS0FBSyxJQUFJLDBCQUF3QixNQUFJO0FBQUMsbUJBQUsseUJBQXlCO0FBQUEsWUFBQyxHQUFFLEtBQUssSUFBSSx5QkFBdUIsTUFBSTtBQUFDLG1CQUFLLHdCQUF3QjtBQUFBLFlBQUMsR0FBRSxLQUFLLElBQUksaUJBQWUsQ0FBQUEsT0FBRztBQUFDLG1CQUFLLGdCQUFnQkEsRUFBQztBQUFBLFlBQUMsR0FBRSxZQUFVLE9BQU8sS0FBSyxJQUFJLGdCQUFjLEtBQUssSUFBSSxhQUFhLE1BQU0sQ0FBQUEsT0FBRztBQUFDLG1CQUFLLFFBQVEsRUFBRUEsSUFBRSxzQkFBc0IsQ0FBQztBQUFBLFlBQUMsQ0FBQyxHQUFFLEtBQUssYUFBVyxLQUFLLG9CQUFrQixLQUFLLFdBQVcsRUFBQyxTQUFRLEtBQUssSUFBSSxrQkFBa0IsS0FBSyxhQUFZLEtBQUssYUFBYSxFQUFDLENBQUMsSUFBRSxLQUFLLElBQUksZ0JBQWMsQ0FBQUEsT0FBRztBQUFDLG1CQUFLLFdBQVdBLEVBQUM7QUFBQSxZQUFDLEdBQUUsS0FBSyxXQUFTLEtBQUssUUFBUSxRQUFRLENBQUFBLE9BQUc7QUFBQyxtQkFBSyxVQUFVQSxFQUFDO0FBQUEsWUFBQyxDQUFDLEdBQUUsS0FBSyxJQUFJLFVBQVEsQ0FBQUEsT0FBRztBQUFDLG1CQUFLLFNBQVNBLEVBQUM7QUFBQSxZQUFDLEdBQUUsS0FBSyxPQUFPLHFCQUFxQixHQUFFLEtBQUssa0JBQWtCLEdBQUUsS0FBSyxpQkFBZSxNQUFJO0FBQUMsbUJBQUssVUFBVTtBQUFBLFlBQUMsR0FBRSxLQUFLLEtBQUssVUFBUyxLQUFLLGNBQWM7QUFBQSxVQUFDO0FBQUEsVUFBQyxJQUFJLGFBQVk7QUFBQyxtQkFBTyxLQUFLLFlBQVUsS0FBSyxTQUFTLGtCQUFnQjtBQUFBLFVBQUM7QUFBQSxVQUFDLElBQUksWUFBVztBQUFDLG1CQUFPLEtBQUssY0FBWSxXQUFTLEtBQUssU0FBUztBQUFBLFVBQVU7QUFBQSxVQUFDLFVBQVM7QUFBQyxtQkFBTSxFQUFDLE1BQUssS0FBSyxXQUFVLFFBQU8sS0FBSyxhQUFZLFNBQVEsS0FBSyxhQUFZO0FBQUEsVUFBQztBQUFBLFVBQUMsT0FBT0EsSUFBRTtBQUFDLGdCQUFHLENBQUMsS0FBSyxZQUFXO0FBQUMsa0JBQUcsS0FBSztBQUFVLHNCQUFNLEVBQUUsSUFBSSxNQUFNLHVDQUF1QyxHQUFFLGVBQWU7QUFBRSxrQkFBRyxZQUFVLE9BQU9BO0FBQUUsb0JBQUc7QUFBQyxrQkFBQUEsS0FBRSxLQUFLLE1BQU1BLEVBQUM7QUFBQSxnQkFBQyxTQUFPSCxJQUFOO0FBQVMsa0JBQUFHLEtBQUUsQ0FBQztBQUFBLGdCQUFDO0FBQUMsbUJBQUssT0FBTyxVQUFVLEdBQUVBLEdBQUUsZUFBYSxLQUFLLGNBQVksS0FBSyxPQUFPLDRCQUE0QixHQUFFLEtBQUssa0JBQWtCLElBQUdBLEdBQUUsc0JBQW9CLEtBQUssY0FBWSxLQUFLLE9BQU8sNkJBQTZCLEdBQUUsS0FBSyxlQUFlQSxHQUFFLG1CQUFtQixNQUFLQSxHQUFFLG1CQUFtQixJQUFJLElBQUdBLEdBQUUsY0FBWSxLQUFLLElBQUkscUJBQW1CLEtBQUssSUFBSSxrQkFBa0IsT0FBSyxLQUFLLGlCQUFpQkEsR0FBRSxTQUFTLElBQUUsS0FBSyxtQkFBbUIsS0FBS0EsR0FBRSxTQUFTLElBQUdBLEdBQUUsT0FBSyxLQUFLLElBQUkscUJBQXFCLElBQUksS0FBSyxNQUFNLHNCQUFzQkEsRUFBQyxDQUFDLEVBQUUsS0FBSyxNQUFJO0FBQUMscUJBQUssY0FBWSxLQUFLLG1CQUFtQixRQUFRLENBQUFBLE9BQUc7QUFBQyx1QkFBSyxpQkFBaUJBLEVBQUM7QUFBQSxnQkFBQyxDQUFDLEdBQUUsS0FBSyxxQkFBbUIsQ0FBQyxHQUFFLFlBQVUsS0FBSyxJQUFJLGtCQUFrQixRQUFNLEtBQUssY0FBYztBQUFBLGNBQUUsQ0FBQyxFQUFFLE1BQU0sQ0FBQUEsT0FBRztBQUFDLHFCQUFLLFFBQVEsRUFBRUEsSUFBRSw0QkFBNEIsQ0FBQztBQUFBLGNBQUMsQ0FBQyxHQUFFQSxHQUFFLE9BQUtBLEdBQUUsYUFBV0EsR0FBRSxlQUFhQSxHQUFFLHNCQUFvQixLQUFLLFFBQVEsRUFBRSxJQUFJLE1BQU0sMENBQTBDLEdBQUUsZUFBZSxDQUFDO0FBQUEsWUFBQztBQUFBLFVBQUM7QUFBQSxVQUFDLGlCQUFpQkEsSUFBRTtBQUFDLGtCQUFNSCxLQUFFLElBQUksS0FBSyxNQUFNLGdCQUFnQkcsRUFBQztBQUFFLGlCQUFLLElBQUksZ0JBQWdCSCxFQUFDLEVBQUUsTUFBTSxDQUFBRyxPQUFHO0FBQUMsZUFBQ0gsR0FBRSxXQUFTQSxHQUFFLFFBQVEsU0FBUyxRQUFRLElBQUVDLEdBQUUscUNBQXFDLElBQUUsS0FBSyxRQUFRLEVBQUVFLElBQUUsdUJBQXVCLENBQUM7QUFBQSxZQUFDLENBQUM7QUFBQSxVQUFDO0FBQUEsVUFBQyxLQUFLQSxJQUFFO0FBQUMsZ0JBQUcsQ0FBQyxLQUFLLFlBQVc7QUFBQyxrQkFBRyxLQUFLO0FBQVUsc0JBQU0sRUFBRSxJQUFJLE1BQU0scUNBQXFDLEdBQUUsZUFBZTtBQUFFLG1CQUFLLFNBQVMsS0FBS0EsRUFBQztBQUFBLFlBQUM7QUFBQSxVQUFDO0FBQUEsVUFBQyxlQUFlQSxJQUFFSCxJQUFFO0FBQUMsZ0JBQUcsQ0FBQyxLQUFLLFlBQVc7QUFBQyxrQkFBRyxLQUFLO0FBQVUsc0JBQU0sRUFBRSxJQUFJLE1BQU0sK0NBQStDLEdBQUUsZUFBZTtBQUFFLGtCQUFHLEtBQUssT0FBTyxrQkFBa0IsR0FBRSxLQUFLO0FBQVUsb0JBQUc7QUFBQyx1QkFBSyxJQUFJLGVBQWVHLElBQUVILEVBQUMsR0FBRSxLQUFLLGtCQUFrQjtBQUFBLGdCQUFDLFNBQU9HLElBQU47QUFBUyx1QkFBSyxRQUFRLEVBQUVBLElBQUUscUJBQXFCLENBQUM7QUFBQSxnQkFBQztBQUFBO0FBQU0scUJBQUssS0FBSyxVQUFTLEVBQUMsTUFBSyxzQkFBcUIsb0JBQW1CLEVBQUMsTUFBS0EsSUFBRSxNQUFLSCxHQUFDLEVBQUMsQ0FBQztBQUFBLFlBQUM7QUFBQSxVQUFDO0FBQUEsVUFBQyxVQUFVRyxJQUFFO0FBQUMsZ0JBQUcsQ0FBQyxLQUFLLFlBQVc7QUFBQyxrQkFBRyxLQUFLO0FBQVUsc0JBQU0sRUFBRSxJQUFJLE1BQU0sMENBQTBDLEdBQUUsZUFBZTtBQUFFLG1CQUFLLE9BQU8sYUFBYSxHQUFFQSxHQUFFLFVBQVUsRUFBRSxRQUFRLENBQUFILE9BQUc7QUFBQyxxQkFBSyxTQUFTQSxJQUFFRyxFQUFDO0FBQUEsY0FBQyxDQUFDO0FBQUEsWUFBQztBQUFBLFVBQUM7QUFBQSxVQUFDLFNBQVNBLElBQUVILElBQUU7QUFBQyxnQkFBRyxLQUFLO0FBQVc7QUFBTyxnQkFBRyxLQUFLO0FBQVUsb0JBQU0sRUFBRSxJQUFJLE1BQU0seUNBQXlDLEdBQUUsZUFBZTtBQUFFLGlCQUFLLE9BQU8sWUFBWTtBQUFFLGtCQUFNRCxLQUFFLEtBQUssV0FBVyxJQUFJSSxFQUFDLEtBQUcsb0JBQUk7QUFBSSxnQkFBSUYsS0FBRUYsR0FBRSxJQUFJQyxFQUFDO0FBQUUsZ0JBQUcsQ0FBQ0M7QUFBRSxjQUFBQSxLQUFFLEtBQUssSUFBSSxTQUFTRSxJQUFFSCxFQUFDLEdBQUVELEdBQUUsSUFBSUMsSUFBRUMsRUFBQyxHQUFFLEtBQUssV0FBVyxJQUFJRSxJQUFFSixFQUFDLEdBQUUsS0FBSyxrQkFBa0I7QUFBQSxxQkFBVUUsR0FBRTtBQUFRLG9CQUFNLEVBQUUsSUFBSSxNQUFNLG1GQUFtRixHQUFFLG9CQUFvQjtBQUFBO0FBQU8sb0JBQU0sRUFBRSxJQUFJLE1BQU0sOENBQThDLEdBQUUsMEJBQTBCO0FBQUEsVUFBQztBQUFBLFVBQUMsYUFBYUUsSUFBRUgsSUFBRUQsSUFBRTtBQUFDLGdCQUFHLEtBQUs7QUFBVztBQUFPLGdCQUFHLEtBQUs7QUFBVSxvQkFBTSxFQUFFLElBQUksTUFBTSw2Q0FBNkMsR0FBRSxlQUFlO0FBQUUsaUJBQUssT0FBTyxnQkFBZ0I7QUFBRSxrQkFBTUUsS0FBRSxLQUFLLFdBQVcsSUFBSUUsRUFBQyxHQUFFRCxLQUFFRCxLQUFFQSxHQUFFLElBQUlGLEVBQUMsSUFBRTtBQUFLLGdCQUFHLENBQUNHO0FBQUUsb0JBQU0sRUFBRSxJQUFJLE1BQU0sNENBQTRDLEdBQUUscUJBQXFCO0FBQUUsWUFBQUYsTUFBRyxLQUFLLFdBQVcsSUFBSUEsSUFBRUMsRUFBQyxHQUFFLFFBQU1DLEdBQUUsZUFBYSxLQUFLLFFBQVEsRUFBRSxJQUFJLE1BQU0sK0NBQStDLEdBQUUsOEJBQThCLENBQUMsSUFBRUEsR0FBRSxhQUFhRixFQUFDO0FBQUEsVUFBQztBQUFBLFVBQUMsWUFBWUcsSUFBRUgsSUFBRTtBQUFDLGdCQUFHLEtBQUs7QUFBVztBQUFPLGdCQUFHLEtBQUs7QUFBVSxvQkFBTSxFQUFFLElBQUksTUFBTSw0Q0FBNEMsR0FBRSxlQUFlO0FBQUUsaUJBQUssT0FBTyxnQkFBZ0I7QUFBRSxrQkFBTUQsS0FBRSxLQUFLLFdBQVcsSUFBSUksRUFBQyxHQUFFRixLQUFFRixLQUFFQSxHQUFFLElBQUlDLEVBQUMsSUFBRTtBQUFLLGdCQUFHLENBQUNDO0FBQUUsb0JBQU0sRUFBRSxJQUFJLE1BQU0sMkNBQTJDLEdBQUUscUJBQXFCO0FBQUUsZ0JBQUc7QUFBQyxjQUFBQSxHQUFFLFVBQVEsTUFBRyxLQUFLLElBQUksWUFBWUEsRUFBQztBQUFBLFlBQUMsU0FBT0UsSUFBTjtBQUFTLHdDQUF3QkEsR0FBRSxPQUFLLEtBQUssdUJBQXVCLEtBQUtGLEVBQUMsSUFBRSxLQUFLLFFBQVEsRUFBRUUsSUFBRSxrQkFBa0IsQ0FBQztBQUFBLFlBQUM7QUFBQyxpQkFBSyxrQkFBa0I7QUFBQSxVQUFDO0FBQUEsVUFBQyxhQUFhQSxJQUFFO0FBQUMsZ0JBQUcsQ0FBQyxLQUFLLFlBQVc7QUFBQyxrQkFBRyxLQUFLO0FBQVUsc0JBQU0sRUFBRSxJQUFJLE1BQU0sNkNBQTZDLEdBQUUsZUFBZTtBQUFFLG1CQUFLLE9BQU8saUJBQWlCLEdBQUVBLEdBQUUsVUFBVSxFQUFFLFFBQVEsQ0FBQUgsT0FBRztBQUFDLHFCQUFLLFlBQVlBLElBQUVHLEVBQUM7QUFBQSxjQUFDLENBQUM7QUFBQSxZQUFDO0FBQUEsVUFBQztBQUFBLFVBQUMsb0JBQW1CO0FBQUMsaUJBQUssT0FBTyxtQkFBbUIsR0FBRSxLQUFLLHdCQUFzQixLQUFLLHNCQUFvQixNQUFHLEVBQUUsTUFBSTtBQUFDLG1CQUFLLHNCQUFvQixPQUFHLEtBQUssYUFBVyxDQUFDLEtBQUsscUJBQW1CLEtBQUssT0FBTyw4QkFBOEIsR0FBRSxLQUFLLFVBQVUsS0FBRyxLQUFLLE9BQU8scURBQXFELEdBQUUsS0FBSyxvQkFBa0I7QUFBQSxZQUFFLENBQUM7QUFBQSxVQUFFO0FBQUEsVUFBQyxZQUFXO0FBQUMsZ0JBQUcsQ0FBQyxLQUFLLFlBQVc7QUFBQyxrQkFBRyxLQUFLO0FBQVUsc0JBQU0sRUFBRSxJQUFJLE1BQU0sMENBQTBDLEdBQUUsZUFBZTtBQUFFLG1CQUFLLFlBQVUsS0FBSyxrQkFBZ0IsS0FBSyxxQkFBbUIsTUFBRyxLQUFLLE9BQU8sK0JBQStCLE1BQUksS0FBSyxPQUFPLG1CQUFtQixHQUFFLFdBQVcsTUFBSTtBQUFDLHFCQUFLLGFBQWE7QUFBQSxjQUFDLEdBQUUsQ0FBQyxLQUFHLEtBQUssa0JBQWdCLEtBQUsscUJBQW1CLE1BQUcsS0FBSyxPQUFPLCtCQUErQixNQUFJLEtBQUssT0FBTyx1Q0FBdUMsR0FBRSxLQUFLLEtBQUssVUFBUyxFQUFDLE1BQUssZUFBYyxhQUFZLEtBQUUsQ0FBQyxJQUFHLEtBQUssaUJBQWU7QUFBQSxZQUFFO0FBQUEsVUFBQztBQUFBLFVBQUMsUUFBUUEsSUFBRTtBQUFDLGlCQUFLLFNBQVNBLElBQUUsTUFBSTtBQUFBLFlBQUMsQ0FBQztBQUFBLFVBQUM7QUFBQSxVQUFDLFNBQVNBLElBQUVILElBQUU7QUFBQyxpQkFBSyxhQUFXLEtBQUssZUFBYSxLQUFLLGFBQVcsTUFBRyxLQUFLLE9BQU8sMEJBQXlCRyxPQUFJQSxHQUFFLFdBQVNBLEdBQUUsR0FBRSxFQUFFLE1BQUk7QUFBQyxrQkFBRyxLQUFLLFlBQVUsTUFBRyxLQUFLLGFBQVcsT0FBRyxLQUFLLE9BQU8sdUJBQXNCQSxPQUFJQSxHQUFFLFdBQVNBLEdBQUUsR0FBRSxLQUFLLFdBQVMsS0FBSyxXQUFTLE9BQUcsS0FBSyxlQUFlLFNBQU8sS0FBSyxLQUFLLElBQUksR0FBRSxLQUFLLGVBQWUsWUFBVSxLQUFLLElBQUksR0FBRSxLQUFLLGFBQVcsT0FBRyxLQUFLLFdBQVMsT0FBRyxLQUFLLGdCQUFjLE9BQUcsS0FBSyxnQkFBYyxNQUFLLEtBQUssaUJBQWUsTUFBSyxLQUFLLGFBQVcsTUFBSyxjQUFjLEtBQUssZ0JBQWdCLEdBQUUsS0FBSyxtQkFBaUIsTUFBSyxjQUFjLEtBQUssU0FBUyxHQUFFLEtBQUssWUFBVSxNQUFLLEtBQUssU0FBTyxNQUFLLEtBQUssTUFBSSxNQUFLLEtBQUssa0JBQWdCLEtBQUssZUFBZSxVQUFTLEtBQUssY0FBYyxHQUFFLEtBQUssaUJBQWUsTUFBSyxLQUFLLFVBQVM7QUFBQyxvQkFBRztBQUFDLHVCQUFLLFNBQVMsTUFBTTtBQUFBLGdCQUFDLFNBQU9BLElBQU47QUFBQSxnQkFBUztBQUFDLHFCQUFLLFNBQVMsWUFBVSxNQUFLLEtBQUssU0FBUyxTQUFPLE1BQUssS0FBSyxTQUFTLFVBQVEsTUFBSyxLQUFLLFNBQVMsVUFBUTtBQUFBLGNBQUk7QUFBQyxrQkFBRyxLQUFLLEtBQUk7QUFBQyxvQkFBRztBQUFDLHVCQUFLLElBQUksTUFBTTtBQUFBLGdCQUFDLFNBQU9BLElBQU47QUFBQSxnQkFBUztBQUFDLHFCQUFLLElBQUksNkJBQTJCLE1BQUssS0FBSyxJQUFJLDRCQUEwQixNQUFLLEtBQUssSUFBSSx5QkFBdUIsTUFBSyxLQUFLLElBQUksaUJBQWUsTUFBSyxLQUFLLElBQUksVUFBUSxNQUFLLEtBQUssSUFBSSxnQkFBYztBQUFBLGNBQUk7QUFBQyxtQkFBSyxNQUFJLE1BQUssS0FBSyxXQUFTLE1BQUtBLE1BQUcsS0FBSyxLQUFLLFNBQVFBLEVBQUMsR0FBRSxLQUFLLEtBQUssT0FBTyxHQUFFSCxHQUFFO0FBQUEsWUFBQyxDQUFDO0FBQUEsVUFBRTtBQUFBLFVBQUMsV0FBV0csSUFBRTtBQUFDLGdCQUFHLENBQUNBLEdBQUU7QUFBUSxxQkFBTyxLQUFLLFFBQVEsRUFBRSxJQUFJLE1BQU0sa0RBQWtELEdBQUUsa0JBQWtCLENBQUM7QUFBRSxpQkFBSyxXQUFTQSxHQUFFLFNBQVEsS0FBSyxTQUFTLGFBQVcsZUFBYyxZQUFVLE9BQU8sS0FBSyxTQUFTLCtCQUE2QixLQUFLLFNBQVMsNkJBQTJCLElBQUcsS0FBSyxjQUFZLEtBQUssU0FBUyxPQUFNLEtBQUssU0FBUyxZQUFVLENBQUFBLE9BQUc7QUFBQyxtQkFBSyxrQkFBa0JBLEVBQUM7QUFBQSxZQUFDLEdBQUUsS0FBSyxTQUFTLHNCQUFvQixNQUFJO0FBQUMsbUJBQUssNEJBQTRCO0FBQUEsWUFBQyxHQUFFLEtBQUssU0FBUyxTQUFPLE1BQUk7QUFBQyxtQkFBSyxlQUFlO0FBQUEsWUFBQyxHQUFFLEtBQUssU0FBUyxVQUFRLE1BQUk7QUFBQyxtQkFBSyxnQkFBZ0I7QUFBQSxZQUFDLEdBQUUsS0FBSyxTQUFTLFVBQVEsQ0FBQUEsT0FBRztBQUFDLG9CQUFNSCxLQUFFRyxHQUFFLGlCQUFpQixRQUFNQSxHQUFFLFFBQU0sSUFBSSxNQUFNLHNCQUFzQkEsR0FBRSxXQUFXQSxHQUFFLFlBQVlBLEdBQUUsVUFBVUEsR0FBRSxPQUFPO0FBQUUsbUJBQUssUUFBUSxFQUFFSCxJQUFFLGtCQUFrQixDQUFDO0FBQUEsWUFBQztBQUFFLGdCQUFJQSxLQUFFO0FBQUcsaUJBQUssbUJBQWlCLFlBQVksTUFBSTtBQUFDLG1CQUFLLFlBQVUsY0FBWSxLQUFLLFNBQVMsY0FBWUEsTUFBRyxLQUFLLGdCQUFnQixHQUFFQSxLQUFFLFFBQUlBLEtBQUU7QUFBQSxZQUFFLEdBQUUsR0FBSTtBQUFBLFVBQUM7QUFBQSxVQUFDLFFBQU87QUFBQSxVQUFDO0FBQUEsVUFBQyxPQUFPRyxJQUFFSCxJQUFFRCxJQUFFO0FBQUMsZ0JBQUcsS0FBSztBQUFVLHFCQUFPQSxHQUFFLEVBQUUsSUFBSSxNQUFNLHNDQUFzQyxHQUFFLGtCQUFrQixDQUFDO0FBQUUsZ0JBQUcsS0FBSyxZQUFXO0FBQUMsa0JBQUc7QUFBQyxxQkFBSyxLQUFLSSxFQUFDO0FBQUEsY0FBQyxTQUFPQSxJQUFOO0FBQVMsdUJBQU8sS0FBSyxRQUFRLEVBQUVBLElBQUUsa0JBQWtCLENBQUM7QUFBQSxjQUFDO0FBQUMsbUJBQUssU0FBUyxpQkFBZSxLQUFHLEtBQUssT0FBTyx5Q0FBd0MsS0FBSyxTQUFTLGNBQWMsR0FBRSxLQUFLLE1BQUlKLE1BQUdBLEdBQUUsSUFBSTtBQUFBLFlBQUM7QUFBTSxtQkFBSyxPQUFPLHNCQUFzQixHQUFFLEtBQUssU0FBT0ksSUFBRSxLQUFLLE1BQUlKO0FBQUEsVUFBQztBQUFBLFVBQUMsWUFBVztBQUFDLGdCQUFHLENBQUMsS0FBSyxXQUFVO0FBQUMsb0JBQU1JLEtBQUUsTUFBSTtBQUFDLDJCQUFXLE1BQUksS0FBSyxRQUFRLEdBQUUsR0FBRztBQUFBLGNBQUM7QUFBRSxtQkFBSyxhQUFXQSxHQUFFLElBQUUsS0FBSyxLQUFLLFdBQVVBLEVBQUM7QUFBQSxZQUFDO0FBQUEsVUFBQztBQUFBLFVBQUMsMkJBQTBCO0FBQUMsaUJBQUssYUFBVyxLQUFLLHNCQUFvQixLQUFLLE9BQU8sNkJBQTZCLEdBQUUsS0FBSyxvQkFBa0IsV0FBVyxNQUFJO0FBQUMsbUJBQUssaUJBQWUsS0FBSyxlQUFhLE1BQUcsS0FBSyxPQUFPLCtCQUErQixHQUFFLEtBQUssS0FBSyxZQUFZLEdBQUUsS0FBSyxLQUFLLGNBQWM7QUFBQSxZQUFFLEdBQUUsS0FBSyxrQkFBa0I7QUFBQSxVQUFFO0FBQUEsVUFBQyxlQUFjO0FBQUMsaUJBQUssYUFBVyxLQUFLLElBQUksWUFBWSxLQUFLLFlBQVksRUFBRSxLQUFLLENBQUFBLE9BQUc7QUFBQyxrQkFBRyxLQUFLO0FBQVU7QUFBTyxtQkFBSyxXQUFTLEtBQUsscUJBQW1CQSxHQUFFLE1BQUlKLEdBQUVJLEdBQUUsR0FBRyxJQUFHQSxHQUFFLE1BQUksS0FBSyxhQUFhQSxHQUFFLEdBQUc7QUFBRSxvQkFBTUgsS0FBRSxNQUFJO0FBQUMsb0JBQUcsQ0FBQyxLQUFLLFdBQVU7QUFBQyx3QkFBTUEsS0FBRSxLQUFLLElBQUksb0JBQWtCRztBQUFFLHVCQUFLLE9BQU8sUUFBUSxHQUFFLEtBQUssS0FBSyxVQUFTLEVBQUMsTUFBS0gsR0FBRSxNQUFLLEtBQUlBLEdBQUUsSUFBRyxDQUFDO0FBQUEsZ0JBQUM7QUFBQSxjQUFDO0FBQUUsbUJBQUssSUFBSSxvQkFBb0JHLEVBQUMsRUFBRSxLQUFLLE1BQUk7QUFBQyxxQkFBSyxPQUFPLHFCQUFxQixHQUFFLEtBQUssY0FBWSxLQUFLLFdBQVMsS0FBSyxlQUFhSCxHQUFFLElBQUUsS0FBSyxLQUFLLGdCQUFlQSxFQUFDO0FBQUEsY0FBRSxDQUFDLEVBQUUsTUFBTSxDQUFBRyxPQUFHO0FBQUMscUJBQUssUUFBUSxFQUFFQSxJQUFFLDJCQUEyQixDQUFDO0FBQUEsY0FBQyxDQUFDO0FBQUEsWUFBQyxDQUFDLEVBQUUsTUFBTSxDQUFBQSxPQUFHO0FBQUMsbUJBQUssUUFBUSxFQUFFQSxJQUFFLGtCQUFrQixDQUFDO0FBQUEsWUFBQyxDQUFDO0FBQUEsVUFBQztBQUFBLFVBQUMsOEJBQTZCO0FBQUMsaUJBQUssSUFBSSxtQkFBaUIsS0FBSyxJQUFJLGdCQUFnQixFQUFFLFFBQVEsQ0FBQUEsT0FBRztBQUFDLGNBQUFBLEdBQUUsT0FBSyxDQUFDQSxHQUFFLE9BQU8sU0FBT0EsR0FBRSxjQUFZQSxHQUFFLFlBQVUsTUFBRyxLQUFLLGVBQWVBLEdBQUUsT0FBTyxNQUFNLElBQUk7QUFBQSxZQUFFLENBQUM7QUFBQSxVQUFDO0FBQUEsVUFBQyxnQkFBZTtBQUFDLGlCQUFLLGFBQVcsS0FBSyxJQUFJLGFBQWEsS0FBSyxhQUFhLEVBQUUsS0FBSyxDQUFBQSxPQUFHO0FBQUMsa0JBQUcsS0FBSztBQUFVO0FBQU8sbUJBQUssV0FBUyxLQUFLLHFCQUFtQkEsR0FBRSxNQUFJSixHQUFFSSxHQUFFLEdBQUcsSUFBR0EsR0FBRSxNQUFJLEtBQUssYUFBYUEsR0FBRSxHQUFHO0FBQUUsb0JBQU1ILEtBQUUsTUFBSTtBQUFDLG9CQUFHLENBQUMsS0FBSyxXQUFVO0FBQUMsd0JBQU1BLEtBQUUsS0FBSyxJQUFJLG9CQUFrQkc7QUFBRSx1QkFBSyxPQUFPLFFBQVEsR0FBRSxLQUFLLEtBQUssVUFBUyxFQUFDLE1BQUtILEdBQUUsTUFBSyxLQUFJQSxHQUFFLElBQUcsQ0FBQyxHQUFFLEtBQUssYUFBVyxLQUFLLDRCQUE0QjtBQUFBLGdCQUFDO0FBQUEsY0FBQztBQUFFLG1CQUFLLElBQUksb0JBQW9CRyxFQUFDLEVBQUUsS0FBSyxNQUFJO0FBQUMscUJBQUssY0FBWSxLQUFLLFdBQVMsS0FBSyxlQUFhSCxHQUFFLElBQUUsS0FBSyxLQUFLLGdCQUFlQSxFQUFDO0FBQUEsY0FBRSxDQUFDLEVBQUUsTUFBTSxDQUFBRyxPQUFHO0FBQUMscUJBQUssUUFBUSxFQUFFQSxJQUFFLDJCQUEyQixDQUFDO0FBQUEsY0FBQyxDQUFDO0FBQUEsWUFBQyxDQUFDLEVBQUUsTUFBTSxDQUFBQSxPQUFHO0FBQUMsbUJBQUssUUFBUSxFQUFFQSxJQUFFLG1CQUFtQixDQUFDO0FBQUEsWUFBQyxDQUFDO0FBQUEsVUFBQztBQUFBLFVBQUMsMkJBQTBCO0FBQUMsaUJBQUssYUFBVyxhQUFXLEtBQUssSUFBSSxtQkFBaUIsS0FBSyxRQUFRLEVBQUUsSUFBSSxNQUFNLG9CQUFvQixHQUFFLHdCQUF3QixDQUFDO0FBQUEsVUFBQztBQUFBLFVBQUMsb0JBQW1CO0FBQUMsZ0JBQUcsS0FBSztBQUFVO0FBQU8sa0JBQU1BLEtBQUUsS0FBSyxJQUFJLG9CQUFtQkgsS0FBRSxLQUFLLElBQUk7QUFBa0IsaUJBQUssT0FBTyxtREFBa0RHLElBQUVILEVBQUMsR0FBRSxLQUFLLEtBQUssa0JBQWlCRyxJQUFFSCxFQUFDLElBQUcsZ0JBQWNHLE1BQUcsZ0JBQWNBLFFBQUssS0FBSyxXQUFTLE1BQUcsS0FBSyxZQUFZLElBQUcsYUFBV0EsTUFBRyxLQUFLLFFBQVEsRUFBRSxJQUFJLE1BQU0sd0JBQXdCLEdBQUUsNEJBQTRCLENBQUMsR0FBRSxhQUFXQSxNQUFHLEtBQUssUUFBUSxFQUFFLElBQUksTUFBTSx3QkFBd0IsR0FBRSwyQkFBMkIsQ0FBQztBQUFBLFVBQUM7QUFBQSxVQUFDLFNBQVNBLElBQUU7QUFBQyxrQkFBTUgsS0FBRSxDQUFBRyxRQUFJLHFCQUFtQixPQUFPLFVBQVUsU0FBUyxLQUFLQSxHQUFFLE1BQU0sS0FBR0EsR0FBRSxPQUFPLFFBQVEsQ0FBQUgsT0FBRztBQUFDLHFCQUFPLE9BQU9HLElBQUVILEVBQUM7QUFBQSxZQUFDLENBQUMsR0FBRUc7QUFBRyxrQkFBSSxLQUFLLElBQUksU0FBUyxVQUFRLEtBQUssdUJBQXFCLEtBQUssSUFBSSxTQUFTLEVBQUUsS0FBSyxDQUFBSixPQUFHO0FBQUMsb0JBQU1FLEtBQUUsQ0FBQztBQUFFLGNBQUFGLEdBQUUsUUFBUSxDQUFBSSxPQUFHO0FBQUMsZ0JBQUFGLEdBQUUsS0FBS0QsR0FBRUcsRUFBQyxDQUFDO0FBQUEsY0FBQyxDQUFDLEdBQUVBLEdBQUUsTUFBS0YsRUFBQztBQUFBLFlBQUMsR0FBRSxDQUFBRCxPQUFHRyxHQUFFSCxFQUFDLENBQUMsSUFBRSxJQUFFLEtBQUssSUFBSSxTQUFTLFNBQU8sS0FBSyxJQUFJLFNBQVMsQ0FBQUQsT0FBRztBQUFDLGtCQUFHLEtBQUs7QUFBVTtBQUFPLG9CQUFNRSxLQUFFLENBQUM7QUFBRSxjQUFBRixHQUFFLE9BQU8sRUFBRSxRQUFRLENBQUFJLE9BQUc7QUFBQyxzQkFBTUosS0FBRSxDQUFDO0FBQUUsZ0JBQUFJLEdBQUUsTUFBTSxFQUFFLFFBQVEsQ0FBQUgsT0FBRztBQUFDLGtCQUFBRCxHQUFFQyxFQUFDLElBQUVHLEdBQUUsS0FBS0gsRUFBQztBQUFBLGdCQUFDLENBQUMsR0FBRUQsR0FBRSxLQUFHSSxHQUFFLElBQUdKLEdBQUUsT0FBS0ksR0FBRSxNQUFLSixHQUFFLFlBQVVJLEdBQUUsV0FBVUYsR0FBRSxLQUFLRCxHQUFFRCxFQUFDLENBQUM7QUFBQSxjQUFDLENBQUMsR0FBRUksR0FBRSxNQUFLRixFQUFDO0FBQUEsWUFBQyxHQUFFLENBQUFELE9BQUdHLEdBQUVILEVBQUMsQ0FBQyxJQUFFRyxHQUFFLE1BQUssQ0FBQyxDQUFDO0FBQUEsVUFBQztBQUFBLFVBQUMsY0FBYTtBQUFDLGdCQUFHLEtBQUssT0FBTywrQkFBOEIsS0FBSyxVQUFTLEtBQUssYUFBYSxHQUFFLEtBQUssY0FBWSxLQUFLLGVBQWEsQ0FBQyxLQUFLLFlBQVUsQ0FBQyxLQUFLO0FBQWM7QUFBTyxpQkFBSyxjQUFZO0FBQUcsa0JBQU1BLEtBQUUsTUFBSTtBQUFDLG1CQUFLLGFBQVcsS0FBSyxTQUFTLENBQUNILElBQUVELE9BQUk7QUFBQyxvQkFBRyxLQUFLO0FBQVU7QUFBTyxnQkFBQUMsT0FBSUQsS0FBRSxDQUFDO0FBQUcsc0JBQU1FLEtBQUUsQ0FBQyxHQUFFQyxLQUFFLENBQUMsR0FBRUUsS0FBRSxDQUFDO0FBQUUsb0JBQUlRLEtBQUU7QUFBRyxnQkFBQWIsR0FBRSxRQUFRLENBQUFJLE9BQUc7QUFBQyxtQkFBQyxzQkFBb0JBLEdBQUUsUUFBTSx1QkFBcUJBLEdBQUUsVUFBUUYsR0FBRUUsR0FBRSxFQUFFLElBQUVBLE1BQUkscUJBQW1CQSxHQUFFLFFBQU0sc0JBQW9CQSxHQUFFLFVBQVFELEdBQUVDLEdBQUUsRUFBRSxJQUFFQSxNQUFJLG9CQUFrQkEsR0FBRSxRQUFNLHFCQUFtQkEsR0FBRSxVQUFRQyxHQUFFRCxHQUFFLEVBQUUsSUFBRUE7QUFBQSxnQkFBRSxDQUFDO0FBQUUsc0JBQU1FLEtBQUUsQ0FBQUYsT0FBRztBQUFDLGtCQUFBUyxLQUFFO0FBQUcsc0JBQUlaLEtBQUVFLEdBQUVDLEdBQUUsZ0JBQWdCO0FBQUUsa0JBQUFILE9BQUlBLEdBQUUsTUFBSUEsR0FBRSxZQUFVLEtBQUssZUFBYUEsR0FBRSxNQUFJQSxHQUFFLFNBQVEsS0FBSyxZQUFVLENBQUNBLEdBQUUsUUFBTUEsTUFBR0EsR0FBRSxhQUFXLEtBQUssZUFBYUEsR0FBRSxXQUFVLEtBQUssWUFBVSxDQUFDQSxHQUFFLGNBQVksWUFBVSxPQUFPRyxHQUFFLHFCQUFtQkgsS0FBRUcsR0FBRSxpQkFBaUIsTUFBTSxHQUFHLEdBQUUsS0FBSyxlQUFhSCxHQUFFLENBQUMsR0FBRSxLQUFLLFlBQVUsQ0FBQ0EsR0FBRSxDQUFDLElBQUcsS0FBSyxpQkFBZSxLQUFLLGNBQVksS0FBSyxhQUFhLFNBQVMsR0FBRyxJQUFFLFNBQU87QUFBUSxzQkFBSUQsS0FBRUUsR0FBRUUsR0FBRSxpQkFBaUI7QUFBRSxrQkFBQUosT0FBSUEsR0FBRSxNQUFJQSxHQUFFLFlBQVUsS0FBSyxnQkFBY0EsR0FBRSxNQUFJQSxHQUFFLFNBQVEsS0FBSyxhQUFXLENBQUNBLEdBQUUsUUFBTUEsTUFBR0EsR0FBRSxhQUFXLEtBQUssZ0JBQWNBLEdBQUUsV0FBVSxLQUFLLGFBQVcsQ0FBQ0EsR0FBRSxjQUFZLFlBQVUsT0FBT0ksR0FBRSxzQkFBb0JKLEtBQUVJLEdBQUUsa0JBQWtCLE1BQU0sR0FBRyxHQUFFLEtBQUssZ0JBQWNKLEdBQUUsQ0FBQyxHQUFFLEtBQUssYUFBVyxDQUFDQSxHQUFFLENBQUMsSUFBRyxLQUFLLGtCQUFnQixLQUFLLGVBQWEsS0FBSyxjQUFjLFNBQVMsR0FBRyxJQUFFLFNBQU8sU0FBUSxLQUFLLE9BQU8sc0NBQXFDLEtBQUssY0FBYSxLQUFLLFdBQVUsS0FBSyxlQUFjLEtBQUssVUFBVTtBQUFBLGdCQUFDO0FBQUUsb0JBQUdBLEdBQUUsUUFBUSxDQUFBSSxPQUFHO0FBQUMsa0NBQWNBLEdBQUUsUUFBTUEsR0FBRSwyQkFBeUJFLEdBQUVELEdBQUVELEdBQUUsdUJBQXVCLENBQUMsSUFBRyx3QkFBc0JBLEdBQUUsUUFBTSxXQUFTQSxHQUFFLHlCQUF1QixvQkFBa0JBLEdBQUUsUUFBTSxxQkFBbUJBLEdBQUUsU0FBT0EsR0FBRSxhQUFXRSxHQUFFRixFQUFDO0FBQUEsZ0JBQUMsQ0FBQyxHQUFFLENBQUNTLE9BQUksQ0FBQyxPQUFPLEtBQUtSLEVBQUMsRUFBRSxVQUFRLE9BQU8sS0FBS0YsRUFBQyxFQUFFO0FBQVEseUJBQU8sS0FBSyxXQUFXQyxJQUFFLEdBQUc7QUFBRSxvQkFBRyxLQUFLLGNBQVksT0FBRyxLQUFLLGFBQVcsTUFBRyxLQUFLLFFBQU87QUFBQyxzQkFBRztBQUFDLHlCQUFLLEtBQUssS0FBSyxNQUFNO0FBQUEsa0JBQUMsU0FBT0EsSUFBTjtBQUFTLDJCQUFPLEtBQUssUUFBUSxFQUFFQSxJQUFFLGtCQUFrQixDQUFDO0FBQUEsa0JBQUM7QUFBQyx1QkFBSyxTQUFPLE1BQUssS0FBSyxPQUFPLHdDQUEwQztBQUFFLHdCQUFNQSxLQUFFLEtBQUs7QUFBSSx1QkFBSyxNQUFJLE1BQUtBLEdBQUUsSUFBSTtBQUFBLGdCQUFDO0FBQUMsNEJBQVUsT0FBTyxLQUFLLFNBQVMsK0JBQTZCLEtBQUssWUFBVSxZQUFZLE1BQUksS0FBSyxZQUFZLEdBQUUsR0FBRyxHQUFFLEtBQUssVUFBVSxTQUFPLEtBQUssVUFBVSxNQUFNLElBQUcsS0FBSyxPQUFPLFNBQVMsR0FBRSxLQUFLLEtBQUssU0FBUztBQUFBLGNBQUMsQ0FBQztBQUFBLFlBQUM7QUFBRSxZQUFBQSxHQUFFO0FBQUEsVUFBQztBQUFBLFVBQUMsY0FBYTtBQUFDLGlCQUFLLE9BQUssS0FBSyxZQUFVLEVBQUUsS0FBSyxTQUFTLGlCQUFlLE1BQUksS0FBSyw0QkFBNEI7QUFBQSxVQUFDO0FBQUEsVUFBQywwQkFBeUI7QUFBQyxpQkFBSyxjQUFZLGFBQVcsS0FBSyxJQUFJLG1CQUFpQixLQUFLLGlCQUFlLE9BQUcsS0FBSyxPQUFPLHlCQUF3QixLQUFLLHNCQUFzQixHQUFFLEtBQUssdUJBQXVCLFFBQVEsQ0FBQUEsT0FBRztBQUFDLG1CQUFLLElBQUksWUFBWUEsRUFBQyxHQUFFLEtBQUsscUJBQW1CO0FBQUEsWUFBRSxDQUFDLEdBQUUsS0FBSyx5QkFBdUIsQ0FBQyxHQUFFLEtBQUssc0JBQW9CLEtBQUssT0FBTyw0QkFBNEIsR0FBRSxLQUFLLHFCQUFtQixPQUFHLEtBQUssa0JBQWtCLE1BQUksS0FBSyxPQUFPLFlBQVksR0FBRSxLQUFLLEtBQUssWUFBWSxLQUFJLEtBQUssT0FBTywyQkFBMEIsS0FBSyxJQUFJLGNBQWMsR0FBRSxLQUFLLEtBQUssd0JBQXVCLEtBQUssSUFBSSxjQUFjO0FBQUEsVUFBRTtBQUFBLFVBQUMsZ0JBQWdCQSxJQUFFO0FBQUMsaUJBQUssY0FBWUEsR0FBRSxhQUFXLEtBQUssVUFBUSxLQUFLLEtBQUssVUFBUyxFQUFDLE1BQUssYUFBWSxXQUFVLEVBQUMsV0FBVUEsR0FBRSxVQUFVLFdBQVUsZUFBY0EsR0FBRSxVQUFVLGVBQWMsUUFBT0EsR0FBRSxVQUFVLE9BQU0sRUFBQyxDQUFDLElBQUUsQ0FBQ0EsR0FBRSxhQUFXLENBQUMsS0FBSyxpQkFBZSxLQUFLLGVBQWEsTUFBRyxLQUFLLEtBQUssY0FBYyxJQUFHQSxHQUFFLGFBQVcsS0FBSyx5QkFBeUI7QUFBQSxVQUFFO0FBQUEsVUFBQyxrQkFBa0JBLElBQUU7QUFBQyxnQkFBRyxLQUFLO0FBQVU7QUFBTyxnQkFBSUgsS0FBRUcsR0FBRTtBQUFLLFlBQUFILGNBQWEsZ0JBQWNBLEtBQUUsRUFBRSxLQUFLQSxFQUFDLElBQUcsS0FBSyxLQUFLQSxFQUFDO0FBQUEsVUFBQztBQUFBLFVBQUMsOEJBQTZCO0FBQUMsZ0JBQUcsQ0FBQyxLQUFLLGFBQVcsS0FBSyxLQUFJO0FBQUMsbUJBQUssT0FBTywwQ0FBeUMsS0FBSyxTQUFTLGNBQWM7QUFBRSxvQkFBTUcsS0FBRSxLQUFLO0FBQUksbUJBQUssTUFBSSxNQUFLQSxHQUFFLElBQUk7QUFBQSxZQUFDO0FBQUEsVUFBQztBQUFBLFVBQUMsaUJBQWdCO0FBQUMsaUJBQUssY0FBWSxLQUFLLGNBQVksS0FBSyxPQUFPLGlCQUFpQixHQUFFLEtBQUssZ0JBQWMsTUFBRyxLQUFLLFlBQVk7QUFBQSxVQUFFO0FBQUEsVUFBQyxrQkFBaUI7QUFBQyxpQkFBSyxjQUFZLEtBQUssT0FBTyxrQkFBa0IsR0FBRSxLQUFLLFFBQVE7QUFBQSxVQUFFO0FBQUEsVUFBQyxTQUFTQSxJQUFFO0FBQUMsaUJBQUssYUFBV0EsR0FBRSxRQUFRLFFBQVEsQ0FBQUgsT0FBRztBQUFDLG1CQUFLLE9BQU8sVUFBVSxHQUFFLEtBQUssS0FBSyxTQUFRRyxHQUFFLE9BQU1ILEVBQUMsR0FBRSxLQUFLLGNBQWMsS0FBSyxFQUFDLE9BQU1HLEdBQUUsT0FBTSxRQUFPSCxHQUFDLENBQUMsR0FBRSxLQUFLLGVBQWUsS0FBSyxDQUFBRyxPQUFHQSxHQUFFLE9BQUtILEdBQUUsRUFBRSxNQUFJLEtBQUssZUFBZSxLQUFLQSxFQUFDLEdBQUUsRUFBRSxNQUFJO0FBQUMscUJBQUssT0FBTyxXQUFXLEdBQUUsS0FBSyxLQUFLLFVBQVNBLEVBQUM7QUFBQSxjQUFDLENBQUM7QUFBQSxZQUFFLENBQUM7QUFBQSxVQUFDO0FBQUEsVUFBQyxTQUFRO0FBQUMsa0JBQU1HLEtBQUUsQ0FBQyxFQUFFLE1BQU0sS0FBSyxTQUFTO0FBQUUsWUFBQUEsR0FBRSxDQUFDLElBQUUsTUFBSSxLQUFLLE1BQUksT0FBS0EsR0FBRSxDQUFDLEdBQUUsRUFBRSxNQUFNLE1BQUtBLEVBQUM7QUFBQSxVQUFDO0FBQUEsUUFBQztBQUFDLFVBQUUsaUJBQWUsQ0FBQyxDQUFDLEVBQUUsR0FBRSxFQUFFLFNBQU8sRUFBQyxZQUFXLENBQUMsRUFBQyxNQUFLLENBQUMsZ0NBQStCLGtDQUFrQyxFQUFDLENBQUMsR0FBRSxjQUFhLGVBQWMsR0FBRSxFQUFFLGdCQUFjLENBQUMsR0FBRUgsR0FBRSxVQUFRO0FBQUEsTUFBQyxHQUFFLEVBQUMsUUFBTyxHQUFFLE9BQU0sR0FBRSxZQUFXLEdBQUUsbUJBQWtCLEdBQUUsbUJBQWtCLElBQUcsYUFBWSxJQUFHLG1CQUFrQixHQUFFLENBQUMsRUFBQyxHQUFFLENBQUMsR0FBRSxDQUFDLENBQUMsRUFBRSxHQUFHO0FBQUEsSUFBQyxDQUFDO0FBQUE7QUFBQTs7O0FDTDd3OUY7QUFBQTtBQUFBO0FBQUE7QUFBQTs7O0FDQUEsSUFBQWlCLG9CQUFvRTs7O0FDTTdELElBQU0sUUFBUSxLQUFLO0FBRW5CLElBQU0sTUFBTSxLQUFLO0FBR2pCLElBQU0sUUFBUSxLQUFLO0FBbUJuQixJQUFNLE1BQU0sQ0FBQyxHQUFHLE1BQU0sSUFBSSxJQUFJLElBQUk7QUFRbEMsSUFBTSxNQUFNLENBQUMsR0FBRyxNQUFNLElBQUksSUFBSSxJQUFJO0FBRWxDLElBQU1DLFNBQVEsT0FBTztBQUVyQixJQUFNLE1BQU0sS0FBSztBQWVqQixJQUFNLGlCQUFpQixPQUFLLE1BQU0sSUFBSSxJQUFJLElBQUksSUFBSSxJQUFJOzs7QUNwQ3RELElBQU0sY0FBYyxLQUFLOzs7QUNQekIsSUFBTSxTQUFTLE1BQU0sb0JBQUksSUFBSTtBQVU3QixJQUFNLE9BQU8sT0FBSztBQUN2QixRQUFNLElBQUksT0FBTztBQUNqQixJQUFFLFFBQVEsQ0FBQyxHQUFHLE1BQU07QUFBRSxNQUFFLElBQUksR0FBRyxDQUFDO0FBQUEsRUFBRSxDQUFDO0FBQ25DLFNBQU87QUFDVDtBQWtCTyxJQUFNLGlCQUFpQixDQUFDQyxNQUFLLEtBQUssWUFBWTtBQUNuRCxNQUFJLE1BQU1BLEtBQUksSUFBSSxHQUFHO0FBQ3JCLE1BQUksUUFBUSxRQUFXO0FBQ3JCLElBQUFBLEtBQUksSUFBSSxLQUFLLE1BQU0sUUFBUSxDQUFDO0FBQUEsRUFDOUI7QUFDQSxTQUFPO0FBQ1Q7QUFhTyxJQUFNLE1BQU0sQ0FBQyxHQUFHLE1BQU07QUFDM0IsUUFBTSxNQUFNLENBQUM7QUFDYixhQUFXLENBQUMsS0FBSyxLQUFLLEtBQUssR0FBRztBQUM1QixRQUFJLEtBQUssRUFBRSxPQUFPLEdBQUcsQ0FBQztBQUFBLEVBQ3hCO0FBQ0EsU0FBTztBQUNUO0FBY08sSUFBTSxNQUFNLENBQUMsR0FBRyxNQUFNO0FBQzNCLGFBQVcsQ0FBQyxLQUFLLEtBQUssS0FBSyxHQUFHO0FBQzVCLFFBQUksRUFBRSxPQUFPLEdBQUcsR0FBRztBQUNqQixhQUFPO0FBQUEsSUFDVDtBQUFBLEVBQ0Y7QUFDQSxTQUFPO0FBQ1Q7OztBQ3RGTyxJQUFNQyxVQUFTLE1BQU0sb0JBQUksSUFBSTs7O0FDUzdCLElBQU0sT0FBTyxTQUFPLElBQUksSUFBSSxTQUFTLENBQUM7QUFzQnRDLElBQU0sV0FBVyxDQUFDLE1BQU0sUUFBUTtBQUNyQyxXQUFTLElBQUksR0FBRyxJQUFJLElBQUksUUFBUSxLQUFLO0FBQ25DLFNBQUssS0FBSyxJQUFJLENBQUMsQ0FBQztBQUFBLEVBQ2xCO0FBQ0Y7QUFVTyxJQUFNLE9BQU8sTUFBTTtBQWdDbkIsSUFBTSxPQUFPLENBQUMsS0FBSyxNQUFNO0FBQzlCLFdBQVMsSUFBSSxHQUFHLElBQUksSUFBSSxRQUFRLEtBQUs7QUFDbkMsUUFBSSxFQUFFLElBQUksQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHO0FBQ3JCLGFBQU87QUFBQSxJQUNUO0FBQUEsRUFDRjtBQUNBLFNBQU87QUFDVDtBQXlDTyxJQUFNLFVBQVUsTUFBTTs7O0FDaEh0QixJQUFNLGVBQU4sTUFBbUI7QUFBQSxFQUN4QixjQUFlO0FBS2IsU0FBSyxhQUFpQixPQUFPO0FBQUEsRUFDL0I7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFPQSxHQUFJLE1BQU0sR0FBRztBQUNYLElBQUk7QUFBQSxNQUFlLEtBQUs7QUFBQTtBQUFBLE1BQW1DO0FBQUEsTUFBV0M7QUFBQSxJQUFNLEVBQUUsSUFBSSxDQUFDO0FBQ25GLFdBQU87QUFBQSxFQUNUO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBT0EsS0FBTSxNQUFNLEdBQUc7QUFJYixVQUFNLEtBQUssSUFBSUMsVUFBUztBQUN0QixXQUFLO0FBQUEsUUFBSTtBQUFBO0FBQUEsUUFBMEI7QUFBQSxNQUFHO0FBQ3RDLFFBQUUsR0FBR0EsS0FBSTtBQUFBLElBQ1g7QUFDQSxTQUFLO0FBQUEsTUFBRztBQUFBO0FBQUEsTUFBMEI7QUFBQSxJQUFHO0FBQUEsRUFDdkM7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFPQSxJQUFLLE1BQU0sR0FBRztBQUNaLFVBQU0sWUFBWSxLQUFLLFdBQVcsSUFBSSxJQUFJO0FBQzFDLFFBQUksY0FBYyxRQUFXO0FBQzNCLGdCQUFVLE9BQU8sQ0FBQztBQUNsQixVQUFJLFVBQVUsU0FBUyxHQUFHO0FBQ3hCLGFBQUssV0FBVyxPQUFPLElBQUk7QUFBQSxNQUM3QjtBQUFBLElBQ0Y7QUFBQSxFQUNGO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQVlBLEtBQU0sTUFBTUEsT0FBTTtBQUVoQixXQUFhLE1BQU0sS0FBSyxXQUFXLElBQUksSUFBSSxLQUFTLE9BQU8sR0FBRyxPQUFPLENBQUMsRUFBRSxRQUFRLE9BQUssRUFBRSxHQUFHQSxLQUFJLENBQUM7QUFBQSxFQUNqRztBQUFBLEVBRUEsVUFBVztBQUNULFNBQUssYUFBaUIsT0FBTztBQUFBLEVBQy9CO0FBQ0Y7QUFTTyxJQUFNLGFBQU4sTUFBaUI7QUFBQSxFQUN0QixjQUFlO0FBS2IsU0FBSyxhQUFpQixPQUFPO0FBQUEsRUFDL0I7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBTUEsR0FBSSxNQUFNLEdBQUc7QUFDWCxJQUFJLGVBQWUsS0FBSyxZQUFZLE1BQVVELE9BQU0sRUFBRSxJQUFJLENBQUM7QUFBQSxFQUM3RDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFNQSxLQUFNLE1BQU0sR0FBRztBQUliLFVBQU0sS0FBSyxJQUFJQyxVQUFTO0FBQ3RCLFdBQUssSUFBSSxNQUFNLEVBQUU7QUFDakIsUUFBRSxHQUFHQSxLQUFJO0FBQUEsSUFDWDtBQUNBLFNBQUssR0FBRyxNQUFNLEVBQUU7QUFBQSxFQUNsQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFNQSxJQUFLLE1BQU0sR0FBRztBQUNaLFVBQU0sWUFBWSxLQUFLLFdBQVcsSUFBSSxJQUFJO0FBQzFDLFFBQUksY0FBYyxRQUFXO0FBQzNCLGdCQUFVLE9BQU8sQ0FBQztBQUNsQixVQUFJLFVBQVUsU0FBUyxHQUFHO0FBQ3hCLGFBQUssV0FBVyxPQUFPLElBQUk7QUFBQSxNQUM3QjtBQUFBLElBQ0Y7QUFBQSxFQUNGO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFXQSxLQUFNLE1BQU1BLE9BQU07QUFFaEIsV0FBYSxNQUFNLEtBQUssV0FBVyxJQUFJLElBQUksS0FBUyxPQUFPLEdBQUcsT0FBTyxDQUFDLEVBQUUsUUFBUSxPQUFLLEVBQUUsR0FBR0EsS0FBSSxDQUFDO0FBQUEsRUFDakc7QUFBQSxFQUVBLFVBQVc7QUFDVCxTQUFLLGFBQWlCLE9BQU87QUFBQSxFQUMvQjtBQUNGOzs7QUMvSkEsSUFBQUMsbUJBQW1FOzs7QUNhNUQsSUFBTSxPQUFPO0FBQ2IsSUFBTSxPQUFPO0FBQ2IsSUFBTSxPQUFPO0FBQ2IsSUFBTSxPQUFPO0FBRWIsSUFBTSxPQUFPO0FBQ2IsSUFBTSxPQUFPO0FBQ2IsSUFBTSxPQUFPO0FBVWIsSUFBTSxRQUFRLEtBQUs7QUFDbkIsSUFBTSxRQUFRLEtBQUs7QUFDbkIsSUFBTSxRQUFRLEtBQUs7QUFDbkIsSUFBTSxRQUFRLEtBQUs7QUFDbkIsSUFBTSxRQUFRLEtBQUs7QUFDbkIsSUFBTSxRQUFRLEtBQUs7QUFDbkIsSUFBTSxRQUFRLEtBQUs7QUFDbkIsSUFBTSxRQUFRLEtBQUs7QUFDbkIsSUFBTSxRQUFRLEtBQUs7QUFDbkIsSUFBTSxRQUFRLEtBQUs7QUFDbkIsSUFBTSxRQUFRLEtBQUs7QUFDbkIsSUFBTSxRQUFRLEtBQUs7QUFDbkIsSUFBTSxRQUFRLEtBQUs7QUFDbkIsSUFBTSxRQUFRLEtBQUs7QUFDbkIsSUFBTSxRQUFRLEtBQUs7QUFZbkIsSUFBTSxRQUFRO0FBQ2QsSUFBTSxRQUFRO0FBQ2QsSUFBTSxRQUFRO0FBVWQsSUFBTSxTQUFTLFFBQVE7QUFDdkIsSUFBTSxTQUFTLFFBQVE7QUFDdkIsSUFBTSxTQUFTLFFBQVE7QUFDdkIsSUFBTSxTQUFTLFFBQVE7QUFDdkIsSUFBTSxTQUFTLFFBQVE7QUFDdkIsSUFBTSxTQUFTLFFBQVE7QUFDdkIsSUFBTSxTQUFTLFFBQVE7QUFDdkIsSUFBTSxTQUFTLFFBQVE7QUFDdkIsSUFBTSxTQUFTLFFBQVE7QUFDdkIsSUFBTSxTQUFTLFFBQVE7QUFDdkIsSUFBTSxTQUFTLFFBQVE7QUFDdkIsSUFBTSxTQUFTLFFBQVE7QUFDdkIsSUFBTSxTQUFTLFFBQVE7QUFDdkIsSUFBTSxTQUFTLFFBQVE7QUFJdkIsSUFBTSxTQUFTOzs7QUM1RWYsSUFBTSxtQkFBbUIsT0FBTztBQUNoQyxJQUFNLG1CQUFtQixPQUFPO0FBRWhDLElBQU0sZUFBZSxLQUFLO0FBSzFCLElBQU0sWUFBWSxPQUFPLGNBQWMsU0FBTyxPQUFPLFFBQVEsWUFBWSxTQUFTLEdBQUcsS0FBVSxNQUFNLEdBQUcsTUFBTTtBQUM5RyxJQUFNQyxTQUFRLE9BQU87QUFDckIsSUFBTUMsWUFBVyxPQUFPOzs7QUNYeEIsSUFBTSxlQUFlLE9BQU87QUFDNUIsSUFBTSxnQkFBZ0IsT0FBTztBQU03QixJQUFNLHNCQUFzQixhQUFhLEtBQUs7QUFNckQsSUFBTSxjQUFjLE9BQUssRUFBRSxZQUFZO0FBRXZDLElBQU0sZ0JBQWdCO0FBTWYsSUFBTSxXQUFXLE9BQUssRUFBRSxRQUFRLGVBQWUsRUFBRTtBQUV4RCxJQUFNLHFCQUFxQjtBQU9wQixJQUFNLGdCQUFnQixDQUFDLEdBQUcsY0FBYyxTQUFTLEVBQUUsUUFBUSxvQkFBb0IsV0FBUyxHQUFHLFlBQVksWUFBWSxLQUFLLEdBQUcsQ0FBQztBQWE1SCxJQUFNLHNCQUFzQixTQUFPO0FBQ3hDLFFBQU0sZ0JBQWdCLFNBQVMsbUJBQW1CLEdBQUcsQ0FBQztBQUN0RCxRQUFNLE1BQU0sY0FBYztBQUMxQixRQUFNLE1BQU0sSUFBSSxXQUFXLEdBQUc7QUFDOUIsV0FBUyxJQUFJLEdBQUcsSUFBSSxLQUFLLEtBQUs7QUFDNUIsUUFBSSxDQUFDO0FBQUEsSUFBMkIsY0FBYyxZQUFZLENBQUM7QUFBQSxFQUM3RDtBQUNBLFNBQU87QUFDVDtBQUdPLElBQU07QUFBQTtBQUFBLEVBQThDLE9BQU8sZ0JBQWdCLGNBQWMsSUFBSSxZQUFZLElBQUk7QUFBQTtBQU03RyxJQUFNLG9CQUFvQixTQUFPLGdCQUFnQixPQUFPLEdBQUc7QUFPM0QsSUFBTSxhQUFhLGtCQUFrQixvQkFBb0I7QUFzQnpELElBQUksa0JBQWtCLE9BQU8sZ0JBQWdCLGNBQWMsT0FBTyxJQUFJLFlBQVksU0FBUyxFQUFFLE9BQU8sTUFBTSxXQUFXLEtBQUssQ0FBQztBQUdsSSxJQUFJLG1CQUFtQixnQkFBZ0IsT0FBTyxJQUFJLFdBQVcsQ0FBQyxFQUFFLFdBQVcsR0FBRztBQU81RSxvQkFBa0I7QUFDcEI7OztBQ3ZFTyxJQUFNLFVBQU4sTUFBYztBQUFBLEVBQ25CLGNBQWU7QUFDYixTQUFLLE9BQU87QUFDWixTQUFLLE9BQU8sSUFBSSxXQUFXLEdBQUc7QUFJOUIsU0FBSyxPQUFPLENBQUM7QUFBQSxFQUNmO0FBQ0Y7QUFNTyxJQUFNLGdCQUFnQixNQUFNLElBQUksUUFBUTtBQWtCeEMsSUFBTSxTQUFTLGFBQVc7QUFDL0IsTUFBSSxNQUFNLFFBQVE7QUFDbEIsV0FBUyxJQUFJLEdBQUcsSUFBSSxRQUFRLEtBQUssUUFBUSxLQUFLO0FBQzVDLFdBQU8sUUFBUSxLQUFLLENBQUMsRUFBRTtBQUFBLEVBQ3pCO0FBQ0EsU0FBTztBQUNUO0FBa0JPLElBQU0sZUFBZSxhQUFXO0FBQ3JDLFFBQU0sV0FBVyxJQUFJLFdBQVcsT0FBTyxPQUFPLENBQUM7QUFDL0MsTUFBSSxTQUFTO0FBQ2IsV0FBUyxJQUFJLEdBQUcsSUFBSSxRQUFRLEtBQUssUUFBUSxLQUFLO0FBQzVDLFVBQU0sSUFBSSxRQUFRLEtBQUssQ0FBQztBQUN4QixhQUFTLElBQUksR0FBRyxNQUFNO0FBQ3RCLGNBQVUsRUFBRTtBQUFBLEVBQ2Q7QUFDQSxXQUFTLElBQUksSUFBSSxXQUFXLFFBQVEsS0FBSyxRQUFRLEdBQUcsUUFBUSxJQUFJLEdBQUcsTUFBTTtBQUN6RSxTQUFPO0FBQ1Q7QUFTTyxJQUFNLFlBQVksQ0FBQyxTQUFTLFFBQVE7QUFDekMsUUFBTSxZQUFZLFFBQVEsS0FBSztBQUMvQixNQUFJLFlBQVksUUFBUSxPQUFPLEtBQUs7QUFDbEMsWUFBUSxLQUFLLEtBQUssSUFBSSxXQUFXLFFBQVEsS0FBSyxRQUFRLEdBQUcsUUFBUSxJQUFJLENBQUM7QUFDdEUsWUFBUSxPQUFPLElBQUksV0FBZ0IsSUFBSSxXQUFXLEdBQUcsSUFBSSxDQUFDO0FBQzFELFlBQVEsT0FBTztBQUFBLEVBQ2pCO0FBQ0Y7QUFTTyxJQUFNLFFBQVEsQ0FBQyxTQUFTLFFBQVE7QUFDckMsUUFBTSxZQUFZLFFBQVEsS0FBSztBQUMvQixNQUFJLFFBQVEsU0FBUyxXQUFXO0FBQzlCLFlBQVEsS0FBSyxLQUFLLFFBQVEsSUFBSTtBQUM5QixZQUFRLE9BQU8sSUFBSSxXQUFXLFlBQVksQ0FBQztBQUMzQyxZQUFRLE9BQU87QUFBQSxFQUNqQjtBQUNBLFVBQVEsS0FBSyxRQUFRLE1BQU0sSUFBSTtBQUNqQztBQW9DTyxJQUFNLGFBQWE7QUFzRm5CLElBQU0sZUFBZSxDQUFDLFNBQVMsUUFBUTtBQUM1QyxTQUFPLE1BQWEsT0FBTztBQUN6QixVQUFNLFNBQWdCLE9BQWUsUUFBUSxHQUFJO0FBQ2pELFVBQVcsTUFBTSxNQUFNLEdBQUc7QUFBQSxFQUM1QjtBQUNBLFFBQU0sU0FBZ0IsUUFBUSxHQUFHO0FBQ25DO0FBV08sSUFBTSxjQUFjLENBQUMsU0FBUyxRQUFRO0FBQzNDLFFBQU0sYUFBa0IsZUFBZSxHQUFHO0FBQzFDLE1BQUksWUFBWTtBQUNkLFVBQU0sQ0FBQztBQUFBLEVBQ1Q7QUFFQSxRQUFNLFVBQVUsTUFBYSxRQUFlLE9BQU8sTUFBTSxhQUFvQixPQUFPLEtBQWEsUUFBUSxHQUFJO0FBQzdHLFFBQVcsTUFBTSxNQUFNLEVBQUU7QUFHekIsU0FBTyxNQUFNLEdBQUc7QUFDZCxVQUFNLFVBQVUsTUFBYSxRQUFlLE9BQU8sS0FBYSxRQUFRLEdBQUk7QUFDNUUsVUFBVyxNQUFNLE1BQU0sR0FBRztBQUFBLEVBQzVCO0FBQ0Y7QUFLQSxJQUFNLGFBQWEsSUFBSSxXQUFXLEdBQUs7QUFDdkMsSUFBTSxlQUFlLFdBQVcsU0FBUztBQVNsQyxJQUFNLHdCQUF3QixDQUFDLFNBQVMsUUFBUTtBQUNyRCxNQUFJLElBQUksU0FBUyxjQUFjO0FBRzdCLFVBQU0sVUFBaUIsZ0JBQWdCLFdBQVcsS0FBSyxVQUFVLEVBQUUsV0FBVztBQUM5RSxpQkFBYSxTQUFTLE9BQU87QUFDN0IsYUFBUyxJQUFJLEdBQUcsSUFBSSxTQUFTLEtBQUs7QUFDaEMsWUFBTSxTQUFTLFdBQVcsQ0FBQyxDQUFDO0FBQUEsSUFDOUI7QUFBQSxFQUNGLE9BQU87QUFDTCx1QkFBbUIsU0FBZ0IsV0FBVyxHQUFHLENBQUM7QUFBQSxFQUNwRDtBQUNGO0FBU08sSUFBTSwwQkFBMEIsQ0FBQyxTQUFTLFFBQVE7QUFDdkQsUUFBTSxnQkFBZ0IsU0FBUyxtQkFBbUIsR0FBRyxDQUFDO0FBQ3RELFFBQU0sTUFBTSxjQUFjO0FBQzFCLGVBQWEsU0FBUyxHQUFHO0FBQ3pCLFdBQVMsSUFBSSxHQUFHLElBQUksS0FBSyxLQUFLO0FBQzVCO0FBQUEsTUFBTTtBQUFBO0FBQUEsTUFBZ0MsY0FBYyxZQUFZLENBQUM7QUFBQSxJQUFFO0FBQUEsRUFDckU7QUFDRjtBQVVPLElBQU0saUJBQXlCO0FBQThDLGdCQUFpQixhQUFjLHdCQUF3QjtBQWdFcEksSUFBTSxrQkFBa0IsQ0FBQyxTQUFTLGVBQWU7QUFDdEQsUUFBTSxZQUFZLFFBQVEsS0FBSztBQUMvQixRQUFNLE9BQU8sUUFBUTtBQUNyQixRQUFNLGNBQW1CLElBQUksWUFBWSxNQUFNLFdBQVcsTUFBTTtBQUNoRSxRQUFNLGVBQWUsV0FBVyxTQUFTO0FBQ3pDLFVBQVEsS0FBSyxJQUFJLFdBQVcsU0FBUyxHQUFHLFdBQVcsR0FBRyxJQUFJO0FBQzFELFVBQVEsUUFBUTtBQUNoQixNQUFJLGVBQWUsR0FBRztBQUdwQixZQUFRLEtBQUssS0FBSyxRQUFRLElBQUk7QUFFOUIsWUFBUSxPQUFPLElBQUksV0FBZ0IsSUFBSSxZQUFZLEdBQUcsWUFBWSxDQUFDO0FBRW5FLFlBQVEsS0FBSyxJQUFJLFdBQVcsU0FBUyxXQUFXLENBQUM7QUFDakQsWUFBUSxPQUFPO0FBQUEsRUFDakI7QUFDRjtBQVNPLElBQU0scUJBQXFCLENBQUMsU0FBUyxlQUFlO0FBQ3pELGVBQWEsU0FBUyxXQUFXLFVBQVU7QUFDM0Msa0JBQWdCLFNBQVMsVUFBVTtBQUNyQztBQW1CTyxJQUFNLGtCQUFrQixDQUFDLFNBQVMsUUFBUTtBQUMvQyxZQUFVLFNBQVMsR0FBRztBQUN0QixRQUFNLFFBQVEsSUFBSSxTQUFTLFFBQVEsS0FBSyxRQUFRLFFBQVEsTUFBTSxHQUFHO0FBQ2pFLFVBQVEsUUFBUTtBQUNoQixTQUFPO0FBQ1Q7QUFNTyxJQUFNLGVBQWUsQ0FBQyxTQUFTLFFBQVEsZ0JBQWdCLFNBQVMsQ0FBQyxFQUFFLFdBQVcsR0FBRyxLQUFLLEtBQUs7QUFNM0YsSUFBTSxlQUFlLENBQUMsU0FBUyxRQUFRLGdCQUFnQixTQUFTLENBQUMsRUFBRSxXQUFXLEdBQUcsS0FBSyxLQUFLO0FBTTNGLElBQU0sZ0JBQWdCLENBQUMsU0FBUztBQUFBO0FBQUEsRUFBNEIsZ0JBQWdCLFNBQVMsQ0FBQyxFQUFHLFlBQVksR0FBRyxLQUFLLEtBQUs7QUFBQTtBQVF6SCxJQUFNLGVBQWUsSUFBSSxTQUFTLElBQUksWUFBWSxDQUFDLENBQUM7QUFPcEQsSUFBTSxZQUFZLFNBQU87QUFDdkIsZUFBYSxXQUFXLEdBQUcsR0FBRztBQUM5QixTQUFPLGFBQWEsV0FBVyxDQUFDLE1BQU07QUFDeEM7QUF1Q08sSUFBTSxXQUFXLENBQUMsU0FBUyxTQUFTO0FBQ3pDLFVBQVEsT0FBTyxNQUFNO0FBQUEsSUFDbkIsS0FBSztBQUVILFlBQU0sU0FBUyxHQUFHO0FBQ2xCLHFCQUFlLFNBQVMsSUFBSTtBQUM1QjtBQUFBLElBQ0YsS0FBSztBQUNILFVBQVcsVUFBVSxJQUFJLEtBQVUsSUFBSSxJQUFJLEtBQVksUUFBUTtBQUU3RCxjQUFNLFNBQVMsR0FBRztBQUNsQixvQkFBWSxTQUFTLElBQUk7QUFBQSxNQUMzQixXQUFXLFVBQVUsSUFBSSxHQUFHO0FBRTFCLGNBQU0sU0FBUyxHQUFHO0FBQ2xCLHFCQUFhLFNBQVMsSUFBSTtBQUFBLE1BQzVCLE9BQU87QUFFTCxjQUFNLFNBQVMsR0FBRztBQUNsQixxQkFBYSxTQUFTLElBQUk7QUFBQSxNQUM1QjtBQUNBO0FBQUEsSUFDRixLQUFLO0FBRUgsWUFBTSxTQUFTLEdBQUc7QUFDbEIsb0JBQWMsU0FBUyxJQUFJO0FBQzNCO0FBQUEsSUFDRixLQUFLO0FBQ0gsVUFBSSxTQUFTLE1BQU07QUFFakIsY0FBTSxTQUFTLEdBQUc7QUFBQSxNQUNwQixXQUFpQixRQUFRLElBQUksR0FBRztBQUU5QixjQUFNLFNBQVMsR0FBRztBQUNsQixxQkFBYSxTQUFTLEtBQUssTUFBTTtBQUNqQyxpQkFBUyxJQUFJLEdBQUcsSUFBSSxLQUFLLFFBQVEsS0FBSztBQUNwQyxtQkFBUyxTQUFTLEtBQUssQ0FBQyxDQUFDO0FBQUEsUUFDM0I7QUFBQSxNQUNGLFdBQVcsZ0JBQWdCLFlBQVk7QUFFckMsY0FBTSxTQUFTLEdBQUc7QUFDbEIsMkJBQW1CLFNBQVMsSUFBSTtBQUFBLE1BQ2xDLE9BQU87QUFFTCxjQUFNLFNBQVMsR0FBRztBQUNsQixjQUFNQyxRQUFPLE9BQU8sS0FBSyxJQUFJO0FBQzdCLHFCQUFhLFNBQVNBLE1BQUssTUFBTTtBQUNqQyxpQkFBUyxJQUFJLEdBQUcsSUFBSUEsTUFBSyxRQUFRLEtBQUs7QUFDcEMsZ0JBQU0sTUFBTUEsTUFBSyxDQUFDO0FBQ2xCLHlCQUFlLFNBQVMsR0FBRztBQUMzQixtQkFBUyxTQUFTLEtBQUssR0FBRyxDQUFDO0FBQUEsUUFDN0I7QUFBQSxNQUNGO0FBQ0E7QUFBQSxJQUNGLEtBQUs7QUFFSCxZQUFNLFNBQVMsT0FBTyxNQUFNLEdBQUc7QUFDL0I7QUFBQSxJQUNGO0FBRUUsWUFBTSxTQUFTLEdBQUc7QUFBQSxFQUN0QjtBQUNGO0FBaUJPLElBQU0sYUFBTixjQUF5QixRQUFRO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJdEMsWUFBYSxRQUFRO0FBQ25CLFVBQU07QUFJTixTQUFLLElBQUk7QUFLVCxTQUFLLElBQUk7QUFDVCxTQUFLLFFBQVE7QUFBQSxFQUNmO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFLQSxNQUFPLEdBQUc7QUFDUixRQUFJLEtBQUssTUFBTSxHQUFHO0FBQ2hCLFdBQUs7QUFBQSxJQUNQLE9BQU87QUFDTCxVQUFJLEtBQUssUUFBUSxHQUFHO0FBRWxCLHFCQUFhLE1BQU0sS0FBSyxRQUFRLENBQUM7QUFBQSxNQUNuQztBQUNBLFdBQUssUUFBUTtBQUViLFdBQUssRUFBRSxNQUFNLENBQUM7QUFDZCxXQUFLLElBQUk7QUFBQSxJQUNYO0FBQUEsRUFDRjtBQUNGO0FBd0VBLElBQU0seUJBQXlCLGFBQVc7QUFDeEMsTUFBSSxRQUFRLFFBQVEsR0FBRztBQUlyQixnQkFBWSxRQUFRLFNBQVMsUUFBUSxVQUFVLElBQUksUUFBUSxJQUFJLENBQUMsUUFBUSxDQUFDO0FBQ3pFLFFBQUksUUFBUSxRQUFRLEdBQUc7QUFDckIsbUJBQWEsUUFBUSxTQUFTLFFBQVEsUUFBUSxDQUFDO0FBQUEsSUFDakQ7QUFBQSxFQUNGO0FBQ0Y7QUFVTyxJQUFNLG9CQUFOLE1BQXdCO0FBQUEsRUFDN0IsY0FBZTtBQUNiLFNBQUssVUFBVSxJQUFJLFFBQVE7QUFJM0IsU0FBSyxJQUFJO0FBQ1QsU0FBSyxRQUFRO0FBQUEsRUFDZjtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBS0EsTUFBTyxHQUFHO0FBQ1IsUUFBSSxLQUFLLE1BQU0sR0FBRztBQUNoQixXQUFLO0FBQUEsSUFDUCxPQUFPO0FBQ0wsNkJBQXVCLElBQUk7QUFDM0IsV0FBSyxRQUFRO0FBQ2IsV0FBSyxJQUFJO0FBQUEsSUFDWDtBQUFBLEVBQ0Y7QUFBQSxFQUVBLGVBQWdCO0FBQ2QsMkJBQXVCLElBQUk7QUFDM0IsV0FBTyxhQUFhLEtBQUssT0FBTztBQUFBLEVBQ2xDO0FBQ0Y7QUEwQ0EsSUFBTSw0QkFBNEIsYUFBVztBQUMzQyxNQUFJLFFBQVEsUUFBUSxHQUFHO0FBR3JCLFVBQU0sY0FBYyxRQUFRLE9BQU8sS0FBSyxRQUFRLFVBQVUsSUFBSSxJQUFJO0FBSWxFLGdCQUFZLFFBQVEsU0FBUyxXQUFXO0FBQ3hDLFFBQUksUUFBUSxRQUFRLEdBQUc7QUFDckIsbUJBQWEsUUFBUSxTQUFTLFFBQVEsUUFBUSxDQUFDO0FBQUEsSUFDakQ7QUFBQSxFQUNGO0FBQ0Y7QUFtQk8sSUFBTSx1QkFBTixNQUEyQjtBQUFBLEVBQ2hDLGNBQWU7QUFDYixTQUFLLFVBQVUsSUFBSSxRQUFRO0FBSTNCLFNBQUssSUFBSTtBQUNULFNBQUssUUFBUTtBQUNiLFNBQUssT0FBTztBQUFBLEVBQ2Q7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUtBLE1BQU8sR0FBRztBQUNSLFFBQUksS0FBSyxTQUFTLElBQUksS0FBSyxHQUFHO0FBQzVCLFdBQUssSUFBSTtBQUNULFdBQUs7QUFBQSxJQUNQLE9BQU87QUFDTCxnQ0FBMEIsSUFBSTtBQUM5QixXQUFLLFFBQVE7QUFDYixXQUFLLE9BQU8sSUFBSSxLQUFLO0FBQ3JCLFdBQUssSUFBSTtBQUFBLElBQ1g7QUFBQSxFQUNGO0FBQUEsRUFFQSxlQUFnQjtBQUNkLDhCQUEwQixJQUFJO0FBQzlCLFdBQU8sYUFBYSxLQUFLLE9BQU87QUFBQSxFQUNsQztBQUNGO0FBWU8sSUFBTSxnQkFBTixNQUFvQjtBQUFBLEVBQ3pCLGNBQWU7QUFJYixTQUFLLE9BQU8sQ0FBQztBQUNiLFNBQUssSUFBSTtBQUNULFNBQUssUUFBUSxJQUFJLGtCQUFrQjtBQUFBLEVBQ3JDO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFLQSxNQUFPLFFBQVE7QUFDYixTQUFLLEtBQUs7QUFDVixRQUFJLEtBQUssRUFBRSxTQUFTLElBQUk7QUFDdEIsV0FBSyxLQUFLLEtBQUssS0FBSyxDQUFDO0FBQ3JCLFdBQUssSUFBSTtBQUFBLElBQ1g7QUFDQSxTQUFLLE1BQU0sTUFBTSxPQUFPLE1BQU07QUFBQSxFQUNoQztBQUFBLEVBRUEsZUFBZ0I7QUFDZCxVQUFNLFVBQVUsSUFBSSxRQUFRO0FBQzVCLFNBQUssS0FBSyxLQUFLLEtBQUssQ0FBQztBQUNyQixTQUFLLElBQUk7QUFDVCxtQkFBZSxTQUFTLEtBQUssS0FBSyxLQUFLLEVBQUUsQ0FBQztBQUMxQyxvQkFBZ0IsU0FBUyxLQUFLLE1BQU0sYUFBYSxDQUFDO0FBQ2xELFdBQU8sYUFBYSxPQUFPO0FBQUEsRUFDN0I7QUFDRjs7O0FDdjRCTyxJQUFNQyxVQUFTLE9BQUssSUFBSSxNQUFNLENBQUM7QUFPL0IsSUFBTSxzQkFBc0IsTUFBTTtBQUN2QyxRQUFNQSxRQUFPLHNCQUFzQjtBQUNyQztBQU9PLElBQU0saUJBQWlCLE1BQU07QUFDbEMsUUFBTUEsUUFBTyxpQkFBaUI7QUFDaEM7OztBQ01BLElBQU0sNEJBQWtDQyxRQUFPLHlCQUF5QjtBQUN4RSxJQUFNLHlCQUErQkEsUUFBTyxzQkFBc0I7QUFLM0QsSUFBTSxVQUFOLE1BQWM7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUluQixZQUFhLFlBQVk7QUFNdkIsU0FBSyxNQUFNO0FBTVgsU0FBSyxNQUFNO0FBQUEsRUFDYjtBQUNGO0FBT08sSUFBTSxnQkFBZ0IsZ0JBQWMsSUFBSSxRQUFRLFVBQVU7QUFPMUQsSUFBTSxhQUFhLGFBQVcsUUFBUSxRQUFRLFFBQVEsSUFBSTtBQTRCMUQsSUFBTSxpQkFBaUIsQ0FBQyxTQUFTLFFBQVE7QUFDOUMsUUFBTSxPQUFPLElBQUksV0FBVyxRQUFRLElBQUksUUFBUSxRQUFRLE1BQU0sUUFBUSxJQUFJLFlBQVksR0FBRztBQUN6RixVQUFRLE9BQU87QUFDZixTQUFPO0FBQ1Q7QUFZTyxJQUFNLG9CQUFvQixhQUFXLGVBQWUsU0FBUyxZQUFZLE9BQU8sQ0FBQztBQXdCakYsSUFBTSxZQUFZLGFBQVcsUUFBUSxJQUFJLFFBQVEsS0FBSztBQW1HdEQsSUFBTSxjQUFjLGFBQVc7QUFDcEMsTUFBSSxNQUFNO0FBQ1YsTUFBSSxPQUFPO0FBQ1gsUUFBTSxNQUFNLFFBQVEsSUFBSTtBQUN4QixTQUFPLFFBQVEsTUFBTSxLQUFLO0FBQ3hCLFVBQU0sSUFBSSxRQUFRLElBQUksUUFBUSxLQUFLO0FBRW5DLFVBQU0sT0FBTyxJQUFXLFNBQVM7QUFDakMsWUFBUTtBQUNSLFFBQUksSUFBVyxNQUFNO0FBQ25CLGFBQU87QUFBQSxJQUNUO0FBRUEsUUFBSSxNQUFhLGtCQUFrQjtBQUNqQyxZQUFNO0FBQUEsSUFDUjtBQUFBLEVBRUY7QUFDQSxRQUFNO0FBQ1I7QUFhTyxJQUFNLGFBQWEsYUFBVztBQUNuQyxNQUFJLElBQUksUUFBUSxJQUFJLFFBQVEsS0FBSztBQUNqQyxNQUFJLE1BQU0sSUFBVztBQUNyQixNQUFJLE9BQU87QUFDWCxRQUFNLFFBQVEsSUFBVyxRQUFRLElBQUksS0FBSztBQUMxQyxPQUFLLElBQVcsVUFBVSxHQUFHO0FBRTNCLFdBQU8sT0FBTztBQUFBLEVBQ2hCO0FBQ0EsUUFBTSxNQUFNLFFBQVEsSUFBSTtBQUN4QixTQUFPLFFBQVEsTUFBTSxLQUFLO0FBQ3hCLFFBQUksUUFBUSxJQUFJLFFBQVEsS0FBSztBQUU3QixVQUFNLE9BQU8sSUFBVyxTQUFTO0FBQ2pDLFlBQVE7QUFDUixRQUFJLElBQVcsTUFBTTtBQUNuQixhQUFPLE9BQU87QUFBQSxJQUNoQjtBQUVBLFFBQUksTUFBYSxrQkFBa0I7QUFDakMsWUFBTTtBQUFBLElBQ1I7QUFBQSxFQUVGO0FBQ0EsUUFBTTtBQUNSO0FBNENPLElBQU0seUJBQXlCLGFBQVc7QUFDL0MsTUFBSSxlQUFlLFlBQVksT0FBTztBQUN0QyxNQUFJLGlCQUFpQixHQUFHO0FBQ3RCLFdBQU87QUFBQSxFQUNULE9BQU87QUFDTCxRQUFJLGdCQUFnQixPQUFPLGNBQWMsVUFBVSxPQUFPLENBQUM7QUFDM0QsUUFBSSxFQUFFLGVBQWUsS0FBSztBQUN4QixhQUFPLGdCQUFnQjtBQUNyQix5QkFBaUIsT0FBTyxjQUFjLFVBQVUsT0FBTyxDQUFDO0FBQUEsTUFDMUQ7QUFBQSxJQUNGLE9BQU87QUFDTCxhQUFPLGVBQWUsR0FBRztBQUN2QixjQUFNLFVBQVUsZUFBZSxNQUFRLGVBQWU7QUFFdEQsY0FBTSxRQUFRLFFBQVEsSUFBSSxTQUFTLFFBQVEsS0FBSyxRQUFRLE1BQU0sT0FBTztBQUNyRSxnQkFBUSxPQUFPO0FBRWYseUJBQWlCLE9BQU8sY0FBYztBQUFBLFVBQU07QUFBQTtBQUFBLFVBQTBCO0FBQUEsUUFBTTtBQUM1RSx3QkFBZ0I7QUFBQSxNQUNsQjtBQUFBLElBQ0Y7QUFDQSxXQUFPLG1CQUFtQixPQUFPLGFBQWEsQ0FBQztBQUFBLEVBQ2pEO0FBQ0Y7QUFRTyxJQUFNLHVCQUF1QjtBQUFBO0FBQUEsRUFDVCxnQkFBaUIsT0FBTyxrQkFBa0IsT0FBTyxDQUFDO0FBQUE7QUFZdEUsSUFBTSxnQkFBdUIsa0JBQWtCLHVCQUF1QjtBQThDdEUsSUFBTSxtQkFBbUIsQ0FBQyxTQUFTLFFBQVE7QUFDaEQsUUFBTSxLQUFLLElBQUksU0FBUyxRQUFRLElBQUksUUFBUSxRQUFRLElBQUksYUFBYSxRQUFRLEtBQUssR0FBRztBQUNyRixVQUFRLE9BQU87QUFDZixTQUFPO0FBQ1Q7QUFLTyxJQUFNLGNBQWMsYUFBVyxpQkFBaUIsU0FBUyxDQUFDLEVBQUUsV0FBVyxHQUFHLEtBQUs7QUFLL0UsSUFBTSxjQUFjLGFBQVcsaUJBQWlCLFNBQVMsQ0FBQyxFQUFFLFdBQVcsR0FBRyxLQUFLO0FBSy9FLElBQU0sZUFBZTtBQUFBO0FBQUEsRUFBK0IsaUJBQWlCLFNBQVMsQ0FBQyxFQUFHLFlBQVksR0FBRyxLQUFLO0FBQUE7QUFVN0csSUFBTSxxQkFBcUI7QUFBQSxFQUN6QixhQUFXO0FBQUE7QUFBQSxFQUNYLGFBQVc7QUFBQTtBQUFBLEVBQ1g7QUFBQTtBQUFBLEVBQ0E7QUFBQTtBQUFBLEVBQ0E7QUFBQTtBQUFBLEVBQ0E7QUFBQTtBQUFBLEVBQ0EsYUFBVztBQUFBO0FBQUEsRUFDWCxhQUFXO0FBQUE7QUFBQSxFQUNYO0FBQUE7QUFBQSxFQUNBLGFBQVc7QUFDVCxVQUFNLE1BQU0sWUFBWSxPQUFPO0FBSS9CLFVBQU0sTUFBTSxDQUFDO0FBQ2IsYUFBUyxJQUFJLEdBQUcsSUFBSSxLQUFLLEtBQUs7QUFDNUIsWUFBTSxNQUFNLGNBQWMsT0FBTztBQUNqQyxVQUFJLEdBQUcsSUFBSSxRQUFRLE9BQU87QUFBQSxJQUM1QjtBQUNBLFdBQU87QUFBQSxFQUNUO0FBQUEsRUFDQSxhQUFXO0FBQ1QsVUFBTSxNQUFNLFlBQVksT0FBTztBQUMvQixVQUFNLE1BQU0sQ0FBQztBQUNiLGFBQVMsSUFBSSxHQUFHLElBQUksS0FBSyxLQUFLO0FBQzVCLFVBQUksS0FBSyxRQUFRLE9BQU8sQ0FBQztBQUFBLElBQzNCO0FBQ0EsV0FBTztBQUFBLEVBQ1Q7QUFBQSxFQUNBO0FBQUE7QUFDRjtBQUtPLElBQU0sVUFBVSxhQUFXLG1CQUFtQixNQUFNLFVBQVUsT0FBTyxDQUFDLEVBQUUsT0FBTztBQU8vRSxJQUFNLGFBQU4sY0FBeUIsUUFBUTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFLdEMsWUFBYSxZQUFZLFFBQVE7QUFDL0IsVUFBTSxVQUFVO0FBSWhCLFNBQUssU0FBUztBQUtkLFNBQUssSUFBSTtBQUNULFNBQUssUUFBUTtBQUFBLEVBQ2Y7QUFBQSxFQUVBLE9BQVE7QUFDTixRQUFJLEtBQUssVUFBVSxHQUFHO0FBQ3BCLFdBQUssSUFBSSxLQUFLLE9BQU8sSUFBSTtBQUN6QixVQUFJLFdBQVcsSUFBSSxHQUFHO0FBQ3BCLGFBQUssUUFBUSxZQUFZLElBQUksSUFBSTtBQUFBLE1BQ25DLE9BQU87QUFDTCxhQUFLLFFBQVE7QUFBQSxNQUNmO0FBQUEsSUFDRjtBQUNBLFNBQUs7QUFDTDtBQUFBO0FBQUEsTUFBeUIsS0FBSztBQUFBO0FBQUEsRUFDaEM7QUFDRjtBQXlETyxJQUFNLG9CQUFOLGNBQWdDLFFBQVE7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUk3QyxZQUFhLFlBQVk7QUFDdkIsVUFBTSxVQUFVO0FBSWhCLFNBQUssSUFBSTtBQUNULFNBQUssUUFBUTtBQUFBLEVBQ2Y7QUFBQSxFQUVBLE9BQVE7QUFDTixRQUFJLEtBQUssVUFBVSxHQUFHO0FBQ3BCLFdBQUssSUFBSSxXQUFXLElBQUk7QUFFeEIsWUFBTSxhQUFrQixlQUFlLEtBQUssQ0FBQztBQUM3QyxXQUFLLFFBQVE7QUFDYixVQUFJLFlBQVk7QUFDZCxhQUFLLElBQUksQ0FBQyxLQUFLO0FBQ2YsYUFBSyxRQUFRLFlBQVksSUFBSSxJQUFJO0FBQUEsTUFDbkM7QUFBQSxJQUNGO0FBQ0EsU0FBSztBQUNMO0FBQUE7QUFBQSxNQUE4QixLQUFLO0FBQUE7QUFBQSxFQUNyQztBQUNGO0FBK0JPLElBQU0sdUJBQU4sY0FBbUMsUUFBUTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSWhELFlBQWEsWUFBWTtBQUN2QixVQUFNLFVBQVU7QUFJaEIsU0FBSyxJQUFJO0FBQ1QsU0FBSyxRQUFRO0FBQ2IsU0FBSyxPQUFPO0FBQUEsRUFDZDtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBS0EsT0FBUTtBQUNOLFFBQUksS0FBSyxVQUFVLEdBQUc7QUFDcEIsWUFBTSxPQUFPLFdBQVcsSUFBSTtBQUU1QixZQUFNLFdBQVcsT0FBTztBQUN4QixXQUFLLE9BQVksTUFBTSxPQUFPLENBQUM7QUFDL0IsV0FBSyxRQUFRO0FBQ2IsVUFBSSxVQUFVO0FBQ1osYUFBSyxRQUFRLFlBQVksSUFBSSxJQUFJO0FBQUEsTUFDbkM7QUFBQSxJQUNGO0FBQ0EsU0FBSyxLQUFLLEtBQUs7QUFDZixTQUFLO0FBQ0wsV0FBTyxLQUFLO0FBQUEsRUFDZDtBQUNGO0FBRU8sSUFBTSxnQkFBTixNQUFvQjtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXpCLFlBQWEsWUFBWTtBQUN2QixTQUFLLFVBQVUsSUFBSSxrQkFBa0IsVUFBVTtBQUMvQyxTQUFLLE1BQU0sY0FBYyxLQUFLLE9BQU87QUFJckMsU0FBSyxPQUFPO0FBQUEsRUFDZDtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBS0EsT0FBUTtBQUNOLFVBQU0sTUFBTSxLQUFLLE9BQU8sS0FBSyxRQUFRLEtBQUs7QUFDMUMsVUFBTSxNQUFNLEtBQUssSUFBSSxNQUFNLEtBQUssTUFBTSxHQUFHO0FBQ3pDLFNBQUssT0FBTztBQUNaLFdBQU87QUFBQSxFQUNUO0FBQ0Y7OztBQy9yQk8sSUFBTSxTQUFTLE9BQU87QUFDdEIsSUFBTSxrQkFBa0IsT0FBTyxnQkFBZ0IsS0FBSyxNQUFNOzs7QUNTMUQsSUFBTSxPQUFPLEtBQUs7QUFFbEIsSUFBTSxTQUFTLE1BQU0sZ0JBQWdCLElBQUksWUFBWSxDQUFDLENBQUMsRUFBRSxDQUFDO0FBZWpFLElBQU0saUJBQWlCLENBQUMsR0FBRyxJQUFJLE9BQU8sT0FBTyxPQUFPO0FBSzdDLElBQU0sU0FBUyxNQUFNLGVBQWU7QUFBQSxFQUFRO0FBQUE7QUFBQSxFQUFtQyxRQUNuRixJQUFJLE9BQU8sSUFBSSxNQUFNLElBQUksR0FBRyxTQUFTLEVBQUU7QUFDMUM7OztBQ2pCTyxJQUFNQyxVQUFTO0FBQUE7QUFBQSxFQUFnQyxJQUFJLFFBQVEsQ0FBQztBQUFBO0FBZTVELElBQU0sTUFBTSxRQUFRLElBQUksS0FBSyxPQUFPO0FBTXBDLElBQU0sU0FBUyxZQUFVLFFBQVEsT0FBTyxNQUFNO0FBTzlDLElBQU0sVUFBVSxTQUFPLFFBQVEsUUFBUSxHQUFHOzs7QUNuQzFDLElBQU0sa0JBQWtCLE9BQUssTUFBTSxTQUFZLE9BQU87OztBQ0Q3RCxJQUFNLHFCQUFOLE1BQXlCO0FBQUEsRUFDdkIsY0FBZTtBQUNiLFNBQUssTUFBTSxvQkFBSSxJQUFJO0FBQUEsRUFDckI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBTUEsUUFBUyxLQUFLLFVBQVU7QUFDdEIsU0FBSyxJQUFJLElBQUksS0FBSyxRQUFRO0FBQUEsRUFDNUI7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUtBLFFBQVMsS0FBSztBQUNaLFdBQU8sS0FBSyxJQUFJLElBQUksR0FBRztBQUFBLEVBQ3pCO0FBQ0Y7QUFNQSxJQUFJLGdCQUFnQixJQUFJLG1CQUFtQjtBQUMzQyxJQUFJLGNBQWM7QUFHbEIsSUFBSTtBQUVGLE1BQUksT0FBTyxpQkFBaUIsZUFBZSxjQUFjO0FBQ3ZELG9CQUFnQjtBQUNoQixrQkFBYztBQUFBLEVBQ2hCO0FBQ0YsU0FBUyxHQUFQO0FBQVk7QUFPUCxJQUFNLGFBQWE7QUFTbkIsSUFBTSxXQUFXLGtCQUFnQixlQUFlO0FBQUEsRUFBaUI7QUFBQTtBQUFBLEVBQStCO0FBQWE7QUFTN0csSUFBTSxZQUFZLGtCQUFnQixlQUFlO0FBQUEsRUFBb0I7QUFBQTtBQUFBLEVBQStCO0FBQWE7OztBQ3pEakgsSUFBTSxTQUFTLE9BQU87QUFLdEIsSUFBTSxPQUFPLE9BQU87QUFPcEIsSUFBTSxVQUFVLENBQUMsS0FBSyxNQUFNO0FBQ2pDLGFBQVcsT0FBTyxLQUFLO0FBQ3JCLE1BQUUsSUFBSSxHQUFHLEdBQUcsR0FBRztBQUFBLEVBQ2pCO0FBQ0Y7QUFzQk8sSUFBTUMsVUFBUyxTQUFPLEtBQUssR0FBRyxFQUFFO0FBbUJoQyxJQUFNLFVBQVUsU0FBTztBQUU1QixhQUFXLE1BQU0sS0FBSztBQUNwQixXQUFPO0FBQUEsRUFDVDtBQUNBLFNBQU87QUFDVDtBQU9PLElBQU0sUUFBUSxDQUFDLEtBQUssTUFBTTtBQUMvQixhQUFXLE9BQU8sS0FBSztBQUNyQixRQUFJLENBQUMsRUFBRSxJQUFJLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFDckIsYUFBTztBQUFBLElBQ1Q7QUFBQSxFQUNGO0FBQ0EsU0FBTztBQUNUO0FBU08sSUFBTSxjQUFjLENBQUMsS0FBSyxRQUFRLE9BQU8sVUFBVSxlQUFlLEtBQUssS0FBSyxHQUFHO0FBTy9FLElBQU0sWUFBWSxDQUFDLEdBQUcsTUFBTSxNQUFNLEtBQU1DLFFBQU8sQ0FBQyxNQUFNQSxRQUFPLENBQUMsS0FBSyxNQUFNLEdBQUcsQ0FBQyxLQUFLLFNBQVMsUUFBUSxVQUFhLFlBQVksR0FBRyxHQUFHLE1BQU0sRUFBRSxHQUFHLE1BQU0sR0FBRzs7O0FDNUZ0SixJQUFNLFVBQVUsQ0FBQyxJQUFJQyxPQUFNLElBQUksTUFBTTtBQUMxQyxNQUFJO0FBQ0YsV0FBTyxJQUFJLEdBQUcsUUFBUSxLQUFLO0FBQ3pCLFNBQUcsQ0FBQyxFQUFFLEdBQUdBLEtBQUk7QUFBQSxJQUNmO0FBQUEsRUFDRixVQUFFO0FBQ0EsUUFBSSxJQUFJLEdBQUcsUUFBUTtBQUNqQixjQUFRLElBQUlBLE9BQU0sSUFBSSxDQUFDO0FBQUEsSUFDekI7QUFBQSxFQUNGO0FBQ0Y7QUFFTyxJQUFNLE1BQU0sTUFBTTtBQUFDO0FBZW5CLElBQU0sS0FBSyxPQUFLO0FBU2hCLElBQU0saUJBQWlCLENBQUMsR0FBRyxNQUFNLE1BQU07QUFrQnZDLElBQU0sZUFBZSxDQUFDLEdBQUcsTUFBTTtBQUNwQyxNQUFJLEtBQUssUUFBUSxLQUFLLE1BQU07QUFDMUIsV0FBTyxlQUFlLEdBQUcsQ0FBQztBQUFBLEVBQzVCO0FBQ0EsTUFBSSxFQUFFLGdCQUFnQixFQUFFLGFBQWE7QUFDbkMsV0FBTztBQUFBLEVBQ1Q7QUFDQSxNQUFJLE1BQU0sR0FBRztBQUNYLFdBQU87QUFBQSxFQUNUO0FBQ0EsVUFBUSxFQUFFLGFBQWE7QUFBQSxJQUNyQixLQUFLO0FBQ0gsVUFBSSxJQUFJLFdBQVcsQ0FBQztBQUNwQixVQUFJLElBQUksV0FBVyxDQUFDO0FBQUEsSUFFdEIsS0FBSyxZQUFZO0FBQ2YsVUFBSSxFQUFFLGVBQWUsRUFBRSxZQUFZO0FBQ2pDLGVBQU87QUFBQSxNQUNUO0FBQ0EsZUFBUyxJQUFJLEdBQUcsSUFBSSxFQUFFLFFBQVEsS0FBSztBQUNqQyxZQUFJLEVBQUUsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxHQUFHO0FBQ2pCLGlCQUFPO0FBQUEsUUFDVDtBQUFBLE1BQ0Y7QUFDQTtBQUFBLElBQ0Y7QUFBQSxJQUNBLEtBQUssS0FBSztBQUNSLFVBQUksRUFBRSxTQUFTLEVBQUUsTUFBTTtBQUNyQixlQUFPO0FBQUEsTUFDVDtBQUNBLGlCQUFXLFNBQVMsR0FBRztBQUNyQixZQUFJLENBQUMsRUFBRSxJQUFJLEtBQUssR0FBRztBQUNqQixpQkFBTztBQUFBLFFBQ1Q7QUFBQSxNQUNGO0FBQ0E7QUFBQSxJQUNGO0FBQUEsSUFDQSxLQUFLLEtBQUs7QUFDUixVQUFJLEVBQUUsU0FBUyxFQUFFLE1BQU07QUFDckIsZUFBTztBQUFBLE1BQ1Q7QUFDQSxpQkFBVyxPQUFPLEVBQUUsS0FBSyxHQUFHO0FBQzFCLFlBQUksQ0FBQyxFQUFFLElBQUksR0FBRyxLQUFLLENBQUMsYUFBYSxFQUFFLElBQUksR0FBRyxHQUFHLEVBQUUsSUFBSSxHQUFHLENBQUMsR0FBRztBQUN4RCxpQkFBTztBQUFBLFFBQ1Q7QUFBQSxNQUNGO0FBQ0E7QUFBQSxJQUNGO0FBQUEsSUFDQSxLQUFLO0FBQ0gsVUFBV0MsUUFBTyxDQUFDLE1BQWFBLFFBQU8sQ0FBQyxHQUFHO0FBQ3pDLGVBQU87QUFBQSxNQUNUO0FBQ0EsaUJBQVcsT0FBTyxHQUFHO0FBQ25CLFlBQUksQ0FBUSxZQUFZLEdBQUcsR0FBRyxLQUFLLENBQUMsYUFBYSxFQUFFLEdBQUcsR0FBRyxFQUFFLEdBQUcsQ0FBQyxHQUFHO0FBQ2hFLGlCQUFPO0FBQUEsUUFDVDtBQUFBLE1BQ0Y7QUFDQTtBQUFBLElBQ0YsS0FBSztBQUNILFVBQUksRUFBRSxXQUFXLEVBQUUsUUFBUTtBQUN6QixlQUFPO0FBQUEsTUFDVDtBQUNBLGVBQVMsSUFBSSxHQUFHLElBQUksRUFBRSxRQUFRLEtBQUs7QUFDakMsWUFBSSxDQUFDLGFBQWEsRUFBRSxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsR0FBRztBQUM3QixpQkFBTztBQUFBLFFBQ1Q7QUFBQSxNQUNGO0FBQ0E7QUFBQSxJQUNGO0FBQ0UsYUFBTztBQUFBLEVBQ1g7QUFDQSxTQUFPO0FBQ1Q7QUFVTyxJQUFNLFVBQVUsQ0FBQyxPQUFPLFlBQVksUUFBUSxTQUFTLEtBQUs7OztBQ3pJMUQsSUFBTSxTQUFTLE9BQU8sWUFBWSxlQUFlLFFBQVEsV0FBVyxjQUFjLEtBQUssUUFBUSxRQUFRLElBQUksS0FBSyxPQUFPLFVBQVUsU0FBUyxLQUFLLE9BQU8sWUFBWSxjQUFjLFVBQVUsQ0FBQyxNQUFNO0FBR2pNLElBQU0sWUFBWSxPQUFPLFdBQVcsZUFBZSxPQUFPLGFBQWEsZUFBZSxDQUFDO0FBRXZGLElBQU0sUUFBUSxPQUFPLGNBQWMsY0FDdEMsTUFBTSxLQUFLLFVBQVUsUUFBUSxJQUM3QjtBQUtKLElBQUk7QUFDSixJQUFNLE9BQU8sQ0FBQztBQUdkLElBQU0sZ0JBQWdCLE1BQU07QUFDMUIsTUFBSSxXQUFXLFFBQVc7QUFDeEIsUUFBSSxRQUFRO0FBQ1YsZUFBYSxPQUFPO0FBQ3BCLFlBQU0sUUFBUSxRQUFRO0FBQ3RCLFVBQUksZ0JBQWdCO0FBQ3BCLGVBQVMsSUFBSSxHQUFHLElBQUksTUFBTSxRQUFRLEtBQUs7QUFDckMsY0FBTSxPQUFPLE1BQU0sQ0FBQztBQUNwQixZQUFJLEtBQUssQ0FBQyxNQUFNLEtBQUs7QUFDbkIsY0FBSSxrQkFBa0IsTUFBTTtBQUMxQixtQkFBTyxJQUFJLGVBQWUsRUFBRTtBQUFBLFVBQzlCO0FBQ0EsMEJBQWdCO0FBQUEsUUFDbEIsT0FBTztBQUNMLGNBQUksa0JBQWtCLE1BQU07QUFDMUIsbUJBQU8sSUFBSSxlQUFlLElBQUk7QUFDOUIsNEJBQWdCO0FBQUEsVUFDbEIsT0FBTztBQUNMLGlCQUFLLEtBQUssSUFBSTtBQUFBLFVBQ2hCO0FBQUEsUUFDRjtBQUFBLE1BQ0Y7QUFDQSxVQUFJLGtCQUFrQixNQUFNO0FBQzFCLGVBQU8sSUFBSSxlQUFlLEVBQUU7QUFBQSxNQUM5QjtBQUFBLElBRUYsV0FBVyxPQUFPLGFBQWEsVUFBVTtBQUN2QyxlQUFhLE9BQU87QUFDcEIsT0FBQyxTQUFTLFVBQVUsS0FBSyxNQUFNLENBQUMsRUFBRSxNQUFNLEdBQUcsRUFBRSxRQUFRLENBQUMsT0FBTztBQUMzRCxZQUFJLEdBQUcsV0FBVyxHQUFHO0FBQ25CLGdCQUFNLENBQUMsS0FBSyxLQUFLLElBQUksR0FBRyxNQUFNLEdBQUc7QUFDakMsaUJBQU8sSUFBSSxLQUFZLGNBQWMsS0FBSyxHQUFHLEtBQUssS0FBSztBQUN2RCxpQkFBTyxJQUFJLElBQVcsY0FBYyxLQUFLLEdBQUcsS0FBSyxLQUFLO0FBQUEsUUFDeEQ7QUFBQSxNQUNGLENBQUM7QUFBQSxJQUNILE9BQU87QUFDTCxlQUFhLE9BQU87QUFBQSxJQUN0QjtBQUFBLEVBQ0Y7QUFDQSxTQUFPO0FBQ1Q7QUFRTyxJQUFNLFdBQVcsQ0FBQyxTQUFTLGNBQWMsRUFBRSxJQUFJLElBQUk7QUFnQm5ELElBQU0sY0FBYyxDQUFDLFNBQzFCLFNBQ2UsZ0JBQWdCLFFBQVEsSUFBSSxLQUFLLFlBQVksQ0FBQyxDQUFDLElBQy9DLGdCQUF3QixXQUFXLFFBQVEsSUFBSSxDQUFDO0FBZTFELElBQU0sVUFBVSxDQUFDLFNBQ3RCLFNBQVMsT0FBTyxJQUFJLEtBQUssWUFBWSxJQUFJLE1BQU07QUFHMUMsSUFBTSxhQUFhLFFBQVEsWUFBWTtBQUc5QyxJQUFNLGFBQWEsVUFDZixRQUFRLFFBQVEsSUFBSSxhQUFhLENBQUMsUUFBUSxLQUFLLEdBQUcsQ0FBQztBQUdoRCxJQUFNLGdCQUFnQixDQUFDLFNBQVMsV0FBVyxNQUMvQyxDQUFDLFVBQVUsUUFBUSxPQUFPLFNBQVMsZ0JBQ3BDLENBQUMsVUFBVSxTQUFTLE9BQU8sS0FBSyxjQUM5QixZQUFZLFdBQVcsTUFBTSxTQUM1QixZQUFZLE1BQU0sS0FBSyxJQUFJLFNBQVMsT0FBTzs7O0FDL0d6QyxJQUFNLDBCQUEwQixTQUFPLElBQUksV0FBVyxHQUFHO0FBU3pELElBQU0sc0NBQXNDLENBQUMsUUFBUSxZQUFZQyxZQUFXLElBQUksV0FBVyxRQUFRLFlBQVlBLE9BQU07QUFPckgsSUFBTSxrQ0FBa0MsWUFBVSxJQUFJLFdBQVcsTUFBTTtBQU85RSxJQUFNLGtCQUFrQixXQUFTO0FBQy9CLE1BQUksSUFBSTtBQUNSLFdBQVMsSUFBSSxHQUFHLElBQUksTUFBTSxZQUFZLEtBQUs7QUFDekMsU0FBWSxhQUFhLE1BQU0sQ0FBQyxDQUFDO0FBQUEsRUFDbkM7QUFFQSxTQUFPLEtBQUssQ0FBQztBQUNmO0FBT0EsSUFBTSxlQUFlLFdBQVMsT0FBTyxLQUFLLE1BQU0sUUFBUSxNQUFNLFlBQVksTUFBTSxVQUFVLEVBQUUsU0FBUyxRQUFRO0FBTzdHLElBQU0sb0JBQW9CLE9BQUs7QUFFN0IsUUFBTSxJQUFJLEtBQUssQ0FBQztBQUNoQixRQUFNLFFBQVEsd0JBQXdCLEVBQUUsTUFBTTtBQUM5QyxXQUFTLElBQUksR0FBRyxJQUFJLEVBQUUsUUFBUSxLQUFLO0FBQ2pDLFVBQU0sQ0FBQyxJQUFJLEVBQUUsV0FBVyxDQUFDO0FBQUEsRUFDM0I7QUFDQSxTQUFPO0FBQ1Q7QUFNQSxJQUFNLGlCQUFpQixPQUFLO0FBQzFCLFFBQU0sTUFBTSxPQUFPLEtBQUssR0FBRyxRQUFRO0FBQ25DLFNBQU8sb0NBQW9DLElBQUksUUFBUSxJQUFJLFlBQVksSUFBSSxVQUFVO0FBQ3ZGO0FBR08sSUFBTSxXQUFlLFlBQVksa0JBQWtCO0FBR25ELElBQU0sYUFBaUIsWUFBWSxvQkFBb0I7QUF3Q3ZELElBQU0saUJBQWlCLGdCQUFjO0FBQzFDLFFBQU0sU0FBUyx3QkFBd0IsV0FBVyxVQUFVO0FBQzVELFNBQU8sSUFBSSxVQUFVO0FBQ3JCLFNBQU87QUFDVDs7O0FDdEhPLElBQU0sT0FBTixNQUFXO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUtoQixZQUFhLE1BQU0sT0FBTztBQUN4QixTQUFLLE9BQU87QUFDWixTQUFLLFFBQVE7QUFBQSxFQUNmO0FBQ0Y7QUFRTyxJQUFNQyxVQUFTLENBQUMsTUFBTSxVQUFVLElBQUksS0FBSyxNQUFNLEtBQUs7QUFlcEQsSUFBTUMsV0FBVSxDQUFDLEtBQUssTUFBTSxJQUFJLFFBQVEsT0FBSyxFQUFFLEVBQUUsTUFBTSxFQUFFLEtBQUssQ0FBQzs7O0FDMUIvRCxJQUFNO0FBQUE7QUFBQSxFQUErQixPQUFPLGFBQWEsY0FBYyxXQUFXLENBQUM7QUFBQTtBQU1uRixJQUFNLGdCQUFnQixVQUFRLElBQUksY0FBYyxJQUFJO0FBS3BELElBQU0seUJBQXlCLE1BQU0sSUFBSSx1QkFBdUI7QUFNaEUsSUFBTSxpQkFBaUIsQ0FBQUMsVUFBUSxJQUFJLGVBQWVBLEtBQUk7QUFFdEQsSUFBTTtBQUFBO0FBQUEsRUFBc0MsT0FBTyxjQUFjLGNBQWMsSUFBSSxVQUFVLElBQUk7QUFBQTtBQWNqRyxJQUFNLGdCQUFnQixDQUFDLElBQUksVUFBVTtBQUMxQyxFQUFLQyxTQUFRLE9BQU8sQ0FBQyxLQUFLLFVBQVU7QUFDbEMsUUFBSSxVQUFVLE9BQU87QUFDbkIsU0FBRyxnQkFBZ0IsR0FBRztBQUFBLElBQ3hCLFdBQVcsVUFBVSxNQUFNO0FBQ3pCLFNBQUcsYUFBYSxLQUFLLEVBQUU7QUFBQSxJQUN6QixPQUFPO0FBRUwsU0FBRyxhQUFhLEtBQUssS0FBSztBQUFBLElBQzVCO0FBQUEsRUFDRixDQUFDO0FBQ0QsU0FBTztBQUNUO0FBZ0JPLElBQU0sV0FBVyxjQUFZO0FBQ2xDLFFBQU1DLFlBQVcsdUJBQXVCO0FBQ3hDLFdBQVMsSUFBSSxHQUFHLElBQUksU0FBUyxRQUFRLEtBQUs7QUFDeEMsZ0JBQVlBLFdBQVUsU0FBUyxDQUFDLENBQUM7QUFBQSxFQUNuQztBQUNBLFNBQU9BO0FBQ1Q7QUFPTyxJQUFNLFNBQVMsQ0FBQyxRQUFRLFVBQVU7QUFDdkMsY0FBWSxRQUFRLFNBQVMsS0FBSyxDQUFDO0FBQ25DLFNBQU87QUFDVDtBQStDTyxJQUFNLFVBQVUsQ0FBQyxNQUFNLFFBQVEsQ0FBQyxHQUFHLFdBQVcsQ0FBQyxNQUNwRCxPQUFPLGNBQWMsY0FBYyxJQUFJLEdBQUcsS0FBSyxHQUFHLFFBQVE7QUFpQnJELElBQU0sT0FBTztBQWlCYixJQUFNLG1CQUFtQixPQUFTLElBQUksR0FBRyxDQUFDLE9BQU8sUUFBUSxHQUFHLE9BQU8sUUFBUSxFQUFFLEtBQUssRUFBRTtBQTZEcEYsSUFBTSxjQUFjLENBQUMsUUFBUSxVQUFVLE9BQU8sWUFBWSxLQUFLO0FBRS9ELElBQU0sZUFBZSxJQUFJO0FBQ3pCLElBQU0sWUFBWSxJQUFJO0FBQ3RCLElBQU0scUJBQXFCLElBQUk7QUFDL0IsSUFBTSxlQUFlLElBQUk7QUFDekIsSUFBTSxnQkFBZ0IsSUFBSTtBQUMxQixJQUFNLHFCQUFxQixJQUFJO0FBQy9CLElBQU0seUJBQXlCLElBQUk7OztBQ3hPbkMsSUFBTUMsVUFBUzs7O0FDTmYsSUFBTSxPQUFjQyxRQUFPO0FBQzNCLElBQU0sU0FBZ0JBLFFBQU87QUFDN0IsSUFBTSxPQUFjQSxRQUFPO0FBQzNCLElBQU0sT0FBY0EsUUFBTztBQUMzQixJQUFNLFFBQWVBLFFBQU87QUFDNUIsSUFBTSxNQUFhQSxRQUFPO0FBQzFCLElBQU0sU0FBZ0JBLFFBQU87QUFDN0IsSUFBTSxTQUFnQkEsUUFBTztBQUM3QixJQUFNLFVBQWlCQSxRQUFPO0FBTzlCLElBQU0sNEJBQTRCLENBQUFDLFVBQVE7QUFDL0MsUUFBTSxhQUFhLENBQUM7QUFDcEIsUUFBTSxVQUFVLENBQUM7QUFFakIsTUFBSSxJQUFJO0FBQ1IsU0FBTyxJQUFJQSxNQUFLLFFBQVEsS0FBSztBQUMzQixVQUFNLE1BQU1BLE1BQUssQ0FBQztBQUNsQixRQUFJLElBQUksZ0JBQWdCLFVBQVUsSUFBSSxnQkFBZ0IsUUFBUTtBQUM1RCxpQkFBVyxLQUFLLEdBQUc7QUFBQSxJQUNyQixXQUFXLElBQUksZ0JBQWdCLFFBQVE7QUFDckMsY0FBUSxLQUFLLEtBQUssVUFBVSxHQUFHLENBQUM7QUFBQSxJQUNsQztBQUFBLEVBQ0Y7QUFDQSxTQUFPO0FBQ1Q7QUFHQSxJQUFNLGdCQUFnQixDQUFDLE9BQU8sUUFBUSxRQUFRLElBQUk7QUFDbEQsSUFBSSxZQUFZO0FBQ2hCLElBQUksa0JBQXVCLFlBQVk7QUFRaEMsSUFBTSxxQkFBcUIsQ0FBQyxRQUFRLGVBQWU7QUFDeEQsUUFBTSxRQUFRLGNBQWMsU0FBUztBQUNyQyxRQUFNLGdCQUFvQixZQUFZLEtBQUs7QUFDM0MsUUFBTSxZQUFZLGtCQUFrQixTQUNqQyxrQkFBa0IsT0FBTyxrQkFBa0IsVUFDMUMsSUFBSSxPQUFPLGVBQWUsSUFBSSxFQUFFLEtBQUssVUFBVTtBQUNuRCxlQUFhLFlBQVksS0FBSyxjQUFjO0FBQzVDLGdCQUFjO0FBQ2QsU0FBTyxDQUFDLFlBQ0MsTUFDTCxJQUFJQSxVQUFTO0FBQ1gsVUFBTSxVQUFlLFlBQVk7QUFDakMsVUFBTSxXQUFXLFVBQVU7QUFDM0Isc0JBQWtCO0FBQ2xCO0FBQUEsTUFDRTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQSxHQUFHQSxNQUFLO0FBQUEsUUFBSSxDQUFDLFFBQ1YsT0FBTyxRQUFRLFlBQVksT0FBTyxRQUFRLFdBQ3ZDLE1BQ0EsS0FBSyxVQUFVLEdBQUc7QUFBQSxNQUN4QjtBQUFBLE1BQ0E7QUFBQSxNQUNBLE9BQU8sV0FBVztBQUFBLElBQ3BCO0FBQUEsRUFDRjtBQUNOOzs7QUNyREEsSUFBTSxtQkFBbUI7QUFBQSxFQUN2QixDQUFRLElBQUksR0FBUUMsUUFBTyxlQUFlLE1BQU07QUFBQSxFQUNoRCxDQUFRLE1BQU0sR0FBUUEsUUFBTyxlQUFlLFFBQVE7QUFBQSxFQUNwRCxDQUFRLElBQUksR0FBUUEsUUFBTyxTQUFTLE1BQU07QUFBQSxFQUMxQyxDQUFRLEtBQUssR0FBUUEsUUFBTyxTQUFTLE9BQU87QUFBQSxFQUM1QyxDQUFRLElBQUksR0FBUUEsUUFBTyxTQUFTLE1BQU07QUFBQSxFQUMxQyxDQUFRLEdBQUcsR0FBUUEsUUFBTyxTQUFTLEtBQUs7QUFBQSxFQUN4QyxDQUFRLE1BQU0sR0FBUUEsUUFBTyxTQUFTLFFBQVE7QUFBQSxFQUM5QyxDQUFRLE1BQU0sR0FBUUEsUUFBTyxTQUFTLFFBQVE7QUFBQTtBQUFBLEVBQzlDLENBQVEsT0FBTyxHQUFRQSxRQUFPLFNBQVMsT0FBTztBQUNoRDtBQU9BLElBQU0sNEJBQTRCLENBQUNDLFVBQVM7QUFDMUMsUUFBTSxhQUFhLENBQUM7QUFDcEIsUUFBTSxTQUFTLENBQUM7QUFDaEIsUUFBTSxlQUFtQixPQUFPO0FBSWhDLE1BQUksVUFBVSxDQUFDO0FBRWYsTUFBSSxJQUFJO0FBQ1IsU0FBTyxJQUFJQSxNQUFLLFFBQVEsS0FBSztBQUMzQixVQUFNLE1BQU1BLE1BQUssQ0FBQztBQUVsQixVQUFNLFFBQVEsaUJBQWlCLEdBQUc7QUFDbEMsUUFBSSxVQUFVLFFBQVc7QUFDdkIsbUJBQWEsSUFBSSxNQUFNLE1BQU0sTUFBTSxLQUFLO0FBQUEsSUFDMUMsT0FBTztBQUNMLFVBQUksSUFBSSxnQkFBZ0IsVUFBVSxJQUFJLGdCQUFnQixRQUFRO0FBQzVELGNBQU1DLFNBQVksaUJBQWlCLFlBQVk7QUFDL0MsWUFBSSxJQUFJLEtBQUtBLE9BQU0sU0FBUyxHQUFHO0FBQzdCLHFCQUFXLEtBQUssT0FBTyxHQUFHO0FBQzFCLGlCQUFPLEtBQUtBLE1BQUs7QUFBQSxRQUNuQixPQUFPO0FBQ0wscUJBQVcsS0FBSyxHQUFHO0FBQUEsUUFDckI7QUFBQSxNQUNGLE9BQU87QUFDTDtBQUFBLE1BQ0Y7QUFBQSxJQUNGO0FBQUEsRUFDRjtBQUNBLE1BQUksSUFBSSxHQUFHO0FBRVQsY0FBVTtBQUNWLFlBQVEsUUFBUSxXQUFXLEtBQUssRUFBRSxDQUFDO0FBQUEsRUFDckM7QUFFQSxTQUFPLElBQUlELE1BQUssUUFBUSxLQUFLO0FBQzNCLFVBQU0sTUFBTUEsTUFBSyxDQUFDO0FBQ2xCLFFBQUksRUFBRSxlQUFlLFNBQVM7QUFDNUIsY0FBUSxLQUFLLEdBQUc7QUFBQSxJQUNsQjtBQUFBLEVBQ0Y7QUFDQSxTQUFPO0FBQ1Q7QUFJQSxJQUFNLHFCQUF5QixnQkFDM0IsNEJBQ087QUFNSixJQUFNLFFBQVEsSUFBSUEsVUFBUztBQUNoQyxVQUFRLElBQUksR0FBRyxtQkFBbUJBLEtBQUksQ0FBQztBQUV2QyxZQUFVLFFBQVEsQ0FBQyxPQUFPLEdBQUcsTUFBTUEsS0FBSSxDQUFDO0FBQzFDO0FBTU8sSUFBTSxPQUFPLElBQUlBLFVBQVM7QUFDL0IsVUFBUSxLQUFLLEdBQUcsbUJBQW1CQSxLQUFJLENBQUM7QUFDeEMsRUFBQUEsTUFBSyxRQUFlLE1BQU07QUFDMUIsWUFBVSxRQUFRLENBQUMsT0FBTyxHQUFHLE1BQU1BLEtBQUksQ0FBQztBQUMxQztBQTZFTyxJQUFNLFlBQWdCRSxRQUFPO0FBNkw3QixJQUFNQyxzQkFBcUIsQ0FBQyxlQUFzQixtQkFBbUIsT0FBTyxVQUFVOzs7QUN6VnRGLElBQU0saUJBQWlCLFdBQVM7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUlyQyxDQUFDLE9BQU8sUUFBUSxJQUFLO0FBQ25CLFdBQU87QUFBQSxFQUNUO0FBQUE7QUFBQSxFQUVBO0FBQ0Y7QUFPTyxJQUFNLGlCQUFpQixDQUFDLFVBQVUsV0FBVyxlQUFlLE1BQU07QUFDdkUsTUFBSTtBQUNKLEtBQUc7QUFDRCxVQUFNLFNBQVMsS0FBSztBQUFBLEVBQ3RCLFNBQVMsQ0FBQyxJQUFJLFFBQVEsQ0FBQyxPQUFPLElBQUksS0FBSztBQUN2QyxTQUFPO0FBQ1QsQ0FBQztBQU9NLElBQU0sY0FBYyxDQUFDLFVBQVUsU0FBUyxlQUFlLE1BQU07QUFDbEUsUUFBTSxFQUFFLE1BQU0sTUFBTSxJQUFJLFNBQVMsS0FBSztBQUN0QyxTQUFPLEVBQUUsTUFBTSxPQUFPLE9BQU8sU0FBWSxLQUFLLEtBQUssRUFBRTtBQUN2RCxDQUFDOzs7QUU1Q00sSUFBTSxhQUFOLE1BQWlCOzs7OztFQUt0QixZQUFhLE9BQU8sS0FBSztBQUl2QixTQUFLLFFBQVE7QUFJYixTQUFLLE1BQU07RUFDZjtBQUNBO0FBU08sSUFBTSxZQUFOLE1BQWdCO0VBQ3JCLGNBQWU7QUFJYixTQUFLLFVBQVUsb0JBQUksSUFBRztFQUMxQjtBQUNBO0FBV1ksSUFBQyx3QkFBd0IsQ0FBQyxhQUFhLElBQUksTUFDckQsR0FBRyxRQUFRLFFBQVEsQ0FBQyxTQUFTLGFBQWE7QUFDeEMsUUFBTTs7SUFBeUMsWUFBWSxJQUFJLE1BQU0sUUFBUSxJQUFJLFFBQVE7O0FBQ3pGLFdBQVMsSUFBSSxHQUFHLElBQUksUUFBUSxRQUFRLEtBQUs7QUFDdkMsVUFBTUMsT0FBTSxRQUFRLENBQUM7QUFDckIsbUJBQWUsYUFBYSxTQUFTQSxLQUFJLE9BQU9BLEtBQUksS0FBSyxDQUFDO0VBQ2hFO0FBQ0EsQ0FBRztBQVVJLElBQU0sY0FBYyxDQUFDLEtBQUssVUFBVTtBQUN6QyxNQUFJLE9BQU87QUFDWCxNQUFJLFFBQVEsSUFBSSxTQUFTO0FBQ3pCLFNBQU8sUUFBUSxPQUFPO0FBQ3BCLFVBQU0sV0FBZ0IsT0FBTyxPQUFPLFNBQVMsQ0FBQztBQUM5QyxVQUFNLE1BQU0sSUFBSSxRQUFRO0FBQ3hCLFVBQU0sV0FBVyxJQUFJO0FBQ3JCLFFBQUksWUFBWSxPQUFPO0FBQ3JCLFVBQUksUUFBUSxXQUFXLElBQUksS0FBSztBQUM5QixlQUFPO01BQ2Y7QUFDTSxhQUFPLFdBQVc7SUFDeEIsT0FBVztBQUNMLGNBQVEsV0FBVztJQUN6QjtFQUNBO0FBQ0UsU0FBTztBQUNUO0FBVVksSUFBQyxZQUFZLENBQUMsSUFBSUMsUUFBTztBQUNuQyxRQUFNLE1BQU0sR0FBRyxRQUFRLElBQUlBLElBQUcsTUFBTTtBQUNwQyxTQUFPLFFBQVEsVUFBYSxZQUFZLEtBQUtBLElBQUcsS0FBSyxNQUFNO0FBQzdEO0FBUU8sSUFBTSx3QkFBd0IsUUFBTTtBQUN6QyxLQUFHLFFBQVEsUUFBUSxVQUFRO0FBQ3pCLFNBQUssS0FBSyxDQUFDLEdBQUcsTUFBTSxFQUFFLFFBQVEsRUFBRSxLQUFLO0FBS3JDLFFBQUksR0FBRztBQUNQLFNBQUssSUFBSSxHQUFHLElBQUksR0FBRyxJQUFJLEtBQUssUUFBUSxLQUFLO0FBQ3ZDLFlBQU0sT0FBTyxLQUFLLElBQUksQ0FBQztBQUN2QixZQUFNLFFBQVEsS0FBSyxDQUFDO0FBQ3BCLFVBQUksS0FBSyxRQUFRLEtBQUssT0FBTyxNQUFNLE9BQU87QUFDeEMsYUFBSyxNQUFXLElBQUksS0FBSyxLQUFLLE1BQU0sUUFBUSxNQUFNLE1BQU0sS0FBSyxLQUFLO01BQzFFLE9BQWE7QUFDTCxZQUFJLElBQUksR0FBRztBQUNULGVBQUssQ0FBQyxJQUFJO1FBQ3BCO0FBQ1E7TUFDUjtJQUNBO0FBQ0ksU0FBSyxTQUFTO0VBQ2xCLENBQUc7QUFDSDtBQU1PLElBQU0sa0JBQWtCLFNBQU87QUFDcEMsUUFBTSxTQUFTLElBQUksVUFBUztBQUM1QixXQUFTLE9BQU8sR0FBRyxPQUFPLElBQUksUUFBUSxRQUFRO0FBQzVDLFFBQUksSUFBSSxFQUFFLFFBQVEsUUFBUSxDQUFDLFVBQVUsV0FBVztBQUM5QyxVQUFJLENBQUMsT0FBTyxRQUFRLElBQUksTUFBTSxHQUFHO0FBTS9CLGNBQU0sT0FBTyxTQUFTLE1BQUs7QUFDM0IsaUJBQVMsSUFBSSxPQUFPLEdBQUcsSUFBSSxJQUFJLFFBQVEsS0FBSztBQUMxQyxVQUFNLFNBQVMsTUFBTSxJQUFJLENBQUMsRUFBRSxRQUFRLElBQUksTUFBTSxLQUFLLENBQUEsQ0FBRTtRQUMvRDtBQUNRLGVBQU8sUUFBUSxJQUFJLFFBQVEsSUFBSTtNQUN2QztJQUNBLENBQUs7RUFDTDtBQUNFLHdCQUFzQixNQUFNO0FBQzVCLFNBQU87QUFDVDtBQVdPLElBQU0saUJBQWlCLENBQUMsSUFBSSxRQUFRLE9BQU9DLFlBQVc7QUFDM0QsRUFBSSxlQUFlLEdBQUcsU0FBUyxRQUFROztJQUF3QyxDQUFBO0dBQUcsRUFBRSxLQUFLLElBQUksV0FBVyxPQUFPQSxPQUFNLENBQUM7QUFDeEg7QUFFWSxJQUFDLGtCQUFrQixNQUFNLElBQUksVUFBUztBQVN0QyxJQUFDLGlDQUFpQyxRQUFNO0FBQ2xELFFBQU0sS0FBSyxnQkFBZTtBQUMxQixLQUFHLFFBQVEsUUFBUSxDQUFDLFNBQVMsV0FBVztBQUl0QyxVQUFNLFVBQVUsQ0FBQTtBQUNoQixhQUFTLElBQUksR0FBRyxJQUFJLFFBQVEsUUFBUSxLQUFLO0FBQ3ZDLFlBQU0sU0FBUyxRQUFRLENBQUM7QUFDeEIsVUFBSSxPQUFPLFNBQVM7QUFDbEIsY0FBTSxRQUFRLE9BQU8sR0FBRztBQUN4QixZQUFJLE1BQU0sT0FBTztBQUNqQixZQUFJLElBQUksSUFBSSxRQUFRLFFBQVE7QUFDMUIsbUJBQVMsT0FBTyxRQUFRLElBQUksQ0FBQyxHQUFHLElBQUksSUFBSSxRQUFRLFVBQVUsS0FBSyxTQUFTLE9BQU8sUUFBUSxFQUFFLElBQUksQ0FBQyxHQUFHO0FBQy9GLG1CQUFPLEtBQUs7VUFDeEI7UUFDQTtBQUNRLGdCQUFRLEtBQUssSUFBSSxXQUFXLE9BQU8sR0FBRyxDQUFDO01BQy9DO0lBQ0E7QUFDSSxRQUFJLFFBQVEsU0FBUyxHQUFHO0FBQ3RCLFNBQUcsUUFBUSxJQUFJLFFBQVEsT0FBTztJQUNwQztFQUNBLENBQUc7QUFDRCxTQUFPO0FBQ1Q7QUFTTyxJQUFNLGlCQUFpQixDQUFDLFNBQVMsT0FBTztBQUM3QyxFQUFTLGFBQWEsUUFBUSxhQUFhLEdBQUcsUUFBUSxJQUFJO0FBRzFELEVBQU0sS0FBSyxHQUFHLFFBQVEsUUFBTyxDQUFFLEVBQzVCLEtBQUssQ0FBQyxHQUFHLE1BQU0sRUFBRSxDQUFDLElBQUksRUFBRSxDQUFDLENBQUMsRUFDMUIsUUFBUSxDQUFDLENBQUMsUUFBUSxPQUFPLE1BQU07QUFDOUIsWUFBUSxjQUFhO0FBQ3JCLElBQVMsYUFBYSxRQUFRLGFBQWEsTUFBTTtBQUNqRCxVQUFNLE1BQU0sUUFBUTtBQUNwQixJQUFTLGFBQWEsUUFBUSxhQUFhLEdBQUc7QUFDOUMsYUFBUyxJQUFJLEdBQUcsSUFBSSxLQUFLLEtBQUs7QUFDNUIsWUFBTSxPQUFPLFFBQVEsQ0FBQztBQUN0QixjQUFRLGFBQWEsS0FBSyxLQUFLO0FBQy9CLGNBQVEsV0FBVyxLQUFLLEdBQUc7SUFDbkM7RUFDQSxDQUFLO0FBQ0w7QUFTTyxJQUFNLGdCQUFnQixhQUFXO0FBQ3RDLFFBQU0sS0FBSyxJQUFJLFVBQVM7QUFDeEIsUUFBTSxhQUFzQixZQUFZLFFBQVEsV0FBVztBQUMzRCxXQUFTLElBQUksR0FBRyxJQUFJLFlBQVksS0FBSztBQUNuQyxZQUFRLGNBQWE7QUFDckIsVUFBTSxTQUFrQixZQUFZLFFBQVEsV0FBVztBQUN2RCxVQUFNLGtCQUEyQixZQUFZLFFBQVEsV0FBVztBQUNoRSxRQUFJLGtCQUFrQixHQUFHO0FBQ3ZCLFlBQU0sVUFBYyxlQUFlLEdBQUcsU0FBUyxRQUFROztRQUF3QyxDQUFBO09BQUc7QUFDbEcsZUFBU0MsS0FBSSxHQUFHQSxLQUFJLGlCQUFpQkEsTUFBSztBQUN4QyxnQkFBUSxLQUFLLElBQUksV0FBVyxRQUFRLFlBQVcsR0FBSSxRQUFRLFVBQVMsQ0FBRSxDQUFDO01BQy9FO0lBQ0E7RUFDQTtBQUNFLFNBQU87QUFDVDtBQWVPLElBQU0sd0JBQXdCLENBQUMsU0FBUyxhQUFhLFVBQVU7QUFDcEUsUUFBTSxjQUFjLElBQUksVUFBUztBQUNqQyxRQUFNLGFBQXNCLFlBQVksUUFBUSxXQUFXO0FBQzNELFdBQVMsSUFBSSxHQUFHLElBQUksWUFBWSxLQUFLO0FBQ25DLFlBQVEsY0FBYTtBQUNyQixVQUFNLFNBQWtCLFlBQVksUUFBUSxXQUFXO0FBQ3ZELFVBQU0sa0JBQTJCLFlBQVksUUFBUSxXQUFXO0FBQ2hFLFVBQU0sVUFBVSxNQUFNLFFBQVEsSUFBSSxNQUFNLEtBQUssQ0FBQTtBQUM3QyxVQUFNLFFBQVEsU0FBUyxPQUFPLE1BQU07QUFDcEMsYUFBU0EsS0FBSSxHQUFHQSxLQUFJLGlCQUFpQkEsTUFBSztBQUN4QyxZQUFNLFFBQVEsUUFBUSxZQUFXO0FBQ2pDLFlBQU0sV0FBVyxRQUFRLFFBQVEsVUFBUztBQUMxQyxVQUFJLFFBQVEsT0FBTztBQUNqQixZQUFJLFFBQVEsVUFBVTtBQUNwQix5QkFBZSxhQUFhLFFBQVEsT0FBTyxXQUFXLEtBQUs7UUFDckU7QUFDUSxZQUFJLFFBQVEsWUFBWSxTQUFTLEtBQUs7QUFNdEMsWUFBSSxTQUFTLFFBQVEsS0FBSztBQUUxQixZQUFJLENBQUMsT0FBTyxXQUFXLE9BQU8sR0FBRyxRQUFRLE9BQU87QUFDOUMsa0JBQVEsT0FBTyxRQUFRLEdBQUcsR0FBRyxVQUFVLGFBQWEsUUFBUSxRQUFRLE9BQU8sR0FBRyxLQUFLLENBQUM7QUFDcEY7UUFDVjtBQUNRLGVBQU8sUUFBUSxRQUFRLFFBQVE7QUFFN0IsbUJBQVMsUUFBUSxPQUFPO0FBQ3hCLGNBQUksT0FBTyxHQUFHLFFBQVEsVUFBVTtBQUM5QixnQkFBSSxDQUFDLE9BQU8sU0FBUztBQUNuQixrQkFBSSxXQUFXLE9BQU8sR0FBRyxRQUFRLE9BQU8sUUFBUTtBQUM5Qyx3QkFBUSxPQUFPLE9BQU8sR0FBRyxVQUFVLGFBQWEsUUFBUSxXQUFXLE9BQU8sR0FBRyxLQUFLLENBQUM7Y0FDbkc7QUFDYyxxQkFBTyxPQUFPLFdBQVc7WUFDdkM7VUFDQSxPQUFpQjtBQUNMO1VBQ1o7UUFDQTtNQUNBLE9BQWE7QUFDTCx1QkFBZSxhQUFhLFFBQVEsT0FBTyxXQUFXLEtBQUs7TUFDbkU7SUFDQTtFQUNBO0FBQ0UsTUFBSSxZQUFZLFFBQVEsT0FBTyxHQUFHO0FBQ2hDLFVBQU0sS0FBSyxJQUFJLGdCQUFlO0FBQzlCLElBQVMsYUFBYSxHQUFHLGFBQWEsQ0FBQztBQUN2QyxtQkFBZSxJQUFJLFdBQVc7QUFDOUIsV0FBTyxHQUFHLGFBQVk7RUFDMUI7QUFDRSxTQUFPO0FBQ1Q7QUNwVE8sSUFBTSxzQkFBNkI7QUFpQm5DLElBQU0sTUFBTixjQUFrQixXQUFXOzs7O0VBSWxDLFlBQWEsRUFBRSxPQUFjLE9BQU0sR0FBSSxlQUFlLE1BQU0sS0FBSyxNQUFNLFdBQVcsTUFBTSxNQUFNLE9BQU8sTUFBTSxXQUFXLE9BQU8sYUFBYSxLQUFJLElBQUssQ0FBQSxHQUFJO0FBQ3JKLFVBQUs7QUFDTCxTQUFLLEtBQUs7QUFDVixTQUFLLFdBQVc7QUFDaEIsU0FBSyxXQUFXLG9CQUFtQjtBQUNuQyxTQUFLLE9BQU87QUFDWixTQUFLLGVBQWU7QUFJcEIsU0FBSyxRQUFRLG9CQUFJLElBQUc7QUFDcEIsU0FBSyxRQUFRLElBQUksWUFBVztBQUk1QixTQUFLLGVBQWU7QUFJcEIsU0FBSyx1QkFBdUIsQ0FBQTtBQUk1QixTQUFLLFVBQVUsb0JBQUksSUFBRztBQUt0QixTQUFLLFFBQVE7QUFDYixTQUFLLGFBQWE7QUFDbEIsU0FBSyxXQUFXO0FBQ2hCLFNBQUssT0FBTztBQU9aLFNBQUssV0FBVztBQVFoQixTQUFLLFdBQVc7QUFJaEIsU0FBSyxhQUFxQkMsUUFBTyxDQUFBQyxhQUFXO0FBQzFDLFdBQUssR0FBRyxRQUFRLE1BQU07QUFDcEIsYUFBSyxXQUFXO0FBQ2hCLFFBQUFBLFNBQVEsSUFBSTtNQUNwQixDQUFPO0lBQ1AsQ0FBSztBQUNELFVBQU0sdUJBQXVCLE1BQWNELFFBQU8sQ0FBQUMsYUFBVztBQUkzRCxZQUFNLGVBQWUsQ0FBQyxhQUFhO0FBQ2pDLFlBQUksYUFBYSxVQUFhLGFBQWEsTUFBTTtBQUMvQyxlQUFLLElBQUksUUFBUSxZQUFZO0FBQzdCLFVBQUFBLFNBQU87UUFDakI7TUFDQTtBQUNNLFdBQUssR0FBRyxRQUFRLFlBQVk7SUFDbEMsQ0FBSztBQUNELFNBQUssR0FBRyxRQUFRLGNBQVk7QUFDMUIsVUFBSSxhQUFhLFNBQVMsS0FBSyxVQUFVO0FBQ3ZDLGFBQUssYUFBYSxxQkFBb0I7TUFDOUM7QUFDTSxXQUFLLFdBQVcsYUFBYSxVQUFhLGFBQWE7QUFDdkQsVUFBSSxDQUFDLEtBQUssVUFBVTtBQUNsQixhQUFLLEtBQUssUUFBUSxDQUFBLENBQUU7TUFDNUI7SUFDQSxDQUFLO0FBTUQsU0FBSyxhQUFhLHFCQUFvQjtFQUMxQzs7Ozs7Ozs7RUFTRSxPQUFRO0FBQ04sVUFBTSxPQUFPLEtBQUs7QUFDbEIsUUFBSSxTQUFTLFFBQVEsQ0FBQyxLQUFLLFlBQVk7QUFDckM7O1FBQTZCLEtBQUssT0FBUTtRQUFLLGlCQUFlO0FBQzVELHNCQUFZLGNBQWMsSUFBSSxJQUFJO1FBQzFDO1FBQVM7UUFBTTtNQUFJO0lBQ25CO0FBQ0ksU0FBSyxhQUFhO0VBQ3RCO0VBRUUsYUFBYztBQUNaLFdBQU8sS0FBSztFQUNoQjtFQUVFLGlCQUFrQjtBQUNoQixXQUFPLElBQUksSUFBVSxLQUFLLEtBQUssT0FBTyxFQUFFLElBQUksQ0FBQUMsU0FBT0EsS0FBSSxJQUFJLENBQUM7RUFDaEU7Ozs7Ozs7Ozs7Ozs7O0VBZUUsU0FBVSxHQUFHLFNBQVMsTUFBTTtBQUMxQixXQUFPLFNBQVMsTUFBTSxHQUFHLE1BQU07RUFDbkM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztFQTRCRSxJQUFLLE1BQU0sa0JBQWtCLGNBQWM7QUFDekMsVUFBTUMsUUFBVyxlQUFlLEtBQUssT0FBTyxNQUFNLE1BQU07QUFFdEQsWUFBTSxJQUFJLElBQUksZ0JBQWU7QUFDN0IsUUFBRSxXQUFXLE1BQU0sSUFBSTtBQUN2QixhQUFPO0lBQ2IsQ0FBSztBQUNELFVBQU0sU0FBU0EsTUFBSztBQUNwQixRQUFJLG9CQUFvQixnQkFBZ0IsV0FBVyxpQkFBaUI7QUFDbEUsVUFBSSxXQUFXLGNBQWM7QUFFM0IsY0FBTSxJQUFJLElBQUksZ0JBQWU7QUFDN0IsVUFBRSxPQUFPQSxNQUFLO0FBQ2QsUUFBQUEsTUFBSyxLQUFLOztVQUFnQyxPQUFLO0FBQzdDLG1CQUFPLE1BQU0sTUFBTSxJQUFJLEVBQUUsTUFBTTtBQUU3QixnQkFBRSxTQUFTO1lBQ3ZCO1VBQ0E7UUFBUztBQUNELFVBQUUsU0FBU0EsTUFBSztBQUNoQixpQkFBUyxJQUFJLEVBQUUsUUFBUSxNQUFNLE1BQU0sSUFBSSxFQUFFLE9BQU87QUFDOUMsWUFBRSxTQUFTO1FBQ3JCO0FBQ1EsVUFBRSxVQUFVQSxNQUFLO0FBQ2pCLGFBQUssTUFBTSxJQUFJLE1BQU0sQ0FBQztBQUN0QixVQUFFLFdBQVcsTUFBTSxJQUFJO0FBQ3ZCLGVBQU87TUFDZixPQUFhO0FBQ0wsY0FBTSxJQUFJLE1BQU0sc0JBQXNCLDREQUE0RDtNQUMxRztJQUNBO0FBQ0ksV0FBT0E7RUFDWDs7Ozs7Ozs7RUFTRSxTQUFVLE9BQU8sSUFBSTtBQUVuQixXQUFPLEtBQUssSUFBSSxNQUFNLE1BQU07RUFDaEM7Ozs7Ozs7RUFRRSxRQUFTLE9BQU8sSUFBSTtBQUVsQixXQUFPLEtBQUssSUFBSSxNQUFNLEtBQUs7RUFDL0I7Ozs7Ozs7O0VBU0UsT0FBUSxPQUFPLElBQUk7QUFFakIsV0FBTyxLQUFLLElBQUksTUFBTSxJQUFJO0VBQzlCOzs7Ozs7O0VBUUUsZUFBZ0IsT0FBTyxJQUFJO0FBRXpCLFdBQU8sS0FBSyxJQUFJLE1BQU0sWUFBWTtFQUN0Qzs7Ozs7Ozs7O0VBVUUsU0FBVTtBQUlSLFVBQU1ELE9BQU0sQ0FBQTtBQUVaLFNBQUssTUFBTSxRQUFRLENBQUMsT0FBTyxRQUFRO0FBQ2pDLE1BQUFBLEtBQUksR0FBRyxJQUFJLE1BQU0sT0FBTTtJQUM3QixDQUFLO0FBRUQsV0FBT0E7RUFDWDs7OztFQUtFLFVBQVc7QUFDVCxJQUFNLEtBQUssS0FBSyxPQUFPLEVBQUUsUUFBUSxZQUFVLE9BQU8sUUFBTyxDQUFFO0FBQzNELFVBQU0sT0FBTyxLQUFLO0FBQ2xCLFFBQUksU0FBUyxNQUFNO0FBQ2pCLFdBQUssUUFBUTtBQUNiLFlBQU07O1FBQXFDLEtBQUs7O0FBQ2hELGNBQVEsTUFBTSxJQUFJLElBQUksRUFBRSxNQUFNLEtBQUssTUFBTSxHQUFHLFFBQVEsTUFBTSxZQUFZLE1BQUssQ0FBRTtBQUM3RSxjQUFRLElBQUksUUFBUTtBQUNwQjs7UUFBNkIsS0FBTSxPQUFPO1FBQUssaUJBQWU7QUFDNUQsZ0JBQU1BLE9BQU0sUUFBUTtBQUNwQixjQUFJLENBQUMsS0FBSyxTQUFTO0FBQ2pCLHdCQUFZLGFBQWEsSUFBSUEsSUFBRztVQUMxQztBQUNRLHNCQUFZLGVBQWUsSUFBSSxJQUFJO1FBQzNDO1FBQVM7UUFBTTtNQUFJO0lBQ25CO0FBQ0ksU0FBSyxLQUFLLGFBQWEsQ0FBQyxJQUFJLENBQUM7QUFDN0IsU0FBSyxLQUFLLFdBQVcsQ0FBQyxJQUFJLENBQUM7QUFDM0IsVUFBTSxRQUFPO0VBQ2pCOzs7OztFQU1FLEdBQUksV0FBVyxHQUFHO0FBQ2hCLFVBQU0sR0FBRyxXQUFXLENBQUM7RUFDekI7Ozs7O0VBTUUsSUFBSyxXQUFXLEdBQUc7QUFDakIsVUFBTSxJQUFJLFdBQVcsQ0FBQztFQUMxQjtBQUNBO0FDelVPLElBQU0sY0FBTixNQUFrQjs7OztFQUl2QixZQUFhLFNBQVM7QUFDcEIsU0FBSyxjQUFjO0VBQ3ZCO0VBRUUsZ0JBQWlCO0VBRW5COzs7O0VBS0UsY0FBZTtBQUNiLFdBQWdCLFlBQVksS0FBSyxXQUFXO0VBQ2hEOzs7O0VBS0UsWUFBYTtBQUNYLFdBQWdCLFlBQVksS0FBSyxXQUFXO0VBQ2hEO0FBQ0E7QUFFTyxJQUFNLGtCQUFOLGNBQThCLFlBQVk7Ozs7RUFJL0MsYUFBYztBQUNaLFdBQU8sU0FBa0IsWUFBWSxLQUFLLFdBQVcsR0FBWSxZQUFZLEtBQUssV0FBVyxDQUFDO0VBQ2xHOzs7O0VBS0UsY0FBZTtBQUNiLFdBQU8sU0FBa0IsWUFBWSxLQUFLLFdBQVcsR0FBWSxZQUFZLEtBQUssV0FBVyxDQUFDO0VBQ2xHOzs7OztFQU1FLGFBQWM7QUFDWixXQUFnQixZQUFZLEtBQUssV0FBVztFQUNoRDs7OztFQUtFLFdBQVk7QUFDVixXQUFnQixVQUFVLEtBQUssV0FBVztFQUM5Qzs7OztFQUtFLGFBQWM7QUFDWixXQUFnQixjQUFjLEtBQUssV0FBVztFQUNsRDs7OztFQUtFLGlCQUFrQjtBQUNoQixXQUFnQixZQUFZLEtBQUssV0FBVyxNQUFNO0VBQ3REOzs7O0VBS0UsY0FBZTtBQUNiLFdBQWdCLFlBQVksS0FBSyxXQUFXO0VBQ2hEOzs7Ozs7RUFPRSxVQUFXO0FBQ1QsV0FBZ0IsWUFBWSxLQUFLLFdBQVc7RUFDaEQ7Ozs7RUFLRSxVQUFXO0FBQ1QsV0FBZ0IsUUFBUSxLQUFLLFdBQVc7RUFDNUM7Ozs7RUFLRSxVQUFXO0FBQ1QsV0FBYyxlQUF3QixrQkFBa0IsS0FBSyxXQUFXLENBQUM7RUFDN0U7Ozs7OztFQU9FLFdBQVk7QUFDVixXQUFPLEtBQUssTUFBZSxjQUFjLEtBQUssV0FBVyxDQUFDO0VBQzlEOzs7O0VBS0UsVUFBVztBQUNULFdBQWdCLGNBQWMsS0FBSyxXQUFXO0VBQ2xEO0FBQ0E7QUFFTyxJQUFNLGNBQU4sTUFBa0I7Ozs7RUFJdkIsWUFBYSxTQUFTO0FBSXBCLFNBQUssWUFBWTtBQUNqQixTQUFLLGNBQWM7RUFDdkI7RUFFRSxnQkFBaUI7QUFDZixTQUFLLFlBQVk7RUFDckI7Ozs7RUFLRSxjQUFlO0FBQ2IsU0FBSyxhQUFzQixZQUFZLEtBQUssV0FBVztBQUN2RCxXQUFPLEtBQUs7RUFDaEI7Ozs7RUFLRSxZQUFhO0FBQ1gsVUFBTSxPQUFnQixZQUFZLEtBQUssV0FBVyxJQUFJO0FBQ3RELFNBQUssYUFBYTtBQUNsQixXQUFPO0VBQ1g7QUFDQTtBQUVPLElBQU0sa0JBQU4sY0FBOEIsWUFBWTs7OztFQUkvQyxZQUFhLFNBQVM7QUFDcEIsVUFBTSxPQUFPO0FBT2IsU0FBSyxPQUFPLENBQUE7QUFDWixJQUFTLFlBQVksT0FBTztBQUM1QixTQUFLLGtCQUFrQixJQUFhLHFCQUE4QixrQkFBa0IsT0FBTyxDQUFDO0FBQzVGLFNBQUssZ0JBQWdCLElBQWEsa0JBQTJCLGtCQUFrQixPQUFPLENBQUM7QUFDdkYsU0FBSyxtQkFBbUIsSUFBYSxxQkFBOEIsa0JBQWtCLE9BQU8sQ0FBQztBQUM3RixTQUFLLG9CQUFvQixJQUFhLHFCQUE4QixrQkFBa0IsT0FBTyxDQUFDO0FBQzlGLFNBQUssY0FBYyxJQUFhLFdBQW9CLGtCQUFrQixPQUFPLEdBQVksU0FBUztBQUNsRyxTQUFLLGdCQUFnQixJQUFhLGNBQXVCLGtCQUFrQixPQUFPLENBQUM7QUFDbkYsU0FBSyxvQkFBb0IsSUFBYSxXQUFvQixrQkFBa0IsT0FBTyxHQUFZLFNBQVM7QUFDeEcsU0FBSyxpQkFBaUIsSUFBYSxrQkFBMkIsa0JBQWtCLE9BQU8sQ0FBQztBQUN4RixTQUFLLGFBQWEsSUFBYSxrQkFBMkIsa0JBQWtCLE9BQU8sQ0FBQztFQUN4Rjs7OztFQUtFLGFBQWM7QUFDWixXQUFPLElBQUksR0FBRyxLQUFLLGNBQWMsS0FBSSxHQUFJLEtBQUssaUJBQWlCLEtBQUksQ0FBRTtFQUN6RTs7OztFQUtFLGNBQWU7QUFDYixXQUFPLElBQUksR0FBRyxLQUFLLGNBQWMsS0FBSSxHQUFJLEtBQUssa0JBQWtCLEtBQUksQ0FBRTtFQUMxRTs7Ozs7RUFNRSxhQUFjO0FBQ1osV0FBTyxLQUFLLGNBQWMsS0FBSTtFQUNsQzs7OztFQUtFLFdBQVk7QUFDVjs7TUFBOEIsS0FBSyxZQUFZLEtBQUk7O0VBQ3ZEOzs7O0VBS0UsYUFBYztBQUNaLFdBQU8sS0FBSyxjQUFjLEtBQUk7RUFDbEM7Ozs7RUFLRSxpQkFBa0I7QUFDaEIsV0FBTyxLQUFLLGtCQUFrQixLQUFJLE1BQU87RUFDN0M7Ozs7RUFLRSxjQUFlO0FBQ2IsV0FBTyxLQUFLLGVBQWUsS0FBSTtFQUNuQzs7Ozs7O0VBT0UsVUFBVztBQUNULFdBQU8sS0FBSyxXQUFXLEtBQUk7RUFDL0I7Ozs7RUFLRSxVQUFXO0FBQ1QsV0FBZ0IsUUFBUSxLQUFLLFdBQVc7RUFDNUM7Ozs7RUFLRSxVQUFXO0FBQ1QsV0FBZ0Isa0JBQWtCLEtBQUssV0FBVztFQUN0RDs7Ozs7Ozs7RUFTRSxXQUFZO0FBQ1YsV0FBZ0IsUUFBUSxLQUFLLFdBQVc7RUFDNUM7Ozs7RUFLRSxVQUFXO0FBQ1QsVUFBTSxXQUFXLEtBQUssZ0JBQWdCLEtBQUk7QUFDMUMsUUFBSSxXQUFXLEtBQUssS0FBSyxRQUFRO0FBQy9CLGFBQU8sS0FBSyxLQUFLLFFBQVE7SUFDL0IsT0FBVztBQUNMLFlBQU0sTUFBTSxLQUFLLGNBQWMsS0FBSTtBQUNuQyxXQUFLLEtBQUssS0FBSyxHQUFHO0FBQ2xCLGFBQU87SUFDYjtFQUNBO0FBQ0E7QUNoUk8sSUFBTSxjQUFOLE1BQWtCO0VBQ3ZCLGNBQWU7QUFDYixTQUFLLGNBQXVCLGNBQWE7RUFDN0M7RUFFRSxlQUFnQjtBQUNkLFdBQWdCLGFBQWEsS0FBSyxXQUFXO0VBQ2pEO0VBRUUsZ0JBQWlCO0VBRW5COzs7O0VBS0UsYUFBYyxPQUFPO0FBQ25CLElBQVMsYUFBYSxLQUFLLGFBQWEsS0FBSztFQUNqRDs7OztFQUtFLFdBQVksS0FBSztBQUNmLElBQVMsYUFBYSxLQUFLLGFBQWEsR0FBRztFQUMvQztBQUNBO0FBRU8sSUFBTSxrQkFBTixjQUE4QixZQUFZOzs7O0VBSS9DLFlBQWFFLEtBQUk7QUFDZixJQUFTLGFBQWEsS0FBSyxhQUFhQSxJQUFHLE1BQU07QUFDakQsSUFBUyxhQUFhLEtBQUssYUFBYUEsSUFBRyxLQUFLO0VBQ3BEOzs7O0VBS0UsYUFBY0EsS0FBSTtBQUNoQixJQUFTLGFBQWEsS0FBSyxhQUFhQSxJQUFHLE1BQU07QUFDakQsSUFBUyxhQUFhLEtBQUssYUFBYUEsSUFBRyxLQUFLO0VBQ3BEOzs7OztFQU1FLFlBQWEsUUFBUTtBQUNuQixJQUFTLGFBQWEsS0FBSyxhQUFhLE1BQU07RUFDbEQ7Ozs7RUFLRSxVQUFXLE1BQU07QUFDZixJQUFTLFdBQVcsS0FBSyxhQUFhLElBQUk7RUFDOUM7Ozs7RUFLRSxZQUFhLEdBQUc7QUFDZCxJQUFTLGVBQWUsS0FBSyxhQUFhLENBQUM7RUFDL0M7Ozs7RUFLRSxnQkFBaUIsUUFBUTtBQUN2QixJQUFTLGFBQWEsS0FBSyxhQUFhLFNBQVMsSUFBSSxDQUFDO0VBQzFEOzs7O0VBS0UsYUFBYyxNQUFNO0FBQ2xCLElBQVMsYUFBYSxLQUFLLGFBQWEsSUFBSTtFQUNoRDs7Ozs7O0VBT0UsU0FBVSxLQUFLO0FBQ2IsSUFBUyxhQUFhLEtBQUssYUFBYSxHQUFHO0VBQy9DOzs7O0VBS0UsU0FBVUMsTUFBSztBQUNiLElBQVMsU0FBUyxLQUFLLGFBQWFBLElBQUc7RUFDM0M7Ozs7RUFLRSxTQUFVLEtBQUs7QUFDYixJQUFTLG1CQUFtQixLQUFLLGFBQWEsR0FBRztFQUNyRDs7OztFQUtFLFVBQVcsT0FBTztBQUNoQixJQUFTLGVBQWUsS0FBSyxhQUFhLEtBQUssVUFBVSxLQUFLLENBQUM7RUFDbkU7Ozs7RUFLRSxTQUFVLEtBQUs7QUFDYixJQUFTLGVBQWUsS0FBSyxhQUFhLEdBQUc7RUFDakQ7QUFDQTtBQUVPLElBQU0sY0FBTixNQUFrQjtFQUN2QixjQUFlO0FBQ2IsU0FBSyxjQUF1QixjQUFhO0FBQ3pDLFNBQUssWUFBWTtFQUNyQjtFQUVFLGVBQWdCO0FBQ2QsV0FBZ0IsYUFBYSxLQUFLLFdBQVc7RUFDakQ7RUFFRSxnQkFBaUI7QUFDZixTQUFLLFlBQVk7RUFDckI7Ozs7RUFLRSxhQUFjLE9BQU87QUFDbkIsVUFBTSxPQUFPLFFBQVEsS0FBSztBQUMxQixTQUFLLFlBQVk7QUFDakIsSUFBUyxhQUFhLEtBQUssYUFBYSxJQUFJO0VBQ2hEOzs7O0VBS0UsV0FBWSxLQUFLO0FBQ2YsUUFBSSxRQUFRLEdBQUc7QUFDYixNQUFNLGVBQWM7SUFDMUI7QUFDSSxJQUFTLGFBQWEsS0FBSyxhQUFhLE1BQU0sQ0FBQztBQUMvQyxTQUFLLGFBQWE7RUFDdEI7QUFDQTtBQUVPLElBQU0sa0JBQU4sY0FBOEIsWUFBWTtFQUMvQyxjQUFlO0FBQ2IsVUFBSztBQUlMLFNBQUssU0FBUyxvQkFBSSxJQUFHO0FBT3JCLFNBQUssV0FBVztBQUNoQixTQUFLLGtCQUFrQixJQUFhLHFCQUFvQjtBQUN4RCxTQUFLLGdCQUFnQixJQUFhLGtCQUFpQjtBQUNuRCxTQUFLLG1CQUFtQixJQUFhLHFCQUFvQjtBQUN6RCxTQUFLLG9CQUFvQixJQUFhLHFCQUFvQjtBQUMxRCxTQUFLLGNBQWMsSUFBYSxXQUFvQixVQUFVO0FBQzlELFNBQUssZ0JBQWdCLElBQWEsY0FBYTtBQUMvQyxTQUFLLG9CQUFvQixJQUFhLFdBQW9CLFVBQVU7QUFDcEUsU0FBSyxpQkFBaUIsSUFBYSxrQkFBaUI7QUFDcEQsU0FBSyxhQUFhLElBQWEsa0JBQWlCO0VBQ3BEO0VBRUUsZUFBZ0I7QUFDZCxVQUFNLFVBQW1CLGNBQWE7QUFDdEMsSUFBUyxhQUFhLFNBQVMsQ0FBQztBQUNoQyxJQUFTLG1CQUFtQixTQUFTLEtBQUssZ0JBQWdCLGFBQVksQ0FBRTtBQUN4RSxJQUFTLG1CQUFtQixTQUFTLEtBQUssY0FBYyxhQUFZLENBQUU7QUFDdEUsSUFBUyxtQkFBbUIsU0FBUyxLQUFLLGlCQUFpQixhQUFZLENBQUU7QUFDekUsSUFBUyxtQkFBbUIsU0FBUyxLQUFLLGtCQUFrQixhQUFZLENBQUU7QUFDMUUsSUFBUyxtQkFBbUIsU0FBa0IsYUFBYSxLQUFLLFdBQVcsQ0FBQztBQUM1RSxJQUFTLG1CQUFtQixTQUFTLEtBQUssY0FBYyxhQUFZLENBQUU7QUFDdEUsSUFBUyxtQkFBbUIsU0FBa0IsYUFBYSxLQUFLLGlCQUFpQixDQUFDO0FBQ2xGLElBQVMsbUJBQW1CLFNBQVMsS0FBSyxlQUFlLGFBQVksQ0FBRTtBQUN2RSxJQUFTLG1CQUFtQixTQUFTLEtBQUssV0FBVyxhQUFZLENBQUU7QUFFbkUsSUFBUyxnQkFBZ0IsU0FBa0IsYUFBYSxLQUFLLFdBQVcsQ0FBQztBQUN6RSxXQUFnQixhQUFhLE9BQU87RUFDeEM7Ozs7RUFLRSxZQUFhRCxLQUFJO0FBQ2YsU0FBSyxjQUFjLE1BQU1BLElBQUcsTUFBTTtBQUNsQyxTQUFLLGlCQUFpQixNQUFNQSxJQUFHLEtBQUs7RUFDeEM7Ozs7RUFLRSxhQUFjQSxLQUFJO0FBQ2hCLFNBQUssY0FBYyxNQUFNQSxJQUFHLE1BQU07QUFDbEMsU0FBSyxrQkFBa0IsTUFBTUEsSUFBRyxLQUFLO0VBQ3pDOzs7O0VBS0UsWUFBYSxRQUFRO0FBQ25CLFNBQUssY0FBYyxNQUFNLE1BQU07RUFDbkM7Ozs7RUFLRSxVQUFXLE1BQU07QUFDZixTQUFLLFlBQVksTUFBTSxJQUFJO0VBQy9COzs7O0VBS0UsWUFBYSxHQUFHO0FBQ2QsU0FBSyxjQUFjLE1BQU0sQ0FBQztFQUM5Qjs7OztFQUtFLGdCQUFpQixRQUFRO0FBQ3ZCLFNBQUssa0JBQWtCLE1BQU0sU0FBUyxJQUFJLENBQUM7RUFDL0M7Ozs7RUFLRSxhQUFjLE1BQU07QUFDbEIsU0FBSyxlQUFlLE1BQU0sSUFBSTtFQUNsQzs7Ozs7O0VBT0UsU0FBVSxLQUFLO0FBQ2IsU0FBSyxXQUFXLE1BQU0sR0FBRztFQUM3Qjs7OztFQUtFLFNBQVVDLE1BQUs7QUFDYixJQUFTLFNBQVMsS0FBSyxhQUFhQSxJQUFHO0VBQzNDOzs7O0VBS0UsU0FBVSxLQUFLO0FBQ2IsSUFBUyxtQkFBbUIsS0FBSyxhQUFhLEdBQUc7RUFDckQ7Ozs7Ozs7O0VBU0UsVUFBVyxPQUFPO0FBQ2hCLElBQVMsU0FBUyxLQUFLLGFBQWEsS0FBSztFQUM3Qzs7Ozs7Ozs7O0VBVUUsU0FBVSxLQUFLO0FBQ2IsVUFBTSxRQUFRLEtBQUssT0FBTyxJQUFJLEdBQUc7QUFDakMsUUFBSSxVQUFVLFFBQVc7QUFldkIsV0FBSyxnQkFBZ0IsTUFBTSxLQUFLLFVBQVU7QUFDMUMsV0FBSyxjQUFjLE1BQU0sR0FBRztJQUNsQyxPQUFXO0FBQ0wsV0FBSyxnQkFBZ0IsTUFBTSxLQUFLO0lBQ3RDO0VBQ0E7QUFDQTtBQ3ZRQSxJQUFNLGVBQWUsQ0FBQyxTQUFTLFNBQVMsUUFBUSxVQUFVO0FBRXhELFVBQWEsSUFBSSxPQUFPLFFBQVEsQ0FBQyxFQUFFLEdBQUcsS0FBSztBQUMzQyxRQUFNLGtCQUFrQixZQUFZLFNBQVMsS0FBSztBQUVsRCxFQUFTLGFBQWEsUUFBUSxhQUFhLFFBQVEsU0FBUyxlQUFlO0FBQzNFLFVBQVEsWUFBWSxNQUFNO0FBQzFCLEVBQVMsYUFBYSxRQUFRLGFBQWEsS0FBSztBQUNoRCxRQUFNLGNBQWMsUUFBUSxlQUFlO0FBRTNDLGNBQVksTUFBTSxTQUFTLFFBQVEsWUFBWSxHQUFHLEtBQUs7QUFDdkQsV0FBUyxJQUFJLGtCQUFrQixHQUFHLElBQUksUUFBUSxRQUFRLEtBQUs7QUFDekQsWUFBUSxDQUFDLEVBQUUsTUFBTSxTQUFTLENBQUM7RUFDL0I7QUFDQTtBQVVPLElBQU0sc0JBQXNCLENBQUMsU0FBUyxPQUFPLFFBQVE7QUFFMUQsUUFBTSxLQUFLLG9CQUFJLElBQUc7QUFDbEIsTUFBSSxRQUFRLENBQUMsT0FBTyxXQUFXO0FBRTdCLFFBQUksU0FBUyxPQUFPLE1BQU0sSUFBSSxPQUFPO0FBQ25DLFNBQUcsSUFBSSxRQUFRLEtBQUs7SUFDMUI7RUFDQSxDQUFHO0FBQ0QsaUJBQWUsS0FBSyxFQUFFLFFBQVEsQ0FBQyxRQUFRLFdBQVc7QUFDaEQsUUFBSSxDQUFDLElBQUksSUFBSSxNQUFNLEdBQUc7QUFDcEIsU0FBRyxJQUFJLFFBQVEsQ0FBQztJQUN0QjtFQUNBLENBQUc7QUFFRCxFQUFTLGFBQWEsUUFBUSxhQUFhLEdBQUcsSUFBSTtBQUdsRCxFQUFNLEtBQUssR0FBRyxRQUFPLENBQUUsRUFBRSxLQUFLLENBQUMsR0FBRyxNQUFNLEVBQUUsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDLEVBQUUsUUFBUSxDQUFDLENBQUMsUUFBUSxLQUFLLE1BQU07QUFDaEY7TUFBYTs7TUFBd0MsTUFBTSxRQUFRLElBQUksTUFBTTtNQUFJO01BQVE7SUFBSztFQUNsRyxDQUFHO0FBQ0g7QUFVTyxJQUFNLHdCQUF3QixDQUFDLFNBQVNILFNBQVE7QUFJckQsUUFBTSxhQUFpQixPQUFNO0FBQzdCLFFBQU0sb0JBQTZCLFlBQVksUUFBUSxXQUFXO0FBQ2xFLFdBQVMsSUFBSSxHQUFHLElBQUksbUJBQW1CLEtBQUs7QUFDMUMsVUFBTSxrQkFBMkIsWUFBWSxRQUFRLFdBQVc7QUFJaEUsVUFBTSxPQUFPLElBQUksTUFBTSxlQUFlO0FBQ3RDLFVBQU0sU0FBUyxRQUFRLFdBQVU7QUFDakMsUUFBSSxRQUFpQixZQUFZLFFBQVEsV0FBVztBQUVwRCxlQUFXLElBQUksUUFBUSxFQUFFLEdBQUcsR0FBRyxLQUFJLENBQUU7QUFDckMsYUFBU0ksS0FBSSxHQUFHQSxLQUFJLGlCQUFpQkEsTUFBSztBQUN4QyxZQUFNLE9BQU8sUUFBUSxTQUFRO0FBQzdCLGNBQWUsUUFBUSxNQUFJO1FBQ3pCLEtBQUssR0FBRztBQUNOLGdCQUFNLE1BQU0sUUFBUSxRQUFPO0FBQzNCLGVBQUtBLEVBQUMsSUFBSSxJQUFJLEdBQUcsU0FBUyxRQUFRLEtBQUssR0FBRyxHQUFHO0FBQzdDLG1CQUFTO0FBQ1Q7UUFDVjtRQUNRLEtBQUssSUFBSTtBQUVQLGdCQUFNLE1BQWUsWUFBWSxRQUFRLFdBQVc7QUFDcEQsZUFBS0EsRUFBQyxJQUFJLElBQUksS0FBSyxTQUFTLFFBQVEsS0FBSyxHQUFHLEdBQUc7QUFDL0MsbUJBQVM7QUFDVDtRQUNWO1FBQ1EsU0FBUztBQU1QLGdCQUFNLHNCQUFzQixRQUFlLE9BQWMsV0FBVztBQUtwRSxnQkFBTSxTQUFTLElBQUk7WUFDakIsU0FBUyxRQUFRLEtBQUs7WUFDdEI7O2FBQ0MsT0FBYyxVQUFpQixPQUFPLFFBQVEsV0FBVSxJQUFLOztZQUM5RDs7YUFDQyxPQUFjLFVBQWlCLE9BQU8sUUFBUSxZQUFXLElBQUs7O1lBQy9ELHFCQUFzQixRQUFRLGVBQWMsSUFBS0osS0FBSSxJQUFJLFFBQVEsV0FBVSxDQUFFLElBQUksUUFBUSxXQUFVLElBQU07O1lBQ3pHLHVCQUF1QixPQUFjLFVBQWlCLE9BQU8sUUFBUSxXQUFVLElBQUs7O1lBQ3BGLGdCQUFnQixTQUFTLElBQUk7O1VBQ3pDO0FBMEJVLGVBQUtJLEVBQUMsSUFBSTtBQUNWLG1CQUFTLE9BQU87UUFDMUI7TUFDQTtJQUNBO0VBRUE7QUFDRSxTQUFPO0FBQ1Q7QUE2QkEsSUFBTSxtQkFBbUIsQ0FBQyxhQUFhLE9BQU8sc0JBQXNCO0FBSWxFLFFBQU0sUUFBUSxDQUFBO0FBRWQsTUFBSSx1QkFBNkIsS0FBSyxrQkFBa0IsS0FBSSxDQUFFLEVBQUUsS0FBSyxDQUFDLEdBQUcsTUFBTSxJQUFJLENBQUM7QUFDcEYsTUFBSSxxQkFBcUIsV0FBVyxHQUFHO0FBQ3JDLFdBQU87RUFDWDtBQUNFLFFBQU0sc0JBQXNCLE1BQU07QUFDaEMsUUFBSSxxQkFBcUIsV0FBVyxHQUFHO0FBQ3JDLGFBQU87SUFDYjtBQUNJLFFBQUk7O01BQW1FLGtCQUFrQixJQUFJLHFCQUFxQixxQkFBcUIsU0FBUyxDQUFDLENBQUM7O0FBQ2xKLFdBQU8sa0JBQWtCLEtBQUssV0FBVyxrQkFBa0IsR0FBRztBQUM1RCwyQkFBcUIsSUFBRztBQUN4QixVQUFJLHFCQUFxQixTQUFTLEdBQUc7QUFDbkM7UUFBbUUsa0JBQWtCLElBQUkscUJBQXFCLHFCQUFxQixTQUFTLENBQUMsQ0FBQztNQUN0SixPQUFhO0FBQ0wsZUFBTztNQUNmO0lBQ0E7QUFDSSxXQUFPO0VBQ1g7QUFDRSxNQUFJLG1CQUFtQixvQkFBbUI7QUFDMUMsTUFBSSxxQkFBcUIsUUFBUSxNQUFNLFdBQVcsR0FBRztBQUNuRCxXQUFPO0VBQ1g7QUFLRSxRQUFNLGNBQWMsSUFBSSxZQUFXO0FBQ25DLFFBQU0sWUFBWSxvQkFBSSxJQUFHO0FBS3pCLFFBQU0sa0JBQWtCLENBQUMsUUFBUSxVQUFVO0FBQ3pDLFVBQU0sU0FBUyxVQUFVLElBQUksTUFBTTtBQUNuQyxRQUFJLFVBQVUsUUFBUSxTQUFTLE9BQU87QUFDcEMsZ0JBQVUsSUFBSSxRQUFRLEtBQUs7SUFDakM7RUFDQTtBQUlFLE1BQUk7O0lBQWdDLGlCQUFrQjs7TUFBeUIsaUJBQWtCO0lBQUc7O0FBRXBHLFFBQU0sUUFBUSxvQkFBSSxJQUFHO0FBRXJCLFFBQU0sbUJBQW1CLE1BQU07QUFDN0IsZUFBVyxRQUFRLE9BQU87QUFDeEIsWUFBTSxTQUFTLEtBQUssR0FBRztBQUN2QixZQUFNLG9CQUFvQixrQkFBa0IsSUFBSSxNQUFNO0FBQ3RELFVBQUksbUJBQW1CO0FBRXJCLDBCQUFrQjtBQUNsQixvQkFBWSxRQUFRLElBQUksUUFBUSxrQkFBa0IsS0FBSyxNQUFNLGtCQUFrQixDQUFDLENBQUM7QUFDakYsMEJBQWtCLE9BQU8sTUFBTTtBQUMvQiwwQkFBa0IsSUFBSTtBQUN0QiwwQkFBa0IsT0FBTyxDQUFBO01BQ2pDLE9BQWE7QUFFTCxvQkFBWSxRQUFRLElBQUksUUFBUSxDQUFDLElBQUksQ0FBQztNQUM5QztBQUVNLDZCQUF1QixxQkFBcUIsT0FBTyxPQUFLLE1BQU0sTUFBTTtJQUMxRTtBQUNJLFVBQU0sU0FBUztFQUNuQjtBQUdFLFNBQU8sTUFBTTtBQUNYLFFBQUksVUFBVSxnQkFBZ0IsTUFBTTtBQUNsQyxZQUFNLGFBQWlCLGVBQWUsT0FBTyxVQUFVLEdBQUcsUUFBUSxNQUFNLFNBQVMsT0FBTyxVQUFVLEdBQUcsTUFBTSxDQUFDO0FBQzVHLFlBQU0sU0FBUyxhQUFhLFVBQVUsR0FBRztBQUN6QyxVQUFJLFNBQVMsR0FBRztBQUVkLGNBQU0sS0FBSyxTQUFTO0FBQ3BCLHdCQUFnQixVQUFVLEdBQUcsUUFBUSxVQUFVLEdBQUcsUUFBUSxDQUFDO0FBRTNELHlCQUFnQjtNQUN4QixPQUFhO0FBQ0wsY0FBTSxVQUFVLFVBQVUsV0FBVyxhQUFhLEtBQUs7QUFDdkQsWUFBSSxZQUFZLE1BQU07QUFDcEIsZ0JBQU0sS0FBSyxTQUFTO0FBS3BCLGdCQUFNLGFBQWEsa0JBQWtCOztZQUEyQjtVQUFPLEtBQU0sRUFBRSxNQUFNLENBQUEsR0FBSSxHQUFHLEVBQUM7QUFDN0YsY0FBSSxXQUFXLEtBQUssV0FBVyxXQUFXLEdBQUc7QUFFM0M7O2NBQXVDO2NBQVUsU0FBUyxPQUFPLE9BQU87WUFBQztBQUN6RSw2QkFBZ0I7VUFDNUIsT0FBaUI7QUFDTCx3QkFBWSxXQUFXLEtBQUssV0FBVyxHQUFHO0FBQzFDO1VBQ1o7UUFDQSxXQUFtQixXQUFXLEtBQUssU0FBUyxVQUFVLFFBQVE7QUFFcEQsb0JBQVUsVUFBVSxhQUFhLE1BQU07QUFDdkMsZ0JBQU0sSUFBSSxVQUFVLEdBQUcsUUFBUSxVQUFVLEdBQUcsUUFBUSxVQUFVLE1BQU07UUFDOUU7TUFDQTtJQUNBO0FBRUksUUFBSSxNQUFNLFNBQVMsR0FBRztBQUNwQjtNQUFvQyxNQUFNLElBQUc7SUFDbkQsV0FBZSxxQkFBcUIsUUFBUSxpQkFBaUIsSUFBSSxpQkFBaUIsS0FBSyxRQUFRO0FBQ3pGO01BQW9DLGlCQUFpQixLQUFLLGlCQUFpQixHQUFHO0lBQ3BGLE9BQVc7QUFDTCx5QkFBbUIsb0JBQW1CO0FBQ3RDLFVBQUkscUJBQXFCLE1BQU07QUFFN0I7TUFDUixPQUFhO0FBQ0w7UUFBb0MsaUJBQWlCLEtBQUssaUJBQWlCLEdBQUc7TUFDdEY7SUFDQTtFQUNBO0FBQ0UsTUFBSSxZQUFZLFFBQVEsT0FBTyxHQUFHO0FBQ2hDLFVBQU0sVUFBVSxJQUFJLGdCQUFlO0FBQ25DLHdCQUFvQixTQUFTLGFBQWEsb0JBQUksSUFBRyxDQUFFO0FBR25ELElBQVMsYUFBYSxRQUFRLGFBQWEsQ0FBQztBQUM1QyxXQUFPLEVBQUUsU0FBUyxXQUFXLFFBQVEsUUFBUSxhQUFZLEVBQUU7RUFDL0Q7QUFDRSxTQUFPO0FBQ1Q7QUFTTyxJQUFNLDhCQUE4QixDQUFDLFNBQVMsZ0JBQWdCLG9CQUFvQixTQUFTLFlBQVksSUFBSSxPQUFPLFlBQVksV0FBVztBQWNwSSxJQUFDLGVBQWUsQ0FBQyxTQUFTLE1BQU0sbUJBQW1CLGdCQUFnQixJQUFJLGdCQUFnQixPQUFPLE1BQ3hHLFNBQVMsTUFBTSxpQkFBZTtBQUU1QixjQUFZLFFBQVE7QUFDcEIsTUFBSSxRQUFRO0FBQ1osUUFBTUosT0FBTSxZQUFZO0FBQ3hCLFFBQU0sUUFBUUEsS0FBSTtBQUVsQixRQUFNLEtBQUssc0JBQXNCLGVBQWVBLElBQUc7QUFLbkQsUUFBTSxjQUFjLGlCQUFpQixhQUFhLE9BQU8sRUFBRTtBQUMzRCxRQUFNLFVBQVUsTUFBTTtBQUN0QixNQUFJLFNBQVM7QUFFWCxlQUFXLENBQUMsUUFBUSxLQUFLLEtBQUssUUFBUSxTQUFTO0FBQzdDLFVBQUksUUFBUSxTQUFTLE9BQU8sTUFBTSxHQUFHO0FBQ25DLGdCQUFRO0FBQ1I7TUFDVjtJQUNBO0FBQ00sUUFBSSxhQUFhO0FBRWYsaUJBQVcsQ0FBQyxRQUFRLEtBQUssS0FBSyxZQUFZLFNBQVM7QUFDakQsY0FBTSxTQUFTLFFBQVEsUUFBUSxJQUFJLE1BQU07QUFDekMsWUFBSSxVQUFVLFFBQVEsU0FBUyxPQUFPO0FBQ3BDLGtCQUFRLFFBQVEsSUFBSSxRQUFRLEtBQUs7UUFDN0M7TUFDQTtBQUNRLGNBQVEsU0FBUyxlQUFlLENBQUMsUUFBUSxRQUFRLFlBQVksTUFBTSxDQUFDO0lBQzVFO0VBQ0EsT0FBVztBQUNMLFVBQU0saUJBQWlCO0VBQzdCO0FBR0ksUUFBTSxTQUFTLHNCQUFzQixlQUFlLGFBQWEsS0FBSztBQUN0RSxNQUFJLE1BQU0sV0FBVztBQUVuQixVQUFNLGtCQUFrQixJQUFJLGdCQUF5QixjQUFjLE1BQU0sU0FBUyxDQUFDO0FBQ25GLElBQVMsWUFBWSxnQkFBZ0IsV0FBVztBQUNoRCxVQUFNLFVBQVUsc0JBQXNCLGlCQUFpQixhQUFhLEtBQUs7QUFDekUsUUFBSSxVQUFVLFNBQVM7QUFFckIsWUFBTSxZQUFZLGVBQWUsQ0FBQyxRQUFRLE9BQU8sQ0FBQztJQUMxRCxPQUFhO0FBSUwsWUFBTSxZQUFZLFVBQVU7SUFDcEM7RUFDQSxPQUFXO0FBRUwsVUFBTSxZQUFZO0VBQ3hCO0FBTUksTUFBSSxPQUFPO0FBQ1QsVUFBTTs7TUFBOEMsTUFBTSxlQUFnQjs7QUFDMUUsVUFBTSxpQkFBaUI7QUFDdkIsa0JBQWMsWUFBWSxLQUFLLE1BQU07RUFDM0M7QUFDQSxHQUFLLG1CQUFtQixLQUFLO0FBMkJqQixJQUFDLGdCQUFnQixDQUFDLE1BQU0sUUFBUSxtQkFBbUIsV0FBVyxvQkFBb0I7QUFDNUYsUUFBTSxVQUFtQixjQUFjLE1BQU07QUFDN0MsZUFBYSxTQUFTLE1BQU0sbUJBQW1CLElBQUksU0FBUyxPQUFPLENBQUM7QUFDdEU7QUFhWSxJQUFDLGNBQWMsQ0FBQyxNQUFNLFFBQVEsc0JBQXNCLGNBQWMsTUFBTSxRQUFRLG1CQUFtQixlQUFlO0FBWXZILElBQU0scUJBQXFCLENBQUMsU0FBU0ssTUFBSyxvQkFBb0Isb0JBQUksSUFBRyxNQUFPO0FBQ2pGLHNCQUFvQixTQUFTQSxLQUFJLE9BQU8saUJBQWlCO0FBQ3pELGlCQUFlLFNBQVMsK0JBQStCQSxLQUFJLEtBQUssQ0FBQztBQUNuRTtBQWVZLElBQUMsd0JBQXdCLENBQUNBLE1BQUssMkJBQTJCLElBQUksV0FBVyxDQUFDLENBQUMsQ0FBQyxHQUFHLFVBQVUsSUFBSSxnQkFBZSxNQUFPO0FBQzdILFFBQU0sb0JBQW9CLGtCQUFrQix3QkFBd0I7QUFDcEUscUJBQW1CLFNBQVNBLE1BQUssaUJBQWlCO0FBQ2xELFFBQU0sVUFBVSxDQUFDLFFBQVEsYUFBWSxDQUFFO0FBRXZDLE1BQUlBLEtBQUksTUFBTSxXQUFXO0FBQ3ZCLFlBQVEsS0FBS0EsS0FBSSxNQUFNLFNBQVM7RUFDcEM7QUFDRSxNQUFJQSxLQUFJLE1BQU0sZ0JBQWdCO0FBQzVCLFlBQVEsS0FBSyxhQUFhQSxLQUFJLE1BQU0sZUFBZSxRQUFRLHdCQUF3QixDQUFDO0VBQ3hGO0FBQ0UsTUFBSSxRQUFRLFNBQVMsR0FBRztBQUN0QixRQUFJLFFBQVEsZ0JBQWdCLGlCQUFpQjtBQUMzQyxhQUFPLGFBQWEsUUFBUSxJQUFJLENBQUMsUUFBUSxNQUFNLE1BQU0sSUFBSSxTQUFTLDBCQUEwQixNQUFNLENBQUMsQ0FBQztJQUMxRyxXQUFlLFFBQVEsZ0JBQWdCLGlCQUFpQjtBQUNsRCxhQUFPLGVBQWUsT0FBTztJQUNuQztFQUNBO0FBQ0UsU0FBTyxRQUFRLENBQUM7QUFDbEI7QUFjWSxJQUFDLHNCQUFzQixDQUFDQSxNQUFLLDZCQUE2QixzQkFBc0JBLE1BQUssMEJBQTBCLElBQUksZ0JBQWUsQ0FBRTtBQVV6SSxJQUFNLGtCQUFrQixhQUFXO0FBQ3hDLFFBQU0sS0FBSyxvQkFBSSxJQUFHO0FBQ2xCLFFBQU0sV0FBb0IsWUFBWSxRQUFRLFdBQVc7QUFDekQsV0FBUyxJQUFJLEdBQUcsSUFBSSxVQUFVLEtBQUs7QUFDakMsVUFBTSxTQUFrQixZQUFZLFFBQVEsV0FBVztBQUN2RCxVQUFNLFFBQWlCLFlBQVksUUFBUSxXQUFXO0FBQ3RELE9BQUcsSUFBSSxRQUFRLEtBQUs7RUFDeEI7QUFDRSxTQUFPO0FBQ1Q7QUFvQlksSUFBQyxvQkFBb0Isa0JBQWdCLGdCQUFnQixJQUFJLFlBQXFCLGNBQWMsWUFBWSxDQUFDLENBQUM7QUFPL0csSUFBTSxtQkFBbUIsQ0FBQyxTQUFTLE9BQU87QUFDL0MsRUFBUyxhQUFhLFFBQVEsYUFBYSxHQUFHLElBQUk7QUFDbEQsRUFBTSxLQUFLLEdBQUcsUUFBTyxDQUFFLEVBQUUsS0FBSyxDQUFDLEdBQUcsTUFBTSxFQUFFLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQyxFQUFFLFFBQVEsQ0FBQyxDQUFDLFFBQVEsS0FBSyxNQUFNO0FBQ2hGLElBQVMsYUFBYSxRQUFRLGFBQWEsTUFBTTtBQUNqRCxJQUFTLGFBQWEsUUFBUSxhQUFhLEtBQUs7RUFDcEQsQ0FBRztBQUNELFNBQU87QUFDVDtBQVFPLElBQU0sMkJBQTJCLENBQUMsU0FBU0EsU0FBUSxpQkFBaUIsU0FBUyxlQUFlQSxLQUFJLEtBQUssQ0FBQztBQVd0RyxJQUFNLHNCQUFzQixDQUFDQSxNQUFLLFVBQVUsSUFBSSxZQUFXLE1BQU87QUFDdkUsTUFBSUEsZ0JBQWUsS0FBSztBQUN0QixxQkFBaUIsU0FBU0EsSUFBRztFQUNqQyxPQUFTO0FBQ0wsNkJBQXlCLFNBQVNBLElBQUc7RUFDekM7QUFDRSxTQUFPLFFBQVEsYUFBWTtBQUM3QjtBQVVZLElBQUMsb0JBQW9CLENBQUFBLFNBQU8sb0JBQW9CQSxNQUFLLElBQUksWUFBVyxDQUFFO0FDM25CM0UsSUFBTSxlQUFOLE1BQW1CO0VBQ3hCLGNBQWU7QUFJYixTQUFLLElBQUksQ0FBQTtFQUNiO0FBQ0E7QUFTTyxJQUFNLHFCQUFxQixNQUFNLElBQUksYUFBWTtBQWFqRCxJQUFNLDBCQUEwQixDQUFDLGNBQWMsTUFDcEQsYUFBYSxFQUFFLEtBQUssQ0FBQztBQWFoQixJQUFNLDZCQUE2QixDQUFDLGNBQWMsTUFBTTtBQUM3RCxRQUFNLElBQUksYUFBYTtBQUN2QixRQUFNLE1BQU0sRUFBRTtBQUNkLGVBQWEsSUFBSSxFQUFFLE9BQU8sT0FBSyxNQUFNLENBQUM7QUFDdEMsTUFBSSxRQUFRLGFBQWEsRUFBRSxRQUFRO0FBQ2pDLFlBQVEsTUFBTSx5REFBMEQ7RUFDNUU7QUFDQTtBQTBCTyxJQUFNLDRCQUE0QixDQUFDLGNBQWMsTUFBTSxTQUMxRCxRQUFRLGFBQWEsR0FBRyxDQUFDLE1BQU0sSUFBSSxDQUFDO0FDL0VqQyxJQUFNLEtBQU4sTUFBUzs7Ozs7RUFLZCxZQUFhLFFBQVEsT0FBTztBQUsxQixTQUFLLFNBQVM7QUFLZCxTQUFLLFFBQVE7RUFDakI7QUFDQTtBQVNZLElBQUMsYUFBYSxDQUFDLEdBQUcsTUFBTSxNQUFNLEtBQU0sTUFBTSxRQUFRLE1BQU0sUUFBUSxFQUFFLFdBQVcsRUFBRSxVQUFVLEVBQUUsVUFBVSxFQUFFO0FBU3ZHLElBQUMsV0FBVyxDQUFDLFFBQVEsVUFBVSxJQUFJLEdBQUcsUUFBUSxLQUFLO0FBdUNuRCxJQUFDLGtCQUFrQixDQUFBQyxVQUFRO0FBRXJDLGFBQVcsQ0FBQyxLQUFLLEtBQUssS0FBS0EsTUFBSyxJQUFJLE1BQU0sUUFBTyxHQUFJO0FBQ25ELFFBQUksVUFBVUEsT0FBTTtBQUNsQixhQUFPO0lBQ2I7RUFDQTtBQUNFLFFBQVksZUFBYztBQUM1QjtBQzVFWSxJQUFDLGFBQWEsQ0FBQyxRQUFRLFVBQVU7QUFDM0MsU0FBTyxVQUFVLE1BQU07QUFDckIsUUFBSSxNQUFNLFdBQVcsUUFBUTtBQUMzQixhQUFPO0lBQ2I7QUFDSTtJQUEwQyxNQUFNLE9BQVE7RUFDNUQ7QUFDRSxTQUFPO0FBQ1Q7QUdxQk8sSUFBTSxtQkFBTixNQUF1Qjs7Ozs7OztFQU81QixZQUFhQyxPQUFNLE9BQU8sTUFBTSxRQUFRLEdBQUc7QUFJekMsU0FBSyxPQUFPQTtBQUlaLFNBQUssUUFBUTtBQUliLFNBQUssT0FBTztBQVlaLFNBQUssUUFBUTtFQUNqQjtBQUNBO0FBTVksSUFBQyx5QkFBeUIsVUFBUTtBQUM1QyxRQUFNLE9BQU8sQ0FBQTtBQUNiLE1BQUksS0FBSyxNQUFNO0FBQ2IsU0FBSyxPQUFPLEtBQUs7RUFDckI7QUFDRSxNQUFJLEtBQUssT0FBTztBQUNkLFNBQUssUUFBUSxLQUFLO0VBQ3RCO0FBQ0UsTUFBSSxLQUFLLE1BQU07QUFDYixTQUFLLE9BQU8sS0FBSztFQUNyQjtBQUNFLE1BQUksS0FBSyxTQUFTLE1BQU07QUFDdEIsU0FBSyxRQUFRLEtBQUs7RUFDdEI7QUFDRSxTQUFPO0FBQ1Q7QUFRWSxJQUFDLGlDQUFpQyxVQUFRLElBQUksaUJBQWlCLEtBQUssUUFBUSxPQUFPLE9BQU8sU0FBUyxLQUFLLEtBQUssUUFBUSxLQUFLLEtBQUssS0FBSyxHQUFHLEtBQUssU0FBUyxNQUFNLEtBQUssUUFBUSxPQUFPLE9BQU8sU0FBUyxLQUFLLEtBQUssUUFBUSxLQUFLLEtBQUssS0FBSyxHQUFHLEtBQUssU0FBUyxPQUFPLElBQUksS0FBSyxLQUFLO0FBRTNRLElBQU0sbUJBQU4sTUFBdUI7Ozs7OztFQU01QixZQUFhQSxPQUFNLE9BQU8sUUFBUSxHQUFHO0FBSW5DLFNBQUssT0FBT0E7QUFJWixTQUFLLFFBQVE7QUFDYixTQUFLLFFBQVE7RUFDakI7QUFDQTtBQVNPLElBQU0seUJBQXlCLENBQUNBLE9BQU0sT0FBTyxRQUFRLE1BQU0sSUFBSSxpQkFBaUJBLE9BQU0sT0FBTyxLQUFLO0FBU2xHLElBQU0seUJBQXlCLENBQUNBLE9BQU0sTUFBTSxVQUFVO0FBQzNELE1BQUksU0FBUztBQUNiLE1BQUksUUFBUTtBQUNaLE1BQUlBLE1BQUssVUFBVSxNQUFNO0FBQ3ZCLFlBQVEsZ0JBQWdCQSxLQUFJO0VBQ2hDLE9BQVM7QUFDTCxhQUFTLFNBQVNBLE1BQUssTUFBTSxHQUFHLFFBQVFBLE1BQUssTUFBTSxHQUFHLEtBQUs7RUFDL0Q7QUFDRSxTQUFPLElBQUksaUJBQWlCLFFBQVEsT0FBTyxNQUFNLEtBQUs7QUFDeEQ7QUFZWSxJQUFDLHNDQUFzQyxDQUFDQSxPQUFNLE9BQU8sUUFBUSxNQUFNO0FBQzdFLE1BQUksSUFBSUEsTUFBSztBQUNiLE1BQUksUUFBUSxHQUFHO0FBRWIsUUFBSSxVQUFVLEdBQUc7QUFDZixhQUFPLHVCQUF1QkEsT0FBTSxNQUFNLEtBQUs7SUFDckQ7QUFDSTtFQUNKO0FBQ0UsU0FBTyxNQUFNLE1BQU07QUFDakIsUUFBSSxDQUFDLEVBQUUsV0FBVyxFQUFFLFdBQVc7QUFDN0IsVUFBSSxFQUFFLFNBQVMsT0FBTztBQUVwQixlQUFPLHVCQUF1QkEsT0FBTSxTQUFTLEVBQUUsR0FBRyxRQUFRLEVBQUUsR0FBRyxRQUFRLEtBQUssR0FBRyxLQUFLO01BQzVGO0FBQ00sZUFBUyxFQUFFO0lBQ2pCO0FBQ0ksUUFBSSxFQUFFLFVBQVUsUUFBUSxRQUFRLEdBQUc7QUFFakMsYUFBTyx1QkFBdUJBLE9BQU0sRUFBRSxRQUFRLEtBQUs7SUFDekQ7QUFDSSxRQUFJLEVBQUU7RUFDVjtBQUNFLFNBQU8sdUJBQXVCQSxPQUFNLE1BQU0sS0FBSztBQUNqRDtBQStFWSxJQUFDLDZDQUE2QyxDQUFDLE1BQU1DLFNBQVE7QUFDdkUsUUFBTSxRQUFRQSxLQUFJO0FBQ2xCLFFBQU0sVUFBVSxLQUFLO0FBQ3JCLFFBQU0sU0FBUyxLQUFLO0FBQ3BCLFFBQU0sUUFBUSxLQUFLO0FBQ25CLFFBQU0sUUFBUSxLQUFLO0FBQ25CLE1BQUlDLFFBQU87QUFDWCxNQUFJLFFBQVE7QUFDWixNQUFJLFlBQVksTUFBTTtBQUNwQixRQUFJLFNBQVMsT0FBTyxRQUFRLE1BQU0sS0FBSyxRQUFRLE9BQU87QUFDcEQsYUFBTztJQUNiO0FBQ0ksVUFBTSxNQUFNLGFBQWEsT0FBTyxPQUFPO0FBQ3ZDLFVBQU0sUUFBUSxJQUFJO0FBQ2xCLFFBQUksRUFBRSxpQkFBaUIsT0FBTztBQUM1QixhQUFPO0lBQ2I7QUFDSSxJQUFBQTtJQUF5QyxNQUFNO0FBQy9DLFFBQUlBLE1BQUssVUFBVSxRQUFRLENBQUNBLE1BQUssTUFBTSxTQUFTO0FBQzlDLGNBQVMsTUFBTSxXQUFXLENBQUMsTUFBTSxZQUFhLElBQUssSUFBSSxRQUFRLFNBQVMsSUFBSSxJQUFJO0FBQ2hGLFVBQUksSUFBSSxNQUFNO0FBQ2QsYUFBTyxNQUFNLE1BQU07QUFDakIsWUFBSSxDQUFDLEVBQUUsV0FBVyxFQUFFLFdBQVc7QUFDN0IsbUJBQVMsRUFBRTtRQUNyQjtBQUNRLFlBQUksRUFBRTtNQUNkO0lBQ0E7RUFDQSxPQUFTO0FBQ0wsUUFBSSxVQUFVLE1BQU07QUFDbEIsTUFBQUEsUUFBT0QsS0FBSSxJQUFJLEtBQUs7SUFDMUIsV0FBZSxXQUFXLE1BQU07QUFDMUIsVUFBSSxTQUFTLE9BQU8sT0FBTyxNQUFNLEtBQUssT0FBTyxPQUFPO0FBRWxELGVBQU87TUFDZjtBQUNNLFlBQU0sRUFBRSxLQUFJLElBQUssYUFBYSxPQUFPLE1BQU07QUFDM0MsVUFBSSxnQkFBZ0IsUUFBUSxLQUFLLG1CQUFtQixhQUFhO0FBQy9ELFFBQUFDLFFBQU8sS0FBSyxRQUFRO01BQzVCLE9BQWE7QUFFTCxlQUFPO01BQ2Y7SUFDQSxPQUFXO0FBQ0wsWUFBWSxlQUFjO0lBQ2hDO0FBQ0ksUUFBSSxTQUFTLEdBQUc7QUFDZCxjQUFRQSxNQUFLO0lBQ25CLE9BQVc7QUFDTCxjQUFRO0lBQ2Q7RUFDQTtBQUNFLFNBQU8sdUJBQXVCQSxPQUFNLE9BQU8sS0FBSyxLQUFLO0FBQ3ZEO0FBU1ksSUFBQywyQkFBMkIsQ0FBQyxHQUFHLE1BQU0sTUFBTSxLQUN0RCxNQUFNLFFBQVEsTUFBTSxRQUFRLEVBQUUsVUFBVSxFQUFFLFNBQVMsV0FBVyxFQUFFLE1BQU0sRUFBRSxJQUFJLEtBQUssV0FBVyxFQUFFLE1BQU0sRUFBRSxJQUFJLEtBQUssRUFBRSxVQUFVLEVBQUU7QUM1U3hILElBQU0sV0FBTixNQUFlOzs7OztFQUtwQixZQUFhLElBQUksSUFBSTtBQUluQixTQUFLLEtBQUs7QUFLVixTQUFLLEtBQUs7RUFDZDtBQUNBO0FBeUVZLElBQUMsaUJBQWlCLENBQUMsSUFBSSxPQUFPLElBQUksU0FBUyxJQUFJLEVBQUU7QUFFakQsSUFBQyxnQkFBZ0IsZUFBZSxnQkFBZSxHQUFJLG9CQUFJLElBQUcsQ0FBRTtBQWVqRSxJQUFNLFlBQVksQ0FBQyxNQUFNLGFBQWEsYUFBYSxTQUN0RCxDQUFDLEtBQUssVUFDTixTQUFTLEdBQUcsSUFBSSxLQUFLLEdBQUcsTUFBTSxNQUFNLFNBQVMsR0FBRyxJQUFJLEtBQUssR0FBRyxNQUFNLEtBQUssS0FBSyxLQUFLLEdBQUcsU0FBUyxDQUFDLFVBQVUsU0FBUyxJQUFJLEtBQUssRUFBRTtBQU16SCxJQUFNLCtCQUErQixDQUFDLGFBQWEsYUFBYTtBQUNyRSxRQUFNLE9BQVcsZUFBZSxZQUFZLE1BQU0sOEJBQWtDQyxPQUFNO0FBQzFGLFFBQU0sUUFBUSxZQUFZLElBQUk7QUFFOUIsTUFBSSxDQUFDLEtBQUssSUFBSSxRQUFRLEdBQUc7QUFDdkIsYUFBUyxHQUFHLFFBQVEsQ0FBQyxPQUFPLFdBQVc7QUFDckMsVUFBSSxRQUFRLFNBQVMsT0FBTyxNQUFNLEdBQUc7QUFDbkMsMEJBQWtCLGFBQWEsU0FBUyxRQUFRLEtBQUssQ0FBQztNQUM5RDtJQUNBLENBQUs7QUFDRCwwQkFBc0IsYUFBYSxTQUFTLElBQUksV0FBUztJQUFBLENBQUU7QUFDM0QsU0FBSyxJQUFJLFFBQVE7RUFDckI7QUFDQTtBQ2pKTyxJQUFNLGNBQU4sTUFBa0I7RUFDdkIsY0FBZTtBQUliLFNBQUssVUFBVSxvQkFBSSxJQUFHO0FBSXRCLFNBQUssaUJBQWlCO0FBSXRCLFNBQUssWUFBWTtFQUNyQjtBQUNBO0FBWU8sSUFBTSxpQkFBaUIsV0FBUztBQUNyQyxRQUFNLEtBQUssb0JBQUksSUFBRztBQUNsQixRQUFNLFFBQVEsUUFBUSxDQUFDLFNBQVMsV0FBVztBQUN6QyxVQUFNLFNBQVMsUUFBUSxRQUFRLFNBQVMsQ0FBQztBQUN6QyxPQUFHLElBQUksUUFBUSxPQUFPLEdBQUcsUUFBUSxPQUFPLE1BQU07RUFDbEQsQ0FBRztBQUNELFNBQU87QUFDVDtBQVVZLElBQUMsV0FBVyxDQUFDLE9BQU8sV0FBVztBQUN6QyxRQUFNLFVBQVUsTUFBTSxRQUFRLElBQUksTUFBTTtBQUN4QyxNQUFJLFlBQVksUUFBVztBQUN6QixXQUFPO0VBQ1g7QUFDRSxRQUFNLGFBQWEsUUFBUSxRQUFRLFNBQVMsQ0FBQztBQUM3QyxTQUFPLFdBQVcsR0FBRyxRQUFRLFdBQVc7QUFDMUM7QUEyQk8sSUFBTSxZQUFZLENBQUMsT0FBTyxXQUFXO0FBQzFDLE1BQUksVUFBVSxNQUFNLFFBQVEsSUFBSSxPQUFPLEdBQUcsTUFBTTtBQUNoRCxNQUFJLFlBQVksUUFBVztBQUN6QixjQUFVLENBQUE7QUFDVixVQUFNLFFBQVEsSUFBSSxPQUFPLEdBQUcsUUFBUSxPQUFPO0VBQy9DLE9BQVM7QUFDTCxVQUFNLGFBQWEsUUFBUSxRQUFRLFNBQVMsQ0FBQztBQUM3QyxRQUFJLFdBQVcsR0FBRyxRQUFRLFdBQVcsV0FBVyxPQUFPLEdBQUcsT0FBTztBQUMvRCxZQUFZLGVBQWM7SUFDaEM7RUFDQTtBQUNFLFVBQVEsS0FBSyxNQUFNO0FBQ3JCO0FBV1ksSUFBQyxjQUFjLENBQUMsU0FBUyxVQUFVO0FBQzdDLE1BQUksT0FBTztBQUNYLE1BQUksUUFBUSxRQUFRLFNBQVM7QUFDN0IsTUFBSSxNQUFNLFFBQVEsS0FBSztBQUN2QixNQUFJLFdBQVcsSUFBSSxHQUFHO0FBQ3RCLE1BQUksYUFBYSxPQUFPO0FBQ3RCLFdBQU87RUFDWDtBQUlFLE1BQUksV0FBZ0IsTUFBTyxTQUFTLFdBQVcsSUFBSSxTQUFTLEtBQU0sS0FBSztBQUN2RSxTQUFPLFFBQVEsT0FBTztBQUNwQixVQUFNLFFBQVEsUUFBUTtBQUN0QixlQUFXLElBQUksR0FBRztBQUNsQixRQUFJLFlBQVksT0FBTztBQUNyQixVQUFJLFFBQVEsV0FBVyxJQUFJLFFBQVE7QUFDakMsZUFBTztNQUNmO0FBQ00sYUFBTyxXQUFXO0lBQ3hCLE9BQVc7QUFDTCxjQUFRLFdBQVc7SUFDekI7QUFDSSxlQUFnQixPQUFPLE9BQU8sU0FBUyxDQUFDO0VBQzVDO0FBR0UsUUFBWSxlQUFjO0FBQzVCO0FBWU8sSUFBTSxPQUFPLENBQUMsT0FBT0MsUUFBTztBQUtqQyxRQUFNLFVBQVUsTUFBTSxRQUFRLElBQUlBLElBQUcsTUFBTTtBQUMzQyxTQUFPLFFBQVEsWUFBWSxTQUFTQSxJQUFHLEtBQUssQ0FBQztBQUMvQztBQU9ZLElBQUM7O0VBQXdEOztBQU85RCxJQUFNLHNCQUFzQixDQUFDLGFBQWEsU0FBUyxVQUFVO0FBQ2xFLFFBQU0sUUFBUSxZQUFZLFNBQVMsS0FBSztBQUN4QyxRQUFNLFNBQVMsUUFBUSxLQUFLO0FBQzVCLE1BQUksT0FBTyxHQUFHLFFBQVEsU0FBUyxrQkFBa0IsTUFBTTtBQUNyRCxZQUFRLE9BQU8sUUFBUSxHQUFHLEdBQUcsVUFBVSxhQUFhLFFBQVEsUUFBUSxPQUFPLEdBQUcsS0FBSyxDQUFDO0FBQ3BGLFdBQU8sUUFBUTtFQUNuQjtBQUNFLFNBQU87QUFDVDtBQVlPLElBQU0sb0JBQW9CLENBQUMsYUFBYUEsUUFBTztBQUNwRCxRQUFNOztJQUFzQyxZQUFZLElBQUksTUFBTSxRQUFRLElBQUlBLElBQUcsTUFBTTs7QUFDdkYsU0FBTyxRQUFRLG9CQUFvQixhQUFhLFNBQVNBLElBQUcsS0FBSyxDQUFDO0FBQ3BFO0FBYU8sSUFBTSxrQkFBa0IsQ0FBQyxhQUFhLE9BQU9BLFFBQU87QUFLekQsUUFBTSxVQUFVLE1BQU0sUUFBUSxJQUFJQSxJQUFHLE1BQU07QUFDM0MsUUFBTSxRQUFRLFlBQVksU0FBU0EsSUFBRyxLQUFLO0FBQzNDLFFBQU0sU0FBUyxRQUFRLEtBQUs7QUFDNUIsTUFBSUEsSUFBRyxVQUFVLE9BQU8sR0FBRyxRQUFRLE9BQU8sU0FBUyxLQUFLLE9BQU8sZ0JBQWdCLElBQUk7QUFDakYsWUFBUSxPQUFPLFFBQVEsR0FBRyxHQUFHLFVBQVUsYUFBYSxRQUFRQSxJQUFHLFFBQVEsT0FBTyxHQUFHLFFBQVEsQ0FBQyxDQUFDO0VBQy9GO0FBQ0UsU0FBTztBQUNUO0FBV08sSUFBTSxnQkFBZ0IsQ0FBQyxPQUFPLFFBQVEsY0FBYztBQUN6RCxRQUFNOztJQUF5QyxNQUFNLFFBQVEsSUFBSSxPQUFPLEdBQUcsTUFBTTs7QUFDakYsVUFBUSxZQUFZLFNBQVMsT0FBTyxHQUFHLEtBQUssQ0FBQyxJQUFJO0FBQ25EO0FBYU8sSUFBTSxpQkFBaUIsQ0FBQyxhQUFhLFNBQVMsWUFBWSxLQUFLLE1BQU07QUFDMUUsTUFBSSxRQUFRLEdBQUc7QUFDYjtFQUNKO0FBQ0UsUUFBTSxXQUFXLGFBQWE7QUFDOUIsTUFBSSxRQUFRLG9CQUFvQixhQUFhLFNBQVMsVUFBVTtBQUNoRSxNQUFJO0FBQ0osS0FBRztBQUNELGFBQVMsUUFBUSxPQUFPO0FBQ3hCLFFBQUksV0FBVyxPQUFPLEdBQUcsUUFBUSxPQUFPLFFBQVE7QUFDOUMsMEJBQW9CLGFBQWEsU0FBUyxRQUFRO0lBQ3hEO0FBQ0ksTUFBRSxNQUFNO0VBQ1osU0FBVyxRQUFRLFFBQVEsVUFBVSxRQUFRLEtBQUssRUFBRSxHQUFHLFFBQVE7QUFDL0Q7QUN0Tk8sSUFBTSxjQUFOLE1BQWtCOzs7Ozs7RUFNdkIsWUFBYUMsTUFBSyxRQUFRLE9BQU87QUFLL0IsU0FBSyxNQUFNQTtBQUtYLFNBQUssWUFBWSxJQUFJLFVBQVM7QUFLOUIsU0FBSyxjQUFjLGVBQWVBLEtBQUksS0FBSztBQUszQyxTQUFLLGFBQWEsb0JBQUksSUFBRztBQU96QixTQUFLLFVBQVUsb0JBQUksSUFBRztBQU10QixTQUFLLHFCQUFxQixvQkFBSSxJQUFHO0FBSWpDLFNBQUssZ0JBQWdCLENBQUE7QUFJckIsU0FBSyxTQUFTO0FBS2QsU0FBSyxPQUFPLG9CQUFJLElBQUc7QUFLbkIsU0FBSyxRQUFRO0FBSWIsU0FBSyxlQUFlLG9CQUFJLElBQUc7QUFJM0IsU0FBSyxpQkFBaUIsb0JBQUksSUFBRztBQUk3QixTQUFLLGdCQUFnQixvQkFBSSxJQUFHO0FBSTVCLFNBQUsseUJBQXlCO0VBQ2xDO0FBQ0E7QUFPTyxJQUFNLG9DQUFvQyxDQUFDLFNBQVMsZ0JBQWdCO0FBQ3pFLE1BQUksWUFBWSxVQUFVLFFBQVEsU0FBUyxLQUFLLENBQUssSUFBSSxZQUFZLFlBQVksQ0FBQyxPQUFPLFdBQVcsWUFBWSxZQUFZLElBQUksTUFBTSxNQUFNLEtBQUssR0FBRztBQUNsSixXQUFPO0VBQ1g7QUFDRSx3QkFBc0IsWUFBWSxTQUFTO0FBQzNDLDhCQUE0QixTQUFTLFdBQVc7QUFDaEQsaUJBQWUsU0FBUyxZQUFZLFNBQVM7QUFDN0MsU0FBTztBQUNUO0FBcUJPLElBQU0sOEJBQThCLENBQUMsYUFBYUMsT0FBTSxjQUFjO0FBQzNFLFFBQU0sT0FBT0EsTUFBSztBQUNsQixNQUFJLFNBQVMsUUFBUyxLQUFLLEdBQUcsU0FBUyxZQUFZLFlBQVksSUFBSSxLQUFLLEdBQUcsTUFBTSxLQUFLLE1BQU0sQ0FBQyxLQUFLLFNBQVU7QUFDMUcsSUFBSSxlQUFlLFlBQVksU0FBU0EsT0FBVUMsT0FBTSxFQUFFLElBQUksU0FBUztFQUMzRTtBQUNBO0FBT0EsSUFBTSxzQkFBc0IsQ0FBQyxTQUFTLFFBQVE7QUFDNUMsTUFBSSxRQUFRLFFBQVEsR0FBRztBQUN2QixNQUFJLE9BQU8sUUFBUSxNQUFNLENBQUM7QUFDMUIsTUFBSSxJQUFJO0FBQ1IsU0FBTyxJQUFJLEdBQUcsUUFBUSxNQUFNLE9BQU8sUUFBUSxFQUFFLElBQUksQ0FBQyxHQUFHO0FBQ25ELFFBQUksS0FBSyxZQUFZLE1BQU0sV0FBVyxLQUFLLGdCQUFnQixNQUFNLGFBQWE7QUFDNUUsVUFBSSxLQUFLLFVBQVUsS0FBSyxHQUFHO0FBQ3pCLFlBQUksaUJBQWlCLFFBQVEsTUFBTSxjQUFjO1FBQTBDLE1BQU0sT0FBUSxLQUFLLElBQUksTUFBTSxTQUFTLE1BQU0sT0FBTztBQUMzRyxVQUFDLE1BQU0sT0FBUSxLQUFLO1lBQUksTUFBTTs7WUFBZ0M7VUFBSTtRQUM3RztBQUNRO01BQ1I7SUFDQTtBQUNJO0VBQ0o7QUFDRSxRQUFNLFNBQVMsTUFBTTtBQUNyQixNQUFJLFFBQVE7QUFFVixZQUFRLE9BQU8sTUFBTSxJQUFJLFFBQVEsTUFBTTtFQUMzQztBQUNFLFNBQU87QUFDVDtBQU9BLElBQU0saUJBQWlCLENBQUMsSUFBSSxPQUFPLGFBQWE7QUFDOUMsYUFBVyxDQUFDLFFBQVEsV0FBVyxLQUFLLEdBQUcsUUFBUSxRQUFPLEdBQUk7QUFDeEQsVUFBTTs7TUFBeUMsTUFBTSxRQUFRLElBQUksTUFBTTs7QUFDdkUsYUFBUyxLQUFLLFlBQVksU0FBUyxHQUFHLE1BQU0sR0FBRyxNQUFNO0FBQ25ELFlBQU0sYUFBYSxZQUFZLEVBQUU7QUFDakMsWUFBTSxxQkFBcUIsV0FBVyxRQUFRLFdBQVc7QUFDekQsZUFDTSxLQUFLLFlBQVksU0FBUyxXQUFXLEtBQUssR0FBRyxTQUFTLFFBQVEsRUFBRSxHQUNwRSxLQUFLLFFBQVEsVUFBVSxPQUFPLEdBQUcsUUFBUSxvQkFDekMsU0FBUyxRQUFRLEVBQUUsRUFBRSxHQUNyQjtBQUNBLGNBQU1DLFVBQVMsUUFBUSxFQUFFO0FBQ3pCLFlBQUksV0FBVyxRQUFRLFdBQVcsT0FBT0EsUUFBTyxHQUFHLE9BQU87QUFDeEQ7UUFDVjtBQUNRLFlBQUlBLG1CQUFrQixRQUFRQSxRQUFPLFdBQVcsQ0FBQ0EsUUFBTyxRQUFRLFNBQVNBLE9BQU0sR0FBRztBQUNoRixVQUFBQSxRQUFPLEdBQUcsT0FBTyxLQUFLO1FBQ2hDO01BQ0E7SUFDQTtFQUNBO0FBQ0E7QUFNQSxJQUFNLG9CQUFvQixDQUFDLElBQUksVUFBVTtBQUd2QyxLQUFHLFFBQVEsUUFBUSxDQUFDLGFBQWEsV0FBVztBQUMxQyxVQUFNOztNQUF5QyxNQUFNLFFBQVEsSUFBSSxNQUFNOztBQUN2RSxhQUFTLEtBQUssWUFBWSxTQUFTLEdBQUcsTUFBTSxHQUFHLE1BQU07QUFDbkQsWUFBTSxhQUFhLFlBQVksRUFBRTtBQUVqQyxZQUFNLHdCQUE2QixJQUFJLFFBQVEsU0FBUyxHQUFHLElBQUksWUFBWSxTQUFTLFdBQVcsUUFBUSxXQUFXLE1BQU0sQ0FBQyxDQUFDO0FBQzFILGVBQ00sS0FBSyx1QkFBdUIsU0FBUyxRQUFRLEVBQUUsR0FDbkQsS0FBSyxLQUFLLE9BQU8sR0FBRyxTQUFTLFdBQVcsT0FDeEMsU0FBUyxRQUFRLEVBQUUsR0FDbkI7QUFDQSxjQUFNLElBQUksb0JBQW9CLFNBQVMsRUFBRTtNQUNqRDtJQUNBO0VBQ0EsQ0FBRztBQUNIO0FBZ0JBLElBQU0sc0JBQXNCLENBQUMscUJBQXFCLE1BQU07QUFDdEQsTUFBSSxJQUFJLG9CQUFvQixRQUFRO0FBQ2xDLFVBQU0sY0FBYyxvQkFBb0IsQ0FBQztBQUN6QyxVQUFNQyxPQUFNLFlBQVk7QUFDeEIsVUFBTSxRQUFRQSxLQUFJO0FBQ2xCLFVBQU0sS0FBSyxZQUFZO0FBQ3ZCLFVBQU0sZUFBZSxZQUFZO0FBQ2pDLFFBQUk7QUFDRiw0QkFBc0IsRUFBRTtBQUN4QixrQkFBWSxhQUFhLGVBQWUsWUFBWSxJQUFJLEtBQUs7QUFDN0QsTUFBQUEsS0FBSSxLQUFLLHVCQUF1QixDQUFDLGFBQWFBLElBQUcsQ0FBQztBQVFsRCxZQUFNLEtBQUssQ0FBQTtBQUVYLGtCQUFZLFFBQVE7UUFBUSxDQUFDLE1BQU0sYUFDakMsR0FBRyxLQUFLLE1BQU07QUFDWixjQUFJLFNBQVMsVUFBVSxRQUFRLENBQUMsU0FBUyxNQUFNLFNBQVM7QUFDdEQscUJBQVMsY0FBYyxhQUFhLElBQUk7VUFDcEQ7UUFDQSxDQUFTO01BQ1Q7QUFDTSxTQUFHLEtBQUssTUFBTTtBQUVaLG9CQUFZLG1CQUFtQixRQUFRLENBQUMsUUFBUUMsVUFBUztBQUd2RCxjQUFJQSxNQUFLLEtBQUssRUFBRSxTQUFTLE1BQU1BLE1BQUssVUFBVSxRQUFRLENBQUNBLE1BQUssTUFBTSxVQUFVO0FBQzFFLHFCQUFTLE9BQ047Y0FBTyxXQUNOLE1BQU0sT0FBTyxVQUFVLFFBQVEsQ0FBQyxNQUFNLE9BQU8sTUFBTTtZQUNuRTtBQUNZLG1CQUNHLFFBQVEsV0FBUztBQUNoQixvQkFBTSxnQkFBZ0JBO0FBRXRCLG9CQUFNLFFBQVE7WUFDOUIsQ0FBZTtBQUVILG1CQUNHLEtBQUssQ0FBQyxRQUFRLFdBQVcsT0FBTyxLQUFLLFNBQVMsT0FBTyxLQUFLLE1BQU07QUFHbkUsc0NBQTBCQSxNQUFLLE1BQU0sUUFBUSxXQUFXO1VBQ3BFO1FBQ0EsQ0FBUztNQUNULENBQU87QUFDRCxTQUFHLEtBQUssTUFBTUQsS0FBSSxLQUFLLG9CQUFvQixDQUFDLGFBQWFBLElBQUcsQ0FBQyxDQUFDO0FBQzlELGNBQVEsSUFBSSxDQUFBLENBQUU7QUFDZCxVQUFJLFlBQVksd0JBQXdCO0FBQ3RDLHFDQUE2QixXQUFXO01BQ2hEO0lBQ0EsVUFBSztBQUdDLFVBQUlBLEtBQUksSUFBSTtBQUNWLHVCQUFlLElBQUksT0FBT0EsS0FBSSxRQUFRO01BQzlDO0FBQ00sd0JBQWtCLElBQUksS0FBSztBQUczQixrQkFBWSxXQUFXLFFBQVEsQ0FBQyxPQUFPLFdBQVc7QUFDaEQsY0FBTSxjQUFjLFlBQVksWUFBWSxJQUFJLE1BQU0sS0FBSztBQUMzRCxZQUFJLGdCQUFnQixPQUFPO0FBQ3pCLGdCQUFNOztZQUF5QyxNQUFNLFFBQVEsSUFBSSxNQUFNOztBQUV2RSxnQkFBTSxpQkFBc0IsSUFBSSxZQUFZLFNBQVMsV0FBVyxHQUFHLENBQUM7QUFDcEUsbUJBQVNFLEtBQUksUUFBUSxTQUFTLEdBQUdBLE1BQUssa0JBQWlCO0FBQ3JELFlBQUFBLE1BQUssSUFBSSxvQkFBb0IsU0FBU0EsRUFBQztVQUNuRDtRQUNBO01BQ0EsQ0FBTztBQUlELGVBQVNBLEtBQUksYUFBYSxTQUFTLEdBQUdBLE1BQUssR0FBR0EsTUFBSztBQUNqRCxjQUFNLEVBQUUsUUFBUSxNQUFLLElBQUssYUFBYUEsRUFBQyxFQUFFO0FBQzFDLGNBQU07O1VBQXlDLE1BQU0sUUFBUSxJQUFJLE1BQU07O0FBQ3ZFLGNBQU0sb0JBQW9CLFlBQVksU0FBUyxLQUFLO0FBQ3BELFlBQUksb0JBQW9CLElBQUksUUFBUSxRQUFRO0FBQzFDLGNBQUksb0JBQW9CLFNBQVMsb0JBQW9CLENBQUMsSUFBSSxHQUFHO0FBQzNEO1VBQ1o7UUFDQTtBQUNRLFlBQUksb0JBQW9CLEdBQUc7QUFDekIsOEJBQW9CLFNBQVMsaUJBQWlCO1FBQ3hEO01BQ0E7QUFDTSxVQUFJLENBQUMsWUFBWSxTQUFTLFlBQVksV0FBVyxJQUFJRixLQUFJLFFBQVEsTUFBTSxZQUFZLFlBQVksSUFBSUEsS0FBSSxRQUFRLEdBQUc7QUFDaEgsUUFBUSxNQUFjLFFBQWdCLE1BQU0sVUFBa0IsUUFBZ0IsS0FBSyxvRUFBb0U7QUFDdkosUUFBQUEsS0FBSSxXQUFXLG9CQUFtQjtNQUMxQztBQUVNLE1BQUFBLEtBQUksS0FBSywyQkFBMkIsQ0FBQyxhQUFhQSxJQUFHLENBQUM7QUFDdEQsVUFBSUEsS0FBSSxXQUFXLElBQUksUUFBUSxHQUFHO0FBQ2hDLGNBQU0sVUFBVSxJQUFJLGdCQUFlO0FBQ25DLGNBQU1HLGNBQWEsa0NBQWtDLFNBQVMsV0FBVztBQUN6RSxZQUFJQSxhQUFZO0FBQ2QsVUFBQUgsS0FBSSxLQUFLLFVBQVUsQ0FBQyxRQUFRLGFBQVksR0FBSSxZQUFZLFFBQVFBLE1BQUssV0FBVyxDQUFDO1FBQzNGO01BQ0E7QUFDTSxVQUFJQSxLQUFJLFdBQVcsSUFBSSxVQUFVLEdBQUc7QUFDbEMsY0FBTSxVQUFVLElBQUksZ0JBQWU7QUFDbkMsY0FBTUcsY0FBYSxrQ0FBa0MsU0FBUyxXQUFXO0FBQ3pFLFlBQUlBLGFBQVk7QUFDZCxVQUFBSCxLQUFJLEtBQUssWUFBWSxDQUFDLFFBQVEsYUFBWSxHQUFJLFlBQVksUUFBUUEsTUFBSyxXQUFXLENBQUM7UUFDN0Y7TUFDQTtBQUNNLFlBQU0sRUFBRSxjQUFjLGVBQWUsZUFBYyxJQUFLO0FBQ3hELFVBQUksYUFBYSxPQUFPLEtBQUssZUFBZSxPQUFPLEtBQUssY0FBYyxPQUFPLEdBQUc7QUFDOUUscUJBQWEsUUFBUSxZQUFVO0FBQzdCLGlCQUFPLFdBQVdBLEtBQUk7QUFDdEIsY0FBSSxPQUFPLGdCQUFnQixNQUFNO0FBQy9CLG1CQUFPLGVBQWVBLEtBQUk7VUFDdEM7QUFDVSxVQUFBQSxLQUFJLFFBQVEsSUFBSSxNQUFNO1FBQ2hDLENBQVM7QUFDRCx1QkFBZSxRQUFRLFlBQVVBLEtBQUksUUFBUSxPQUFPLE1BQU0sQ0FBQztBQUMzRCxRQUFBQSxLQUFJLEtBQUssV0FBVyxDQUFDLEVBQUUsUUFBUSxlQUFlLE9BQU8sY0FBYyxTQUFTLGVBQWMsR0FBSUEsTUFBSyxXQUFXLENBQUM7QUFDL0csdUJBQWUsUUFBUSxZQUFVLE9BQU8sUUFBTyxDQUFFO01BQ3pEO0FBRU0sVUFBSSxvQkFBb0IsVUFBVSxJQUFJLEdBQUc7QUFDdkMsUUFBQUEsS0FBSSx1QkFBdUIsQ0FBQTtBQUMzQixRQUFBQSxLQUFJLEtBQUssd0JBQXdCLENBQUNBLE1BQUssbUJBQW1CLENBQUM7TUFDbkUsT0FBYTtBQUNMLDRCQUFvQixxQkFBcUIsSUFBSSxDQUFDO01BQ3REO0lBQ0E7RUFDQTtBQUNBO0FBYVksSUFBQyxXQUFXLENBQUNBLE1BQUssR0FBRyxTQUFTLE1BQU0sUUFBUSxTQUFTO0FBQy9ELFFBQU0sc0JBQXNCQSxLQUFJO0FBQ2hDLE1BQUksY0FBYztBQUlsQixNQUFJLFNBQVM7QUFDYixNQUFJQSxLQUFJLGlCQUFpQixNQUFNO0FBQzdCLGtCQUFjO0FBQ2QsSUFBQUEsS0FBSSxlQUFlLElBQUksWUFBWUEsTUFBSyxRQUFRLEtBQUs7QUFDckQsd0JBQW9CLEtBQUtBLEtBQUksWUFBWTtBQUN6QyxRQUFJLG9CQUFvQixXQUFXLEdBQUc7QUFDcEMsTUFBQUEsS0FBSSxLQUFLLHlCQUF5QixDQUFDQSxJQUFHLENBQUM7SUFDN0M7QUFDSSxJQUFBQSxLQUFJLEtBQUsscUJBQXFCLENBQUNBLEtBQUksY0FBY0EsSUFBRyxDQUFDO0VBQ3pEO0FBQ0UsTUFBSTtBQUNGLGFBQVMsRUFBRUEsS0FBSSxZQUFZO0VBQy9CLFVBQUc7QUFDQyxRQUFJLGFBQWE7QUFDZixZQUFNLGdCQUFnQkEsS0FBSSxpQkFBaUIsb0JBQW9CLENBQUM7QUFDaEUsTUFBQUEsS0FBSSxlQUFlO0FBQ25CLFVBQUksZUFBZTtBQVNqQiw0QkFBb0IscUJBQXFCLENBQUM7TUFDbEQ7SUFDQTtFQUNBO0FBQ0UsU0FBTztBQUNUO0FDdmFPLElBQU0sWUFBTixNQUFnQjs7Ozs7RUFLckIsWUFBYSxXQUFXLFlBQVk7QUFDbEMsU0FBSyxhQUFhO0FBQ2xCLFNBQUssWUFBWTtBQUlqQixTQUFLLE9BQU8sb0JBQUksSUFBRztFQUN2QjtBQUNBO0FBTUEsSUFBTSw0QkFBNEIsQ0FBQyxJQUFJLElBQUksY0FBYztBQUN2RCx3QkFBc0IsSUFBSSxVQUFVLFdBQVcsVUFBUTtBQUNyRCxRQUFJLGdCQUFnQixRQUFRLEdBQUcsTUFBTSxLQUFLLENBQUFDLFVBQVEsV0FBV0EsT0FBTSxJQUFJLENBQUMsR0FBRztBQUN6RSxlQUFTLE1BQU0sS0FBSztJQUMxQjtFQUNBLENBQUc7QUFDSDtBQVFBLElBQU0sZUFBZSxDQUFDLGFBQWEsT0FBTyxjQUFjO0FBS3RELE1BQUksU0FBUztBQUtiLE1BQUksTUFBTTtBQUNWLFFBQU1ELE9BQU0sWUFBWTtBQUN4QixRQUFNLFFBQVEsWUFBWTtBQUMxQixXQUFTQSxNQUFLLGlCQUFlO0FBQzNCLFdBQU8sTUFBTSxTQUFTLEtBQUssV0FBVyxNQUFNO0FBQzFDLFlBQU0sUUFBUUEsS0FBSTtBQUNsQixZQUFNOztRQUFzQyxNQUFNLElBQUc7O0FBSXJELFlBQU0sY0FBYyxvQkFBSSxJQUFHO0FBSTNCLFlBQU0sZ0JBQWdCLENBQUE7QUFDdEIsVUFBSSxrQkFBa0I7QUFDdEIsNEJBQXNCLGFBQWEsVUFBVSxZQUFZLFlBQVU7QUFDakUsWUFBSSxrQkFBa0IsTUFBTTtBQUMxQixjQUFJLE9BQU8sV0FBVyxNQUFNO0FBQzFCLGdCQUFJLEVBQUUsTUFBTSxLQUFJLElBQUssYUFBYSxPQUFPLE9BQU8sRUFBRTtBQUNsRCxnQkFBSSxPQUFPLEdBQUc7QUFDWixxQkFBTyxrQkFBa0IsYUFBYSxTQUFTLEtBQUssR0FBRyxRQUFRLEtBQUssR0FBRyxRQUFRLElBQUksQ0FBQztZQUNsRztBQUNZLHFCQUFTO1VBQ3JCO0FBQ1UsY0FBSSxDQUFDLE9BQU8sV0FBVyxNQUFNLEtBQUssQ0FBQUMsVUFBUTtZQUFXQTs7WUFBMkI7VUFBTSxDQUFFLEdBQUc7QUFDekYsMEJBQWMsS0FBSyxNQUFNO1VBQ3JDO1FBQ0E7TUFDQSxDQUFPO0FBQ0QsNEJBQXNCLGFBQWEsVUFBVSxXQUFXLFlBQVU7QUFDaEUsWUFDRSxrQkFBa0IsUUFDbEIsTUFBTSxLQUFLLENBQUFBLFVBQVEsV0FBV0EsT0FBTSxNQUFNLENBQUM7UUFFM0MsQ0FBQyxVQUFVLFVBQVUsWUFBWSxPQUFPLEVBQUUsR0FDMUM7QUFDQSxzQkFBWSxJQUFJLE1BQU07UUFDaEM7TUFDQSxDQUFPO0FBQ0Qsa0JBQVksUUFBUSxZQUFVO0FBQzVCLDBCQUFrQixTQUFTLGFBQWEsUUFBUSxhQUFhLFVBQVUsWUFBWSxZQUFZLHdCQUF3QixXQUFXLE1BQU0sUUFBUTtNQUN4SixDQUFPO0FBR0QsZUFBUyxJQUFJLGNBQWMsU0FBUyxHQUFHLEtBQUssR0FBRyxLQUFLO0FBQ2xELGNBQU0sT0FBTyxjQUFjLENBQUM7QUFDNUIsWUFBSSxZQUFZLGFBQWEsSUFBSSxHQUFHO0FBQ2xDLGVBQUssT0FBTyxXQUFXO0FBQ3ZCLDRCQUFrQjtRQUM1QjtNQUNBO0FBQ00sZUFBUyxrQkFBa0IsWUFBWTtJQUM3QztBQUNJLGdCQUFZLFFBQVEsUUFBUSxDQUFDLFVBQVVBLFVBQVM7QUFFOUMsVUFBSSxTQUFTLElBQUksSUFBSSxLQUFLQSxNQUFLLGVBQWU7QUFDNUMsUUFBQUEsTUFBSyxjQUFjLFNBQVM7TUFDcEM7SUFDQSxDQUFLO0FBQ0QsVUFBTTtFQUNWLEdBQUssV0FBVztBQUNkLE1BQUksVUFBVSxNQUFNO0FBQ2xCLFVBQU0scUJBQXFCLElBQUk7QUFDL0IsZ0JBQVksS0FBSyxxQkFBcUIsQ0FBQyxFQUFFLFdBQVcsUUFBUSxNQUFNLFdBQVcsbUJBQWtCLEdBQUksV0FBVyxDQUFDO0VBQ25IO0FBQ0UsU0FBTztBQUNUO0FBd0JPLElBQU0sY0FBTixjQUEwQixXQUFXOzs7OztFQUsxQyxZQUFhLFdBQVc7SUFDdEIsaUJBQWlCO0lBQ2pCLHFCQUFxQixTQUFPO0lBQzVCLGVBQWUsTUFBTTtJQUNyQixpQkFBaUIsb0JBQUksSUFBSSxDQUFDLElBQUksQ0FBQztJQUMvQix5QkFBeUI7SUFDekIsS0FBQUQ7O01BQWdDLFFBQVEsU0FBUyxJQUFJLFVBQVUsQ0FBQyxFQUFFLE1BQU0sVUFBVTs7RUFDdEYsSUFBTSxDQUFBLEdBQUk7QUFDTixVQUFLO0FBSUwsU0FBSyxRQUFRLENBQUE7QUFDYixTQUFLLE1BQU1BO0FBQ1gsU0FBSyxXQUFXLFNBQVM7QUFDekIsU0FBSyxlQUFlO0FBQ3BCLG1CQUFlLElBQUksSUFBSTtBQUN2QixTQUFLLGlCQUFpQjtBQUN0QixTQUFLLHFCQUFxQjtBQUkxQixTQUFLLFlBQVksQ0FBQTtBQUlqQixTQUFLLFlBQVksQ0FBQTtBQU1qQixTQUFLLFVBQVU7QUFDZixTQUFLLFVBQVU7QUFDZixTQUFLLGFBQWE7QUFDbEIsU0FBSyx5QkFBeUI7QUFDOUIsU0FBSyxpQkFBaUI7QUFJdEIsU0FBSywwQkFBMEIsaUJBQWU7QUFFNUMsVUFDRSxDQUFDLEtBQUssbUJBQW1CLFdBQVcsS0FDcEMsQ0FBQyxLQUFLLE1BQU0sS0FBSyxDQUFBQyxVQUFRLFlBQVksbUJBQW1CLElBQUlBLEtBQUksQ0FBQyxLQUNoRSxDQUFDLEtBQUssZUFBZSxJQUFJLFlBQVksTUFBTSxNQUFNLENBQUMsWUFBWSxVQUFVLENBQUMsS0FBSyxlQUFlLElBQUksWUFBWSxPQUFPLFdBQVcsSUFDaEk7QUFDQTtNQUNSO0FBQ00sWUFBTSxVQUFVLEtBQUs7QUFDckIsWUFBTSxVQUFVLEtBQUs7QUFDckIsWUFBTSxRQUFRLFVBQVUsS0FBSyxZQUFZLEtBQUs7QUFDOUMsVUFBSSxTQUFTO0FBQ1gsYUFBSyxjQUFhO01BQzFCLFdBQWlCLENBQUMsU0FBUztBQUVuQixhQUFLLE1BQU0sT0FBTyxJQUFJO01BQzlCO0FBQ00sWUFBTSxhQUFhLElBQUksVUFBUztBQUNoQyxrQkFBWSxXQUFXLFFBQVEsQ0FBQyxVQUFVLFdBQVc7QUFDbkQsY0FBTSxhQUFhLFlBQVksWUFBWSxJQUFJLE1BQU0sS0FBSztBQUMxRCxjQUFNLE1BQU0sV0FBVztBQUN2QixZQUFJLE1BQU0sR0FBRztBQUNYLHlCQUFlLFlBQVksUUFBUSxZQUFZLEdBQUc7UUFDNUQ7TUFDQSxDQUFPO0FBQ0QsWUFBTSxNQUFXLFlBQVc7QUFDNUIsVUFBSSxTQUFTO0FBQ2IsVUFBSSxLQUFLLGFBQWEsS0FBSyxNQUFNLEtBQUssYUFBYSxLQUFLLGtCQUFrQixNQUFNLFNBQVMsS0FBSyxDQUFDLFdBQVcsQ0FBQyxTQUFTO0FBRWxILGNBQU0sU0FBUyxNQUFNLE1BQU0sU0FBUyxDQUFDO0FBQ3JDLGVBQU8sWUFBWSxnQkFBZ0IsQ0FBQyxPQUFPLFdBQVcsWUFBWSxTQUFTLENBQUM7QUFDNUUsZUFBTyxhQUFhLGdCQUFnQixDQUFDLE9BQU8sWUFBWSxVQUFVLENBQUM7TUFDM0UsT0FBYTtBQUVMLGNBQU0sS0FBSyxJQUFJLFVBQVUsWUFBWSxXQUFXLFVBQVUsQ0FBQztBQUMzRCxpQkFBUztNQUNqQjtBQUNNLFVBQUksQ0FBQyxXQUFXLENBQUMsU0FBUztBQUN4QixhQUFLLGFBQWE7TUFDMUI7QUFFTTtRQUFzQjtRQUFhLFlBQVk7O1FBQXdDLFVBQVE7QUFDN0YsY0FBSSxnQkFBZ0IsUUFBUSxLQUFLLE1BQU0sS0FBSyxDQUFBQSxVQUFRLFdBQVdBLE9BQU0sSUFBSSxDQUFDLEdBQUc7QUFDM0UscUJBQVMsTUFBTSxJQUFJO1VBQzdCO1FBQ0E7TUFBTztBQUNELFlBQU0sY0FBYyxDQUFDLEVBQUUsV0FBVyxNQUFNLE1BQU0sU0FBUyxDQUFDLEdBQUcsUUFBUSxZQUFZLFFBQVEsTUFBTSxVQUFVLFNBQVMsUUFBUSxvQkFBb0IsWUFBWSxtQkFBa0IsR0FBSSxJQUFJO0FBQ2xMLFVBQUksUUFBUTtBQUNWLGFBQUssS0FBSyxvQkFBb0IsV0FBVztNQUNqRCxPQUFhO0FBQ0wsYUFBSyxLQUFLLHNCQUFzQixXQUFXO01BQ25EO0lBQ0E7QUFDSSxTQUFLLElBQUksR0FBRyxvQkFBb0IsS0FBSyx1QkFBdUI7QUFDNUQsU0FBSyxJQUFJLEdBQUcsV0FBVyxNQUFNO0FBQzNCLFdBQUssUUFBTztJQUNsQixDQUFLO0VBQ0w7Ozs7RUFLRSxXQUFZLFFBQVE7QUFDbEIsYUFBZSxRQUFRLE1BQU0sSUFBSSxTQUFTLENBQUMsTUFBTTtBQUNqRCxXQUFPLFFBQVEsV0FBUztBQUN0QixVQUFJLEtBQUssTUFBTSxNQUFNLFFBQU0sT0FBTyxLQUFLLEdBQUc7QUFDeEMsWUFBSSxNQUFNLFFBQVEsS0FBSztBQUFLLFVBQVEsS0FBSywwQkFBMEI7QUFDbkUsYUFBSyxNQUFNLEtBQUssS0FBSztNQUM3QjtJQUNBLENBQUs7RUFDTDs7OztFQUtFLGlCQUFrQixRQUFRO0FBQ3hCLFNBQUssZUFBZSxJQUFJLE1BQU07RUFDbEM7Ozs7RUFLRSxvQkFBcUIsUUFBUTtBQUMzQixTQUFLLGVBQWUsT0FBTyxNQUFNO0VBQ3JDO0VBRUUsTUFBTyxpQkFBaUIsTUFBTSxpQkFBaUIsTUFBTTtBQUNuRCxRQUFLLGtCQUFrQixLQUFLLFFBQU8sS0FBUSxrQkFBa0IsS0FBSyxRQUFPLEdBQUs7QUFDNUUsV0FBSyxJQUFJLFNBQVMsUUFBTTtBQUN0QixZQUFJLGdCQUFnQjtBQUNsQixlQUFLLFVBQVUsUUFBUSxVQUFRLDBCQUEwQixJQUFJLE1BQU0sSUFBSSxDQUFDO0FBQ3hFLGVBQUssWUFBWSxDQUFBO1FBQzNCO0FBQ1EsWUFBSSxnQkFBZ0I7QUFDbEIsZUFBSyxVQUFVLFFBQVEsVUFBUSwwQkFBMEIsSUFBSSxNQUFNLElBQUksQ0FBQztBQUN4RSxlQUFLLFlBQVksQ0FBQTtRQUMzQjtBQUNRLGFBQUssS0FBSyxpQkFBaUIsQ0FBQyxFQUFFLGtCQUFrQixnQkFBZ0Isa0JBQWtCLGVBQWMsQ0FBRSxDQUFDO01BQzNHLENBQU87SUFDUDtFQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RUFzQkUsZ0JBQWlCO0FBQ2YsU0FBSyxhQUFhO0VBQ3RCOzs7Ozs7RUFPRSxPQUFRO0FBQ04sU0FBSyxVQUFVO0FBQ2YsUUFBSTtBQUNKLFFBQUk7QUFDRixZQUFNLGFBQWEsTUFBTSxLQUFLLFdBQVcsTUFBTTtJQUNyRCxVQUFLO0FBQ0MsV0FBSyxVQUFVO0lBQ3JCO0FBQ0ksV0FBTztFQUNYOzs7Ozs7RUFPRSxPQUFRO0FBQ04sU0FBSyxVQUFVO0FBQ2YsUUFBSTtBQUNKLFFBQUk7QUFDRixZQUFNLGFBQWEsTUFBTSxLQUFLLFdBQVcsTUFBTTtJQUNyRCxVQUFLO0FBQ0MsV0FBSyxVQUFVO0lBQ3JCO0FBQ0ksV0FBTztFQUNYOzs7Ozs7RUFPRSxVQUFXO0FBQ1QsV0FBTyxLQUFLLFVBQVUsU0FBUztFQUNuQzs7Ozs7O0VBT0UsVUFBVztBQUNULFdBQU8sS0FBSyxVQUFVLFNBQVM7RUFDbkM7RUFFRSxVQUFXO0FBQ1QsU0FBSyxlQUFlLE9BQU8sSUFBSTtBQUMvQixTQUFLLElBQUksSUFBSSxvQkFBb0IsS0FBSyx1QkFBdUI7QUFDN0QsVUFBTSxRQUFPO0VBQ2pCO0FBQ0E7QUNsVkEsVUFBVywwQkFBMkIsU0FBUztBQUM3QyxRQUFNLG9CQUE2QixZQUFZLFFBQVEsV0FBVztBQUNsRSxXQUFTLElBQUksR0FBRyxJQUFJLG1CQUFtQixLQUFLO0FBQzFDLFVBQU0sa0JBQTJCLFlBQVksUUFBUSxXQUFXO0FBQ2hFLFVBQU0sU0FBUyxRQUFRLFdBQVU7QUFDakMsUUFBSSxRQUFpQixZQUFZLFFBQVEsV0FBVztBQUNwRCxhQUFTQyxLQUFJLEdBQUdBLEtBQUksaUJBQWlCQSxNQUFLO0FBQ3hDLFlBQU0sT0FBTyxRQUFRLFNBQVE7QUFFN0IsVUFBSSxTQUFTLElBQUk7QUFDZixjQUFNLE1BQWUsWUFBWSxRQUFRLFdBQVc7QUFDcEQsY0FBTSxJQUFJLEtBQUssU0FBUyxRQUFRLEtBQUssR0FBRyxHQUFHO0FBQzNDLGlCQUFTO01BQ2pCLFlBQXlCLFFBQVEsVUFBVSxHQUFHO0FBQ3RDLGNBQU0sc0JBQXNCLFFBQWUsT0FBYyxXQUFXO0FBS3BFLGNBQU0sU0FBUyxJQUFJO1VBQ2pCLFNBQVMsUUFBUSxLQUFLO1VBQ3RCOztXQUNDLE9BQWMsVUFBaUIsT0FBTyxRQUFRLFdBQVUsSUFBSzs7VUFDOUQ7O1dBQ0MsT0FBYyxVQUFpQixPQUFPLFFBQVEsWUFBVyxJQUFLOzs7VUFFL0QscUJBQXNCLFFBQVEsZUFBYyxJQUFLLFFBQVEsV0FBVSxJQUFLLFFBQVEsV0FBVSxJQUFNOztVQUNoRyx1QkFBdUIsT0FBYyxVQUFpQixPQUFPLFFBQVEsV0FBVSxJQUFLOztVQUNwRixnQkFBZ0IsU0FBUyxJQUFJOztRQUN2QztBQUNRLGNBQU07QUFDTixpQkFBUyxPQUFPO01BQ3hCLE9BQWE7QUFDTCxjQUFNLE1BQU0sUUFBUSxRQUFPO0FBQzNCLGNBQU0sSUFBSSxHQUFHLFNBQVMsUUFBUSxLQUFLLEdBQUcsR0FBRztBQUN6QyxpQkFBUztNQUNqQjtJQUNBO0VBQ0E7QUFDQTtBQUVPLElBQU0sbUJBQU4sTUFBdUI7Ozs7O0VBSzVCLFlBQWEsU0FBUyxhQUFhO0FBQ2pDLFNBQUssTUFBTSwwQkFBMEIsT0FBTztBQUk1QyxTQUFLLE9BQU87QUFDWixTQUFLLE9BQU87QUFDWixTQUFLLGNBQWM7QUFDbkIsU0FBSyxLQUFJO0VBQ2I7Ozs7RUFLRSxPQUFRO0FBRU4sT0FBRztBQUNELFdBQUssT0FBTyxLQUFLLElBQUksS0FBSSxFQUFHLFNBQVM7SUFDM0MsU0FBYSxLQUFLLGVBQWUsS0FBSyxTQUFTLFFBQVEsS0FBSyxLQUFLLGdCQUFnQjtBQUM3RSxXQUFPLEtBQUs7RUFDaEI7QUFDQTtBQWlETyxJQUFNLG1CQUFOLE1BQXVCOzs7O0VBSTVCLFlBQWEsU0FBUztBQUNwQixTQUFLLGFBQWE7QUFDbEIsU0FBSyxhQUFhO0FBQ2xCLFNBQUssVUFBVTtBQUNmLFNBQUssVUFBVTtBQVdmLFNBQUssZ0JBQWdCLENBQUE7RUFDekI7QUFDQTtBQU1ZLElBQUMsZUFBZSxhQUFXLGVBQWUsU0FBUyxpQkFBaUIsZUFBZTtBQW1IL0YsSUFBTSxjQUFjLENBQUMsTUFBTSxTQUFTO0FBQ2xDLE1BQUksS0FBSyxnQkFBZ0IsSUFBSTtBQUMzQixVQUFNLEVBQUUsUUFBUSxNQUFLLElBQUssS0FBSztBQUMvQixXQUFPLElBQUksR0FBRyxTQUFTLFFBQVEsUUFBUSxJQUFJLEdBQUcsS0FBSyxTQUFTLElBQUk7RUFDcEUsV0FBYSxLQUFLLGdCQUFnQixNQUFNO0FBQ3BDLFVBQU0sRUFBRSxRQUFRLE1BQUssSUFBSyxLQUFLO0FBQy9CLFdBQU8sSUFBSSxLQUFLLFNBQVMsUUFBUSxRQUFRLElBQUksR0FBRyxLQUFLLFNBQVMsSUFBSTtFQUN0RSxPQUFTO0FBQ0wsVUFBTTs7TUFBZ0M7O0FBQ3RDLFVBQU0sRUFBRSxRQUFRLE1BQUssSUFBSyxTQUFTO0FBQ25DLFdBQU8sSUFBSTtNQUNULFNBQVMsUUFBUSxRQUFRLElBQUk7TUFDN0I7TUFDQSxTQUFTLFFBQVEsUUFBUSxPQUFPLENBQUM7TUFDakM7TUFDQSxTQUFTO01BQ1QsU0FBUztNQUNULFNBQVM7TUFDVCxTQUFTLFFBQVEsT0FBTyxJQUFJO0lBQ2xDO0VBQ0E7QUFDQTtBQVdZLElBQUMsaUJBQWlCLENBQUMsU0FBUyxXQUFXLGlCQUFpQixXQUFXLG9CQUFvQjtBQUNqRyxNQUFJLFFBQVEsV0FBVyxHQUFHO0FBQ3hCLFdBQU8sUUFBUSxDQUFDO0VBQ3BCO0FBQ0UsUUFBTSxpQkFBaUIsUUFBUSxJQUFJLFlBQVUsSUFBSSxTQUFrQixjQUFjLE1BQU0sQ0FBQyxDQUFDO0FBQ3pGLE1BQUkscUJBQXFCLGVBQWUsSUFBSSxhQUFXLElBQUksaUJBQWlCLFNBQVMsSUFBSSxDQUFDO0FBTTFGLE1BQUksWUFBWTtBQUVoQixRQUFNLGdCQUFnQixJQUFJLFNBQVE7QUFFbEMsUUFBTSxvQkFBb0IsSUFBSSxpQkFBaUIsYUFBYTtBQU01RCxTQUFPLE1BQU07QUFFWCx5QkFBcUIsbUJBQW1CLE9BQU8sU0FBTyxJQUFJLFNBQVMsSUFBSTtBQUN2RSx1QkFBbUI7O01BQ3VCLENBQUMsTUFBTSxTQUFTO0FBQ3RELFlBQUksS0FBSyxLQUFLLEdBQUcsV0FBVyxLQUFLLEtBQUssR0FBRyxRQUFRO0FBQy9DLGdCQUFNLFlBQVksS0FBSyxLQUFLLEdBQUcsUUFBUSxLQUFLLEtBQUssR0FBRztBQUNwRCxjQUFJLGNBQWMsR0FBRztBQUVuQixtQkFBTyxLQUFLLEtBQUssZ0JBQWdCLEtBQUssS0FBSyxjQUN2QyxJQUNBLEtBQUssS0FBSyxnQkFBZ0IsT0FBTyxJQUFJO1VBQ3JELE9BQWlCO0FBQ0wsbUJBQU87VUFDbkI7UUFDQSxPQUFlO0FBQ0wsaUJBQU8sS0FBSyxLQUFLLEdBQUcsU0FBUyxLQUFLLEtBQUssR0FBRztRQUNwRDtNQUNBO0lBQ0E7QUFDSSxRQUFJLG1CQUFtQixXQUFXLEdBQUc7QUFDbkM7SUFDTjtBQUNJLFVBQU0sY0FBYyxtQkFBbUIsQ0FBQztBQUd4QyxVQUFNOztNQUF3QyxZQUFZLEtBQU0sR0FBRzs7QUFFbkUsUUFBSSxjQUFjLE1BQU07QUFDdEIsVUFBSTs7UUFBd0MsWUFBWTs7QUFDeEQsVUFBSSxXQUFXO0FBSWYsYUFBTyxTQUFTLFFBQVEsS0FBSyxHQUFHLFFBQVEsS0FBSyxVQUFVLFVBQVUsT0FBTyxHQUFHLFFBQVEsVUFBVSxPQUFPLFVBQVUsS0FBSyxHQUFHLFVBQVUsVUFBVSxPQUFPLEdBQUcsUUFBUTtBQUMxSixlQUFPLFlBQVksS0FBSTtBQUN2QixtQkFBVztNQUNuQjtBQUNNLFVBQ0UsU0FBUztNQUNULEtBQUssR0FBRyxXQUFXO01BQ2xCLFlBQVksS0FBSyxHQUFHLFFBQVEsVUFBVSxPQUFPLEdBQUcsUUFBUSxVQUFVLE9BQU8sUUFDMUU7QUFDQTtNQUNSO0FBRU0sVUFBSSxnQkFBZ0IsVUFBVSxPQUFPLEdBQUcsUUFBUTtBQUM5QyxzQ0FBOEIsbUJBQW1CLFVBQVUsUUFBUSxVQUFVLE1BQU07QUFDbkYsb0JBQVksRUFBRSxRQUFRLE1BQU0sUUFBUSxFQUFDO0FBQ3JDLG9CQUFZLEtBQUk7TUFDeEIsT0FBYTtBQUNMLFlBQUksVUFBVSxPQUFPLEdBQUcsUUFBUSxVQUFVLE9BQU8sU0FBUyxLQUFLLEdBQUcsT0FBTztBQUV2RSxjQUFJLFVBQVUsT0FBTyxnQkFBZ0IsTUFBTTtBQUV6QyxzQkFBVSxPQUFPLFNBQVMsS0FBSyxHQUFHLFFBQVEsS0FBSyxTQUFTLFVBQVUsT0FBTyxHQUFHO1VBQ3hGLE9BQWlCO0FBQ0wsMENBQThCLG1CQUFtQixVQUFVLFFBQVEsVUFBVSxNQUFNO0FBQ25GLGtCQUFNLE9BQU8sS0FBSyxHQUFHLFFBQVEsVUFBVSxPQUFPLEdBQUcsUUFBUSxVQUFVLE9BQU87QUFJMUUsa0JBQU0sU0FBUyxJQUFJLEtBQUssU0FBUyxhQUFhLFVBQVUsT0FBTyxHQUFHLFFBQVEsVUFBVSxPQUFPLE1BQU0sR0FBRyxJQUFJO0FBQ3hHLHdCQUFZLEVBQUUsUUFBUSxRQUFRLEVBQUM7VUFDM0M7UUFDQSxPQUFlO0FBQ0wsZ0JBQU0sT0FBTyxVQUFVLE9BQU8sR0FBRyxRQUFRLFVBQVUsT0FBTyxTQUFTLEtBQUssR0FBRztBQUMzRSxjQUFJLE9BQU8sR0FBRztBQUNaLGdCQUFJLFVBQVUsT0FBTyxnQkFBZ0IsTUFBTTtBQUV6Qyx3QkFBVSxPQUFPLFVBQVU7WUFDekMsT0FBbUI7QUFDTCxxQkFBTyxZQUFZLE1BQU0sSUFBSTtZQUMzQztVQUNBO0FBQ1UsY0FBSSxDQUFDLFVBQVUsT0FBTzs7WUFBOEI7VUFBSSxHQUFJO0FBQzFELDBDQUE4QixtQkFBbUIsVUFBVSxRQUFRLFVBQVUsTUFBTTtBQUNuRix3QkFBWSxFQUFFLFFBQVEsTUFBTSxRQUFRLEVBQUM7QUFDckMsd0JBQVksS0FBSTtVQUM1QjtRQUNBO01BQ0E7SUFDQSxPQUFXO0FBQ0wsa0JBQVksRUFBRTs7UUFBa0MsWUFBWTtTQUFPLFFBQVEsRUFBQztBQUM1RSxrQkFBWSxLQUFJO0lBQ3RCO0FBQ0ksYUFDTSxPQUFPLFlBQVksTUFDdkIsU0FBUyxRQUFRLEtBQUssR0FBRyxXQUFXLGVBQWUsS0FBSyxHQUFHLFVBQVUsVUFBVSxPQUFPLEdBQUcsUUFBUSxVQUFVLE9BQU8sVUFBVSxLQUFLLGdCQUFnQixNQUNqSixPQUFPLFlBQVksS0FBSSxHQUN2QjtBQUNBLG9DQUE4QixtQkFBbUIsVUFBVSxRQUFRLFVBQVUsTUFBTTtBQUNuRixrQkFBWSxFQUFFLFFBQVEsTUFBTSxRQUFRLEVBQUM7SUFDM0M7RUFDQTtBQUNFLE1BQUksY0FBYyxNQUFNO0FBQ3RCLGtDQUE4QixtQkFBbUIsVUFBVSxRQUFRLFVBQVUsTUFBTTtBQUNuRixnQkFBWTtFQUNoQjtBQUNFLDBCQUF3QixpQkFBaUI7QUFFekMsUUFBTSxNQUFNLGVBQWUsSUFBSSxhQUFXLGNBQWMsT0FBTyxDQUFDO0FBQ2hFLFFBQU0sS0FBSyxnQkFBZ0IsR0FBRztBQUM5QixpQkFBZSxlQUFlLEVBQUU7QUFDaEMsU0FBTyxjQUFjLGFBQVk7QUFDbkM7QUFRWSxJQUFDLGVBQWUsQ0FBQyxRQUFRLElBQUksV0FBVyxpQkFBaUIsV0FBVyxvQkFBb0I7QUFDbEcsUUFBTSxRQUFRLGtCQUFrQixFQUFFO0FBQ2xDLFFBQU0sVUFBVSxJQUFJLFNBQVE7QUFDNUIsUUFBTSxtQkFBbUIsSUFBSSxpQkFBaUIsT0FBTztBQUNyRCxRQUFNLFVBQVUsSUFBSSxTQUFrQixjQUFjLE1BQU0sQ0FBQztBQUMzRCxRQUFNLFNBQVMsSUFBSSxpQkFBaUIsU0FBUyxLQUFLO0FBQ2xELFNBQU8sT0FBTyxNQUFNO0FBQ2xCLFVBQU0sT0FBTyxPQUFPO0FBQ3BCLFVBQU0sYUFBYSxLQUFLLEdBQUc7QUFDM0IsVUFBTSxVQUFVLE1BQU0sSUFBSSxVQUFVLEtBQUs7QUFDekMsUUFBSSxPQUFPLEtBQUssZ0JBQWdCLE1BQU07QUFFcEMsYUFBTyxLQUFJO0FBQ1g7SUFDTjtBQUNJLFFBQUksS0FBSyxHQUFHLFFBQVEsS0FBSyxTQUFTLFNBQVM7QUFDekMsb0NBQThCLGtCQUFrQixNQUFXLElBQUksVUFBVSxLQUFLLEdBQUcsT0FBTyxDQUFDLENBQUM7QUFDMUYsYUFBTyxLQUFJO0FBQ1gsYUFBTyxPQUFPLFFBQVEsT0FBTyxLQUFLLEdBQUcsV0FBVyxZQUFZO0FBQzFELHNDQUE4QixrQkFBa0IsT0FBTyxNQUFNLENBQUM7QUFDOUQsZUFBTyxLQUFJO01BQ25CO0lBQ0EsT0FBVztBQUVMLGFBQU8sT0FBTyxRQUFRLE9BQU8sS0FBSyxHQUFHLFdBQVcsY0FBYyxPQUFPLEtBQUssR0FBRyxRQUFRLE9BQU8sS0FBSyxVQUFVLFNBQVM7QUFDbEgsZUFBTyxLQUFJO01BQ25CO0lBQ0E7RUFDQTtBQUNFLDBCQUF3QixnQkFBZ0I7QUFFeEMsUUFBTSxLQUFLLGNBQWMsT0FBTztBQUNoQyxpQkFBZSxTQUFTLEVBQUU7QUFDMUIsU0FBTyxRQUFRLGFBQVk7QUFDN0I7QUFXQSxJQUFNLHdCQUF3QixnQkFBYztBQUMxQyxNQUFJLFdBQVcsVUFBVSxHQUFHO0FBQzFCLGVBQVcsY0FBYyxLQUFLLEVBQUUsU0FBUyxXQUFXLFNBQVMsYUFBc0IsYUFBYSxXQUFXLFFBQVEsV0FBVyxFQUFDLENBQUU7QUFDakksZUFBVyxRQUFRLGNBQXVCLGNBQWE7QUFDdkQsZUFBVyxVQUFVO0VBQ3pCO0FBQ0E7QUFPQSxJQUFNLGdDQUFnQyxDQUFDLFlBQVksUUFBUSxXQUFXO0FBRXBFLE1BQUksV0FBVyxVQUFVLEtBQUssV0FBVyxlQUFlLE9BQU8sR0FBRyxRQUFRO0FBQ3hFLDBCQUFzQixVQUFVO0VBQ3BDO0FBQ0UsTUFBSSxXQUFXLFlBQVksR0FBRztBQUM1QixlQUFXLGFBQWEsT0FBTyxHQUFHO0FBRWxDLGVBQVcsUUFBUSxZQUFZLE9BQU8sR0FBRyxNQUFNO0FBRS9DLElBQVMsYUFBYSxXQUFXLFFBQVEsYUFBYSxPQUFPLEdBQUcsUUFBUSxNQUFNO0VBQ2xGO0FBQ0UsU0FBTyxNQUFNLFdBQVcsU0FBUyxNQUFNO0FBQ3ZDLGFBQVc7QUFDYjtBQVFBLElBQU0sMEJBQTBCLENBQUMsZUFBZTtBQUM5Qyx3QkFBc0IsVUFBVTtBQUdoQyxRQUFNLGNBQWMsV0FBVyxRQUFRO0FBUXZDLEVBQVMsYUFBYSxhQUFhLFdBQVcsY0FBYyxNQUFNO0FBRWxFLFdBQVMsSUFBSSxHQUFHLElBQUksV0FBVyxjQUFjLFFBQVEsS0FBSztBQUN4RCxVQUFNLGNBQWMsV0FBVyxjQUFjLENBQUM7QUFLOUMsSUFBUyxhQUFhLGFBQWEsWUFBWSxPQUFPO0FBRXRELElBQVMsZ0JBQWdCLGFBQWEsWUFBWSxXQUFXO0VBQ2pFO0FBQ0E7QUFRTyxJQUFNLHNCQUFzQixDQUFDLFFBQVEsa0JBQWtCLFVBQVUsYUFBYTtBQUNuRixRQUFNLGdCQUFnQixJQUFJLFNBQWtCLGNBQWMsTUFBTSxDQUFDO0FBQ2pFLFFBQU0sY0FBYyxJQUFJLGlCQUFpQixlQUFlLEtBQUs7QUFDN0QsUUFBTSxnQkFBZ0IsSUFBSSxTQUFRO0FBQ2xDLFFBQU0sYUFBYSxJQUFJLGlCQUFpQixhQUFhO0FBQ3JELFdBQVMsT0FBTyxZQUFZLE1BQU0sU0FBUyxNQUFNLE9BQU8sWUFBWSxLQUFJLEdBQUk7QUFDMUUsa0NBQThCLFlBQVksaUJBQWlCLElBQUksR0FBRyxDQUFDO0VBQ3ZFO0FBQ0UsMEJBQXdCLFVBQVU7QUFDbEMsUUFBTSxLQUFLLGNBQWMsYUFBYTtBQUN0QyxpQkFBZSxlQUFlLEVBQUU7QUFDaEMsU0FBTyxjQUFjLGFBQVk7QUFDbkM7QUFtSVksSUFBQyw0QkFBNEIsWUFBVSxvQkFBb0IsUUFBVSxJQUFJLGlCQUFpQixlQUFlO0FDeHNCckgsSUFBTSxzQkFBc0I7QUFNckIsSUFBTSxTQUFOLE1BQWE7Ozs7O0VBS2xCLFlBQWEsUUFBUSxhQUFhO0FBS2hDLFNBQUssU0FBUztBQUtkLFNBQUssZ0JBQWdCO0FBS3JCLFNBQUssY0FBYztBQUluQixTQUFLLFdBQVc7QUFJaEIsU0FBSyxRQUFRO0FBSWIsU0FBSyxTQUFTO0FBSWQsU0FBSyxRQUFRO0VBQ2pCOzs7Ozs7Ozs7Ozs7OztFQWVFLElBQUksT0FBUTtBQUNWLFdBQU8sS0FBSyxVQUFVLEtBQUssUUFBUSxVQUFVLEtBQUssZUFBZSxLQUFLLE1BQU07RUFDaEY7Ozs7Ozs7OztFQVVFLFFBQVMsUUFBUTtBQUNmLFdBQU8sVUFBVSxLQUFLLFlBQVksV0FBVyxPQUFPLEVBQUU7RUFDMUQ7Ozs7RUFLRSxJQUFJLE9BQVE7QUFDVixRQUFJLEtBQUssVUFBVSxNQUFNO0FBQ3ZCLFVBQUksS0FBSyxZQUFZLElBQUkscUJBQXFCLFdBQVcsR0FBRztBQUMxRCxjQUFZRSxRQUFPLG1CQUFtQjtNQUM5QztBQUNNLFlBQU1DLFFBQU8sb0JBQUksSUFBRztBQUNwQixZQUFNLFNBQVMsS0FBSztBQUNwQixZQUFNOztRQUF5QyxLQUFLLFlBQVksUUFBUSxJQUFJLE1BQU07O0FBQ2xGLGNBQVEsUUFBUSxTQUFPO0FBQ3JCLFlBQUksUUFBUSxNQUFNO0FBQ2hCLGdCQUFNOztZQUE0QixPQUFPLEtBQUssSUFBSSxHQUFHOztBQUlyRCxjQUFJO0FBQ0osY0FBSTtBQUNKLGNBQUksS0FBSyxLQUFLLElBQUksR0FBRztBQUNuQixnQkFBSSxPQUFPLEtBQUs7QUFDaEIsbUJBQU8sU0FBUyxRQUFRLEtBQUssS0FBSyxJQUFJLEdBQUc7QUFDdkMscUJBQU8sS0FBSztZQUMxQjtBQUNZLGdCQUFJLEtBQUssUUFBUSxJQUFJLEdBQUc7QUFDdEIsa0JBQUksU0FBUyxRQUFRLEtBQUssUUFBUSxJQUFJLEdBQUc7QUFDdkMseUJBQVM7QUFDVCwyQkFBaUIsS0FBSyxLQUFLLFFBQVEsV0FBVSxDQUFFO2NBQy9ELE9BQXFCO0FBQ0w7Y0FDaEI7WUFDQSxPQUFtQjtBQUNMLGtCQUFJLFNBQVMsUUFBUSxLQUFLLFFBQVEsSUFBSSxHQUFHO0FBQ3ZDLHlCQUFTO0FBQ1QsMkJBQWlCLEtBQUssS0FBSyxRQUFRLFdBQVUsQ0FBRTtjQUMvRCxPQUFxQjtBQUNMLHlCQUFTO0FBQ1QsMkJBQVc7Y0FDM0I7WUFDQTtVQUNBLE9BQWlCO0FBQ0wsZ0JBQUksS0FBSyxRQUFRLElBQUksR0FBRztBQUN0Qix1QkFBUztBQUNULHlCQUFpQjs7Z0JBQXlCLEtBQUssUUFBUSxXQUFVO2NBQUU7WUFDakYsT0FBbUI7QUFDTDtZQUNkO1VBQ0E7QUFDVSxVQUFBQSxNQUFLLElBQUksS0FBSyxFQUFFLFFBQVEsU0FBUSxDQUFFO1FBQzVDO01BQ0EsQ0FBTztBQUNELFdBQUssUUFBUUE7SUFDbkI7QUFDSSxXQUFPLEtBQUs7RUFDaEI7Ozs7Ozs7OztFQVVFLElBQUksUUFBUztBQUNYLFdBQU8sS0FBSyxRQUFRO0VBQ3hCOzs7Ozs7Ozs7RUFVRSxLQUFNLFFBQVE7QUFDWixXQUFPLE9BQU8sR0FBRyxVQUFVLEtBQUssWUFBWSxZQUFZLElBQUksT0FBTyxHQUFHLE1BQU0sS0FBSztFQUNyRjs7Ozs7Ozs7O0VBVUUsSUFBSSxVQUFXO0FBQ2IsUUFBSSxVQUFVLEtBQUs7QUFDbkIsUUFBSSxZQUFZLE1BQU07QUFDcEIsVUFBSSxLQUFLLFlBQVksSUFBSSxxQkFBcUIsV0FBVyxHQUFHO0FBQzFELGNBQVlELFFBQU8sbUJBQW1CO01BQzlDO0FBQ00sWUFBTSxTQUFTLEtBQUs7QUFDcEIsWUFBTSxRQUFZQSxRQUFNO0FBQ3hCLFlBQU0sVUFBY0EsUUFBTTtBQUkxQixZQUFNLFFBQVEsQ0FBQTtBQUNkLGdCQUFVO1FBQ1I7UUFDQTtRQUNBO1FBQ0EsTUFBTSxLQUFLO01BQ25CO0FBQ00sWUFBTTs7UUFBeUMsS0FBSyxZQUFZLFFBQVEsSUFBSSxNQUFNOztBQUNsRixVQUFJLFFBQVEsSUFBSSxJQUFJLEdBQUc7QUFJckIsWUFBSSxTQUFTO0FBQ2IsY0FBTSxTQUFTLE1BQU07QUFDbkIsY0FBSSxRQUFRO0FBQ1Ysa0JBQU0sS0FBSyxNQUFNO1VBQzdCO1FBQ0E7QUFDUSxpQkFBUyxPQUFPLE9BQU8sUUFBUSxTQUFTLE1BQU0sT0FBTyxLQUFLLE9BQU87QUFDL0QsY0FBSSxLQUFLLFNBQVM7QUFDaEIsZ0JBQUksS0FBSyxRQUFRLElBQUksS0FBSyxDQUFDLEtBQUssS0FBSyxJQUFJLEdBQUc7QUFDMUMsa0JBQUksV0FBVyxRQUFRLE9BQU8sV0FBVyxRQUFXO0FBQ2xELHVCQUFNO0FBQ04seUJBQVMsRUFBRSxRQUFRLEVBQUM7Y0FDcEM7QUFDYyxxQkFBTyxVQUFVLEtBQUs7QUFDdEIsc0JBQVEsSUFBSSxJQUFJO1lBQzlCO1VBQ0EsT0FBaUI7QUFDTCxnQkFBSSxLQUFLLEtBQUssSUFBSSxHQUFHO0FBQ25CLGtCQUFJLFdBQVcsUUFBUSxPQUFPLFdBQVcsUUFBVztBQUNsRCx1QkFBTTtBQUNOLHlCQUFTLEVBQUUsUUFBUSxDQUFBLEVBQUU7Y0FDckM7QUFDYyxxQkFBTyxTQUFTLE9BQU8sT0FBTyxPQUFPLEtBQUssUUFBUSxXQUFVLENBQUU7QUFDOUQsb0JBQU0sSUFBSSxJQUFJO1lBQzVCLE9BQW1CO0FBQ0wsa0JBQUksV0FBVyxRQUFRLE9BQU8sV0FBVyxRQUFXO0FBQ2xELHVCQUFNO0FBQ04seUJBQVMsRUFBRSxRQUFRLEVBQUM7Y0FDcEM7QUFDYyxxQkFBTyxVQUFVLEtBQUs7WUFDcEM7VUFDQTtRQUNBO0FBQ1EsWUFBSSxXQUFXLFFBQVEsT0FBTyxXQUFXLFFBQVc7QUFDbEQsaUJBQU07UUFDaEI7TUFDQTtBQUNNLFdBQUssV0FBVztJQUN0QjtBQUNJOztNQUEyQjs7RUFDL0I7QUFDQTtBQW1CQSxJQUFNLFlBQVksQ0FBQyxRQUFRLFVBQVU7QUFDbkMsUUFBTUUsUUFBTyxDQUFBO0FBQ2IsU0FBTyxNQUFNLFVBQVUsUUFBUSxVQUFVLFFBQVE7QUFDL0MsUUFBSSxNQUFNLE1BQU0sY0FBYyxNQUFNO0FBRWxDLE1BQUFBLE1BQUssUUFBUSxNQUFNLE1BQU0sU0FBUztJQUN4QyxPQUFXO0FBRUwsVUFBSSxJQUFJO0FBQ1IsVUFBSTs7UUFBc0MsTUFBTSxNQUFNLE9BQVE7O0FBQzlELGFBQU8sTUFBTSxNQUFNLFNBQVMsTUFBTSxNQUFNO0FBQ3RDLFlBQUksQ0FBQyxFQUFFLFNBQVM7QUFDZDtRQUNWO0FBQ1EsWUFBSSxFQUFFO01BQ2Q7QUFDTSxNQUFBQSxNQUFLLFFBQVEsQ0FBQztJQUNwQjtBQUNJO0lBQTBDLE1BQU0sTUFBTTtFQUMxRDtBQUNFLFNBQU9BO0FBQ1Q7QUNoUUEsSUFBTSxrQkFBa0I7QUFTeEIsSUFBSSw4QkFBOEI7QUFFM0IsSUFBTSxvQkFBTixNQUF3Qjs7Ozs7RUFLN0IsWUFBYSxHQUFHLE9BQU87QUFDckIsTUFBRSxTQUFTO0FBQ1gsU0FBSyxJQUFJO0FBQ1QsU0FBSyxRQUFRO0FBQ2IsU0FBSyxZQUFZO0VBQ3JCO0FBQ0E7QUFLQSxJQUFNLHlCQUF5QixZQUFVO0FBQUUsU0FBTyxZQUFZO0FBQTZCO0FBUzNGLElBQU0sa0JBQWtCLENBQUMsUUFBUSxHQUFHLFVBQVU7QUFDNUMsU0FBTyxFQUFFLFNBQVM7QUFDbEIsU0FBTyxJQUFJO0FBQ1gsSUFBRSxTQUFTO0FBQ1gsU0FBTyxRQUFRO0FBQ2YsU0FBTyxZQUFZO0FBQ3JCO0FBT0EsSUFBTSxlQUFlLENBQUMsY0FBYyxHQUFHLFVBQVU7QUFDL0MsTUFBSSxhQUFhLFVBQVUsaUJBQWlCO0FBRTFDLFVBQU0sU0FBUyxhQUFhLE9BQU8sQ0FBQyxHQUFHLE1BQU0sRUFBRSxZQUFZLEVBQUUsWUFBWSxJQUFJLENBQUM7QUFDOUUsb0JBQWdCLFFBQVEsR0FBRyxLQUFLO0FBQ2hDLFdBQU87RUFDWCxPQUFTO0FBRUwsVUFBTSxLQUFLLElBQUksa0JBQWtCLEdBQUcsS0FBSztBQUN6QyxpQkFBYSxLQUFLLEVBQUU7QUFDcEIsV0FBTztFQUNYO0FBQ0E7QUFjTyxJQUFNLGFBQWEsQ0FBQyxRQUFRLFVBQVU7QUFDM0MsTUFBSSxPQUFPLFdBQVcsUUFBUSxVQUFVLEtBQUssT0FBTyxrQkFBa0IsTUFBTTtBQUMxRSxXQUFPO0VBQ1g7QUFDRSxRQUFNLFNBQVMsT0FBTyxjQUFjLFdBQVcsSUFBSSxPQUFPLE9BQU8sY0FBYyxPQUFPLENBQUMsR0FBRyxNQUFXLElBQUksUUFBUSxFQUFFLEtBQUssSUFBUyxJQUFJLFFBQVEsRUFBRSxLQUFLLElBQUksSUFBSSxDQUFDO0FBQzdKLE1BQUksSUFBSSxPQUFPO0FBQ2YsTUFBSSxTQUFTO0FBQ2IsTUFBSSxXQUFXLE1BQU07QUFDbkIsUUFBSSxPQUFPO0FBQ1gsYUFBUyxPQUFPO0FBQ2hCLDJCQUF1QixNQUFNO0VBQ2pDO0FBRUUsU0FBTyxFQUFFLFVBQVUsUUFBUSxTQUFTLE9BQU87QUFDekMsUUFBSSxDQUFDLEVBQUUsV0FBVyxFQUFFLFdBQVc7QUFDN0IsVUFBSSxRQUFRLFNBQVMsRUFBRSxRQUFRO0FBQzdCO01BQ1I7QUFDTSxnQkFBVSxFQUFFO0lBQ2xCO0FBQ0ksUUFBSSxFQUFFO0VBQ1Y7QUFFRSxTQUFPLEVBQUUsU0FBUyxRQUFRLFNBQVMsT0FBTztBQUN4QyxRQUFJLEVBQUU7QUFDTixRQUFJLENBQUMsRUFBRSxXQUFXLEVBQUUsV0FBVztBQUM3QixnQkFBVSxFQUFFO0lBQ2xCO0VBQ0E7QUFJRSxTQUFPLEVBQUUsU0FBUyxRQUFRLEVBQUUsS0FBSyxHQUFHLFdBQVcsRUFBRSxHQUFHLFVBQVUsRUFBRSxLQUFLLEdBQUcsUUFBUSxFQUFFLEtBQUssV0FBVyxFQUFFLEdBQUcsT0FBTztBQUM1RyxRQUFJLEVBQUU7QUFDTixRQUFJLENBQUMsRUFBRSxXQUFXLEVBQUUsV0FBVztBQUM3QixnQkFBVSxFQUFFO0lBQ2xCO0VBQ0E7QUEwQkUsTUFBSSxXQUFXLFFBQWEsSUFBSSxPQUFPLFFBQVEsTUFBTTtFQUFzQyxFQUFFLE9BQVEsU0FBUyxpQkFBaUI7QUFFN0gsb0JBQWdCLFFBQVEsR0FBRyxNQUFNO0FBQ2pDLFdBQU87RUFDWCxPQUFTO0FBRUwsV0FBTyxhQUFhLE9BQU8sZUFBZSxHQUFHLE1BQU07RUFDdkQ7QUFDQTtBQVdPLElBQU0sc0JBQXNCLENBQUMsY0FBYyxPQUFPLFFBQVE7QUFDL0QsV0FBUyxJQUFJLGFBQWEsU0FBUyxHQUFHLEtBQUssR0FBRyxLQUFLO0FBQ2pELFVBQU0sSUFBSSxhQUFhLENBQUM7QUFDeEIsUUFBSSxNQUFNLEdBQUc7QUFJWCxVQUFJLElBQUksRUFBRTtBQUNWLFFBQUUsU0FBUztBQUlYLGFBQU8sTUFBTSxFQUFFLFdBQVcsQ0FBQyxFQUFFLFlBQVk7QUFDdkMsWUFBSSxFQUFFO0FBQ04sWUFBSSxLQUFLLENBQUMsRUFBRSxXQUFXLEVBQUUsV0FBVztBQUVsQyxZQUFFLFNBQVMsRUFBRTtRQUN2QjtNQUNBO0FBQ00sVUFBSSxNQUFNLFFBQVEsRUFBRSxXQUFXLE1BQU07QUFFbkMscUJBQWEsT0FBTyxHQUFHLENBQUM7QUFDeEI7TUFDUjtBQUNNLFFBQUUsSUFBSTtBQUNOLFFBQUUsU0FBUztJQUNqQjtBQUNJLFFBQUksUUFBUSxFQUFFLFNBQVUsTUFBTSxLQUFLLFVBQVUsRUFBRSxPQUFRO0FBQ3JELFFBQUUsUUFBYSxJQUFJLE9BQU8sRUFBRSxRQUFRLEdBQUc7SUFDN0M7RUFDQTtBQUNBO0FBMkJPLElBQU0sb0JBQW9CLENBQUNDLE9BQU0sYUFBYSxVQUFVO0FBQzdELFFBQU0sY0FBY0E7QUFDcEIsUUFBTSxxQkFBcUIsWUFBWTtBQUN2QyxTQUFPLE1BQU07QUFFWCxJQUFJLGVBQWUsb0JBQW9CQSxPQUFNLE1BQU0sQ0FBQSxDQUFFLEVBQUUsS0FBSyxLQUFLO0FBQ2pFLFFBQUlBLE1BQUssVUFBVSxNQUFNO0FBQ3ZCO0lBQ047QUFDSSxJQUFBQTtJQUF5Q0EsTUFBSyxNQUFNO0VBQ3hEO0FBQ0UsNEJBQTBCLFlBQVksS0FBSyxPQUFPLFdBQVc7QUFDL0Q7QUFNTyxJQUFNLGVBQU4sTUFBbUI7RUFDeEIsY0FBZTtBQUliLFNBQUssUUFBUTtBQUliLFNBQUssT0FBTyxvQkFBSSxJQUFHO0FBSW5CLFNBQUssU0FBUztBQUlkLFNBQUssTUFBTTtBQUNYLFNBQUssVUFBVTtBQUtmLFNBQUssTUFBTSxtQkFBa0I7QUFLN0IsU0FBSyxPQUFPLG1CQUFrQjtBQUk5QixTQUFLLGdCQUFnQjtFQUN6Qjs7OztFQUtFLElBQUksU0FBVTtBQUNaLFdBQU8sS0FBSzs7TUFBMEMsS0FBSyxNQUFNO1FBQVU7RUFDL0U7Ozs7Ozs7Ozs7O0VBWUUsV0FBWSxHQUFHLE1BQU07QUFDbkIsU0FBSyxNQUFNO0FBQ1gsU0FBSyxRQUFRO0VBQ2pCOzs7O0VBS0UsUUFBUztBQUNQLFVBQVksb0JBQW1CO0VBQ25DOzs7O0VBS0UsUUFBUztBQUNQLFVBQVksb0JBQW1CO0VBQ25DOzs7O0VBS0UsT0FBUSxVQUFVO0VBQUE7Ozs7RUFLbEIsSUFBSSxTQUFVO0FBQ1osUUFBSSxJQUFJLEtBQUs7QUFDYixXQUFPLE1BQU0sUUFBUSxFQUFFLFNBQVM7QUFDOUIsVUFBSSxFQUFFO0lBQ1o7QUFDSSxXQUFPO0VBQ1g7Ozs7Ozs7O0VBU0UsY0FBZSxhQUFhLGFBQWE7QUFDdkMsUUFBSSxDQUFDLFlBQVksU0FBUyxLQUFLLGVBQWU7QUFDNUMsV0FBSyxjQUFjLFNBQVM7SUFDbEM7RUFDQTs7Ozs7O0VBT0UsUUFBUyxHQUFHO0FBQ1YsNEJBQXdCLEtBQUssS0FBSyxDQUFDO0VBQ3ZDOzs7Ozs7RUFPRSxZQUFhLEdBQUc7QUFDZCw0QkFBd0IsS0FBSyxNQUFNLENBQUM7RUFDeEM7Ozs7OztFQU9FLFVBQVcsR0FBRztBQUNaLCtCQUEyQixLQUFLLEtBQUssQ0FBQztFQUMxQzs7Ozs7O0VBT0UsY0FBZSxHQUFHO0FBQ2hCLCtCQUEyQixLQUFLLE1BQU0sQ0FBQztFQUMzQzs7Ozs7RUFNRSxTQUFVO0VBQUE7QUFDWjtBQVdPLElBQU0sZ0JBQWdCLENBQUNBLE9BQU0sT0FBTyxRQUFRO0FBQ2pELE1BQUksUUFBUSxHQUFHO0FBQ2IsWUFBUUEsTUFBSyxVQUFVO0VBQzNCO0FBQ0UsTUFBSSxNQUFNLEdBQUc7QUFDWCxVQUFNQSxNQUFLLFVBQVU7RUFDekI7QUFDRSxNQUFJLE1BQU0sTUFBTTtBQUNoQixRQUFNLEtBQUssQ0FBQTtBQUNYLE1BQUksSUFBSUEsTUFBSztBQUNiLFNBQU8sTUFBTSxRQUFRLE1BQU0sR0FBRztBQUM1QixRQUFJLEVBQUUsYUFBYSxDQUFDLEVBQUUsU0FBUztBQUM3QixZQUFNLElBQUksRUFBRSxRQUFRLFdBQVU7QUFDOUIsVUFBSSxFQUFFLFVBQVUsT0FBTztBQUNyQixpQkFBUyxFQUFFO01BQ25CLE9BQWE7QUFDTCxpQkFBUyxJQUFJLE9BQU8sSUFBSSxFQUFFLFVBQVUsTUFBTSxHQUFHLEtBQUs7QUFDaEQsYUFBRyxLQUFLLEVBQUUsQ0FBQyxDQUFDO0FBQ1o7UUFDVjtBQUNRLGdCQUFRO01BQ2hCO0lBQ0E7QUFDSSxRQUFJLEVBQUU7RUFDVjtBQUNFLFNBQU87QUFDVDtBQVNPLElBQU0sa0JBQWtCLENBQUFBLFVBQVE7QUFDckMsUUFBTSxLQUFLLENBQUE7QUFDWCxNQUFJLElBQUlBLE1BQUs7QUFDYixTQUFPLE1BQU0sTUFBTTtBQUNqQixRQUFJLEVBQUUsYUFBYSxDQUFDLEVBQUUsU0FBUztBQUM3QixZQUFNLElBQUksRUFBRSxRQUFRLFdBQVU7QUFDOUIsZUFBUyxJQUFJLEdBQUcsSUFBSSxFQUFFLFFBQVEsS0FBSztBQUNqQyxXQUFHLEtBQUssRUFBRSxDQUFDLENBQUM7TUFDcEI7SUFDQTtBQUNJLFFBQUksRUFBRTtFQUNWO0FBQ0UsU0FBTztBQUNUO0FBa0NPLElBQU0sa0JBQWtCLENBQUNDLE9BQU0sTUFBTTtBQUMxQyxNQUFJLFFBQVE7QUFDWixNQUFJLElBQUlBLE1BQUs7QUFDYixTQUFPLE1BQU0sTUFBTTtBQUNqQixRQUFJLEVBQUUsYUFBYSxDQUFDLEVBQUUsU0FBUztBQUM3QixZQUFNLElBQUksRUFBRSxRQUFRLFdBQVU7QUFDOUIsZUFBUyxJQUFJLEdBQUcsSUFBSSxFQUFFLFFBQVEsS0FBSztBQUNqQyxVQUFFLEVBQUUsQ0FBQyxHQUFHLFNBQVNBLEtBQUk7TUFDN0I7SUFDQTtBQUNJLFFBQUksRUFBRTtFQUNWO0FBQ0E7QUFXTyxJQUFNLGNBQWMsQ0FBQ0EsT0FBTSxNQUFNO0FBSXRDLFFBQU0sU0FBUyxDQUFBO0FBQ2Ysa0JBQWdCQSxPQUFNLENBQUMsR0FBRyxNQUFNO0FBQzlCLFdBQU8sS0FBSyxFQUFFLEdBQUcsR0FBR0EsS0FBSSxDQUFDO0VBQzdCLENBQUc7QUFDRCxTQUFPO0FBQ1Q7QUFTTyxJQUFNLHlCQUF5QixDQUFBQSxVQUFRO0FBQzVDLE1BQUksSUFBSUEsTUFBSztBQUliLE1BQUksaUJBQWlCO0FBQ3JCLE1BQUksc0JBQXNCO0FBQzFCLFNBQU87SUFDTCxDQUFDLE9BQU8sUUFBUSxJQUFLO0FBQ25CLGFBQU87SUFDYjtJQUNJLE1BQU0sTUFBTTtBQUVWLFVBQUksbUJBQW1CLE1BQU07QUFDM0IsZUFBTyxNQUFNLFFBQVEsRUFBRSxTQUFTO0FBQzlCLGNBQUksRUFBRTtRQUNoQjtBQUVRLFlBQUksTUFBTSxNQUFNO0FBQ2QsaUJBQU87WUFDTCxNQUFNO1lBQ04sT0FBTztVQUNuQjtRQUNBO0FBRVEseUJBQWlCLEVBQUUsUUFBUSxXQUFVO0FBQ3JDLDhCQUFzQjtBQUN0QixZQUFJLEVBQUU7TUFDZDtBQUNNLFlBQU0sUUFBUSxlQUFlLHFCQUFxQjtBQUVsRCxVQUFJLGVBQWUsVUFBVSxxQkFBcUI7QUFDaEQseUJBQWlCO01BQ3pCO0FBQ00sYUFBTztRQUNMLE1BQU07UUFDTjtNQUNSO0lBQ0E7RUFDQTtBQUNBO0FBbUNPLElBQU0sY0FBYyxDQUFDQSxPQUFNLFVBQVU7QUFDMUMsUUFBTSxTQUFTLFdBQVdBLE9BQU0sS0FBSztBQUNyQyxNQUFJLElBQUlBLE1BQUs7QUFDYixNQUFJLFdBQVcsTUFBTTtBQUNuQixRQUFJLE9BQU87QUFDWCxhQUFTLE9BQU87RUFDcEI7QUFDRSxTQUFPLE1BQU0sTUFBTSxJQUFJLEVBQUUsT0FBTztBQUM5QixRQUFJLENBQUMsRUFBRSxXQUFXLEVBQUUsV0FBVztBQUM3QixVQUFJLFFBQVEsRUFBRSxRQUFRO0FBQ3BCLGVBQU8sRUFBRSxRQUFRLFdBQVUsRUFBRyxLQUFLO01BQzNDO0FBQ00sZUFBUyxFQUFFO0lBQ2pCO0VBQ0E7QUFDQTtBQVdPLElBQU0sOEJBQThCLENBQUMsYUFBYSxRQUFRLGVBQWUsWUFBWTtBQUMxRixNQUFJLE9BQU87QUFDWCxRQUFNQyxPQUFNLFlBQVk7QUFDeEIsUUFBTSxjQUFjQSxLQUFJO0FBQ3hCLFFBQU0sUUFBUUEsS0FBSTtBQUNsQixRQUFNLFFBQVEsa0JBQWtCLE9BQU8sT0FBTyxTQUFTLGNBQWM7QUFJckUsTUFBSSxjQUFjLENBQUE7QUFDbEIsUUFBTSxrQkFBa0IsTUFBTTtBQUM1QixRQUFJLFlBQVksU0FBUyxHQUFHO0FBQzFCLGFBQU8sSUFBSSxLQUFLLFNBQVMsYUFBYSxTQUFTLE9BQU8sV0FBVyxDQUFDLEdBQUcsTUFBTSxRQUFRLEtBQUssUUFBUSxPQUFPLFNBQVMsTUFBTSxJQUFJLFFBQVEsTUFBTSxJQUFJLFdBQVcsV0FBVyxDQUFDO0FBQ25LLFdBQUssVUFBVSxhQUFhLENBQUM7QUFDN0Isb0JBQWMsQ0FBQTtJQUNwQjtFQUNBO0FBQ0UsVUFBUSxRQUFRLE9BQUs7QUFDbkIsUUFBSSxNQUFNLE1BQU07QUFDZCxrQkFBWSxLQUFLLENBQUM7SUFDeEIsT0FBVztBQUNMLGNBQVEsRUFBRSxhQUFXO1FBQ25CLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO0FBQ0gsc0JBQVksS0FBSyxDQUFDO0FBQ2xCO1FBQ0Y7QUFDRSwwQkFBZTtBQUNmLGtCQUFRLEVBQUUsYUFBVztZQUNuQixLQUFLO1lBQ0wsS0FBSztBQUNILHFCQUFPLElBQUksS0FBSyxTQUFTLGFBQWEsU0FBUyxPQUFPLFdBQVcsQ0FBQyxHQUFHLE1BQU0sUUFBUSxLQUFLLFFBQVEsT0FBTyxTQUFTLE1BQU0sSUFBSSxRQUFRLE1BQU0sSUFBSSxjQUFjLElBQUk7O2dCQUFzQztjQUFDLENBQUUsQ0FBQztBQUN4TSxtQkFBSyxVQUFVLGFBQWEsQ0FBQztBQUM3QjtZQUNGLEtBQUs7QUFDSCxxQkFBTyxJQUFJLEtBQUssU0FBUyxhQUFhLFNBQVMsT0FBTyxXQUFXLENBQUMsR0FBRyxNQUFNLFFBQVEsS0FBSyxRQUFRLE9BQU8sU0FBUyxNQUFNLElBQUksUUFBUSxNQUFNLElBQUk7O2dCQUErQjtjQUFDLENBQUU7QUFDOUssbUJBQUssVUFBVSxhQUFhLENBQUM7QUFDN0I7WUFDRjtBQUNFLGtCQUFJLGFBQWEsY0FBYztBQUM3Qix1QkFBTyxJQUFJLEtBQUssU0FBUyxhQUFhLFNBQVMsT0FBTyxXQUFXLENBQUMsR0FBRyxNQUFNLFFBQVEsS0FBSyxRQUFRLE9BQU8sU0FBUyxNQUFNLElBQUksUUFBUSxNQUFNLElBQUksWUFBWSxDQUFDLENBQUM7QUFDMUoscUJBQUssVUFBVSxhQUFhLENBQUM7Y0FDN0MsT0FBcUI7QUFDTCxzQkFBTSxJQUFJLE1BQU0sNkNBQTZDO2NBQzdFO1VBQ0E7TUFDQTtJQUNBO0VBQ0EsQ0FBRztBQUNELGtCQUFlO0FBQ2pCO0FBRUEsSUFBTSxpQkFBaUIsTUFBWUMsUUFBTyxrQkFBa0I7QUFXckQsSUFBTSx5QkFBeUIsQ0FBQyxhQUFhLFFBQVEsT0FBTyxZQUFZO0FBQzdFLE1BQUksUUFBUSxPQUFPLFNBQVM7QUFDMUIsVUFBTSxlQUFjO0VBQ3hCO0FBQ0UsTUFBSSxVQUFVLEdBQUc7QUFDZixRQUFJLE9BQU8sZUFBZTtBQUN4QiwwQkFBb0IsT0FBTyxlQUFlLE9BQU8sUUFBUSxNQUFNO0lBQ3JFO0FBQ0ksV0FBTyw0QkFBNEIsYUFBYSxRQUFRLE1BQU0sT0FBTztFQUN6RTtBQUNFLFFBQU0sYUFBYTtBQUNuQixRQUFNLFNBQVMsV0FBVyxRQUFRLEtBQUs7QUFDdkMsTUFBSSxJQUFJLE9BQU87QUFDZixNQUFJLFdBQVcsTUFBTTtBQUNuQixRQUFJLE9BQU87QUFDWCxhQUFTLE9BQU87QUFFaEIsUUFBSSxVQUFVLEdBQUc7QUFFZixVQUFJLEVBQUU7QUFDTixlQUFVLEtBQUssRUFBRSxhQUFhLENBQUMsRUFBRSxVQUFXLEVBQUUsU0FBUztJQUM3RDtFQUNBO0FBQ0UsU0FBTyxNQUFNLE1BQU0sSUFBSSxFQUFFLE9BQU87QUFDOUIsUUFBSSxDQUFDLEVBQUUsV0FBVyxFQUFFLFdBQVc7QUFDN0IsVUFBSSxTQUFTLEVBQUUsUUFBUTtBQUNyQixZQUFJLFFBQVEsRUFBRSxRQUFRO0FBRXBCLDRCQUFrQixhQUFhLFNBQVMsRUFBRSxHQUFHLFFBQVEsRUFBRSxHQUFHLFFBQVEsS0FBSyxDQUFDO1FBQ2xGO0FBQ1E7TUFDUjtBQUNNLGVBQVMsRUFBRTtJQUNqQjtFQUNBO0FBQ0UsTUFBSSxPQUFPLGVBQWU7QUFDeEIsd0JBQW9CLE9BQU8sZUFBZSxZQUFZLFFBQVEsTUFBTTtFQUN4RTtBQUNFLFNBQU8sNEJBQTRCLGFBQWEsUUFBUSxHQUFHLE9BQU87QUFDcEU7QUFhTyxJQUFNLHVCQUF1QixDQUFDLGFBQWEsUUFBUSxZQUFZO0FBRXBFLFFBQU0sVUFBVSxPQUFPLGlCQUFpQixDQUFBLEdBQUksT0FBTyxDQUFDLFdBQVcsZUFBZSxXQUFXLFFBQVEsVUFBVSxRQUFRLGFBQWEsV0FBVyxFQUFFLE9BQU8sR0FBRyxHQUFHLE9BQU8sT0FBTSxDQUFFO0FBQ3pLLE1BQUksSUFBSSxPQUFPO0FBQ2YsTUFBSSxHQUFHO0FBQ0wsV0FBTyxFQUFFLE9BQU87QUFDZCxVQUFJLEVBQUU7SUFDWjtFQUNBO0FBQ0UsU0FBTyw0QkFBNEIsYUFBYSxRQUFRLEdBQUcsT0FBTztBQUNwRTtBQVdPLElBQU0saUJBQWlCLENBQUMsYUFBYSxRQUFRLE9BQU9DLFlBQVc7QUFDcEUsTUFBSUEsWUFBVyxHQUFHO0FBQUU7RUFBTTtBQUMxQixRQUFNLGFBQWE7QUFDbkIsUUFBTSxjQUFjQTtBQUNwQixRQUFNLFNBQVMsV0FBVyxRQUFRLEtBQUs7QUFDdkMsTUFBSSxJQUFJLE9BQU87QUFDZixNQUFJLFdBQVcsTUFBTTtBQUNuQixRQUFJLE9BQU87QUFDWCxhQUFTLE9BQU87RUFDcEI7QUFFRSxTQUFPLE1BQU0sUUFBUSxRQUFRLEdBQUcsSUFBSSxFQUFFLE9BQU87QUFDM0MsUUFBSSxDQUFDLEVBQUUsV0FBVyxFQUFFLFdBQVc7QUFDN0IsVUFBSSxRQUFRLEVBQUUsUUFBUTtBQUNwQiwwQkFBa0IsYUFBYSxTQUFTLEVBQUUsR0FBRyxRQUFRLEVBQUUsR0FBRyxRQUFRLEtBQUssQ0FBQztNQUNoRjtBQUNNLGVBQVMsRUFBRTtJQUNqQjtFQUNBO0FBRUUsU0FBT0EsVUFBUyxLQUFLLE1BQU0sTUFBTTtBQUMvQixRQUFJLENBQUMsRUFBRSxTQUFTO0FBQ2QsVUFBSUEsVUFBUyxFQUFFLFFBQVE7QUFDckIsMEJBQWtCLGFBQWEsU0FBUyxFQUFFLEdBQUcsUUFBUSxFQUFFLEdBQUcsUUFBUUEsT0FBTSxDQUFDO01BQ2pGO0FBQ00sUUFBRSxPQUFPLFdBQVc7QUFDcEIsTUFBQUEsV0FBVSxFQUFFO0lBQ2xCO0FBQ0ksUUFBSSxFQUFFO0VBQ1Y7QUFDRSxNQUFJQSxVQUFTLEdBQUc7QUFDZCxVQUFNLGVBQWM7RUFDeEI7QUFDRSxNQUFJLE9BQU8sZUFBZTtBQUN4QjtNQUFvQixPQUFPO01BQWU7TUFBWSxDQUFDLGNBQWNBOztJQUFNO0VBQy9FO0FBQ0E7QUFVTyxJQUFNLGdCQUFnQixDQUFDLGFBQWEsUUFBUSxRQUFRO0FBQ3pELFFBQU0sSUFBSSxPQUFPLEtBQUssSUFBSSxHQUFHO0FBQzdCLE1BQUksTUFBTSxRQUFXO0FBQ25CLE1BQUUsT0FBTyxXQUFXO0VBQ3hCO0FBQ0E7QUFXTyxJQUFNLGFBQWEsQ0FBQyxhQUFhLFFBQVEsS0FBSyxVQUFVO0FBQzdELFFBQU0sT0FBTyxPQUFPLEtBQUssSUFBSSxHQUFHLEtBQUs7QUFDckMsUUFBTUYsT0FBTSxZQUFZO0FBQ3hCLFFBQU0sY0FBY0EsS0FBSTtBQUN4QixNQUFJO0FBQ0osTUFBSSxTQUFTLE1BQU07QUFDakIsY0FBVSxJQUFJLFdBQVcsQ0FBQyxLQUFLLENBQUM7RUFDcEMsT0FBUztBQUNMLFlBQVEsTUFBTSxhQUFXO01BQ3ZCLEtBQUs7TUFDTCxLQUFLO01BQ0wsS0FBSztNQUNMLEtBQUs7TUFDTCxLQUFLO0FBQ0gsa0JBQVUsSUFBSSxXQUFXLENBQUMsS0FBSyxDQUFDO0FBQ2hDO01BQ0YsS0FBSztBQUNILGtCQUFVLElBQUk7O1VBQXlDO1FBQUs7QUFDNUQ7TUFDRixLQUFLO0FBQ0gsa0JBQVUsSUFBSTs7VUFBK0I7UUFBSztBQUNsRDtNQUNGO0FBQ0UsWUFBSSxpQkFBaUIsY0FBYztBQUNqQyxvQkFBVSxJQUFJLFlBQVksS0FBSztRQUN6QyxPQUFlO0FBQ0wsZ0JBQU0sSUFBSSxNQUFNLHlCQUF5QjtRQUNuRDtJQUNBO0VBQ0E7QUFDRSxNQUFJLEtBQUssU0FBUyxhQUFhLFNBQVNBLEtBQUksT0FBTyxXQUFXLENBQUMsR0FBRyxNQUFNLFFBQVEsS0FBSyxRQUFRLE1BQU0sTUFBTSxRQUFRLEtBQUssT0FBTyxFQUFFLFVBQVUsYUFBYSxDQUFDO0FBQ3pKO0FBVU8sSUFBTSxhQUFhLENBQUMsUUFBUSxRQUFRO0FBQ3pDLFFBQU0sTUFBTSxPQUFPLEtBQUssSUFBSSxHQUFHO0FBQy9CLFNBQU8sUUFBUSxVQUFhLENBQUMsSUFBSSxVQUFVLElBQUksUUFBUSxXQUFVLEVBQUcsSUFBSSxTQUFTLENBQUMsSUFBSTtBQUN4RjtBQVNPLElBQU0sZ0JBQWdCLENBQUMsV0FBVztBQUl2QyxRQUFNLE1BQU0sQ0FBQTtBQUNaLFNBQU8sS0FBSyxRQUFRLENBQUMsT0FBTyxRQUFRO0FBQ2xDLFFBQUksQ0FBQyxNQUFNLFNBQVM7QUFDbEIsVUFBSSxHQUFHLElBQUksTUFBTSxRQUFRLFdBQVUsRUFBRyxNQUFNLFNBQVMsQ0FBQztJQUM1RDtFQUNBLENBQUc7QUFDRCxTQUFPO0FBQ1Q7QUFVTyxJQUFNLGFBQWEsQ0FBQyxRQUFRLFFBQVE7QUFDekMsUUFBTSxNQUFNLE9BQU8sS0FBSyxJQUFJLEdBQUc7QUFDL0IsU0FBTyxRQUFRLFVBQWEsQ0FBQyxJQUFJO0FBQ25DO0FBMEJPLElBQU0sb0JBQW9CLENBQUFHLFNBQWdCO0VBQWVBLEtBQUksUUFBTzs7RUFBOEIsV0FBUyxDQUFDLE1BQU0sQ0FBQyxFQUFFO0FBQU87QUMzNEI1SCxJQUFNLGNBQU4sY0FBMEIsT0FBTzs7Ozs7RUFLdEMsWUFBYSxRQUFRLGFBQWE7QUFDaEMsVUFBTSxRQUFRLFdBQVc7QUFDekIsU0FBSyxlQUFlO0VBQ3hCO0FBQ0E7QUFRTyxJQUFNLFNBQU4sY0FBcUIsYUFBYTtFQUN2QyxjQUFlO0FBQ2IsVUFBSztBQUtMLFNBQUssaUJBQWlCLENBQUE7QUFJdEIsU0FBSyxnQkFBZ0IsQ0FBQTtFQUN6Qjs7Ozs7OztFQVFFLE9BQU8sS0FBTSxPQUFPO0FBSWxCLFVBQU0sSUFBSSxJQUFJLE9BQU07QUFDcEIsTUFBRSxLQUFLLEtBQUs7QUFDWixXQUFPO0VBQ1g7Ozs7Ozs7Ozs7O0VBWUUsV0FBWSxHQUFHLE1BQU07QUFDbkIsVUFBTSxXQUFXLEdBQUcsSUFBSTtBQUN4QixTQUFLO01BQU87O01BQThCLEtBQUs7SUFBYztBQUM3RCxTQUFLLGlCQUFpQjtFQUMxQjs7OztFQUtFLFFBQVM7QUFDUCxXQUFPLElBQUksT0FBTTtFQUNyQjs7OztFQUtFLFFBQVM7QUFJUCxVQUFNLE1BQU0sSUFBSSxPQUFNO0FBQ3RCLFFBQUksT0FBTyxHQUFHLEtBQUssUUFBTyxFQUFHO01BQUksUUFDL0IsY0FBYzs7UUFBeUMsR0FBRyxNQUFLO1VBQU07SUFDM0UsQ0FBSztBQUNELFdBQU87RUFDWDtFQUVFLElBQUksU0FBVTtBQUNaLFdBQU8sS0FBSyxtQkFBbUIsT0FBTyxLQUFLLFVBQVUsS0FBSyxlQUFlO0VBQzdFOzs7Ozs7O0VBUUUsY0FBZSxhQUFhLFlBQVk7QUFDdEMsVUFBTSxjQUFjLGFBQWEsVUFBVTtBQUMzQyxzQkFBa0IsTUFBTSxhQUFhLElBQUksWUFBWSxNQUFNLFdBQVcsQ0FBQztFQUMzRTs7Ozs7Ozs7Ozs7Ozs7Ozs7RUFrQkUsT0FBUSxPQUFPLFNBQVM7QUFDdEIsUUFBSSxLQUFLLFFBQVEsTUFBTTtBQUNyQixlQUFTLEtBQUssS0FBSyxpQkFBZTtBQUNoQztVQUF1QjtVQUFhO1VBQU07O1VBQTJCO1FBQU87TUFDcEYsQ0FBTztJQUNQLE9BQVc7QUFDcUIsTUFBQyxLQUFLLGVBQWdCLE9BQU8sT0FBTyxHQUFHLEdBQUcsT0FBTztJQUNqRjtFQUNBOzs7Ozs7OztFQVNFLEtBQU0sU0FBUztBQUNiLFFBQUksS0FBSyxRQUFRLE1BQU07QUFDckIsZUFBUyxLQUFLLEtBQUssaUJBQWU7QUFDaEM7VUFBcUI7VUFBYTs7VUFBMEI7UUFBTztNQUMzRSxDQUFPO0lBQ1AsT0FBVztBQUNxQixNQUFDLEtBQUssZUFBZ0IsS0FBSyxHQUFHLE9BQU87SUFDckU7RUFDQTs7Ozs7O0VBT0UsUUFBUyxTQUFTO0FBQ2hCLFNBQUssT0FBTyxHQUFHLE9BQU87RUFDMUI7Ozs7Ozs7RUFRRSxPQUFRLE9BQU9DLFVBQVMsR0FBRztBQUN6QixRQUFJLEtBQUssUUFBUSxNQUFNO0FBQ3JCLGVBQVMsS0FBSyxLQUFLLGlCQUFlO0FBQ2hDLHVCQUFlLGFBQWEsTUFBTSxPQUFPQSxPQUFNO01BQ3ZELENBQU87SUFDUCxPQUFXO0FBQ3FCLE1BQUMsS0FBSyxlQUFnQixPQUFPLE9BQU9BLE9BQU07SUFDMUU7RUFDQTs7Ozs7OztFQVFFLElBQUssT0FBTztBQUNWLFdBQU8sWUFBWSxNQUFNLEtBQUs7RUFDbEM7Ozs7OztFQU9FLFVBQVc7QUFDVCxXQUFPLGdCQUFnQixJQUFJO0VBQy9COzs7Ozs7OztFQVNFLE1BQU8sUUFBUSxHQUFHLE1BQU0sS0FBSyxRQUFRO0FBQ25DLFdBQU8sY0FBYyxNQUFNLE9BQU8sR0FBRztFQUN6Qzs7Ozs7O0VBT0UsU0FBVTtBQUNSLFdBQU8sS0FBSyxJQUFJLE9BQUssYUFBYSxlQUFlLEVBQUUsT0FBTSxJQUFLLENBQUM7RUFDbkU7Ozs7Ozs7Ozs7RUFXRSxJQUFLLEdBQUc7QUFDTixXQUFPO01BQVk7O01BQTBCO0lBQUM7RUFDbEQ7Ozs7OztFQU9FLFFBQVMsR0FBRztBQUNWLG9CQUFnQixNQUFNLENBQUM7RUFDM0I7Ozs7RUFLRSxDQUFDLE9BQU8sUUFBUSxJQUFLO0FBQ25CLFdBQU8sdUJBQXVCLElBQUk7RUFDdEM7Ozs7RUFLRSxPQUFRLFNBQVM7QUFDZixZQUFRLGFBQWEsV0FBVztFQUNwQztBQUNBO0FBUU8sSUFBTSxhQUFhLGNBQVksSUFBSSxPQUFNO0FDelB6QyxJQUFNLFlBQU4sY0FBd0IsT0FBTzs7Ozs7O0VBTXBDLFlBQWEsTUFBTSxhQUFhLE1BQU07QUFDcEMsVUFBTSxNQUFNLFdBQVc7QUFDdkIsU0FBSyxjQUFjO0VBQ3ZCO0FBQ0E7QUFTTyxJQUFNLE9BQU4sY0FBbUIsYUFBYTs7Ozs7RUFLckMsWUFBYSxTQUFTO0FBQ3BCLFVBQUs7QUFLTCxTQUFLLGlCQUFpQjtBQUV0QixRQUFJLFlBQVksUUFBVztBQUN6QixXQUFLLGlCQUFpQixvQkFBSSxJQUFHO0lBQ25DLE9BQVc7QUFDTCxXQUFLLGlCQUFpQixJQUFJLElBQUksT0FBTztJQUMzQztFQUNBOzs7Ozs7Ozs7OztFQVlFLFdBQVksR0FBRyxNQUFNO0FBQ25CLFVBQU0sV0FBVyxHQUFHLElBQUk7QUFDUyxJQUFDLEtBQUssZUFBZ0IsUUFBUSxDQUFDLE9BQU8sUUFBUTtBQUM3RSxXQUFLLElBQUksS0FBSyxLQUFLO0lBQ3pCLENBQUs7QUFDRCxTQUFLLGlCQUFpQjtFQUMxQjs7OztFQUtFLFFBQVM7QUFDUCxXQUFPLElBQUksS0FBSTtFQUNuQjs7OztFQUtFLFFBQVM7QUFJUCxVQUFNRCxPQUFNLElBQUksS0FBSTtBQUNwQixTQUFLLFFBQVEsQ0FBQyxPQUFPLFFBQVE7QUFDM0IsTUFBQUEsS0FBSSxJQUFJLEtBQUssaUJBQWlCOztRQUE0QyxNQUFNLE1BQUs7VUFBTSxLQUFLO0lBQ3RHLENBQUs7QUFDRCxXQUFPQTtFQUNYOzs7Ozs7O0VBUUUsY0FBZSxhQUFhLFlBQVk7QUFDdEMsc0JBQWtCLE1BQU0sYUFBYSxJQUFJLFVBQVUsTUFBTSxhQUFhLFVBQVUsQ0FBQztFQUNyRjs7Ozs7O0VBT0UsU0FBVTtBQUlSLFVBQU1BLE9BQU0sQ0FBQTtBQUNaLFNBQUssS0FBSyxRQUFRLENBQUMsTUFBTSxRQUFRO0FBQy9CLFVBQUksQ0FBQyxLQUFLLFNBQVM7QUFDakIsY0FBTSxJQUFJLEtBQUssUUFBUSxXQUFVLEVBQUcsS0FBSyxTQUFTLENBQUM7QUFDbkQsUUFBQUEsS0FBSSxHQUFHLElBQUksYUFBYSxlQUFlLEVBQUUsT0FBTSxJQUFLO01BQzVEO0lBQ0EsQ0FBSztBQUNELFdBQU9BO0VBQ1g7Ozs7OztFQU9FLElBQUksT0FBUTtBQUNWLFdBQU8sQ0FBQyxHQUFHLGtCQUFrQixLQUFLLElBQUksQ0FBQyxFQUFFO0VBQzdDOzs7Ozs7RUFPRSxPQUFRO0FBQ04sV0FBZ0I7TUFBWSxrQkFBa0IsS0FBSyxJQUFJOztNQUF5QixPQUFLLEVBQUUsQ0FBQztJQUFDO0VBQzdGOzs7Ozs7RUFPRSxTQUFVO0FBQ1IsV0FBZ0I7TUFBWSxrQkFBa0IsS0FBSyxJQUFJOztNQUF5QixPQUFLLEVBQUUsQ0FBQyxFQUFFLFFBQVEsV0FBVSxFQUFHLEVBQUUsQ0FBQyxFQUFFLFNBQVMsQ0FBQztJQUFDO0VBQ25JOzs7Ozs7RUFPRSxVQUFXO0FBQ1QsV0FBZ0I7TUFBWSxrQkFBa0IsS0FBSyxJQUFJOztNQUF5QixPQUFLLENBQUMsRUFBRSxDQUFDLEdBQUcsRUFBRSxDQUFDLEVBQUUsUUFBUSxXQUFVLEVBQUcsRUFBRSxDQUFDLEVBQUUsU0FBUyxDQUFDLENBQUM7SUFBQztFQUMzSTs7Ozs7O0VBT0UsUUFBUyxHQUFHO0FBQ1YsU0FBSyxLQUFLLFFBQVEsQ0FBQyxNQUFNLFFBQVE7QUFDL0IsVUFBSSxDQUFDLEtBQUssU0FBUztBQUNqQixVQUFFLEtBQUssUUFBUSxXQUFVLEVBQUcsS0FBSyxTQUFTLENBQUMsR0FBRyxLQUFLLElBQUk7TUFDL0Q7SUFDQSxDQUFLO0VBQ0w7Ozs7OztFQU9FLENBQUMsT0FBTyxRQUFRLElBQUs7QUFDbkIsV0FBTyxLQUFLLFFBQU87RUFDdkI7Ozs7OztFQU9FLE9BQVEsS0FBSztBQUNYLFFBQUksS0FBSyxRQUFRLE1BQU07QUFDckIsZUFBUyxLQUFLLEtBQUssaUJBQWU7QUFDaEMsc0JBQWMsYUFBYSxNQUFNLEdBQUc7TUFDNUMsQ0FBTztJQUNQLE9BQVc7QUFDMkIsTUFBQyxLQUFLLGVBQWdCLE9BQU8sR0FBRztJQUN0RTtFQUNBOzs7Ozs7Ozs7RUFVRSxJQUFLLEtBQUssT0FBTztBQUNmLFFBQUksS0FBSyxRQUFRLE1BQU07QUFDckIsZUFBUyxLQUFLLEtBQUssaUJBQWU7QUFDaEM7VUFBVztVQUFhO1VBQU07O1VBQXlCO1FBQUs7TUFDcEUsQ0FBTztJQUNQLE9BQVc7QUFDMkIsTUFBQyxLQUFLLGVBQWdCLElBQUksS0FBSyxLQUFLO0lBQzFFO0FBQ0ksV0FBTztFQUNYOzs7Ozs7O0VBUUUsSUFBSyxLQUFLO0FBQ1I7O01BQTJCLFdBQVcsTUFBTSxHQUFHOztFQUNuRDs7Ozs7OztFQVFFLElBQUssS0FBSztBQUNSLFdBQU8sV0FBVyxNQUFNLEdBQUc7RUFDL0I7Ozs7RUFLRSxRQUFTO0FBQ1AsUUFBSSxLQUFLLFFBQVEsTUFBTTtBQUNyQixlQUFTLEtBQUssS0FBSyxpQkFBZTtBQUNoQyxhQUFLLFFBQVEsU0FBVSxRQUFRLEtBQUtBLE1BQUs7QUFDdkMsd0JBQWMsYUFBYUEsTUFBSyxHQUFHO1FBQzdDLENBQVM7TUFDVCxDQUFPO0lBQ1AsT0FBVztBQUMyQixNQUFDLEtBQUssZUFBZ0IsTUFBSztJQUNqRTtFQUNBOzs7O0VBS0UsT0FBUSxTQUFTO0FBQ2YsWUFBUSxhQUFhLFNBQVM7RUFDbEM7QUFDQTtBQVFPLElBQU0sV0FBVyxjQUFZLElBQUksS0FBSTtBQ3pPNUMsSUFBTSxhQUFhLENBQUMsR0FBRyxNQUFNLE1BQU0sS0FBTSxPQUFPLE1BQU0sWUFBWSxPQUFPLE1BQU0sWUFBWSxLQUFLLEtBQVksVUFBVSxHQUFHLENBQUM7QUFFbkgsSUFBTSx1QkFBTixNQUEyQjs7Ozs7OztFQU9oQyxZQUFhLE1BQU0sT0FBTyxPQUFPLG1CQUFtQjtBQUNsRCxTQUFLLE9BQU87QUFDWixTQUFLLFFBQVE7QUFDYixTQUFLLFFBQVE7QUFDYixTQUFLLG9CQUFvQjtFQUM3Qjs7OztFQUtFLFVBQVc7QUFDVCxRQUFJLEtBQUssVUFBVSxNQUFNO0FBQ3ZCLE1BQU0sZUFBYztJQUMxQjtBQUNJLFlBQVEsS0FBSyxNQUFNLFFBQVEsYUFBVztNQUNwQyxLQUFLO0FBQ0gsWUFBSSxDQUFDLEtBQUssTUFBTSxTQUFTO0FBQ3ZCO1lBQXdCLEtBQUs7O1lBQWlELEtBQUssTUFBTTtVQUFPO1FBQzFHO0FBQ1E7TUFDRjtBQUNFLFlBQUksQ0FBQyxLQUFLLE1BQU0sU0FBUztBQUN2QixlQUFLLFNBQVMsS0FBSyxNQUFNO1FBQ25DO0FBQ1E7SUFDUjtBQUNJLFNBQUssT0FBTyxLQUFLO0FBQ2pCLFNBQUssUUFBUSxLQUFLLE1BQU07RUFDNUI7QUFDQTtBQVdBLElBQU0sbUJBQW1CLENBQUMsYUFBYSxLQUFLRSxXQUFVO0FBQ3BELFNBQU8sSUFBSSxVQUFVLFFBQVFBLFNBQVEsR0FBRztBQUN0QyxZQUFRLElBQUksTUFBTSxRQUFRLGFBQVc7TUFDbkMsS0FBSztBQUNILFlBQUksQ0FBQyxJQUFJLE1BQU0sU0FBUztBQUN0QjtZQUF3QixJQUFJOztZQUFpRCxJQUFJLE1BQU07VUFBTztRQUN4RztBQUNRO01BQ0Y7QUFDRSxZQUFJLENBQUMsSUFBSSxNQUFNLFNBQVM7QUFDdEIsY0FBSUEsU0FBUSxJQUFJLE1BQU0sUUFBUTtBQUU1Qiw4QkFBa0IsYUFBYSxTQUFTLElBQUksTUFBTSxHQUFHLFFBQVEsSUFBSSxNQUFNLEdBQUcsUUFBUUEsTUFBSyxDQUFDO1VBQ3BHO0FBQ1UsY0FBSSxTQUFTLElBQUksTUFBTTtBQUN2QixVQUFBQSxVQUFTLElBQUksTUFBTTtRQUM3QjtBQUNRO0lBQ1I7QUFDSSxRQUFJLE9BQU8sSUFBSTtBQUNmLFFBQUksUUFBUSxJQUFJLE1BQU07RUFFMUI7QUFDRSxTQUFPO0FBQ1Q7QUFXQSxJQUFNLGVBQWUsQ0FBQyxhQUFhLFFBQVEsVUFBVTtBQUNuRCxRQUFNLG9CQUFvQixvQkFBSSxJQUFHO0FBQ2pDLFFBQU0sU0FBUyxXQUFXLFFBQVEsS0FBSztBQUN2QyxNQUFJLFFBQVE7QUFDVixVQUFNLE1BQU0sSUFBSSxxQkFBcUIsT0FBTyxFQUFFLE1BQU0sT0FBTyxHQUFHLE9BQU8sT0FBTyxpQkFBaUI7QUFDN0YsV0FBTyxpQkFBaUIsYUFBYSxLQUFLLFFBQVEsT0FBTyxLQUFLO0VBQ2xFLE9BQVM7QUFDTCxVQUFNLE1BQU0sSUFBSSxxQkFBcUIsTUFBTSxPQUFPLFFBQVEsR0FBRyxpQkFBaUI7QUFDOUUsV0FBTyxpQkFBaUIsYUFBYSxLQUFLLEtBQUs7RUFDbkQ7QUFDQTtBQWFBLElBQU0sMEJBQTBCLENBQUMsYUFBYSxRQUFRLFNBQVMsc0JBQXNCO0FBRW5GLFNBQ0UsUUFBUSxVQUFVLFNBQ2hCLFFBQVEsTUFBTSxZQUFZLFFBQ3hCLFFBQVEsTUFBTSxRQUFRLGdCQUFnQixpQkFDdEM7SUFBVyxrQkFBa0I7O01BQWtDLFFBQVEsTUFBTSxRQUFTO0lBQUc7O0lBQWlDLFFBQVEsTUFBTSxRQUFTO0VBQUssSUFHMUo7QUFDQSxRQUFJLENBQUMsUUFBUSxNQUFNLFNBQVM7QUFDMUIsd0JBQWtCOztRQUFxQyxRQUFRLE1BQU0sUUFBUztNQUFHO0lBQ3ZGO0FBQ0ksWUFBUSxRQUFPO0VBQ25CO0FBQ0UsUUFBTUMsT0FBTSxZQUFZO0FBQ3hCLFFBQU0sY0FBY0EsS0FBSTtBQUN4QixvQkFBa0IsUUFBUSxDQUFDLEtBQUssUUFBUTtBQUN0QyxVQUFNLE9BQU8sUUFBUTtBQUNyQixVQUFNLFFBQVEsUUFBUTtBQUN0QixVQUFNLGFBQWEsSUFBSSxLQUFLLFNBQVMsYUFBYSxTQUFTQSxLQUFJLE9BQU8sV0FBVyxDQUFDLEdBQUcsTUFBTSxRQUFRLEtBQUssUUFBUSxPQUFPLFNBQVMsTUFBTSxJQUFJLFFBQVEsTUFBTSxJQUFJLGNBQWMsS0FBSyxHQUFHLENBQUM7QUFDbkwsZUFBVyxVQUFVLGFBQWEsQ0FBQztBQUNuQyxZQUFRLFFBQVE7QUFDaEIsWUFBUSxRQUFPO0VBQ25CLENBQUc7QUFDSDtBQVNBLElBQU0sMEJBQTBCLENBQUMsbUJBQW1CLFdBQVc7QUFDN0QsUUFBTSxFQUFFLEtBQUssTUFBSyxJQUFLO0FBQ3ZCLE1BQUksVUFBVSxNQUFNO0FBQ2xCLHNCQUFrQixPQUFPLEdBQUc7RUFDaEMsT0FBUztBQUNMLHNCQUFrQixJQUFJLEtBQUssS0FBSztFQUNwQztBQUNBO0FBU0EsSUFBTSwyQkFBMkIsQ0FBQyxTQUFTLGVBQWU7QUFFeEQsU0FBTyxNQUFNO0FBQ1gsUUFBSSxRQUFRLFVBQVUsTUFBTTtBQUMxQjtJQUNOLFdBQWUsUUFBUSxNQUFNLFdBQVksUUFBUSxNQUFNLFFBQVEsZ0JBQWdCLGlCQUFpQjtNQUFXOztRQUEwQyxRQUFRLE1BQU0sUUFBVTtNQUFHLEtBQUs7O01BQW9DLFFBQVEsTUFBTSxRQUFTO0lBQUs7QUFBSTtTQUU5TztBQUNMO0lBQ047QUFDSSxZQUFRLFFBQU87RUFDbkI7QUFDQTtBQVlBLElBQU0sbUJBQW1CLENBQUMsYUFBYSxRQUFRLFNBQVMsZUFBZTtBQUNyRSxRQUFNQSxPQUFNLFlBQVk7QUFDeEIsUUFBTSxjQUFjQSxLQUFJO0FBQ3hCLFFBQU0sb0JBQW9CLG9CQUFJLElBQUc7QUFFakMsYUFBVyxPQUFPLFlBQVk7QUFDNUIsVUFBTSxNQUFNLFdBQVcsR0FBRztBQUMxQixVQUFNLGFBQWEsUUFBUSxrQkFBa0IsSUFBSSxHQUFHLEtBQUs7QUFDekQsUUFBSSxDQUFDLFdBQVcsWUFBWSxHQUFHLEdBQUc7QUFFaEMsd0JBQWtCLElBQUksS0FBSyxVQUFVO0FBQ3JDLFlBQU0sRUFBRSxNQUFNLE1BQUssSUFBSztBQUN4QixjQUFRLFFBQVEsSUFBSSxLQUFLLFNBQVMsYUFBYSxTQUFTQSxLQUFJLE9BQU8sV0FBVyxDQUFDLEdBQUcsTUFBTSxRQUFRLEtBQUssUUFBUSxPQUFPLFNBQVMsTUFBTSxJQUFJLFFBQVEsTUFBTSxJQUFJLGNBQWMsS0FBSyxHQUFHLENBQUM7QUFDaEwsY0FBUSxNQUFNLFVBQVUsYUFBYSxDQUFDO0FBQ3RDLGNBQVEsUUFBTztJQUNyQjtFQUNBO0FBQ0UsU0FBTztBQUNUO0FBWUEsSUFBTSxhQUFhLENBQUMsYUFBYSxRQUFRLFNBQVNDLE9BQU0sZUFBZTtBQUNyRSxVQUFRLGtCQUFrQixRQUFRLENBQUMsTUFBTSxRQUFRO0FBQy9DLFFBQUksV0FBVyxHQUFHLE1BQU0sUUFBVztBQUNqQyxpQkFBVyxHQUFHLElBQUk7SUFDeEI7RUFDQSxDQUFHO0FBQ0QsUUFBTUQsT0FBTSxZQUFZO0FBQ3hCLFFBQU0sY0FBY0EsS0FBSTtBQUN4QiwyQkFBeUIsU0FBUyxVQUFVO0FBQzVDLFFBQU0sb0JBQW9CLGlCQUFpQixhQUFhLFFBQVEsU0FBUyxVQUFVO0FBRW5GLFFBQU0sVUFBVUMsTUFBSyxnQkFBZ0IsU0FBUyxJQUFJOztJQUFxQ0E7RUFBSSxJQUFNQSxpQkFBZ0IsZUFBZSxJQUFJLFlBQVlBLEtBQUksSUFBSSxJQUFJLGFBQWFBLEtBQUk7QUFDN0ssTUFBSSxFQUFFLE1BQU0sT0FBTyxNQUFLLElBQUs7QUFDN0IsTUFBSSxPQUFPLGVBQWU7QUFDeEIsd0JBQW9CLE9BQU8sZUFBZSxRQUFRLE9BQU8sUUFBUSxVQUFTLENBQUU7RUFDaEY7QUFDRSxVQUFRLElBQUksS0FBSyxTQUFTLGFBQWEsU0FBU0QsS0FBSSxPQUFPLFdBQVcsQ0FBQyxHQUFHLE1BQU0sUUFBUSxLQUFLLFFBQVEsT0FBTyxTQUFTLE1BQU0sSUFBSSxRQUFRLE1BQU0sT0FBTztBQUNwSixRQUFNLFVBQVUsYUFBYSxDQUFDO0FBQzlCLFVBQVEsUUFBUTtBQUNoQixVQUFRLFFBQVE7QUFDaEIsVUFBUSxRQUFPO0FBQ2YsMEJBQXdCLGFBQWEsUUFBUSxTQUFTLGlCQUFpQjtBQUN6RTtBQVlBLElBQU0sYUFBYSxDQUFDLGFBQWEsUUFBUSxTQUFTRixTQUFRLGVBQWU7QUFDdkUsUUFBTUUsT0FBTSxZQUFZO0FBQ3hCLFFBQU0sY0FBY0EsS0FBSTtBQUN4QiwyQkFBeUIsU0FBUyxVQUFVO0FBQzVDLFFBQU0sb0JBQW9CLGlCQUFpQixhQUFhLFFBQVEsU0FBUyxVQUFVO0FBS25GO0FBQWUsV0FDYixRQUFRLFVBQVUsU0FDakJGLFVBQVMsS0FFTixrQkFBa0IsT0FBTyxNQUN4QixRQUFRLE1BQU0sV0FBVyxRQUFRLE1BQU0sUUFBUSxnQkFBZ0IsaUJBR3BFO0FBQ0EsVUFBSSxDQUFDLFFBQVEsTUFBTSxTQUFTO0FBQzFCLGdCQUFRLFFBQVEsTUFBTSxRQUFRLGFBQVc7VUFDdkMsS0FBSyxlQUFlO0FBQ2xCLGtCQUFNLEVBQUUsS0FBSyxNQUFLOztjQUFtQyxRQUFRLE1BQU07O0FBQ25FLGtCQUFNLE9BQU8sV0FBVyxHQUFHO0FBQzNCLGdCQUFJLFNBQVMsUUFBVztBQUN0QixrQkFBSSxXQUFXLE1BQU0sS0FBSyxHQUFHO0FBQzNCLGtDQUFrQixPQUFPLEdBQUc7Y0FDMUMsT0FBbUI7QUFDTCxvQkFBSUEsWUFBVyxHQUFHO0FBR2hCLHdCQUFNO2dCQUN0QjtBQUNjLGtDQUFrQixJQUFJLEtBQUssS0FBSztjQUM5QztBQUNZLHNCQUFRLE1BQU0sT0FBTyxXQUFXO1lBQzVDLE9BQWlCO0FBQ0wsc0JBQVEsa0JBQWtCLElBQUksS0FBSyxLQUFLO1lBQ3BEO0FBQ1U7VUFDVjtVQUNRO0FBQ0UsZ0JBQUlBLFVBQVMsUUFBUSxNQUFNLFFBQVE7QUFDakMsZ0NBQWtCLGFBQWEsU0FBUyxRQUFRLE1BQU0sR0FBRyxRQUFRLFFBQVEsTUFBTSxHQUFHLFFBQVFBLE9BQU0sQ0FBQztZQUM3RztBQUNVLFlBQUFBLFdBQVUsUUFBUSxNQUFNO0FBQ3hCO1FBQ1Y7TUFDQTtBQUNJLGNBQVEsUUFBTztJQUNuQjtBQUlFLE1BQUlBLFVBQVMsR0FBRztBQUNkLFFBQUksV0FBVztBQUNmLFdBQU9BLFVBQVMsR0FBR0EsV0FBVTtBQUMzQixrQkFBWTtJQUNsQjtBQUNJLFlBQVEsUUFBUSxJQUFJLEtBQUssU0FBUyxhQUFhLFNBQVNFLEtBQUksT0FBTyxXQUFXLENBQUMsR0FBRyxRQUFRLE1BQU0sUUFBUSxRQUFRLFFBQVEsS0FBSyxRQUFRLFFBQVEsT0FBTyxRQUFRLFNBQVMsUUFBUSxNQUFNLElBQUksUUFBUSxNQUFNLElBQUksY0FBYyxRQUFRLENBQUM7QUFDaE8sWUFBUSxNQUFNLFVBQVUsYUFBYSxDQUFDO0FBQ3RDLFlBQVEsUUFBTztFQUNuQjtBQUNFLDBCQUF3QixhQUFhLFFBQVEsU0FBUyxpQkFBaUI7QUFDekU7QUFlQSxJQUFNLHVCQUF1QixDQUFDLGFBQWEsT0FBTyxNQUFNLGlCQUFpQixtQkFBbUI7QUFJMUYsTUFBSSxNQUFNO0FBSVYsUUFBTSxhQUFpQixPQUFNO0FBQzdCLFNBQU8sUUFBUSxDQUFDLElBQUksYUFBYSxJQUFJLFVBQVU7QUFDN0MsUUFBSSxDQUFDLElBQUksV0FBVyxJQUFJLFFBQVEsZ0JBQWdCLGVBQWU7QUFDN0QsWUFBTTs7UUFBbUMsSUFBSTs7QUFDN0MsaUJBQVcsSUFBSSxHQUFHLEtBQUssRUFBRTtJQUMvQjtBQUNJLFVBQU0sSUFBSTtFQUNkO0FBQ0UsTUFBSSxXQUFXO0FBQ2YsTUFBSSxjQUFjO0FBQ2xCLFNBQU8sVUFBVSxLQUFLO0FBQ3BCLFFBQUksU0FBUyxPQUFPO0FBQ2xCLG9CQUFjO0lBQ3BCO0FBQ0ksUUFBSSxDQUFDLE1BQU0sU0FBUztBQUNsQixZQUFNLFVBQVUsTUFBTTtBQUN0QixjQUFRLFFBQVEsYUFBVztRQUN6QixLQUFLLGVBQWU7QUFDbEIsZ0JBQU0sRUFBRSxLQUFLLE1BQUs7O1lBQW1DOztBQUNyRCxnQkFBTSxpQkFBaUIsZ0JBQWdCLElBQUksR0FBRyxLQUFLO0FBQ25ELGNBQUksV0FBVyxJQUFJLEdBQUcsTUFBTSxXQUFXLG1CQUFtQixPQUFPO0FBRS9ELGtCQUFNLE9BQU8sV0FBVztBQUN4QjtBQUNBLGdCQUFJLENBQUMsZ0JBQWdCLGVBQWUsSUFBSSxHQUFHLEtBQUssVUFBVSxTQUFTLG1CQUFtQixPQUFPO0FBQzNGLGtCQUFJLG1CQUFtQixNQUFNO0FBQzNCLCtCQUFlLE9BQU8sR0FBRztjQUN6QyxPQUFxQjtBQUNMLCtCQUFlLElBQUksS0FBSyxjQUFjO2NBQ3REO1lBQ0E7VUFDQTtBQUNVLGNBQUksQ0FBQyxlQUFlLENBQUMsTUFBTSxTQUFTO0FBQ2xDO2NBQXdCOztjQUE4QztZQUFPO1VBQ3pGO0FBQ1U7UUFDVjtNQUNBO0lBQ0E7QUFDSTtJQUE2QixNQUFNO0VBQ3ZDO0FBQ0UsU0FBTztBQUNUO0FBTUEsSUFBTSxrQ0FBa0MsQ0FBQyxhQUFhLFNBQVM7QUFFN0QsU0FBTyxRQUFRLEtBQUssVUFBVSxLQUFLLE1BQU0sV0FBVyxDQUFDLEtBQUssTUFBTSxZQUFZO0FBQzFFLFdBQU8sS0FBSztFQUNoQjtBQUNFLFFBQU0sUUFBUSxvQkFBSSxJQUFHO0FBRXJCLFNBQU8sU0FBUyxLQUFLLFdBQVcsQ0FBQyxLQUFLLFlBQVk7QUFDaEQsUUFBSSxDQUFDLEtBQUssV0FBVyxLQUFLLFFBQVEsZ0JBQWdCLGVBQWU7QUFDL0QsWUFBTTs7UUFBb0MsS0FBSyxRQUFTOztBQUN4RCxVQUFJLE1BQU0sSUFBSSxHQUFHLEdBQUc7QUFDbEIsYUFBSyxPQUFPLFdBQVc7TUFDL0IsT0FBYTtBQUNMLGNBQU0sSUFBSSxHQUFHO01BQ3JCO0lBQ0E7QUFDSSxXQUFPLEtBQUs7RUFDaEI7QUFDQTtBQWNZLElBQUMseUJBQXlCLENBQUFFLFVBQVE7QUFDNUMsTUFBSSxNQUFNO0FBQ1Y7O0lBQTZCQSxNQUFLO0lBQU0saUJBQWU7QUFDckQsVUFBSTs7UUFBNkJBLE1BQUs7O0FBQ3RDLFVBQUksTUFBTUEsTUFBSztBQUNmLFVBQUksa0JBQXNCLE9BQU07QUFDaEMsWUFBTSxvQkFBd0IsS0FBSyxlQUFlO0FBQ2xELGFBQU8sS0FBSztBQUNWLFlBQUksSUFBSSxZQUFZLE9BQU87QUFDekIsa0JBQVEsSUFBSSxRQUFRLGFBQVc7WUFDN0IsS0FBSztBQUNIO2dCQUF3Qjs7Z0JBQWlELElBQUk7Y0FBTztBQUNwRjtZQUNGO0FBQ0UscUJBQU8scUJBQXFCLGFBQWEsT0FBTyxLQUFLLGlCQUFpQixpQkFBaUI7QUFDdkYsZ0NBQXNCLEtBQUssaUJBQWlCO0FBQzVDLHNCQUFRO0FBQ1I7VUFDWjtRQUNBO0FBQ00sY0FBTSxJQUFJO01BQ2hCO0lBQ0E7RUFBRztBQUNELFNBQU87QUFDVDtBQVFPLElBQU0sK0JBQStCLGlCQUFlO0FBSXpELFFBQU0sa0JBQWtCLG9CQUFJLElBQUc7QUFFL0IsUUFBTUYsT0FBTSxZQUFZO0FBQ3hCLGFBQVcsQ0FBQyxRQUFRLFVBQVUsS0FBSyxZQUFZLFdBQVcsUUFBTyxHQUFJO0FBQ25FLFVBQU0sUUFBUSxZQUFZLFlBQVksSUFBSSxNQUFNLEtBQUs7QUFDckQsUUFBSSxlQUFlLE9BQU87QUFDeEI7SUFDTjtBQUNJO01BQWU7O01BQTRDQSxLQUFJLE1BQU0sUUFBUSxJQUFJLE1BQU07TUFBSTtNQUFPO01BQVksVUFBUTtBQUNwSCxZQUNFLENBQUMsS0FBSztRQUFnQyxLQUFNLFFBQVEsZ0JBQWdCLGlCQUFpQixLQUFLLGdCQUFnQixJQUMxRztBQUNBLDBCQUFnQjs7WUFBd0IsS0FBTTtVQUFNO1FBQzVEO01BQ0E7SUFBSztFQUNMO0FBRUUsV0FBU0EsTUFBSyxDQUFDLE1BQU07QUFDbkIsMEJBQXNCLGFBQWEsWUFBWSxXQUFXLFVBQVE7QUFDaEUsVUFBSSxnQkFBZ0IsTUFBTTtNQUF3QixLQUFLLE9BQVEsa0JBQW1CLGdCQUFnQjs7UUFBMEIsS0FBSztNQUFNLEdBQUk7QUFDekk7TUFDUjtBQUNNLFlBQU07O1FBQStCLEtBQUs7O0FBQzFDLFVBQUksS0FBSyxRQUFRLGdCQUFnQixlQUFlO0FBQzlDLHdCQUFnQixJQUFJLE1BQU07TUFDbEMsT0FBYTtBQUlMLHdDQUFnQyxHQUFHLElBQUk7TUFDL0M7SUFDQSxDQUFLO0FBR0QsZUFBVyxTQUFTLGlCQUFpQjtBQUNuQyw2QkFBdUIsS0FBSztJQUNsQztFQUNBLENBQUc7QUFDSDtBQVdBLElBQU0sYUFBYSxDQUFDLGFBQWEsU0FBU0YsWUFBVztBQUNuRCxRQUFNLGNBQWNBO0FBQ3BCLFFBQU0sYUFBaUIsS0FBSyxRQUFRLGlCQUFpQjtBQUNyRCxRQUFNLFFBQVEsUUFBUTtBQUN0QixTQUFPQSxVQUFTLEtBQUssUUFBUSxVQUFVLE1BQU07QUFDM0MsUUFBSSxRQUFRLE1BQU0sWUFBWSxPQUFPO0FBQ25DLGNBQVEsUUFBUSxNQUFNLFFBQVEsYUFBVztRQUN2QyxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7QUFDSCxjQUFJQSxVQUFTLFFBQVEsTUFBTSxRQUFRO0FBQ2pDLDhCQUFrQixhQUFhLFNBQVMsUUFBUSxNQUFNLEdBQUcsUUFBUSxRQUFRLE1BQU0sR0FBRyxRQUFRQSxPQUFNLENBQUM7VUFDN0c7QUFDVSxVQUFBQSxXQUFVLFFBQVEsTUFBTTtBQUN4QixrQkFBUSxNQUFNLE9BQU8sV0FBVztBQUNoQztNQUNWO0lBQ0E7QUFDSSxZQUFRLFFBQU87RUFDbkI7QUFDRSxNQUFJLE9BQU87QUFDVCx5QkFBcUIsYUFBYSxPQUFPLFFBQVEsT0FBTyxZQUFZLFFBQVEsaUJBQWlCO0VBQ2pHO0FBQ0UsUUFBTTs7O0tBQWdFLFFBQVEsUUFBUSxRQUFRLE9BQU87O0FBQ3JHLE1BQUksT0FBTyxlQUFlO0FBQ3hCLHdCQUFvQixPQUFPLGVBQWUsUUFBUSxPQUFPLENBQUMsY0FBY0EsT0FBTTtFQUNsRjtBQUNFLFNBQU87QUFDVDtBQWlDTyxJQUFNLGFBQU4sY0FBeUIsT0FBTzs7Ozs7O0VBTXJDLFlBQWEsT0FBTyxhQUFhLE1BQU07QUFDckMsVUFBTSxPQUFPLFdBQVc7QUFNeEIsU0FBSyxtQkFBbUI7QUFLeEIsU0FBSyxjQUFjLG9CQUFJLElBQUc7QUFDMUIsU0FBSyxRQUFRLENBQUMsUUFBUTtBQUNwQixVQUFJLFFBQVEsTUFBTTtBQUNoQixhQUFLLG1CQUFtQjtNQUNoQyxPQUFhO0FBQ0wsYUFBSyxZQUFZLElBQUksR0FBRztNQUNoQztJQUNBLENBQUs7RUFDTDs7OztFQUtFLElBQUksVUFBVztBQUNiLFFBQUksS0FBSyxhQUFhLE1BQU07QUFJMUIsWUFBTSxVQUFVO1FBQ2QsTUFBTSxLQUFLO1FBQ1gsT0FBTyxLQUFLO1FBQ1osT0FBTyxvQkFBSSxJQUFHO1FBQ2QsU0FBUyxvQkFBSSxJQUFHO01BQ3hCO0FBQ00sV0FBSyxXQUFXO0lBQ3RCO0FBQ0k7O01BQTJCLEtBQUs7O0VBQ3BDOzs7Ozs7Ozs7RUFVRSxJQUFJLFFBQVM7QUFDWCxRQUFJLEtBQUssV0FBVyxNQUFNO0FBQ3hCLFlBQU07O1FBQXdCLEtBQUssT0FBTzs7QUFJMUMsWUFBTSxRQUFRLENBQUE7QUFDZCxlQUFTLEdBQUcsaUJBQWU7QUFDekIsY0FBTSxvQkFBb0Isb0JBQUksSUFBRztBQUNqQyxjQUFNLGdCQUFnQixvQkFBSSxJQUFHO0FBQzdCLFlBQUksT0FBTyxLQUFLLE9BQU87QUFJdkIsWUFBSSxTQUFTO0FBSWIsY0FBTSxhQUFhLENBQUE7QUFJbkIsWUFBSSxTQUFTO0FBQ2IsWUFBSSxTQUFTO0FBQ2IsWUFBSSxZQUFZO0FBQ2hCLGNBQU0sUUFBUSxNQUFNO0FBQ2xCLGNBQUksV0FBVyxNQUFNO0FBSW5CLGdCQUFJLEtBQUs7QUFDVCxvQkFBUSxRQUFNO2NBQ1osS0FBSztBQUNILG9CQUFJLFlBQVksR0FBRztBQUNqQix1QkFBSyxFQUFFLFFBQVEsVUFBUztnQkFDMUM7QUFDZ0IsNEJBQVk7QUFDWjtjQUNGLEtBQUs7QUFDSCxvQkFBSSxPQUFPLFdBQVcsWUFBWSxPQUFPLFNBQVMsR0FBRztBQUNuRCx1QkFBSyxFQUFFLE9BQU07QUFDYixzQkFBSSxrQkFBa0IsT0FBTyxHQUFHO0FBQzlCLHVCQUFHLGFBQWEsQ0FBQTtBQUNoQixzQ0FBa0IsUUFBUSxDQUFDLE9BQU8sUUFBUTtBQUN4QywwQkFBSSxVQUFVLE1BQU07QUFDbEIsMkJBQUcsV0FBVyxHQUFHLElBQUk7c0JBQzdDO29CQUNBLENBQXFCO2tCQUNyQjtnQkFDQTtBQUNnQix5QkFBUztBQUNUO2NBQ0YsS0FBSztBQUNILG9CQUFJLFNBQVMsR0FBRztBQUNkLHVCQUFLLEVBQUUsT0FBTTtBQUNiLHNCQUFJLENBQVEsUUFBUSxVQUFVLEdBQUc7QUFDL0IsdUJBQUcsYUFBb0IsT0FBTyxDQUFBLEdBQUksVUFBVTtrQkFDaEU7Z0JBQ0E7QUFDZ0IseUJBQVM7QUFDVDtZQUNoQjtBQUNZLGdCQUFJO0FBQUksb0JBQU0sS0FBSyxFQUFFO0FBQ3JCLHFCQUFTO1VBQ3JCO1FBQ0E7QUFDUSxlQUFPLFNBQVMsTUFBTTtBQUNwQixrQkFBUSxLQUFLLFFBQVEsYUFBVztZQUM5QixLQUFLO1lBQ0wsS0FBSztBQUNILGtCQUFJLEtBQUssS0FBSyxJQUFJLEdBQUc7QUFDbkIsb0JBQUksQ0FBQyxLQUFLLFFBQVEsSUFBSSxHQUFHO0FBQ3ZCLHdCQUFLO0FBQ0wsMkJBQVM7QUFDVCwyQkFBUyxLQUFLLFFBQVEsV0FBVSxFQUFHLENBQUM7QUFDcEMsd0JBQUs7Z0JBQ3ZCO2NBQ0EsV0FBeUIsS0FBSyxRQUFRLElBQUksR0FBRztBQUM3QixvQkFBSSxXQUFXLFVBQVU7QUFDdkIsd0JBQUs7QUFDTCwyQkFBUztnQkFDM0I7QUFDZ0IsNkJBQWE7Y0FDN0IsV0FBeUIsQ0FBQyxLQUFLLFNBQVM7QUFDeEIsb0JBQUksV0FBVyxVQUFVO0FBQ3ZCLHdCQUFLO0FBQ0wsMkJBQVM7Z0JBQzNCO0FBQ2dCLDBCQUFVO2NBQzFCO0FBQ2M7WUFDRixLQUFLO0FBQ0gsa0JBQUksS0FBSyxLQUFLLElBQUksR0FBRztBQUNuQixvQkFBSSxDQUFDLEtBQUssUUFBUSxJQUFJLEdBQUc7QUFDdkIsc0JBQUksV0FBVyxVQUFVO0FBQ3ZCLDBCQUFLO0FBQ0wsNkJBQVM7a0JBQzdCO0FBQ2tCO2tCQUF3QyxLQUFLLFFBQVM7Z0JBQ3hFO2NBQ0EsV0FBeUIsS0FBSyxRQUFRLElBQUksR0FBRztBQUM3QixvQkFBSSxXQUFXLFVBQVU7QUFDdkIsd0JBQUs7QUFDTCwyQkFBUztnQkFDM0I7QUFDZ0IsNkJBQWEsS0FBSztjQUNsQyxXQUF5QixDQUFDLEtBQUssU0FBUztBQUN4QixvQkFBSSxXQUFXLFVBQVU7QUFDdkIsd0JBQUs7QUFDTCwyQkFBUztnQkFDM0I7QUFDZ0IsMEJBQVUsS0FBSztjQUMvQjtBQUNjO1lBQ0YsS0FBSyxlQUFlO0FBQ2xCLG9CQUFNLEVBQUUsS0FBSyxNQUFLOztnQkFBbUMsS0FBSzs7QUFDMUQsa0JBQUksS0FBSyxLQUFLLElBQUksR0FBRztBQUNuQixvQkFBSSxDQUFDLEtBQUssUUFBUSxJQUFJLEdBQUc7QUFDdkIsd0JBQU0sU0FBUyxrQkFBa0IsSUFBSSxHQUFHLEtBQUs7QUFDN0Msc0JBQUksQ0FBQyxXQUFXLFFBQVEsS0FBSyxHQUFHO0FBQzlCLHdCQUFJLFdBQVcsVUFBVTtBQUN2Qiw0QkFBSztvQkFDM0I7QUFDb0Isd0JBQUksV0FBVyxPQUFRLGNBQWMsSUFBSSxHQUFHLEtBQUssSUFBSSxHQUFJO0FBQ3ZELDZCQUFPLFdBQVcsR0FBRztvQkFDM0MsT0FBMkI7QUFDTCxpQ0FBVyxHQUFHLElBQUk7b0JBQ3hDO2tCQUNBLFdBQTZCLFVBQVUsTUFBTTtBQUN6Qix5QkFBSyxPQUFPLFdBQVc7a0JBQzNDO2dCQUNBO2NBQ0EsV0FBeUIsS0FBSyxRQUFRLElBQUksR0FBRztBQUM3Qiw4QkFBYyxJQUFJLEtBQUssS0FBSztBQUM1QixzQkFBTSxTQUFTLGtCQUFrQixJQUFJLEdBQUcsS0FBSztBQUM3QyxvQkFBSSxDQUFDLFdBQVcsUUFBUSxLQUFLLEdBQUc7QUFDOUIsc0JBQUksV0FBVyxVQUFVO0FBQ3ZCLDBCQUFLO2tCQUN6QjtBQUNrQiw2QkFBVyxHQUFHLElBQUk7Z0JBQ3BDO2NBQ0EsV0FBeUIsQ0FBQyxLQUFLLFNBQVM7QUFDeEIsOEJBQWMsSUFBSSxLQUFLLEtBQUs7QUFDNUIsc0JBQU0sT0FBTyxXQUFXLEdBQUc7QUFDM0Isb0JBQUksU0FBUyxRQUFXO0FBQ3RCLHNCQUFJLENBQUMsV0FBVyxNQUFNLEtBQUssR0FBRztBQUM1Qix3QkFBSSxXQUFXLFVBQVU7QUFDdkIsNEJBQUs7b0JBQzNCO0FBQ29CLHdCQUFJLFVBQVUsTUFBTTtBQUNsQiw2QkFBTyxXQUFXLEdBQUc7b0JBQzNDLE9BQTJCO0FBQ0wsaUNBQVcsR0FBRyxJQUFJO29CQUN4QztrQkFDQSxXQUE2QixTQUFTLE1BQU07QUFDeEIseUJBQUssT0FBTyxXQUFXO2tCQUMzQztnQkFDQTtjQUNBO0FBQ2Msa0JBQUksQ0FBQyxLQUFLLFNBQVM7QUFDakIsb0JBQUksV0FBVyxVQUFVO0FBQ3ZCLHdCQUFLO2dCQUN2QjtBQUNnQjtrQkFBd0I7O2tCQUFpRCxLQUFLO2dCQUFPO2NBQ3JHO0FBQ2M7WUFDZDtVQUNBO0FBQ1UsaUJBQU8sS0FBSztRQUN0QjtBQUNRLGNBQUs7QUFDTCxlQUFPLE1BQU0sU0FBUyxHQUFHO0FBQ3ZCLGdCQUFNLFNBQVMsTUFBTSxNQUFNLFNBQVMsQ0FBQztBQUNyQyxjQUFJLE9BQU8sV0FBVyxVQUFhLE9BQU8sZUFBZSxRQUFXO0FBRWxFLGtCQUFNLElBQUc7VUFDckIsT0FBaUI7QUFDTDtVQUNaO1FBQ0E7TUFDQSxDQUFPO0FBQ0QsV0FBSyxTQUFTO0lBQ3BCO0FBQ0k7O01BQTJCLEtBQUs7O0VBQ3BDO0FBQ0E7QUFXTyxJQUFNLFFBQU4sY0FBb0IsYUFBYTs7OztFQUl0QyxZQUFhLFFBQVE7QUFDbkIsVUFBSztBQUtMLFNBQUssV0FBVyxXQUFXLFNBQVksQ0FBQyxNQUFNLEtBQUssT0FBTyxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUE7QUFJeEUsU0FBSyxnQkFBZ0IsQ0FBQTtBQUtyQixTQUFLLGlCQUFpQjtFQUMxQjs7Ozs7O0VBT0UsSUFBSSxTQUFVO0FBQ1osV0FBTyxLQUFLO0VBQ2hCOzs7OztFQU1FLFdBQVksR0FBRyxNQUFNO0FBQ25CLFVBQU0sV0FBVyxHQUFHLElBQUk7QUFDeEIsUUFBSTtBQUM2QixNQUFDLEtBQUssU0FBVSxRQUFRLE9BQUssRUFBQyxDQUFFO0lBQ3JFLFNBQWEsR0FBUDtBQUNBLGNBQVEsTUFBTSxDQUFDO0lBQ3JCO0FBQ0ksU0FBSyxXQUFXO0VBQ3BCO0VBRUUsUUFBUztBQUNQLFdBQU8sSUFBSSxNQUFLO0VBQ3BCOzs7O0VBS0UsUUFBUztBQUNQLFVBQU1HLFFBQU8sSUFBSSxNQUFLO0FBQ3RCLElBQUFBLE1BQUssV0FBVyxLQUFLLFFBQU8sQ0FBRTtBQUM5QixXQUFPQTtFQUNYOzs7Ozs7O0VBUUUsY0FBZSxhQUFhLFlBQVk7QUFDdEMsVUFBTSxjQUFjLGFBQWEsVUFBVTtBQUMzQyxVQUFNLFFBQVEsSUFBSSxXQUFXLE1BQU0sYUFBYSxVQUFVO0FBQzFELHNCQUFrQixNQUFNLGFBQWEsS0FBSztBQUUxQyxRQUFJLENBQUMsWUFBWSxTQUFTLEtBQUssZ0JBQWdCO0FBQzdDLGtCQUFZLHlCQUF5QjtJQUMzQztFQUNBOzs7Ozs7RUFPRSxXQUFZO0FBQ1YsUUFBSSxNQUFNO0FBSVYsUUFBSSxJQUFJLEtBQUs7QUFDYixXQUFPLE1BQU0sTUFBTTtBQUNqQixVQUFJLENBQUMsRUFBRSxXQUFXLEVBQUUsYUFBYSxFQUFFLFFBQVEsZ0JBQWdCLGVBQWU7QUFDeEU7UUFBcUMsRUFBRSxRQUFTO01BQ3hEO0FBQ00sVUFBSSxFQUFFO0lBQ1o7QUFDSSxXQUFPO0VBQ1g7Ozs7Ozs7RUFRRSxTQUFVO0FBQ1IsV0FBTyxLQUFLLFNBQVE7RUFDeEI7Ozs7Ozs7Ozs7O0VBWUUsV0FBWSxPQUFPLEVBQUUsV0FBVyxLQUFJLElBQUssQ0FBQSxHQUFJO0FBQzNDLFFBQUksS0FBSyxRQUFRLE1BQU07QUFDckIsZUFBUyxLQUFLLEtBQUssaUJBQWU7QUFDaEMsY0FBTSxVQUFVLElBQUkscUJBQXFCLE1BQU0sS0FBSyxRQUFRLEdBQUcsb0JBQUksSUFBRyxDQUFFO0FBQ3hFLGlCQUFTLElBQUksR0FBRyxJQUFJLE1BQU0sUUFBUSxLQUFLO0FBQ3JDLGdCQUFNLEtBQUssTUFBTSxDQUFDO0FBQ2xCLGNBQUksR0FBRyxXQUFXLFFBQVc7QUFNM0Isa0JBQU0sTUFBTyxDQUFDLFlBQVksT0FBTyxHQUFHLFdBQVcsWUFBWSxNQUFNLE1BQU0sU0FBUyxLQUFLLFFBQVEsVUFBVSxRQUFRLEdBQUcsT0FBTyxNQUFNLEVBQUUsTUFBTSxPQUFRLEdBQUcsT0FBTyxNQUFNLEdBQUcsRUFBRSxJQUFJLEdBQUc7QUFDM0ssZ0JBQUksT0FBTyxRQUFRLFlBQVksSUFBSSxTQUFTLEdBQUc7QUFDN0MseUJBQVcsYUFBYSxNQUFNLFNBQVMsS0FBSyxHQUFHLGNBQWMsQ0FBQSxDQUFFO1lBQzdFO1VBQ0EsV0FBcUIsR0FBRyxXQUFXLFFBQVc7QUFDbEMsdUJBQVcsYUFBYSxNQUFNLFNBQVMsR0FBRyxRQUFRLEdBQUcsY0FBYyxDQUFBLENBQUU7VUFDakYsV0FBcUIsR0FBRyxXQUFXLFFBQVc7QUFDbEMsdUJBQVcsYUFBYSxTQUFTLEdBQUcsTUFBTTtVQUN0RDtRQUNBO01BQ0EsQ0FBTztJQUNQLE9BQVc7QUFDMEIsTUFBQyxLQUFLLFNBQVUsS0FBSyxNQUFNLEtBQUssV0FBVyxLQUFLLENBQUM7SUFDdEY7RUFDQTs7Ozs7Ozs7Ozs7RUFZRSxRQUFTLFVBQVUsY0FBYyxnQkFBZ0I7QUFJL0MsVUFBTSxNQUFNLENBQUE7QUFDWixVQUFNLG9CQUFvQixvQkFBSSxJQUFHO0FBQ2pDLFVBQU1EOztNQUEwQixLQUFLOztBQUNyQyxRQUFJLE1BQU07QUFDVixRQUFJLElBQUksS0FBSztBQUNiLGFBQVMsVUFBVztBQUNsQixVQUFJLElBQUksU0FBUyxHQUFHO0FBS2xCLGNBQU0sYUFBYSxDQUFBO0FBQ25CLFlBQUksZ0JBQWdCO0FBQ3BCLDBCQUFrQixRQUFRLENBQUMsT0FBTyxRQUFRO0FBQ3hDLDBCQUFnQjtBQUNoQixxQkFBVyxHQUFHLElBQUk7UUFDNUIsQ0FBUztBQUlELGNBQU0sS0FBSyxFQUFFLFFBQVEsSUFBRztBQUN4QixZQUFJLGVBQWU7QUFDakIsYUFBRyxhQUFhO1FBQzFCO0FBQ1EsWUFBSSxLQUFLLEVBQUU7QUFDWCxjQUFNO01BQ2Q7SUFDQTtBQUNJLFVBQU0sZUFBZSxNQUFNO0FBQ3pCLGFBQU8sTUFBTSxNQUFNO0FBQ2pCLFlBQUksVUFBVSxHQUFHLFFBQVEsS0FBTSxpQkFBaUIsVUFBYSxVQUFVLEdBQUcsWUFBWSxHQUFJO0FBQ3hGLGtCQUFRLEVBQUUsUUFBUSxhQUFXO1lBQzNCLEtBQUssZUFBZTtBQUNsQixvQkFBTSxNQUFNLGtCQUFrQixJQUFJLFNBQVM7QUFDM0Msa0JBQUksYUFBYSxVQUFhLENBQUMsVUFBVSxHQUFHLFFBQVEsR0FBRztBQUNyRCxvQkFBSSxRQUFRLFVBQWEsSUFBSSxTQUFTLEVBQUUsR0FBRyxVQUFVLElBQUksU0FBUyxXQUFXO0FBQzNFLDBCQUFPO0FBQ1Asb0NBQWtCLElBQUksV0FBVyxpQkFBaUIsZUFBZSxXQUFXLEVBQUUsRUFBRSxJQUFJLEVBQUUsTUFBTSxVQUFTLENBQUU7Z0JBQ3pIO2NBQ0EsV0FBeUIsaUJBQWlCLFVBQWEsQ0FBQyxVQUFVLEdBQUcsWUFBWSxHQUFHO0FBQ3BFLG9CQUFJLFFBQVEsVUFBYSxJQUFJLFNBQVMsRUFBRSxHQUFHLFVBQVUsSUFBSSxTQUFTLFNBQVM7QUFDekUsMEJBQU87QUFDUCxvQ0FBa0IsSUFBSSxXQUFXLGlCQUFpQixlQUFlLFNBQVMsRUFBRSxFQUFFLElBQUksRUFBRSxNQUFNLFFBQU8sQ0FBRTtnQkFDckg7Y0FDQSxXQUF5QixRQUFRLFFBQVc7QUFDNUIsd0JBQU87QUFDUCxrQ0FBa0IsT0FBTyxTQUFTO2NBQ2xEO0FBQ2M7Y0FBcUMsRUFBRSxRQUFTO0FBQ2hEO1lBQ2Q7WUFDWSxLQUFLO1lBQ0wsS0FBSyxjQUFjO0FBQ2pCLHNCQUFPO0FBSVAsb0JBQU0sS0FBSztnQkFDVCxRQUFRLEVBQUUsUUFBUSxXQUFVLEVBQUcsQ0FBQztjQUNoRDtBQUNjLGtCQUFJLGtCQUFrQixPQUFPLEdBQUc7QUFDOUIsc0JBQU07O2tCQUEyQyxDQUFBOztBQUNqRCxtQkFBRyxhQUFhO0FBQ2hCLGtDQUFrQixRQUFRLENBQUMsT0FBTyxRQUFRO0FBQ3hDLHdCQUFNLEdBQUcsSUFBSTtnQkFDL0IsQ0FBaUI7Y0FDakI7QUFDYyxrQkFBSSxLQUFLLEVBQUU7QUFDWDtZQUNkO1lBQ1ksS0FBSztBQUNILGtCQUFJLFVBQVUsR0FBRyxRQUFRLEdBQUc7QUFDMUIsd0JBQU87QUFDUDtrQkFBd0I7O2tCQUFpRCxFQUFFO2dCQUFPO2NBQ2xHO0FBQ2M7VUFDZDtRQUNBO0FBQ1EsWUFBSSxFQUFFO01BQ2Q7QUFDTSxjQUFPO0lBQ2I7QUFDSSxRQUFJLFlBQVksY0FBYztBQUc1QixlQUFTQSxNQUFLLGlCQUFlO0FBQzNCLFlBQUksVUFBVTtBQUNaLHVDQUE2QixhQUFhLFFBQVE7UUFDNUQ7QUFDUSxZQUFJLGNBQWM7QUFDaEIsdUNBQTZCLGFBQWEsWUFBWTtRQUNoRTtBQUNRLHFCQUFZO01BQ3BCLEdBQVMsU0FBUztJQUNsQixPQUFXO0FBQ0wsbUJBQVk7SUFDbEI7QUFDSSxXQUFPO0VBQ1g7Ozs7Ozs7Ozs7O0VBWUUsT0FBUSxPQUFPQyxPQUFNLFlBQVk7QUFDL0IsUUFBSUEsTUFBSyxVQUFVLEdBQUc7QUFDcEI7SUFDTjtBQUNJLFVBQU0sSUFBSSxLQUFLO0FBQ2YsUUFBSSxNQUFNLE1BQU07QUFDZCxlQUFTLEdBQUcsaUJBQWU7QUFDekIsY0FBTSxNQUFNLGFBQWEsYUFBYSxNQUFNLEtBQUs7QUFDakQsWUFBSSxDQUFDLFlBQVk7QUFDZix1QkFBYSxDQUFBO0FBRWIsY0FBSSxrQkFBa0IsUUFBUSxDQUFDLEdBQUcsTUFBTTtBQUFFLHVCQUFXLENBQUMsSUFBSTtVQUFDLENBQUU7UUFDdkU7QUFDUSxtQkFBVyxhQUFhLE1BQU0sS0FBS0EsT0FBTSxVQUFVO01BQzNELENBQU87SUFDUCxPQUFXO0FBQzBCLE1BQUMsS0FBSyxTQUFVLEtBQUssTUFBTSxLQUFLLE9BQU8sT0FBT0EsT0FBTSxVQUFVLENBQUM7SUFDcEc7RUFDQTs7Ozs7Ozs7Ozs7RUFZRSxZQUFhLE9BQU8sT0FBTyxhQUFhLENBQUEsR0FBSTtBQUMxQyxVQUFNLElBQUksS0FBSztBQUNmLFFBQUksTUFBTSxNQUFNO0FBQ2QsZUFBUyxHQUFHLGlCQUFlO0FBQ3pCLGNBQU0sTUFBTSxhQUFhLGFBQWEsTUFBTSxLQUFLO0FBQ2pELG1CQUFXLGFBQWEsTUFBTSxLQUFLLE9BQU8sVUFBVTtNQUM1RCxDQUFPO0lBQ1AsT0FBVztBQUMwQixNQUFDLEtBQUssU0FBVSxLQUFLLE1BQU0sS0FBSyxZQUFZLE9BQU8sT0FBTyxVQUFVLENBQUM7SUFDMUc7RUFDQTs7Ozs7Ozs7O0VBVUUsT0FBUSxPQUFPSCxTQUFRO0FBQ3JCLFFBQUlBLFlBQVcsR0FBRztBQUNoQjtJQUNOO0FBQ0ksVUFBTSxJQUFJLEtBQUs7QUFDZixRQUFJLE1BQU0sTUFBTTtBQUNkLGVBQVMsR0FBRyxpQkFBZTtBQUN6QixtQkFBVyxhQUFhLGFBQWEsYUFBYSxNQUFNLEtBQUssR0FBR0EsT0FBTTtNQUM5RSxDQUFPO0lBQ1AsT0FBVztBQUMwQixNQUFDLEtBQUssU0FBVSxLQUFLLE1BQU0sS0FBSyxPQUFPLE9BQU9BLE9BQU0sQ0FBQztJQUMxRjtFQUNBOzs7Ozs7Ozs7OztFQVlFLE9BQVEsT0FBT0EsU0FBUSxZQUFZO0FBQ2pDLFFBQUlBLFlBQVcsR0FBRztBQUNoQjtJQUNOO0FBQ0ksVUFBTSxJQUFJLEtBQUs7QUFDZixRQUFJLE1BQU0sTUFBTTtBQUNkLGVBQVMsR0FBRyxpQkFBZTtBQUN6QixjQUFNLE1BQU0sYUFBYSxhQUFhLE1BQU0sS0FBSztBQUNqRCxZQUFJLElBQUksVUFBVSxNQUFNO0FBQ3RCO1FBQ1Y7QUFDUSxtQkFBVyxhQUFhLE1BQU0sS0FBS0EsU0FBUSxVQUFVO01BQzdELENBQU87SUFDUCxPQUFXO0FBQzBCLE1BQUMsS0FBSyxTQUFVLEtBQUssTUFBTSxLQUFLLE9BQU8sT0FBT0EsU0FBUSxVQUFVLENBQUM7SUFDdEc7RUFDQTs7Ozs7Ozs7OztFQVdFLGdCQUFpQixlQUFlO0FBQzlCLFFBQUksS0FBSyxRQUFRLE1BQU07QUFDckIsZUFBUyxLQUFLLEtBQUssaUJBQWU7QUFDaEMsc0JBQWMsYUFBYSxNQUFNLGFBQWE7TUFDdEQsQ0FBTztJQUNQLE9BQVc7QUFDMEIsTUFBQyxLQUFLLFNBQVUsS0FBSyxNQUFNLEtBQUssZ0JBQWdCLGFBQWEsQ0FBQztJQUNuRztFQUNBOzs7Ozs7Ozs7OztFQVlFLGFBQWMsZUFBZSxnQkFBZ0I7QUFDM0MsUUFBSSxLQUFLLFFBQVEsTUFBTTtBQUNyQixlQUFTLEtBQUssS0FBSyxpQkFBZTtBQUNoQyxtQkFBVyxhQUFhLE1BQU0sZUFBZSxjQUFjO01BQ25FLENBQU87SUFDUCxPQUFXO0FBQzBCLE1BQUMsS0FBSyxTQUFVLEtBQUssTUFBTSxLQUFLLGFBQWEsZUFBZSxjQUFjLENBQUM7SUFDaEg7RUFDQTs7Ozs7Ozs7Ozs7O0VBYUUsYUFBYyxlQUFlO0FBQzNCOztNQUEyQixXQUFXLE1BQU0sYUFBYTs7RUFDN0Q7Ozs7Ozs7Ozs7RUFXRSxnQkFBaUI7QUFDZixXQUFPLGNBQWMsSUFBSTtFQUM3Qjs7OztFQUtFLE9BQVEsU0FBUztBQUNmLFlBQVEsYUFBYSxVQUFVO0VBQ25DO0FBQ0E7QUFTTyxJQUFNLFlBQVksY0FBWSxJQUFJLE1BQUs7QUNsdEN2QyxJQUFNLGlCQUFOLE1BQXFCOzs7OztFQUsxQixZQUFhLE1BQU0sSUFBSSxNQUFNLE1BQU07QUFDakMsU0FBSyxVQUFVO0FBQ2YsU0FBSyxRQUFRO0FBSWIsU0FBSztJQUFvQyxLQUFLO0FBQzlDLFNBQUssYUFBYTtFQUN0QjtFQUVFLENBQUMsT0FBTyxRQUFRLElBQUs7QUFDbkIsV0FBTztFQUNYOzs7Ozs7OztFQVNFLE9BQVE7QUFJTixRQUFJLElBQUksS0FBSztBQUNiLFFBQUlJLFFBQU8sS0FBSyxFQUFFO0lBQStCLEVBQUUsUUFBUztBQUM1RCxRQUFJLE1BQU0sU0FBUyxDQUFDLEtBQUssY0FBYyxFQUFFLFdBQVcsQ0FBQyxLQUFLLFFBQVFBLEtBQUksSUFBSTtBQUN4RSxTQUFHO0FBQ0QsUUFBQUE7UUFBMkIsRUFBRSxRQUFTO0FBQ3RDLFlBQUksQ0FBQyxFQUFFLFlBQVlBLE1BQUssZ0JBQWdCLGVBQWVBLE1BQUssZ0JBQWdCLGlCQUFpQkEsTUFBSyxXQUFXLE1BQU07QUFFakgsY0FBSUEsTUFBSztRQUNuQixPQUFlO0FBRUwsaUJBQU8sTUFBTSxNQUFNO0FBQ2pCLGdCQUFJLEVBQUUsVUFBVSxNQUFNO0FBQ3BCLGtCQUFJLEVBQUU7QUFDTjtZQUNkLFdBQXVCLEVBQUUsV0FBVyxLQUFLLE9BQU87QUFDbEMsa0JBQUk7WUFDbEIsT0FBbUI7QUFDTDtjQUFzQyxFQUFFLE9BQVE7WUFDOUQ7VUFDQTtRQUNBO01BQ0EsU0FBZSxNQUFNLFNBQVMsRUFBRSxXQUFXLENBQUMsS0FBSzs7UUFBb0MsRUFBRSxRQUFTO01BQUk7SUFDcEc7QUFDSSxTQUFLLGFBQWE7QUFDbEIsUUFBSSxNQUFNLE1BQU07QUFFZCxhQUFPLEVBQUUsT0FBTyxRQUFXLE1BQU0sS0FBSTtJQUMzQztBQUNJLFNBQUssZUFBZTtBQUNwQixXQUFPLEVBQUU7O01BQTJCLEVBQUUsUUFBUztPQUFNLE1BQU0sTUFBSztFQUNwRTtBQUNBO0FBV08sSUFBTSxlQUFOLGNBQTJCLGFBQWE7RUFDN0MsY0FBZTtBQUNiLFVBQUs7QUFJTCxTQUFLLGlCQUFpQixDQUFBO0VBQzFCOzs7O0VBS0UsSUFBSSxhQUFjO0FBQ2hCLFVBQU0sUUFBUSxLQUFLO0FBQ25CLFdBQU8sUUFBUSxNQUFNLFFBQVEsV0FBVSxFQUFHLENBQUMsSUFBSTtFQUNuRDs7Ozs7Ozs7Ozs7RUFZRSxXQUFZLEdBQUcsTUFBTTtBQUNuQixVQUFNLFdBQVcsR0FBRyxJQUFJO0FBQ3hCLFNBQUs7TUFBTzs7TUFBOEIsS0FBSztJQUFjO0FBQzdELFNBQUssaUJBQWlCO0VBQzFCO0VBRUUsUUFBUztBQUNQLFdBQU8sSUFBSSxhQUFZO0VBQzNCOzs7O0VBS0UsUUFBUztBQUNQLFVBQU0sS0FBSyxJQUFJLGFBQVk7QUFFM0IsT0FBRyxPQUFPLEdBQUcsS0FBSyxRQUFPLEVBQUcsSUFBSSxVQUFRLGdCQUFnQixlQUFlLEtBQUssTUFBSyxJQUFLLElBQUksQ0FBQztBQUMzRixXQUFPO0VBQ1g7RUFFRSxJQUFJLFNBQVU7QUFDWixXQUFPLEtBQUssbUJBQW1CLE9BQU8sS0FBSyxVQUFVLEtBQUssZUFBZTtFQUM3RTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0VBbUJFLGlCQUFrQixRQUFRO0FBQ3hCLFdBQU8sSUFBSSxlQUFlLE1BQU0sTUFBTTtFQUMxQzs7Ozs7Ozs7Ozs7Ozs7OztFQWlCRSxjQUFlLE9BQU87QUFDcEIsWUFBUSxNQUFNLFlBQVc7QUFFekIsVUFBTSxXQUFXLElBQUksZUFBZSxNQUFNLENBQUFDLGFBQVdBLFNBQVEsWUFBWUEsU0FBUSxTQUFTLFlBQVcsTUFBTyxLQUFLO0FBQ2pILFVBQU0sT0FBTyxTQUFTLEtBQUk7QUFDMUIsUUFBSSxLQUFLLE1BQU07QUFDYixhQUFPO0lBQ2IsT0FBVztBQUNMLGFBQU8sS0FBSztJQUNsQjtFQUNBOzs7Ozs7Ozs7Ozs7RUFhRSxpQkFBa0IsT0FBTztBQUN2QixZQUFRLE1BQU0sWUFBVztBQUV6QixXQUFhLEtBQUssSUFBSSxlQUFlLE1BQU0sQ0FBQUEsYUFBV0EsU0FBUSxZQUFZQSxTQUFRLFNBQVMsWUFBVyxNQUFPLEtBQUssQ0FBQztFQUN2SDs7Ozs7OztFQVFFLGNBQWUsYUFBYSxZQUFZO0FBQ3RDLHNCQUFrQixNQUFNLGFBQWEsSUFBSSxVQUFVLE1BQU0sWUFBWSxXQUFXLENBQUM7RUFDckY7Ozs7OztFQU9FLFdBQVk7QUFDVixXQUFPLFlBQVksTUFBTSxTQUFPLElBQUksU0FBUSxDQUFFLEVBQUUsS0FBSyxFQUFFO0VBQzNEOzs7O0VBS0UsU0FBVTtBQUNSLFdBQU8sS0FBSyxTQUFRO0VBQ3hCOzs7Ozs7Ozs7Ozs7Ozs7O0VBaUJFLE1BQU8sWUFBWSxVQUFVLFFBQVEsQ0FBQSxHQUFJLFNBQVM7QUFDaEQsVUFBTUMsWUFBVyxVQUFVLHVCQUFzQjtBQUNqRCxRQUFJLFlBQVksUUFBVztBQUN6QixjQUFRLG1CQUFtQkEsV0FBVSxJQUFJO0lBQy9DO0FBQ0ksb0JBQWdCLE1BQU0sYUFBVztBQUMvQixNQUFBQSxVQUFTLGFBQWEsUUFBUSxNQUFNLFdBQVcsT0FBTyxPQUFPLEdBQUcsSUFBSTtJQUMxRSxDQUFLO0FBQ0QsV0FBT0E7RUFDWDs7Ozs7Ozs7Ozs7RUFZRSxPQUFRLE9BQU8sU0FBUztBQUN0QixRQUFJLEtBQUssUUFBUSxNQUFNO0FBQ3JCLGVBQVMsS0FBSyxLQUFLLGlCQUFlO0FBQ2hDLCtCQUF1QixhQUFhLE1BQU0sT0FBTyxPQUFPO01BQ2hFLENBQU87SUFDUCxPQUFXO0FBRUwsV0FBSyxlQUFlLE9BQU8sT0FBTyxHQUFHLEdBQUcsT0FBTztJQUNyRDtFQUNBOzs7Ozs7Ozs7OztFQVlFLFlBQWEsS0FBSyxTQUFTO0FBQ3pCLFFBQUksS0FBSyxRQUFRLE1BQU07QUFDckIsZUFBUyxLQUFLLEtBQUssaUJBQWU7QUFDaEMsY0FBTSxVQUFXLE9BQU8sZUFBZSxlQUFnQixJQUFJLFFBQVE7QUFDbkUsb0NBQTRCLGFBQWEsTUFBTSxTQUFTLE9BQU87TUFDdkUsQ0FBTztJQUNQLE9BQVc7QUFDTCxZQUFNOztRQUFnQyxLQUFLOztBQUMzQyxZQUFNLFFBQVEsUUFBUSxPQUFPLElBQUksR0FBRyxVQUFVLFFBQU0sT0FBTyxHQUFHLElBQUk7QUFDbEUsVUFBSSxVQUFVLEtBQUssUUFBUSxNQUFNO0FBQy9CLGNBQVlDLFFBQU8sMEJBQTBCO01BQ3JEO0FBQ00sU0FBRyxPQUFPLE9BQU8sR0FBRyxHQUFHLE9BQU87SUFDcEM7RUFDQTs7Ozs7OztFQVFFLE9BQVEsT0FBT1AsVUFBUyxHQUFHO0FBQ3pCLFFBQUksS0FBSyxRQUFRLE1BQU07QUFDckIsZUFBUyxLQUFLLEtBQUssaUJBQWU7QUFDaEMsdUJBQWUsYUFBYSxNQUFNLE9BQU9BLE9BQU07TUFDdkQsQ0FBTztJQUNQLE9BQVc7QUFFTCxXQUFLLGVBQWUsT0FBTyxPQUFPQSxPQUFNO0lBQzlDO0VBQ0E7Ozs7OztFQU9FLFVBQVc7QUFDVCxXQUFPLGdCQUFnQixJQUFJO0VBQy9COzs7Ozs7RUFPRSxLQUFNLFNBQVM7QUFDYixTQUFLLE9BQU8sS0FBSyxRQUFRLE9BQU87RUFDcEM7Ozs7OztFQU9FLFFBQVMsU0FBUztBQUNoQixTQUFLLE9BQU8sR0FBRyxPQUFPO0VBQzFCOzs7Ozs7O0VBUUUsSUFBSyxPQUFPO0FBQ1YsV0FBTyxZQUFZLE1BQU0sS0FBSztFQUNsQzs7Ozs7Ozs7RUFTRSxNQUFPLFFBQVEsR0FBRyxNQUFNLEtBQUssUUFBUTtBQUNuQyxXQUFPLGNBQWMsTUFBTSxPQUFPLEdBQUc7RUFDekM7Ozs7OztFQU9FLFFBQVMsR0FBRztBQUNWLG9CQUFnQixNQUFNLENBQUM7RUFDM0I7Ozs7Ozs7OztFQVVFLE9BQVEsU0FBUztBQUNmLFlBQVEsYUFBYSxpQkFBaUI7RUFDMUM7QUFDQTtBQVNPLElBQU0sbUJBQW1CLGNBQVksSUFBSSxhQUFZO0FDeFpyRCxJQUFNLGNBQU4sY0FBMEIsYUFBYTtFQUM1QyxZQUFhLFdBQVcsYUFBYTtBQUNuQyxVQUFLO0FBQ0wsU0FBSyxXQUFXO0FBSWhCLFNBQUssZUFBZSxvQkFBSSxJQUFHO0VBQy9COzs7O0VBS0UsSUFBSSxjQUFlO0FBQ2pCLFVBQU0sSUFBSSxLQUFLLFFBQVEsS0FBSyxNQUFNLE9BQU87QUFDekMsV0FBTzs7O01BQXFFLEVBQUUsUUFBUztRQUFRO0VBQ25HOzs7O0VBS0UsSUFBSSxjQUFlO0FBQ2pCLFVBQU0sSUFBSSxLQUFLLFFBQVEsS0FBSyxNQUFNLE9BQU87QUFDekMsV0FBTzs7O01BQXFFLEVBQUUsUUFBUztRQUFRO0VBQ25HOzs7Ozs7Ozs7OztFQVlFLFdBQVksR0FBRyxNQUFNO0FBQ25CLFVBQU0sV0FBVyxHQUFHLElBQUk7QUFDdkI7SUFBa0MsS0FBSyxhQUFlLFFBQVEsQ0FBQyxPQUFPLFFBQVE7QUFDN0UsV0FBSyxhQUFhLEtBQUssS0FBSztJQUNsQyxDQUFLO0FBQ0QsU0FBSyxlQUFlO0VBQ3hCOzs7Ozs7RUFPRSxRQUFTO0FBQ1AsV0FBTyxJQUFJLFlBQVksS0FBSyxRQUFRO0VBQ3hDOzs7O0VBS0UsUUFBUztBQUlQLFVBQU0sS0FBSyxJQUFJLFlBQVksS0FBSyxRQUFRO0FBQ3hDLFVBQU0sUUFBUSxLQUFLLGNBQWE7QUFDaEMsSUFBTyxRQUFRLE9BQU8sQ0FBQyxPQUFPLFFBQVE7QUFDcEMsVUFBSSxPQUFPLFVBQVUsVUFBVTtBQUM3QixXQUFHLGFBQWEsS0FBSyxLQUFLO01BQ2xDO0lBQ0EsQ0FBSztBQUVELE9BQUcsT0FBTyxHQUFHLEtBQUssUUFBTyxFQUFHLElBQUksVUFBUSxnQkFBZ0IsZUFBZSxLQUFLLE1BQUssSUFBSyxJQUFJLENBQUM7QUFDM0YsV0FBTztFQUNYOzs7Ozs7Ozs7O0VBV0UsV0FBWTtBQUNWLFVBQU0sUUFBUSxLQUFLLGNBQWE7QUFDaEMsVUFBTSxnQkFBZ0IsQ0FBQTtBQUN0QixVQUFNUSxRQUFPLENBQUE7QUFDYixlQUFXLE9BQU8sT0FBTztBQUN2QixNQUFBQSxNQUFLLEtBQUssR0FBRztJQUNuQjtBQUNJLElBQUFBLE1BQUssS0FBSTtBQUNULFVBQU0sVUFBVUEsTUFBSztBQUNyQixhQUFTLElBQUksR0FBRyxJQUFJLFNBQVMsS0FBSztBQUNoQyxZQUFNLE1BQU1BLE1BQUssQ0FBQztBQUNsQixvQkFBYyxLQUFLLE1BQU0sT0FBTyxNQUFNLEdBQUcsSUFBSSxHQUFHO0lBQ3REO0FBQ0ksVUFBTSxXQUFXLEtBQUssU0FBUyxrQkFBaUI7QUFDaEQsVUFBTSxjQUFjLGNBQWMsU0FBUyxJQUFJLE1BQU0sY0FBYyxLQUFLLEdBQUcsSUFBSTtBQUMvRSxXQUFPLElBQUksV0FBVyxlQUFlLE1BQU0sU0FBUSxNQUFPO0VBQzlEOzs7Ozs7OztFQVNFLGdCQUFpQixlQUFlO0FBQzlCLFFBQUksS0FBSyxRQUFRLE1BQU07QUFDckIsZUFBUyxLQUFLLEtBQUssaUJBQWU7QUFDaEMsc0JBQWMsYUFBYSxNQUFNLGFBQWE7TUFDdEQsQ0FBTztJQUNQLE9BQVc7QUFDMEIsTUFBQyxLQUFLLGFBQWMsT0FBTyxhQUFhO0lBQzdFO0VBQ0E7Ozs7Ozs7Ozs7O0VBWUUsYUFBYyxlQUFlLGdCQUFnQjtBQUMzQyxRQUFJLEtBQUssUUFBUSxNQUFNO0FBQ3JCLGVBQVMsS0FBSyxLQUFLLGlCQUFlO0FBQ2hDLG1CQUFXLGFBQWEsTUFBTSxlQUFlLGNBQWM7TUFDbkUsQ0FBTztJQUNQLE9BQVc7QUFDMkIsTUFBQyxLQUFLLGFBQWMsSUFBSSxlQUFlLGNBQWM7SUFDM0Y7RUFDQTs7Ozs7Ozs7Ozs7O0VBYUUsYUFBYyxlQUFlO0FBQzNCOztNQUEyQixXQUFXLE1BQU0sYUFBYTs7RUFDN0Q7Ozs7Ozs7OztFQVVFLGFBQWMsZUFBZTtBQUMzQjs7TUFBMkIsV0FBVyxNQUFNLGFBQWE7O0VBQzdEOzs7Ozs7OztFQVNFLGdCQUFpQjtBQUNmOztNQUEyQixjQUFjLElBQUk7O0VBQ2pEOzs7Ozs7Ozs7Ozs7Ozs7O0VBaUJFLE1BQU8sWUFBWSxVQUFVLFFBQVEsQ0FBQSxHQUFJLFNBQVM7QUFDaEQsVUFBTSxNQUFNLFVBQVUsY0FBYyxLQUFLLFFBQVE7QUFDakQsVUFBTSxRQUFRLEtBQUssY0FBYTtBQUNoQyxlQUFXLE9BQU8sT0FBTztBQUN2QixZQUFNLFFBQVEsTUFBTSxHQUFHO0FBQ3ZCLFVBQUksT0FBTyxVQUFVLFVBQVU7QUFDN0IsWUFBSSxhQUFhLEtBQUssS0FBSztNQUNuQztJQUNBO0FBQ0ksb0JBQWdCLE1BQU0sVUFBUTtBQUM1QixVQUFJLFlBQVksS0FBSyxNQUFNLFdBQVcsT0FBTyxPQUFPLENBQUM7SUFDM0QsQ0FBSztBQUNELFFBQUksWUFBWSxRQUFXO0FBQ3pCLGNBQVEsbUJBQW1CLEtBQUssSUFBSTtJQUMxQztBQUNJLFdBQU87RUFDWDs7Ozs7Ozs7O0VBVUUsT0FBUSxTQUFTO0FBQ2YsWUFBUSxhQUFhLGdCQUFnQjtBQUNyQyxZQUFRLFNBQVMsS0FBSyxRQUFRO0VBQ2xDO0FBQ0E7QUFRTyxJQUFNLGtCQUFrQixhQUFXLElBQUksWUFBWSxRQUFRLFFBQU8sQ0FBRTtBQ3JQcEUsSUFBTSxZQUFOLGNBQXdCLE9BQU87Ozs7Ozs7O0VBUXBDLFlBQWEsUUFBUSxNQUFNLGFBQWE7QUFDdEMsVUFBTSxRQUFRLFdBQVc7QUFNekIsU0FBSyxtQkFBbUI7QUFLeEIsU0FBSyxvQkFBb0Isb0JBQUksSUFBRztBQUNoQyxTQUFLLFFBQVEsQ0FBQyxRQUFRO0FBQ3BCLFVBQUksUUFBUSxNQUFNO0FBQ2hCLGFBQUssbUJBQW1CO01BQ2hDLE9BQWE7QUFDTCxhQUFLLGtCQUFrQixJQUFJLEdBQUc7TUFDdEM7SUFDQSxDQUFLO0VBQ0w7QUFDQTtBQzNCTyxJQUFNLFdBQU4sY0FBdUIsS0FBSzs7OztFQUlqQyxZQUFhLFVBQVU7QUFDckIsVUFBSztBQUlMLFNBQUssV0FBVztFQUNwQjs7OztFQUtFLFFBQVM7QUFDUCxXQUFPLElBQUksU0FBUyxLQUFLLFFBQVE7RUFDckM7Ozs7RUFLRSxRQUFTO0FBQ1AsVUFBTSxLQUFLLElBQUksU0FBUyxLQUFLLFFBQVE7QUFDckMsU0FBSyxRQUFRLENBQUMsT0FBTyxRQUFRO0FBQzNCLFNBQUcsSUFBSSxLQUFLLEtBQUs7SUFDdkIsQ0FBSztBQUNELFdBQU87RUFDWDs7Ozs7Ozs7Ozs7Ozs7OztFQWlCRSxNQUFPLFlBQVksVUFBVSxRQUFRLENBQUEsR0FBSSxTQUFTO0FBQ2hELFVBQU0sT0FBTyxNQUFNLEtBQUssUUFBUTtBQUNoQyxRQUFJO0FBQ0osUUFBSSxTQUFTLFFBQVc7QUFDdEIsWUFBTSxLQUFLLFVBQVUsSUFBSTtJQUMvQixPQUFXO0FBQ0wsWUFBTSxTQUFTLGNBQWMsS0FBSyxRQUFRO0lBQ2hEO0FBQ0ksUUFBSSxhQUFhLGlCQUFpQixLQUFLLFFBQVE7QUFDL0MsUUFBSSxZQUFZLFFBQVc7QUFDekIsY0FBUSxtQkFBbUIsS0FBSyxJQUFJO0lBQzFDO0FBQ0ksV0FBTztFQUNYOzs7Ozs7Ozs7RUFVRSxPQUFRLFNBQVM7QUFDZixZQUFRLGFBQWEsYUFBYTtBQUNsQyxZQUFRLFNBQVMsS0FBSyxRQUFRO0VBQ2xDO0FBQ0E7QUFTTyxJQUFNLGVBQWUsYUFDMUIsSUFBSSxTQUFTLFFBQVEsUUFBTyxDQUFFO0FDbkZ6QixJQUFNLFdBQU4sY0FBdUIsTUFBTTs7OztFQUlsQyxJQUFJLGNBQWU7QUFDakIsVUFBTSxJQUFJLEtBQUssUUFBUSxLQUFLLE1BQU0sT0FBTztBQUN6QyxXQUFPOzs7TUFBcUUsRUFBRSxRQUFTO1FBQVE7RUFDbkc7Ozs7RUFLRSxJQUFJLGNBQWU7QUFDakIsVUFBTSxJQUFJLEtBQUssUUFBUSxLQUFLLE1BQU0sT0FBTztBQUN6QyxXQUFPOzs7TUFBcUUsRUFBRSxRQUFTO1FBQVE7RUFDbkc7RUFFRSxRQUFTO0FBQ1AsV0FBTyxJQUFJLFNBQVE7RUFDdkI7Ozs7RUFLRSxRQUFTO0FBQ1AsVUFBTUwsUUFBTyxJQUFJLFNBQVE7QUFDekIsSUFBQUEsTUFBSyxXQUFXLEtBQUssUUFBTyxDQUFFO0FBQzlCLFdBQU9BO0VBQ1g7Ozs7Ozs7Ozs7Ozs7Ozs7RUFpQkUsTUFBTyxZQUFZLFVBQVUsT0FBTyxTQUFTO0FBQzNDLFVBQU0sTUFBTSxVQUFVLGVBQWUsS0FBSyxTQUFRLENBQUU7QUFDcEQsUUFBSSxZQUFZLFFBQVc7QUFDekIsY0FBUSxtQkFBbUIsS0FBSyxJQUFJO0lBQzFDO0FBQ0ksV0FBTztFQUNYO0VBRUUsV0FBWTtBQUVWLFdBQU8sS0FBSyxRQUFPLEVBQUcsSUFBSSxXQUFTO0FBQ2pDLFlBQU0sY0FBYyxDQUFBO0FBQ3BCLGlCQUFXLFlBQVksTUFBTSxZQUFZO0FBQ3ZDLGNBQU0sUUFBUSxDQUFBO0FBQ2QsbUJBQVcsT0FBTyxNQUFNLFdBQVcsUUFBUSxHQUFHO0FBQzVDLGdCQUFNLEtBQUssRUFBRSxLQUFLLE9BQU8sTUFBTSxXQUFXLFFBQVEsRUFBRSxHQUFHLEVBQUMsQ0FBRTtRQUNwRTtBQUVRLGNBQU0sS0FBSyxDQUFDLEdBQUcsTUFBTSxFQUFFLE1BQU0sRUFBRSxNQUFNLEtBQUssQ0FBQztBQUMzQyxvQkFBWSxLQUFLLEVBQUUsVUFBVSxNQUFLLENBQUU7TUFDNUM7QUFFTSxrQkFBWSxLQUFLLENBQUMsR0FBRyxNQUFNLEVBQUUsV0FBVyxFQUFFLFdBQVcsS0FBSyxDQUFDO0FBRTNELFVBQUksTUFBTTtBQUNWLGVBQVMsSUFBSSxHQUFHLElBQUksWUFBWSxRQUFRLEtBQUs7QUFDM0MsY0FBTSxPQUFPLFlBQVksQ0FBQztBQUMxQixlQUFPLElBQUksS0FBSztBQUNoQixpQkFBUyxJQUFJLEdBQUcsSUFBSSxLQUFLLE1BQU0sUUFBUSxLQUFLO0FBQzFDLGdCQUFNLE9BQU8sS0FBSyxNQUFNLENBQUM7QUFDekIsaUJBQU8sSUFBSSxLQUFLLFFBQVEsS0FBSztRQUN2QztBQUNRLGVBQU87TUFDZjtBQUNNLGFBQU8sTUFBTTtBQUNiLGVBQVMsSUFBSSxZQUFZLFNBQVMsR0FBRyxLQUFLLEdBQUcsS0FBSztBQUNoRCxlQUFPLEtBQUssWUFBWSxDQUFDLEVBQUU7TUFDbkM7QUFDTSxhQUFPO0lBQ2IsQ0FBSyxFQUFFLEtBQUssRUFBRTtFQUNkOzs7O0VBS0UsU0FBVTtBQUNSLFdBQU8sS0FBSyxTQUFRO0VBQ3hCOzs7O0VBS0UsT0FBUSxTQUFTO0FBQ2YsWUFBUSxhQUFhLGFBQWE7RUFDdEM7QUFDQTtBQVNPLElBQU0sZUFBZSxhQUFXLElBQUksU0FBUTtBQ2pINUMsSUFBTSxpQkFBTixNQUFxQjs7Ozs7RUFLMUIsWUFBYU0sS0FBSVQsU0FBUTtBQUN2QixTQUFLLEtBQUtTO0FBQ1YsU0FBSyxTQUFTVDtFQUNsQjs7OztFQUtFLElBQUksVUFBVztBQUNiLFVBQVksb0JBQW1CO0VBQ25DOzs7Ozs7OztFQVNFLFVBQVcsT0FBTztBQUNoQixXQUFPO0VBQ1g7Ozs7OztFQU9FLE1BQU8sU0FBUyxRQUFRLGFBQWE7QUFDbkMsVUFBWSxvQkFBbUI7RUFDbkM7Ozs7O0VBTUUsVUFBVyxhQUFhLFFBQVE7QUFDOUIsVUFBWSxvQkFBbUI7RUFDbkM7QUFDQTtBQzVDTyxJQUFNLG9CQUFvQjtBQUsxQixJQUFNLEtBQU4sY0FBaUIsZUFBZTtFQUNyQyxJQUFJLFVBQVc7QUFDYixXQUFPO0VBQ1g7RUFFRSxTQUFVO0VBQUE7Ozs7O0VBTVYsVUFBVyxPQUFPO0FBQ2hCLFFBQUksS0FBSyxnQkFBZ0IsTUFBTSxhQUFhO0FBQzFDLGFBQU87SUFDYjtBQUNJLFNBQUssVUFBVSxNQUFNO0FBQ3JCLFdBQU87RUFDWDs7Ozs7RUFNRSxVQUFXLGFBQWEsUUFBUTtBQUM5QixRQUFJLFNBQVMsR0FBRztBQUNkLFdBQUssR0FBRyxTQUFTO0FBQ2pCLFdBQUssVUFBVTtJQUNyQjtBQUNJLGNBQVUsWUFBWSxJQUFJLE9BQU8sSUFBSTtFQUN6Qzs7Ozs7RUFNRSxNQUFPLFNBQVMsUUFBUTtBQUN0QixZQUFRLFVBQVUsaUJBQWlCO0FBQ25DLFlBQVEsU0FBUyxLQUFLLFNBQVMsTUFBTTtFQUN6Qzs7Ozs7O0VBT0UsV0FBWSxhQUFhLE9BQU87QUFDOUIsV0FBTztFQUNYO0FBQ0E7QUN0RE8sSUFBTSxnQkFBTixNQUFvQjs7OztFQUl6QixZQUFhLFNBQVM7QUFDcEIsU0FBSyxVQUFVO0VBQ25COzs7O0VBS0UsWUFBYTtBQUNYLFdBQU87RUFDWDs7OztFQUtFLGFBQWM7QUFDWixXQUFPLENBQUMsS0FBSyxPQUFPO0VBQ3hCOzs7O0VBS0UsY0FBZTtBQUNiLFdBQU87RUFDWDs7OztFQUtFLE9BQVE7QUFDTixXQUFPLElBQUksY0FBYyxLQUFLLE9BQU87RUFDekM7Ozs7O0VBTUUsT0FBUSxRQUFRO0FBQ2QsVUFBWSxvQkFBbUI7RUFDbkM7Ozs7O0VBTUUsVUFBVyxPQUFPO0FBQ2hCLFdBQU87RUFDWDs7Ozs7RUFNRSxVQUFXLGFBQWEsTUFBTTtFQUFBOzs7O0VBSTlCLE9BQVEsYUFBYTtFQUFBOzs7O0VBSXJCLEdBQUksT0FBTztFQUFBOzs7OztFQUtYLE1BQU8sU0FBUyxRQUFRO0FBQ3RCLFlBQVEsU0FBUyxLQUFLLE9BQU87RUFDakM7Ozs7RUFLRSxTQUFVO0FBQ1IsV0FBTztFQUNYO0FBQ0E7QUFNTyxJQUFNLG9CQUFvQixhQUFXLElBQUksY0FBYyxRQUFRLFFBQU8sQ0FBRTtBQ3JGeEUsSUFBTSxpQkFBTixNQUFxQjs7OztFQUkxQixZQUFhLEtBQUs7QUFDaEIsU0FBSyxNQUFNO0VBQ2Y7Ozs7RUFLRSxZQUFhO0FBQ1gsV0FBTyxLQUFLO0VBQ2hCOzs7O0VBS0UsYUFBYztBQUNaLFdBQU8sQ0FBQTtFQUNYOzs7O0VBS0UsY0FBZTtBQUNiLFdBQU87RUFDWDs7OztFQUtFLE9BQVE7QUFDTixXQUFPLElBQUksZUFBZSxLQUFLLEdBQUc7RUFDdEM7Ozs7O0VBTUUsT0FBUSxRQUFRO0FBQ2QsVUFBTSxRQUFRLElBQUksZUFBZSxLQUFLLE1BQU0sTUFBTTtBQUNsRCxTQUFLLE1BQU07QUFDWCxXQUFPO0VBQ1g7Ozs7O0VBTUUsVUFBVyxPQUFPO0FBQ2hCLFNBQUssT0FBTyxNQUFNO0FBQ2xCLFdBQU87RUFDWDs7Ozs7RUFNRSxVQUFXLGFBQWEsTUFBTTtBQUM1QixtQkFBZSxZQUFZLFdBQVcsS0FBSyxHQUFHLFFBQVEsS0FBSyxHQUFHLE9BQU8sS0FBSyxHQUFHO0FBQzdFLFNBQUssWUFBVztFQUNwQjs7OztFQUtFLE9BQVEsYUFBYTtFQUFBOzs7O0VBSXJCLEdBQUksT0FBTztFQUFBOzs7OztFQUtYLE1BQU8sU0FBUyxRQUFRO0FBQ3RCLFlBQVEsU0FBUyxLQUFLLE1BQU0sTUFBTTtFQUN0Qzs7OztFQUtFLFNBQVU7QUFDUixXQUFPO0VBQ1g7QUFDQTtBQVFPLElBQU0scUJBQXFCLGFBQVcsSUFBSSxlQUFlLFFBQVEsUUFBTyxDQUFFO0FDekZqRixJQUFNLG9CQUFvQixDQUFDLE1BQU0sU0FBUyxJQUFJLElBQUksRUFBRSxNQUFNLEdBQUcsTUFBTSxZQUFZLEtBQUssY0FBYyxLQUFLLFlBQVksTUFBSyxDQUFFO0FBS25ILElBQU0sYUFBTixNQUFpQjs7OztFQUl0QixZQUFhRSxNQUFLO0FBQ2hCLFFBQUlBLEtBQUksT0FBTztBQUNiLGNBQVEsTUFBTSx5SEFBeUg7SUFDN0k7QUFJSSxTQUFLLE1BQU1BO0FBSVgsVUFBTSxPQUFPLENBQUE7QUFDYixTQUFLLE9BQU87QUFDWixRQUFJLENBQUNBLEtBQUksSUFBSTtBQUNYLFdBQUssS0FBSztJQUNoQjtBQUNJLFFBQUlBLEtBQUksVUFBVTtBQUNoQixXQUFLLFdBQVc7SUFDdEI7QUFDSSxRQUFJQSxLQUFJLFNBQVMsTUFBTTtBQUNyQixXQUFLLE9BQU9BLEtBQUk7SUFDdEI7RUFDQTs7OztFQUtFLFlBQWE7QUFDWCxXQUFPO0VBQ1g7Ozs7RUFLRSxhQUFjO0FBQ1osV0FBTyxDQUFDLEtBQUssR0FBRztFQUNwQjs7OztFQUtFLGNBQWU7QUFDYixXQUFPO0VBQ1g7Ozs7RUFLRSxPQUFRO0FBQ04sV0FBTyxJQUFJLFdBQVcsa0JBQWtCLEtBQUssSUFBSSxNQUFNLEtBQUssSUFBSSxDQUFDO0VBQ3JFOzs7OztFQU1FLE9BQVEsUUFBUTtBQUNkLFVBQVksb0JBQW1CO0VBQ25DOzs7OztFQU1FLFVBQVcsT0FBTztBQUNoQixXQUFPO0VBQ1g7Ozs7O0VBTUUsVUFBVyxhQUFhLE1BQU07QUFFNUIsU0FBSyxJQUFJLFFBQVE7QUFDakIsZ0JBQVksYUFBYSxJQUFJLEtBQUssR0FBRztBQUNyQyxRQUFJLEtBQUssSUFBSSxZQUFZO0FBQ3ZCLGtCQUFZLGNBQWMsSUFBSSxLQUFLLEdBQUc7SUFDNUM7RUFDQTs7OztFQUtFLE9BQVEsYUFBYTtBQUNuQixRQUFJLFlBQVksYUFBYSxJQUFJLEtBQUssR0FBRyxHQUFHO0FBQzFDLGtCQUFZLGFBQWEsT0FBTyxLQUFLLEdBQUc7SUFDOUMsT0FBVztBQUNMLGtCQUFZLGVBQWUsSUFBSSxLQUFLLEdBQUc7SUFDN0M7RUFDQTs7OztFQUtFLEdBQUksT0FBTztFQUFBOzs7OztFQU1YLE1BQU8sU0FBUyxRQUFRO0FBQ3RCLFlBQVEsWUFBWSxLQUFLLElBQUksSUFBSTtBQUNqQyxZQUFRLFNBQVMsS0FBSyxJQUFJO0VBQzlCOzs7O0VBS0UsU0FBVTtBQUNSLFdBQU87RUFDWDtBQUNBO0FBUU8sSUFBTSxpQkFBaUIsYUFBVyxJQUFJLFdBQVcsa0JBQWtCLFFBQVEsV0FBVSxHQUFJLFFBQVEsUUFBTyxDQUFFLENBQUM7QUNsSTNHLElBQU0sZUFBTixNQUFtQjs7OztFQUl4QixZQUFhLE9BQU87QUFDbEIsU0FBSyxRQUFRO0VBQ2pCOzs7O0VBS0UsWUFBYTtBQUNYLFdBQU87RUFDWDs7OztFQUtFLGFBQWM7QUFDWixXQUFPLENBQUMsS0FBSyxLQUFLO0VBQ3RCOzs7O0VBS0UsY0FBZTtBQUNiLFdBQU87RUFDWDs7OztFQUtFLE9BQVE7QUFDTixXQUFPLElBQUksYUFBYSxLQUFLLEtBQUs7RUFDdEM7Ozs7O0VBTUUsT0FBUSxRQUFRO0FBQ2QsVUFBWSxvQkFBbUI7RUFDbkM7Ozs7O0VBTUUsVUFBVyxPQUFPO0FBQ2hCLFdBQU87RUFDWDs7Ozs7RUFNRSxVQUFXLGFBQWEsTUFBTTtFQUFBOzs7O0VBSTlCLE9BQVEsYUFBYTtFQUFBOzs7O0VBSXJCLEdBQUksT0FBTztFQUFBOzs7OztFQUtYLE1BQU8sU0FBUyxRQUFRO0FBQ3RCLFlBQVEsVUFBVSxLQUFLLEtBQUs7RUFDaEM7Ozs7RUFLRSxTQUFVO0FBQ1IsV0FBTztFQUNYO0FBQ0E7QUFRTyxJQUFNLG1CQUFtQixhQUFXLElBQUksYUFBYSxRQUFRLFNBQVEsQ0FBRTtBQ3ZGdkUsSUFBTSxnQkFBTixNQUFvQjs7Ozs7RUFLekIsWUFBYSxLQUFLLE9BQU87QUFDdkIsU0FBSyxNQUFNO0FBQ1gsU0FBSyxRQUFRO0VBQ2pCOzs7O0VBS0UsWUFBYTtBQUNYLFdBQU87RUFDWDs7OztFQUtFLGFBQWM7QUFDWixXQUFPLENBQUE7RUFDWDs7OztFQUtFLGNBQWU7QUFDYixXQUFPO0VBQ1g7Ozs7RUFLRSxPQUFRO0FBQ04sV0FBTyxJQUFJLGNBQWMsS0FBSyxLQUFLLEtBQUssS0FBSztFQUNqRDs7Ozs7RUFNRSxPQUFRLFNBQVM7QUFDZixVQUFZLG9CQUFtQjtFQUNuQzs7Ozs7RUFNRSxVQUFXLFFBQVE7QUFDakIsV0FBTztFQUNYOzs7OztFQU1FLFVBQVcsY0FBYyxNQUFNO0FBRTdCLFVBQU07O01BQTBCLEtBQUs7O0FBQ3JDLE1BQUUsZ0JBQWdCO0FBQ2xCLE1BQUUsaUJBQWlCO0VBQ3ZCOzs7O0VBS0UsT0FBUSxhQUFhO0VBQUE7Ozs7RUFJckIsR0FBSSxPQUFPO0VBQUE7Ozs7O0VBS1gsTUFBTyxTQUFTLFFBQVE7QUFDdEIsWUFBUSxTQUFTLEtBQUssR0FBRztBQUN6QixZQUFRLFVBQVUsS0FBSyxLQUFLO0VBQ2hDOzs7O0VBS0UsU0FBVTtBQUNSLFdBQU87RUFDWDtBQUNBO0FBTU8sSUFBTSxvQkFBb0IsYUFBVyxJQUFJLGNBQWMsUUFBUSxRQUFPLEdBQUksUUFBUSxTQUFRLENBQUU7QUNqRzVGLElBQU0sY0FBTixNQUFrQjs7OztFQUl2QixZQUFhLEtBQUs7QUFJaEIsU0FBSyxNQUFNO0VBQ2Y7Ozs7RUFLRSxZQUFhO0FBQ1gsV0FBTyxLQUFLLElBQUk7RUFDcEI7Ozs7RUFLRSxhQUFjO0FBQ1osV0FBTyxLQUFLO0VBQ2hCOzs7O0VBS0UsY0FBZTtBQUNiLFdBQU87RUFDWDs7OztFQUtFLE9BQVE7QUFDTixXQUFPLElBQUksWUFBWSxLQUFLLEdBQUc7RUFDbkM7Ozs7O0VBTUUsT0FBUSxRQUFRO0FBQ2QsVUFBTSxRQUFRLElBQUksWUFBWSxLQUFLLElBQUksTUFBTSxNQUFNLENBQUM7QUFDcEQsU0FBSyxNQUFNLEtBQUssSUFBSSxNQUFNLEdBQUcsTUFBTTtBQUNuQyxXQUFPO0VBQ1g7Ozs7O0VBTUUsVUFBVyxPQUFPO0FBQ2hCLFNBQUssTUFBTSxLQUFLLElBQUksT0FBTyxNQUFNLEdBQUc7QUFDcEMsV0FBTztFQUNYOzs7OztFQU1FLFVBQVcsYUFBYSxNQUFNO0VBQUE7Ozs7RUFJOUIsT0FBUSxhQUFhO0VBQUE7Ozs7RUFJckIsR0FBSSxPQUFPO0VBQUE7Ozs7O0VBS1gsTUFBTyxTQUFTLFFBQVE7QUFDdEIsVUFBTSxNQUFNLEtBQUssSUFBSTtBQUNyQixZQUFRLFNBQVMsTUFBTSxNQUFNO0FBQzdCLGFBQVMsSUFBSSxRQUFRLElBQUksS0FBSyxLQUFLO0FBQ2pDLFlBQU0sSUFBSSxLQUFLLElBQUksQ0FBQztBQUNwQixjQUFRLFlBQVksTUFBTSxTQUFZLGNBQWMsS0FBSyxVQUFVLENBQUMsQ0FBQztJQUMzRTtFQUNBOzs7O0VBS0UsU0FBVTtBQUNSLFdBQU87RUFDWDtBQUNBO0FBUU8sSUFBTSxrQkFBa0IsYUFBVztBQUN4QyxRQUFNLE1BQU0sUUFBUSxRQUFPO0FBQzNCLFFBQU0sS0FBSyxDQUFBO0FBQ1gsV0FBUyxJQUFJLEdBQUcsSUFBSSxLQUFLLEtBQUs7QUFDNUIsVUFBTSxJQUFJLFFBQVEsV0FBVTtBQUM1QixRQUFJLE1BQU0sYUFBYTtBQUNyQixTQUFHLEtBQUssTUFBUztJQUN2QixPQUFXO0FBQ0wsU0FBRyxLQUFLLEtBQUssTUFBTSxDQUFDLENBQUM7SUFDM0I7RUFDQTtBQUNFLFNBQU8sSUFBSSxZQUFZLEVBQUU7QUFDM0I7QUNqSE8sSUFBTSxhQUFOLE1BQWlCOzs7O0VBSXRCLFlBQWEsS0FBSztBQUloQixTQUFLLE1BQU07RUFDZjs7OztFQUtFLFlBQWE7QUFDWCxXQUFPLEtBQUssSUFBSTtFQUNwQjs7OztFQUtFLGFBQWM7QUFDWixXQUFPLEtBQUs7RUFDaEI7Ozs7RUFLRSxjQUFlO0FBQ2IsV0FBTztFQUNYOzs7O0VBS0UsT0FBUTtBQUNOLFdBQU8sSUFBSSxXQUFXLEtBQUssR0FBRztFQUNsQzs7Ozs7RUFNRSxPQUFRLFFBQVE7QUFDZCxVQUFNLFFBQVEsSUFBSSxXQUFXLEtBQUssSUFBSSxNQUFNLE1BQU0sQ0FBQztBQUNuRCxTQUFLLE1BQU0sS0FBSyxJQUFJLE1BQU0sR0FBRyxNQUFNO0FBQ25DLFdBQU87RUFDWDs7Ozs7RUFNRSxVQUFXLE9BQU87QUFDaEIsU0FBSyxNQUFNLEtBQUssSUFBSSxPQUFPLE1BQU0sR0FBRztBQUNwQyxXQUFPO0VBQ1g7Ozs7O0VBTUUsVUFBVyxhQUFhLE1BQU07RUFBQTs7OztFQUk5QixPQUFRLGFBQWE7RUFBQTs7OztFQUlyQixHQUFJLE9BQU87RUFBQTs7Ozs7RUFLWCxNQUFPLFNBQVMsUUFBUTtBQUN0QixVQUFNLE1BQU0sS0FBSyxJQUFJO0FBQ3JCLFlBQVEsU0FBUyxNQUFNLE1BQU07QUFDN0IsYUFBUyxJQUFJLFFBQVEsSUFBSSxLQUFLLEtBQUs7QUFDakMsWUFBTSxJQUFJLEtBQUssSUFBSSxDQUFDO0FBQ3BCLGNBQVEsU0FBUyxDQUFDO0lBQ3hCO0VBQ0E7Ozs7RUFLRSxTQUFVO0FBQ1IsV0FBTztFQUNYO0FBQ0E7QUFNTyxJQUFNLGlCQUFpQixhQUFXO0FBQ3ZDLFFBQU0sTUFBTSxRQUFRLFFBQU87QUFDM0IsUUFBTSxLQUFLLENBQUE7QUFDWCxXQUFTLElBQUksR0FBRyxJQUFJLEtBQUssS0FBSztBQUM1QixPQUFHLEtBQUssUUFBUSxRQUFPLENBQUU7RUFDN0I7QUFDRSxTQUFPLElBQUksV0FBVyxFQUFFO0FBQzFCO0FDcEdPLElBQU0sZ0JBQU4sTUFBb0I7Ozs7RUFJekIsWUFBYSxLQUFLO0FBSWhCLFNBQUssTUFBTTtFQUNmOzs7O0VBS0UsWUFBYTtBQUNYLFdBQU8sS0FBSyxJQUFJO0VBQ3BCOzs7O0VBS0UsYUFBYztBQUNaLFdBQU8sS0FBSyxJQUFJLE1BQU0sRUFBRTtFQUM1Qjs7OztFQUtFLGNBQWU7QUFDYixXQUFPO0VBQ1g7Ozs7RUFLRSxPQUFRO0FBQ04sV0FBTyxJQUFJLGNBQWMsS0FBSyxHQUFHO0VBQ3JDOzs7OztFQU1FLE9BQVEsUUFBUTtBQUNkLFVBQU0sUUFBUSxJQUFJLGNBQWMsS0FBSyxJQUFJLE1BQU0sTUFBTSxDQUFDO0FBQ3RELFNBQUssTUFBTSxLQUFLLElBQUksTUFBTSxHQUFHLE1BQU07QUFHbkMsVUFBTSxnQkFBZ0IsS0FBSyxJQUFJLFdBQVcsU0FBUyxDQUFDO0FBQ3BELFFBQUksaUJBQWlCLFNBQVUsaUJBQWlCLE9BQVE7QUFJdEQsV0FBSyxNQUFNLEtBQUssSUFBSSxNQUFNLEdBQUcsU0FBUyxDQUFDLElBQUk7QUFFM0MsWUFBTSxNQUFNLFdBQU0sTUFBTSxJQUFJLE1BQU0sQ0FBQztJQUN6QztBQUNJLFdBQU87RUFDWDs7Ozs7RUFNRSxVQUFXLE9BQU87QUFDaEIsU0FBSyxPQUFPLE1BQU07QUFDbEIsV0FBTztFQUNYOzs7OztFQU1FLFVBQVcsYUFBYSxNQUFNO0VBQUE7Ozs7RUFJOUIsT0FBUSxhQUFhO0VBQUE7Ozs7RUFJckIsR0FBSSxPQUFPO0VBQUE7Ozs7O0VBS1gsTUFBTyxTQUFTLFFBQVE7QUFDdEIsWUFBUSxZQUFZLFdBQVcsSUFBSSxLQUFLLE1BQU0sS0FBSyxJQUFJLE1BQU0sTUFBTSxDQUFDO0VBQ3hFOzs7O0VBS0UsU0FBVTtBQUNSLFdBQU87RUFDWDtBQUNBO0FBUU8sSUFBTSxvQkFBb0IsYUFBVyxJQUFJLGNBQWMsUUFBUSxXQUFVLENBQUU7QUM3RjNFLElBQU0sV0FBVztFQUN0QjtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtBQUNGO0FBRU8sSUFBTSxjQUFjO0FBQ3BCLElBQU0sWUFBWTtBQUNsQixJQUFNLGFBQWE7QUFDbkIsSUFBTSxtQkFBbUI7QUFDekIsSUFBTSxvQkFBb0I7QUFDMUIsSUFBTSxnQkFBZ0I7QUFDdEIsSUFBTSxnQkFBZ0I7QUFLdEIsSUFBTSxjQUFOLE1BQWtCOzs7O0VBSXZCLFlBQWFFLE9BQU07QUFJakIsU0FBSyxPQUFPQTtFQUNoQjs7OztFQUtFLFlBQWE7QUFDWCxXQUFPO0VBQ1g7Ozs7RUFLRSxhQUFjO0FBQ1osV0FBTyxDQUFDLEtBQUssSUFBSTtFQUNyQjs7OztFQUtFLGNBQWU7QUFDYixXQUFPO0VBQ1g7Ozs7RUFLRSxPQUFRO0FBQ04sV0FBTyxJQUFJLFlBQVksS0FBSyxLQUFLLE1BQUssQ0FBRTtFQUM1Qzs7Ozs7RUFNRSxPQUFRLFFBQVE7QUFDZCxVQUFZLG9CQUFtQjtFQUNuQzs7Ozs7RUFNRSxVQUFXLE9BQU87QUFDaEIsV0FBTztFQUNYOzs7OztFQU1FLFVBQVcsYUFBYSxNQUFNO0FBQzVCLFNBQUssS0FBSyxXQUFXLFlBQVksS0FBSyxJQUFJO0VBQzlDOzs7O0VBS0UsT0FBUSxhQUFhO0FBQ25CLFFBQUksT0FBTyxLQUFLLEtBQUs7QUFDckIsV0FBTyxTQUFTLE1BQU07QUFDcEIsVUFBSSxDQUFDLEtBQUssU0FBUztBQUNqQixhQUFLLE9BQU8sV0FBVztNQUMvQixXQUFpQixLQUFLLEdBQUcsU0FBUyxZQUFZLFlBQVksSUFBSSxLQUFLLEdBQUcsTUFBTSxLQUFLLElBQUk7QUFLN0Usb0JBQVksY0FBYyxLQUFLLElBQUk7TUFDM0M7QUFDTSxhQUFPLEtBQUs7SUFDbEI7QUFDSSxTQUFLLEtBQUssS0FBSyxRQUFRLENBQUFNLFVBQVE7QUFDN0IsVUFBSSxDQUFDQSxNQUFLLFNBQVM7QUFDakIsUUFBQUEsTUFBSyxPQUFPLFdBQVc7TUFDL0IsV0FBaUJBLE1BQUssR0FBRyxTQUFTLFlBQVksWUFBWSxJQUFJQSxNQUFLLEdBQUcsTUFBTSxLQUFLLElBQUk7QUFFN0Usb0JBQVksY0FBYyxLQUFLQSxLQUFJO01BQzNDO0lBQ0EsQ0FBSztBQUNELGdCQUFZLFFBQVEsT0FBTyxLQUFLLElBQUk7RUFDeEM7Ozs7RUFLRSxHQUFJLE9BQU87QUFDVCxRQUFJLE9BQU8sS0FBSyxLQUFLO0FBQ3JCLFdBQU8sU0FBUyxNQUFNO0FBQ3BCLFdBQUssR0FBRyxPQUFPLElBQUk7QUFDbkIsYUFBTyxLQUFLO0lBQ2xCO0FBQ0ksU0FBSyxLQUFLLFNBQVM7QUFDbkIsU0FBSyxLQUFLLEtBQUs7O01BQXlDLENBQUNBLFVBQVM7QUFDaEUsZUFBT0EsVUFBUyxNQUFNO0FBQ3BCLFVBQUFBLE1BQUssR0FBRyxPQUFPLElBQUk7QUFDbkIsVUFBQUEsUUFBT0EsTUFBSztRQUNwQjtNQUNBO0lBQUs7QUFDRCxTQUFLLEtBQUssT0FBTyxvQkFBSSxJQUFHO0VBQzVCOzs7OztFQU1FLE1BQU8sU0FBUyxRQUFRO0FBQ3RCLFNBQUssS0FBSyxPQUFPLE9BQU87RUFDNUI7Ozs7RUFLRSxTQUFVO0FBQ1IsV0FBTztFQUNYO0FBQ0E7QUFRTyxJQUFNLGtCQUFrQixhQUFXLElBQUksWUFBWSxTQUFTLFFBQVEsWUFBVyxDQUFFLEVBQUUsT0FBTyxDQUFDO0FDcEkzRixJQUFNLGVBQWUsQ0FBQyxPQUFPRCxRQUFPO0FBSXpDLE1BQUksU0FBU0E7QUFDYixNQUFJLE9BQU87QUFDWCxNQUFJO0FBQ0osS0FBRztBQUNELFFBQUksT0FBTyxHQUFHO0FBQ1osZUFBUyxTQUFTLE9BQU8sUUFBUSxPQUFPLFFBQVEsSUFBSTtJQUMxRDtBQUNJLFdBQU8sUUFBUSxPQUFPLE1BQU07QUFDNUIsV0FBTyxPQUFPLFFBQVEsS0FBSyxHQUFHO0FBQzlCLGFBQVMsS0FBSztFQUNsQixTQUFXLFdBQVcsUUFBUSxnQkFBZ0I7QUFDNUMsU0FBTztJQUNMO0lBQU07RUFDVjtBQUNBO0FBV08sSUFBTSxXQUFXLENBQUMsTUFBTSxTQUFTO0FBQ3RDLFNBQU8sU0FBUyxRQUFRLEtBQUssU0FBUyxNQUFNO0FBQzFDLFNBQUssT0FBTztBQUNaO0lBQXlDLEtBQUssT0FBUTtFQUMxRDtBQUNBO0FBWU8sSUFBTSxZQUFZLENBQUMsYUFBYSxVQUFVLFNBQVM7QUFFeEQsUUFBTSxFQUFFLFFBQVEsTUFBSyxJQUFLLFNBQVM7QUFDbkMsUUFBTSxZQUFZLElBQUk7SUFDcEIsU0FBUyxRQUFRLFFBQVEsSUFBSTtJQUM3QjtJQUNBLFNBQVMsUUFBUSxRQUFRLE9BQU8sQ0FBQztJQUNqQyxTQUFTO0lBQ1QsU0FBUztJQUNULFNBQVM7SUFDVCxTQUFTO0lBQ1QsU0FBUyxRQUFRLE9BQU8sSUFBSTtFQUNoQztBQUNFLE1BQUksU0FBUyxTQUFTO0FBQ3BCLGNBQVUsWUFBVztFQUN6QjtBQUNFLE1BQUksU0FBUyxNQUFNO0FBQ2pCLGNBQVUsT0FBTztFQUNyQjtBQUNFLE1BQUksU0FBUyxXQUFXLE1BQU07QUFDNUIsY0FBVSxTQUFTLFNBQVMsU0FBUyxPQUFPLFFBQVEsU0FBUyxPQUFPLFFBQVEsSUFBSTtFQUNwRjtBQUVFLFdBQVMsUUFBUTtBQUVqQixNQUFJLFVBQVUsVUFBVSxNQUFNO0FBQzVCLGNBQVUsTUFBTSxPQUFPO0VBQzNCO0FBRUUsY0FBWSxjQUFjLEtBQUssU0FBUztBQUV4QyxNQUFJLFVBQVUsY0FBYyxRQUFRLFVBQVUsVUFBVSxNQUFNO0FBQzNCLElBQUMsVUFBVSxPQUFRLEtBQUssSUFBSSxVQUFVLFdBQVcsU0FBUztFQUMvRjtBQUNFLFdBQVMsU0FBUztBQUNsQixTQUFPO0FBQ1Q7QUFNQSxJQUFNLHVCQUF1QixDQUFDLE9BQU9BLFFBQWE7RUFBSzs7RUFBbUMsT0FBSyxVQUFVLEVBQUUsV0FBV0EsR0FBRTtBQUFDO0FBZ0JsSCxJQUFNLFdBQVcsQ0FBQyxhQUFhLE1BQU0sV0FBVyxlQUFlLHdCQUF3QixPQUFPO0FBQ25HLFFBQU1QLE9BQU0sWUFBWTtBQUN4QixRQUFNLFFBQVFBLEtBQUk7QUFDbEIsUUFBTSxjQUFjQSxLQUFJO0FBQ3hCLFFBQU0sU0FBUyxLQUFLO0FBQ3BCLE1BQUksV0FBVyxNQUFNO0FBQ25CLFdBQU8sa0JBQWtCLGFBQWEsTUFBTTtFQUNoRDtBQUNFLE1BQUk7O0lBQStDLEtBQUssT0FBUTs7QUFJaEUsTUFBSSxPQUFPO0FBSVgsTUFBSTtBQUVKLE1BQUksZUFBZSxRQUFRLFdBQVcsWUFBWSxNQUFNO0FBRXRELFFBQUksV0FBVyxXQUFXLFNBQVMsQ0FBQyxVQUFVLElBQUksVUFBVSxLQUFLLFNBQVMsYUFBYSxZQUFZLFdBQVcsZUFBZSx3QkFBd0IsRUFBRSxNQUFNLE9BQU87QUFDbEssYUFBTztJQUNiO0FBQ0ksV0FBTyxXQUFXLFdBQVcsTUFBTTtBQUNqQyxtQkFBYSxrQkFBa0IsYUFBYSxXQUFXLE1BQU07SUFDbkU7RUFDQTtBQUNFLFFBQU0sYUFBYSxlQUFlOztJQUF5QyxLQUFLOzs7SUFBc0MsV0FBVyxRQUFTOztBQUUxSSxNQUFJLEtBQUssY0FBYyxNQUFNO0FBRTNCLFdBQU8sS0FBSztBQUNaLFlBQVE7QUFFUixXQUFPLFNBQVMsTUFBTTtBQUlwQixVQUFJLFlBQVk7QUFFaEIsYUFBTyxjQUFjO01BQTBDLFVBQVUsT0FBUSxVQUFVLFlBQVk7QUFDckcsb0JBQVksVUFBVSxXQUFXLE9BQU8sT0FBTyxrQkFBa0IsYUFBYSxVQUFVLE1BQU07TUFDdEc7QUFDTSxVQUFJLGNBQWM7TUFBMEMsVUFBVSxPQUFRLFVBQVUsWUFBWTtBQUNsRyxlQUFPO0FBQ1A7TUFDUjtBQUNNLGFBQU8sS0FBSztJQUNsQjtBQUNJLFdBQU8sVUFBVSxNQUFNO0FBSXJCLFVBQUksYUFBYTtBQUVqQixhQUFPLGVBQWU7TUFBMEMsV0FBVyxPQUFRLFVBQVUsWUFBWTtBQUN2RyxxQkFBYSxXQUFXLFdBQVcsT0FBTyxPQUFPLGtCQUFrQixhQUFhLFdBQVcsTUFBTTtNQUN6RztBQUNNLFVBQUksZUFBZTtNQUEwQyxXQUFXLE9BQVEsVUFBVSxZQUFZO0FBQ3BHLGdCQUFRO0FBQ1I7TUFDUjtBQUNNLGNBQVEsTUFBTTtJQUNwQjtFQUNBLE9BQVM7QUFDTCxZQUFRO0FBQ1IsUUFBSSxLQUFLLFNBQVMsQ0FBQyx3QkFBd0I7QUFDekMsYUFBTztBQUdQLGFBQU8sU0FBUyxRQUFRLEtBQUssVUFBVSxTQUFTLEtBQUssTUFBTSxVQUFVLFVBQVUsZUFBZSxLQUFLLE1BQU0sRUFBRSxLQUFLLHFCQUFxQixHQUFHLFdBQVcsS0FBSyxNQUFNLEVBQUUsS0FBSyxxQkFBcUIsR0FBRyxXQUFXLEtBQUssTUFBTSxFQUFFLElBQUk7QUFDdk4sZUFBTyxLQUFLO0FBRVosZUFBTyxLQUFLO0FBQVEsaUJBQU8sa0JBQWtCLGFBQWEsS0FBSyxNQUFNO01BQzdFO0FBQ00sVUFBSSxRQUFRLEtBQUssVUFBVSxNQUFNO0FBRy9CLGVBQU87TUFDZjtJQUNBLE9BQVc7QUFDTCxhQUFPLFdBQVcsS0FBSyxJQUFJLEtBQUssU0FBUyxLQUFLO0lBQ3BEO0VBQ0E7QUFDRSxRQUFNLFlBQVksU0FBUyxPQUFPLFdBQVc7QUFDN0MsUUFBTSxTQUFTLFNBQVMsYUFBYSxTQUFTO0FBQzlDLFFBQU0sYUFBYSxJQUFJO0lBQ3JCO0lBQ0E7SUFBTSxRQUFRLEtBQUs7SUFDbkI7SUFBTyxTQUFTLE1BQU07SUFDdEI7SUFDQSxLQUFLO0lBQ0wsS0FBSyxRQUFRLEtBQUk7RUFDckI7QUFDRSxPQUFLLFNBQVM7QUFDZCxXQUFTLFlBQVksSUFBSTtBQUN6QixhQUFXLFVBQVUsYUFBYSxDQUFDO0FBQ25DLFNBQU87QUFDVDtBQUtPLElBQU0sT0FBTixjQUFtQixlQUFlOzs7Ozs7Ozs7OztFQVd2QyxZQUFhTyxLQUFJLE1BQU0sUUFBUSxPQUFPLGFBQWEsUUFBUSxXQUFXLFNBQVM7QUFDN0UsVUFBTUEsS0FBSSxRQUFRLFVBQVMsQ0FBRTtBQUs3QixTQUFLLFNBQVM7QUFLZCxTQUFLLE9BQU87QUFLWixTQUFLLFFBQVE7QUFLYixTQUFLLGNBQWM7QUFJbkIsU0FBSyxTQUFTO0FBUWQsU0FBSyxZQUFZO0FBTWpCLFNBQUssU0FBUztBQUlkLFNBQUssVUFBVTtBQVFmLFNBQUssT0FBTyxLQUFLLFFBQVEsWUFBVyxJQUFZLE9BQU87RUFDM0Q7Ozs7OztFQU9FLElBQUksT0FBUSxVQUFVO0FBQ3BCLFNBQU0sS0FBSyxPQUFjLFFBQVEsTUFBTyxVQUFVO0FBQ2hELFdBQUssUUFBZTtJQUMxQjtFQUNBO0VBRUUsSUFBSSxTQUFVO0FBQ1osWUFBUSxLQUFLLE9BQWMsUUFBUTtFQUN2Qzs7OztFQUtFLElBQUksT0FBUTtBQUNWLFlBQVEsS0FBSyxPQUFjLFFBQVE7RUFDdkM7RUFFRSxJQUFJLEtBQU0sUUFBUTtBQUNoQixRQUFJLEtBQUssU0FBUyxRQUFRO0FBQ3hCLFdBQUssUUFBZTtJQUMxQjtFQUNBO0VBRUUsSUFBSSxZQUFhO0FBQ2YsWUFBUSxLQUFLLE9BQWMsUUFBUTtFQUN2Qzs7Ozs7RUFNRSxJQUFJLFVBQVc7QUFDYixZQUFRLEtBQUssT0FBYyxRQUFRO0VBQ3ZDO0VBRUUsSUFBSSxRQUFTLFVBQVU7QUFDckIsUUFBSSxLQUFLLFlBQVksVUFBVTtBQUM3QixXQUFLLFFBQWU7SUFDMUI7RUFDQTtFQUVFLGNBQWU7QUFDYixTQUFLLFFBQWU7RUFDeEI7Ozs7Ozs7O0VBU0UsV0FBWSxhQUFhLE9BQU87QUFDOUIsUUFBSSxLQUFLLFVBQVUsS0FBSyxPQUFPLFdBQVcsS0FBSyxHQUFHLFVBQVUsS0FBSyxPQUFPLFNBQVMsU0FBUyxPQUFPLEtBQUssT0FBTyxNQUFNLEdBQUc7QUFDcEgsYUFBTyxLQUFLLE9BQU87SUFDekI7QUFDSSxRQUFJLEtBQUssZUFBZSxLQUFLLFlBQVksV0FBVyxLQUFLLEdBQUcsVUFBVSxLQUFLLFlBQVksU0FBUyxTQUFTLE9BQU8sS0FBSyxZQUFZLE1BQU0sR0FBRztBQUN4SSxhQUFPLEtBQUssWUFBWTtJQUM5QjtBQUNJLFFBQUksS0FBSyxVQUFVLEtBQUssT0FBTyxnQkFBZ0IsTUFBTSxLQUFLLEdBQUcsV0FBVyxLQUFLLE9BQU8sVUFBVSxLQUFLLE9BQU8sU0FBUyxTQUFTLE9BQU8sS0FBSyxPQUFPLE1BQU0sR0FBRztBQUN0SixhQUFPLEtBQUssT0FBTztJQUN6QjtBQUlJLFFBQUksS0FBSyxRQUFRO0FBQ2YsV0FBSyxPQUFPLGdCQUFnQixhQUFhLE9BQU8sS0FBSyxNQUFNO0FBQzNELFdBQUssU0FBUyxLQUFLLEtBQUs7SUFDOUI7QUFDSSxRQUFJLEtBQUssYUFBYTtBQUNwQixXQUFLLFFBQVEsa0JBQWtCLGFBQWEsS0FBSyxXQUFXO0FBQzVELFdBQUssY0FBYyxLQUFLLE1BQU07SUFDcEM7QUFDSSxRQUFLLEtBQUssUUFBUSxLQUFLLEtBQUssZ0JBQWdCLE1BQVEsS0FBSyxTQUFTLEtBQUssTUFBTSxnQkFBZ0IsSUFBSztBQUNoRyxXQUFLLFNBQVM7SUFDcEIsV0FBZSxDQUFDLEtBQUssUUFBUTtBQUV2QixVQUFJLEtBQUssUUFBUSxLQUFLLEtBQUssZ0JBQWdCLE1BQU07QUFDL0MsYUFBSyxTQUFTLEtBQUssS0FBSztBQUN4QixhQUFLLFlBQVksS0FBSyxLQUFLO01BQ25DO0FBQ00sVUFBSSxLQUFLLFNBQVMsS0FBSyxNQUFNLGdCQUFnQixNQUFNO0FBQ2pELGFBQUssU0FBUyxLQUFLLE1BQU07QUFDekIsYUFBSyxZQUFZLEtBQUssTUFBTTtNQUNwQztJQUNBLFdBQWUsS0FBSyxPQUFPLGdCQUFnQixJQUFJO0FBQ3pDLFlBQU0sYUFBYSxRQUFRLE9BQU8sS0FBSyxNQUFNO0FBQzdDLFVBQUksV0FBVyxnQkFBZ0IsSUFBSTtBQUNqQyxhQUFLLFNBQVM7TUFDdEIsT0FBYTtBQUNMLGFBQUs7UUFBcUMsV0FBVyxRQUFTO01BQ3RFO0lBQ0E7QUFDSSxXQUFPO0VBQ1g7Ozs7O0VBTUUsVUFBVyxhQUFhLFFBQVE7QUFDOUIsUUFBSSxTQUFTLEdBQUc7QUFDZCxXQUFLLEdBQUcsU0FBUztBQUNqQixXQUFLLE9BQU8sZ0JBQWdCLGFBQWEsWUFBWSxJQUFJLE9BQU8sU0FBUyxLQUFLLEdBQUcsUUFBUSxLQUFLLEdBQUcsUUFBUSxDQUFDLENBQUM7QUFDM0csV0FBSyxTQUFTLEtBQUssS0FBSztBQUN4QixXQUFLLFVBQVUsS0FBSyxRQUFRLE9BQU8sTUFBTTtBQUN6QyxXQUFLLFVBQVU7SUFDckI7QUFFSSxRQUFJLEtBQUssUUFBUTtBQUNmLFVBQUssQ0FBQyxLQUFLLFNBQVMsQ0FBQyxLQUFLLFNBQVMsS0FBSyxNQUFNLFNBQVMsU0FBVyxLQUFLLFFBQVEsS0FBSyxLQUFLLFVBQVUsS0FBSyxPQUFRO0FBSTlHLFlBQUksT0FBTyxLQUFLO0FBS2hCLFlBQUk7QUFFSixZQUFJLFNBQVMsTUFBTTtBQUNqQixjQUFJLEtBQUs7UUFDbkIsV0FBbUIsS0FBSyxjQUFjLE1BQU07QUFDbEM7VUFBc0MsS0FBSyxPQUFRLEtBQUssSUFBSSxLQUFLLFNBQVMsS0FBSztBQUMvRSxpQkFBTyxNQUFNLFFBQVEsRUFBRSxTQUFTLE1BQU07QUFDcEMsZ0JBQUksRUFBRTtVQUNsQjtRQUNBLE9BQWU7QUFDTDtVQUFzQyxLQUFLLE9BQVE7UUFDN0Q7QUFNUSxjQUFNLG1CQUFtQixvQkFBSSxJQUFHO0FBSWhDLGNBQU0sb0JBQW9CLG9CQUFJLElBQUc7QUFJakMsZUFBTyxNQUFNLFFBQVEsTUFBTSxLQUFLLE9BQU87QUFDckMsNEJBQWtCLElBQUksQ0FBQztBQUN2QiwyQkFBaUIsSUFBSSxDQUFDO0FBQ3RCLGNBQUksV0FBVyxLQUFLLFFBQVEsRUFBRSxNQUFNLEdBQUc7QUFFckMsZ0JBQUksRUFBRSxHQUFHLFNBQVMsS0FBSyxHQUFHLFFBQVE7QUFDaEMscUJBQU87QUFDUCwrQkFBaUIsTUFBSztZQUNwQyxXQUF1QixXQUFXLEtBQUssYUFBYSxFQUFFLFdBQVcsR0FBRztBQUd0RDtZQUNkO1VBQ0EsV0FBcUIsRUFBRSxXQUFXLFFBQVEsa0JBQWtCLElBQUksUUFBUSxZQUFZLElBQUksT0FBTyxFQUFFLE1BQU0sQ0FBQyxHQUFHO0FBRS9GLGdCQUFJLENBQUMsaUJBQWlCLElBQUksUUFBUSxZQUFZLElBQUksT0FBTyxFQUFFLE1BQU0sQ0FBQyxHQUFHO0FBQ25FLHFCQUFPO0FBQ1AsK0JBQWlCLE1BQUs7WUFDcEM7VUFDQSxPQUFpQjtBQUNMO1VBQ1o7QUFDVSxjQUFJLEVBQUU7UUFDaEI7QUFDUSxhQUFLLE9BQU87TUFDcEI7QUFFTSxVQUFJLEtBQUssU0FBUyxNQUFNO0FBQ3RCLGNBQU0sUUFBUSxLQUFLLEtBQUs7QUFDeEIsYUFBSyxRQUFRO0FBQ2IsYUFBSyxLQUFLLFFBQVE7TUFDMUIsT0FBYTtBQUNMLFlBQUk7QUFDSixZQUFJLEtBQUssY0FBYyxNQUFNO0FBQzNCO1VBQXNDLEtBQUssT0FBUSxLQUFLLElBQUksS0FBSyxTQUFTLEtBQUs7QUFDL0UsaUJBQU8sTUFBTSxRQUFRLEVBQUUsU0FBUyxNQUFNO0FBQ3BDLGdCQUFJLEVBQUU7VUFDbEI7UUFDQSxPQUFlO0FBQ0w7VUFBc0MsS0FBSyxPQUFRO0FBQ2pCLFVBQUMsS0FBSyxPQUFRLFNBQVM7UUFDbkU7QUFDUSxhQUFLLFFBQVE7TUFDckI7QUFDTSxVQUFJLEtBQUssVUFBVSxNQUFNO0FBQ3ZCLGFBQUssTUFBTSxPQUFPO01BQzFCLFdBQWlCLEtBQUssY0FBYyxNQUFNO0FBRUQsUUFBQyxLQUFLLE9BQVEsS0FBSyxJQUFJLEtBQUssV0FBVyxJQUFJO0FBQzVFLFlBQUksS0FBSyxTQUFTLE1BQU07QUFFdEIsZUFBSyxLQUFLLE9BQU8sV0FBVztRQUN0QztNQUNBO0FBRU0sVUFBSSxLQUFLLGNBQWMsUUFBUSxLQUFLLGFBQWEsQ0FBQyxLQUFLLFNBQVM7QUFDN0IsUUFBQyxLQUFLLE9BQVEsV0FBVyxLQUFLO01BQ3ZFO0FBQ00sZ0JBQVUsWUFBWSxJQUFJLE9BQU8sSUFBSTtBQUNyQyxXQUFLLFFBQVEsVUFBVSxhQUFhLElBQUk7QUFFeEM7UUFBNEI7O1FBQStDLEtBQUs7UUFBUyxLQUFLO01BQVM7QUFDdkc7O1FBQXVDLEtBQUssT0FBUSxVQUFVO1FBQTBDLEtBQUssT0FBUSxNQUFNLFdBQWEsS0FBSyxjQUFjLFFBQVEsS0FBSyxVQUFVO1FBQU87QUFFdkwsYUFBSyxPQUFPLFdBQVc7TUFDL0I7SUFDQSxPQUFXO0FBRUwsVUFBSSxHQUFHLEtBQUssSUFBSSxLQUFLLE1BQU0sRUFBRSxVQUFVLGFBQWEsQ0FBQztJQUMzRDtFQUNBOzs7O0VBS0UsSUFBSSxPQUFRO0FBQ1YsUUFBSSxJQUFJLEtBQUs7QUFDYixXQUFPLE1BQU0sUUFBUSxFQUFFLFNBQVM7QUFDOUIsVUFBSSxFQUFFO0lBQ1o7QUFDSSxXQUFPO0VBQ1g7Ozs7RUFLRSxJQUFJLE9BQVE7QUFDVixRQUFJLElBQUksS0FBSztBQUNiLFdBQU8sTUFBTSxRQUFRLEVBQUUsU0FBUztBQUM5QixVQUFJLEVBQUU7SUFDWjtBQUNJLFdBQU87RUFDWDs7OztFQUtFLElBQUksU0FBVTtBQUVaLFdBQU8sS0FBSyxXQUFXLElBQUksS0FBSyxLQUFLLFNBQVMsS0FBSyxHQUFHLFFBQVEsS0FBSyxHQUFHLFFBQVEsS0FBSyxTQUFTLENBQUM7RUFDakc7Ozs7Ozs7RUFRRSxVQUFXLE9BQU87QUFDaEIsUUFDRSxLQUFLLGdCQUFnQixNQUFNLGVBQzNCLFdBQVcsTUFBTSxRQUFRLEtBQUssTUFBTSxLQUNwQyxLQUFLLFVBQVUsU0FDZixXQUFXLEtBQUssYUFBYSxNQUFNLFdBQVcsS0FDOUMsS0FBSyxHQUFHLFdBQVcsTUFBTSxHQUFHLFVBQzVCLEtBQUssR0FBRyxRQUFRLEtBQUssV0FBVyxNQUFNLEdBQUcsU0FDekMsS0FBSyxZQUFZLE1BQU0sV0FDdkIsS0FBSyxXQUFXLFFBQ2hCLE1BQU0sV0FBVyxRQUNqQixLQUFLLFFBQVEsZ0JBQWdCLE1BQU0sUUFBUSxlQUMzQyxLQUFLLFFBQVEsVUFBVSxNQUFNLE9BQU8sR0FDcEM7QUFDQSxZQUFNOztRQUFpRCxLQUFLLE9BQVE7O0FBQ3BFLFVBQUksY0FBYztBQUNoQixxQkFBYSxRQUFRLFlBQVU7QUFDN0IsY0FBSSxPQUFPLE1BQU0sT0FBTztBQUV0QixtQkFBTyxJQUFJO0FBRVgsZ0JBQUksQ0FBQyxLQUFLLFdBQVcsS0FBSyxXQUFXO0FBQ25DLHFCQUFPLFNBQVMsS0FBSztZQUNuQztVQUNBO1FBQ0EsQ0FBUztNQUNUO0FBQ00sVUFBSSxNQUFNLE1BQU07QUFDZCxhQUFLLE9BQU87TUFDcEI7QUFDTSxXQUFLLFFBQVEsTUFBTTtBQUNuQixVQUFJLEtBQUssVUFBVSxNQUFNO0FBQ3ZCLGFBQUssTUFBTSxPQUFPO01BQzFCO0FBQ00sV0FBSyxVQUFVLE1BQU07QUFDckIsYUFBTztJQUNiO0FBQ0ksV0FBTztFQUNYOzs7Ozs7RUFPRSxPQUFRLGFBQWE7QUFDbkIsUUFBSSxDQUFDLEtBQUssU0FBUztBQUNqQixZQUFNOztRQUEyQyxLQUFLOztBQUV0RCxVQUFJLEtBQUssYUFBYSxLQUFLLGNBQWMsTUFBTTtBQUM3QyxlQUFPLFdBQVcsS0FBSztNQUMvQjtBQUNNLFdBQUssWUFBVztBQUNoQixxQkFBZSxZQUFZLFdBQVcsS0FBSyxHQUFHLFFBQVEsS0FBSyxHQUFHLE9BQU8sS0FBSyxNQUFNO0FBQ2hGLGtDQUE0QixhQUFhLFFBQVEsS0FBSyxTQUFTO0FBQy9ELFdBQUssUUFBUSxPQUFPLFdBQVc7SUFDckM7RUFDQTs7Ozs7RUFNRSxHQUFJLE9BQU8sV0FBVztBQUNwQixRQUFJLENBQUMsS0FBSyxTQUFTO0FBQ2pCLFlBQVksZUFBYztJQUNoQztBQUNJLFNBQUssUUFBUSxHQUFHLEtBQUs7QUFDckIsUUFBSSxXQUFXO0FBQ2Isb0JBQWMsT0FBTyxNQUFNLElBQUksR0FBRyxLQUFLLElBQUksS0FBSyxNQUFNLENBQUM7SUFDN0QsT0FBVztBQUNMLFdBQUssVUFBVSxJQUFJLGVBQWUsS0FBSyxNQUFNO0lBQ25EO0VBQ0E7Ozs7Ozs7Ozs7RUFXRSxNQUFPLFNBQVMsUUFBUTtBQUN0QixVQUFNLFNBQVMsU0FBUyxJQUFJLFNBQVMsS0FBSyxHQUFHLFFBQVEsS0FBSyxHQUFHLFFBQVEsU0FBUyxDQUFDLElBQUksS0FBSztBQUN4RixVQUFNLGNBQWMsS0FBSztBQUN6QixVQUFNLFlBQVksS0FBSztBQUN2QixVQUFNLE9BQVEsS0FBSyxRQUFRLE9BQU0sSUFBWSxTQUMxQyxXQUFXLE9BQU8sSUFBVztLQUM3QixnQkFBZ0IsT0FBTyxJQUFXO0tBQ2xDLGNBQWMsT0FBTyxJQUFXO0FBQ25DLFlBQVEsVUFBVSxJQUFJO0FBQ3RCLFFBQUksV0FBVyxNQUFNO0FBQ25CLGNBQVEsWUFBWSxNQUFNO0lBQ2hDO0FBQ0ksUUFBSSxnQkFBZ0IsTUFBTTtBQUN4QixjQUFRLGFBQWEsV0FBVztJQUN0QztBQUNJLFFBQUksV0FBVyxRQUFRLGdCQUFnQixNQUFNO0FBQzNDLFlBQU07O1FBQTJDLEtBQUs7O0FBQ3RELFVBQUksT0FBTyxVQUFVLFFBQVc7QUFDOUIsY0FBTSxhQUFhLE9BQU87QUFDMUIsWUFBSSxlQUFlLE1BQU07QUFHdkIsZ0JBQU0sT0FBTyxnQkFBZ0IsTUFBTTtBQUNuQyxrQkFBUSxnQkFBZ0IsSUFBSTtBQUM1QixrQkFBUSxZQUFZLElBQUk7UUFDbEMsT0FBZTtBQUNMLGtCQUFRLGdCQUFnQixLQUFLO0FBQzdCLGtCQUFRLFlBQVksV0FBVyxFQUFFO1FBQzNDO01BQ0EsV0FBaUIsT0FBTyxnQkFBZ0IsUUFBUTtBQUN4QyxnQkFBUSxnQkFBZ0IsSUFBSTtBQUM1QixnQkFBUSxZQUFZLE1BQU07TUFDbEMsV0FBaUIsT0FBTyxnQkFBZ0IsSUFBSTtBQUNwQyxnQkFBUSxnQkFBZ0IsS0FBSztBQUM3QixnQkFBUSxZQUFZLE1BQU07TUFDbEMsT0FBYTtBQUNMLFFBQU0sZUFBYztNQUM1QjtBQUNNLFVBQUksY0FBYyxNQUFNO0FBQ3RCLGdCQUFRLFlBQVksU0FBUztNQUNyQztJQUNBO0FBQ0ksU0FBSyxRQUFRLE1BQU0sU0FBUyxNQUFNO0VBQ3RDO0FBQ0E7QUFNTyxJQUFNLGtCQUFrQixDQUFDLFNBQVMsU0FBUyxZQUFZLE9BQWMsS0FBSyxFQUFFLE9BQU87QUFPbkYsSUFBTSxjQUFjO0VBQ3pCLE1BQU07QUFBRSxJQUFNLGVBQWM7RUFBRTs7RUFDOUI7O0VBQ0E7O0VBQ0E7O0VBQ0E7O0VBQ0E7O0VBQ0E7O0VBQ0E7O0VBQ0E7O0VBQ0E7O0VBQ0EsTUFBTTtBQUFFLElBQU0sZUFBYztFQUFFOztBQUNoQztBQ3pzQk8sSUFBTSxzQkFBc0I7QUFLNUIsSUFBTSxPQUFOLGNBQW1CLGVBQWU7RUFDdkMsSUFBSSxVQUFXO0FBQ2IsV0FBTztFQUNYO0VBRUUsU0FBVTtFQUFBOzs7OztFQU1WLFVBQVcsT0FBTztBQUNoQixRQUFJLEtBQUssZ0JBQWdCLE1BQU0sYUFBYTtBQUMxQyxhQUFPO0lBQ2I7QUFDSSxTQUFLLFVBQVUsTUFBTTtBQUNyQixXQUFPO0VBQ1g7Ozs7O0VBTUUsVUFBVyxhQUFhLFFBQVE7QUFFOUIsSUFBTSxlQUFjO0VBQ3hCOzs7OztFQU1FLE1BQU8sU0FBUyxRQUFRO0FBQ3RCLFlBQVEsVUFBVSxtQkFBbUI7QUFFckMsSUFBUyxhQUFhLFFBQVEsYUFBYSxLQUFLLFNBQVMsTUFBTTtFQUNuRTs7Ozs7O0VBT0UsV0FBWSxhQUFhLE9BQU87QUFDOUIsV0FBTztFQUNYO0FBQ0E7QUN3Q0EsSUFBTTs7RUFBMEIsT0FBTyxlQUFlLGNBQ2xELGFBQ0EsT0FBTyxXQUFXLGNBQ2hCLFNBRUEsT0FBTyxXQUFXLGNBQWMsU0FBUyxDQUFBOztBQUUvQyxJQUFNLG1CQUFtQjtBQUV6QixJQUFJLElBQUksZ0JBQWdCLE1BQU0sTUFBTTtBQWVsQyxVQUFRLE1BQU0sMkhBQTJIO0FBQzNJO0FBQ0EsSUFBSSxnQkFBZ0IsSUFBSTs7O0FDN0h4QixVQUFxQjtBQUdkLElBQU0saUJBQWlCLE1BQWM7QUFDMUMsU0FBTyxPQUFPLE9BQU8sV0FBVztBQUNsQztBQUVPLElBQU0sZUFBZSxNQUFjO0FBQ3hDLFNBQU8sT0FBTyxPQUFPLGdCQUFnQixJQUFJLFlBQVksQ0FBQyxDQUFDLEVBQUUsQ0FBQztBQUM1RDtBQUVPLElBQU0sdUJBQXVCLFdBQVk7QUFDOUMsU0FBTyxLQUFLLE9BQU8sRUFBRSxTQUFTLEVBQUUsRUFBRSxVQUFVLEdBQUcsQ0FBQztBQUNsRDtBQUVPLElBQU0sZ0JBQWdCLENBQUNFLFVBQWlCO0FBQUUsU0FBVyxRQUFJQSxPQUFNLEtBQU0sRUFBRSxTQUFTLEVBQUU7QUFBRTtBQUVwRixJQUFNLFlBQVksQ0FBQyxRQUFxQjtBQUM3QyxNQUFJLE1BQU0sUUFBUSxHQUFHLEdBQUc7QUFDdEIsV0FBTyxJQUFJLElBQUksSUFBSSxRQUFNLFVBQVUsRUFBRSxDQUFDLEVBQUUsS0FBSyxHQUFHO0FBQUEsRUFDbEQsV0FBVyxPQUFPLFFBQVEsWUFBWSxRQUFRLE1BQU07QUFDbEQsUUFBSSxNQUFNO0FBQ1YsVUFBTUMsUUFBTyxPQUFPLEtBQUssR0FBRyxFQUFFLEtBQUs7QUFDbkMsV0FBTyxJQUFJLEtBQUssVUFBVUEsS0FBSTtBQUM5QixhQUFTLElBQUksR0FBRyxJQUFJQSxNQUFLLFFBQVEsS0FBSztBQUNwQyxhQUFPLEdBQUcsVUFBVSxJQUFJQSxNQUFLLENBQUMsQ0FBQyxDQUFDO0FBQUEsSUFDbEM7QUFDQSxXQUFPLEdBQUc7QUFBQSxFQUNaO0FBQ0EsU0FBTyxHQUFHLEtBQUssVUFBVSxHQUFHO0FBQzlCOzs7QS9EM0JBLG1CQUE0Qjs7O0FnRUg1QixzQkFBNkU7QUFFN0UsSUFBTSxnQkFBTixjQUE0QixzQkFBTTtBQUFBLEVBS2pDLFlBQVksS0FBVSxPQUFlLFNBQWlCO0FBQ3JELFVBQU0sR0FBRztBQUNULFNBQUssVUFBVTtBQUNiLFNBQUssUUFBUTtBQUFBLEVBQ2hCO0FBQUEsRUFFQSxTQUFTO0FBQ1IsU0FBSyxRQUFRLFFBQVEsS0FBSyxLQUFLO0FBQy9CLFNBQUssVUFBVSxRQUFRLEtBQUssT0FBTztBQUFBLEVBQ3BDO0FBQUEsRUFFQSxVQUFVO0FBQ1QsU0FBSyxZQUFZLE1BQU07QUFBQSxFQUN4QjtBQUNEO0FBRU8sSUFBTSxnQkFBZ0IsQ0FBQyxLQUFVLE9BQWVDLFVBQWlCO0FBQ3RFLE1BQUksY0FBYyxLQUFLLE9BQU9BLEtBQUksRUFBRSxLQUFLO0FBQzNDO0FBRU8sSUFBTSxhQUFhLENBQUNBLE9BQWMsYUFBa0M7QUFDMUUsTUFBSSx1QkFBT0EsT0FBTSxRQUFRO0FBQzFCO0FBa0VPLElBQU0sbUJBQW1CLE9BQU8sTUFBYSxjQUF5QjtBQUMzRSxRQUFNLE9BQU8sVUFBVSxRQUFRLEtBQUs7QUFDcEMsUUFBTSxLQUFLLFNBQVMsSUFBSTtBQUN4QixTQUFPO0FBQ1Q7QUFJTyxJQUFNLFVBQVUsQ0FBQyxTQUF3QjtBQUM5QyxPQUFLLFVBQVUsSUFBSTtBQUNuQixhQUFXLGdCQUFnQixLQUFLLGVBQWUsSUFBSTtBQUNyRDtBQUVPLElBQU0sYUFBYTtBQUFBLEVBQ3hCLEVBQUUsTUFBTSxXQUFXLE9BQU8sWUFBWTtBQUFBLEVBQ3RDLEVBQUUsTUFBTSxXQUFXLE9BQU8sWUFBWTtBQUFBLEVBQ3RDLEVBQUUsTUFBTSxXQUFXLE9BQU8sWUFBWTtBQUFBLEVBQ3RDLEVBQUUsTUFBTSxXQUFXLE9BQU8sWUFBWTtBQUFBLEVBQ3RDLEVBQUUsTUFBTSxXQUFXLE9BQU8sWUFBWTtBQUFBLEVBQ3RDLEVBQUUsTUFBTSxXQUFXLE9BQU8sWUFBWTtBQUFBLEVBQ3RDLEVBQUUsTUFBTSxXQUFXLE9BQU8sWUFBWTtBQUFBLEVBQ3RDLEVBQUUsTUFBTSxXQUFXLE9BQU8sWUFBWTtBQUN4Qzs7O0FDbkhBLElBQUFDLFVBQXdCO0FBQ3hCLElBQUFDLFdBQXlCOzs7QUNEekIsY0FBeUI7QUFDekIsYUFBd0I7OztBQ0dqQixJQUFNLFNBQU4sTUFBYTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFLbEIsWUFBYSxTQUFTLE9BQU87QUFDM0IsU0FBSyxVQUFVO0FBQ2YsU0FBSyxRQUFRO0FBQUEsRUFDZjtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBS0EsU0FBVTtBQUNSLFdBQU87QUFBQSxNQUNMLFNBQVcsdUJBQXVCLEtBQUssT0FBTztBQUFBLE1BQzlDLE9BQVMsdUJBQXVCLEtBQUssS0FBSztBQUFBLElBQzVDO0FBQUEsRUFDRjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFNQSxPQUFPLFNBQVUsTUFBTTtBQUNyQixXQUFPLElBQUksT0FBUywrQkFBK0IsS0FBSyxPQUFPLEdBQUssK0JBQStCLEtBQUssS0FBSyxDQUFDO0FBQUEsRUFDaEg7QUFDRjs7O0FEM0JPLElBQU0sY0FBTixNQUFrQjtBQUFBLEVBQ3ZCLFlBQWEsT0FBTyxXQUFXO0FBQzdCLFNBQUssUUFBUTtBQUNiLFNBQUssWUFBWTtBQUNqQixTQUFLLGNBQWMsSUFBTSxZQUFZLEtBQUs7QUFBQSxFQUM1QztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBNkJBLE9BQVEsS0FBSyxRQUFRLEdBQUc7QUFDdEIsV0FBUyxvQ0FBb0MsS0FBSyxPQUFPLEtBQUssS0FBSztBQUFBLEVBQ3JFO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFLQSxTQUFVLE1BQU07QUFDZCxVQUFNLE1BQVEsMkNBQTZDLCtCQUErQixJQUFJLEdBQUcsS0FBSyxNQUFNLEdBQUc7QUFDL0csUUFBSSxPQUFPLFFBQVEsSUFBSSxTQUFTLEtBQUssT0FBTztBQUMxQyxZQUFNLElBQUksTUFBTSxzRkFBc0Y7QUFBQSxJQUN4RztBQUNBLFdBQU87QUFBQSxNQUNMLEtBQUssSUFBSTtBQUFBLE1BQ1QsT0FBTyxJQUFJO0FBQUEsSUFDYjtBQUFBLEVBQ0Y7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBTUEsU0FBVSxPQUFPO0FBQ2YsVUFBTSxRQUFRLE1BQU07QUFDcEIsVUFBTSxVQUFVLEtBQUssT0FBTyxNQUFNLFFBQVEsS0FBSztBQUMvQyxVQUFNLFFBQVEsS0FBSyxPQUFPLE1BQU0sTUFBTSxLQUFLO0FBQzNDLFdBQU8sSUFBSSxPQUFPLFNBQVMsS0FBSztBQUFBLEVBQ2xDO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFLQSxXQUFZLFFBQVE7QUFDbEIsVUFBTSxTQUFTLEtBQUssU0FBUyxPQUFPLE9BQU87QUFDM0MsVUFBTSxPQUFPLEtBQUssU0FBUyxPQUFPLEtBQUs7QUFDdkMsUUFBSSxPQUFPLFFBQVEsS0FBSyxLQUFLO0FBQzNCLGFBQWUsd0JBQWdCLE9BQU8sS0FBSyxLQUFLLEtBQUssS0FBSztBQUFBLElBQzVEO0FBQ0EsV0FBZSx3QkFBZ0IsTUFBTSxPQUFPLEtBQUssS0FBSyxHQUFHO0FBQUEsRUFDM0Q7QUFDRjtBQUtPLElBQU0sYUFBcUIsY0FBTSxPQUFPO0FBQUEsRUFDN0MsUUFBUyxRQUFRO0FBQ2YsV0FBTyxPQUFPLE9BQU8sU0FBUyxDQUFDO0FBQUEsRUFDakM7QUFDRixDQUFDO0FBS00sSUFBTSxrQkFBMEIsbUJBQVcsT0FBTztBQUt6RCxJQUFNLG1CQUFOLE1BQXVCO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJckIsWUFBYSxNQUFNO0FBQ2pCLFNBQUssT0FBTztBQUNaLFNBQUssT0FBTyxLQUFLLE1BQU0sTUFBTSxVQUFVO0FBQ3ZDLFNBQUssWUFBWSxDQUFDLE9BQU8sT0FBTztBQUM5QixVQUFJLEdBQUcsV0FBVyxLQUFLLE1BQU07QUFDM0IsY0FBTSxRQUFRLE1BQU07QUFDcEIsY0FBTSxVQUFVLENBQUM7QUFDakIsWUFBSSxNQUFNO0FBQ1YsaUJBQVMsSUFBSSxHQUFHLElBQUksTUFBTSxRQUFRLEtBQUs7QUFDckMsZ0JBQU0sSUFBSSxNQUFNLENBQUM7QUFDakIsY0FBSSxFQUFFLFVBQVUsTUFBTTtBQUNwQixvQkFBUSxLQUFLLEVBQUUsTUFBTSxLQUFLLElBQUksS0FBSyxRQUFRLEVBQUUsT0FBTyxDQUFDO0FBQUEsVUFDdkQsV0FBVyxFQUFFLFVBQVUsTUFBTTtBQUMzQixvQkFBUSxLQUFLLEVBQUUsTUFBTSxLQUFLLElBQUksTUFBTSxFQUFFLFFBQVEsUUFBUSxHQUFHLENBQUM7QUFDMUQsbUJBQU8sRUFBRTtBQUFBLFVBQ1gsT0FBTztBQUNMLG1CQUFPLEVBQUU7QUFBQSxVQUNYO0FBQUEsUUFDRjtBQUNBLGFBQUssU0FBUyxFQUFFLFNBQVMsYUFBYSxDQUFDLGdCQUFnQixHQUFHLEtBQUssSUFBSSxDQUFDLEVBQUUsQ0FBQztBQUFBLE1BQ3pFO0FBQUEsSUFDRjtBQUNBLFNBQUssU0FBUyxLQUFLLEtBQUs7QUFDeEIsU0FBSyxPQUFPLFFBQVEsS0FBSyxTQUFTO0FBQUEsRUFDcEM7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUtBLE9BQVEsUUFBUTtBQUNkLFFBQUksQ0FBQyxPQUFPLGNBQWUsT0FBTyxhQUFhLFNBQVMsS0FBSyxPQUFPLGFBQWEsQ0FBQyxFQUFFLFdBQVcsZUFBZSxNQUFNLEtBQUssTUFBTztBQUM5SDtBQUFBLElBQ0Y7QUFDQSxVQUFNLFFBQVEsS0FBSyxLQUFLO0FBQ3hCLFVBQU0sSUFBSSxTQUFTLE1BQU07QUFJdkIsVUFBSSxNQUFNO0FBQ1YsYUFBTyxRQUFRLFlBQVksQ0FBQyxPQUFPLEtBQUssT0FBTyxLQUFLLFdBQVc7QUFDN0QsY0FBTUMsY0FBYSxPQUFPLFlBQVksR0FBRyxPQUFPLFFBQVEsSUFBSTtBQUM1RCxZQUFJLFVBQVUsS0FBSztBQUNqQixnQkFBTSxPQUFPLFFBQVEsS0FBSyxNQUFNLEtBQUs7QUFBQSxRQUN2QztBQUNBLFlBQUlBLFlBQVcsU0FBUyxHQUFHO0FBQ3pCLGdCQUFNLE9BQU8sUUFBUSxLQUFLQSxXQUFVO0FBQUEsUUFDdEM7QUFDQSxlQUFPQSxZQUFXLFVBQVUsTUFBTTtBQUFBLE1BQ3BDLENBQUM7QUFBQSxJQUNILEdBQUcsS0FBSyxJQUFJO0FBQUEsRUFDZDtBQUFBLEVBRUEsVUFBVztBQUNULFNBQUssT0FBTyxVQUFVLEtBQUssU0FBUztBQUFBLEVBQ3RDO0FBQ0Y7QUFFTyxJQUFNLFFBQWUsa0JBQVcsVUFBVSxnQkFBZ0I7OztBRS9KakUsSUFBQUMsVUFBd0I7QUFFeEIsSUFBQUMsV0FBeUI7QUFRbEIsSUFBTSx5QkFBZ0MsbUJBQVcsVUFBVTtBQUFBLEVBQ2hFLGtCQUFrQixDQUNsQjtBQUFBLEVBQ0Esc0JBQXNCO0FBQUEsSUFDcEIsU0FBUztBQUFBLElBQ1QsUUFBUTtBQUFBLEVBQ1Y7QUFBQSxFQUNBLHVCQUF1QjtBQUFBLElBQ3JCLFVBQVU7QUFBQSxJQUNWLFlBQVk7QUFBQSxJQUNaLGFBQWE7QUFBQSxJQUNiLFlBQVk7QUFBQSxJQUNaLGFBQWE7QUFBQSxJQUNiLFdBQVc7QUFBQSxJQUNYLFNBQVM7QUFBQSxFQUNYO0FBQUEsRUFDQSwwQkFBMEI7QUFBQSxJQUN4QixjQUFjO0FBQUEsSUFDZCxVQUFVO0FBQUEsSUFDVixPQUFPO0FBQUEsSUFDUCxRQUFRO0FBQUEsSUFDUixLQUFLO0FBQUEsSUFDTCxNQUFNO0FBQUEsSUFDTixpQkFBaUI7QUFBQSxJQUNqQixZQUFZO0FBQUEsSUFDWixXQUFXO0FBQUEsRUFDYjtBQUFBLEVBQ0Esc0RBQXNEO0FBQUEsSUFDcEQsaUJBQWlCO0FBQUEsSUFDakIsV0FBVztBQUFBLEVBQ2I7QUFBQSxFQUNBLHNCQUFzQjtBQUFBLElBQ3BCLFVBQVU7QUFBQSxJQUNWLEtBQUs7QUFBQSxJQUNMLE1BQU07QUFBQSxJQUNOLFVBQVU7QUFBQSxJQUNWLFlBQVk7QUFBQSxJQUNaLFdBQVc7QUFBQSxJQUNYLFlBQVk7QUFBQSxJQUNaLFlBQVk7QUFBQSxJQUNaLFlBQVk7QUFBQSxJQUNaLE9BQU87QUFBQSxJQUNQLGFBQWE7QUFBQSxJQUNiLGNBQWM7QUFBQSxJQUNkLFFBQVE7QUFBQSxJQUNSLFlBQVk7QUFBQSxJQUNaLGlCQUFpQjtBQUFBO0FBQUEsSUFFakIsU0FBUztBQUFBLElBQ1QsaUJBQWlCO0FBQUEsSUFDakIsWUFBWTtBQUFBLEVBQ2Q7QUFBQSxFQUNBLGtEQUFrRDtBQUFBLElBQ2hELFNBQVM7QUFBQSxJQUNULGlCQUFpQjtBQUFBLEVBQ25CO0FBQ0YsQ0FBQztBQU1ELElBQU0sOEJBQXNDLG9CQUFXLE9BQU87QUFFOUQsSUFBTSxxQkFBTixjQUF3QyxtQkFBVztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFLakQsWUFBYSxPQUFPLE1BQU07QUFDeEIsVUFBTTtBQUNOLFNBQUssUUFBUTtBQUNiLFNBQUssT0FBTztBQUFBLEVBQ2Q7QUFBQSxFQUVBLFFBQVM7QUFDUDtBQUFBO0FBQUEsTUFBdUMsUUFBUSxRQUFRLENBQU1DLFFBQU8sU0FBUyxvQkFBb0IsR0FBUUEsUUFBTyxTQUFTLHFCQUFxQixLQUFLLHdCQUF3QixLQUFLLE9BQU8sQ0FBQyxHQUFHO0FBQUEsUUFDckwsS0FBSyxRQUFRO0FBQUEsUUFDYixRQUFRLE9BQU87QUFBQSxVQUNaQSxRQUFPLFNBQVMsdUJBQXVCO0FBQUEsUUFDOUMsQ0FBQztBQUFBLFFBQ0csS0FBSyxRQUFRO0FBQUEsUUFDYixRQUFRLE9BQU87QUFBQSxVQUNaQSxRQUFPLFNBQVMsbUJBQW1CO0FBQUEsUUFDMUMsR0FBRztBQUFBLFVBQ0csS0FBSyxLQUFLLElBQUk7QUFBQSxRQUNwQixDQUFDO0FBQUEsUUFDRyxLQUFLLFFBQVE7QUFBQSxNQUNuQixDQUFDO0FBQUE7QUFBQSxFQUNIO0FBQUEsRUFFQSxHQUFJLFFBQVE7QUFDVixXQUFPLE9BQU8sVUFBVSxLQUFLO0FBQUEsRUFDL0I7QUFBQSxFQUVBLFFBQVMsUUFBUTtBQUNmLFdBQU8sT0FBTyxVQUFVLEtBQUs7QUFBQSxFQUMvQjtBQUFBLEVBRUEsWUFBYTtBQUNYLFdBQU87QUFBQSxFQUNUO0FBQUEsRUFFQSxJQUFJLGtCQUFtQjtBQUFFLFdBQU87QUFBQSxFQUFHO0FBQUEsRUFFbkMsY0FBZTtBQUNiLFdBQU87QUFBQSxFQUNUO0FBQ0Y7QUFFTyxJQUFNLCtCQUFOLE1BQW1DO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJeEMsWUFBYSxNQUFNO0FBQ2pCLFNBQUssT0FBTyxLQUFLLE1BQU0sTUFBTSxVQUFVO0FBQ3ZDLFNBQUssWUFBWSxDQUFDLEVBQUUsT0FBTyxTQUFTLFFBQVEsR0FBRyxHQUFHLE1BQU07QUFDdEQsWUFBTSxVQUFVLE1BQU0sT0FBTyxPQUFPLEVBQUUsT0FBTyxPQUFPO0FBQ3BELFVBQUksUUFBUSxVQUFVLENBQUFDLFFBQU1BLFFBQU8sS0FBSyxLQUFLLFVBQVUsSUFBSSxRQUFRLEtBQUssR0FBRztBQUN6RSxhQUFLLFNBQVMsRUFBRSxhQUFhLENBQUMsNEJBQTRCLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDO0FBQUEsTUFDckU7QUFBQSxJQUNGO0FBQ0EsU0FBSyxhQUFhLEtBQUssS0FBSztBQUM1QixTQUFLLFdBQVcsR0FBRyxVQUFVLEtBQUssU0FBUztBQUkzQyxTQUFLLGNBQXNCLGtCQUFTLEdBQUcsQ0FBQyxDQUFDO0FBQUEsRUFDM0M7QUFBQSxFQUVBLFVBQVc7QUFDVCxTQUFLLFdBQVcsSUFBSSxVQUFVLEtBQUssU0FBUztBQUFBLEVBQzlDO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFLQSxPQUFRLFFBQVE7QUFDZCxVQUFNLFFBQVEsS0FBSyxLQUFLO0FBQ3hCLFVBQU07QUFBQTtBQUFBLE1BQTZCLE1BQU07QUFBQTtBQUN6QyxVQUFNLFlBQVksS0FBSyxLQUFLO0FBSTVCLFVBQU0sY0FBYyxDQUFDO0FBQ3JCLFVBQU0sc0JBQXNCLEtBQUssS0FBSyxVQUFVLGNBQWM7QUFHOUQsUUFBSSx1QkFBdUIsTUFBTTtBQUMvQixZQUFNLFdBQVcsT0FBTyxLQUFLLFlBQVksT0FBTyxLQUFLLElBQUksY0FBYyxTQUFTO0FBQ2hGLFlBQU0sTUFBTSxXQUFXLE9BQU8sTUFBTSxVQUFVLE9BQU87QUFDckQsWUFBTSxnQkFBZ0Isb0JBQW9CLFVBQVUsT0FBTyxPQUFTLCtCQUErQixvQkFBb0IsT0FBTyxNQUFNO0FBQ3BJLFlBQU0sY0FBYyxvQkFBb0IsVUFBVSxPQUFPLE9BQVMsK0JBQStCLG9CQUFvQixPQUFPLElBQUk7QUFFaEksVUFBSSxPQUFPLE1BQU07QUFDZixjQUFNLFNBQVcsb0NBQW9DLE9BQU8sSUFBSSxNQUFNO0FBQ3RFLGNBQU0sT0FBUyxvQ0FBb0MsT0FBTyxJQUFJLElBQUk7QUFDbEUsWUFBSSxvQkFBb0IsVUFBVSxRQUFRLENBQUcseUJBQXlCLGVBQWUsTUFBTSxLQUFLLENBQUcseUJBQXlCLGFBQWEsSUFBSSxHQUFHO0FBQzlJLG9CQUFVLG1CQUFtQixVQUFVO0FBQUEsWUFDckM7QUFBQSxZQUNBO0FBQUEsVUFDRixDQUFDO0FBQUEsUUFDSDtBQUFBLE1BQ0YsV0FBVyxvQkFBb0IsVUFBVSxRQUFRLFVBQVU7QUFDekQsa0JBQVUsbUJBQW1CLFVBQVUsSUFBSTtBQUFBLE1BQzdDO0FBQUEsSUFDRjtBQUdBLGNBQVUsVUFBVSxFQUFFLFFBQVEsQ0FBQyxPQUFPLGFBQWE7QUFDakQsVUFBSSxhQUFhLFVBQVUsSUFBSSxVQUFVO0FBQ3ZDO0FBQUEsTUFDRjtBQUNBLFlBQU0sU0FBUyxNQUFNO0FBQ3JCLFVBQUksVUFBVSxRQUFRLE9BQU8sVUFBVSxRQUFRLE9BQU8sUUFBUSxNQUFNO0FBQ2xFO0FBQUEsTUFDRjtBQUNBLFlBQU0sU0FBVywyQ0FBMkMsT0FBTyxRQUFRLElBQUk7QUFDL0UsWUFBTSxPQUFTLDJDQUEyQyxPQUFPLE1BQU0sSUFBSTtBQUMzRSxVQUFJLFVBQVUsUUFBUSxRQUFRLFFBQVEsT0FBTyxTQUFTLFNBQVMsS0FBSyxTQUFTLE9BQU87QUFDbEY7QUFBQSxNQUNGO0FBQ0EsWUFBTSxFQUFFLFFBQVEsV0FBVyxPQUFPLFlBQVksSUFBSSxNQUFNLFFBQVEsQ0FBQztBQUNqRSxZQUFNLGFBQWMsTUFBTSxRQUFRLE1BQU0sS0FBSyxjQUFlLFFBQVE7QUFDcEUsWUFBTSxRQUFhLElBQUksT0FBTyxPQUFPLEtBQUssS0FBSztBQUMvQyxZQUFNLE1BQVcsSUFBSSxPQUFPLE9BQU8sS0FBSyxLQUFLO0FBQzdDLFlBQU0sWUFBWSxPQUFPLEtBQUssTUFBTSxJQUFJLE9BQU8sS0FBSztBQUNwRCxZQUFNLFVBQVUsT0FBTyxLQUFLLE1BQU0sSUFBSSxPQUFPLEdBQUc7QUFDaEQsVUFBSSxVQUFVLFdBQVcsUUFBUSxRQUFRO0FBRXZDLG9CQUFZLEtBQUs7QUFBQSxVQUNmLE1BQU07QUFBQSxVQUNOLElBQUk7QUFBQSxVQUNKLE9BQWMsbUJBQVcsS0FBSztBQUFBLFlBQzVCLFlBQVksRUFBRSxPQUFPLHFCQUFxQixhQUFhO0FBQUEsWUFDdkQsT0FBTztBQUFBLFVBQ1QsQ0FBQztBQUFBLFFBQ0gsQ0FBQztBQUFBLE1BQ0gsT0FBTztBQUdMLG9CQUFZLEtBQUs7QUFBQSxVQUNmLE1BQU07QUFBQSxVQUNOLElBQUksVUFBVSxPQUFPLFVBQVU7QUFBQSxVQUMvQixPQUFjLG1CQUFXLEtBQUs7QUFBQSxZQUM1QixZQUFZLEVBQUUsT0FBTyxxQkFBcUIsYUFBYTtBQUFBLFlBQ3ZELE9BQU87QUFBQSxVQUNULENBQUM7QUFBQSxRQUNILENBQUM7QUFFRCxvQkFBWSxLQUFLO0FBQUEsVUFDZixNQUFNLFFBQVE7QUFBQSxVQUNkLElBQUk7QUFBQSxVQUNKLE9BQWMsbUJBQVcsS0FBSztBQUFBLFlBQzVCLFlBQVksRUFBRSxPQUFPLHFCQUFxQixhQUFhO0FBQUEsWUFDdkQsT0FBTztBQUFBLFVBQ1QsQ0FBQztBQUFBLFFBQ0gsQ0FBQztBQUNELGlCQUFTLElBQUksVUFBVSxTQUFTLEdBQUcsSUFBSSxRQUFRLFFBQVEsS0FBSztBQUMxRCxnQkFBTSxVQUFVLE9BQU8sS0FBSyxNQUFNLElBQUksS0FBSyxDQUFDLEVBQUU7QUFDOUMsc0JBQVksS0FBSztBQUFBLFlBQ2YsTUFBTTtBQUFBLFlBQ04sSUFBSTtBQUFBLFlBQ0osT0FBYyxtQkFBVyxLQUFLO0FBQUEsY0FDNUIsWUFBWSxFQUFFLE9BQU8scUJBQXFCLGNBQWMsT0FBTyxvQkFBb0I7QUFBQSxZQUNyRixDQUFDO0FBQUEsVUFDSCxDQUFDO0FBQUEsUUFDSDtBQUFBLE1BQ0Y7QUFDQSxrQkFBWSxLQUFLO0FBQUEsUUFDZixNQUFNLEtBQUs7QUFBQSxRQUNYLElBQUksS0FBSztBQUFBLFFBQ1QsT0FBYyxtQkFBVyxPQUFPO0FBQUEsVUFDOUIsTUFBTSxLQUFLLFFBQVEsT0FBTyxRQUFRLElBQUksS0FBSztBQUFBO0FBQUEsVUFDM0MsT0FBTztBQUFBLFVBQ1AsUUFBUSxJQUFJLG1CQUFtQixPQUFPLElBQUk7QUFBQSxRQUM1QyxDQUFDO0FBQUEsTUFDSCxDQUFDO0FBQUEsSUFDSCxDQUFDO0FBQ0QsU0FBSyxjQUFxQixtQkFBVyxJQUFJLGFBQWEsSUFBSTtBQUFBLEVBQzVEO0FBQ0Y7QUFFTyxJQUFNLG9CQUEyQixtQkFBVyxVQUFVLDhCQUE4QjtBQUFBLEVBQ3pGLGFBQWEsT0FBSyxFQUFFO0FBQ3RCLENBQUM7OztBQy9QRCxJQUFBQyxXQUF5QjtBQUV6QixJQUFBQyxVQUF3Qjs7O0FDeUJqQixJQUFNLGNBQWMsTUFBTTtBQUMvQixNQUFJLFFBQVE7QUFDWixTQUFPLENBQUMsR0FBRyxNQUFNO0FBQ2YsUUFBSSxPQUFPO0FBQ1QsY0FBUTtBQUNSLFVBQUk7QUFDRixVQUFFO0FBQUEsTUFDSixVQUFFO0FBQ0EsZ0JBQVE7QUFBQSxNQUNWO0FBQUEsSUFDRixXQUFXLE1BQU0sUUFBVztBQUMxQixRQUFFO0FBQUEsSUFDSjtBQUFBLEVBQ0Y7QUFDRjs7O0FEbENPLElBQU0scUJBQU4sTUFBeUI7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUk5QixZQUFhLGFBQWE7QUFDeEIsU0FBSyxjQUFjO0FBQUEsRUFDckI7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUtBLGlCQUFrQixRQUFRO0FBQ3hCLFNBQUssWUFBWSxpQkFBaUIsTUFBTTtBQUFBLEVBQzFDO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFLQSxvQkFBcUIsUUFBUTtBQUMzQixTQUFLLFlBQVksb0JBQW9CLE1BQU07QUFBQSxFQUM3QztBQUFBO0FBQUE7QUFBQTtBQUFBLEVBS0EsT0FBUTtBQUNOLFdBQU8sS0FBSyxZQUFZLEtBQUssS0FBSztBQUFBLEVBQ3BDO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFLQSxPQUFRO0FBQ04sV0FBTyxLQUFLLFlBQVksS0FBSyxLQUFLO0FBQUEsRUFDcEM7QUFDRjtBQUtPLElBQU0sb0JBQTRCLGVBQU0sT0FBTztBQUFBLEVBQ3BELFFBQVMsUUFBUTtBQUNmLFdBQU8sT0FBTyxPQUFPLFNBQVMsQ0FBQztBQUFBLEVBQ2pDO0FBQ0YsQ0FBQztBQUtNLElBQU0seUJBQWlDLG9CQUFXLE9BQU87QUFLaEUsSUFBTSwwQkFBTixNQUE4QjtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSTVCLFlBQWEsTUFBTTtBQUNqQixTQUFLLE9BQU87QUFDWixTQUFLLE9BQU8sS0FBSyxNQUFNLE1BQU0saUJBQWlCO0FBQzlDLFNBQUssZUFBZSxLQUFLLEtBQUs7QUFDOUIsU0FBSyxXQUFXLEtBQUssTUFBTSxNQUFNLFVBQVU7QUFJM0MsU0FBSyx5QkFBeUI7QUFDOUIsU0FBSyxPQUFPLFlBQVk7QUFFeEIsU0FBSyxvQkFBb0IsQ0FBQyxFQUFFLFdBQVcsbUJBQW1CLE1BQU07QUFFOUQsVUFBSSxtQkFBbUIsSUFBSSxLQUFLLFNBQVMsS0FBSyxLQUFLLEtBQUssMEJBQTBCLENBQUMsVUFBVSxLQUFLLElBQUksSUFBSSxHQUFHO0FBQzNHLGtCQUFVLEtBQUssSUFBSSxNQUFNLEtBQUssc0JBQXNCO0FBQUEsTUFDdEQ7QUFBQSxJQUNGO0FBQ0EsU0FBSyxxQkFBcUIsQ0FBQyxFQUFFLFVBQVUsTUFBTTtBQUMzQyxZQUFNLE1BQU0sVUFBVSxLQUFLLElBQUksSUFBSTtBQUNuQyxVQUFJLEtBQUs7QUFDUCxjQUFNLFlBQVksS0FBSyxTQUFTLFdBQVcsR0FBRztBQUM5QyxhQUFLLFNBQVMsS0FBSyxNQUFNLE9BQU8sRUFBRSxVQUFVLENBQUMsQ0FBQztBQUM5QyxhQUFLLGdCQUFnQjtBQUFBLE1BQ3ZCO0FBQUEsSUFDRjtBQUlBLFNBQUssa0JBQWtCLE1BQU07QUFFM0IsV0FBSyx5QkFBeUIsS0FBSyxTQUFTLFNBQVMsS0FBSyxLQUFLLE1BQU0sVUFBVSxJQUFJO0FBQUEsSUFDckY7QUFDQSxTQUFLLGFBQWEsR0FBRyxvQkFBb0IsS0FBSyxpQkFBaUI7QUFDL0QsU0FBSyxhQUFhLEdBQUcscUJBQXFCLEtBQUssa0JBQWtCO0FBQ2pFLFNBQUssYUFBYSxpQkFBaUIsS0FBSyxRQUFRO0FBQUEsRUFDbEQ7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUtBLE9BQVEsUUFBUTtBQUNkLFFBQUksT0FBTyxpQkFBaUIsT0FBTyxhQUFhLFdBQVcsS0FBSyxPQUFPLGFBQWEsQ0FBQyxFQUFFLFdBQVcsZUFBZSxNQUFNLEtBQUssV0FBVztBQUVySSxXQUFLLGdCQUFnQjtBQUFBLElBQ3ZCO0FBQUEsRUFDRjtBQUFBLEVBRUEsVUFBVztBQUNULFNBQUssYUFBYSxJQUFJLG9CQUFvQixLQUFLLGlCQUFpQjtBQUNoRSxTQUFLLGFBQWEsSUFBSSxxQkFBcUIsS0FBSyxrQkFBa0I7QUFDbEUsU0FBSyxhQUFhLG9CQUFvQixLQUFLLFFBQVE7QUFBQSxFQUNyRDtBQUNGO0FBQ08sSUFBTSxlQUFzQixtQkFBVyxVQUFVLHVCQUF1QjtBQUt4RSxJQUFNLE9BQU8sQ0FBQyxFQUFFLE9BQU8sU0FBUyxNQUNyQyxNQUFNLE1BQU0saUJBQWlCLEVBQUUsS0FBSyxLQUFLO0FBS3BDLElBQU0sT0FBTyxDQUFDLEVBQUUsT0FBTyxTQUFTLE1BQ3JDLE1BQU0sTUFBTSxpQkFBaUIsRUFBRSxLQUFLLEtBQUs7OztBSmpIcEMsSUFBTSxVQUFVLENBQUMsT0FBTyxXQUFXLEVBQUUsY0FBYyxJQUFNLFlBQVksS0FBSyxFQUFFLElBQUksQ0FBQyxNQUFNO0FBQzVGLFFBQU0sY0FBYyxJQUFJLFlBQVksT0FBTyxTQUFTO0FBQ3BELFFBQU0sVUFBVTtBQUFBLElBQ2QsV0FBVyxHQUFHLFdBQVc7QUFBQSxJQUN6QjtBQUFBLEVBQ0Y7QUFDQSxNQUFJLFdBQVc7QUFDYixZQUFRO0FBQUEsTUFDTjtBQUFBLE1BQ0E7QUFBQSxJQUNGO0FBQUEsRUFDRjtBQUNBLE1BQUksZ0JBQWdCLE9BQU87QUFFekIsWUFBUTtBQUFBLE1BQ04sa0JBQWtCLEdBQUcsSUFBSSxtQkFBbUIsV0FBVyxDQUFDO0FBQUEsTUFDeEQ7QUFBQSxNQUNPLG1CQUFXLGlCQUFpQjtBQUFBLFFBQ2pDLFlBQWEsR0FBRyxNQUFNO0FBQ3BCLGNBQUksRUFBRSxjQUFjO0FBQWUsbUJBQU8sS0FBSyxJQUFJO0FBQ25ELGNBQUksRUFBRSxjQUFjO0FBQWUsbUJBQU8sS0FBSyxJQUFJO0FBQ25ELGlCQUFPO0FBQUEsUUFDVDtBQUFBLE1BQ0YsQ0FBQztBQUFBLElBQ0g7QUFBQSxFQUNGO0FBQ0EsU0FBTztBQUNUOzs7QWpFckNBLElBQUFDLGdCQUE0Qjs7O0F1RUFyQixJQUFNLGtCQUFOLGNBQWdELGFBQTRCO0FBQUEsRUFBNUU7QUFBQTtBQUNMLFNBQVEsU0FBZ0MsQ0FBQztBQUFBO0FBQUEsRUFFbEMsSUFBSSxLQUFhLE9BQWM7QUFDcEMsVUFBTSxXQUFXLEtBQUssT0FBTyxHQUFHO0FBQ2hDLFNBQUssT0FBTyxHQUFHLElBQUk7QUFDbkIsUUFBSSxhQUFhLFFBQVc7QUFDMUIsV0FBSyxLQUFLLE9BQU8sQ0FBQyxLQUFLLEtBQUssQ0FBQztBQUFBLElBQy9CLFdBQVcsWUFBWSxPQUFPO0FBQzVCLFdBQUssS0FBSyxVQUFVLENBQUMsS0FBSyxVQUFVLEtBQUssQ0FBQztBQUFBLElBQzVDO0FBQUEsRUFDRjtBQUFBLEVBRU8sSUFBSSxLQUFhO0FBQ3RCLFdBQU8sS0FBSyxPQUFPLEdBQUc7QUFBQSxFQUN4QjtBQUFBLEVBRU8sT0FBTyxLQUFhO0FBQ3pCLFVBQU0sV0FBVyxLQUFLLE9BQU8sR0FBRztBQUNoQyxXQUFPLEtBQUssT0FBTyxHQUFHO0FBQ3RCLFNBQUssS0FBSyxVQUFVLENBQUMsS0FBSyxRQUFRLENBQUM7QUFBQSxFQUNyQztBQUFBLEVBRUEsSUFBVyxPQUFPO0FBQ2hCLFdBQU8sT0FBTyxLQUFLLEtBQUssTUFBTSxFQUFFO0FBQUEsRUFDbEM7QUFBQSxFQUVBLElBQVcsT0FBTztBQUNoQixXQUFPLE9BQU8sS0FBSyxLQUFLLE1BQU07QUFBQSxFQUNoQztBQUNGOzs7QUMvQk8sSUFBTSxnQkFBTixjQUF1QyxhQUFxQjtBQUFBLEVBSWpFLFlBQVlDLE9BQWMsV0FBb0I7QUFDNUMsVUFBTTtBQUNOLFNBQUssYUFBYSxXQUNsQixLQUFLLFFBQVFBO0FBQUEsRUFDZjtBQUFBLEVBRUEsSUFBSSxZQUFhO0FBQ2YsV0FBTyxLQUFLO0FBQUEsRUFDZDtBQUFBLEVBRUEsSUFBSSxVQUFXLE9BQWdCO0FBQzdCLFVBQU0sTUFBTSxLQUFLO0FBQ2pCLFNBQUssYUFBYTtBQUNsQixRQUFJLFNBQVMsS0FBSztBQUNoQixXQUFLLEtBQUssbUJBQW1CLENBQUMsS0FBSyxLQUFLLENBQUM7QUFBQSxJQUMzQztBQUFBLEVBQ0Y7QUFBQSxFQUVBLElBQUksT0FBTztBQUNULFdBQU8sS0FBSztBQUFBLEVBQ2Q7QUFBQSxFQUVBLElBQUksS0FBTSxPQUFlO0FBQ3ZCLFVBQU0sTUFBTSxLQUFLO0FBQ2pCLFNBQUssUUFBUTtBQUNiLFFBQUksU0FBUyxLQUFLO0FBQ2hCLFdBQUssS0FBSyxjQUFjLENBQUMsS0FBSyxLQUFLLENBQUM7QUFBQSxJQUN0QztBQUFBLEVBQ0Y7QUFFRjs7O0FDdkNBLElBQUFDLG1CQUF1RDtBQUVoRCxJQUFNLDJCQUEyQixDQUFDLElBQWUsUUFBd0M7QUFKaEc7QUFLRSxRQUFNLFFBQVEsR0FBRyxnQkFBZ0IsVUFBVTtBQUUzQyxRQUFNLGFBQWEsSUFBSTtBQUN2QixRQUFNLGtCQUFrQixNQUFNLElBQUksVUFBUTtBQUV4QyxXQUFPLEtBQUs7QUFBQSxFQUNkLENBQUM7QUFFRCxhQUFXLFFBQVEsT0FBTztBQUV4QixVQUFNLFNBQVMsS0FBSztBQUVwQixVQUFNLFlBQVksS0FBSyxLQUFLLFlBQVksYUFBYSxXQUFXLE1BQU07QUFDdEUsVUFBTUMsU0FBUSxnQkFBSyxLQUF3QixTQUE3QixtQkFBbUMsU0FBbkMsWUFBMkM7QUFFekQsUUFBSSxRQUFRLElBQUksSUFBSSxNQUFNO0FBQzFCLFFBQUksT0FBTztBQUNULFlBQU0sWUFBWTtBQUNsQixZQUFNLE9BQU9BO0FBQUEsSUFDZixPQUFPO0FBQ0wsY0FBUSxJQUFJLGNBQWNBLE9BQU0sU0FBUztBQUN6QyxVQUFJLElBQUksUUFBUSxLQUFLO0FBQUEsSUFDdkI7QUFBQSxFQUNGO0FBRUEsYUFBVyxhQUFhLFlBQVk7QUFDbEMsUUFBRyxDQUFDLGdCQUFnQixTQUFTLFNBQVMsR0FBRztBQUN2QyxVQUFJLE9BQU8sU0FBUztBQUFBLElBQ3RCO0FBQUEsRUFDRjtBQUVGO0FBRU8sSUFBTSxpQkFBaUIsQ0FBQ0EsT0FBYyxRQUF3QztBQUNuRixTQUFPLElBQUksS0FBSyxJQUFJLENBQUMsUUFBUTtBQUMzQixXQUFPLElBQUksSUFBSSxHQUFHO0FBQUEsRUFDcEIsQ0FBQyxFQUFFLE9BQU8sQ0FBQyxTQUFTO0FBQ2xCLFdBQU8sS0FBSyxTQUFTQTtBQUFBLEVBQ3ZCLENBQUM7QUFDSDtBQUVPLElBQU0sbUJBQW1CLENBQUNBLE9BQWMsUUFBd0M7QUFDckYsUUFBTSxxQkFBaUIsZ0NBQWNBLEtBQUk7QUFDekMsU0FBTyxJQUFJLEtBQUssT0FBTyxDQUFDLFFBQVE7QUFDOUIsZUFBTyxnQ0FBYyxJQUFJLElBQUksR0FBRyxFQUFFLElBQUksTUFBTTtBQUFBLEVBQzlDLENBQUM7QUFDSDs7O0FDckNBLElBQU0sdUJBQXVCO0FBQzdCLElBQU0sc0JBQXNCO0FBRTVCLElBQU0sMEJBQTBCO0FBS2hDLElBQU0sVUFBVSxDQUFDLGFBQWE7QUFDNUIsTUFBSSxTQUFTLGlCQUFpQixTQUFTLE9BQU8sTUFBTTtBQUNsRCxVQUFNLFlBQVksSUFBSSxVQUFVLFNBQVMsR0FBRztBQUM1QyxVQUFNLGFBQWEsU0FBUztBQUk1QixRQUFJLGNBQWM7QUFDbEIsUUFBSSxZQUFZO0FBQ2QsZ0JBQVUsYUFBYTtBQUFBLElBQ3pCO0FBQ0EsYUFBUyxLQUFLO0FBQ2QsYUFBUyxhQUFhO0FBQ3RCLGFBQVMsWUFBWTtBQUNyQixjQUFVLFlBQVksV0FBUztBQUM3QixlQUFTLHNCQUEyQixZQUFZO0FBQ2hELFlBQU0sT0FBTyxNQUFNO0FBQ25CLFlBQU0sVUFBVSxPQUFPLFNBQVMsV0FBVyxLQUFLLE1BQU0sSUFBSSxJQUFJO0FBQzlELFVBQUksV0FBVyxRQUFRLFNBQVMsUUFBUTtBQUN0QyxxQkFBYSxXQUFXO0FBQ3hCLHNCQUFjLFdBQVcsVUFBVSwwQkFBMEIsQ0FBQztBQUFBLE1BQ2hFO0FBQ0EsZUFBUyxLQUFLLFdBQVcsQ0FBQyxTQUFTLFFBQVEsQ0FBQztBQUFBLElBQzlDO0FBSUEsVUFBTSxVQUFVLFdBQVM7QUFDdkIsVUFBSSxTQUFTLE9BQU8sTUFBTTtBQUN4QixpQkFBUyxLQUFLO0FBQ2QsaUJBQVMsYUFBYTtBQUN0QixZQUFJLFNBQVMsV0FBVztBQUN0QixtQkFBUyxZQUFZO0FBQ3JCLG1CQUFTLEtBQUssY0FBYyxDQUFDLEVBQUUsTUFBTSxjQUFjLE1BQU0sR0FBRyxRQUFRLENBQUM7QUFBQSxRQUN2RSxPQUFPO0FBQ0wsbUJBQVM7QUFBQSxRQUNYO0FBS0EsbUJBQVcsU0FBYyxJQUFTLE1BQU0sU0FBUyx5QkFBeUIsQ0FBQyxJQUFJLHNCQUFzQixtQkFBbUIsR0FBRyxRQUFRO0FBQUEsTUFDckk7QUFDQSxtQkFBYSxXQUFXO0FBQUEsSUFDMUI7QUFDQSxVQUFNLFdBQVcsTUFBTTtBQUNyQixVQUFJLFNBQVMsT0FBTyxXQUFXO0FBQzdCLGlCQUFTLEtBQUs7QUFBQSxVQUNaLE1BQU07QUFBQSxRQUNSLENBQUM7QUFBQSxNQUNIO0FBQUEsSUFDRjtBQUNBLGNBQVUsVUFBVSxNQUFNLFFBQVEsSUFBSTtBQUN0QyxjQUFVLFVBQVUsV0FBUyxRQUFRLEtBQUs7QUFDMUMsY0FBVSxTQUFTLE1BQU07QUFDdkIsZUFBUyxzQkFBMkIsWUFBWTtBQUNoRCxlQUFTLGFBQWE7QUFDdEIsZUFBUyxZQUFZO0FBQ3JCLGVBQVMseUJBQXlCO0FBQ2xDLGVBQVMsS0FBSyxXQUFXLENBQUMsRUFBRSxNQUFNLFVBQVUsR0FBRyxRQUFRLENBQUM7QUFFeEQsb0JBQWMsV0FBVyxVQUFVLDBCQUEwQixDQUFDO0FBQUEsSUFDaEU7QUFBQSxFQUNGO0FBQ0Y7QUFNTyxJQUFNLGtCQUFOLGNBQThCLFdBQVc7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFNOUMsWUFBYSxLQUFLLEVBQUUsV0FBVyxJQUFJLENBQUMsR0FBRztBQUNyQyxVQUFNO0FBQ04sU0FBSyxNQUFNO0FBSVgsU0FBSyxLQUFLO0FBQ1YsU0FBSyxhQUFhLGNBQWM7QUFDaEMsU0FBSyxZQUFZO0FBQ2pCLFNBQUssYUFBYTtBQUNsQixTQUFLLHlCQUF5QjtBQUM5QixTQUFLLHNCQUFzQjtBQUszQixTQUFLLGdCQUFnQjtBQUNyQixTQUFLLGlCQUFpQixZQUFZLE1BQU07QUFDdEMsVUFBSSxLQUFLLGFBQWEsMEJBQStCLFlBQVksSUFBSSxLQUFLLHFCQUFxQjtBQUdwRSxRQUFDLEtBQUssR0FBSSxNQUFNO0FBQUEsTUFDM0M7QUFBQSxJQUNGLEdBQUcsMEJBQTBCLENBQUM7QUFDOUIsWUFBUSxJQUFJO0FBQUEsRUFDZDtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBS0EsS0FBTSxTQUFTO0FBQ2IsUUFBSSxLQUFLLElBQUk7QUFDWCxXQUFLLEdBQUcsS0FBSyxLQUFLLFVBQVUsT0FBTyxDQUFDO0FBQUEsSUFDdEM7QUFBQSxFQUNGO0FBQUEsRUFFQSxVQUFXO0FBQ1Qsa0JBQWMsS0FBSyxjQUFjO0FBQ2pDLFNBQUssV0FBVztBQUNoQixVQUFNLFFBQVE7QUFBQSxFQUNoQjtBQUFBLEVBRUEsYUFBYztBQUNaLFNBQUssZ0JBQWdCO0FBQ3JCLFFBQUksS0FBSyxPQUFPLE1BQU07QUFDcEIsV0FBSyxHQUFHLE1BQU07QUFBQSxJQUNoQjtBQUFBLEVBQ0Y7QUFBQSxFQUVBLFVBQVc7QUFDVCxTQUFLLGdCQUFnQjtBQUNyQixRQUFJLENBQUMsS0FBSyxhQUFhLEtBQUssT0FBTyxNQUFNO0FBQ3ZDLGNBQVEsSUFBSTtBQUFBLElBQ2Q7QUFBQSxFQUNGO0FBQ0Y7OztBQ3hIQSxJQUFNLFdBQVcsb0JBQUksSUFBSTtBQUd6QixJQUFNLHVCQUFOLE1BQTJCO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJekIsWUFBYSxNQUFNO0FBQ2pCLFNBQUssT0FBTztBQUlaLFNBQUssWUFBWTtBQUlqQixTQUFLLFlBQVksT0FBSyxFQUFFLFFBQVEsUUFBUSxLQUFLLGNBQWMsUUFBUSxLQUFLLFVBQVUsRUFBRSxNQUFhLFdBQVcsRUFBRSxZQUFZLEVBQUUsRUFBRSxDQUFDO0FBQy9ILElBQVEsU0FBUyxLQUFLLFNBQVM7QUFBQSxFQUNqQztBQUFBO0FBQUE7QUFBQTtBQUFBLEVBS0EsWUFBYSxLQUFLO0FBQ2hCLElBQVEsV0FBVyxRQUFRLEtBQUssTUFBYSxTQUFnQixnQ0FBZ0MsR0FBRyxDQUFDLENBQUM7QUFBQSxFQUNwRztBQUFBLEVBRUEsUUFBUztBQUNQLElBQVEsVUFBVSxLQUFLLFNBQVM7QUFBQSxFQUNsQztBQUNGO0FBS0EsSUFBTSxLQUFLLE9BQU8scUJBQXFCLGNBQWMsdUJBQXVCO0FBTTVFLElBQU0sYUFBYSxVQUNiLGVBQWUsVUFBVSxNQUFNLE1BQU07QUFDdkMsUUFBTSxPQUFXQyxRQUFPO0FBQ3hCLFFBQU0sS0FBSyxJQUFJLEdBQUcsSUFBSTtBQUt0QixLQUFHLFlBQVksT0FBSyxLQUFLLFFBQVEsU0FBTyxJQUFJLEVBQUUsTUFBTSxrQkFBa0IsQ0FBQztBQUN2RSxTQUFPO0FBQUEsSUFDTDtBQUFBLElBQUk7QUFBQSxFQUNOO0FBQ0YsQ0FBQztBQVNJLElBQU0sWUFBWSxDQUFDLE1BQU0sTUFBTTtBQUNwQyxhQUFXLElBQUksRUFBRSxLQUFLLElBQUksQ0FBQztBQUMzQixTQUFPO0FBQ1Q7QUFTTyxJQUFNLGNBQWMsQ0FBQyxNQUFNLE1BQU07QUFDdEMsUUFBTSxVQUFVLFdBQVcsSUFBSTtBQUMvQixRQUFNLGVBQWUsUUFBUSxLQUFLLE9BQU8sQ0FBQztBQUMxQyxNQUFJLGdCQUFnQixRQUFRLEtBQUssU0FBUyxHQUFHO0FBQzNDLFlBQVEsR0FBRyxNQUFNO0FBQ2pCLGFBQVMsT0FBTyxJQUFJO0FBQUEsRUFDdEI7QUFDQSxTQUFPO0FBQ1Q7QUFVTyxJQUFNLFVBQVUsQ0FBQyxNQUFNLE1BQU0sU0FBUyxTQUFTO0FBQ3BELFFBQU0sSUFBSSxXQUFXLElBQUk7QUFDekIsSUFBRSxHQUFHLFlBQVksSUFBSTtBQUNyQixJQUFFLEtBQUssUUFBUSxTQUFPLElBQUksTUFBTSxNQUFNLENBQUM7QUFDekM7OztBQ2xIQSw0QkFBaUI7OztBQ3NCVixJQUFNLHNCQUFzQjtBQUM1QixJQUFNLHNCQUFzQjtBQUM1QixJQUFNLG1CQUFtQjtBQVF6QixJQUFNLGlCQUFpQixDQUFDLFNBQVNDLFNBQVE7QUFDOUMsRUFBUyxhQUFhLFNBQVMsbUJBQW1CO0FBQ2xELFFBQU0sS0FBTyxrQkFBa0JBLElBQUc7QUFDbEMsRUFBUyxtQkFBbUIsU0FBUyxFQUFFO0FBQ3pDO0FBT08sSUFBTSxpQkFBaUIsQ0FBQyxTQUFTQSxNQUFLLHVCQUF1QjtBQUNsRSxFQUFTLGFBQWEsU0FBUyxtQkFBbUI7QUFDbEQsRUFBUyxtQkFBbUIsU0FBVyxvQkFBb0JBLE1BQUssa0JBQWtCLENBQUM7QUFDckY7QUFTTyxJQUFNLGdCQUFnQixDQUFDLFNBQVMsU0FBU0EsU0FDOUMsZUFBZSxTQUFTQSxNQUFjLGtCQUFrQixPQUFPLENBQUM7QUFTM0QsSUFBTSxnQkFBZ0IsQ0FBQyxTQUFTQSxNQUFLLHNCQUFzQjtBQUNoRSxNQUFJO0FBQ0YsSUFBRSxZQUFZQSxNQUFjLGtCQUFrQixPQUFPLEdBQUcsaUJBQWlCO0FBQUEsRUFDM0UsU0FBUyxPQUFQO0FBRUEsWUFBUSxNQUFNLDRDQUE0QyxLQUFLO0FBQUEsRUFDakU7QUFDRjtBQU1PLElBQU0sY0FBYyxDQUFDLFNBQVMsV0FBVztBQUM5QyxFQUFTLGFBQWEsU0FBUyxnQkFBZ0I7QUFDL0MsRUFBUyxtQkFBbUIsU0FBUyxNQUFNO0FBQzdDO0FBU08sSUFBTSxhQUFhO0FBUW5CLElBQU0sa0JBQWtCLENBQUMsU0FBUyxTQUFTQSxNQUFLLHNCQUFzQjtBQUMzRSxRQUFNLGNBQXVCLFlBQVksT0FBTztBQUNoRCxVQUFRLGFBQWE7QUFBQSxJQUNuQixLQUFLO0FBQ0gsb0JBQWMsU0FBUyxTQUFTQSxJQUFHO0FBQ25DO0FBQUEsSUFDRixLQUFLO0FBQ0gsb0JBQWMsU0FBU0EsTUFBSyxpQkFBaUI7QUFDN0M7QUFBQSxJQUNGLEtBQUs7QUFDSCxpQkFBVyxTQUFTQSxNQUFLLGlCQUFpQjtBQUMxQztBQUFBLElBQ0Y7QUFDRSxZQUFNLElBQUksTUFBTSxzQkFBc0I7QUFBQSxFQUMxQztBQUNBLFNBQU87QUFDVDs7O0FDckhPLElBQU0sa0JBQWtCO0FBMEJ4QixJQUFNLFlBQU4sY0FBd0IsV0FBVztBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXhDLFlBQWFDLE1BQUs7QUFDaEIsVUFBTTtBQUNOLFNBQUssTUFBTUE7QUFJWCxTQUFLLFdBQVdBLEtBQUk7QUFLcEIsU0FBSyxTQUFTLG9CQUFJLElBQUk7QUFJdEIsU0FBSyxPQUFPLG9CQUFJLElBQUk7QUFDcEIsU0FBSztBQUFBLElBQXFDLFlBQVksTUFBTTtBQUMxRCxZQUFNLE1BQVcsWUFBWTtBQUM3QixVQUFJLEtBQUssY0FBYyxNQUFNLFFBQVMsa0JBQWtCLEtBQUs7QUFBQSxNQUEyQyxLQUFLLEtBQUssSUFBSSxLQUFLLFFBQVEsRUFBRyxhQUFjO0FBRWxKLGFBQUssY0FBYyxLQUFLLGNBQWMsQ0FBQztBQUFBLE1BQ3pDO0FBSUEsWUFBTSxTQUFTLENBQUM7QUFDaEIsV0FBSyxLQUFLLFFBQVEsQ0FBQyxNQUFNLGFBQWE7QUFDcEMsWUFBSSxhQUFhLEtBQUssWUFBWSxtQkFBbUIsTUFBTSxLQUFLLGVBQWUsS0FBSyxPQUFPLElBQUksUUFBUSxHQUFHO0FBQ3hHLGlCQUFPLEtBQUssUUFBUTtBQUFBLFFBQ3RCO0FBQUEsTUFDRixDQUFDO0FBQ0QsVUFBSSxPQUFPLFNBQVMsR0FBRztBQUNyQiw4QkFBc0IsTUFBTSxRQUFRLFNBQVM7QUFBQSxNQUMvQztBQUFBLElBQ0YsR0FBUSxNQUFNLGtCQUFrQixFQUFFLENBQUM7QUFDbkMsSUFBQUEsS0FBSSxHQUFHLFdBQVcsTUFBTTtBQUN0QixXQUFLLFFBQVE7QUFBQSxJQUNmLENBQUM7QUFDRCxTQUFLLGNBQWMsQ0FBQyxDQUFDO0FBQUEsRUFDdkI7QUFBQSxFQUVBLFVBQVc7QUFDVCxTQUFLLEtBQUssV0FBVyxDQUFDLElBQUksQ0FBQztBQUMzQixTQUFLLGNBQWMsSUFBSTtBQUN2QixVQUFNLFFBQVE7QUFDZCxrQkFBYyxLQUFLLGNBQWM7QUFBQSxFQUNuQztBQUFBO0FBQUE7QUFBQTtBQUFBLEVBS0EsZ0JBQWlCO0FBQ2YsV0FBTyxLQUFLLE9BQU8sSUFBSSxLQUFLLFFBQVEsS0FBSztBQUFBLEVBQzNDO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFLQSxjQUFlLE9BQU87QUFDcEIsVUFBTSxXQUFXLEtBQUs7QUFDdEIsVUFBTSxnQkFBZ0IsS0FBSyxLQUFLLElBQUksUUFBUTtBQUM1QyxVQUFNLFFBQVEsa0JBQWtCLFNBQVksSUFBSSxjQUFjLFFBQVE7QUFDdEUsVUFBTSxZQUFZLEtBQUssT0FBTyxJQUFJLFFBQVE7QUFDMUMsUUFBSSxVQUFVLE1BQU07QUFDbEIsV0FBSyxPQUFPLE9BQU8sUUFBUTtBQUFBLElBQzdCLE9BQU87QUFDTCxXQUFLLE9BQU8sSUFBSSxVQUFVLEtBQUs7QUFBQSxJQUNqQztBQUNBLFNBQUssS0FBSyxJQUFJLFVBQVU7QUFBQSxNQUN0QjtBQUFBLE1BQ0EsYUFBa0IsWUFBWTtBQUFBLElBQ2hDLENBQUM7QUFDRCxVQUFNLFFBQVEsQ0FBQztBQUNmLFVBQU0sVUFBVSxDQUFDO0FBQ2pCLFVBQU0sa0JBQWtCLENBQUM7QUFDekIsVUFBTSxVQUFVLENBQUM7QUFDakIsUUFBSSxVQUFVLE1BQU07QUFDbEIsY0FBUSxLQUFLLFFBQVE7QUFBQSxJQUN2QixXQUFXLGFBQWEsTUFBTTtBQUM1QixVQUFJLFNBQVMsTUFBTTtBQUNqQixjQUFNLEtBQUssUUFBUTtBQUFBLE1BQ3JCO0FBQUEsSUFDRixPQUFPO0FBQ0wsY0FBUSxLQUFLLFFBQVE7QUFDckIsVUFBSSxDQUFHLGFBQWEsV0FBVyxLQUFLLEdBQUc7QUFDckMsd0JBQWdCLEtBQUssUUFBUTtBQUFBLE1BQy9CO0FBQUEsSUFDRjtBQUNBLFFBQUksTUFBTSxTQUFTLEtBQUssZ0JBQWdCLFNBQVMsS0FBSyxRQUFRLFNBQVMsR0FBRztBQUN4RSxXQUFLLEtBQUssVUFBVSxDQUFDLEVBQUUsT0FBTyxTQUFTLGlCQUFpQixRQUFRLEdBQUcsT0FBTyxDQUFDO0FBQUEsSUFDN0U7QUFDQSxTQUFLLEtBQUssVUFBVSxDQUFDLEVBQUUsT0FBTyxTQUFTLFFBQVEsR0FBRyxPQUFPLENBQUM7QUFBQSxFQUM1RDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFNQSxtQkFBb0IsT0FBTyxPQUFPO0FBQ2hDLFVBQU0sUUFBUSxLQUFLLGNBQWM7QUFDakMsUUFBSSxVQUFVLE1BQU07QUFDbEIsV0FBSyxjQUFjO0FBQUEsUUFDakIsR0FBRztBQUFBLFFBQ0gsQ0FBQyxLQUFLLEdBQUc7QUFBQSxNQUNYLENBQUM7QUFBQSxJQUNIO0FBQUEsRUFDRjtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBS0EsWUFBYTtBQUNYLFdBQU8sS0FBSztBQUFBLEVBQ2Q7QUFDRjtBQVVPLElBQU0sd0JBQXdCLENBQUMsV0FBVyxTQUFTLFdBQVc7QUFDbkUsUUFBTSxVQUFVLENBQUM7QUFDakIsV0FBUyxJQUFJLEdBQUcsSUFBSSxRQUFRLFFBQVEsS0FBSztBQUN2QyxVQUFNLFdBQVcsUUFBUSxDQUFDO0FBQzFCLFFBQUksVUFBVSxPQUFPLElBQUksUUFBUSxHQUFHO0FBQ2xDLGdCQUFVLE9BQU8sT0FBTyxRQUFRO0FBQ2hDLFVBQUksYUFBYSxVQUFVLFVBQVU7QUFDbkMsY0FBTTtBQUFBO0FBQUEsVUFBMEMsVUFBVSxLQUFLLElBQUksUUFBUTtBQUFBO0FBQzNFLGtCQUFVLEtBQUssSUFBSSxVQUFVO0FBQUEsVUFDM0IsT0FBTyxRQUFRLFFBQVE7QUFBQSxVQUN2QixhQUFrQixZQUFZO0FBQUEsUUFDaEMsQ0FBQztBQUFBLE1BQ0g7QUFDQSxjQUFRLEtBQUssUUFBUTtBQUFBLElBQ3ZCO0FBQUEsRUFDRjtBQUNBLE1BQUksUUFBUSxTQUFTLEdBQUc7QUFDdEIsY0FBVSxLQUFLLFVBQVUsQ0FBQyxFQUFFLE9BQU8sQ0FBQyxHQUFHLFNBQVMsQ0FBQyxHQUFHLFFBQVEsR0FBRyxNQUFNLENBQUM7QUFDdEUsY0FBVSxLQUFLLFVBQVUsQ0FBQyxFQUFFLE9BQU8sQ0FBQyxHQUFHLFNBQVMsQ0FBQyxHQUFHLFFBQVEsR0FBRyxNQUFNLENBQUM7QUFBQSxFQUN4RTtBQUNGO0FBT08sSUFBTSx3QkFBd0IsQ0FBQyxXQUFXLFNBQVMsU0FBUyxVQUFVLFdBQVc7QUFDdEYsUUFBTSxNQUFNLFFBQVE7QUFDcEIsUUFBTSxVQUFtQixjQUFjO0FBQ3ZDLEVBQVMsYUFBYSxTQUFTLEdBQUc7QUFDbEMsV0FBUyxJQUFJLEdBQUcsSUFBSSxLQUFLLEtBQUs7QUFDNUIsVUFBTSxXQUFXLFFBQVEsQ0FBQztBQUMxQixVQUFNLFFBQVEsT0FBTyxJQUFJLFFBQVEsS0FBSztBQUN0QyxVQUFNO0FBQUE7QUFBQSxNQUF3QyxVQUFVLEtBQUssSUFBSSxRQUFRLEVBQUc7QUFBQTtBQUM1RSxJQUFTLGFBQWEsU0FBUyxRQUFRO0FBQ3ZDLElBQVMsYUFBYSxTQUFTLEtBQUs7QUFDcEMsSUFBUyxlQUFlLFNBQVMsS0FBSyxVQUFVLEtBQUssQ0FBQztBQUFBLEVBQ3hEO0FBQ0EsU0FBZ0IsYUFBYSxPQUFPO0FBQ3RDO0FBa0NPLElBQU0sdUJBQXVCLENBQUMsV0FBVyxRQUFRLFdBQVc7QUFDakUsUUFBTSxVQUFtQixjQUFjLE1BQU07QUFDN0MsUUFBTSxZQUFpQixZQUFZO0FBQ25DLFFBQU0sUUFBUSxDQUFDO0FBQ2YsUUFBTSxVQUFVLENBQUM7QUFDakIsUUFBTSxrQkFBa0IsQ0FBQztBQUN6QixRQUFNLFVBQVUsQ0FBQztBQUNqQixRQUFNLE1BQWUsWUFBWSxPQUFPO0FBQ3hDLFdBQVMsSUFBSSxHQUFHLElBQUksS0FBSyxLQUFLO0FBQzVCLFVBQU0sV0FBb0IsWUFBWSxPQUFPO0FBQzdDLFFBQUksUUFBaUIsWUFBWSxPQUFPO0FBQ3hDLFVBQU0sUUFBUSxLQUFLLE1BQWUsY0FBYyxPQUFPLENBQUM7QUFDeEQsVUFBTSxhQUFhLFVBQVUsS0FBSyxJQUFJLFFBQVE7QUFDOUMsVUFBTSxZQUFZLFVBQVUsT0FBTyxJQUFJLFFBQVE7QUFDL0MsVUFBTSxZQUFZLGVBQWUsU0FBWSxJQUFJLFdBQVc7QUFDNUQsUUFBSSxZQUFZLFNBQVUsY0FBYyxTQUFTLFVBQVUsUUFBUSxVQUFVLE9BQU8sSUFBSSxRQUFRLEdBQUk7QUFDbEcsVUFBSSxVQUFVLE1BQU07QUFFbEIsWUFBSSxhQUFhLFVBQVUsWUFBWSxVQUFVLGNBQWMsS0FBSyxNQUFNO0FBR3hFO0FBQUEsUUFDRixPQUFPO0FBQ0wsb0JBQVUsT0FBTyxPQUFPLFFBQVE7QUFBQSxRQUNsQztBQUFBLE1BQ0YsT0FBTztBQUNMLGtCQUFVLE9BQU8sSUFBSSxVQUFVLEtBQUs7QUFBQSxNQUN0QztBQUNBLGdCQUFVLEtBQUssSUFBSSxVQUFVO0FBQUEsUUFDM0I7QUFBQSxRQUNBLGFBQWE7QUFBQSxNQUNmLENBQUM7QUFDRCxVQUFJLGVBQWUsVUFBYSxVQUFVLE1BQU07QUFDOUMsY0FBTSxLQUFLLFFBQVE7QUFBQSxNQUNyQixXQUFXLGVBQWUsVUFBYSxVQUFVLE1BQU07QUFDckQsZ0JBQVEsS0FBSyxRQUFRO0FBQUEsTUFDdkIsV0FBVyxVQUFVLE1BQU07QUFDekIsWUFBSSxDQUFHLGFBQWEsT0FBTyxTQUFTLEdBQUc7QUFDckMsMEJBQWdCLEtBQUssUUFBUTtBQUFBLFFBQy9CO0FBQ0EsZ0JBQVEsS0FBSyxRQUFRO0FBQUEsTUFDdkI7QUFBQSxJQUNGO0FBQUEsRUFDRjtBQUNBLE1BQUksTUFBTSxTQUFTLEtBQUssZ0JBQWdCLFNBQVMsS0FBSyxRQUFRLFNBQVMsR0FBRztBQUN4RSxjQUFVLEtBQUssVUFBVSxDQUFDO0FBQUEsTUFDeEI7QUFBQSxNQUFPLFNBQVM7QUFBQSxNQUFpQjtBQUFBLElBQ25DLEdBQUcsTUFBTSxDQUFDO0FBQUEsRUFDWjtBQUNBLE1BQUksTUFBTSxTQUFTLEtBQUssUUFBUSxTQUFTLEtBQUssUUFBUSxTQUFTLEdBQUc7QUFDaEUsY0FBVSxLQUFLLFVBQVUsQ0FBQztBQUFBLE1BQ3hCO0FBQUEsTUFBTztBQUFBLE1BQVM7QUFBQSxJQUNsQixHQUFHLE1BQU0sQ0FBQztBQUFBLEVBQ1o7QUFDRjs7O0FDelJPLElBQU0sWUFBWSxDQUFDLFFBQVEsYUFBYTtBQUM3QyxRQUFNLGVBQXNCLFdBQVcsTUFBTSxFQUFFO0FBQy9DLFFBQU0sT0FBYyxXQUFXLFFBQVEsRUFBRTtBQUN6QyxTQUFPLE9BQU8sT0FBTztBQUFBLElBQ25CO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQSxDQUFDLFdBQVc7QUFBQSxFQUNkLEVBQUU7QUFBQSxJQUFLLGlCQUNMLE9BQU8sT0FBTztBQUFBLE1BQ1o7QUFBQSxRQUNFLE1BQU07QUFBQSxRQUNOO0FBQUEsUUFDQSxZQUFZO0FBQUEsUUFDWixNQUFNO0FBQUEsTUFDUjtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsUUFDRSxNQUFNO0FBQUEsUUFDTixRQUFRO0FBQUEsTUFDVjtBQUFBLE1BQ0E7QUFBQSxNQUNBLENBQUMsV0FBVyxTQUFTO0FBQUEsSUFDdkI7QUFBQSxFQUNGO0FBQ0Y7QUFPTyxJQUFNLFVBQVUsQ0FBQyxNQUFNLFFBQVE7QUFDcEMsTUFBSSxDQUFDLEtBQUs7QUFDUjtBQUFBO0FBQUEsTUFBdUQsUUFBUSxJQUFJO0FBQUE7QUFBQSxFQUNyRTtBQUNBLFFBQU0sS0FBSyxPQUFPLGdCQUFnQixJQUFJLFdBQVcsRUFBRSxDQUFDO0FBQ3BELFNBQU8sT0FBTyxPQUFPO0FBQUEsSUFDbkI7QUFBQSxNQUNFLE1BQU07QUFBQSxNQUNOO0FBQUEsSUFDRjtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsRUFDRixFQUFFLEtBQUssWUFBVTtBQUNmLFVBQU0sdUJBQWdDLGNBQWM7QUFDcEQsSUFBUyxlQUFlLHNCQUFzQixTQUFTO0FBQ3ZELElBQVMsbUJBQW1CLHNCQUFzQixFQUFFO0FBQ3BELElBQVMsbUJBQW1CLHNCQUFzQixJQUFJLFdBQVcsTUFBTSxDQUFDO0FBQ3hFLFdBQWdCLGFBQWEsb0JBQW9CO0FBQUEsRUFDbkQsQ0FBQztBQUNIO0FBT08sSUFBTSxjQUFjLENBQUMsTUFBTSxRQUFRO0FBQ3hDLFFBQU0sY0FBdUIsY0FBYztBQUMzQyxFQUFTLFNBQVMsYUFBYSxJQUFJO0FBQ25DLFNBQU8sUUFBaUIsYUFBYSxXQUFXLEdBQUcsR0FBRztBQUN4RDtBQU9PLElBQU0sVUFBVSxDQUFDLE1BQU0sUUFBUTtBQUNwQyxNQUFJLENBQUMsS0FBSztBQUNSO0FBQUE7QUFBQSxNQUF1RCxRQUFRLElBQUk7QUFBQTtBQUFBLEVBQ3JFO0FBQ0EsUUFBTSxjQUF1QixjQUFjLElBQUk7QUFDL0MsUUFBTSxZQUFxQixjQUFjLFdBQVc7QUFDcEQsTUFBSSxjQUFjLFdBQVc7QUFDM0IsSUFBUSxPQUFhQyxRQUFPLDhCQUE4QixDQUFDO0FBQUEsRUFDN0Q7QUFDQSxRQUFNLEtBQWMsa0JBQWtCLFdBQVc7QUFDakQsUUFBTSxTQUFrQixrQkFBa0IsV0FBVztBQUNyRCxTQUFPLE9BQU8sT0FBTztBQUFBLElBQ25CO0FBQUEsTUFDRSxNQUFNO0FBQUEsTUFDTjtBQUFBLElBQ0Y7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLEVBQ0YsRUFBRSxLQUFLLENBQUFDLFVBQVEsSUFBSSxXQUFXQSxLQUFJLENBQUM7QUFDckM7QUFPTyxJQUFNLGNBQWMsQ0FBQyxNQUFNLFFBQ2hDLFFBQVEsTUFBTSxHQUFHLEVBQUU7QUFBQSxFQUFLLG9CQUNiLFFBQWlCLGNBQWMsSUFBSSxXQUFXLGNBQWMsQ0FBQyxDQUFDO0FBQ3pFOzs7QUgxRkYsSUFBTSxNQUFjQyxvQkFBbUIsVUFBVTtBQUVqRCxJQUFNLGNBQWM7QUFDcEIsSUFBTSx3QkFBd0I7QUFDOUIsSUFBTSxtQkFBbUI7QUFDekIsSUFBTSxrQkFBa0I7QUFLeEIsSUFBTSxpQkFBaUIsb0JBQUksSUFBSTtBQUsvQixJQUFNLFFBQVEsb0JBQUksSUFBSTtBQUt0QixJQUFNLGdCQUFnQixVQUFRO0FBQzVCLE1BQUksU0FBUztBQUNiLE9BQUssWUFBWSxRQUFRLFVBQVE7QUFDL0IsUUFBSSxDQUFDLEtBQUssUUFBUTtBQUNoQixlQUFTO0FBQUEsSUFDWDtBQUFBLEVBQ0YsQ0FBQztBQUNELE1BQUssQ0FBQyxVQUFVLEtBQUssVUFBWSxVQUFVLENBQUMsS0FBSyxRQUFTO0FBQ3hELFNBQUssU0FBUztBQUNkLFNBQUssU0FBUyxLQUFLLFVBQVUsQ0FBQyxFQUFFLE9BQU8sQ0FBQyxDQUFDO0FBQ3pDLFFBQUksV0FBbUIsTUFBTSxLQUFLLE1BQWMsUUFBUSxpQkFBaUI7QUFBQSxFQUMzRTtBQUNGO0FBUUEsSUFBTSxjQUFjLENBQUMsTUFBTSxLQUFLLG1CQUFtQjtBQUNqRCxRQUFNLFVBQW1CLGNBQWMsR0FBRztBQUMxQyxRQUFNLFVBQW1CLGNBQWM7QUFDdkMsUUFBTSxjQUF1QixZQUFZLE9BQU87QUFDaEQsTUFBSSxTQUFTLFFBQVc7QUFDdEIsV0FBTztBQUFBLEVBQ1Q7QUFDQSxRQUFNLFlBQVksS0FBSztBQUN2QixRQUFNQyxPQUFNLEtBQUs7QUFDakIsTUFBSSxZQUFZO0FBQ2hCLFVBQVEsYUFBYTtBQUFBLElBQ25CLEtBQUssYUFBYTtBQUNoQixNQUFTLGFBQWEsU0FBUyxXQUFXO0FBQzFDLFlBQU0sa0JBQStCLGdCQUFnQixTQUFTLFNBQVNBLE1BQUssSUFBSTtBQUNoRixVQUFJLG9CQUFpQyx1QkFBdUIsQ0FBQyxLQUFLLFFBQVE7QUFDeEUsdUJBQWU7QUFBQSxNQUNqQjtBQUNBLFVBQUksb0JBQWlDLHFCQUFxQjtBQUN4RCxvQkFBWTtBQUFBLE1BQ2Q7QUFDQTtBQUFBLElBQ0Y7QUFBQSxJQUNBLEtBQUs7QUFDSCxNQUFTLGFBQWEsU0FBUyxnQkFBZ0I7QUFDL0MsTUFBUyxtQkFBbUIsU0FBMkIsc0JBQXNCLFdBQVcsTUFBTSxLQUFLLFVBQVUsVUFBVSxFQUFFLEtBQUssQ0FBQyxDQUFDLENBQUM7QUFDakksa0JBQVk7QUFDWjtBQUFBLElBQ0YsS0FBSztBQUNILE1BQWtCLHFCQUFxQixXQUFvQixrQkFBa0IsT0FBTyxHQUFHLElBQUk7QUFDM0Y7QUFBQSxJQUNGLEtBQUssaUJBQWlCO0FBQ3BCLFlBQU1DLE9BQWUsVUFBVSxPQUFPLE1BQU07QUFDNUMsWUFBTSxXQUFvQixjQUFjLE9BQU87QUFDL0MsVUFBSSxhQUFhLEtBQUssV0FBWSxLQUFLLFFBQVEsSUFBSSxRQUFRLEtBQUssQ0FBQ0EsUUFBUyxDQUFDLEtBQUssUUFBUSxJQUFJLFFBQVEsS0FBS0EsT0FBTztBQUM5RyxjQUFNLFVBQVUsQ0FBQztBQUNqQixjQUFNLFFBQVEsQ0FBQztBQUNmLFlBQUlBLE1BQUs7QUFDUCxlQUFLLFFBQVEsSUFBSSxRQUFRO0FBQ3pCLGdCQUFNLEtBQUssUUFBUTtBQUFBLFFBQ3JCLE9BQU87QUFDTCxlQUFLLFFBQVEsT0FBTyxRQUFRO0FBQzVCLGtCQUFRLEtBQUssUUFBUTtBQUFBLFFBQ3ZCO0FBQ0EsYUFBSyxTQUFTLEtBQUssU0FBUyxDQUFDO0FBQUEsVUFDM0I7QUFBQSxVQUNBO0FBQUEsVUFDQSxhQUFhLE1BQU0sS0FBSyxLQUFLLFlBQVksS0FBSyxDQUFDO0FBQUEsVUFDL0MsU0FBUyxNQUFNLEtBQUssS0FBSyxPQUFPO0FBQUEsUUFDbEMsQ0FBQyxDQUFDO0FBQ0YsMEJBQWtCLElBQUk7QUFBQSxNQUN4QjtBQUNBO0FBQUEsSUFDRjtBQUFBLElBQ0E7QUFDRSxjQUFRLE1BQU0sMkJBQTJCO0FBQ3pDLGFBQU87QUFBQSxFQUNYO0FBQ0EsTUFBSSxDQUFDLFdBQVc7QUFFZCxXQUFPO0FBQUEsRUFDVDtBQUNBLFNBQU87QUFDVDtBQU9BLElBQU0sa0JBQWtCLENBQUMsVUFBVSxRQUFRO0FBQ3pDLFFBQU0sT0FBTyxTQUFTO0FBQ3RCLE1BQUksMEJBQWtDLE1BQU0sU0FBUyxjQUFzQixNQUFNLE1BQU0sS0FBSyxNQUFNLEtBQWEsUUFBZ0IsT0FBTztBQUN0SSxTQUFPLFlBQVksTUFBTSxLQUFLLE1BQU07QUFDbEMsYUFBUyxTQUFTO0FBQ2xCLFFBQUksV0FBbUIsTUFBTSxLQUFLLE1BQWMsUUFBUSxVQUFrQixNQUFNLFNBQVMsWUFBWTtBQUNyRyxrQkFBYyxJQUFJO0FBQUEsRUFDcEIsQ0FBQztBQUNIO0FBTUEsSUFBTSxpQkFBaUIsQ0FBQyxZQUFZLFlBQVk7QUFDOUMsTUFBSSxvQkFBNEIsTUFBTSxXQUFXLGNBQXNCLFFBQWdCLE1BQU0sTUFBTSxXQUFXLEtBQUssTUFBTSxLQUFhLE9BQU87QUFDN0ksTUFBSTtBQUNGLGVBQVcsS0FBSyxLQUFjLGFBQWEsT0FBTyxDQUFDO0FBQUEsRUFDckQsU0FBUyxHQUFQO0FBQUEsRUFBVztBQUNmO0FBTUEsSUFBTSxzQkFBc0IsQ0FBQyxNQUFNLE1BQU07QUFDdkMsTUFBSSx5QkFBaUMsTUFBTSxLQUFLLE1BQWMsTUFBTTtBQUNwRSxPQUFLLFlBQVksUUFBUSxVQUFRO0FBQy9CLFFBQUk7QUFDRixXQUFLLEtBQUssS0FBSyxDQUFDO0FBQUEsSUFDbEIsU0FBUyxHQUFQO0FBQUEsSUFBVztBQUFBLEVBQ2YsQ0FBQztBQUNIO0FBRU8sSUFBTSxhQUFOLE1BQWlCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFPdEIsWUFBYSxlQUFlLFdBQVcsY0FBYyxNQUFNO0FBQ3pELFFBQUksK0JBQXVDLE1BQU0sWUFBWTtBQUM3RCxTQUFLLE9BQU87QUFDWixTQUFLLGVBQWU7QUFDcEIsU0FBSyxhQUFhO0FBQ2xCLFNBQUssU0FBUztBQUNkLFNBQUssWUFBWTtBQUNqQixTQUFLLFNBQVM7QUFJZCxTQUFLLE9BQU8sSUFBSSxzQkFBQUMsUUFBSyxFQUFFLFdBQVcsR0FBRyxLQUFLLFNBQVMsU0FBUyxDQUFDO0FBQzdELFNBQUssS0FBSyxHQUFHLFVBQVUsWUFBVTtBQUMvQixVQUFJLEtBQUssZUFBZSxRQUFXO0FBRWpDLGFBQUssYUFBYSxLQUFLLElBQUksSUFBSSxLQUFLLE9BQU87QUFBQSxNQUM3QztBQUNBLDhCQUF3QixlQUFlLE1BQU0sRUFBRSxJQUFJLGNBQWMsTUFBTSxLQUFLLFFBQVEsTUFBTSxVQUFVLE9BQU8sS0FBSyxZQUFZLE9BQU8sQ0FBQztBQUFBLElBQ3RJLENBQUM7QUFDRCxTQUFLLEtBQUssR0FBRyxXQUFXLE1BQU07QUFDNUIsVUFBSSxpQkFBeUIsTUFBTSxZQUFZO0FBQy9DLFdBQUssWUFBWTtBQUVqQixZQUFNLFdBQVcsS0FBSztBQUN0QixZQUFNRixPQUFNLFNBQVM7QUFDckIsWUFBTSxZQUFZLEtBQUs7QUFDdkIsWUFBTSxVQUFtQixjQUFjO0FBQ3ZDLE1BQVMsYUFBYSxTQUFTLFdBQVc7QUFDMUMsTUFBYSxlQUFlLFNBQVNBLElBQUc7QUFDeEMscUJBQWUsTUFBTSxPQUFPO0FBQzVCLFlBQU0sa0JBQWtCLFVBQVUsVUFBVTtBQUM1QyxVQUFJLGdCQUFnQixPQUFPLEdBQUc7QUFDNUIsY0FBTUcsV0FBbUIsY0FBYztBQUN2QyxRQUFTLGFBQWFBLFVBQVMsZ0JBQWdCO0FBQy9DLFFBQVMsbUJBQW1CQSxVQUEyQixzQkFBc0IsV0FBVyxNQUFNLEtBQUssZ0JBQWdCLEtBQUssQ0FBQyxDQUFDLENBQUM7QUFDM0gsdUJBQWUsTUFBTUEsUUFBTztBQUFBLE1BQzlCO0FBQUEsSUFDRixDQUFDO0FBQ0QsU0FBSyxLQUFLLEdBQUcsU0FBUyxNQUFNO0FBQzFCLFdBQUssWUFBWTtBQUNqQixXQUFLLFNBQVM7QUFDZCxVQUFJLEtBQUssWUFBWSxJQUFJLEtBQUssWUFBWSxHQUFHO0FBQzNDLGFBQUssWUFBWSxPQUFPLEtBQUssWUFBWTtBQUN6QyxhQUFLLFNBQVMsS0FBSyxTQUFTLENBQUM7QUFBQSxVQUMzQixTQUFTLENBQUMsS0FBSyxZQUFZO0FBQUEsVUFDM0IsT0FBTyxDQUFDO0FBQUEsVUFDUixhQUFhLE1BQU0sS0FBSyxLQUFLLFlBQVksS0FBSyxDQUFDO0FBQUEsVUFDL0MsU0FBUyxNQUFNLEtBQUssS0FBSyxPQUFPO0FBQUEsUUFDbEMsQ0FBQyxDQUFDO0FBQUEsTUFDSjtBQUNBLG9CQUFjLElBQUk7QUFDbEIsV0FBSyxLQUFLLFFBQVE7QUFDbEIsVUFBSSx5QkFBaUMsTUFBTSxZQUFZO0FBQ3ZELDRCQUFzQixJQUFJO0FBQUEsSUFDNUIsQ0FBQztBQUNELFNBQUssS0FBSyxHQUFHLFNBQVMsU0FBTztBQUMzQixVQUFJLDJCQUFtQyxNQUFNLGNBQWMsTUFBTSxHQUFHO0FBQ3BFLDRCQUFzQixJQUFJO0FBQUEsSUFDNUIsQ0FBQztBQUNELFNBQUssS0FBSyxHQUFHLFFBQVEsVUFBUTtBQUMzQixZQUFNLFNBQVMsZ0JBQWdCLE1BQU0sSUFBSTtBQUN6QyxVQUFJLFdBQVcsTUFBTTtBQUNuQix1QkFBZSxNQUFNLE1BQU07QUFBQSxNQUM3QjtBQUFBLElBQ0YsQ0FBQztBQUFBLEVBQ0g7QUFBQSxFQUVBLFVBQVc7QUFDVCxTQUFLLEtBQUssUUFBUTtBQUFBLEVBQ3BCO0FBQ0Y7QUFNQSxJQUFNLHFCQUFxQixDQUFDLE1BQU0sTUFBa0IsUUFBUSxHQUFHLEtBQUssR0FBRyxFQUFFO0FBQUEsRUFBSyxVQUM1RSxLQUFLO0FBQUEsSUFBSSxNQUNKLFFBQVEsS0FBSyxNQUFNLElBQUk7QUFBQSxFQUM1QjtBQUNGO0FBTUEsSUFBTSx1QkFBdUIsQ0FBQyxNQUFNLE1BQU07QUFDeEMsTUFBSSxLQUFLLGFBQWE7QUFDcEIsdUJBQW1CLE1BQU0sQ0FBQztBQUFBLEVBQzVCO0FBQ0Esc0JBQW9CLE1BQU0sQ0FBQztBQUM3QjtBQUtBLElBQU0sd0JBQXdCLFVBQVE7QUFDcEMsaUJBQWUsUUFBUSxVQUFRO0FBRTdCLFFBQUksS0FBSyxXQUFXO0FBQ2xCLFdBQUssS0FBSyxFQUFFLE1BQU0sYUFBYSxRQUFRLENBQUMsS0FBSyxJQUFJLEVBQUUsQ0FBQztBQUNwRCxVQUFJLEtBQUssWUFBWSxPQUFPLEtBQUssU0FBUyxVQUFVO0FBQ2xELGdDQUF3QixNQUFNLE1BQU0sRUFBRSxNQUFNLFlBQVksTUFBTSxLQUFLLE9BQU8sQ0FBQztBQUFBLE1BQzdFO0FBQUEsSUFDRjtBQUFBLEVBQ0YsQ0FBQztBQUNIO0FBS0EsSUFBTSxvQkFBb0IsVUFBUTtBQUNoQyxNQUFJLEtBQUssU0FBUyxlQUFlO0FBRS9CLFVBQU0sa0JBQTJCLGNBQWM7QUFDL0MsSUFBUyxhQUFhLGlCQUFpQixlQUFlO0FBQ3RELElBQVMsV0FBVyxpQkFBaUIsQ0FBQztBQUN0QyxJQUFTLGVBQWUsaUJBQWlCLEtBQUssTUFBTTtBQUNwRCx1QkFBbUIsTUFBZSxhQUFhLGVBQWUsQ0FBQztBQUFBLEVBQ2pFO0FBQ0Y7QUFFTyxJQUFNLE9BQU4sTUFBVztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBT2hCLFlBQWFILE1BQUssVUFBVSxNQUFNLEtBQUs7QUFNckMsU0FBSyxTQUFnQixPQUFPO0FBQzVCLFNBQUssTUFBTUE7QUFJWCxTQUFLLFlBQVksU0FBUztBQUMxQixTQUFLLFdBQVc7QUFDaEIsU0FBSyxTQUFTO0FBQ2QsU0FBSyxPQUFPO0FBRVosU0FBSyxNQUFNO0FBSVgsU0FBSyxjQUFjLG9CQUFJLElBQUk7QUFJM0IsU0FBSyxVQUFVLG9CQUFJLElBQUk7QUFDdkIsU0FBSyxNQUFNLFlBQVk7QUFDdkIsU0FBSyxjQUFjO0FBSW5CLFNBQUssZ0JBQWdCLFVBQ1AsUUFBUSxJQUFJLFdBQVcsSUFBSSxHQUFHLEdBQUcsRUFBRTtBQUFBLE1BQUssT0FDbEQsS0FBSyxJQUFJLE1BQU07QUFDYixjQUFNLFFBQVEsWUFBWSxNQUFNLEdBQUcsTUFBTTtBQUFBLFFBQUMsQ0FBQztBQUMzQyxZQUFJLE9BQU87QUFDVCw2QkFBbUIsTUFBZSxhQUFhLEtBQUssQ0FBQztBQUFBLFFBQ3ZEO0FBQUEsTUFDRixDQUFDO0FBQUEsSUFDSDtBQU9GLFNBQUssb0JBQW9CLENBQUMsUUFBUSxXQUFXO0FBQzNDLFlBQU0sVUFBbUIsY0FBYztBQUN2QyxNQUFTLGFBQWEsU0FBUyxXQUFXO0FBQzFDLE1BQWEsWUFBWSxTQUFTLE1BQU07QUFDeEMsMkJBQXFCLE1BQWUsYUFBYSxPQUFPLENBQUM7QUFBQSxJQUMzRDtBQU9BLFNBQUssMEJBQTBCLENBQUMsRUFBRSxPQUFPLFNBQVMsUUFBUSxHQUFHLFdBQVc7QUFDdEUsWUFBTSxpQkFBaUIsTUFBTSxPQUFPLE9BQU8sRUFBRSxPQUFPLE9BQU87QUFDM0QsWUFBTSxtQkFBNEIsY0FBYztBQUNoRCxNQUFTLGFBQWEsa0JBQWtCLGdCQUFnQjtBQUN4RCxNQUFTLG1CQUFtQixrQkFBb0Msc0JBQXNCLEtBQUssV0FBVyxjQUFjLENBQUM7QUFDckgsMkJBQXFCLE1BQWUsYUFBYSxnQkFBZ0IsQ0FBQztBQUFBLElBQ3BFO0FBRUEsU0FBSyx1QkFBdUIsTUFBTTtBQUNoQyxNQUFrQixzQkFBc0IsS0FBSyxXQUFXLENBQUNBLEtBQUksUUFBUSxHQUFHLGVBQWU7QUFDdkYsWUFBTSxRQUFRLFVBQVE7QUFDcEIsYUFBSyxXQUFXO0FBQUEsTUFDbEIsQ0FBQztBQUFBLElBQ0g7QUFFQSxRQUFJLE9BQU8sV0FBVyxhQUFhO0FBQ2pDLGFBQU8saUJBQWlCLGdCQUFnQixLQUFLLG9CQUFvQjtBQUFBLElBQ25FLFdBQVcsT0FBTyxZQUFZLGFBQWE7QUFDekMsY0FBUSxHQUFHLFFBQVEsS0FBSyxvQkFBb0I7QUFBQSxJQUM5QztBQUFBLEVBQ0Y7QUFBQSxFQUVBLFVBQVc7QUFDVCxTQUFLLElBQUksR0FBRyxVQUFVLEtBQUssaUJBQWlCO0FBQzVDLFNBQUssVUFBVSxHQUFHLFVBQVUsS0FBSyx1QkFBdUI7QUFFeEQsMEJBQXNCLElBQUk7QUFDMUIsVUFBTSxXQUFXLEtBQUs7QUFDdEIsSUFBRyxVQUFVLFVBQVUsS0FBSyxhQUFhO0FBQ3pDLFNBQUssY0FBYztBQUVuQixzQkFBa0IsSUFBSTtBQUV0QixVQUFNLGNBQXVCLGNBQWM7QUFDM0MsSUFBUyxhQUFhLGFBQWEsV0FBVztBQUM5QyxJQUFhLGVBQWUsYUFBYSxLQUFLLEdBQUc7QUFDakQsdUJBQW1CLE1BQWUsYUFBYSxXQUFXLENBQUM7QUFFM0QsVUFBTSxlQUF3QixjQUFjO0FBQzVDLElBQVMsYUFBYSxjQUFjLFdBQVc7QUFDL0MsSUFBYSxlQUFlLGNBQWMsS0FBSyxHQUFHO0FBQ2xELHVCQUFtQixNQUFlLGFBQWEsWUFBWSxDQUFDO0FBRTVELFVBQU0sd0JBQWlDLGNBQWM7QUFDckQsSUFBUyxhQUFhLHVCQUF1QixxQkFBcUI7QUFDbEUsdUJBQW1CLE1BQWUsYUFBYSxxQkFBcUIsQ0FBQztBQUVyRSxVQUFNLHdCQUFpQyxjQUFjO0FBQ3JELElBQVMsYUFBYSx1QkFBdUIsZ0JBQWdCO0FBQzdELElBQVMsbUJBQW1CLHVCQUF5QyxzQkFBc0IsS0FBSyxXQUFXLENBQUMsS0FBSyxJQUFJLFFBQVEsQ0FBQyxDQUFDO0FBQy9ILHVCQUFtQixNQUFlLGFBQWEscUJBQXFCLENBQUM7QUFBQSxFQUN2RTtBQUFBLEVBRUEsYUFBYztBQUVaLG1CQUFlLFFBQVEsVUFBUTtBQUM3QixVQUFJLEtBQUssV0FBVztBQUNsQixhQUFLLEtBQUssRUFBRSxNQUFNLGVBQWUsUUFBUSxDQUFDLEtBQUssSUFBSSxFQUFFLENBQUM7QUFBQSxNQUN4RDtBQUFBLElBQ0YsQ0FBQztBQUNELElBQWtCLHNCQUFzQixLQUFLLFdBQVcsQ0FBQyxLQUFLLElBQUksUUFBUSxHQUFHLFlBQVk7QUFFekYsVUFBTSxrQkFBMkIsY0FBYztBQUMvQyxJQUFTLGFBQWEsaUJBQWlCLGVBQWU7QUFDdEQsSUFBUyxXQUFXLGlCQUFpQixDQUFDO0FBQ3RDLElBQVMsZUFBZSxpQkFBaUIsS0FBSyxNQUFNO0FBQ3BELHVCQUFtQixNQUFlLGFBQWEsZUFBZSxDQUFDO0FBRS9ELElBQUcsWUFBWSxLQUFLLE1BQU0sS0FBSyxhQUFhO0FBQzVDLFNBQUssY0FBYztBQUNuQixTQUFLLElBQUksSUFBSSxVQUFVLEtBQUssaUJBQWlCO0FBQzdDLFNBQUssVUFBVSxJQUFJLFVBQVUsS0FBSyx1QkFBdUI7QUFDekQsU0FBSyxZQUFZLFFBQVEsVUFBUSxLQUFLLFFBQVEsQ0FBQztBQUFBLEVBQ2pEO0FBQUEsRUFFQSxVQUFXO0FBQ1QsU0FBSyxXQUFXO0FBQ2hCLFFBQUksT0FBTyxXQUFXLGFBQWE7QUFDakMsYUFBTyxvQkFBb0IsZ0JBQWdCLEtBQUssb0JBQW9CO0FBQUEsSUFDdEUsV0FBVyxPQUFPLFlBQVksYUFBYTtBQUN6QyxjQUFRLElBQUksUUFBUSxLQUFLLG9CQUFvQjtBQUFBLElBQy9DO0FBQUEsRUFDRjtBQUNGO0FBU0EsSUFBTSxXQUFXLENBQUNBLE1BQUssVUFBVSxNQUFNLFFBQVE7QUFFN0MsTUFBSSxNQUFNLElBQUksSUFBSSxHQUFHO0FBQ25CLFVBQVlJLFFBQU8sZ0NBQWdDLHVCQUF1QjtBQUFBLEVBQzVFO0FBQ0EsUUFBTSxPQUFPLElBQUksS0FBS0osTUFBSyxVQUFVLE1BQU0sR0FBRztBQUM5QyxRQUFNO0FBQUEsSUFBSTtBQUFBO0FBQUEsSUFBMkI7QUFBQSxFQUFLO0FBQzFDLFNBQU87QUFDVDtBQU9BLElBQU0sMEJBQTBCLENBQUMsTUFBTSxNQUFNLFNBQVM7QUFDcEQsTUFBSSxLQUFLLEtBQUs7QUFDWixJQUFZLFlBQVksTUFBTSxLQUFLLEdBQUcsRUFBRSxLQUFLLENBQUFLLFVBQVE7QUFDbkQsV0FBSyxLQUFLLEVBQUUsTUFBTSxXQUFXLE9BQU8sS0FBSyxNQUFNLE1BQWEsU0FBU0EsS0FBSSxFQUFFLENBQUM7QUFBQSxJQUM5RSxDQUFDO0FBQUEsRUFDSCxPQUFPO0FBQ0wsU0FBSyxLQUFLLEVBQUUsTUFBTSxXQUFXLE9BQU8sS0FBSyxNQUFNLEtBQUssQ0FBQztBQUFBLEVBQ3ZEO0FBQ0Y7QUFFTyxJQUFNLGdCQUFOLGNBQStCLGdCQUFnQjtBQUFBLEVBQ3BELFlBQWEsS0FBSztBQUNoQixVQUFNLEdBQUc7QUFJVCxTQUFLLFlBQVksb0JBQUksSUFBSTtBQUN6QixTQUFLLEdBQUcsV0FBVyxNQUFNO0FBQ3ZCLFVBQUksY0FBYyxNQUFNO0FBQ3hCLFlBQU0sU0FBUyxNQUFNLEtBQUssTUFBTSxLQUFLLENBQUM7QUFDdEMsV0FBSyxLQUFLLEVBQUUsTUFBTSxhQUFhLE9BQU8sQ0FBQztBQUN2QyxZQUFNO0FBQUEsUUFBUSxVQUNaLHdCQUF3QixNQUFNLE1BQU0sRUFBRSxNQUFNLFlBQVksTUFBTSxLQUFLLE9BQU8sQ0FBQztBQUFBLE1BQzdFO0FBQUEsSUFDRixDQUFDO0FBQ0QsU0FBSyxHQUFHLFdBQVcsT0FBSztBQUN0QixjQUFRLEVBQUUsTUFBTTtBQUFBLFFBQ2QsS0FBSyxXQUFXO0FBQ2QsZ0JBQU0sV0FBVyxFQUFFO0FBQ25CLGdCQUFNLE9BQU8sTUFBTSxJQUFJLFFBQVE7QUFDL0IsY0FBSSxRQUFRLFFBQVEsT0FBTyxhQUFhLFVBQVU7QUFDaEQ7QUFBQSxVQUNGO0FBQ0EsZ0JBQU0sY0FBYyxVQUFRO0FBQzFCLGtCQUFNLGNBQWMsS0FBSztBQUN6QixrQkFBTSxTQUFTLEtBQUs7QUFDcEIsZ0JBQUksUUFBUSxRQUFRLEtBQUssU0FBUyxVQUFXLEtBQUssT0FBTyxVQUFhLEtBQUssT0FBTyxVQUFXLEtBQUssUUFBUSxJQUFJLEtBQUssSUFBSSxHQUFHO0FBRXhIO0FBQUEsWUFDRjtBQUNBLGtCQUFNLGlCQUFpQixZQUFZLElBQUksS0FBSyxJQUFJLElBQzVDLE1BQU07QUFBQSxZQUFDLElBQ1AsTUFDQSxLQUFLLFNBQVMsS0FBSyxTQUFTLENBQUM7QUFBQSxjQUMzQixTQUFTLENBQUM7QUFBQSxjQUNWLE9BQU8sQ0FBQyxLQUFLLElBQUk7QUFBQSxjQUNqQixhQUFhLE1BQU0sS0FBSyxLQUFLLFlBQVksS0FBSyxDQUFDO0FBQUEsY0FDL0MsU0FBUyxNQUFNLEtBQUssS0FBSyxPQUFPO0FBQUEsWUFDbEMsQ0FBQyxDQUFDO0FBQ04sb0JBQVEsS0FBSyxNQUFNO0FBQUEsY0FDakIsS0FBSztBQUNILG9CQUFJLFlBQVksT0FBTyxLQUFLLFNBQVMsVUFBVTtBQUM3QyxrQkFBSSxlQUFlLGFBQWEsS0FBSyxNQUFNLE1BQU0sSUFBSSxXQUFXLE1BQU0sTUFBTSxLQUFLLE1BQU0sSUFBSSxDQUFDO0FBQzVGLGlDQUFlO0FBQUEsZ0JBQ2pCO0FBQ0E7QUFBQSxjQUNGLEtBQUs7QUFDSCxvQkFBSSxLQUFLLE9BQU8sU0FBUyxTQUFTO0FBQ2hDLHdCQUFNLGVBQWUsWUFBWSxJQUFJLEtBQUssSUFBSTtBQUM5QyxzQkFBSSxjQUFjO0FBQ2hCLDBCQUFNLGNBQWMsS0FBSztBQUN6QiwwQkFBTSxhQUFhLGFBQWE7QUFDaEMsd0JBQUksY0FBYyxhQUFhLGFBQWE7QUFDMUMsMEJBQUksb0JBQW9CLEtBQUssSUFBSTtBQUNqQztBQUFBLG9CQUNGO0FBRUEsaUNBQWEsYUFBYTtBQUFBLGtCQUM1QjtBQUFBLGdCQUNGO0FBQ0Esb0JBQUksS0FBSyxPQUFPLFNBQVMsVUFBVTtBQUNqQyxzQkFBSSx1QkFBdUIsS0FBSyxJQUFJO0FBQ3BDLHdCQUFNLGVBQWUsWUFBWSxJQUFJLEtBQUssSUFBSTtBQUM5QywrQkFBYSxhQUFhO0FBQUEsZ0JBQzVCO0FBQ0Esb0JBQUksS0FBSyxPQUFPLFFBQVE7QUFDdEIsa0JBQUksZUFBZSxhQUFhLEtBQUssTUFBTSxNQUFNLElBQUksV0FBVyxNQUFNLE9BQU8sS0FBSyxNQUFNLElBQUksQ0FBQyxFQUFFLEtBQUssT0FBTyxLQUFLLE1BQU07QUFDdEgsaUNBQWU7QUFBQSxnQkFDakI7QUFDQTtBQUFBLFlBQ0o7QUFBQSxVQUNGO0FBQ0EsY0FBSSxLQUFLLEtBQUs7QUFDWixnQkFBSSxPQUFPLEVBQUUsU0FBUyxVQUFVO0FBQzlCLGNBQVksWUFBbUIsV0FBVyxFQUFFLElBQUksR0FBRyxLQUFLLEdBQUcsRUFBRSxLQUFLLFdBQVc7QUFBQSxZQUMvRTtBQUFBLFVBQ0YsT0FBTztBQUNMLHdCQUFZLEVBQUUsSUFBSTtBQUFBLFVBQ3BCO0FBQUEsUUFDRjtBQUFBLE1BQ0Y7QUFBQSxJQUNGLENBQUM7QUFDRCxTQUFLLEdBQUcsY0FBYyxNQUFNLElBQUksZUFBZSxNQUFNLENBQUM7QUFBQSxFQUN4RDtBQUNGO0FBZU8sSUFBTSxpQkFBTixjQUE2QixXQUFXO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBTTdDLFlBQ0UsVUFDQUwsTUFDQTtBQUFBLElBQ0UsWUFBWSxDQUFDLDJCQUEyQjtBQUFBLElBQ3hDLFdBQVc7QUFBQSxJQUNYLFlBQVksSUFBc0IsVUFBVUEsSUFBRztBQUFBLElBQy9DLFdBQVcsS0FBVSxNQUFhLEtBQUssSUFBSSxFQUFFO0FBQUE7QUFBQSxJQUM3QyxnQkFBZ0I7QUFBQSxJQUNoQixXQUFXLENBQUM7QUFBQTtBQUFBLEVBQ2QsSUFBSSxDQUFDLEdBQ0w7QUFDQSxVQUFNO0FBQ04sU0FBSyxXQUFXO0FBQ2hCLFNBQUssTUFBTUE7QUFDWCxTQUFLLGdCQUFnQjtBQUlyQixTQUFLLFlBQVk7QUFDakIsU0FBSyxnQkFBZ0I7QUFDckIsU0FBSyxnQkFBZ0I7QUFDckIsU0FBSyxpQkFBaUIsQ0FBQztBQUN2QixTQUFLLFdBQVc7QUFDaEIsU0FBSyxXQUFXO0FBSWhCLFNBQUssTUFBTSxXQUF1QixVQUFVLFVBQVUsUUFBUTtBQUFBO0FBQUEsTUFBOEMsUUFBUSxJQUFJO0FBQUE7QUFJeEgsU0FBSyxPQUFPO0FBQ1osU0FBSyxJQUFJLEtBQUssU0FBTztBQUNuQixXQUFLLE9BQU8sU0FBU0EsTUFBSyxNQUFNLFVBQVUsR0FBRztBQUM3QyxVQUFJLEtBQUssZUFBZTtBQUN0QixhQUFLLEtBQUssUUFBUTtBQUFBLE1BQ3BCLE9BQU87QUFDTCxhQUFLLEtBQUssV0FBVztBQUFBLE1BQ3ZCO0FBQUEsSUFDRixDQUFDO0FBQ0QsU0FBSyxRQUFRO0FBQ2IsU0FBSyxVQUFVLEtBQUssUUFBUSxLQUFLLElBQUk7QUFDckMsSUFBQUEsS0FBSSxHQUFHLFdBQVcsS0FBSyxPQUFPO0FBQUEsRUFDaEM7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUtBLElBQUksWUFBYTtBQUNmLFdBQU8sS0FBSyxTQUFTLFFBQVEsS0FBSztBQUFBLEVBQ3BDO0FBQUEsRUFFQSxVQUFXO0FBQ1QsU0FBSyxnQkFBZ0I7QUFDckIsU0FBSyxjQUFjLFFBQVEsU0FBTztBQUNoQyxZQUFNLGdCQUFvQixlQUFlLGdCQUFnQixLQUFLLE1BQU0sSUFBSSxjQUFjLEdBQUcsQ0FBQztBQUMxRixXQUFLLGVBQWUsS0FBSyxhQUFhO0FBQ3RDLG9CQUFjLFVBQVUsSUFBSSxJQUFJO0FBQUEsSUFDbEMsQ0FBQztBQUNELFFBQUksS0FBSyxNQUFNO0FBQ2IsV0FBSyxLQUFLLFFBQVE7QUFBQSxJQUNwQjtBQUFBLEVBQ0Y7QUFBQSxFQUVBLGFBQWM7QUFDWixTQUFLLGdCQUFnQjtBQUNyQixTQUFLLGVBQWUsUUFBUSxVQUFRO0FBQ2xDLFdBQUssVUFBVSxPQUFPLElBQUk7QUFDMUIsVUFBSSxLQUFLLFVBQVUsU0FBUyxHQUFHO0FBQzdCLGFBQUssUUFBUTtBQUNiLHVCQUFlLE9BQU8sS0FBSyxHQUFHO0FBQUEsTUFDaEM7QUFBQSxJQUNGLENBQUM7QUFDRCxRQUFJLEtBQUssTUFBTTtBQUNiLFdBQUssS0FBSyxXQUFXO0FBQUEsSUFDdkI7QUFBQSxFQUNGO0FBQUEsRUFFQSxVQUFXO0FBQ1QsU0FBSyxJQUFJLElBQUksV0FBVyxLQUFLLE9BQU87QUFFcEMsU0FBSyxJQUFJLEtBQUssTUFBTTtBQUNFLE1BQUMsS0FBSyxLQUFNLFFBQVE7QUFDeEMsWUFBTSxPQUFPLEtBQUssUUFBUTtBQUFBLElBQzVCLENBQUM7QUFDRCxVQUFNLFFBQVE7QUFBQSxFQUNoQjtBQUNGOzs7QUl2cEJBLElBQUFNLG1CQUE4QjtBQUN2QixJQUFlLGVBQWYsTUFBNEI7QUFBQSxFQTJEakMsWUFBc0IsUUFBeUI7QUFBekI7QUFuRHRCLFNBQVUsaUJBQWdDO0FBQUEsRUFtRE07QUFBQSxFQTNDaEQsSUFBSSxVQUFVO0FBQ1osV0FBTyxLQUFLO0FBQUEsRUFDZDtBQUFBLEVBRUEsSUFBSSxPQUFPO0FBQ1QsV0FBTyxLQUFLO0FBQUEsRUFDZDtBQUFBLEVBRUEsSUFBSSxvQkFBb0I7QUFDdEIsV0FBTyxLQUFLO0FBQUEsRUFDZDtBQUFBLEVBRUEsSUFBSSxpQkFBZ0I7QUFDbEIsV0FBTyxLQUFLO0FBQUEsRUFDZDtBQUFBLEVBRUEsT0FBTyxXQUFXQyxPQUFjO0FBQzlCLFVBQU0scUJBQWlCLGdDQUFjQSxLQUFJO0FBQ3pDLFVBQU0sT0FBTyxLQUFLLGVBQWUsT0FBTyxDQUFBQyxTQUFPO0FBQzdDLGFBQU9BLEtBQUksU0FBUztBQUFBLElBQ3RCLENBQUM7QUFDRCxRQUFJLEtBQUssVUFBVSxHQUFHO0FBQ3BCLGFBQU8sS0FBSyxDQUFDO0FBQUEsSUFDZixPQUFPO0FBQ0w7QUFBQSxJQUNGO0FBQUEsRUFDRjtBQUFBLEVBRUEsT0FBTyxTQUFTQyxLQUFZO0FBQzFCLFVBQU0sT0FBTyxLQUFLLGVBQWUsT0FBTyxDQUFBRCxTQUFPO0FBQzdDLGFBQU9BLEtBQUksWUFBWUM7QUFBQSxJQUN6QixDQUFDO0FBQ0QsUUFBSSxLQUFLLFVBQVUsR0FBRztBQUNwQixhQUFPLEtBQUssQ0FBQztBQUFBLElBQ2YsT0FBTztBQUNMO0FBQUEsSUFDRjtBQUFBLEVBQ0Y7QUFBQSxFQUVBLE9BQU8sU0FBUztBQUNkLFdBQU8sT0FBTyxPQUFPLENBQUMsR0FBRyxLQUFLLGNBQWM7QUFBQSxFQUM5QztBQUFBLEVBTUEsaUJBQWlCO0FBQ2YsV0FBTyxJQUFJLFFBQWdCLENBQUFDLGFBQVc7QUFDcEMsWUFBTSxTQUFTLGVBQWU7QUFDOUIsWUFBTSxVQUFVLENBQUMsY0FBc0JELEtBQVksYUFBcUI7QUFDdEUsWUFBSSxpQkFBaUIsUUFBUTtBQUMzQixlQUFLLE9BQU8sV0FBVyxJQUFJLHFCQUFxQixPQUFPO0FBQ3ZELGVBQUssV0FBV0E7QUFDaEIsVUFBQUMsU0FBUSxRQUFRO0FBQUEsUUFDbEI7QUFBQSxNQUNGO0FBQ0EsV0FBSyxPQUFPLFdBQVcsR0FBRyxxQkFBcUIsT0FBTztBQUN0RCxXQUFLLE9BQU8sV0FBVyxnQkFBZ0IsTUFBTSxNQUFNO0FBQUEsSUFDckQsQ0FBQztBQUFBLEVBQ0g7QUFBQSxFQUVBLGlCQUFpQjtBQUNmLFdBQU8sSUFBSSxRQUFnQixDQUFBQSxhQUFXO0FBQ3BDLFlBQU0sVUFBVSxPQUFPRCxLQUFZLFNBQWlCO0FBQ2xELFlBQUlBLFFBQU8sS0FBSyxTQUFTO0FBQ3ZCLGVBQUssT0FBTyxXQUFXLElBQUksVUFBVSxPQUFPO0FBQzVDLGVBQUssT0FBTyxJQUFJLFlBQVksS0FBSyxJQUFJO0FBQ3JDLFVBQUFDLFNBQVEsSUFBSTtBQUFBLFFBQ2Q7QUFBQSxNQUNGO0FBQ0EsV0FBSyxPQUFPLFdBQVcsR0FBRyxVQUFVLE9BQU87QUFFM0MsV0FBSyxPQUFPLFdBQVcsY0FBYyxJQUFJO0FBQ3pDLFdBQUssT0FBTyxJQUFJLGFBQWEsS0FBSyxJQUFJO0FBQUEsSUFDeEMsQ0FBQztBQUFBLEVBQ0g7QUFBQSxFQUdBLGdCQUFnQixNQUEwQztBQUN4RCxTQUFLLE9BQU8sSUFBSSxjQUFjLEtBQUssYUFBYTtBQUNoRCxRQUFJLENBQUMsS0FBSztBQUFTO0FBQ25CLFFBQUksS0FBSyxpQkFBaUI7QUFDeEIsV0FBSyxnQkFBZ0IsUUFBUTtBQUM3QixhQUFPLEtBQUs7QUFBQSxJQUNkO0FBQ0EsVUFBTSxpQkFBaUIsSUFBSSxlQUFlLEtBQUssVUFBVSxLQUFLLE1BQU0sRUFBRSxXQUFXLENBQUMsS0FBSyxPQUFPLFNBQVMsU0FBUyxHQUFHLFVBQVUsRUFBRSxZQUFZLENBQUMsRUFBRSxNQUFNLHlCQUF5QixHQUFHLEVBQUUsTUFBTSwyQkFBMkIsVUFBVSxRQUFRLFlBQVksT0FBTyxHQUFHLEVBQUUsTUFBTSwrQkFBK0IsR0FBRyxFQUFFLE1BQU0saURBQWlELENBQUMsRUFBRSxFQUFFLENBQUM7QUFDcFcsU0FBSyxrQkFBa0I7QUFDdkIsUUFBSSxNQUFNO0FBQ1IsV0FBSyxjQUFjO0FBQUEsSUFDckI7QUFDQSxXQUFPO0FBQUEsRUFDVDtBQUFBLEVBRUEsaUJBQWlCO0FBcEhuQjtBQXFISSxRQUFJLENBQUMsS0FBSztBQUFpQjtBQUMzQixTQUFLLE9BQU8sSUFBSSxjQUFjLEtBQUssWUFBWTtBQUMvQyxlQUFLLG9CQUFMLG1CQUFzQixVQUFVO0FBQ2hDLGVBQUssb0JBQUwsbUJBQXNCO0FBQ3RCLGVBQUssb0JBQUwsbUJBQXNCO0FBQ3RCLFNBQUssa0JBQWtCO0FBQUEsRUFDekI7QUFBQSxFQUVBLE1BQU0sb0JBQW9CO0FBQ3hCLFFBQUksQ0FBQyxLQUFLO0FBQW9CO0FBQzlCLFVBQU0sS0FBSyxtQkFBbUIsUUFBUTtBQUFBLEVBQ3hDO0FBQUEsRUFFQSxVQUFVO0FBQ1IsU0FBSyxlQUFlO0FBQUEsRUFDdEI7QUFFRjtBQWhJc0IsYUFFYix3QkFBd0I7OztBaEZLakMsSUFBQUMsUUFBc0I7OztBaUZNZixJQUFNLE9BQU8sYUFBbUJDLFFBQU8sQ0FBQ0MsVUFBU0MsWUFBVztBQUVqRSxVQUFRLFVBQVUsV0FBU0EsUUFBTyxJQUFJLE1BQU0sTUFBTSxPQUFPLEtBQUssQ0FBQztBQUUvRCxVQUFRLFlBQVksV0FBU0QsU0FBUSxNQUFNLE9BQU8sTUFBTTtBQUMxRCxDQUFDO0FBT00sSUFBTSxTQUFTLENBQUMsTUFBTSxXQUFtQkQsUUFBTyxDQUFDQyxVQUFTQyxZQUFXO0FBQzFFLFFBQU0sVUFBVSxVQUFVLEtBQUssSUFBSTtBQUluQyxVQUFRLGtCQUFrQixXQUFTLE9BQU8sTUFBTSxPQUFPLE1BQU07QUFJN0QsVUFBUSxVQUFVLFdBQVNBLFFBQWFGLFFBQU8sTUFBTSxPQUFPLEtBQUssQ0FBQztBQUlsRSxVQUFRLFlBQVksV0FBUztBQUkzQixVQUFNLEtBQUssTUFBTSxPQUFPO0FBQ3hCLE9BQUcsa0JBQWtCLE1BQU07QUFBRSxTQUFHLE1BQU07QUFBQSxJQUFFO0FBQ3hDLElBQUFDLFNBQVEsRUFBRTtBQUFBLEVBQ1o7QUFDRixDQUFDO0FBS00sSUFBTSxXQUFXLFVBQVEsS0FBSyxVQUFVLGVBQWUsSUFBSSxDQUFDO0FBTTVELElBQU0sZUFBZSxDQUFDLElBQUksZ0JBQWdCLFlBQVk7QUFBQSxFQUFRO0FBQUE7QUFBQSxJQUVuRSxHQUFHLGtCQUFrQixNQUFNLElBQUksQ0FBQztBQUFBO0FBQ2xDO0FBUU8sSUFBTUUsWUFBVyxDQUFDLElBQUksUUFBUSxTQUFTLGdCQUFnQjtBQUM1RCxRQUFNLGNBQWMsR0FBRyxZQUFZLFFBQVEsTUFBTTtBQUNqRCxTQUFPLE9BQU8sSUFBSSxXQUFTLFNBQVMsYUFBYSxLQUFLLENBQUM7QUFDekQ7QUFPTyxJQUFNLFFBQVEsQ0FBQyxPQUFPLFVBQzNCLEtBQUssTUFBTSxNQUFNLEtBQUssQ0FBQztBQU9sQixJQUFNLE1BQU0sQ0FBQyxPQUFPLFFBQ3pCLEtBQUssTUFBTSxJQUFJLEdBQUcsQ0FBQztBQU1kLElBQU0sTUFBTSxDQUFDLE9BQU8sUUFDekIsS0FBSyxNQUFNLE9BQU8sR0FBRyxDQUFDO0FBT2pCLElBQU0sTUFBTSxDQUFDLE9BQU8sTUFBTSxRQUMvQixLQUFLLE1BQU0sSUFBSSxNQUFNLEdBQUcsQ0FBQztBQWdCcEIsSUFBTSxhQUFhLENBQUMsT0FBTyxTQUNoQyxLQUFLLE1BQU0sSUFBSSxJQUFJLENBQUM7QUFRZixJQUFNLFNBQVMsQ0FBQyxPQUFPLE9BQU8sVUFDbkMsS0FBSyxNQUFNLE9BQU8sT0FBTyxLQUFLLENBQUM7QUFpQjFCLElBQU0sYUFBYSxDQUFDLE9BQU8sT0FBTyxjQUFjO0FBSXJELE1BQUksUUFBUTtBQUNaLFNBQU8sWUFBWSxPQUFPLE9BQU8sU0FBTztBQUN0QyxZQUFRO0FBQ1IsV0FBTztBQUFBLEVBQ1QsR0FBRyxTQUFTLEVBQUUsS0FBSyxNQUFNLEtBQUs7QUFDaEM7QUFPTyxJQUFNLGFBQWEsQ0FBQyxPQUFPLFFBQVEsU0FBUyxXQUFXLE9BQU8sT0FBTyxNQUFNO0FBK0JsRixJQUFNLG1CQUFtQixDQUFDLFNBQVMsTUFBY0MsUUFBTyxDQUFDQyxVQUFTQyxZQUFXO0FBQzNFLFVBQVEsVUFBVUE7QUFJbEIsVUFBUSxZQUFZLE9BQU0sVUFBUztBQUNqQyxVQUFNLFNBQVMsTUFBTSxPQUFPO0FBQzVCLFFBQUksV0FBVyxRQUFTLE1BQU0sRUFBRSxNQUFNLE1BQU8sT0FBTztBQUNsRCxhQUFPRCxTQUFRO0FBQUEsSUFDakI7QUFDQSxXQUFPLFNBQVM7QUFBQSxFQUNsQjtBQUNGLENBQUM7QUFvQk0sSUFBTSxjQUFjLENBQUMsT0FBTyxVQUFVLEdBQUcsWUFBWSxXQUMxRCxpQkFBaUIsTUFBTSxjQUFjLFVBQVUsU0FBUyxHQUFHLFlBQVUsRUFBRSxPQUFPLEdBQUcsQ0FBQztBQVE3RSxJQUFNLFdBQVcsQ0FBQyxHQUFHLFVBQVUsRUFBRSxZQUFZLEtBQUs7QUFjbEQsSUFBTSw4QkFBOEIsQ0FBQyxPQUFPLGNBQWMsWUFBWSxXQUFXLE9BQU8sU0FBUztBQU1qRyxJQUFNLDhCQUE4QixDQUFDLE9BQU8sY0FBYyxZQUFZLFdBQVcsT0FBTyxTQUFTOzs7QUM5UHhHLElBQU0sa0JBQWtCO0FBQ3hCLElBQU0sbUJBQW1CO0FBRWxCLElBQU0sc0JBQXNCO0FBTzVCLElBQU0sZUFBZSxDQUFDLGdCQUFnQiw2QkFBNkIsTUFBTTtBQUFDLEdBQUcsNEJBQTRCLE1BQU07QUFBQyxNQUFNO0FBQzNILFFBQU0sQ0FBQyxZQUFZLElBQVFFO0FBQUE7QUFBQSxJQUFxQyxlQUFlO0FBQUEsSUFBSyxDQUFDLGdCQUFnQjtBQUFBLEVBQUM7QUFDdEcsU0FBVyxPQUFPLGNBQWtCLDRCQUE0QixlQUFlLFFBQVEsS0FBSyxDQUFDLEVBQUUsS0FBSyxhQUFXO0FBQzdHLFFBQUksQ0FBQyxlQUFlLFlBQVk7QUFDOUIsaUNBQTJCLFlBQVk7QUFDdkMsTUFBRSxTQUFTLGVBQWUsS0FBSyxNQUFNO0FBQ25DLGdCQUFRLFFBQVEsU0FBUyxZQUFZLGVBQWUsS0FBSyxHQUFHLENBQUM7QUFBQSxNQUMvRCxHQUFHLGdCQUFnQixLQUFLO0FBQ3hCLGdDQUEwQixZQUFZO0FBQUEsSUFDeEM7QUFBQSxFQUNGLENBQUMsRUFDRSxLQUFLLE1BQVUsV0FBVyxZQUFZLEVBQUUsS0FBSyxhQUFXO0FBQUUsbUJBQWUsU0FBUyxVQUFVO0FBQUEsRUFBRSxDQUFDLENBQUMsRUFDaEcsS0FBSyxNQUFVLE1BQU0sWUFBWSxFQUFFLEtBQUssU0FBTztBQUFFLG1CQUFlLFVBQVU7QUFBQSxFQUFJLENBQUMsQ0FBQyxFQUNoRixLQUFLLE1BQU0sWUFBWTtBQUM1QjtBQU1PLElBQU0sYUFBYSxDQUFDLGdCQUFnQixhQUFhLFNBQ3RELGFBQWEsY0FBYyxFQUN4QixLQUFLLGtCQUFnQjtBQUNwQixNQUFJLGNBQWMsZUFBZSxXQUFXLHFCQUFxQjtBQUMvRCxJQUFJLFdBQVcsY0FBZ0Isb0JBQW9CLGVBQWUsR0FBRyxDQUFDLEVBQ25FLEtBQUssTUFBVSxJQUFJLGNBQWtCLDRCQUE0QixlQUFlLFFBQVEsSUFBSSxDQUFDLENBQUMsRUFDOUYsS0FBSyxNQUFVLE1BQU0sWUFBWSxFQUFFLEtBQUssU0FBTztBQUFFLHFCQUFlLFVBQVU7QUFBQSxJQUFJLENBQUMsQ0FBQztBQUFBLEVBQ3JGO0FBQ0YsQ0FBQztBQVVFLElBQU0sdUJBQU4sY0FBbUMsV0FBVztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFLbkQsWUFBYSxNQUFNQyxNQUFLO0FBQ3RCLFVBQU07QUFDTixTQUFLLE1BQU1BO0FBQ1gsU0FBSyxPQUFPO0FBQ1osU0FBSyxTQUFTO0FBQ2QsU0FBSyxVQUFVO0FBQ2YsU0FBSyxhQUFhO0FBSWxCLFNBQUssS0FBSztBQUNWLFNBQUssU0FBUztBQUNkLFNBQUssTUFBVTtBQUFBLE1BQU87QUFBQSxNQUFNLFFBQ3RCLGFBQWEsSUFBSTtBQUFBLFFBQ25CLENBQUMsV0FBVyxFQUFFLGVBQWUsS0FBSyxDQUFDO0FBQUEsUUFDbkMsQ0FBQyxRQUFRO0FBQUEsTUFDWCxDQUFDO0FBQUEsSUFDSDtBQUlBLFNBQUssYUFBcUJDLFFBQU8sQ0FBQUMsYUFBVyxLQUFLLEdBQUcsVUFBVSxNQUFNQSxTQUFRLElBQUksQ0FBQyxDQUFDO0FBRWxGLFNBQUssSUFBSSxLQUFLLFFBQU07QUFDbEIsV0FBSyxLQUFLO0FBSVYsWUFBTSw2QkFBNkIsQ0FBQyxpQkFBcUIsV0FBVyxjQUFnQixvQkFBb0JGLElBQUcsQ0FBQztBQUM1RyxZQUFNLDRCQUE0QixNQUFNO0FBQ3RDLFlBQUksS0FBSztBQUFZLGlCQUFPO0FBQzVCLGFBQUssU0FBUztBQUNkLGFBQUssS0FBSyxVQUFVLENBQUMsSUFBSSxDQUFDO0FBQUEsTUFDNUI7QUFDQSxtQkFBYSxNQUFNLDRCQUE0Qix5QkFBeUI7QUFBQSxJQUMxRSxDQUFDO0FBSUQsU0FBSyxnQkFBZ0I7QUFJckIsU0FBSyxrQkFBa0I7QUFLdkIsU0FBSyxlQUFlLENBQUMsUUFBUSxXQUFXO0FBQ3RDLFVBQUksS0FBSyxNQUFNLFdBQVcsTUFBTTtBQUM5QixjQUFNLENBQUMsWUFBWSxJQUFRRztBQUFBO0FBQUEsVUFBcUMsS0FBSztBQUFBLFVBQUssQ0FBQyxnQkFBZ0I7QUFBQSxRQUFDO0FBQzVGLFFBQUksV0FBVyxjQUFjLE1BQU07QUFDbkMsWUFBSSxFQUFFLEtBQUssV0FBVyxxQkFBcUI7QUFFekMsY0FBSSxLQUFLLG9CQUFvQixNQUFNO0FBQ2pDLHlCQUFhLEtBQUssZUFBZTtBQUFBLFVBQ25DO0FBQ0EsZUFBSyxrQkFBa0IsV0FBVyxNQUFNO0FBQ3RDLHVCQUFXLE1BQU0sS0FBSztBQUN0QixpQkFBSyxrQkFBa0I7QUFBQSxVQUN6QixHQUFHLEtBQUssYUFBYTtBQUFBLFFBQ3ZCO0FBQUEsTUFDRjtBQUFBLElBQ0Y7QUFDQSxJQUFBSCxLQUFJLEdBQUcsVUFBVSxLQUFLLFlBQVk7QUFDbEMsU0FBSyxVQUFVLEtBQUssUUFBUSxLQUFLLElBQUk7QUFDckMsSUFBQUEsS0FBSSxHQUFHLFdBQVcsS0FBSyxPQUFPO0FBQUEsRUFDaEM7QUFBQSxFQUVBLFVBQVc7QUFDVCxRQUFJLEtBQUssaUJBQWlCO0FBQ3hCLG1CQUFhLEtBQUssZUFBZTtBQUFBLElBQ25DO0FBQ0EsU0FBSyxJQUFJLElBQUksVUFBVSxLQUFLLFlBQVk7QUFDeEMsU0FBSyxJQUFJLElBQUksV0FBVyxLQUFLLE9BQU87QUFDcEMsU0FBSyxhQUFhO0FBQ2xCLFdBQU8sS0FBSyxJQUFJLEtBQUssUUFBTTtBQUN6QixTQUFHLE1BQU07QUFBQSxJQUNYLENBQUM7QUFBQSxFQUNIO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBT0EsWUFBYTtBQUNYLFdBQU8sS0FBSyxRQUFRLEVBQUUsS0FBSyxNQUFNO0FBQy9CLE1BQUksU0FBUyxLQUFLLElBQUk7QUFBQSxJQUN4QixDQUFDO0FBQUEsRUFDSDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFNQSxJQUFLLEtBQUs7QUFDUixXQUFPLEtBQUssSUFBSSxLQUFLLFFBQU07QUFDekIsWUFBTSxDQUFDLE1BQU0sSUFBUUcsVUFBUyxJQUFJLENBQUMsZUFBZSxHQUFHLFVBQVU7QUFDL0QsYUFBVyxJQUFJLFFBQVEsR0FBRztBQUFBLElBQzVCLENBQUM7QUFBQSxFQUNIO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBT0EsSUFBSyxLQUFLLE9BQU87QUFDZixXQUFPLEtBQUssSUFBSSxLQUFLLFFBQU07QUFDekIsWUFBTSxDQUFDLE1BQU0sSUFBUUEsVUFBUyxJQUFJLENBQUMsZUFBZSxDQUFDO0FBQ25ELGFBQVcsSUFBSSxRQUFRLE9BQU8sR0FBRztBQUFBLElBQ25DLENBQUM7QUFBQSxFQUNIO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQU1BLElBQUssS0FBSztBQUNSLFdBQU8sS0FBSyxJQUFJLEtBQUssUUFBTTtBQUN6QixZQUFNLENBQUMsTUFBTSxJQUFRQSxVQUFTLElBQUksQ0FBQyxlQUFlLENBQUM7QUFDbkQsYUFBVyxJQUFJLFFBQVEsR0FBRztBQUFBLElBQzVCLENBQUM7QUFBQSxFQUNIO0FBQ0Y7OztBQ3JMTyxJQUFNLG1CQUFtQixDQUFDQyxPQUFjLFdBQTRCO0FBQ3pFLFFBQU0sZ0JBQWdCLE9BQU8sSUFBSSxVQUFVLGdCQUFnQixlQUFlO0FBQzFFLGdCQUFjLFFBQVEsa0JBQWdCO0FBRXBDLFVBQU0sV0FBVyxhQUFhLEtBQUssVUFBVUEsS0FBSTtBQUNqRCxRQUFJLENBQUM7QUFBVTtBQUNmLFVBQU0sS0FBSyxTQUFTO0FBQ3BCLE9BQUcsU0FBUyxvQkFBb0I7QUFBQSxFQUNsQyxDQUFDO0FBQ0g7QUFFTyxJQUFNLHNCQUFzQixDQUFDQSxPQUFjLFdBQTRCO0FBQzVFLFFBQU0sZ0JBQWdCLE9BQU8sSUFBSSxVQUFVLGdCQUFnQixlQUFlO0FBQzFFLGdCQUFjLFFBQVEsa0JBQWdCO0FBRXBDLFVBQU0sV0FBVyxhQUFhLEtBQUssVUFBVUEsS0FBSTtBQUNqRCxRQUFJLENBQUM7QUFBVTtBQUNmLFVBQU0sS0FBSyxTQUFTO0FBQ3BCLE9BQUcsWUFBWSxvQkFBb0I7QUFBQSxFQUNyQyxDQUFDO0FBQ0g7OztBQ3RCQSxJQUFBQyxtQkFBNkQ7QUFDN0QsV0FBc0I7OztBQ0R0QixJQUFBQyxtQkFBOEY7OztBQ0E5RixJQUFBQyxtQkFBbUM7QUFJNUIsSUFBTSwwQkFBMEIsT0FBTyxXQUE0QjtBQUN4RSxRQUFNLFdBQVcsTUFBTSxZQUFZLE1BQU07QUFDekMsUUFBTSxNQUFNLElBQUksSUFBSSxTQUFTLGVBQWU7QUFDNUMsTUFBSSxhQUFhLElBQUksT0FBTyxTQUFTLEdBQUc7QUFDeEMsUUFBTSxPQUFPLFVBQU0sNkJBQVcsSUFBSSxTQUFTLENBQUMsRUFBRTtBQUM5QyxNQUFJLE1BQU07QUFDUixRQUFHLEtBQUssTUFBTTtBQUNaLGVBQVMsT0FBTyxLQUFLO0FBQUEsSUFDdkI7QUFDQSxRQUFHLEtBQUssT0FBTztBQUNiLGVBQVMsV0FBVyxLQUFLO0FBQUEsSUFDM0I7QUFDQSxVQUFNLGFBQWEsVUFBVSxNQUFNO0FBQUEsRUFDckM7QUFDRjs7O0FDbEJBLElBQUFDLG1CQUF5RDtBQUdsRCxJQUFNLG9CQUFOLGNBQWdDLDhCQUFzQjtBQUFBLEVBTTNELFlBQVksS0FBVSxJQUE0QjtBQUNoRCxVQUFNLEdBQUc7QUFDVCxTQUFLLEtBQUs7QUFFVixTQUFLLFVBQVUsQ0FBQztBQUNoQiwyQkFBTSxnQkFBZ0IsSUFBSSxNQUFNLFFBQVEsR0FBRyxDQUFDLFNBQVM7QUFDbkQsVUFBSSxnQkFBZ0I7QUFBUyxhQUFLLFFBQVEsS0FBSyxJQUFJO0FBQUEsSUFDckQsQ0FBQztBQUVELFNBQUssUUFBUSxNQUFNO0FBQ25CLFNBQUssUUFBUSxLQUFLLENBQUMsR0FBRyxNQUFNO0FBQzFCLGFBQU8sRUFBRSxLQUFLLGtCQUFrQixFQUFFLGNBQWMsRUFBRSxLQUFLLGtCQUFrQixDQUFDO0FBQUEsSUFDNUUsQ0FBQztBQUFBLEVBQ0g7QUFBQSxFQUVBLFNBQVM7QUFDUCxVQUFNLE9BQU87QUFDYixTQUFLLFFBQVEsY0FBYztBQUFBLEVBQzdCO0FBQUEsRUFFQSxlQUFlLE9BQTBCO0FBQ3ZDLFdBQU8sS0FBSyxRQUFRLE9BQU8sWUFBVTtBQUNuQyxhQUFPLE9BQU8sS0FBSyxrQkFBa0IsRUFBRSxTQUFTLE1BQU0sa0JBQWtCLENBQUM7QUFBQSxJQUMzRSxDQUFDO0FBQUEsRUFDSDtBQUFBLEVBRUEsaUJBQWlCLE9BQWdCLElBQWlCO0FBQ2hELE9BQUcsUUFBUSxNQUFNLElBQUk7QUFBQSxFQUN2QjtBQUFBLEVBRUEsaUJBQWlCLE9BQWdCLEtBQXVDO0FBQ3RFLFNBQUssaUJBQWlCO0FBQ3RCLFVBQU0saUJBQWlCLE9BQU8sR0FBRztBQUFBLEVBQ25DO0FBQUEsRUFFQSxtQkFBbUIsTUFBZSxLQUFpQztBQUFBLEVBQ25FO0FBQUEsRUFFQSxVQUFnQjtBQUNkLFNBQUssR0FBRyxLQUFLLGNBQWM7QUFBQSxFQUM3QjtBQUVGO0FBRU8sSUFBTSwyQkFBMkIsT0FBTyxRQUFhO0FBQzFELFNBQU8sSUFBSSxRQUF3QixDQUFDQyxhQUFZO0FBQzlDLFFBQUksa0JBQWtCLEtBQUssQ0FBQyxXQUFXO0FBQ3JDLE1BQUFBLFNBQVEsTUFBTTtBQUFBLElBQ2hCLENBQUMsRUFBRSxLQUFLO0FBQUEsRUFDVixDQUFDO0FBQ0g7OztBQzFETyxJQUFNLFVBQ1QsT0FBTyxlQUFlLGNBQWMsYUFDcEMsT0FBTyxTQUFTLGNBQWMsT0FDOUIsT0FBTyxXQUFXLGNBQWMsU0FDaEM7QUNKRyxJQUFNQyxRQUFPLE9BQU87QUFDcEIsSUFBTUMsV0FBVSxNQUFNO0FBQzdCLElBQUksT0FBTyxZQUFZLGVBQWUsQ0FBQyxRQUFRLFNBQVE7QUFJbkQsVUFBUSxVQUFVOztTQUlOLE9BQTBDLEtBQVEsV0FBWTtBQUMxRSxNQUFJLE9BQU8sY0FBYztBQUFVLFdBQU87QUFDMUMsRUFBQUQsTUFBSyxTQUFTLEVBQUUsUUFBUSxTQUFVLEtBQUc7QUFDakMsUUFBSSxHQUFHLElBQUksVUFBVSxHQUFHO0dBQzNCO0FBQ0QsU0FBTztBQUNYO0FBRU8sSUFBTSxXQUFXLE9BQU87QUFDeEIsSUFBTSxVQUFVLENBQUEsRUFBRztTQUNWLE9BQU8sS0FBSyxNQUFJO0FBQzVCLFNBQU8sUUFBUSxLQUFLLEtBQUssSUFBSTtBQUNqQztTQUVnQixNQUFPLE9BQU8sV0FBUztBQUNuQyxNQUFJLE9BQU8sY0FBYztBQUFZLGdCQUFZLFVBQVUsU0FBUyxLQUFLLENBQUM7QUFDMUUsR0FBQyxPQUFPLFlBQVksY0FBY0EsUUFBTyxRQUFRLFNBQVMsU0FBUyxFQUFFLFFBQVEsU0FBRztBQUM1RSxZQUFRLE9BQU8sS0FBSyxVQUFVLEdBQUcsQ0FBQztHQUNyQztBQUNMO0FBRU8sSUFBTSxpQkFBaUIsT0FBTztTQUVyQixRQUFRLEtBQUssTUFBTSxrQkFBa0IsU0FBUTtBQUN6RCxpQkFBZSxLQUFLLE1BQU0sT0FBTyxvQkFBb0IsT0FBTyxrQkFBa0IsS0FBSyxLQUFLLE9BQU8saUJBQWlCLFFBQVEsYUFDcEgsRUFBQyxLQUFLLGlCQUFpQixLQUFLLEtBQUssaUJBQWlCLEtBQUssY0FBYyxLQUFJLElBQ3pFLEVBQUMsT0FBTyxrQkFBa0IsY0FBYyxNQUFNLFVBQVUsS0FBSSxHQUFHLE9BQU8sQ0FBQztBQUMvRTtTQUVnQixPQUFPLE9BQUs7QUFDeEIsU0FBTztJQUNILE1BQU0sU0FBVSxRQUFNO0FBQ2xCLFlBQU0sWUFBWSxPQUFPLE9BQU8sT0FBTyxTQUFTO0FBQ2hELGNBQVEsTUFBTSxXQUFXLGVBQWUsS0FBSztBQUM3QyxhQUFPO1FBQ0gsUUFBUSxNQUFNLEtBQUssTUFBTSxNQUFNLFNBQVM7Ozs7QUFJeEQ7QUFFTyxJQUFNLDJCQUEyQixPQUFPO1NBRS9CLHNCQUFzQixLQUFLLE1BQUk7QUFDM0MsUUFBTSxLQUFLLHlCQUF5QixLQUFLLElBQUk7QUFDN0MsTUFBSTtBQUNKLFNBQU8sT0FBTyxRQUFRLFNBQVMsR0FBRyxNQUFNLHNCQUF1QixPQUFPLElBQUk7QUFDOUU7QUFFQSxJQUFNLFNBQVMsQ0FBQSxFQUFHO1NBQ0YsTUFBTUUsT0FBTSxPQUFRLEtBQUk7QUFDcEMsU0FBTyxPQUFPLEtBQUtBLE9BQU0sT0FBTyxHQUFHO0FBQ3ZDO1NBRWdCLFNBQVMsVUFBVSxrQkFBZ0I7QUFDL0MsU0FBTyxpQkFBaUIsUUFBUTtBQUNwQztTQUVnQixPQUFRLEdBQUM7QUFDckIsTUFBSSxDQUFDO0FBQUcsVUFBTSxJQUFJLE1BQU0sa0JBQWtCO0FBQzlDO1NBRWdCQyxPQUFLLElBQUU7QUFFbkIsTUFBSSxRQUFRO0FBQWMsaUJBQWEsRUFBRTs7QUFBUSxlQUFXLElBQUksQ0FBQztBQUNyRTtTQVdnQixjQUFvQixPQUFZLFdBQTBDO0FBQ3RGLFNBQU8sTUFBTSxPQUFPLENBQUMsUUFBUSxNQUFNLE1BQUM7QUFDaEMsUUFBSSxlQUFlLFVBQVUsTUFBTSxDQUFDO0FBQ3BDLFFBQUk7QUFBYyxhQUFPLGFBQWEsQ0FBQyxDQUFDLElBQUksYUFBYSxDQUFDO0FBQzFELFdBQU87S0FDUixDQUFBLENBQUU7QUFDVDtTQVlnQixTQUFTLElBQTRCLFNBQVNELE9BQUs7QUFDL0QsTUFBSTtBQUNBLE9BQUcsTUFBTSxNQUFNQSxLQUFJO1dBQ2QsSUFBUDtBQUNFLGVBQVcsUUFBUSxFQUFFOztBQUU3QjtTQUVnQixhQUFhLEtBQUssU0FBTztBQUVyQyxNQUFJLE9BQU8sWUFBWSxZQUFZLE9BQU8sS0FBSyxPQUFPO0FBQUcsV0FBTyxJQUFJLE9BQU87QUFDM0UsTUFBSSxDQUFDO0FBQVMsV0FBTztBQUNyQixNQUFJLE9BQU8sWUFBWSxVQUFVO0FBQzdCLFFBQUksS0FBSyxDQUFBO0FBQ1QsYUFBUyxJQUFJLEdBQUcsSUFBSSxRQUFRLFFBQVEsSUFBSSxHQUFHLEVBQUUsR0FBRztBQUM1QyxVQUFJLE1BQU0sYUFBYSxLQUFLLFFBQVEsQ0FBQyxDQUFDO0FBQ3RDLFNBQUcsS0FBSyxHQUFHOztBQUVmLFdBQU87O0FBRVgsTUFBSSxTQUFTLFFBQVEsUUFBUSxHQUFHO0FBQ2hDLE1BQUksV0FBVyxJQUFJO0FBQ2YsUUFBSSxXQUFXLElBQUksUUFBUSxPQUFPLEdBQUcsTUFBTSxDQUFDO0FBQzVDLFdBQU8sWUFBWSxPQUFPLFNBQVksYUFBYSxVQUFVLFFBQVEsT0FBTyxTQUFTLENBQUMsQ0FBQzs7QUFFM0YsU0FBTztBQUNYO1NBRWdCLGFBQWEsS0FBSyxTQUFTLE9BQUs7QUFDNUMsTUFBSSxDQUFDLE9BQU8sWUFBWTtBQUFXO0FBQ25DLE1BQUksY0FBYyxVQUFVLE9BQU8sU0FBUyxHQUFHO0FBQUc7QUFDbEQsTUFBSSxPQUFPLFlBQVksWUFBWSxZQUFZLFNBQVM7QUFDcEQsV0FBTyxPQUFPLFVBQVUsWUFBWSxZQUFZLEtBQUs7QUFDckQsYUFBUyxJQUFJLEdBQUcsSUFBSSxRQUFRLFFBQVEsSUFBSSxHQUFHLEVBQUUsR0FBRztBQUM1QyxtQkFBYSxLQUFLLFFBQVEsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxDQUFDOztTQUV2QztBQUNILFFBQUksU0FBUyxRQUFRLFFBQVEsR0FBRztBQUNoQyxRQUFJLFdBQVcsSUFBSTtBQUNmLFVBQUksaUJBQWlCLFFBQVEsT0FBTyxHQUFHLE1BQU07QUFDN0MsVUFBSSxtQkFBbUIsUUFBUSxPQUFPLFNBQVMsQ0FBQztBQUNoRCxVQUFJLHFCQUFxQjtBQUNyQixZQUFJLFVBQVUsUUFBVztBQUNyQixjQUFJRCxTQUFRLEdBQUcsS0FBSyxDQUFDLE1BQU0sU0FBUyxjQUFjLENBQUM7QUFBRyxnQkFBSSxPQUFPLGdCQUFnQixDQUFDOztBQUM3RSxtQkFBTyxJQUFJLGNBQWM7O0FBQzNCLGNBQUksY0FBYyxJQUFJO1dBQzVCO0FBQ0QsWUFBSSxXQUFXLElBQUksY0FBYztBQUNqQyxZQUFJLENBQUMsWUFBWSxDQUFDLE9BQU8sS0FBSyxjQUFjO0FBQUcscUJBQVksSUFBSSxjQUFjLElBQUksQ0FBQTtBQUNqRixxQkFBYSxVQUFVLGtCQUFrQixLQUFLOztXQUUvQztBQUNILFVBQUksVUFBVSxRQUFXO0FBQ3JCLFlBQUlBLFNBQVEsR0FBRyxLQUFLLENBQUMsTUFBTSxTQUFTLE9BQU8sQ0FBQztBQUFHLGNBQUksT0FBTyxTQUFTLENBQUM7O0FBQy9ELGlCQUFPLElBQUksT0FBTzs7QUFDcEIsWUFBSSxPQUFPLElBQUk7OztBQUdsQztTQUVnQixhQUFhLEtBQUssU0FBTztBQUNyQyxNQUFJLE9BQU8sWUFBWTtBQUNuQixpQkFBYSxLQUFLLFNBQVMsTUFBUztXQUMvQixZQUFZO0FBQ2pCLEtBQUEsRUFBRyxJQUFJLEtBQUssU0FBUyxTQUFTLElBQUU7QUFDNUIsbUJBQWEsS0FBSyxJQUFJLE1BQVM7S0FDbEM7QUFDVDtTQUVnQixhQUFhLEtBQUc7QUFDNUIsTUFBSSxLQUFLLENBQUE7QUFDVCxXQUFTLEtBQUssS0FBSztBQUNmLFFBQUksT0FBTyxLQUFLLENBQUM7QUFBRyxTQUFHLENBQUMsSUFBSSxJQUFJLENBQUM7O0FBRXJDLFNBQU87QUFDWDtBQUVBLElBQU0sU0FBUyxDQUFBLEVBQUc7U0FDRixRQUFZLEdBQWM7QUFDdEMsU0FBTyxPQUFPLE1BQU0sQ0FBQSxHQUFJLENBQUM7QUFDN0I7QUFHQSxJQUFNLHFCQUNGLGlOQUNDLE1BQU0sR0FBRyxFQUFFLE9BQ1IsUUFBUSxDQUFDLEdBQUUsSUFBRyxJQUFHLEVBQUUsRUFBRSxJQUFJLFNBQUssQ0FBQyxPQUFNLFFBQU8sT0FBTyxFQUFFLElBQUksT0FBRyxJQUFFLE1BQUksT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUM5RSxPQUFPLE9BQUcsUUFBUSxDQUFDLENBQUM7QUFDMUIsSUFBTSxpQkFBaUIsbUJBQW1CLElBQUksT0FBRyxRQUFRLENBQUMsQ0FBQztBQUN2QixjQUFjLG9CQUFvQixPQUFHLENBQUMsR0FBRSxJQUFJLENBQUM7QUFFakYsSUFBSSxlQUF3QztTQUM1QixVQUFhRyxNQUFNO0FBQy9CLGlCQUFlLE9BQU8sWUFBWSxlQUFlLG9CQUFJLFFBQU87QUFDNUQsUUFBTSxLQUFLLGVBQWVBLElBQUc7QUFDN0IsaUJBQWU7QUFDZixTQUFPO0FBQ1g7QUFFQSxTQUFTLGVBQWtCQSxNQUFNO0FBQzdCLE1BQUksQ0FBQ0EsUUFBTyxPQUFPQSxTQUFRO0FBQVUsV0FBT0E7QUFDNUMsTUFBSSxLQUFLLGdCQUFnQixhQUFhLElBQUlBLElBQUc7QUFDN0MsTUFBSTtBQUFJLFdBQU87QUFDZixNQUFJSCxTQUFRRyxJQUFHLEdBQUc7QUFDZCxTQUFLLENBQUE7QUFDTCxvQkFBZ0IsYUFBYSxJQUFJQSxNQUFLLEVBQUU7QUFDeEMsYUFBUyxJQUFJLEdBQUcsSUFBSUEsS0FBSSxRQUFRLElBQUksR0FBRyxFQUFFLEdBQUc7QUFDeEMsU0FBRyxLQUFLLGVBQWVBLEtBQUksQ0FBQyxDQUFDLENBQUM7O2FBRTNCLGVBQWUsUUFBUUEsS0FBSSxXQUFXLEtBQUssR0FBRztBQUNyRCxTQUFLQTtTQUNGO0FBQ0gsVUFBTSxRQUFRLFNBQVNBLElBQUc7QUFDMUIsU0FBSyxVQUFVLE9BQU8sWUFBWSxDQUFBLElBQUssT0FBTyxPQUFPLEtBQUs7QUFDMUQsb0JBQWdCLGFBQWEsSUFBSUEsTUFBSyxFQUFFO0FBQ3hDLGFBQVMsUUFBUUEsTUFBSztBQUNsQixVQUFJLE9BQU9BLE1BQUssSUFBSSxHQUFHO0FBQ25CLFdBQUcsSUFBSSxJQUFJLGVBQWVBLEtBQUksSUFBSSxDQUFDOzs7O0FBSS9DLFNBQU87QUFDWDtBQUVBLElBQU0sRUFBQyxTQUFRLElBQUksQ0FBQTtTQUNILFlBQVksR0FBUztBQUNqQyxTQUFPLFNBQVMsS0FBSyxDQUFDLEVBQUUsTUFBTSxHQUFHLEVBQUU7QUFDdkM7QUFHTyxJQUFNLGlCQUFpQixPQUFPLFdBQVcsY0FDNUMsT0FBTyxXQUNQO0FBQ0csSUFBTSxnQkFBZ0IsT0FBTyxtQkFBbUIsV0FBVyxTQUFTLEdBQUM7QUFDeEUsTUFBSTtBQUNKLFNBQU8sS0FBSyxTQUFTLElBQUksRUFBRSxjQUFjLE1BQU0sRUFBRSxNQUFNLENBQUM7QUFDNUQsSUFBSSxXQUFBO0FBQWMsU0FBTztBQUFLO0FBS3ZCLElBQU0sZ0JBQWdCLENBQUE7U0FTYixXQUFZLFdBQVM7QUFDakMsTUFBSSxHQUFHLEdBQUcsR0FBRztBQUNiLE1BQUksVUFBVSxXQUFXLEdBQUc7QUFDeEIsUUFBSUgsU0FBUSxTQUFTO0FBQUcsYUFBTyxVQUFVLE1BQUs7QUFDOUMsUUFBSSxTQUFTLGlCQUFpQixPQUFPLGNBQWM7QUFBVSxhQUFPLENBQUMsU0FBUztBQUM5RSxRQUFLLEtBQUssY0FBYyxTQUFTLEdBQUk7QUFDakMsVUFBSSxDQUFBO0FBQ0osYUFBUSxJQUFJLEdBQUcsS0FBSSxHQUFLLENBQUMsRUFBRTtBQUFNLFVBQUUsS0FBSyxFQUFFLEtBQUs7QUFDL0MsYUFBTzs7QUFFWCxRQUFJLGFBQWE7QUFBTSxhQUFPLENBQUMsU0FBUztBQUN4QyxRQUFJLFVBQVU7QUFDZCxRQUFJLE9BQU8sTUFBTSxVQUFVO0FBQ3ZCLFVBQUksSUFBSSxNQUFNLENBQUM7QUFDZixhQUFPO0FBQUssVUFBRSxDQUFDLElBQUksVUFBVSxDQUFDO0FBQzlCLGFBQU87O0FBRVgsV0FBTyxDQUFDLFNBQVM7O0FBRXJCLE1BQUksVUFBVTtBQUNkLE1BQUksSUFBSSxNQUFNLENBQUM7QUFDZixTQUFPO0FBQUssTUFBRSxDQUFDLElBQUksVUFBVSxDQUFDO0FBQzlCLFNBQU87QUFDWDtBQUNPLElBQU0sa0JBQWtCLE9BQU8sV0FBVyxjQUMzQyxDQUFDLE9BQWlCLEdBQUcsT0FBTyxXQUFXLE1BQU0sa0JBQzdDLE1BQUk7QUN2UkgsSUFBSSxRQUFRLE9BQU8sYUFBYSxlQUUvQiw2Q0FBNkMsS0FBSyxTQUFTLElBQUk7U0FFdkQsU0FBUyxPQUFPLFFBQU07QUFDbEMsVUFBUTtBQUNSLGtCQUFnQjtBQUNwQjtBQUVPLElBQUksZ0JBQWdCLE1BQU07QUFFMUIsSUFBTSx3QkFBd0IsQ0FBQyxJQUFJLE1BQU0sRUFBRSxFQUFFO1NBRXBDLG9CQUFpQjtBQUU3QixNQUFJO0FBQXVCLFFBQUk7QUFNM0Isd0JBQWtCO0FBQ2xCLFlBQU0sSUFBSSxNQUFLO2FBQ1gsR0FBTjtBQUNFLGFBQU87O0FBRVgsU0FBTyxJQUFJLE1BQUs7QUFDcEI7U0FFZ0IsWUFBWSxXQUFXLGtCQUFnQjtBQUNuRCxNQUFJLFFBQVEsVUFBVTtBQUN0QixNQUFJLENBQUM7QUFBTyxXQUFPO0FBQ25CLHFCQUFvQixvQkFBb0I7QUFDeEMsTUFBSSxNQUFNLFFBQVEsVUFBVSxJQUFJLE1BQU07QUFDbEMseUJBQXFCLFVBQVUsT0FBTyxVQUFVLFNBQVMsTUFBTSxJQUFJLEVBQUU7QUFDekUsU0FBTyxNQUFNLE1BQU0sSUFBSSxFQUNsQixNQUFNLGdCQUFnQixFQUN0QixPQUFPLGFBQWEsRUFDcEIsSUFBSSxXQUFTLE9BQU8sS0FBSyxFQUN6QixLQUFLLEVBQUU7QUFDaEI7QUN2Q0EsSUFBSSxrQkFBa0I7RUFDbEI7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7O0FBR0osSUFBSSxtQkFBbUI7RUFDbkI7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTs7QUFHSixJQUFJLFlBQVksZ0JBQWdCLE9BQU8sZ0JBQWdCO0FBRXZELElBQUksZUFBZTtFQUNmLGdCQUFnQjtFQUNoQixnQkFBZ0I7RUFDaEIsT0FBTztFQUNQLHFCQUFxQjtFQUNyQixZQUFZOztTQU1BLFdBQVksTUFBTSxLQUFHO0FBTWpDLE9BQUssS0FBSyxrQkFBaUI7QUFDM0IsT0FBSyxPQUFPO0FBQ1osT0FBSyxVQUFVO0FBQ25CO0FBRUEsT0FBTyxVQUFVLEVBQUUsS0FBSyxLQUFLLEVBQUUsT0FBTztFQUNsQyxPQUFPO0lBQ0gsS0FBSyxXQUFBO0FBQ0QsYUFBTyxLQUFLLFdBQ1AsS0FBSyxTQUFTLEtBQUssT0FBTyxPQUFPLEtBQUssVUFBVSxZQUFZLEtBQUssSUFBSSxDQUFDOzs7RUFHbkYsVUFBVSxXQUFBO0FBQVksV0FBTyxLQUFLLE9BQU8sT0FBTyxLQUFLO0VBQVE7Q0FDaEU7QUFFRCxTQUFTLHFCQUFzQixLQUFLLFVBQVE7QUFDeEMsU0FBTyxNQUFNLGVBQWUsT0FBTyxLQUFLLFFBQVEsRUFDM0MsSUFBSSxTQUFLLFNBQVMsR0FBRyxFQUFFLFNBQVEsQ0FBRSxFQUNqQyxPQUFPLENBQUMsR0FBRSxHQUFFLE1BQUksRUFBRSxRQUFRLENBQUMsTUFBTSxDQUFDLEVBQ2xDLEtBQUssSUFBSTtBQUNsQjtTQU1nQixZQUFhLEtBQUssVUFBVSxjQUFjLFlBQVU7QUFDaEUsT0FBSyxLQUFLLGtCQUFpQjtBQUMzQixPQUFLLFdBQVc7QUFDaEIsT0FBSyxhQUFhO0FBQ2xCLE9BQUssZUFBZTtBQUNwQixPQUFLLFVBQVUscUJBQXFCLEtBQUssUUFBUTtBQUNyRDtBQUNBLE9BQU8sV0FBVyxFQUFFLEtBQUssVUFBVTtTQUVuQixVQUFXLEtBQUssVUFBUTtBQUNwQyxPQUFLLEtBQUssa0JBQWlCO0FBQzNCLE9BQUssT0FBTztBQUNaLE9BQUssV0FBVyxPQUFPLEtBQUssUUFBUSxFQUFFLElBQUksU0FBTyxTQUFTLEdBQUcsQ0FBQztBQUM5RCxPQUFLLGdCQUFnQjtBQUNyQixPQUFLLFVBQVUscUJBQXFCLEtBQUssUUFBUTtBQUNyRDtBQUNBLE9BQU8sU0FBUyxFQUFFLEtBQUssVUFBVTtBQVUxQixJQUFJLFdBQVcsVUFBVSxPQUFPLENBQUMsS0FBSSxVQUFRLElBQUksSUFBSSxJQUFFLE9BQUssU0FBUSxNQUFLLENBQUEsQ0FBRTtBQUdsRixJQUFNLGdCQUFnQjtBQUVmLElBQUksYUFBYSxVQUFVLE9BQU8sQ0FBQyxLQUFJLFNBQUk7QUFPOUMsTUFBSSxXQUFXLE9BQU87QUFDdEIsV0FBU0ksWUFBWSxZQUFZLE9BQUs7QUFDbEMsU0FBSyxLQUFLLGtCQUFpQjtBQUMzQixTQUFLLE9BQU87QUFDWixRQUFJLENBQUMsWUFBWTtBQUNiLFdBQUssVUFBVSxhQUFhLElBQUksS0FBSztBQUNyQyxXQUFLLFFBQVE7ZUFDTixPQUFPLGVBQWUsVUFBVTtBQUN2QyxXQUFLLFVBQVUsR0FBRyxhQUFhLENBQUMsUUFBUSxLQUFLLFFBQVE7QUFDckQsV0FBSyxRQUFRLFNBQVM7ZUFDZixPQUFPLGVBQWUsVUFBVTtBQUN2QyxXQUFLLFVBQVUsR0FBRyxXQUFXLFFBQVEsV0FBVztBQUNoRCxXQUFLLFFBQVE7OztBQUdyQixTQUFPQSxXQUFVLEVBQUUsS0FBSyxhQUFhO0FBQ3JDLE1BQUksSUFBSSxJQUFFQTtBQUNWLFNBQU87QUFDWCxHQUFFLENBQUEsQ0FBRTtBQUdKLFdBQVcsU0FBUztBQUNwQixXQUFXLE9BQU87QUFDbEIsV0FBVyxRQUFRO0FBRVosSUFBSSxlQUFlLGlCQUFpQixPQUFPLENBQUMsS0FBSyxTQUFJO0FBQ3hELE1BQUksT0FBTyxPQUFPLElBQUksV0FBVyxJQUFJO0FBQ3JDLFNBQU87QUFDWCxHQUFHLENBQUEsQ0FBRTtTQUVXLFNBQVUsVUFBVSxTQUFPO0FBQ3ZDLE1BQUksQ0FBQyxZQUFZLG9CQUFvQixjQUFjLG9CQUFvQixhQUFhLG9CQUFvQixlQUFlLENBQUMsU0FBUyxRQUFRLENBQUMsYUFBYSxTQUFTLElBQUk7QUFDaEssV0FBTztBQUNYLE1BQUksS0FBSyxJQUFJLGFBQWEsU0FBUyxJQUFJLEVBQUUsV0FBVyxTQUFTLFNBQVMsUUFBUTtBQUM5RSxNQUFJLFdBQVcsVUFBVTtBQUVyQixZQUFRLElBQUksU0FBUyxFQUFDLEtBQUssV0FBQTtBQUN2QixhQUFPLEtBQUssTUFBTTtNQUNyQixDQUFDOztBQUVOLFNBQU87QUFDWDtBQUVPLElBQUkscUJBQXFCLFVBQVUsT0FBTyxDQUFDLEtBQUssU0FBSTtBQUN2RCxNQUFJLENBQUMsVUFBUyxRQUFPLE9BQU8sRUFBRSxRQUFRLElBQUksTUFBTTtBQUM1QyxRQUFJLE9BQU8sT0FBTyxJQUFJLFdBQVcsSUFBSTtBQUN6QyxTQUFPO0FBQ1gsR0FBRyxDQUFBLENBQUU7QUFFTCxtQkFBbUIsY0FBYztBQUNqQyxtQkFBbUIsYUFBYTtBQUNoQyxtQkFBbUIsWUFBWTtTQzNLZkMsT0FBRztBQUFBO1NBQ0gsT0FBTyxLQUFHO0FBQUksU0FBTztBQUFJO1NBQ3pCLGtCQUFrQixJQUFJLElBQUU7QUFHcEMsTUFBSSxNQUFNLFFBQVEsT0FBTztBQUFRLFdBQU87QUFDeEMsU0FBTyxTQUFVLEtBQUc7QUFDaEIsV0FBTyxHQUFHLEdBQUcsR0FBRyxDQUFDOztBQUV6QjtTQUVnQixTQUFTLEtBQUssS0FBRztBQUM3QixTQUFPLFdBQUE7QUFDSCxRQUFJLE1BQU0sTUFBTSxTQUFTO0FBQ3pCLFFBQUksTUFBTSxNQUFNLFNBQVM7O0FBRWpDO1NBRWdCLGtCQUFrQixJQUFJLElBQUU7QUFHcEMsTUFBSSxPQUFPQTtBQUFLLFdBQU87QUFDdkIsU0FBTyxXQUFBO0FBQ0gsUUFBSSxNQUFNLEdBQUcsTUFBTSxNQUFNLFNBQVM7QUFDbEMsUUFBSSxRQUFRO0FBQVcsZ0JBQVUsQ0FBQyxJQUFJO0FBQ3RDLFFBQUksWUFBWSxLQUFLLFdBQ2pCLFVBQVUsS0FBSztBQUNuQixTQUFLLFlBQVk7QUFDakIsU0FBSyxVQUFVO0FBQ2YsUUFBSSxPQUFPLEdBQUcsTUFBTSxNQUFNLFNBQVM7QUFDbkMsUUFBSTtBQUFXLFdBQUssWUFBWSxLQUFLLFlBQVksU0FBUyxXQUFXLEtBQUssU0FBUyxJQUFJO0FBQ3ZGLFFBQUk7QUFBUyxXQUFLLFVBQVUsS0FBSyxVQUFVLFNBQVMsU0FBUyxLQUFLLE9BQU8sSUFBSTtBQUM3RSxXQUFPLFNBQVMsU0FBWSxPQUFPOztBQUUzQztTQUVnQixrQkFBa0IsSUFBSSxJQUFFO0FBQ3BDLE1BQUksT0FBT0E7QUFBSyxXQUFPO0FBQ3ZCLFNBQU8sV0FBQTtBQUNILE9BQUcsTUFBTSxNQUFNLFNBQVM7QUFDeEIsUUFBSSxZQUFZLEtBQUssV0FDakIsVUFBVSxLQUFLO0FBQ25CLFNBQUssWUFBWSxLQUFLLFVBQVU7QUFDaEMsT0FBRyxNQUFNLE1BQU0sU0FBUztBQUN4QixRQUFJO0FBQVcsV0FBSyxZQUFZLEtBQUssWUFBWSxTQUFTLFdBQVcsS0FBSyxTQUFTLElBQUk7QUFDdkYsUUFBSTtBQUFTLFdBQUssVUFBVSxLQUFLLFVBQVUsU0FBUyxTQUFTLEtBQUssT0FBTyxJQUFJOztBQUVyRjtTQUVnQixrQkFBa0IsSUFBSSxJQUFFO0FBQ3BDLE1BQUksT0FBT0E7QUFBSyxXQUFPO0FBQ3ZCLFNBQU8sU0FBVSxlQUFhO0FBQzFCLFFBQUksTUFBTSxHQUFHLE1BQU0sTUFBTSxTQUFTO0FBQ2xDLFdBQU8sZUFBZSxHQUFHO0FBQ3pCLFFBQUksWUFBWSxLQUFLLFdBQ2pCLFVBQVUsS0FBSztBQUNuQixTQUFLLFlBQVk7QUFDakIsU0FBSyxVQUFVO0FBQ2YsUUFBSSxPQUFPLEdBQUcsTUFBTSxNQUFNLFNBQVM7QUFDbkMsUUFBSTtBQUFXLFdBQUssWUFBWSxLQUFLLFlBQVksU0FBUyxXQUFXLEtBQUssU0FBUyxJQUFJO0FBQ3ZGLFFBQUk7QUFBUyxXQUFLLFVBQVUsS0FBSyxVQUFVLFNBQVMsU0FBUyxLQUFLLE9BQU8sSUFBSTtBQUM3RSxXQUFPLFFBQVEsU0FDVixTQUFTLFNBQVksU0FBWSxPQUNqQyxPQUFPLEtBQUssSUFBSTs7QUFFN0I7U0FFZ0IsMkJBQTJCLElBQUksSUFBRTtBQUM3QyxNQUFJLE9BQU9BO0FBQUssV0FBTztBQUN2QixTQUFPLFdBQUE7QUFDSCxRQUFJLEdBQUcsTUFBTSxNQUFNLFNBQVMsTUFBTTtBQUFPLGFBQU87QUFDaEQsV0FBTyxHQUFHLE1BQU0sTUFBTSxTQUFTOztBQUV2QztTQVVnQixnQkFBZ0IsSUFBSSxJQUFFO0FBQ2xDLE1BQUksT0FBT0E7QUFBSyxXQUFPO0FBQ3ZCLFNBQU8sV0FBQTtBQUNILFFBQUksTUFBTSxHQUFHLE1BQU0sTUFBTSxTQUFTO0FBQ2xDLFFBQUksT0FBTyxPQUFPLElBQUksU0FBUyxZQUFZO0FBQ3ZDLFVBQUksT0FBTyxNQUNQLElBQUksVUFBVSxRQUNkSixRQUFPLElBQUksTUFBTSxDQUFDO0FBQ3RCLGFBQU87QUFBSyxRQUFBQSxNQUFLLENBQUMsSUFBSSxVQUFVLENBQUM7QUFDakMsYUFBTyxJQUFJLEtBQUssV0FBQTtBQUNaLGVBQU8sR0FBRyxNQUFNLE1BQU1BLEtBQUk7T0FDN0I7O0FBRUwsV0FBTyxHQUFHLE1BQU0sTUFBTSxTQUFTOztBQUV2QztBQ2hFQSxJQUFJLFdBQVcsQ0FBQTtBQUdmLElBQ0kseUJBQXlCO0FBRDdCLElBR0ksa0JBQWtCO0FBSHRCLElBSUksa0JBQWtCO0FBSnRCLElBS0ksQ0FBQyx1QkFBdUIsb0JBQW9CLHFCQUFxQixJQUFJLE9BQU8sWUFBWSxjQUNwRixDQUFBLEtBQ0MsTUFBQTtBQUNHLE1BQUksVUFBVSxRQUFRLFFBQU87QUFDN0IsTUFBSSxPQUFPLFdBQVcsZUFBZSxDQUFDLE9BQU87QUFDekMsV0FBTyxDQUFDLFNBQVMsU0FBUyxPQUFPLEdBQUcsT0FBTztBQUUvQyxRQUFNLFVBQVUsT0FBTyxPQUFPLE9BQU8sV0FBVyxJQUFJLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNuRSxTQUFPO0lBQ0g7SUFDQSxTQUFTLE9BQU87SUFDaEI7O0dBRVA7QUFsQlQsSUFtQkksb0JBQW9CLHNCQUFzQixtQkFBbUI7QUFFMUQsSUFBTSxnQkFBZ0IseUJBQXlCLHNCQUFzQjtBQUM1RSxJQUFNLHFCQUFxQixDQUFDLENBQUM7QUFFN0IsSUFBSSx3QkFBd0I7QUFTNUIsSUFBSSx1QkFBdUIsd0JBQ3ZCLE1BQUE7QUFBTyx3QkFBc0IsS0FBSyxZQUFZO0FBQUUsSUFFaEQsUUFBUSxlQUVKLGFBQWEsS0FBSyxNQUFNLFlBQVksSUFDcEMsUUFBUSxtQkFFSixNQUFBO0FBQ0ksTUFBSSxZQUFZLFNBQVMsY0FBYyxLQUFLO0FBQzVDLEVBQUMsSUFBSSxpQkFBaUIsTUFBQTtBQUNsQixpQkFBWTtBQUNaLGdCQUFZO0dBQ2YsRUFBRyxRQUFRLFdBQVcsRUFBRSxZQUFZLEtBQUksQ0FBRTtBQUMzQyxZQUFVLGFBQWEsS0FBSyxHQUFHO0lBS25DLE1BQUE7QUFBSyxhQUFXLGNBQWEsQ0FBQztBQUFFO0FBTzVDLElBQUksT0FBTyxTQUFVLFVBQVVBLE9BQUk7QUFDL0IsaUJBQWUsS0FBSyxDQUFDLFVBQVVBLEtBQUksQ0FBQztBQUNwQyxNQUFJLHNCQUFzQjtBQUN0Qix5QkFBb0I7QUFDcEIsMkJBQXVCOztBQUUvQjtBQUVBLElBQUkscUJBQXFCO0FBQXpCLElBQ0ksdUJBQXVCO0FBRDNCLElBRUksa0JBQWtCLENBQUE7QUFGdEIsSUFHSSxrQkFBa0IsQ0FBQTtBQUh0QixJQUlJLG1CQUFtQjtBQUp2QixJQUtJLGtCQUFrQjtBQUVmLElBQUksWUFBWTtFQUNuQixJQUFJO0VBQ0osUUFBUTtFQUNSLEtBQUs7RUFDTCxZQUFZLENBQUE7RUFDWixhQUFhO0VBQ2IsS0FBSztFQUNMLEtBQUssQ0FBQTtFQUNMLFVBQVUsV0FBQTtBQUNOLFNBQUssV0FBVyxRQUFRLFFBQUU7QUFDdEIsVUFBSTtBQUNBLG9CQUFZLEdBQUcsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDO2VBQ25CLEdBQVA7TUFBVTtLQUNmOzs7QUFJRixJQUFJLE1BQU07QUFFVixJQUFJLGlCQUFpQixDQUFBO0FBQ3JCLElBQUksb0JBQW9CO0FBQ3hCLElBQUksaUJBQWlCLENBQUE7U0FFSixhQUFhLElBQUU7QUFDbkMsTUFBSSxPQUFPLFNBQVM7QUFBVSxVQUFNLElBQUksVUFBVSxzQ0FBc0M7QUFDeEYsT0FBSyxhQUFhLENBQUE7QUFDbEIsT0FBSyxjQUFjSTtBQVFuQixPQUFLLE9BQU87QUFFWixNQUFJLE1BQU8sS0FBSyxPQUFPO0FBRXZCLE1BQUksT0FBTztBQUNQLFNBQUssZUFBZSxrQkFBaUI7QUFDckMsU0FBSyxRQUFRO0FBQ2IsU0FBSyxXQUFXOztBQUdwQixNQUFJLE9BQU8sT0FBTyxZQUFZO0FBQzFCLFFBQUksT0FBTztBQUFVLFlBQU0sSUFBSSxVQUFVLGdCQUFnQjtBQUd6RCxTQUFLLFNBQVMsVUFBVSxDQUFDO0FBQ3pCLFNBQUssU0FBUyxVQUFVLENBQUM7QUFDekIsUUFBSSxLQUFLLFdBQVc7QUFDaEIsc0JBQWdCLE1BQU0sS0FBSyxNQUFNO0FBQ3JDOztBQUdKLE9BQUssU0FBUztBQUNkLE9BQUssU0FBUztBQUNkLElBQUUsSUFBSTtBQUNOLHFCQUFtQixNQUFNLEVBQUU7QUFDL0I7QUFHQSxJQUFNLFdBQVc7RUFDYixLQUFLLFdBQUE7QUFDRCxRQUFJLE1BQU0sS0FBSyxjQUFjO0FBRTdCLGFBQVMsS0FBTSxhQUFhLFlBQVU7QUFDbEMsVUFBSSxnQkFBZ0IsQ0FBQyxJQUFJLFdBQVcsUUFBUSxPQUFPLGdCQUFnQjtBQUNuRSxZQUFNLFVBQVUsaUJBQWlCLENBQUMsd0JBQXVCO0FBQ3pELFVBQUksS0FBSyxJQUFJLGFBQWEsQ0FBQ0MsVUFBU0MsWUFBTTtBQUN0Qyw0QkFBb0IsTUFBTSxJQUFJLFNBQzFCLDBCQUEwQixhQUFhLEtBQUssZUFBZSxPQUFPLEdBQ2xFLDBCQUEwQixZQUFZLEtBQUssZUFBZSxPQUFPLEdBQ2pFRCxVQUNBQyxTQUNBLEdBQUcsQ0FBQztPQUNYO0FBQ0QsZUFBUyxzQkFBc0IsSUFBSSxJQUFJO0FBQ3ZDLGFBQU87O0FBR1gsU0FBSyxZQUFZO0FBRWpCLFdBQU87O0VBSVgsS0FBSyxTQUFVLE9BQUs7QUFDaEIsWUFBUyxNQUFNLFFBQVEsU0FBUyxNQUFNLGNBQWMsV0FDaEQsV0FDQTtNQUNJLEtBQUssV0FBQTtBQUNELGVBQU87O01BRVgsS0FBSyxTQUFTO0tBQ2pCOzs7QUFLYixNQUFNLGFBQWEsV0FBVztFQUMxQixNQUFNO0VBQ04sT0FBTyxTQUFVLGFBQWEsWUFBVTtBQUVwQyx3QkFBb0IsTUFBTSxJQUFJLFNBQVMsTUFBTSxNQUFNLGFBQWEsWUFBWSxHQUFHLENBQUM7O0VBR3BGLE9BQU8sU0FBVSxZQUFVO0FBQ3ZCLFFBQUksVUFBVSxXQUFXO0FBQUcsYUFBTyxLQUFLLEtBQUssTUFBTSxVQUFVO0FBRTdELFFBQUlDLFFBQU8sVUFBVSxDQUFDLEdBQ2xCLFVBQVUsVUFBVSxDQUFDO0FBQ3pCLFdBQU8sT0FBT0EsVUFBUyxhQUFhLEtBQUssS0FBSyxNQUFNLFNBR2hELGVBQWVBLFFBQU8sUUFBUSxHQUFHLElBQUksY0FBYyxHQUFHLENBQUMsSUFDekQsS0FBSyxLQUFLLE1BQU0sU0FJZCxPQUFPLElBQUksU0FBU0EsUUFBTyxRQUFRLEdBQUcsSUFBSSxjQUFjLEdBQUcsQ0FBQzs7RUFHcEUsU0FBUyxTQUFVLFdBQVM7QUFDeEIsV0FBTyxLQUFLLEtBQUssV0FBSztBQUNsQixnQkFBUztBQUNULGFBQU87T0FDUixTQUFHO0FBQ0YsZ0JBQVM7QUFDVCxhQUFPLGNBQWMsR0FBRztLQUMzQjs7RUFHTCxPQUFPO0lBQ0gsS0FBSyxXQUFBO0FBQ0QsVUFBSSxLQUFLO0FBQVEsZUFBTyxLQUFLO0FBQzdCLFVBQUk7QUFDQSxnQ0FBd0I7QUFDeEIsWUFBSSxTQUFTLFNBQVUsTUFBTSxDQUFBLEdBQUksZUFBZTtBQUNoRCxZQUFJLFFBQVEsT0FBTyxLQUFLLG1CQUFtQjtBQUMzQyxZQUFJLEtBQUssV0FBVztBQUFNLGVBQUssU0FBUztBQUN4QyxlQUFPOztBQUVQLGdDQUF3Qjs7OztFQUtwQyxTQUFTLFNBQVUsSUFBSSxLQUFHO0FBQ3RCLFdBQU8sS0FBSyxXQUNSLElBQUksYUFBYSxDQUFDRixVQUFTQyxZQUFNO0FBQzdCLFVBQUksU0FBUyxXQUFXLE1BQU1BLFFBQU8sSUFBSSxXQUFXLFFBQVEsR0FBRyxDQUFDLEdBQUcsRUFBRTtBQUNyRSxXQUFLLEtBQUtELFVBQVNDLE9BQU0sRUFBRSxRQUFRLGFBQWEsS0FBSyxNQUFNLE1BQU0sQ0FBQztLQUNyRSxJQUFJOztDQUVoQjtBQUVELElBQUksT0FBTyxXQUFXLGVBQWUsT0FBTztBQUN4QyxVQUFRLGFBQWEsV0FBVyxPQUFPLGFBQWEsZUFBZTtBQUl2RSxVQUFVLE1BQU0sU0FBUTtBQUV4QixTQUFTLFNBQVMsYUFBYSxZQUFZRCxVQUFTQyxTQUFRLE1BQUk7QUFDNUQsT0FBSyxjQUFjLE9BQU8sZ0JBQWdCLGFBQWEsY0FBYztBQUNyRSxPQUFLLGFBQWEsT0FBTyxlQUFlLGFBQWEsYUFBYTtBQUNsRSxPQUFLLFVBQVVEO0FBQ2YsT0FBSyxTQUFTQztBQUNkLE9BQUssTUFBTTtBQUNmO0FBR0EsTUFBTyxjQUFjO0VBQ2pCLEtBQUssV0FBQTtBQUNELFFBQUksU0FBUyxXQUFXLE1BQU0sTUFBTSxTQUFTLEVBQ3hDLElBQUksd0JBQXdCO0FBQ2pDLFdBQU8sSUFBSSxhQUFhLFNBQVVELFVBQVNDLFNBQU07QUFDN0MsVUFBSSxPQUFPLFdBQVc7QUFBRyxRQUFBRCxTQUFRLENBQUEsQ0FBRTtBQUNuQyxVQUFJLFlBQVksT0FBTztBQUN2QixhQUFPLFFBQVEsQ0FBQyxHQUFFLE1BQU0sYUFBYSxRQUFRLENBQUMsRUFBRSxLQUFLLE9BQUM7QUFDbEQsZUFBTyxDQUFDLElBQUk7QUFDWixZQUFJLENBQUMsRUFBRTtBQUFXLFVBQUFBLFNBQVEsTUFBTTtTQUNqQ0MsT0FBTSxDQUFDO0tBQ2I7O0VBR0wsU0FBUyxXQUFLO0FBQ1YsUUFBSSxpQkFBaUI7QUFBYyxhQUFPO0FBQzFDLFFBQUksU0FBUyxPQUFPLE1BQU0sU0FBUztBQUFZLGFBQU8sSUFBSSxhQUFhLENBQUNELFVBQVNDLFlBQU07QUFDbkYsY0FBTSxLQUFLRCxVQUFTQyxPQUFNO09BQzdCO0FBQ0QsUUFBSSxLQUFLLElBQUksYUFBYSxVQUFVLE1BQU0sS0FBSztBQUMvQywwQkFBc0IsSUFBSSxnQkFBZ0I7QUFDMUMsV0FBTzs7RUFHWCxRQUFRO0VBRVIsTUFBTSxXQUFBO0FBQ0YsUUFBSSxTQUFTLFdBQVcsTUFBTSxNQUFNLFNBQVMsRUFBRSxJQUFJLHdCQUF3QjtBQUMzRSxXQUFPLElBQUksYUFBYSxDQUFDRCxVQUFTQyxZQUFNO0FBQ3BDLGFBQU8sSUFBSSxXQUFTLGFBQWEsUUFBUSxLQUFLLEVBQUUsS0FBS0QsVUFBU0MsT0FBTSxDQUFDO0tBQ3hFOztFQUdMLEtBQUs7SUFDRCxLQUFLLE1BQUk7SUFDVCxLQUFLLFdBQVMsTUFBTTs7RUFHeEIsYUFBYSxFQUFDLEtBQUssTUFBSSxZQUFXO0VBSWxDLFFBQVE7RUFFUjtFQUVBLFdBQVc7SUFDUCxLQUFLLE1BQU07SUFDWCxLQUFLLFdBQUs7QUFBSyxhQUFPO0lBQUs7O0VBRy9CLGlCQUFpQjtJQUNiLEtBQUssTUFBTTtJQUNYLEtBQUssV0FBSztBQUFLLHdCQUFrQjtJQUFNOztFQUczQyxRQUFRLENBQUMsSUFBSSxjQUFTO0FBQ2xCLFdBQU8sSUFBSSxhQUFhLENBQUNELFVBQVNDLFlBQU07QUFDcEMsYUFBTyxTQUFTLENBQUNELFVBQVNDLFlBQU07QUFDNUIsWUFBSSxNQUFNO0FBQ1YsWUFBSSxhQUFhLENBQUE7QUFDakIsWUFBSSxjQUFjQTtBQUNsQixZQUFJLFdBQVcsU0FBUyxXQUFBO0FBSXBCLG1EQUF5QyxNQUFBO0FBQ3JDLGlCQUFLLFdBQVcsV0FBVyxJQUFJRCxTQUFPLElBQUtDLFFBQU8sS0FBSyxXQUFXLENBQUMsQ0FBQztXQUN2RTtXQUNGLElBQUksUUFBUTtBQUNmLFdBQUU7U0FDSCxXQUFXRCxVQUFTQyxPQUFNO0tBQ2hDOztDQUVSO0FBRUQsSUFBSSxlQUFlO0FBQ2YsTUFBSSxjQUFjO0FBQVksWUFBUyxjQUFjLGNBQWMsV0FBQTtBQUMvRCxZQUFNLG1CQUFtQixXQUFXLE1BQU0sTUFBTSxTQUFTLEVBQUUsSUFBSSx3QkFBd0I7QUFDdkYsYUFBTyxJQUFJLGFBQWEsQ0FBQUQsYUFBTztBQUMzQixZQUFJLGlCQUFpQixXQUFXO0FBQUcsVUFBQUEsU0FBUSxDQUFBLENBQUU7QUFDN0MsWUFBSSxZQUFZLGlCQUFpQjtBQUNqQyxjQUFNLFVBQVUsSUFBSSxNQUFNLFNBQVM7QUFDbkMseUJBQWlCLFFBQVEsQ0FBQyxHQUFHLE1BQU0sYUFBYSxRQUFRLENBQUMsRUFBRSxLQUN2RCxXQUFTLFFBQVEsQ0FBQyxJQUFJLEVBQUMsUUFBUSxhQUFhLE1BQUssR0FDakQsWUFBVSxRQUFRLENBQUMsSUFBSSxFQUFDLFFBQVEsWUFBWSxPQUFNLENBQUMsRUFDbEQsS0FBSyxNQUFJLEVBQUUsYUFBYUEsU0FBUSxPQUFPLENBQUMsQ0FBQztPQUNqRDtLQUNKO0FBQ0QsTUFBSSxjQUFjLE9BQU8sT0FBTyxtQkFBbUI7QUFBYSxZQUFRLGNBQWMsT0FBTyxXQUFBO0FBQ3pGLFlBQU0sbUJBQW1CLFdBQVcsTUFBTSxNQUFNLFNBQVMsRUFBRSxJQUFJLHdCQUF3QjtBQUN2RixhQUFPLElBQUksYUFBYSxDQUFDQSxVQUFTQyxZQUFNO0FBQ3BDLFlBQUksaUJBQWlCLFdBQVc7QUFBRyxVQUFBQSxRQUFPLElBQUksZUFBZSxDQUFBLENBQUUsQ0FBQztBQUNoRSxZQUFJLFlBQVksaUJBQWlCO0FBQ2pDLGNBQU0sV0FBVyxJQUFJLE1BQU0sU0FBUztBQUNwQyx5QkFBaUIsUUFBUSxDQUFDLEdBQUcsTUFBTSxhQUFhLFFBQVEsQ0FBQyxFQUFFLEtBQ3ZELFdBQVNELFNBQVEsS0FBSyxHQUN0QixhQUFPO0FBQ0gsbUJBQVMsQ0FBQyxJQUFJO0FBQ2QsY0FBSSxDQUFDLEVBQUU7QUFBVyxZQUFBQyxRQUFPLElBQUksZUFBZSxRQUFRLENBQUM7U0FDeEQsQ0FBQztPQUNUO0tBQ0o7O0FBU0wsU0FBUyxtQkFBb0IsU0FBUyxJQUFFO0FBR3BDLE1BQUk7QUFDQSxPQUFHLFdBQUs7QUFDSixVQUFJLFFBQVEsV0FBVztBQUFNO0FBQzdCLFVBQUksVUFBVTtBQUFTLGNBQU0sSUFBSSxVQUFVLDJDQUEyQztBQUN0RixVQUFJLG9CQUFvQixRQUFRLFFBQVEsb0JBQW1CO0FBQzNELFVBQUksU0FBUyxPQUFPLE1BQU0sU0FBUyxZQUFZO0FBQzNDLDJCQUFtQixTQUFTLENBQUNELFVBQVNDLFlBQU07QUFDeEMsMkJBQWlCLGVBQ2IsTUFBTSxNQUFNRCxVQUFTQyxPQUFNLElBQzNCLE1BQU0sS0FBS0QsVUFBU0MsT0FBTTtTQUNqQzthQUNFO0FBQ0gsZ0JBQVEsU0FBUztBQUNqQixnQkFBUSxTQUFTO0FBQ2pCLDhCQUFzQixPQUFPOztBQUVqQyxVQUFJO0FBQW1CLDBCQUFpQjtPQUN6QyxnQkFBZ0IsS0FBSyxNQUFNLE9BQU8sQ0FBQztXQUNqQyxJQUFQO0FBQ0Usb0JBQWdCLFNBQVMsRUFBRTs7QUFFbkM7QUFFQSxTQUFTLGdCQUFpQixTQUFTLFFBQU07QUFDckMsa0JBQWdCLEtBQUssTUFBTTtBQUMzQixNQUFJLFFBQVEsV0FBVztBQUFNO0FBQzdCLE1BQUksb0JBQW9CLFFBQVEsUUFBUSxvQkFBbUI7QUFDM0QsV0FBUyxnQkFBZ0IsTUFBTTtBQUMvQixVQUFRLFNBQVM7QUFDakIsVUFBUSxTQUFTO0FBQ2pCLFdBQVMsV0FBVyxRQUFRLE9BQU8sV0FBVyxZQUFZLENBQUMsT0FBTyxZQUFZLFNBQVMsTUFBQTtBQUNuRixRQUFJLFdBQVcsc0JBQXNCLFFBQVEsT0FBTztBQUNwRCxXQUFPLFdBQVc7QUFDbEIsWUFBUSxRQUFRLFNBQVM7TUFDckIsS0FBSyxNQUNELHdCQUNJLGFBQWEsU0FBUyxNQUNWLFNBQVMsSUFBSSxNQUFNLE1BQU0sSUFDekIsU0FBUyxTQUNyQixRQUFRO0tBQ25CO0dBQ0o7QUFFRCw0QkFBMEIsT0FBTztBQUNqQyx3QkFBc0IsT0FBTztBQUM3QixNQUFJO0FBQW1CLHNCQUFpQjtBQUM1QztBQUVBLFNBQVMsc0JBQXVCLFNBQU87QUFFbkMsTUFBSSxZQUFZLFFBQVE7QUFDeEIsVUFBUSxhQUFhLENBQUE7QUFDckIsV0FBUyxJQUFJLEdBQUcsTUFBTSxVQUFVLFFBQVEsSUFBSSxLQUFLLEVBQUUsR0FBRztBQUNsRCx3QkFBb0IsU0FBUyxVQUFVLENBQUMsQ0FBQzs7QUFFN0MsTUFBSSxNQUFNLFFBQVE7QUFDbEIsSUFBRSxJQUFJLE9BQU8sSUFBSSxTQUFRO0FBQ3pCLE1BQUksc0JBQXNCLEdBQUc7QUFNekIsTUFBRTtBQUNGLFNBQUssTUFBQTtBQUNELFVBQUksRUFBRSxzQkFBc0I7QUFBRyw2QkFBb0I7T0FDcEQsQ0FBQSxDQUFFOztBQUViO0FBRUEsU0FBUyxvQkFBb0IsU0FBUyxVQUFRO0FBQzFDLE1BQUksUUFBUSxXQUFXLE1BQU07QUFDekIsWUFBUSxXQUFXLEtBQUssUUFBUTtBQUNoQzs7QUFHSixNQUFJLEtBQUssUUFBUSxTQUFTLFNBQVMsY0FBYyxTQUFTO0FBQzFELE1BQUksT0FBTyxNQUFNO0FBRWIsWUFBUSxRQUFRLFNBQVMsU0FBUyxVQUFVLFNBQVMsUUFBUyxRQUFRLE1BQU07O0FBRWhGLElBQUUsU0FBUyxJQUFJO0FBQ2YsSUFBRTtBQUNGLE9BQU0sY0FBYyxDQUFDLElBQUksU0FBUyxRQUFRLENBQUM7QUFDL0M7QUFFQSxTQUFTLGFBQWMsSUFBSSxTQUFTLFVBQVE7QUFDeEMsTUFBSTtBQUdBLHVCQUFtQjtBQUduQixRQUFJLEtBQUssUUFBUSxRQUFRO0FBRXpCLFFBQUksUUFBUSxRQUFRO0FBRWhCLFlBQU0sR0FBSSxLQUFLO1dBQ1o7QUFFSCxVQUFJLGdCQUFnQjtBQUFRLDBCQUFrQixDQUFBO0FBQzlDLFlBQU0sR0FBRyxLQUFLO0FBQ2QsVUFBSSxnQkFBZ0IsUUFBUSxLQUFLLE1BQU07QUFDbkMsMkJBQW1CLE9BQU87O0FBRWxDLGFBQVMsUUFBUSxHQUFHO1dBQ2YsR0FBUDtBQUVFLGFBQVMsT0FBTyxDQUFDOztBQUdqQix1QkFBbUI7QUFDbkIsUUFBSSxFQUFFLHNCQUFzQjtBQUFHLDJCQUFvQjtBQUNuRCxNQUFFLFNBQVMsSUFBSSxPQUFPLFNBQVMsSUFBSSxTQUFROztBQUVuRDtBQUVBLFNBQVMsU0FBVSxTQUFTLFFBQVEsT0FBSztBQUNyQyxNQUFJLE9BQU8sV0FBVztBQUFPLFdBQU87QUFDcEMsTUFBSSxRQUFRO0FBQ1osTUFBSSxRQUFRLFdBQVcsT0FBTztBQUMxQixRQUFJLFVBQVUsUUFBUSxRQUNsQixXQUNBO0FBRUosUUFBSSxXQUFXLE1BQU07QUFDakIsa0JBQVksUUFBUSxRQUFRO0FBQzVCLGdCQUFVLFFBQVEsV0FBVztBQUM3QixjQUFRLFlBQVksU0FBUyxDQUFDO1dBQzNCO0FBQ0gsa0JBQVk7QUFDWixnQkFBVTs7QUFFZCxXQUFPLEtBQUssYUFBYSxVQUFVLE9BQU8sVUFBVSxNQUFNLEtBQUs7O0FBRW5FLE1BQUksT0FBTztBQUNQLFlBQVEsWUFBWSxRQUFRLGNBQWMsQ0FBQztBQUMzQyxRQUFJLFNBQVMsT0FBTyxRQUFRLEtBQUssTUFBTTtBQUFJLGFBQU8sS0FBSyxLQUFLO0FBQzVELFFBQUksUUFBUTtBQUFPLGVBQVMsUUFBUSxPQUFPLFFBQVEsS0FBSzs7QUFFNUQsU0FBTztBQUNYO0FBRUEsU0FBUyxzQkFBc0IsU0FBUyxNQUFJO0FBRXhDLE1BQUksVUFBVSxPQUFPLEtBQUssV0FBVyxJQUFJO0FBQ3pDLE1BQUksVUFBVSx3QkFBd0I7QUFDbEMsWUFBUSxRQUFRO0FBQ2hCLFlBQVEsV0FBVzs7QUFFM0I7QUFLQSxTQUFTLGVBQVk7QUFDakIsc0JBQW1CLEtBQU0sa0JBQWlCO0FBQzlDO1NBRWdCLHNCQUFtQjtBQUMvQixNQUFJLGNBQWM7QUFDbEIsdUJBQXFCO0FBQ3JCLHlCQUF1QjtBQUN2QixTQUFPO0FBQ1g7U0FVZ0Isb0JBQWlCO0FBQzdCLE1BQUksV0FBVyxHQUFHO0FBQ2xCLEtBQUc7QUFDQyxXQUFPLGVBQWUsU0FBUyxHQUFHO0FBQzlCLGtCQUFZO0FBQ1osdUJBQWlCLENBQUE7QUFDakIsVUFBSSxVQUFVO0FBQ2QsV0FBSyxJQUFJLEdBQUcsSUFBSSxHQUFHLEVBQUUsR0FBRztBQUNwQixZQUFJLE9BQU8sVUFBVSxDQUFDO0FBQ3RCLGFBQUssQ0FBQyxFQUFFLE1BQU0sTUFBTSxLQUFLLENBQUMsQ0FBQzs7O1dBRzlCLGVBQWUsU0FBUztBQUNqQyx1QkFBcUI7QUFDckIseUJBQXVCO0FBQzNCO0FBRUEsU0FBUyx1QkFBb0I7QUFDekIsTUFBSSxnQkFBZ0I7QUFDcEIsb0JBQWtCLENBQUE7QUFDbEIsZ0JBQWMsUUFBUSxPQUFDO0FBQ25CLE1BQUUsS0FBSyxZQUFZLEtBQUssTUFBTSxFQUFFLFFBQVEsQ0FBQztHQUM1QztBQUNELE1BQUksYUFBYSxlQUFlLE1BQU0sQ0FBQztBQUN2QyxNQUFJLElBQUksV0FBVztBQUNuQixTQUFPO0FBQUcsZUFBVyxFQUFFLENBQUMsRUFBQztBQUM3QjtBQUVBLFNBQVMseUNBQTBDLElBQUU7QUFDakQsV0FBUyxZQUFTO0FBQ2QsT0FBRTtBQUNGLG1CQUFlLE9BQU8sZUFBZSxRQUFRLFNBQVMsR0FBRyxDQUFDOztBQUU5RCxpQkFBZSxLQUFLLFNBQVM7QUFDN0IsSUFBRTtBQUNGLE9BQUssTUFBQTtBQUNELFFBQUksRUFBRSxzQkFBc0I7QUFBRywyQkFBb0I7S0FDcEQsQ0FBQSxDQUFFO0FBQ1Q7QUFFQSxTQUFTLDBCQUEwQixTQUFPO0FBSXRDLE1BQUksQ0FBQyxnQkFBZ0IsS0FBSyxPQUFLLEVBQUUsV0FBVyxRQUFRLE1BQU07QUFDdEQsb0JBQWdCLEtBQUssT0FBTztBQUNwQztBQUVBLFNBQVMsbUJBQW1CLFNBQU87QUFJL0IsTUFBSSxJQUFJLGdCQUFnQjtBQUN4QixTQUFPO0FBQUcsUUFBSSxnQkFBZ0IsRUFBRSxDQUFDLEVBQUUsV0FBVyxRQUFRLFFBQVE7QUFHMUQsc0JBQWdCLE9BQU8sR0FBRyxDQUFDO0FBQzNCOztBQUVSO0FBRUEsU0FBUyxjQUFlLFFBQU07QUFDMUIsU0FBTyxJQUFJLGFBQWEsVUFBVSxPQUFPLE1BQU07QUFDbkQ7U0FFZ0IsS0FBTSxJQUFJLGNBQVk7QUFDbEMsTUFBSSxNQUFNO0FBQ1YsU0FBTyxXQUFBO0FBQ0gsUUFBSSxjQUFjLG9CQUFtQixHQUNqQyxhQUFhO0FBRWpCLFFBQUk7QUFDQSxtQkFBYSxLQUFLLElBQUk7QUFDdEIsYUFBTyxHQUFHLE1BQU0sTUFBTSxTQUFTO2FBQzFCLEdBQVA7QUFDRSxzQkFBZ0IsYUFBYSxDQUFDOztBQUU5QixtQkFBYSxZQUFZLEtBQUs7QUFDOUIsVUFBSTtBQUFhLDBCQUFpQjs7O0FBRzlDO0FBTUEsSUFBTSxPQUFPLEVBQUUsUUFBUSxHQUFHLFFBQVEsR0FBRyxJQUFJLEVBQUM7QUFDMUMsSUFBSSxjQUFjO0FBQ2xCLElBQUksWUFBWSxDQUFBO0FBQ2hCLElBQUksYUFBYTtBQUNqQixJQUFJLGNBQWM7QUFHbEIsSUFBSSxrQkFBa0I7U0FDTixTQUFVLElBQUlFLFFBQU8sSUFBSSxJQUFFO0FBQ3ZDLE1BQUksU0FBUyxLQUNULE1BQU0sT0FBTyxPQUFPLE1BQU07QUFDOUIsTUFBSSxTQUFTO0FBQ2IsTUFBSSxNQUFNO0FBQ1YsTUFBSSxTQUFTO0FBQ2IsTUFBSSxLQUFLLEVBQUU7QUFFWCxNQUFJLFlBQVksVUFBVTtBQUMxQixNQUFJLE1BQU0scUJBQXFCO0lBQzNCLFNBQVM7SUFDVCxhQUFhLEVBQUMsT0FBTyxjQUFjLGNBQWMsTUFBTSxVQUFVLEtBQUk7SUFDckUsS0FBSyxhQUFhO0lBQ2xCLE1BQU0sYUFBYTtJQUNuQixZQUFZLGFBQWE7SUFDekIsS0FBSyxhQUFhO0lBQ2xCLFNBQVMsYUFBYTtJQUN0QixRQUFRLGFBQWE7SUFDckIsT0FBTyxzQkFBdUIsVUFBVSxPQUFPLEdBQUc7SUFDbEQsT0FBTyxzQkFBdUIsVUFBVSxPQUFPLEdBQUc7TUFDbEQsQ0FBQTtBQUNKLE1BQUlBO0FBQU8sV0FBTyxLQUFLQSxNQUFLO0FBTTVCLElBQUUsT0FBTztBQUNULE1BQUksV0FBVyxXQUFBO0FBQ1gsTUFBRSxLQUFLLE9BQU8sT0FBTyxLQUFLLE9BQU8sU0FBUTs7QUFFN0MsTUFBSSxLQUFLLE9BQVEsS0FBSyxJQUFJLElBQUksRUFBRTtBQUNoQyxNQUFJLElBQUksUUFBUTtBQUFHLFFBQUksU0FBUTtBQUMvQixTQUFPO0FBQ1g7U0FJZ0IsMEJBQXVCO0FBQ25DLE1BQUksQ0FBQyxLQUFLO0FBQUksU0FBSyxLQUFLLEVBQUU7QUFDMUIsSUFBRSxLQUFLO0FBQ1AsT0FBSyxVQUFVO0FBQ2YsU0FBTyxLQUFLO0FBQ2hCO1NBS2dCLDBCQUF1QjtBQUNuQyxNQUFJLENBQUMsS0FBSztBQUFRLFdBQU87QUFDekIsTUFBSSxFQUFFLEtBQUssV0FBVztBQUFHLFNBQUssS0FBSztBQUNuQyxPQUFLLFNBQVMsS0FBSyxTQUFTO0FBQzVCLFNBQU87QUFDWDtBQUVBLEtBQUssS0FBRyxtQkFBbUIsUUFBUSxlQUFlLE1BQU0sSUFBSTtBQUd4RCw0QkFBMEIsMEJBQTBCSjs7U0FJeEMseUJBQTBCLGlCQUFlO0FBQ3JELE1BQUksS0FBSyxVQUFVLG1CQUFtQixnQkFBZ0IsZ0JBQWdCLGVBQWU7QUFDakYsNEJBQXVCO0FBQ3ZCLFdBQU8sZ0JBQWdCLEtBQUssT0FBQztBQUN6Qiw4QkFBdUI7QUFDdkIsYUFBTztPQUNSLE9BQUM7QUFDQSw4QkFBdUI7QUFDdkIsYUFBTyxVQUFVLENBQUM7S0FDckI7O0FBRUwsU0FBTztBQUNYO0FBRUEsU0FBUyxjQUFjLFlBQVU7QUFDN0IsSUFBRTtBQUVGLE1BQUksQ0FBQyxLQUFLLFVBQVUsRUFBRSxLQUFLLFdBQVcsR0FBRztBQUNyQyxTQUFLLFNBQVMsS0FBSyxLQUFLOztBQUc1QixZQUFVLEtBQUssR0FBRztBQUNsQixlQUFhLFlBQVksSUFBSTtBQUNqQztBQUVBLFNBQVMsZ0JBQWE7QUFDbEIsTUFBSSxPQUFPLFVBQVUsVUFBVSxTQUFPLENBQUM7QUFDdkMsWUFBVSxJQUFHO0FBQ2IsZUFBYSxNQUFNLEtBQUs7QUFDNUI7QUFFQSxTQUFTLGFBQWMsWUFBWSxlQUFhO0FBQzVDLE1BQUksY0FBYztBQUNsQixNQUFJLGdCQUFnQixLQUFLLFdBQVcsQ0FBQyxnQkFBZ0IsZUFBZSxPQUFPLGVBQWUsQ0FBQyxFQUFFLGNBQWMsZUFBZSxNQUFNO0FBRzVILDJCQUF1QixnQkFBZ0IsY0FBYyxLQUFLLE1BQU0sVUFBVSxJQUFJLGFBQWE7O0FBRS9GLE1BQUksZUFBZTtBQUFLO0FBRXhCLFFBQU07QUFHTixNQUFJLGdCQUFnQjtBQUFXLGNBQVUsTUFBTSxTQUFRO0FBRXZELE1BQUksb0JBQW9CO0FBRXBCLFFBQUksZ0JBQWdCLFVBQVUsSUFBSTtBQUVsQyxRQUFJLFlBQVksV0FBVztBQUkzQix1QkFBbUIsT0FBTyxVQUFVO0FBQ3BDLGtCQUFjLFVBQVUsT0FBTyxVQUFVO0FBRXpDLFFBQUksWUFBWSxVQUFVLFdBQVcsUUFBUTtBQUl6QyxhQUFPLGVBQWUsU0FBUyxXQUFXLFVBQVUsV0FBVztBQUkvRCxvQkFBYyxNQUFNLFVBQVU7QUFDOUIsb0JBQWMsT0FBTyxVQUFVO0FBQy9CLG9CQUFjLFVBQVUsVUFBVTtBQUNsQyxvQkFBYyxTQUFTLFVBQVU7QUFDakMsVUFBSSxVQUFVO0FBQVksc0JBQWMsYUFBYSxVQUFVO0FBQy9ELFVBQUksVUFBVTtBQUFLLHNCQUFjLE1BQU0sVUFBVTs7O0FBRzdEO0FBRUEsU0FBUyxXQUFRO0FBQ2IsTUFBSSxnQkFBZ0IsUUFBUTtBQUM1QixTQUFPLHFCQUFxQjtJQUN4QixTQUFTO0lBQ1QsYUFBYSxPQUFPLHlCQUF5QixTQUFTLFNBQVM7SUFDL0QsS0FBSyxjQUFjO0lBQ25CLE1BQU0sY0FBYztJQUNwQixZQUFZLGNBQWM7SUFDMUIsS0FBSyxjQUFjO0lBQ25CLFNBQVMsY0FBYztJQUN2QixRQUFRLGNBQWM7SUFDdEIsT0FBTyxtQkFBbUI7SUFDMUIsT0FBTyxjQUFjLFVBQVU7TUFDL0IsQ0FBQTtBQUNSO1NBRWdCLE9BQVEsS0FBSyxJQUFJLElBQUksSUFBSSxJQUFFO0FBQ3ZDLE1BQUksYUFBYTtBQUNqQixNQUFJO0FBQ0EsaUJBQWEsS0FBSyxJQUFJO0FBQ3RCLFdBQU8sR0FBRyxJQUFJLElBQUksRUFBRTs7QUFFcEIsaUJBQWEsWUFBWSxLQUFLOztBQUV0QztBQUVBLFNBQVMsdUJBQXdCLEtBQUc7QUFJaEMsb0JBQWtCLEtBQUssdUJBQXVCLEdBQUc7QUFDckQ7QUFFQSxTQUFTLDBCQUEwQixJQUFJLE1BQU0sZUFBZSxTQUFPO0FBQy9ELFNBQU8sT0FBTyxPQUFPLGFBQWEsS0FBSyxXQUFBO0FBQ25DLFFBQUksWUFBWTtBQUNoQixRQUFJO0FBQWUsOEJBQXVCO0FBQzFDLGlCQUFhLE1BQU0sSUFBSTtBQUN2QixRQUFJO0FBQ0EsYUFBTyxHQUFHLE1BQU0sTUFBTSxTQUFTOztBQUUvQixtQkFBYSxXQUFXLEtBQUs7QUFDN0IsVUFBSTtBQUFTLCtCQUF1Qix1QkFBdUI7OztBQUd2RTtBQUVBLFNBQVMsc0JBQXVCLFVBQVUsTUFBSTtBQUMxQyxTQUFPLFNBQVUsWUFBWSxZQUFVO0FBQ25DLFdBQU8sU0FBUyxLQUFLLE1BQ2pCLDBCQUEwQixZQUFZLElBQUksR0FDMUMsMEJBQTBCLFlBQVksSUFBSSxDQUFDOztBQUV2RDtBQUVBLElBQU0scUJBQXFCO0FBRTNCLFNBQVMsWUFBWSxLQUFLLFNBQU87QUFDN0IsTUFBSTtBQUNKLE1BQUk7QUFDQSxTQUFLLFFBQVEsWUFBWSxHQUFHO1dBQ3ZCLEdBQVA7RUFBVTtBQUNaLE1BQUksT0FBTztBQUFPLFFBQUk7QUFDbEIsVUFBSSxPQUFPLFlBQVksRUFBQyxTQUFrQixRQUFRLElBQUc7QUFDckQsVUFBSSxRQUFRLFlBQVksU0FBUyxhQUFhO0FBQzFDLGdCQUFRLFNBQVMsWUFBWSxPQUFPO0FBQ3BDLGNBQU0sVUFBVSxvQkFBb0IsTUFBTSxJQUFJO0FBQzlDLGVBQU8sT0FBTyxTQUFTO2lCQUNoQixRQUFRLGFBQWE7QUFDNUIsZ0JBQVEsSUFBSSxZQUFZLG9CQUFvQixFQUFDLFFBQVEsVUFBUyxDQUFDO0FBQy9ELGVBQU8sT0FBTyxTQUFTOztBQUUzQixVQUFJLFNBQVMsUUFBUSxlQUFlO0FBQ2hDLHNCQUFjLEtBQUs7QUFDbkIsWUFBSSxDQUFDLFFBQVEseUJBQXlCLFFBQVE7QUFFMUMsY0FBSTtBQUFDLG9CQUFRLHFCQUFxQixLQUFLO21CQUFXLEdBQVA7VUFBVTs7QUFFN0QsVUFBSSxTQUFTLFNBQVMsQ0FBQyxNQUFNLGtCQUFrQjtBQUMzQyxnQkFBUSxLQUFLLHdCQUF3QixJQUFJLFNBQVMsS0FBSzs7YUFFdEQsR0FBUDtJQUFVO0FBQ2hCO0FBRU8sSUFBSSxZQUFZLGFBQWE7U0NoM0JwQixnQkFDZCxJQUNBLE1BQ0EsWUFDQSxJQUFnRDtBQUdoRCxNQUFJLENBQUMsR0FBRyxTQUFVLENBQUMsR0FBRyxPQUFPLGlCQUFpQixDQUFDLElBQUksY0FBYyxDQUFDLEdBQUcsT0FBUTtBQUMzRSxRQUFJLEdBQUcsT0FBTyxjQUFjO0FBRzFCLGFBQU8sVUFBVSxJQUFJLFdBQVcsZUFBZSxHQUFHLE9BQU8sV0FBVyxDQUFDOztBQUV2RSxRQUFJLENBQUMsR0FBRyxPQUFPLGVBQWU7QUFDNUIsVUFBSSxDQUFDLEdBQUcsU0FBUztBQUNmLGVBQU8sVUFBVSxJQUFJLFdBQVcsZUFBYyxDQUFFO0FBQ2xELFNBQUcsS0FBSSxFQUFHLE1BQU1BLElBQUc7O0FBRXJCLFdBQU8sR0FBRyxPQUFPLGVBQWUsS0FBSyxNQUFNLGdCQUFnQixJQUFJLE1BQU0sWUFBWSxFQUFFLENBQUM7U0FDL0U7QUFDTCxRQUFJLFFBQVEsR0FBRyxtQkFBbUIsTUFBTSxZQUFZLEdBQUcsU0FBUztBQUNoRSxRQUFJO0FBQ0YsWUFBTSxPQUFNO0FBQ1osU0FBRyxPQUFPLGlCQUFpQjthQUNwQixJQUFQO0FBQ0EsVUFBSSxHQUFHLFNBQVMsU0FBUyxnQkFBZ0IsR0FBRyxPQUFNLEtBQU0sRUFBRSxHQUFHLE9BQU8saUJBQWlCLEdBQUc7QUFDdEYsZ0JBQVEsS0FBSywwQkFBMEI7QUFDdkMsV0FBRyxPQUFNO0FBQ1QsZUFBTyxHQUFHLEtBQUksRUFBRyxLQUFLLE1BQUksZ0JBQWdCLElBQUksTUFBTSxZQUFZLEVBQUUsQ0FBQzs7QUFFckUsYUFBTyxVQUFVLEVBQUU7O0FBRXJCLFdBQU8sTUFBTSxTQUFTLE1BQU0sQ0FBQ0MsVUFBU0MsWUFBTTtBQUMxQyxhQUFPLFNBQVMsTUFBQTtBQUNkLFlBQUksUUFBUTtBQUNaLGVBQU8sR0FBR0QsVUFBU0MsU0FBUSxLQUFLO09BQ2pDO0tBQ0YsRUFBRSxLQUFLLFlBQU07QUFXWixhQUFPLE1BQU0sWUFBWSxLQUFLLE1BQU0sTUFBTTtLQUMzQzs7QUFLTDtBQzdETyxJQUFNLGdCQUFnQjtBQUN0QixJQUFNLFlBQVksT0FBTyxhQUFhLEtBQUs7QUFDM0MsSUFBTSxTQUFTO0FBQ2YsSUFBTSx1QkFDWDtBQUNLLElBQU0sa0JBQWtCO0FBQ3hCLElBQU0sY0FBdUIsQ0FBQTtBQUM3QixJQUFNLGFBQ1gsT0FBTyxjQUFjLGVBQWUsc0JBQXNCLEtBQUssVUFBVSxTQUFTO0FBQzdFLElBQU0sNEJBQTRCO0FBQ2xDLElBQU0sNkJBQTZCO0FBQ25DLElBQU0sd0JBQXdCLFdBQVMsQ0FBQyw2QkFBNkIsS0FBSyxLQUFLO0FBQy9FLElBQU0sYUFBYTtBQUNuQixJQUFNLFdBQVc7QUFDakIsSUFBTSxZQUFZO1NDaEJULFFBQVEsU0FBUyxTQUFPO0FBQ3RDLFNBQU8sVUFDSCxVQUNJLFdBQUE7QUFBYyxXQUFPLFFBQVEsTUFBTSxNQUFNLFNBQVMsS0FBSyxRQUFRLE1BQU0sTUFBTSxTQUFTO0VBQUUsSUFDdEYsVUFDSjtBQUNOO0FDSk8sSUFBTSxXQUEyQjtFQUN0QyxNQUFJO0VBQ0osT0FBTztFQUNQLFdBQVc7RUFDWCxPQUFPLENBQUMsQ0FBQSxDQUFFO0VBQ1YsV0FBVzs7U0NGRyw4QkFBOEIsU0FBbUM7QUFFL0UsU0FBTyxPQUFPLFlBQVksWUFBWSxDQUFDLEtBQUssS0FBSyxPQUFPLElBQ3RELENBQUMsUUFBVztBQUNaLFFBQUksSUFBSSxPQUFPLE1BQU0sVUFBYyxXQUFXLEtBQU07QUFJbEQsWUFBTSxVQUFVLEdBQUc7QUFDbkIsYUFBTyxJQUFJLE9BQU87O0FBRXBCLFdBQU87TUFFUCxDQUFDLFFBQWdCO0FBQ3JCO0lDSWEsY0FBSztFQVFoQixPQUNFLE1BQ0EsSUFDQSxhQUE4QjtBQUU5QixVQUFNLFFBQXFCLEtBQUssT0FBTyxJQUFJO0FBQzNDLFVBQU0sWUFBWSxLQUFLO0FBRXZCLGFBQVMsd0JBQXdCRCxVQUFTQyxTQUFRRyxRQUFrQjtBQUNsRSxVQUFJLENBQUNBLE9BQU0sT0FBTyxTQUFTO0FBQ3pCLGNBQU0sSUFBSSxXQUFXLFNBQVMsV0FBVyxZQUFZLDBCQUEwQjtBQUNqRixhQUFPLEdBQUdBLE9BQU0sVUFBVUEsTUFBSzs7QUFlakMsVUFBTSxjQUFjLG9CQUFtQjtBQUN2QyxRQUFJO0FBQ0YsYUFBTyxTQUFTLE1BQU0sT0FBTyxLQUFLLEtBQ2hDLFVBQVUsSUFBSSxRQUNaLE1BQU0sU0FBUyxNQUFNLHlCQUF5QixXQUFXLElBQ3pELFNBQVMsTUFBTSxNQUFNLFNBQVMsTUFBTSx5QkFBeUIsV0FBVyxHQUFHLEVBQUUsT0FBYyxXQUFXLElBQUksYUFBYSxJQUFHLENBQUUsSUFDOUgsZ0JBQWdCLEtBQUssSUFBSSxNQUFNLENBQUMsS0FBSyxJQUFJLEdBQUcsdUJBQXVCOztBQUVyRSxVQUFJO0FBQWEsMEJBQWlCOzs7RUFTdEMsSUFBSSxXQUFXLElBQUc7QUFDaEIsUUFBSSxhQUFhLFVBQVUsZ0JBQWdCO0FBQ3pDLGFBQU8sS0FBSyxNQUFNLFNBQTZDLEVBQUUsTUFBTSxFQUFFO0FBRTNFLFdBQU8sS0FBSyxPQUFPLFlBQVksQ0FBQyxVQUFLO0FBQ25DLGFBQU8sS0FBSyxLQUFLLElBQUksRUFBQyxPQUFPLEtBQUssVUFBUyxDQUFDLEVBQ3pDLEtBQUssU0FBTyxLQUFLLEtBQUssUUFBUSxLQUFLLEdBQUcsQ0FBQztLQUMzQyxFQUFFLEtBQUssRUFBRTs7RUFRWixNQUFNLGFBQWlFO0FBQ3JFLFFBQUksT0FBTyxnQkFBZ0I7QUFDekIsYUFBTyxJQUFJLEtBQUssR0FBRyxZQUFZLE1BQU0sV0FBVztBQUNsRCxRQUFJVixTQUFRLFdBQVc7QUFDckIsYUFBTyxJQUFJLEtBQUssR0FBRyxZQUFZLE1BQU0sSUFBSSxZQUFZLEtBQUssR0FBRyxJQUFJO0FBRW5FLFVBQU0sV0FBV0QsTUFBSyxXQUFXO0FBQ2pDLFFBQUksU0FBUyxXQUFXO0FBRXRCLGFBQU8sS0FDSixNQUFNLFNBQVMsQ0FBQyxDQUFDLEVBQ2pCLE9BQU8sWUFBWSxTQUFTLENBQUMsQ0FBQyxDQUFDO0FBS3BDLFVBQU0sZ0JBQWdCLEtBQUssT0FBTyxRQUFRLE9BQU8sS0FBSyxPQUFPLE9BQU8sRUFBRSxPQUFPLFFBQUU7QUFDN0UsVUFDRSxHQUFHLFlBQ0gsU0FBUyxNQUFNLGFBQVcsR0FBRyxRQUFRLFFBQVEsT0FBTyxLQUFLLENBQUMsR0FBRztBQUMzRCxpQkFBUyxJQUFFLEdBQUcsSUFBRSxTQUFTLFFBQVEsRUFBRSxHQUFHO0FBQ3BDLGNBQUksU0FBUyxRQUFRLEdBQUcsUUFBUSxDQUFDLENBQUMsTUFBTTtBQUFJLG1CQUFPOztBQUVyRCxlQUFPOztBQUVULGFBQU87S0FDUixFQUFFLEtBQUssQ0FBQyxHQUFFLE1BQU0sRUFBRSxRQUFRLFNBQVMsRUFBRSxRQUFRLE1BQU0sRUFBRSxDQUFDO0FBRXpELFFBQUksaUJBQWlCLEtBQUssR0FBRyxZQUFZLFdBQVc7QUFHbEQsWUFBTSx1QkFBd0IsY0FBYyxRQUFxQixNQUFNLEdBQUcsU0FBUyxNQUFNO0FBQ3pGLGFBQU8sS0FDSixNQUFNLG9CQUFvQixFQUMxQixPQUFPLHFCQUFxQixJQUFJLFFBQU0sWUFBWSxFQUFFLENBQUMsQ0FBQzs7QUFHM0QsUUFBSSxDQUFDLGlCQUFpQjtBQUFPLGNBQVEsS0FDbkMsYUFBYSxLQUFLLFVBQVUsV0FBVyxRQUFRLEtBQUssMkNBQ2pDLFNBQVMsS0FBSyxHQUFHLElBQUk7QUFJMUMsVUFBTSxFQUFFLFVBQVMsSUFBSyxLQUFLO0FBQzNCLFVBQU0sTUFBTSxLQUFLLEdBQUcsTUFBTTtBQUUxQixhQUFTLE9BQVEsR0FBRyxHQUFDO0FBQ25CLFVBQUk7QUFDRixlQUFPLElBQUksSUFBSSxHQUFFLENBQUMsTUFBTTtlQUNqQixHQUFQO0FBQ0EsZUFBTzs7O0FBSVgsVUFBTSxDQUFDLEtBQUssY0FBYyxJQUFJLFNBQVMsT0FBTyxDQUFDLENBQUMsV0FBVyxZQUFZLEdBQUcsWUFBTztBQUMvRSxZQUFNLFFBQVEsVUFBVSxPQUFPO0FBQy9CLFlBQU0sUUFBUSxZQUFZLE9BQU87QUFDakMsYUFBTztRQUNMLGFBQWE7UUFDYixhQUFhLENBQUMsUUFDWixRQUNFLGNBQ0EsU0FBUyxNQUFNLFFBQ2IsT0FBQztBQUNDLGdCQUFNLE9BQU8sYUFBYSxHQUFHLE9BQU87QUFDcEMsaUJBQU9DLFNBQVEsSUFBSSxLQUFLLEtBQUssS0FBSyxVQUFRLE9BQU8sT0FBTyxJQUFJLENBQUM7WUFDM0QsT0FBSyxPQUFPLE9BQU8sYUFBYSxHQUFHLE9BQU8sQ0FBQyxDQUFDLElBQ2xEOztPQUVMLENBQUMsTUFBTSxJQUFJLENBQUM7QUFFZixXQUFPLE1BQ0wsS0FBSyxNQUFNLElBQUksSUFBSSxFQUFFLE9BQU8sWUFBWSxJQUFJLE9BQU8sQ0FBQyxFQUNqRCxPQUFPLGNBQWMsSUFDeEIsZ0JBQ0UsS0FBSyxPQUFPLGNBQWMsSUFDMUIsS0FBSyxNQUFNLFFBQVEsRUFBRSxPQUFPLEVBQUU7O0VBUXBDLE9BQU8sZ0JBQXFDO0FBQzFDLFdBQU8sS0FBSyxhQUFZLEVBQUcsSUFBSSxjQUFjOztFQVEvQyxNQUFNLGNBQWtCO0FBQ3RCLFdBQU8sS0FBSyxhQUFZLEVBQUcsTUFBTSxZQUFZOztFQVEvQyxPQUFPLFFBQWM7QUFDbkIsV0FBTyxLQUFLLGFBQVksRUFBRyxPQUFPLE1BQU07O0VBUTFDLE1BQU0sU0FBZTtBQUNuQixXQUFPLEtBQUssYUFBWSxFQUFHLE1BQU0sT0FBTzs7RUFRMUMsS0FBSyxVQUFzRjtBQUN6RixXQUFPLEtBQUssYUFBWSxFQUFHLEtBQUssUUFBUTs7RUFRMUMsUUFBUSxjQUFrQjtBQUN4QixXQUFPLEtBQUssYUFBWSxFQUFHLFFBQVEsWUFBWTs7RUFRakQsZUFBWTtBQUNWLFdBQU8sSUFBSSxLQUFLLEdBQUcsV0FBVyxJQUFJLEtBQUssR0FBRyxZQUFZLElBQUksQ0FBQzs7RUFRN0QsUUFBUSxPQUF3QjtBQUM5QixXQUFPLElBQUksS0FBSyxHQUFHLFdBQ2pCLElBQUksS0FBSyxHQUFHLFlBQVksTUFBTUEsU0FBUSxLQUFLLElBQ3pDLElBQUksTUFBTSxLQUFLLEdBQUcsT0FDbEIsS0FBSyxDQUFDOztFQVFaLFVBQU87QUFDTCxXQUFPLEtBQUssYUFBWSxFQUFHLFFBQU87O0VBUXBDLFdBQVcsYUFBcUI7QUFDOUIsU0FBSyxPQUFPLGNBQWM7QUFHMUIsVUFBTSxXQUFXLFNBQUc7QUFDbEIsVUFBSSxDQUFDO0FBQUssZUFBTztBQUVqQixZQUFNLE1BQU0sT0FBTyxPQUFPLFlBQVksU0FBUztBQUUvQyxlQUFTLEtBQUs7QUFBSyxZQUFJLE9BQU8sS0FBSyxDQUFDO0FBQUcsY0FBSTtBQUFFLGdCQUFJLENBQUMsSUFBSSxJQUFJLENBQUM7bUJBQVksR0FBUDtVQUFVO0FBQzFFLGFBQU87O0FBR1QsUUFBSSxLQUFLLE9BQU8sVUFBVTtBQUN4QixXQUFLLEtBQUssUUFBUSxZQUFZLEtBQUssT0FBTyxRQUFROztBQUVwRCxTQUFLLE9BQU8sV0FBVztBQUN2QixTQUFLLEtBQUssV0FBVyxRQUFRO0FBQzdCLFdBQU87O0VBSVQsY0FBVztBQUNULGFBQVMsTUFBTyxTQUFPO0FBQ3JCLGFBQU8sTUFBTSxPQUFPOztBQUV0QixXQUFPLEtBQUssV0FBVyxLQUFLOztFQVE5QixJQUFJLEtBQUssS0FBbUI7QUFDMUIsVUFBTSxFQUFDLE1BQU0sUUFBTyxJQUFJLEtBQUssT0FBTztBQUNwQyxRQUFJLFdBQVc7QUFDZixRQUFJLFdBQVcsTUFBTTtBQUNuQixpQkFBVyw4QkFBOEIsT0FBTyxFQUFFLEdBQUc7O0FBRXZELFdBQU8sS0FBSyxPQUFPLGFBQWEsV0FBSztBQUNuQyxhQUFPLEtBQUssS0FBSyxPQUFPLEVBQUMsT0FBTyxNQUFNLE9BQU8sTUFBTSxPQUFPLE9BQU8sQ0FBQyxHQUFHLElBQUksTUFBTSxRQUFRLENBQUMsUUFBUSxFQUFDLENBQUM7S0FDbkcsRUFBRSxLQUFLLFNBQU8sSUFBSSxjQUFjVyxhQUFRLE9BQU8sSUFBSSxTQUFTLENBQUMsQ0FBQyxJQUFJLElBQUksVUFBVSxFQUNoRixLQUFLLGdCQUFVO0FBQ2QsVUFBSSxTQUFTO0FBSVgsWUFBRztBQUFDLHVCQUFhLEtBQUssU0FBUyxVQUFVO2lCQUFTLEdBQU47UUFBUTs7QUFFdEQsYUFBTztLQUNSOztFQVFILE9BQU8sYUFBYSxlQUFxSDtBQUN2SSxRQUFJLE9BQU8sZ0JBQWdCLFlBQVksQ0FBQ1gsU0FBUSxXQUFXLEdBQUc7QUFDNUQsWUFBTSxNQUFNLGFBQWEsYUFBYSxLQUFLLE9BQU8sUUFBUSxPQUFPO0FBQ2pFLFVBQUksUUFBUTtBQUFXLGVBQU8sVUFBVSxJQUFJLFdBQVcsZ0JBQ3JELCtDQUErQyxDQUFDO0FBS2xELFVBQUk7QUFDRixZQUFJLE9BQU8sa0JBQWtCLFlBQVk7QUFDdkMsVUFBQUQsTUFBSyxhQUFhLEVBQUUsUUFBUSxhQUFPO0FBQ2pDLHlCQUFhLGFBQWEsU0FBUyxjQUFjLE9BQU8sQ0FBQztXQUMxRDtlQUNJO0FBR0wsd0JBQWMsYUFBYSxFQUFDLE9BQU8sYUFBYSxTQUFTLElBQUcsQ0FBQzs7ZUFFL0QsSUFBQTs7QUFJRixhQUFPLEtBQUssTUFBTSxLQUFLLEVBQUUsT0FBTyxHQUFHLEVBQUUsT0FBTyxhQUFhO1dBQ3BEO0FBRUwsYUFBTyxLQUFLLE1BQU0sS0FBSyxFQUFFLE9BQU8sV0FBVyxFQUFFLE9BQU8sYUFBYTs7O0VBU3JFLElBQUksS0FBSyxLQUFtQjtBQUMxQixVQUFNLEVBQUMsTUFBTSxRQUFPLElBQUksS0FBSyxPQUFPO0FBQ3BDLFFBQUksV0FBVztBQUNmLFFBQUksV0FBVyxNQUFNO0FBQ25CLGlCQUFXLDhCQUE4QixPQUFPLEVBQUUsR0FBRzs7QUFFdkQsV0FBTyxLQUFLLE9BQ1YsYUFDQSxXQUFTLEtBQUssS0FBSyxPQUFPLEVBQUMsT0FBTyxNQUFNLE9BQU8sUUFBUSxDQUFDLFFBQVEsR0FBRyxNQUFNLE9BQU8sT0FBTyxDQUFDLEdBQUcsSUFBSSxLQUFJLENBQUMsQ0FBQyxFQUN0RyxLQUFLLFNBQU8sSUFBSSxjQUFjWSxhQUFRLE9BQU8sSUFBSSxTQUFTLENBQUMsQ0FBQyxJQUFJLElBQUksVUFBVSxFQUM5RSxLQUFLLGdCQUFVO0FBQ2QsVUFBSSxTQUFTO0FBSVgsWUFBRztBQUFDLHVCQUFhLEtBQUssU0FBUyxVQUFVO2lCQUFTLEdBQU47UUFBUTs7QUFFdEQsYUFBTztLQUNSOztFQVFILE9BQU8sS0FBa0I7QUFDdkIsV0FBTyxLQUFLLE9BQU8sYUFDakIsV0FBUyxLQUFLLEtBQUssT0FBTyxFQUFDLE9BQU8sTUFBTSxVQUFVLE1BQU0sQ0FBQyxHQUFHLEVBQUMsQ0FBQyxDQUFDLEVBQ2hFLEtBQUssU0FBTyxJQUFJLGNBQWNBLGFBQVEsT0FBTyxJQUFJLFNBQVMsQ0FBQyxDQUFDLElBQUksTUFBUzs7RUFRNUUsUUFBSztBQUNILFdBQU8sS0FBSyxPQUFPLGFBQ2pCLFdBQVMsS0FBSyxLQUFLLE9BQU8sRUFBQyxPQUFPLE1BQU0sZUFBZSxPQUFPLFNBQVEsQ0FBQyxDQUFDLEVBQ3JFLEtBQUssU0FBTyxJQUFJLGNBQWNBLGFBQVEsT0FBTyxJQUFJLFNBQVMsQ0FBQyxDQUFDLElBQUksTUFBUzs7RUFTaEYsUUFBUVosT0FBcUI7QUFDM0IsV0FBTyxLQUFLLE9BQU8sWUFBWSxXQUFLO0FBQ2xDLGFBQU8sS0FBSyxLQUFLLFFBQVE7UUFDdkIsTUFBQUE7UUFDQTtPQUNELEVBQUUsS0FBSyxZQUFVLE9BQU8sSUFBSSxTQUFPLEtBQUssS0FBSyxRQUFRLEtBQUssR0FBRyxDQUFDLENBQUM7S0FDakU7O0VBUUgsUUFDRSxTQUNBLGVBQ0EsU0FBK0I7QUFFL0IsVUFBTUEsUUFBTyxNQUFNLFFBQVEsYUFBYSxJQUFJLGdCQUFnQjtBQUM1RCxjQUFVLFlBQVlBLFFBQU8sU0FBWTtBQUN6QyxVQUFNLGNBQWMsVUFBVSxRQUFRLFVBQVU7QUFFaEQsV0FBTyxLQUFLLE9BQU8sYUFBYSxXQUFLO0FBQ25DLFlBQU0sRUFBQyxNQUFNLFFBQU8sSUFBSSxLQUFLLE9BQU87QUFDcEMsVUFBSSxXQUFXQTtBQUNiLGNBQU0sSUFBSSxXQUFXLGdCQUFnQiw4REFBOEQ7QUFDckcsVUFBSUEsU0FBUUEsTUFBSyxXQUFXLFFBQVE7QUFDbEMsY0FBTSxJQUFJLFdBQVcsZ0JBQWdCLHNEQUFzRDtBQUU3RixZQUFNLGFBQWEsUUFBUTtBQUMzQixVQUFJLGVBQWUsV0FBVyxPQUM1QixRQUFRLElBQUksOEJBQThCLE9BQU8sQ0FBQyxJQUNsRDtBQUNGLGFBQU8sS0FBSyxLQUFLLE9BQ2YsRUFBQyxPQUFPLE1BQU0sT0FBTyxNQUFNQSxPQUF5QixRQUFRLGNBQWMsWUFBVyxDQUFDLEVBRXJGLEtBQUssQ0FBQyxFQUFDLGFBQWEsU0FBUSxZQUFZLFNBQVEsTUFBQztBQUNoRCxjQUFNLFNBQVMsY0FBYyxVQUFVO0FBQ3ZDLFlBQUksZ0JBQWdCO0FBQUcsaUJBQU87QUFDOUIsY0FBTSxJQUFJLFVBQ1IsR0FBRyxLQUFLLG1CQUFtQixrQkFBa0IsZ0NBQWdDLFFBQVE7T0FDeEY7S0FDSjs7RUFRSCxRQUNFLFNBQ0EsZUFDQSxTQUErQjtBQUUvQixVQUFNQSxRQUFPLE1BQU0sUUFBUSxhQUFhLElBQUksZ0JBQWdCO0FBQzVELGNBQVUsWUFBWUEsUUFBTyxTQUFZO0FBQ3pDLFVBQU0sY0FBYyxVQUFVLFFBQVEsVUFBVTtBQUVoRCxXQUFPLEtBQUssT0FBTyxhQUFhLFdBQUs7QUFDbkMsWUFBTSxFQUFDLE1BQU0sUUFBTyxJQUFJLEtBQUssT0FBTztBQUNwQyxVQUFJLFdBQVdBO0FBQ2IsY0FBTSxJQUFJLFdBQVcsZ0JBQWdCLDhEQUE4RDtBQUNyRyxVQUFJQSxTQUFRQSxNQUFLLFdBQVcsUUFBUTtBQUNsQyxjQUFNLElBQUksV0FBVyxnQkFBZ0Isc0RBQXNEO0FBRTdGLFlBQU0sYUFBYSxRQUFRO0FBQzNCLFVBQUksZUFBZSxXQUFXLE9BQzVCLFFBQVEsSUFBSSw4QkFBOEIsT0FBTyxDQUFDLElBQ2xEO0FBRUYsYUFBTyxLQUFLLEtBQUssT0FDZixFQUFDLE9BQU8sTUFBTSxPQUFPLE1BQU1BLE9BQXlCLFFBQVEsY0FBYyxZQUFXLENBQUMsRUFFckYsS0FBSyxDQUFDLEVBQUMsYUFBYSxTQUFTLFlBQVksU0FBUSxNQUFDO0FBQ2pELGNBQU0sU0FBUyxjQUFjLFVBQVU7QUFDdkMsWUFBSSxnQkFBZ0I7QUFBRyxpQkFBTztBQUM5QixjQUFNLElBQUksVUFDUixHQUFHLEtBQUssbUJBQW1CLGtCQUFrQixnQ0FBZ0MsUUFBUTtPQUN4RjtLQUNKOztFQVFILFdBQVdBLE9BQWtDO0FBQzNDLFVBQU0sVUFBVUEsTUFBSztBQUNyQixXQUFPLEtBQUssT0FBTyxhQUFhLFdBQUs7QUFDbkMsYUFBTyxLQUFLLEtBQUssT0FBTyxFQUFDLE9BQU8sTUFBTSxVQUFVLE1BQU1BLE1BQXVCLENBQUM7S0FDL0UsRUFBRSxLQUFLLENBQUMsRUFBQyxhQUFhLFlBQVksU0FBUSxNQUFDO0FBQzFDLFVBQUksZ0JBQWdCO0FBQUcsZUFBTztBQUM5QixZQUFNLElBQUksVUFDUixHQUFHLEtBQUssc0JBQXNCLGtCQUFrQiw2QkFBNkIsUUFBUTtLQUN4Rjs7O1NDN2VtQixPQUFPLEtBQUc7QUFDOUIsTUFBSSxNQUFNLENBQUE7QUFDVixNQUFJLEtBQUssU0FBVSxXQUFXLFlBQVU7QUFDcEMsUUFBSSxZQUFZO0FBRVosVUFBSWEsS0FBSSxVQUFVLFFBQVFYLFFBQU8sSUFBSSxNQUFNVyxLQUFJLENBQUM7QUFDaEQsYUFBTyxFQUFFQTtBQUFHLFFBQUFYLE1BQUtXLEtBQUksQ0FBQyxJQUFJLFVBQVVBLEVBQUM7QUFDckMsVUFBSSxTQUFTLEVBQUUsVUFBVSxNQUFNLE1BQU1YLEtBQUk7QUFDekMsYUFBTztlQUNBLE9BQVEsY0FBZSxVQUFVO0FBRXhDLGFBQU8sSUFBSSxTQUFTOzs7QUFHNUIsS0FBRyxlQUFlWTtBQUVsQixXQUFTLElBQUksR0FBRyxJQUFJLFVBQVUsUUFBUSxJQUFJLEdBQUcsRUFBRSxHQUFHO0FBQzlDLElBQUFBLEtBQUksVUFBVSxDQUFDLENBQUM7O0FBR3BCLFNBQU87QUFFUCxXQUFTQSxLQUFJLFdBQVcsZUFBZSxpQkFBZTtBQUNsRCxRQUFJLE9BQU8sY0FBYztBQUFVLGFBQU8sb0JBQW9CLFNBQVM7QUFDdkUsUUFBSSxDQUFDO0FBQWUsc0JBQWdCO0FBQ3BDLFFBQUksQ0FBQztBQUFpQix3QkFBa0JSO0FBRXhDLFFBQUksVUFBVTtNQUNWLGFBQWEsQ0FBQTtNQUNiLE1BQU07TUFDTixXQUFXLFNBQVUsSUFBRTtBQUNuQixZQUFJLFFBQVEsWUFBWSxRQUFRLEVBQUUsTUFBTSxJQUFJO0FBQ3hDLGtCQUFRLFlBQVksS0FBSyxFQUFFO0FBQzNCLGtCQUFRLE9BQU8sY0FBYyxRQUFRLE1BQU0sRUFBRTs7O01BR3JELGFBQWEsU0FBVSxJQUFFO0FBQ3JCLGdCQUFRLGNBQWMsUUFBUSxZQUFZLE9BQU8sU0FBVSxJQUFFO0FBQUksaUJBQU8sT0FBTztRQUFHLENBQUU7QUFDcEYsZ0JBQVEsT0FBTyxRQUFRLFlBQVksT0FBTyxlQUFlLGVBQWU7OztBQUdoRixRQUFJLFNBQVMsSUFBSSxHQUFHLFNBQVMsSUFBSTtBQUNqQyxXQUFPOztBQUdYLFdBQVMsb0JBQW9CLEtBQUc7QUFFNUIsSUFBQU4sTUFBSyxHQUFHLEVBQUUsUUFBUSxTQUFVLFdBQVM7QUFDakMsVUFBSUUsUUFBTyxJQUFJLFNBQVM7QUFDeEIsVUFBSUQsU0FBUUMsS0FBSSxHQUFHO0FBQ2YsUUFBQVksS0FBSSxXQUFXLElBQUksU0FBUyxFQUFFLENBQUMsR0FBRyxJQUFJLFNBQVMsRUFBRSxDQUFDLENBQUM7aUJBQzVDWixVQUFTLFFBQVE7QUFHeEIsWUFBSSxVQUFVWSxLQUFJLFdBQVcsUUFBUSxTQUFTLE9BQUk7QUFFOUMsY0FBSUQsS0FBSSxVQUFVLFFBQVFYLFFBQU8sSUFBSSxNQUFNVyxFQUFDO0FBQzVDLGlCQUFPQTtBQUFLLFlBQUFYLE1BQUtXLEVBQUMsSUFBSSxVQUFVQSxFQUFDO0FBRWpDLGtCQUFRLFlBQVksUUFBUSxTQUFVLElBQUU7QUFDcENWLG1CQUFLLFNBQVMsWUFBUztBQUNuQixpQkFBRyxNQUFNLE1BQU1ELEtBQUk7YUFDdEI7V0FDSjtTQUNKOztBQUNFLGNBQU0sSUFBSSxXQUFXLGdCQUFnQixzQkFBc0I7S0FDckU7O0FBRVQ7U0NyRWdCLHFCQUFvQyxXQUFtQixhQUFxQjtBQWlCMUYsU0FBTyxXQUFXLEVBQUUsS0FBSyxFQUFDLFVBQVMsQ0FBQztBQUNwQyxTQUFPO0FBQ1Q7U0NGZ0IsdUJBQXdCLElBQVM7QUFDL0MsU0FBTyxxQkFDTCxNQUFNLFdBRU4sU0FBU2EsT0FBb0IsTUFBYyxhQUEwQixPQUFtQjtBQUN0RixTQUFLLEtBQUs7QUFDVixTQUFLLE1BQU07QUFDWCxTQUFLLE9BQU87QUFDWixTQUFLLFNBQVM7QUFDZCxTQUFLLE9BQU8sR0FBRyxXQUFXLElBQUksSUFBSSxHQUFHLFdBQVcsSUFBSSxFQUFFLE9BQU8sT0FBTyxNQUFNO01BQ3hFLFlBQVksQ0FBQyxtQkFBbUJULElBQUc7TUFDbkMsV0FBVyxDQUFDLG1CQUFtQixNQUFNO01BQ3JDLFlBQVksQ0FBQyxtQkFBbUJBLElBQUc7TUFDbkMsWUFBWSxDQUFDLG1CQUFtQkEsSUFBRztLQUNwQztHQUNGO0FBR0w7U0M1QmdCLGdCQUFpQixLQUF3QixtQkFBMkI7QUFDbEYsU0FBTyxFQUFFLElBQUksVUFBVSxJQUFJLGFBQWEsSUFBSSxRQUN2QyxvQkFBb0IsSUFBSSxZQUFZLENBQUMsSUFBSTtBQUNoRDtTQUVnQixVQUFVLEtBQXdCLElBQVk7QUFDNUQsTUFBSSxTQUFTLFFBQVEsSUFBSSxRQUFRLEVBQUU7QUFDckM7U0FFZ0IsZ0JBQWlCLEtBQXdCLFNBQVMsZUFBYztBQUM5RSxNQUFJLE9BQU8sSUFBSTtBQUNmLE1BQUksZUFBZSxPQUFPLE1BQUksUUFBUSxLQUFJLEdBQUksUUFBTyxDQUFFLElBQUk7QUFDM0QsTUFBSSxZQUFZLGlCQUFpQixDQUFDO0FBQ3BDO1NBRWdCLGVBQWUsS0FBd0IsSUFBRTtBQUN2RCxNQUFJLFVBQVUsUUFBUSxJQUFJLFNBQVMsRUFBRTtBQUN2QztTQUVnQixnQkFBZ0IsS0FBd0IsWUFBNkI7QUFHbkYsTUFBSSxJQUFJO0FBQVcsV0FBTyxXQUFXO0FBQ3JDLFFBQU0sUUFBUSxXQUFXLGtCQUFrQixJQUFJLEtBQUs7QUFDcEQsTUFBSSxDQUFDO0FBQU8sVUFBTSxJQUFJLFdBQVcsT0FBTyxhQUFhLElBQUksUUFBUSxzQkFBc0IsV0FBVyxPQUFPLGlCQUFpQjtBQUMxSCxTQUFPO0FBQ1Q7U0FFZ0IsV0FBVyxLQUF3QixXQUF3QixPQUF3QjtBQUNqRyxRQUFNLFFBQVEsZ0JBQWdCLEtBQUssVUFBVSxNQUFNO0FBQ25ELFNBQU8sVUFBVSxXQUFXO0lBQzFCO0lBQ0EsUUFBUSxDQUFDLElBQUk7SUFDYixTQUFTLElBQUksUUFBUTtJQUNyQixRQUFRLENBQUMsQ0FBQyxJQUFJO0lBQ2QsT0FBTztNQUNMO01BQ0EsT0FBTyxJQUFJOztHQUVkO0FBQ0g7U0FFZ0IsS0FDZCxLQUNBLElBQ0EsV0FDQSxXQUFzQjtBQUV0QixRQUFNLFNBQVMsSUFBSSxlQUFlLFFBQVEsSUFBSSxRQUFRLElBQUksYUFBWSxDQUFFLElBQUksSUFBSTtBQUNoRixNQUFJLENBQUMsSUFBSSxJQUFJO0FBQ1QsV0FBTyxRQUNMLFdBQVcsS0FBSyxXQUFXLFNBQVMsR0FDcEMsUUFBUSxJQUFJLFdBQVcsTUFBTSxHQUFHLElBQUksQ0FBQyxJQUFJLFlBQVksSUFBSSxXQUFXO1NBQ25FO0FBQ0gsVUFBTSxNQUFNLENBQUE7QUFFWixVQUFNLFFBQVEsQ0FBQyxNQUFXLFFBQXNCLFlBQU87QUFDbkQsVUFBSSxDQUFDLFVBQVUsT0FBTyxRQUFRLFNBQVMsWUFBUSxPQUFPLEtBQUssTUFBTSxHQUFHLFNBQU8sT0FBTyxLQUFLLEdBQUcsQ0FBQyxHQUFHO0FBQzFGLFlBQUksYUFBYSxPQUFPO0FBQ3hCLFlBQUksTUFBTSxLQUFLO0FBQ2YsWUFBSSxRQUFRO0FBQXdCLGdCQUFNLEtBQUssSUFBSSxXQUFXLFVBQVU7QUFDeEUsWUFBSSxDQUFDLE9BQU8sS0FBSyxHQUFHLEdBQUc7QUFDbkIsY0FBSSxHQUFHLElBQUk7QUFDWCxhQUFHLE1BQU0sUUFBUSxPQUFPOzs7O0FBS3BDLFdBQU8sUUFBUSxJQUFJO01BQ2pCLElBQUksR0FBRyxTQUFTLE9BQU8sU0FBUztNQUNoQyxRQUFRLFdBQVcsS0FBSyxXQUFXLFNBQVMsR0FBRyxJQUFJLFdBQVcsT0FBTyxDQUFDLElBQUksWUFBWSxJQUFJLFdBQVc7S0FDdEc7O0FBRVA7QUFFQSxTQUFTLFFBQVEsZUFBc0MsUUFBUSxJQUFJLGFBQVc7QUFHNUUsTUFBSSxXQUFXLGNBQWMsQ0FBQyxHQUFFLEdBQUUsTUFBTSxHQUFHLFlBQVksQ0FBQyxHQUFFLEdBQUUsQ0FBQyxJQUFJO0FBRWpFLE1BQUksWUFBWSxLQUFLLFFBQVE7QUFFN0IsU0FBTyxjQUFjLEtBQUssWUFBTTtBQUM5QixRQUFJLFFBQVE7QUFDVixhQUFPLE9BQU8sTUFBTSxNQUFBO0FBQ2xCLFlBQUksSUFBSSxNQUFJLE9BQU8sU0FBUTtBQUMzQixZQUFJLENBQUMsVUFBVSxPQUFPLFFBQVEsY0FBWSxJQUFJLFVBQVUsU0FBRztBQUFHLGlCQUFPLEtBQUssR0FBRztBQUFFLGNBQUVBO1FBQUcsR0FBRyxPQUFDO0FBQUssaUJBQU8sS0FBSyxDQUFDO0FBQUUsY0FBSUE7UUFBSSxDQUFDO0FBQ25ILG9CQUFVLE9BQU8sT0FBTyxRQUFRLGNBQVksSUFBSSxRQUFRO0FBQzFELFVBQUM7T0FDRjs7R0FFSjtBQUNIO1NDakdnQixJQUFJLEdBQVEsR0FBTTtBQUNoQyxNQUFJO0FBQ0YsVUFBTSxLQUFLLEtBQUssQ0FBQztBQUNqQixVQUFNLEtBQUssS0FBSyxDQUFDO0FBQ2pCLFFBQUksT0FBTyxJQUFJO0FBQ2IsVUFBSSxPQUFPO0FBQVMsZUFBTztBQUMzQixVQUFJLE9BQU87QUFBUyxlQUFPO0FBQzNCLFVBQUksT0FBTztBQUFVLGVBQU87QUFDNUIsVUFBSSxPQUFPO0FBQVUsZUFBTztBQUM1QixVQUFJLE9BQU87QUFBVSxlQUFPO0FBQzVCLFVBQUksT0FBTztBQUFVLGVBQU87QUFDNUIsVUFBSSxPQUFPO0FBQVEsZUFBTztBQUMxQixVQUFJLE9BQU87QUFBUSxlQUFPO0FBQzFCLGFBQU87O0FBRVQsWUFBUSxJQUFFO01BQ1IsS0FBSztNQUNMLEtBQUs7TUFDTCxLQUFLO0FBQ0gsZUFBTyxJQUFJLElBQUksSUFBSSxJQUFJLElBQUksS0FBSztNQUNsQyxLQUFLLFVBQVU7QUFDYixlQUFPLG1CQUFtQixjQUFjLENBQUMsR0FBRyxjQUFjLENBQUMsQ0FBQzs7TUFFOUQsS0FBSztBQUNILGVBQU8sY0FBYyxHQUFHLENBQUM7O1dBRTdCLElBQUE7RUFBTTtBQUNSLFNBQU87QUFDVDtTQUVnQixjQUFjLEdBQVUsR0FBUTtBQUM5QyxRQUFNLEtBQUssRUFBRTtBQUNiLFFBQU0sS0FBSyxFQUFFO0FBQ2IsUUFBTSxJQUFJLEtBQUssS0FBSyxLQUFLO0FBQ3pCLFdBQVMsSUFBSSxHQUFHLElBQUksR0FBRyxFQUFFLEdBQUc7QUFDMUIsVUFBTSxNQUFNLElBQUksRUFBRSxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUM7QUFDMUIsUUFBSSxRQUFRO0FBQUcsYUFBTzs7QUFFeEIsU0FBTyxPQUFPLEtBQUssSUFBSSxLQUFLLEtBQUssS0FBSztBQUN4QztTQUVnQixtQkFDZCxHQUNBLEdBQWE7QUFFYixRQUFNLEtBQUssRUFBRTtBQUNiLFFBQU0sS0FBSyxFQUFFO0FBQ2IsUUFBTSxJQUFJLEtBQUssS0FBSyxLQUFLO0FBQ3pCLFdBQVMsSUFBSSxHQUFHLElBQUksR0FBRyxFQUFFLEdBQUc7QUFDMUIsUUFBSSxFQUFFLENBQUMsTUFBTSxFQUFFLENBQUM7QUFBRyxhQUFPLEVBQUUsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxJQUFJLEtBQUs7O0FBRS9DLFNBQU8sT0FBTyxLQUFLLElBQUksS0FBSyxLQUFLLEtBQUs7QUFDeEM7QUFHQSxTQUFTLEtBQUssR0FBTTtBQUNsQixRQUFNLElBQUksT0FBTztBQUNqQixNQUFJLE1BQU07QUFBVSxXQUFPO0FBQzNCLE1BQUksWUFBWSxPQUFPLENBQUM7QUFBRyxXQUFPO0FBQ2xDLFFBQU0sUUFBUSxZQUFZLENBQUM7QUFDM0IsU0FBTyxVQUFVLGdCQUFnQixXQUFZO0FBQy9DO0FBZ0JBLFNBQVMsY0FBYyxHQUFhO0FBQ2xDLE1BQUksYUFBYTtBQUFZLFdBQU87QUFDcEMsTUFBSSxZQUFZLE9BQU8sQ0FBQztBQUV0QixXQUFPLElBQUksV0FBVyxFQUFFLFFBQVEsRUFBRSxZQUFZLEVBQUUsVUFBVTtBQUM1RCxTQUFPLElBQUksV0FBVyxDQUFDO0FBQ3pCO0lDcEVhLG1CQUFVO0VBd0JyQixNQUFTLElBQXdFLElBQUc7QUFDbEYsUUFBSSxNQUFNLEtBQUs7QUFDZixXQUFPLElBQUksUUFDVCxJQUFJLE1BQU0sT0FBTyxNQUFNLFVBQVUsS0FBSyxNQUFNLElBQUksS0FBSyxDQUFDLElBQ3RELElBQUksTUFBTSxPQUFPLFlBQVksRUFBRSxFQUFFLEtBQUssRUFBRTs7RUFHNUMsT0FBVSxJQUFzRTtBQUM5RSxRQUFJLE1BQU0sS0FBSztBQUNmLFdBQU8sSUFBSSxRQUNULElBQUksTUFBTSxPQUFPLE1BQU0sVUFBVSxLQUFLLE1BQU0sSUFBSSxLQUFLLENBQUMsSUFDdEQsSUFBSSxNQUFNLE9BQU8sYUFBYSxJQUFJLFFBQVE7O0VBRzlDLGNBQWMsSUFBRTtBQUNkLFFBQUksTUFBTSxLQUFLO0FBQ2YsUUFBSSxZQUFZLFFBQVEsSUFBSSxXQUFXLEVBQUU7O0VBRzNDLFNBQ0UsSUFDQSxXQUE0QjtBQUU1QixXQUFPLEtBQUssS0FBSyxNQUFNLElBQUksV0FBVyxLQUFLLEtBQUssTUFBTSxJQUFJOztFQVE1RCxNQUFNSSxRQUFNO0FBQ1YsUUFBSSxLQUFLLE9BQU8sT0FBTyxLQUFLLFlBQVksU0FBUyxHQUMvQyxNQUFNLE9BQU8sT0FBTyxLQUFLLElBQUk7QUFDL0IsUUFBSUE7QUFBTyxhQUFPLEtBQUtBLE1BQUs7QUFDNUIsT0FBRyxPQUFPO0FBQ1YsV0FBTzs7RUFRVCxNQUFHO0FBQ0QsU0FBSyxLQUFLLGNBQWM7QUFDeEIsV0FBTzs7RUFRVCxLQUFLLElBQXNDO0FBQ3pDLFFBQUksTUFBTSxLQUFLO0FBRWYsV0FBTyxLQUFLLE1BQU0sV0FBUyxLQUFLLEtBQUssSUFBSSxPQUFPLElBQUksTUFBTSxJQUFJLENBQUM7O0VBUWpFLE1BQU0sSUFBRztBQUNQLFdBQU8sS0FBSyxNQUFNLFdBQUs7QUFDckIsWUFBTSxNQUFNLEtBQUs7QUFDakIsWUFBTSxZQUFZLElBQUksTUFBTTtBQUM1QixVQUFJLGdCQUFnQixLQUFLLElBQUksR0FBRztBQUU5QixlQUFPLFVBQVUsTUFBTTtVQUNyQjtVQUNBLE9BQU87WUFDTCxPQUFPLGdCQUFnQixLQUFLLFVBQVUsTUFBTTtZQUM1QyxPQUFPLElBQUk7O1NBRWQsRUFBRSxLQUFLLENBQUFNLFdBQVMsS0FBSyxJQUFJQSxRQUFPLElBQUksS0FBSyxDQUFDO2FBQ3RDO0FBRUwsWUFBSUEsU0FBUTtBQUNaLGVBQU8sS0FBSyxLQUFLLE1BQUE7QUFBUSxZQUFFQTtBQUFPLGlCQUFPO1FBQU0sR0FBSSxPQUFPLFNBQVMsRUFDbEUsS0FBSyxNQUFJQSxNQUFLOztLQUVsQixFQUFFLEtBQUssRUFBRTs7RUFVWixPQUFPLFNBQWlCLElBQTZCO0FBQ25ELFVBQU0sUUFBUSxRQUFRLE1BQU0sR0FBRyxFQUFFLFFBQU8sR0FDdEMsV0FBVyxNQUFNLENBQUMsR0FDbEIsWUFBWSxNQUFNLFNBQVM7QUFDN0IsYUFBUyxPQUFPLEtBQUssR0FBQztBQUNwQixVQUFJO0FBQUcsZUFBTyxPQUFPLElBQUksTUFBTSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUM7QUFDekMsYUFBTyxJQUFJLFFBQVE7O0FBRXJCLFFBQUksUUFBUSxLQUFLLEtBQUssUUFBUSxTQUFTLElBQUk7QUFFM0MsYUFBUyxPQUFPLEdBQUcsR0FBQztBQUNsQixVQUFJLE9BQU8sT0FBTyxHQUFHLFNBQVMsR0FDNUIsT0FBTyxPQUFPLEdBQUcsU0FBUztBQUM1QixhQUFPLE9BQU8sT0FBTyxDQUFDLFFBQVEsT0FBTyxPQUFPLFFBQVE7O0FBRXRELFdBQU8sS0FBSyxRQUFRLFNBQVUsR0FBQztBQUM3QixhQUFPLEVBQUUsS0FBSyxNQUFNO0tBQ3JCLEVBQUUsS0FBSyxFQUFFOztFQVFaLFFBQVEsSUFBRztBQUNULFdBQU8sS0FBSyxNQUFNLFdBQUs7QUFDckIsVUFBSSxNQUFNLEtBQUs7QUFDZixVQUFJLElBQUksUUFBUSxVQUFVLGdCQUFnQixLQUFLLElBQUksS0FBSyxJQUFJLFFBQVEsR0FBRztBQUdyRSxjQUFNLEVBQUMsWUFBVyxJQUFJO0FBQ3RCLGNBQU0sUUFBUSxnQkFBZ0IsS0FBSyxJQUFJLE1BQU0sS0FBSyxNQUFNO0FBQ3hELGVBQU8sSUFBSSxNQUFNLEtBQUssTUFBTTtVQUMxQjtVQUNBLE9BQU8sSUFBSTtVQUNYLFFBQVE7VUFDUixPQUFPO1lBQ0w7WUFDQSxPQUFPLElBQUk7O1NBRWQsRUFBRSxLQUFLLENBQUMsRUFBQyxPQUFNLE1BQU0sY0FBYyxPQUFPLElBQUksV0FBVyxJQUFJLE1BQU07YUFDL0Q7QUFFTCxjQUFNLElBQUksQ0FBQTtBQUNWLGVBQU8sS0FBSyxLQUFLLFVBQVEsRUFBRSxLQUFLLElBQUksR0FBRyxPQUFPLElBQUksTUFBTSxJQUFJLEVBQUUsS0FBSyxNQUFJLENBQUM7O09BRXpFLEVBQUU7O0VBUVAsT0FBTyxRQUFjO0FBQ25CLFFBQUksTUFBTSxLQUFLO0FBQ2YsUUFBSSxVQUFVO0FBQUcsYUFBTztBQUN4QixRQUFJLFVBQVU7QUFDZCxRQUFJLGdCQUFnQixHQUFHLEdBQUc7QUFDeEIsc0JBQWdCLEtBQUssTUFBQTtBQUNuQixZQUFJLGFBQWE7QUFDakIsZUFBTyxDQUFDLFFBQVEsWUFBTztBQUNyQixjQUFJLGVBQWU7QUFBRyxtQkFBTztBQUM3QixjQUFJLGVBQWUsR0FBRztBQUFFLGNBQUU7QUFBWSxtQkFBTzs7QUFDN0Msa0JBQVEsTUFBQTtBQUNOLG1CQUFPLFFBQVEsVUFBVTtBQUN6Qix5QkFBYTtXQUNkO0FBQ0QsaUJBQU87O09BRVY7V0FDSTtBQUNMLHNCQUFnQixLQUFLLE1BQUE7QUFDbkIsWUFBSSxhQUFhO0FBQ2pCLGVBQU8sTUFBTyxFQUFFLGFBQWE7T0FDOUI7O0FBRUgsV0FBTzs7RUFRVCxNQUFNLFNBQWU7QUFDbkIsU0FBSyxLQUFLLFFBQVEsS0FBSyxJQUFJLEtBQUssS0FBSyxPQUFPLE9BQU87QUFDbkQsb0JBQWdCLEtBQUssTUFBTSxNQUFBO0FBQ3pCLFVBQUksV0FBVztBQUNmLGFBQU8sU0FBVSxRQUFRLFNBQVNULFVBQU87QUFDdkMsWUFBSSxFQUFFLFlBQVk7QUFBRyxrQkFBUUEsUUFBTztBQUNwQyxlQUFPLFlBQVk7O09BRXBCLElBQUk7QUFDUCxXQUFPOztFQVFULE1BQU0sZ0JBQWdDLG1CQUFrQjtBQUN0RCxjQUFVLEtBQUssTUFBTSxTQUFVLFFBQVEsU0FBU0EsVUFBTztBQUNyRCxVQUFJLGVBQWUsT0FBTyxLQUFLLEdBQUc7QUFDaEMsZ0JBQVFBLFFBQU87QUFDZixlQUFPO2FBQ0Y7QUFDTCxlQUFPOztLQUVWO0FBQ0QsV0FBTzs7RUFRVCxNQUFNLElBQUc7QUFDUCxXQUFPLEtBQUssTUFBTSxDQUFDLEVBQUUsUUFBUSxTQUFVLEdBQUM7QUFBSSxhQUFPLEVBQUUsQ0FBQztJQUFFLENBQUUsRUFBRSxLQUFLLEVBQUU7O0VBUXJFLEtBQUssSUFBRztBQUNOLFdBQU8sS0FBSyxRQUFPLEVBQUcsTUFBTSxFQUFFOztFQVFoQyxPQUFPLGdCQUE4QjtBQUVuQyxjQUFVLEtBQUssTUFBTSxTQUFVLFFBQU07QUFDbkMsYUFBTyxlQUFlLE9BQU8sS0FBSztLQUNuQztBQUdELG1CQUFlLEtBQUssTUFBTSxjQUFjO0FBQ3hDLFdBQU87O0VBUVQsSUFBSSxRQUFzQjtBQUN4QixXQUFPLEtBQUssT0FBTyxNQUFNOztFQVEzQixHQUFHLFdBQWlCO0FBQ2xCLFdBQU8sSUFBSSxLQUFLLEdBQUcsWUFBWSxLQUFLLEtBQUssT0FBTyxXQUFXLElBQUk7O0VBUWpFLFVBQU87QUFDTCxTQUFLLEtBQUssTUFBTyxLQUFLLEtBQUssUUFBUSxTQUFTLFNBQVM7QUFDckQsUUFBSSxLQUFLO0FBQW9CLFdBQUssbUJBQW1CLEtBQUssS0FBSyxHQUFHO0FBQ2xFLFdBQU87O0VBUVQsT0FBSTtBQUNGLFdBQU8sS0FBSyxRQUFPOztFQVFyQixRQUFRLElBQUc7QUFDVCxRQUFJLE1BQU0sS0FBSztBQUNmLFFBQUksV0FBVyxDQUFDLElBQUk7QUFDcEIsV0FBTyxLQUFLLEtBQUssU0FBVSxLQUFLLFFBQU07QUFBSSxTQUFHLE9BQU8sS0FBSyxNQUFNO0lBQUUsQ0FBRTs7RUFRckUsY0FBYyxJQUFHO0FBQ2YsU0FBSyxLQUFLLFNBQVM7QUFDbkIsV0FBTyxLQUFLLFFBQVEsRUFBRTs7RUFReEIsZUFBZSxJQUFHO0FBQ2hCLFFBQUksTUFBTSxLQUFLO0FBQ2YsUUFBSSxXQUFXLENBQUMsSUFBSTtBQUNwQixXQUFPLEtBQUssS0FBSyxTQUFVLEtBQUssUUFBTTtBQUFJLFNBQUcsT0FBTyxZQUFZLE1BQU07SUFBRSxDQUFFOztFQVE1RSxLQUFLLElBQUc7QUFDTixRQUFJLE1BQU0sS0FBSztBQUNmLFFBQUksV0FBVyxDQUFDLElBQUk7QUFDcEIsUUFBSSxJQUFJLENBQUE7QUFDUixXQUFPLEtBQUssS0FBSyxTQUFVLE1BQU0sUUFBTTtBQUNyQyxRQUFFLEtBQUssT0FBTyxHQUFHO0tBQ2xCLEVBQUUsS0FBSyxXQUFBO0FBQ04sYUFBTztLQUNSLEVBQUUsS0FBSyxFQUFFOztFQVFaLFlBQVksSUFBRztBQUNiLFFBQUksTUFBTSxLQUFLO0FBQ2YsUUFBSSxJQUFJLFFBQVEsVUFBVSxnQkFBZ0IsS0FBSyxJQUFJLEtBQUssSUFBSSxRQUFRLEdBQUc7QUFHckUsYUFBTyxLQUFLLE1BQU0sV0FBSztBQUNyQixZQUFJLFFBQVEsZ0JBQWdCLEtBQUssSUFBSSxNQUFNLEtBQUssTUFBTTtBQUN0RCxlQUFPLElBQUksTUFBTSxLQUFLLE1BQU07VUFDMUI7VUFDQSxRQUFRO1VBQ1IsT0FBTyxJQUFJO1VBQ1gsT0FBTztZQUNMO1lBQ0EsT0FBTyxJQUFJOztTQUNYO09BQ0wsRUFBRSxLQUFLLENBQUMsRUFBQyxPQUFNLE1BQUksTUFBTSxFQUFFLEtBQUssRUFBRTs7QUFFckMsUUFBSSxXQUFXLENBQUMsSUFBSTtBQUNwQixRQUFJLElBQUksQ0FBQTtBQUNSLFdBQU8sS0FBSyxLQUFLLFNBQVUsTUFBTSxRQUFNO0FBQ3JDLFFBQUUsS0FBSyxPQUFPLFVBQVU7S0FDekIsRUFBRSxLQUFLLFdBQUE7QUFDTixhQUFPO0tBQ1IsRUFBRSxLQUFLLEVBQUU7O0VBUVosV0FBVyxJQUFHO0FBQ1osU0FBSyxLQUFLLFNBQVM7QUFDbkIsV0FBTyxLQUFLLEtBQUssRUFBRTs7RUFRckIsU0FBUyxJQUFHO0FBQ1YsV0FBTyxLQUFLLE1BQU0sQ0FBQyxFQUFFLEtBQUssU0FBVSxHQUFDO0FBQUksYUFBTyxFQUFFLENBQUM7SUFBRSxDQUFFLEVBQUUsS0FBSyxFQUFFOztFQVFsRSxRQUFRLElBQUc7QUFDVCxXQUFPLEtBQUssUUFBTyxFQUFHLFNBQVMsRUFBRTs7RUFRbkMsV0FBUTtBQUNOLFFBQUksTUFBTSxLQUFLLE1BQ2IsTUFBTSxJQUFJLFNBQVMsSUFBSSxNQUFNLE9BQU8sVUFBVSxJQUFJLEtBQUs7QUFDekQsUUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJO0FBQU8sYUFBTztBQUMvQixRQUFJLE1BQU0sQ0FBQTtBQUNWLGNBQVUsS0FBSyxNQUFNLFNBQVUsUUFBb0I7QUFDakQsVUFBSSxTQUFTLE9BQU8sV0FBVyxTQUFRO0FBQ3ZDLFVBQUksUUFBUSxPQUFPLEtBQUssTUFBTTtBQUM5QixVQUFJLE1BQU0sSUFBSTtBQUNkLGFBQU8sQ0FBQztLQUNUO0FBQ0QsV0FBTzs7RUFhVCxPQUFPLFNBQStFO0FBQ3BGLFFBQUksTUFBTSxLQUFLO0FBQ2YsV0FBTyxLQUFLLE9BQU8sV0FBSztBQUN0QixVQUFJO0FBQ0osVUFBSSxPQUFPLFlBQVksWUFBWTtBQUVqQyxtQkFBVzthQUNOO0FBRUwsWUFBSSxXQUFXUCxNQUFLLE9BQU87QUFDM0IsWUFBSSxVQUFVLFNBQVM7QUFDdkIsbUJBQVcsU0FBVSxNQUFJO0FBQ3ZCLGNBQUksbUJBQW1CO0FBQ3ZCLG1CQUFTLElBQUksR0FBRyxJQUFJLFNBQVMsRUFBRSxHQUFHO0FBQ2hDLGdCQUFJLFVBQVUsU0FBUyxDQUFDLEdBQUcsTUFBTSxRQUFRLE9BQU87QUFDaEQsZ0JBQUksYUFBYSxNQUFNLE9BQU8sTUFBTSxLQUFLO0FBQ3ZDLDJCQUFhLE1BQU0sU0FBUyxHQUFHO0FBQy9CLGlDQUFtQjs7O0FBR3ZCLGlCQUFPOzs7QUFJWCxZQUFNLFlBQVksSUFBSSxNQUFNO0FBQzVCLFlBQU0sRUFBQyxVQUFVLFdBQVUsSUFBSSxVQUFVLE9BQU87QUFDaEQsWUFBTSxRQUFRLEtBQUssR0FBRyxTQUFTLG1CQUFtQjtBQUNsRCxZQUFNLGdCQUFnQixDQUFBO0FBQ3RCLFVBQUksZUFBZTtBQUNuQixZQUFNLGFBQThCLENBQUE7QUFDcEMsWUFBTSxvQkFBb0IsQ0FBQyxlQUF1QixRQUF5QjtBQUN6RSxjQUFNLEVBQUMsVUFBVSxZQUFXLElBQUk7QUFDaEMsd0JBQWdCLGdCQUFnQjtBQUNoQyxpQkFBUyxPQUFPQSxNQUFLLFFBQVEsR0FBRztBQUM5Qix3QkFBYyxLQUFLLFNBQVMsR0FBRyxDQUFDOzs7QUFHcEMsYUFBTyxLQUFLLE1BQUssRUFBRyxZQUFXLEVBQUcsS0FBSyxDQUFBQSxVQUFJO0FBRXpDLGNBQU0sWUFBWSxDQUFDLFdBQWM7QUFDL0IsZ0JBQU1nQixTQUFRLEtBQUssSUFBSSxPQUFPaEIsTUFBSyxTQUFTLE1BQU07QUFDbEQsaUJBQU8sVUFBVSxRQUFRO1lBQ3ZCO1lBQ0EsTUFBTUEsTUFBSyxNQUFNLFFBQVEsU0FBU2dCLE1BQUs7WUFDdkMsT0FBTztXQUlSLEVBQUUsS0FBSyxZQUFNO0FBQ1osa0JBQU0sWUFBWSxDQUFBO0FBQ2xCLGtCQUFNLFlBQVksQ0FBQTtBQUNsQixrQkFBTSxVQUFVLFdBQVcsQ0FBQSxJQUFLO0FBQ2hDLGtCQUFNLGFBQWEsQ0FBQTtBQUNuQixxQkFBUyxJQUFFLEdBQUcsSUFBRUEsUUFBTyxFQUFFLEdBQUc7QUFDMUIsb0JBQU0sWUFBWSxPQUFPLENBQUM7QUFDMUIsb0JBQU1DLE9BQU07Z0JBQ1YsT0FBTyxVQUFVLFNBQVM7Z0JBQzFCLFNBQVNqQixNQUFLLFNBQU8sQ0FBQzs7QUFFeEIsa0JBQUksU0FBUyxLQUFLaUIsTUFBS0EsS0FBSSxPQUFPQSxJQUFHLE1BQU0sT0FBTztBQUNoRCxvQkFBSUEsS0FBSSxTQUFTLE1BQU07QUFFckIsNkJBQVcsS0FBS2pCLE1BQUssU0FBTyxDQUFDLENBQUM7MkJBQ3JCLENBQUMsWUFBWSxJQUFJLFdBQVcsU0FBUyxHQUFHLFdBQVdpQixLQUFJLEtBQUssQ0FBQyxNQUFNLEdBQUc7QUFFL0UsNkJBQVcsS0FBS2pCLE1BQUssU0FBTyxDQUFDLENBQUM7QUFDOUIsNEJBQVUsS0FBS2lCLEtBQUksS0FBSzt1QkFDbkI7QUFFTCw0QkFBVSxLQUFLQSxLQUFJLEtBQUs7QUFDeEIsc0JBQUk7QUFBVSw0QkFBUSxLQUFLakIsTUFBSyxTQUFPLENBQUMsQ0FBQzs7OztBQUkvQyxrQkFBTSxXQUFXLGdCQUFnQixHQUFHLEtBQ2xDLElBQUksVUFBVSxhQUNiLE9BQU8sWUFBWSxjQUFjLFlBQVksbUJBQW1CO2NBQy9ELE9BQU8sSUFBSTtjQUNYLE9BQU8sSUFBSTs7QUFHZixtQkFBTyxRQUFRLFFBQVEsVUFBVSxTQUFTLEtBQ3hDLFVBQVUsT0FBTyxFQUFDLE9BQU8sTUFBTSxPQUFPLFFBQVEsVUFBUyxDQUFDLEVBQ3JELEtBQUssU0FBRztBQUNQLHVCQUFTLE9BQU8sSUFBSSxVQUFVO0FBRTVCLDJCQUFXLE9BQU8sU0FBUyxHQUFHLEdBQUcsQ0FBQzs7QUFFcEMsZ0NBQWtCLFVBQVUsUUFBUSxHQUFHO2FBQ3hDLENBQUMsRUFDSixLQUFLLE9BQUssVUFBVSxTQUFTLEtBQU0sWUFBWSxPQUFPLFlBQVksYUFDaEUsVUFBVSxPQUFPO2NBQ2Y7Y0FDQSxNQUFNO2NBQ04sTUFBTTtjQUNOLFFBQVE7Y0FDUjtjQUNBLFlBQVksT0FBTyxZQUFZLGNBQzFCO2FBQ04sRUFBRSxLQUFLLFNBQUssa0JBQWtCLFVBQVUsUUFBUSxHQUFHLENBQUMsQ0FBQyxFQUN4RCxLQUFLLE9BQUssV0FBVyxTQUFTLEtBQU0sWUFBWSxZQUFZLG1CQUMxRCxVQUFVLE9BQU87Y0FDZjtjQUNBLE1BQU07Y0FDTixNQUFNO2NBQ047YUFDRCxFQUFFLEtBQUssU0FBSyxrQkFBa0IsV0FBVyxRQUFRLEdBQUcsQ0FBQyxDQUFDLEVBQ3pELEtBQUssTUFBQTtBQUNMLHFCQUFPQSxNQUFLLFNBQVMsU0FBU2dCLFVBQVMsVUFBVSxTQUFTLEtBQUs7YUFDaEU7V0FDRjs7QUFHSCxlQUFPLFVBQVUsQ0FBQyxFQUFFLEtBQUssTUFBQTtBQUN2QixjQUFJLGNBQWMsU0FBUztBQUN6QixrQkFBTSxJQUFJLFlBQVksdUNBQXVDLGVBQWUsY0FBYyxVQUF3QztBQUVwSSxpQkFBT2hCLE1BQUs7U0FDYjtPQUNGO0tBRUY7O0VBUUgsU0FBTTtBQUNKLFFBQUksTUFBTSxLQUFLLE1BQ2IsUUFBUSxJQUFJO0FBR2QsUUFBSSxnQkFBZ0IsR0FBRyxNQUNuQixJQUFJLGFBQWEsQ0FBQyw4QkFBK0IsTUFBTSxTQUFJLElBQy9EO0FBS0UsYUFBTyxLQUFLLE9BQU8sV0FBSztBQUV0QixjQUFNLEVBQUMsV0FBVSxJQUFJLElBQUksTUFBTSxLQUFLO0FBQ3BDLGNBQU0sWUFBWTtBQUNsQixlQUFPLElBQUksTUFBTSxLQUFLLE1BQU0sRUFBQyxPQUFPLE9BQU8sRUFBQyxPQUFPLFlBQVksT0FBTyxVQUFTLEVBQUMsQ0FBQyxFQUFFLEtBQUssQ0FBQWdCLFdBQUs7QUFDM0YsaUJBQU8sSUFBSSxNQUFNLEtBQUssT0FBTyxFQUFDLE9BQU8sTUFBTSxlQUFlLE9BQU8sVUFBUyxDQUFDLEVBQzFFLEtBQUssQ0FBQyxFQUFDLFVBQVUsWUFBWSxTQUFTLFlBQVcsTUFBQztBQUNqRCxnQkFBSTtBQUFhLG9CQUFNLElBQUksWUFBWSxnQ0FDckMsT0FBTyxLQUFLLFFBQVEsRUFBRSxJQUFJLFNBQU8sU0FBUyxHQUFHLENBQUMsR0FDOUNBLFNBQVEsV0FBVztBQUNyQixtQkFBT0EsU0FBUTtXQUNoQjtTQUNGO09BQ0Y7O0FBR0gsV0FBTyxLQUFLLE9BQU8sY0FBYzs7O0FBSXJDLElBQU0saUJBQWlCLENBQUMsT0FBTyxRQUFRLElBQUksUUFBUTtTQzFsQm5DLDRCQUE0QixJQUFTO0FBQ25ELFNBQU8scUJBQ0wsV0FBVyxXQUVYLFNBQVNFLFlBRVAsYUFDQSxtQkFBd0M7QUFFeEMsU0FBSyxLQUFLO0FBQ1YsUUFBSSxXQUFXLFVBQVUsUUFBUTtBQUNqQyxRQUFJO0FBQW1CLFVBQUk7QUFDekIsbUJBQVcsa0JBQWlCO2VBQ3JCLElBQVA7QUFDQSxnQkFBUTs7QUFHVixVQUFNLFdBQVcsWUFBWTtBQUM3QixVQUFNLFFBQVEsU0FBUztBQUN2QixVQUFNLGNBQWMsTUFBTSxLQUFLLFFBQVE7QUFDdkMsU0FBSyxPQUFPO01BQ1Y7TUFDQSxPQUFPLFNBQVM7TUFDaEIsV0FBWSxDQUFDLFNBQVMsU0FBVSxNQUFNLE9BQU8sUUFBUSxXQUFXLFNBQVMsVUFBVSxNQUFNLE9BQU8sUUFBUTtNQUN4RyxPQUFPO01BQ1AsVUFBVTtNQUNWLEtBQUs7TUFDTCxRQUFRO01BQ1IsV0FBVztNQUNYLFFBQVE7TUFDUixjQUFjO01BQ2QsV0FBVztNQUNYLFNBQVM7TUFDVCxRQUFRO01BQ1IsT0FBTztNQUNQO01BQ0EsSUFBSSxTQUFTO01BQ2IsYUFBYSxnQkFBZ0IsU0FBUyxjQUFjOztHQUV2RDtBQUVMO1NDM0RnQixjQUFjLEdBQUcsR0FBQztBQUNoQyxTQUFPLElBQUksSUFBSSxLQUFLLE1BQU0sSUFBSSxJQUFJO0FBQ3BDO1NBRWdCLHFCQUFxQixHQUFHLEdBQUM7QUFDdkMsU0FBTyxJQUFJLElBQUksS0FBSyxNQUFNLElBQUksSUFBSTtBQUNwQztTQ0RnQixLQUFLLHlCQUFtRCxLQUFLLEdBQUU7QUFDN0UsTUFBSSxhQUFhLG1DQUFtQyxjQUNoRCxJQUFJLHdCQUF3QixXQUFZLHVCQUF1QixJQUMvRDtBQUVKLGFBQVcsS0FBSyxRQUFRLElBQUksSUFBSSxFQUFFLEdBQUcsSUFBSSxJQUFJLFVBQVUsR0FBRztBQUMxRCxTQUFPO0FBQ1Q7U0FFZ0IsZ0JBQWdCLGFBQXdCO0FBQ3RELFNBQU8sSUFBSSxZQUFZLFdBQVksYUFBYSxNQUFNLFdBQVcsRUFBRSxDQUFDLEVBQUUsTUFBTSxDQUFDO0FBQy9FO1NBRWdCLGFBQWEsS0FBb0I7QUFDL0MsU0FBTyxRQUFRLFNBQ2IsQ0FBQyxNQUFjLEVBQUUsWUFBVyxJQUM1QixDQUFDLE1BQWMsRUFBRSxZQUFXO0FBQ2hDO1NBRWdCLGFBQWEsS0FBb0I7QUFDL0MsU0FBTyxRQUFRLFNBQ2IsQ0FBQyxNQUFjLEVBQUUsWUFBVyxJQUM1QixDQUFDLE1BQWMsRUFBRSxZQUFXO0FBQ2hDO1NBRWdCLFdBQVcsS0FBSyxVQUFVLGFBQWEsYUFBYUMsTUFBSyxLQUFHO0FBQzFFLE1BQUlDLFVBQVMsS0FBSyxJQUFJLElBQUksUUFBUSxZQUFZLE1BQU07QUFDcEQsTUFBSSxNQUFNO0FBQ1YsV0FBUyxJQUFJLEdBQUcsSUFBSUEsU0FBUSxFQUFFLEdBQUc7QUFDN0IsUUFBSSxhQUFhLFNBQVMsQ0FBQztBQUMzQixRQUFJLGVBQWUsWUFBWSxDQUFDLEdBQUc7QUFDL0IsVUFBSUQsS0FBSSxJQUFJLENBQUMsR0FBRyxZQUFZLENBQUMsQ0FBQyxJQUFJO0FBQUcsZUFBTyxJQUFJLE9BQU8sR0FBRyxDQUFDLElBQUksWUFBWSxDQUFDLElBQUksWUFBWSxPQUFPLElBQUksQ0FBQztBQUN4RyxVQUFJQSxLQUFJLElBQUksQ0FBQyxHQUFHLFlBQVksQ0FBQyxDQUFDLElBQUk7QUFBRyxlQUFPLElBQUksT0FBTyxHQUFHLENBQUMsSUFBSSxZQUFZLENBQUMsSUFBSSxZQUFZLE9BQU8sSUFBSSxDQUFDO0FBQ3hHLFVBQUksT0FBTztBQUFHLGVBQU8sSUFBSSxPQUFPLEdBQUcsR0FBRyxJQUFJLFNBQVMsR0FBRyxJQUFJLFlBQVksT0FBTyxNQUFNLENBQUM7QUFDcEYsYUFBTzs7QUFFWCxRQUFJQSxLQUFJLElBQUksQ0FBQyxHQUFHLFVBQVUsSUFBSTtBQUFHLFlBQU07O0FBRTNDLE1BQUlDLFVBQVMsWUFBWSxVQUFVLFFBQVE7QUFBUSxXQUFPLE1BQU0sWUFBWSxPQUFPLElBQUksTUFBTTtBQUM3RixNQUFJQSxVQUFTLElBQUksVUFBVSxRQUFRO0FBQVEsV0FBTyxJQUFJLE9BQU8sR0FBRyxZQUFZLE1BQU07QUFDbEYsU0FBUSxNQUFNLElBQUksT0FBTyxJQUFJLE9BQU8sR0FBRyxHQUFHLElBQUksWUFBWSxHQUFHLElBQUksWUFBWSxPQUFPLE1BQU0sQ0FBQztBQUM3RjtTQUVnQix1QkFBdUIsYUFBMEIsT0FBTyxTQUFTLFFBQU07QUFFckYsTUFBSSxPQUFPLE9BQU8sU0FBUyxjQUFjLGNBQWMsV0FBVyxlQUM5RCxhQUFhLFFBQVE7QUFDekIsTUFBSSxDQUFDLFFBQVEsTUFBTSxPQUFLLE9BQU8sTUFBTSxRQUFRLEdBQUc7QUFDNUMsV0FBTyxLQUFLLGFBQWEsZUFBZTs7QUFFNUMsV0FBUyxjQUFjLEtBQUc7QUFDdEIsWUFBUSxhQUFhLEdBQUc7QUFDeEIsWUFBUSxhQUFhLEdBQUc7QUFDeEIsY0FBVyxRQUFRLFNBQVMsZ0JBQWdCO0FBQzVDLFFBQUksZUFBZSxRQUFRLElBQUksU0FBVSxRQUFNO0FBQzNDLGFBQU8sRUFBQyxPQUFPLE1BQU0sTUFBTSxHQUFHLE9BQU8sTUFBTSxNQUFNLEVBQUM7S0FDckQsRUFBRSxLQUFLLFNBQVMsR0FBRSxHQUFDO0FBQ2hCLGFBQU8sUUFBUSxFQUFFLE9BQU8sRUFBRSxLQUFLO0tBQ2xDO0FBQ0QsbUJBQWUsYUFBYSxJQUFJLFNBQVUsSUFBRTtBQUFHLGFBQU8sR0FBRztJQUFNLENBQUU7QUFDakUsbUJBQWUsYUFBYSxJQUFJLFNBQVUsSUFBRTtBQUFHLGFBQU8sR0FBRztJQUFNLENBQUU7QUFDakUsZ0JBQVk7QUFDWixvQkFBaUIsUUFBUSxTQUFTLEtBQUs7O0FBRTNDLGdCQUFjLE1BQU07QUFFcEIsTUFBSSxJQUFJLElBQUksWUFBWSxXQUNwQixhQUNBLE1BQUksWUFBWSxhQUFhLENBQUMsR0FBRyxhQUFhLGFBQVcsQ0FBQyxJQUFJLE1BQU0sQ0FBQztBQUd6RSxJQUFFLHFCQUFxQixTQUFVQyxZQUFTO0FBRXRDLGtCQUFjQSxVQUFTOztBQUczQixNQUFJLHNCQUFzQjtBQUUxQixJQUFFLGNBQWMsU0FBVSxRQUFRLFNBQVNkLFVBQU87QUFJOUMsUUFBSSxNQUFNLE9BQU87QUFDakIsUUFBSSxPQUFPLFFBQVE7QUFBVSxhQUFPO0FBQ3BDLFFBQUksV0FBVyxNQUFNLEdBQUc7QUFDeEIsUUFBSSxNQUFNLFVBQVUsY0FBYyxtQkFBbUIsR0FBRztBQUNwRCxhQUFPO1dBQ0o7QUFDSCxVQUFJLHVCQUF1QjtBQUMzQixlQUFTLElBQUUscUJBQXFCLElBQUUsWUFBWSxFQUFFLEdBQUc7QUFDL0MsWUFBSSxTQUFTLFdBQVcsS0FBSyxVQUFVLGFBQWEsQ0FBQyxHQUFHLGFBQWEsQ0FBQyxHQUFHLFNBQVMsU0FBUztBQUMzRixZQUFJLFdBQVcsUUFBUSx5QkFBeUI7QUFDNUMsZ0NBQXNCLElBQUk7aUJBQ3JCLHlCQUF5QixRQUFRLFFBQVEsc0JBQXNCLE1BQU0sSUFBSSxHQUFHO0FBQ2pGLGlDQUF1Qjs7O0FBRy9CLFVBQUkseUJBQXlCLE1BQU07QUFDL0IsZ0JBQVEsV0FBQTtBQUFjLGlCQUFPLFNBQVMsdUJBQXVCLGFBQWE7UUFBRSxDQUFFO2FBQzNFO0FBQ0gsZ0JBQVFBLFFBQU87O0FBRW5CLGFBQU87O0dBRWQ7QUFDRCxTQUFPO0FBQ1Q7U0FFZ0IsWUFBYSxPQUFzQixPQUFzQixXQUFxQixXQUFtQjtBQUM3RyxTQUFPO0lBQ0gsTUFBSTtJQUNKO0lBQ0E7SUFDQTtJQUNBOztBQUVSO1NBRWdCLFdBQVksT0FBb0I7QUFDNUMsU0FBTztJQUNILE1BQUk7SUFDSixPQUFPO0lBQ1AsT0FBTzs7QUFFZjtJQ3BIYSxvQkFBVztFQWN0QixJQUFJLGFBQVU7QUFDWixXQUFPLEtBQUssS0FBSyxNQUFNLEdBQUc7O0VBUTVCLFFBQVEsT0FBc0IsT0FBc0IsY0FBd0IsY0FBc0I7QUFDaEcsbUJBQWUsaUJBQWlCO0FBQ2hDLG1CQUFlLGlCQUFpQjtBQUNoQyxRQUFJO0FBQ0YsVUFBSyxLQUFLLEtBQUssT0FBTyxLQUFLLElBQUksS0FDNUIsS0FBSyxLQUFLLE9BQU8sS0FBSyxNQUFNLE1BQU0sZ0JBQWdCLGlCQUFpQixFQUFFLGdCQUFnQjtBQUN0RixlQUFPLGdCQUFnQixJQUFJO0FBQzdCLGFBQU8sSUFBSSxLQUFLLFdBQVcsTUFBTSxNQUFJLFlBQVksT0FBTyxPQUFPLENBQUMsY0FBYyxDQUFDLFlBQVksQ0FBQzthQUNyRixHQUFQO0FBQ0EsYUFBTyxLQUFLLE1BQU0sb0JBQW9COzs7RUFTMUMsT0FBTyxPQUFvQjtBQUN6QixRQUFJLFNBQVM7QUFBTSxhQUFPLEtBQUssTUFBTSxvQkFBb0I7QUFDekQsV0FBTyxJQUFJLEtBQUssV0FBVyxNQUFNLE1BQU0sV0FBVyxLQUFLLENBQUM7O0VBUTFELE1BQU0sT0FBb0I7QUFDeEIsUUFBSSxTQUFTO0FBQU0sYUFBTyxLQUFLLE1BQU0sb0JBQW9CO0FBQ3pELFdBQU8sSUFBSSxLQUFLLFdBQVcsTUFBTSxNQUFNLFlBQVksT0FBTyxRQUFXLElBQUksQ0FBQzs7RUFRNUUsYUFBYSxPQUFvQjtBQUMvQixRQUFJLFNBQVM7QUFBTSxhQUFPLEtBQUssTUFBTSxvQkFBb0I7QUFDekQsV0FBTyxJQUFJLEtBQUssV0FBVyxNQUFNLE1BQU0sWUFBWSxPQUFPLFFBQVcsS0FBSyxDQUFDOztFQVE3RSxNQUFNLE9BQW9CO0FBQ3hCLFFBQUksU0FBUztBQUFNLGFBQU8sS0FBSyxNQUFNLG9CQUFvQjtBQUN6RCxXQUFPLElBQUksS0FBSyxXQUFXLE1BQU0sTUFBTSxZQUFZLFFBQVcsT0FBTyxPQUFPLElBQUksQ0FBQzs7RUFRbkYsYUFBYSxPQUFvQjtBQUMvQixRQUFJLFNBQVM7QUFBTSxhQUFPLEtBQUssTUFBTSxvQkFBb0I7QUFDekQsV0FBTyxJQUFJLEtBQUssV0FBVyxNQUFNLE1BQU0sWUFBWSxRQUFXLEtBQUssQ0FBQzs7RUFRdEUsV0FBVyxLQUFXO0FBQ3BCLFFBQUksT0FBTyxRQUFRO0FBQVUsYUFBTyxLQUFLLE1BQU0sZUFBZTtBQUM5RCxXQUFPLEtBQUssUUFBUSxLQUFLLE1BQU0sV0FBVyxNQUFNLElBQUk7O0VBUXRELHFCQUFxQixLQUFXO0FBQzlCLFFBQUksUUFBUTtBQUFJLGFBQU8sS0FBSyxXQUFXLEdBQUc7QUFDMUMsV0FBTyx1QkFBdUIsTUFBTSxDQUFDLEdBQUcsTUFBTSxFQUFFLFFBQVEsRUFBRSxDQUFDLENBQUMsTUFBTSxHQUFHLENBQUMsR0FBRyxHQUFHLFNBQVM7O0VBUXZGLGlCQUFpQixLQUFXO0FBQzFCLFdBQU8sdUJBQXVCLE1BQU0sQ0FBQyxHQUFHLE1BQU0sTUFBTSxFQUFFLENBQUMsR0FBRyxDQUFDLEdBQUcsR0FBRyxFQUFFOztFQVVyRSxrQkFBZTtBQUNiLFFBQUksTUFBTSxXQUFXLE1BQU0sZUFBZSxTQUFTO0FBQ25ELFFBQUksSUFBSSxXQUFXO0FBQUcsYUFBTyxnQkFBZ0IsSUFBSTtBQUNqRCxXQUFPLHVCQUF1QixNQUFNLENBQUMsR0FBRyxNQUFNLEVBQUUsUUFBUSxDQUFDLE1BQU0sSUFBSSxLQUFLLEVBQUU7O0VBVTVFLDRCQUF5QjtBQUN2QixRQUFJLE1BQU0sV0FBVyxNQUFNLGVBQWUsU0FBUztBQUNuRCxRQUFJLElBQUksV0FBVztBQUFHLGFBQU8sZ0JBQWdCLElBQUk7QUFDakQsV0FBTyx1QkFBdUIsTUFBTSxDQUFDLEdBQUcsTUFBTSxFQUFFLEtBQUssT0FBSyxFQUFFLFFBQVEsQ0FBQyxNQUFNLENBQUMsR0FBRyxLQUFLLFNBQVM7O0VBVS9GLFFBQUs7QUFDSCxVQUFNLE1BQU0sV0FBVyxNQUFNLGVBQWUsU0FBUztBQUNyRCxRQUFJLFVBQVUsS0FBSztBQUNuQixRQUFJO0FBQUUsVUFBSSxLQUFLLE9BQU87YUFBWSxHQUFQO0FBQVksYUFBTyxLQUFLLE1BQU0sb0JBQW9COztBQUM3RSxRQUFJLElBQUksV0FBVztBQUFHLGFBQU8sZ0JBQWdCLElBQUk7QUFDakQsVUFBTSxJQUFJLElBQUksS0FBSyxXQUFXLE1BQU0sTUFBTSxZQUFZLElBQUksQ0FBQyxHQUFHLElBQUksSUFBSSxTQUFTLENBQUMsQ0FBQyxDQUFDO0FBRWxGLE1BQUUscUJBQXFCLGVBQVM7QUFDOUIsZ0JBQVcsY0FBYyxTQUN2QixLQUFLLGFBQ0wsS0FBSztBQUNQLFVBQUksS0FBSyxPQUFPOztBQUdsQixRQUFJLElBQUk7QUFDUixNQUFFLGNBQWMsQ0FBQyxRQUFRLFNBQVNBLGFBQU87QUFDdkMsWUFBTSxNQUFNLE9BQU87QUFDbkIsYUFBTyxRQUFRLEtBQUssSUFBSSxDQUFDLENBQUMsSUFBSSxHQUFHO0FBRS9CLFVBQUU7QUFDRixZQUFJLE1BQU0sSUFBSSxRQUFRO0FBRXBCLGtCQUFRQSxRQUFPO0FBQ2YsaUJBQU87OztBQUdYLFVBQUksUUFBUSxLQUFLLElBQUksQ0FBQyxDQUFDLE1BQU0sR0FBRztBQUU5QixlQUFPO2FBQ0Y7QUFFTCxnQkFBUSxNQUFBO0FBQVEsaUJBQU8sU0FBUyxJQUFJLENBQUMsQ0FBQztRQUFFLENBQUU7QUFDMUMsZUFBTzs7S0FFVjtBQUNELFdBQU87O0VBUVQsU0FBUyxPQUFvQjtBQUMzQixXQUFPLEtBQUssV0FBVyxDQUFDLENBQUMsUUFBUSxLQUFLLEdBQUcsQ0FBQyxPQUFPLEtBQUssR0FBRyxPQUFPLENBQUMsR0FBRyxFQUFFLGVBQWUsT0FBTyxlQUFlLE1BQUssQ0FBRTs7RUFVcEgsU0FBTTtBQUNKLFVBQU0sTUFBTSxXQUFXLE1BQU0sZUFBZSxTQUFTO0FBQ3JELFFBQUksSUFBSSxXQUFXO0FBQUcsYUFBTyxJQUFJLEtBQUssV0FBVyxJQUFJO0FBQ3JELFFBQUk7QUFBRSxVQUFJLEtBQUssS0FBSyxVQUFVO2FBQVksR0FBUDtBQUFZLGFBQU8sS0FBSyxNQUFNLG9CQUFvQjs7QUFFckYsVUFBTSxTQUFTLElBQUksT0FDakIsQ0FBQyxLQUFLLFFBQVEsTUFDWixJQUFJLE9BQU8sQ0FBQyxDQUFDLElBQUksSUFBSSxTQUFTLENBQUMsRUFBRSxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUMsSUFDMUMsQ0FBQyxDQUFDLFFBQVEsR0FBRyxDQUFDLEdBQ2hCLElBQUk7QUFDTixXQUFPLEtBQUssQ0FBQyxJQUFJLElBQUksU0FBUyxDQUFDLEdBQUcsS0FBSyxHQUFHLE9BQU8sQ0FBQztBQUNsRCxXQUFPLEtBQUssV0FBVyxRQUFRLEVBQUUsZUFBZSxPQUFPLGVBQWUsTUFBSyxDQUFFOztFQVEvRSxXQUNFLFFBQ0EsU0FBOEQ7QUFFOUQsVUFBTVksT0FBTSxLQUFLLE1BQ1gsWUFBWSxLQUFLLFlBQ2pCLGFBQWEsS0FBSyxhQUNsQkcsT0FBTSxLQUFLLE1BQ1hDLE9BQU0sS0FBSztBQUVqQixRQUFJLE9BQU8sV0FBVztBQUFHLGFBQU8sZ0JBQWdCLElBQUk7QUFDcEQsUUFBSSxDQUFDLE9BQU8sTUFBTSxXQUNoQixNQUFNLENBQUMsTUFBTSxVQUNiLE1BQU0sQ0FBQyxNQUFNLFVBQ2IsVUFBVSxNQUFNLENBQUMsR0FBRyxNQUFNLENBQUMsQ0FBQyxLQUFLLENBQUMsR0FBRztBQUNyQyxhQUFPLEtBQ0wsTUFDQSw4SEFDQSxXQUFXLGVBQWU7O0FBRTlCLFVBQU0sZ0JBQWdCLENBQUMsV0FBVyxRQUFRLGtCQUFrQjtBQUM1RCxVQUFNLGdCQUFnQixXQUFXLFFBQVEsa0JBQWtCO0FBRTNELGFBQVNDLFVBQVNDLFNBQVEsVUFBUTtBQUNoQyxVQUFJLElBQUksR0FBRyxJQUFJQSxRQUFPO0FBQ3RCLGFBQU8sSUFBSSxHQUFHLEVBQUUsR0FBRztBQUNqQixjQUFNLFFBQVFBLFFBQU8sQ0FBQztBQUN0QixZQUFJTixLQUFJLFNBQVMsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxDQUFDLElBQUksS0FBS0EsS0FBSSxTQUFTLENBQUMsR0FBRyxNQUFNLENBQUMsQ0FBQyxJQUFJLEdBQUc7QUFDcEUsZ0JBQU0sQ0FBQyxJQUFJRyxLQUFJLE1BQU0sQ0FBQyxHQUFHLFNBQVMsQ0FBQyxDQUFDO0FBQ3BDLGdCQUFNLENBQUMsSUFBSUMsS0FBSSxNQUFNLENBQUMsR0FBRyxTQUFTLENBQUMsQ0FBQztBQUNwQzs7O0FBR0osVUFBSSxNQUFNO0FBQ1IsUUFBQUUsUUFBTyxLQUFLLFFBQVE7QUFDdEIsYUFBT0E7O0FBR1QsUUFBSSxnQkFBZ0I7QUFDcEIsYUFBUyxZQUFZLEdBQUcsR0FBQztBQUFJLGFBQU8sY0FBYyxFQUFFLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQztJQUFFO0FBRzlELFFBQUk7QUFDSixRQUFJO0FBQ0YsWUFBTSxPQUFPLE9BQU9ELFdBQVUsQ0FBQSxDQUFFO0FBQ2hDLFVBQUksS0FBSyxXQUFXO2FBQ2IsSUFBUDtBQUNBLGFBQU8sS0FBSyxNQUFNLG9CQUFvQjs7QUFHeEMsUUFBSSxXQUFXO0FBQ2YsVUFBTSwwQkFBMEIsZ0JBQzlCLFNBQU8sVUFBVSxLQUFLLElBQUksUUFBUSxFQUFFLENBQUMsQ0FBQyxJQUFJLElBQzFDLFNBQU8sVUFBVSxLQUFLLElBQUksUUFBUSxFQUFFLENBQUMsQ0FBQyxLQUFLO0FBRTdDLFVBQU0sMEJBQTBCLGdCQUM5QixTQUFPLFdBQVcsS0FBSyxJQUFJLFFBQVEsRUFBRSxDQUFDLENBQUMsSUFBSSxJQUMzQyxTQUFPLFdBQVcsS0FBSyxJQUFJLFFBQVEsRUFBRSxDQUFDLENBQUMsS0FBSztBQUU5QyxhQUFTLHNCQUFzQixLQUFHO0FBQ2hDLGFBQU8sQ0FBQyx3QkFBd0IsR0FBRyxLQUFLLENBQUMsd0JBQXdCLEdBQUc7O0FBR3RFLFFBQUksV0FBVztBQUVmLFVBQU0sSUFBSSxJQUFJLEtBQUssV0FDakIsTUFDQSxNQUFNLFlBQVksSUFBSSxDQUFDLEVBQUUsQ0FBQyxHQUFHLElBQUksSUFBSSxTQUFTLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxlQUFlLENBQUMsYUFBYSxDQUFDO0FBRXRGLE1BQUUscUJBQXFCLGVBQVM7QUFDOUIsVUFBSSxjQUFjLFFBQVE7QUFDeEIsbUJBQVc7QUFDWCx3QkFBZ0I7YUFDWDtBQUNMLG1CQUFXO0FBQ1gsd0JBQWdCOztBQUVsQixVQUFJLEtBQUssV0FBVzs7QUFHdEIsTUFBRSxjQUFjLENBQUMsUUFBUSxTQUFTakIsYUFBTztBQUN2QyxVQUFJLE1BQU0sT0FBTztBQUNqQixhQUFPLFNBQVMsR0FBRyxHQUFHO0FBRXBCLFVBQUU7QUFDRixZQUFJLGFBQWEsSUFBSSxRQUFRO0FBRTNCLGtCQUFRQSxRQUFPO0FBQ2YsaUJBQU87OztBQUdYLFVBQUksc0JBQXNCLEdBQUcsR0FBRztBQUU5QixlQUFPO2lCQUNFLEtBQUssS0FBSyxLQUFLLElBQUksUUFBUSxFQUFFLENBQUMsQ0FBQyxNQUFNLEtBQUssS0FBSyxLQUFLLEtBQUssSUFBSSxRQUFRLEVBQUUsQ0FBQyxDQUFDLE1BQU0sR0FBRztBQUczRixlQUFPO2FBQ0Y7QUFFTCxnQkFBUSxNQUFBO0FBQ04sY0FBSSxrQkFBa0I7QUFBVyxtQkFBTyxTQUFTLElBQUksUUFBUSxFQUFFLENBQUMsQ0FBQzs7QUFDNUQsbUJBQU8sU0FBUyxJQUFJLFFBQVEsRUFBRSxDQUFDLENBQUM7U0FDdEM7QUFDRCxlQUFPOztLQUVWO0FBQ0QsV0FBTzs7RUFVVCxrQkFBZTtBQUNiLFVBQU0sTUFBTSxXQUFXLE1BQU0sZUFBZSxTQUFTO0FBRXJELFFBQUksQ0FBQyxJQUFJLE1BQU0sT0FBSyxPQUFPLE1BQU0sUUFBUSxHQUFHO0FBQ3hDLGFBQU8sS0FBSyxNQUFNLDJDQUEyQzs7QUFFakUsUUFBSSxJQUFJLFdBQVc7QUFBRyxhQUFPLGdCQUFnQixJQUFJO0FBRWpELFdBQU8sS0FBSyxXQUFXLElBQUksSUFBSSxDQUFDLFFBQWdCLENBQUMsS0FBSyxNQUFNLFNBQVMsQ0FBQyxDQUFDOzs7U0N2VjNELDZCQUE2QixJQUFTO0FBQ3BELFNBQU8scUJBQ0wsWUFBWSxXQUVaLFNBQVNtQixhQUErQixPQUFjLE9BQWdCLGNBQXlCO0FBQzdGLFNBQUssS0FBSztBQUNWLFNBQUssT0FBTztNQUNWO01BQ0EsT0FBTyxVQUFVLFFBQVEsT0FBTztNQUNoQyxJQUFJOztBQUVOLFVBQU1DLGFBQVksR0FBRyxNQUFNO0FBQzNCLFFBQUksQ0FBQ0E7QUFBVyxZQUFNLElBQUksV0FBVyxXQUFVO0FBQy9DLFNBQUssT0FBTyxLQUFLLGFBQWFBLFdBQVUsSUFBSSxLQUFLQSxVQUFTO0FBQzFELFNBQUssY0FBYyxDQUFDLEdBQUcsTUFBTUEsV0FBVSxJQUFJLEdBQUcsQ0FBQztBQUMvQyxTQUFLLE9BQU8sQ0FBQyxHQUFHLE1BQU1BLFdBQVUsSUFBSSxHQUFFLENBQUMsSUFBSSxJQUFJLElBQUk7QUFDbkQsU0FBSyxPQUFPLENBQUMsR0FBRyxNQUFNQSxXQUFVLElBQUksR0FBRSxDQUFDLElBQUksSUFBSSxJQUFJO0FBQ25ELFNBQUssZUFBZSxHQUFHLE1BQU07R0FDOUI7QUFFTDtTQ3BDZ0IsbUJBQW1CbkIsU0FBTTtBQUN2QyxTQUFPLEtBQUssU0FBVSxPQUFLO0FBQ3ZCLG1CQUFlLEtBQUs7QUFDcEIsSUFBQUEsUUFBUSxNQUFNLE9BQU8sS0FBSztBQUMxQixXQUFPO0dBQ1Y7QUFDSDtTQTRDZ0IsZUFBZSxPQUFLO0FBQ2xDLE1BQUksTUFBTTtBQUNOLFVBQU0sZ0JBQWU7QUFDekIsTUFBSSxNQUFNO0FBQ04sVUFBTSxlQUFjO0FBQzFCO0FDdERPLElBQU0sbUNBQW1DO0FBYXpDLElBQU0saUNBQWlDO0FBRXZDLElBQU0sZUFBZSxPQUFPLE1BQU0sZ0NBQWdDO0lDQzVEb0IscUJBQVc7RUE2QnRCLFFBQUs7QUFDSCxXQUFPLENBQUMsSUFBSSxNQUFNO0FBRWxCLE1BQUUsS0FBSztBQUNQLFFBQUksS0FBSyxjQUFjLEtBQUssQ0FBQyxJQUFJO0FBQVEsVUFBSSxlQUFlO0FBQzVELFdBQU87O0VBT1QsVUFBTztBQUNMLFdBQU8sQ0FBQyxJQUFJLE1BQU07QUFDbEIsUUFBSSxFQUFFLEtBQUssY0FBYyxHQUFHO0FBQzFCLFVBQUksQ0FBQyxJQUFJO0FBQVEsWUFBSSxlQUFlO0FBQ3BDLGFBQU8sS0FBSyxjQUFjLFNBQVMsS0FBSyxDQUFDLEtBQUssUUFBTyxHQUFJO0FBQ3ZELFlBQUksV0FBVyxLQUFLLGNBQWMsTUFBSztBQUN2QyxZQUFJO0FBQUUsaUJBQU8sU0FBUyxDQUFDLEdBQUcsU0FBUyxDQUFDLENBQUM7aUJBQVksR0FBUDtRQUFVOzs7QUFHeEQsV0FBTzs7RUFPVCxVQUFPO0FBV0wsV0FBTyxLQUFLLGFBQWEsSUFBSSxpQkFBaUI7O0VBUWhELE9BQU8sVUFBeUI7QUFDOUIsUUFBSSxDQUFDLEtBQUs7QUFBTSxhQUFPO0FBQ3ZCLFVBQU0sUUFBUSxLQUFLLEdBQUc7QUFDdEIsVUFBTSxjQUFjLEtBQUssR0FBRyxPQUFPO0FBQ25DLFdBQU8sQ0FBQyxLQUFLLFFBQVE7QUFDckIsUUFBSSxDQUFDLFlBQVksQ0FBQyxPQUFPO0FBQ3ZCLGNBQVEsZUFBZSxZQUFZLE1BQUk7UUFDckMsS0FBSztBQUVILGdCQUFNLElBQUksV0FBVyxlQUFlLFdBQVc7UUFDakQsS0FBSztBQUVILGdCQUFNLElBQUksV0FBVyxXQUFXLFlBQVksU0FBUyxXQUFXO1FBQ2xFO0FBRUUsZ0JBQU0sSUFBSSxXQUFXLFdBQVcsV0FBVzs7O0FBR2pELFFBQUksQ0FBQyxLQUFLO0FBQVEsWUFBTSxJQUFJLFdBQVcsb0JBQW1CO0FBQzFELFdBQU8sS0FBSyxZQUFZLFdBQVcsSUFBSTtBQUV2QyxlQUFXLEtBQUssV0FBVyxhQUN4QixLQUFLLEdBQUcsT0FDTCxLQUFLLEdBQUcsS0FBSyxZQUFZLEtBQUssWUFBWSxLQUFLLE1BQWtDLEVBQUUsWUFBWSxLQUFLLDRCQUEyQixDQUFFLElBQ2pJLE1BQU0sWUFBWSxLQUFLLFlBQVksS0FBSyxNQUFNLEVBQUUsWUFBWSxLQUFLLDRCQUEyQixDQUFFO0FBR3BHLGFBQVMsVUFBVSxLQUFLLFFBQUU7QUFDeEIscUJBQWUsRUFBRTtBQUNqQixXQUFLLFFBQVEsU0FBUyxLQUFLO0tBQzVCO0FBQ0QsYUFBUyxVQUFVLEtBQUssUUFBRTtBQUN4QixxQkFBZSxFQUFFO0FBQ2pCLFdBQUssVUFBVSxLQUFLLFFBQVEsSUFBSSxXQUFXLE1BQU0sU0FBUyxLQUFLLENBQUM7QUFDaEUsV0FBSyxTQUFTO0FBQ2QsV0FBSyxHQUFHLE9BQU8sRUFBRSxLQUFLLEVBQUU7S0FDekI7QUFDRCxhQUFTLGFBQWEsS0FBSyxNQUFBO0FBQ3pCLFdBQUssU0FBUztBQUNkLFdBQUssU0FBUTtBQUNiLFVBQUksa0JBQWtCLFVBQVU7QUFDOUIscUJBQWEsZUFBZSxLQUFLLFNBQVMsY0FBYyxDQUFDOztLQUU1RDtBQUNELFdBQU87O0VBT1QsU0FDRSxNQUNBLElBQ0EsWUFBNkI7QUFFN0IsUUFBSSxTQUFTLGVBQWUsS0FBSyxTQUFTO0FBQ3hDLGFBQU8sVUFBVSxJQUFJLFdBQVcsU0FBUyx5QkFBeUIsQ0FBQztBQUVyRSxRQUFJLENBQUMsS0FBSztBQUNSLGFBQU8sVUFBVSxJQUFJLFdBQVcsb0JBQW1CLENBQUU7QUFFdkQsUUFBSSxLQUFLLFFBQU8sR0FBSTtBQUNsQixhQUFPLElBQUksYUFBYSxDQUFDckIsVUFBU0MsWUFBTTtBQUN0QyxhQUFLLGNBQWMsS0FBSyxDQUFDLE1BQUE7QUFDdkIsZUFBSyxTQUFTLE1BQU0sSUFBSSxVQUFVLEVBQUUsS0FBS0QsVUFBU0MsT0FBTTtXQUN2RCxHQUFHLENBQUM7T0FDUjtlQUVRLFlBQVk7QUFDckIsYUFBTyxTQUFTLE1BQUE7QUFDZCxZQUFJcUIsS0FBSSxJQUFJLGFBQWEsQ0FBQ3RCLFVBQVNDLFlBQU07QUFDdkMsZUFBSyxNQUFLO0FBQ1YsZ0JBQU0sS0FBSyxHQUFHRCxVQUFTQyxTQUFRLElBQUk7QUFDbkMsY0FBSSxNQUFNLEdBQUc7QUFBTSxlQUFHLEtBQUtELFVBQVNDLE9BQU07U0FDM0M7QUFDRCxRQUFBcUIsR0FBRSxRQUFRLE1BQU0sS0FBSyxRQUFPLENBQUU7QUFDOUIsUUFBQUEsR0FBRSxPQUFPO0FBQ1QsZUFBT0E7T0FDUjtXQUVJO0FBQ0wsVUFBSSxJQUFJLElBQUksYUFBYSxDQUFDdEIsVUFBU0MsWUFBTTtBQUN2QyxZQUFJLEtBQUssR0FBR0QsVUFBU0MsU0FBUSxJQUFJO0FBQ2pDLFlBQUksTUFBTSxHQUFHO0FBQU0sYUFBRyxLQUFLRCxVQUFTQyxPQUFNO09BQzNDO0FBQ0QsUUFBRSxPQUFPO0FBQ1QsYUFBTzs7O0VBUVgsUUFBSztBQUNILFdBQU8sS0FBSyxTQUFTLEtBQUssT0FBTyxNQUFLLElBQUs7O0VBUzdDLFFBQVEsYUFBNkI7QUFFbkMsUUFBSSxPQUFPLEtBQUssTUFBSztBQUdyQixVQUFNLFVBQVUsYUFBYSxRQUFRLFdBQVc7QUFDaEQsUUFBSSxLQUFLLGFBQWE7QUFFcEIsV0FBSyxjQUFjLEtBQUssWUFBWSxLQUFLLE1BQU0sT0FBTztXQUNqRDtBQUVMLFdBQUssY0FBYztBQUNuQixXQUFLLGdCQUFnQixDQUFBO0FBRXJCLFVBQUksUUFBUSxLQUFLLFNBQVMsWUFBWSxLQUFLLFdBQVcsQ0FBQyxDQUFDO0FBQ3hELE9BQUMsU0FBUyxPQUFJO0FBQ1osVUFBRSxLQUFLO0FBQ1AsZUFBTyxLQUFLLGNBQWM7QUFBUSxVQUFDLEtBQUssY0FBYyxNQUFLLEVBQUU7QUFDN0QsWUFBSSxLQUFLO0FBQWEsZ0JBQU0sSUFBSSxTQUFTLEVBQUUsWUFBWTtTQUN4RDs7QUFFSCxRQUFJLHFCQUFxQixLQUFLO0FBQzlCLFdBQU8sSUFBSSxhQUFhLENBQUNELFVBQVNDLFlBQU07QUFDdEMsY0FBUSxLQUNOLFNBQU8sS0FBSyxjQUFjLEtBQUssS0FBS0QsU0FBUSxLQUFLLE1BQU0sR0FBRyxDQUFDLENBQUMsR0FDNUQsU0FBTyxLQUFLLGNBQWMsS0FBSyxLQUFLQyxRQUFPLEtBQUssTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQzVELFFBQVEsTUFBQTtBQUNSLFlBQUksS0FBSyxnQkFBZ0Isb0JBQW9CO0FBRTNDLGVBQUssY0FBYzs7T0FFdEI7S0FDRjs7RUFPSCxRQUFLO0FBQ0gsUUFBSSxLQUFLLFFBQVE7QUFDZixXQUFLLFNBQVM7QUFDZCxVQUFJLEtBQUs7QUFBVSxhQUFLLFNBQVMsTUFBSztBQUN0QyxXQUFLLFFBQVEsSUFBSSxXQUFXLE1BQUssQ0FBRTs7O0VBUXZDLE1BQU0sV0FBaUI7QUFDckIsVUFBTSxpQkFBa0IsS0FBSyxvQkFBb0IsS0FBSyxrQkFBa0IsQ0FBQTtBQUN4RSxRQUFJLE9BQU8sZ0JBQWdCLFNBQVM7QUFDbEMsYUFBTyxlQUFlLFNBQVM7QUFDakMsVUFBTSxjQUFjLEtBQUssT0FBTyxTQUFTO0FBQ3pDLFFBQUksQ0FBQyxhQUFhO0FBQ2hCLFlBQU0sSUFBSSxXQUFXLFNBQVMsV0FBVyxZQUFZLDBCQUEwQjs7QUFHakYsVUFBTSx3QkFBd0IsSUFBSSxLQUFLLEdBQUcsTUFBTSxXQUFXLGFBQWEsSUFBSTtBQUM1RSwwQkFBc0IsT0FBTyxLQUFLLEdBQUcsS0FBSyxNQUFNLFNBQVM7QUFDekQsbUJBQWUsU0FBUyxJQUFJO0FBQzVCLFdBQU87OztTQ2hQSyw2QkFBNkIsSUFBUztBQUNwRCxTQUFPLHFCQUNMb0IsYUFBWSxXQUNaLFNBQVNBLGFBRVAsTUFDQSxZQUNBLFVBQ0EsNkJBQ0EsUUFBb0I7QUFFcEIsU0FBSyxLQUFLO0FBQ1YsU0FBSyxPQUFPO0FBQ1osU0FBSyxhQUFhO0FBQ2xCLFNBQUssU0FBUztBQUNkLFNBQUssOEJBQThCO0FBQ25DLFNBQUssV0FBVztBQUNoQixTQUFLLEtBQUssT0FBTyxNQUFNLFlBQVksU0FBUyxPQUFPO0FBQ25ELFNBQUssU0FBUyxVQUFVO0FBQ3hCLFNBQUssU0FBUztBQUNkLFNBQUssWUFBWTtBQUNqQixTQUFLLGdCQUFnQixDQUFBO0FBQ3JCLFNBQUssV0FBVztBQUNoQixTQUFLLFVBQVU7QUFDZixTQUFLLGNBQWM7QUFDbkIsU0FBSyxnQkFBZ0I7QUFDckIsU0FBSyxhQUFhO0FBQ2xCLFNBQUssY0FBYyxJQUFJaEIsYUFBUyxDQUFDTCxVQUFTQyxZQUFNO0FBQzVDLFdBQUssV0FBV0Q7QUFDaEIsV0FBSyxVQUFVQztLQUNsQjtBQUVELFNBQUssWUFBWSxLQUNiLE1BQUE7QUFDSSxXQUFLLFNBQVM7QUFDZCxXQUFLLEdBQUcsU0FBUyxLQUFJO09BRXpCLE9BQUM7QUFDRyxVQUFJLFlBQVksS0FBSztBQUNyQixXQUFLLFNBQVM7QUFDZCxXQUFLLEdBQUcsTUFBTSxLQUFLLENBQUM7QUFDcEIsV0FBSyxTQUNELEtBQUssT0FBTyxRQUFRLENBQUMsSUFDckIsYUFBYSxLQUFLLFlBQVksS0FBSyxTQUFTLE1BQUs7QUFDckQsYUFBTyxVQUFVLENBQUM7S0FDckI7R0FFTjtBQUNMO1NDckVnQixnQkFDZCxNQUNBLFNBQ0EsUUFDQSxPQUNBLE1BQ0EsVUFDQSxXQUFrQjtBQUVsQixTQUFPO0lBQ0w7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsTUFBTSxVQUFVLENBQUMsWUFBWSxNQUFNLE9BQU8sUUFBUSxNQUFNLE9BQU8sT0FBTyxPQUFPLE1BQU0sZ0JBQWdCLE9BQU87O0FBRTlHO1NBRWdCLGdCQUFpQixTQUEyQjtBQUMxRCxTQUFPLE9BQU8sWUFBWSxXQUN4QixVQUNBLFVBQVcsTUFBTSxDQUFBLEVBQUcsS0FBSyxLQUFLLFNBQVMsR0FBRyxJQUFJLE1BQU87QUFDekQ7U0NyQmdCLGtCQUNkLE1BQ0EsU0FDQSxTQUFvQjtBQUVwQixTQUFPO0lBQ0w7SUFDQTtJQUNBO0lBQ0EsYUFBYTtJQUNiLFdBQVcsY0FBYyxTQUFTLFdBQVMsQ0FBQyxNQUFNLE1BQU0sS0FBSyxDQUFDOztBQUVsRTtTQ2ZnQixvQkFBb0IsWUFBb0I7QUFDdEQsU0FBTyxXQUFXLFdBQVcsSUFBSSxXQUFXLENBQUMsSUFBSTtBQUNuRDtBQU9PLElBQUksWUFBWSxDQUFDLGdCQUErQjtBQUNyRCxNQUFJO0FBQ0YsZ0JBQVksS0FBSyxDQUFDLENBQUEsQ0FBRSxDQUFDO0FBQ3JCLGdCQUFZLE1BQU0sQ0FBQyxDQUFBLENBQUU7QUFDckIsV0FBTyxDQUFDLENBQUEsQ0FBRTtXQUNILEdBQVA7QUFDQSxnQkFBWSxNQUFNO0FBQ2xCLFdBQU87O0FBRVg7U0NsQmdCLGdCQUFpQixTQUFpQztBQUNoRSxNQUFJLFdBQVcsTUFBTTtBQUNuQixXQUFPLE1BQU07YUFDSixPQUFPLFlBQVksVUFBVTtBQUN0QyxXQUFPLDBCQUEwQixPQUFPO1NBQ25DO0FBQ0wsV0FBTyxTQUFPLGFBQWEsS0FBSyxPQUFPOztBQUUzQztTQUVnQiwwQkFBMEIsU0FBZTtBQUN2RCxRQUFNLFFBQVEsUUFBUSxNQUFNLEdBQUc7QUFDL0IsTUFBSSxNQUFNLFdBQVcsR0FBRztBQUN0QixXQUFPLFNBQU8sSUFBSSxPQUFPO1NBQ3BCO0FBQ0wsV0FBTyxTQUFPLGFBQWEsS0FBSyxPQUFPOztBQUUzQztTQ0NnQixTQUFZLFdBQStDO0FBQ3pFLFNBQU8sQ0FBQSxFQUFHLE1BQU0sS0FBSyxTQUFTO0FBQ2hDO0FBT0EsSUFBSSxjQUFjO1NBRUYsZ0JBQWdCLFNBQWlDO0FBQy9ELFNBQU8sV0FBVyxPQUNoQixRQUNBLE9BQU8sWUFBWSxXQUNqQixVQUNBLElBQUksUUFBUSxLQUFLLEdBQUc7QUFDMUI7U0FFZ0IsYUFDZCxJQUNBLGFBQ0EsVUFBd0I7QUFFeEIsV0FBUyxjQUFjc0IsS0FBaUIsT0FBcUI7QUFDM0QsVUFBTUMsVUFBUyxTQUFTRCxJQUFHLGdCQUFnQjtBQUMzQyxXQUFPO01BQ0wsUUFBUTtRQUNOLE1BQU1BLElBQUc7UUFDVCxRQUFRQyxRQUFPLElBQUksV0FBUyxNQUFNLFlBQVksS0FBSyxDQUFDLEVBQUUsSUFBSSxXQUFLO0FBQzdELGdCQUFNLEVBQUMsU0FBUyxjQUFhLElBQUk7QUFDakMsZ0JBQU0sV0FBVzlCLFNBQVEsT0FBTztBQUNoQyxnQkFBTSxXQUFXLFdBQVc7QUFDNUIsZ0JBQU0saUJBQXdELENBQUE7QUFDOUQsZ0JBQU0sU0FBUztZQUNiLE1BQU0sTUFBTTtZQUNaLFlBQVk7Y0FDVixNQUFNO2NBQ04sY0FBYztjQUNkO2NBQ0E7Y0FDQTtjQUNBO2NBQ0EsUUFBUTtjQUNSLFlBQVksZ0JBQWdCLE9BQU87O1lBRXJDLFNBQVMsU0FBUyxNQUFNLFVBQVUsRUFBRSxJQUFJLGVBQWEsTUFBTSxNQUFNLFNBQVMsQ0FBQyxFQUN4RSxJQUFJLFdBQUs7QUFDUixvQkFBTSxFQUFDLE1BQU0sUUFBUSxZQUFZLFNBQUErQixTQUFPLElBQUk7QUFDNUMsb0JBQU1DLFlBQVdoQyxTQUFRK0IsUUFBTztBQUNoQyxvQkFBTUUsVUFBc0I7Z0JBQzFCO2dCQUNBLFVBQUFEO2dCQUNBLFNBQUFEO2dCQUNBO2dCQUNBO2dCQUNBLFlBQVksZ0JBQWdCQSxRQUFPOztBQUVyQyw2QkFBZSxnQkFBZ0JBLFFBQU8sQ0FBQyxJQUFJRTtBQUMzQyxxQkFBT0E7YUFDUjtZQUNILG1CQUFtQixDQUFDRixhQUFzQyxlQUFlLGdCQUFnQkEsUUFBTyxDQUFDOztBQUVuRyx5QkFBZSxLQUFLLElBQUksT0FBTztBQUMvQixjQUFJLFdBQVcsTUFBTTtBQUNuQiwyQkFBZSxnQkFBZ0IsT0FBTyxDQUFDLElBQUksT0FBTzs7QUFFcEQsaUJBQU87U0FDUjs7TUFFSCxXQUFXRCxRQUFPLFNBQVMsS0FBTSxZQUFZLE1BQU0sWUFBWUEsUUFBTyxDQUFDLENBQUMsS0FDdEUsRUFBRSxPQUFPLGNBQWMsZUFBZSxTQUFTLEtBQUssVUFBVSxTQUFTLEtBQ3ZFLENBQUMsb0JBQW9CLEtBQUssVUFBVSxTQUFTLEtBQzdDLENBQUEsRUFBRyxPQUFPLFVBQVUsVUFBVSxNQUFNLGVBQWUsQ0FBQyxFQUFFLENBQUMsSUFBSTs7O0FBSWpFLFdBQVMsZ0JBQWlCLE9BQXFCO0FBQzdDLFFBQUksTUFBTSxTQUFJO0FBQTBCLGFBQU87QUFDL0MsUUFBSSxNQUFNLFNBQUk7QUFBNEIsWUFBTSxJQUFJLE1BQU0sMENBQTBDO0FBQ3BHLFVBQU0sRUFBQyxPQUFPLE9BQU8sV0FBVyxVQUFTLElBQUk7QUFDN0MsVUFBTSxXQUFXLFVBQVUsU0FDekIsVUFBVSxTQUNSLE9BQ0EsWUFBWSxXQUFXLE9BQU8sQ0FBQyxDQUFDLFNBQVMsSUFDM0MsVUFBVSxTQUNSLFlBQVksV0FBVyxPQUFPLENBQUMsQ0FBQyxTQUFTLElBQ3pDLFlBQVksTUFBTSxPQUFPLE9BQU8sQ0FBQyxDQUFDLFdBQVcsQ0FBQyxDQUFDLFNBQVM7QUFDNUQsV0FBTzs7QUFHVCxXQUFTLGtCQUFrQixhQUE4QjtBQUN2RCxVQUFNLFlBQVksWUFBWTtBQUU5QixhQUFTLE9BQVEsRUFBQyxPQUFPLE1BQUF0QixPQUFNLE1BQUFULE9BQU0sUUFBUSxNQUFLLEdBQUM7QUFDakQsYUFBTyxJQUFJLFFBQThCLENBQUNPLFVBQVNDLFlBQU07QUFDdkQsUUFBQUQsV0FBVSxLQUFLQSxRQUFPO0FBQ3RCLGNBQU0sUUFBUyxNQUF5QixZQUFZLFNBQVM7QUFDN0QsY0FBTSxXQUFXLE1BQU0sV0FBVztBQUNsQyxjQUFNLGFBQWFFLFVBQVMsU0FBU0EsVUFBUztBQUM5QyxZQUFJLENBQUMsY0FBY0EsVUFBUyxZQUFZQSxVQUFTO0FBQy9DLGdCQUFNLElBQUksTUFBTyw2QkFBNkJBLEtBQUk7QUFFcEQsY0FBTSxFQUFDLFFBQUFXLFFBQU0sSUFBSXBCLFNBQVEsVUFBVSxFQUFDLFFBQVEsRUFBQztBQUM3QyxZQUFJQSxTQUFRLFVBQVVBLE1BQUssV0FBVyxPQUFPLFFBQVE7QUFDbkQsZ0JBQU0sSUFBSSxNQUFNLCtEQUErRDs7QUFFakYsWUFBSW9CLFlBQVc7QUFFYixpQkFBT2IsU0FBUSxFQUFDLGFBQWEsR0FBRyxVQUFVLENBQUEsR0FBSSxTQUFTLENBQUEsR0FBSSxZQUFZLE9BQVMsQ0FBQztBQUVuRixZQUFJO0FBQ0osY0FBTSxPQUFxQixDQUFBO0FBRTNCLGNBQU0sV0FBK0MsQ0FBQTtBQUNyRCxZQUFJLGNBQWM7QUFDbEIsY0FBTSxlQUNKLFdBQUs7QUFDSCxZQUFFO0FBQ0YseUJBQWUsS0FBSzs7QUFHeEIsWUFBSUUsVUFBUyxlQUFlO0FBRTFCLGNBQUksTUFBTSxTQUFJO0FBQ1osbUJBQU9GLFNBQVEsRUFBQyxhQUFhLFVBQVUsU0FBUyxDQUFBLEdBQUksWUFBWSxPQUFTLENBQUM7QUFDNUUsY0FBSSxNQUFNLFNBQUk7QUFDWixpQkFBSyxLQUFLLE1BQU0sTUFBTSxNQUFLLENBQUU7O0FBRTdCLGlCQUFLLEtBQUssTUFBTSxNQUFNLE9BQU8sZ0JBQWdCLEtBQUssQ0FBQyxDQUFDO2VBQ2pEO0FBRUwsZ0JBQU0sQ0FBQyxPQUFPLEtBQUssSUFBSSxhQUNyQixXQUNFLENBQUMsUUFBUVAsS0FBSSxJQUNiLENBQUMsUUFBUSxJQUFJLElBQ2YsQ0FBQ0EsT0FBTSxJQUFJO0FBRWIsY0FBSSxZQUFZO0FBQ2QscUJBQVMsSUFBRSxHQUFHLElBQUVvQixTQUFRLEVBQUUsR0FBRztBQUMzQixtQkFBSyxLQUFLLE1BQU8sU0FBUyxNQUFNLENBQUMsTUFBTSxTQUNyQyxNQUFNWCxLQUFJLEVBQUUsTUFBTSxDQUFDLEdBQUcsTUFBTSxDQUFDLENBQUMsSUFDOUIsTUFBTUEsS0FBSSxFQUFFLE1BQU0sQ0FBQyxDQUFDLENBQWdCO0FBQ3RDLGtCQUFJLFVBQVU7O2lCQUVYO0FBQ0wscUJBQVMsSUFBRSxHQUFHLElBQUVXLFNBQVEsRUFBRSxHQUFHO0FBQzNCLG1CQUFLLEtBQUssTUFBTSxNQUFNWCxLQUFJLEVBQUUsTUFBTSxDQUFDLENBQUMsQ0FBZTtBQUNuRCxrQkFBSSxVQUFVOzs7O0FBSXBCLGNBQU0sT0FBTyxXQUFLO0FBQ2hCLGdCQUFNLGFBQWEsTUFBTSxPQUFPO0FBQ2hDLGVBQUssUUFBUSxDQUFDMEIsTUFBSyxNQUFNQSxLQUFJLFNBQVMsU0FBUyxTQUFTLENBQUMsSUFBSUEsS0FBSSxNQUFNO0FBQ3ZFLFVBQUE1QixTQUFRO1lBQ047WUFDQTtZQUNBLFNBQVNFLFVBQVMsV0FBV1QsUUFBTyxLQUFLLElBQUksQ0FBQW1DLFNBQU9BLEtBQUksTUFBTTtZQUM5RDtXQUNEOztBQUdILFlBQUksVUFBVSxXQUFLO0FBQ2pCLHVCQUFhLEtBQUs7QUFDbEIsZUFBSyxLQUFLOztBQUdaLFlBQUksWUFBWTtPQUNqQjs7QUFHSCxhQUFTQyxZQUFZLEVBQUMsT0FBTyxRQUFRLE9BQUFDLFFBQU8sU0FBUyxPQUFNLEdBQTBCO0FBRW5GLGFBQU8sSUFBSSxRQUFRLENBQUM5QixVQUFTQyxZQUFNO0FBQ2pDLFFBQUFELFdBQVUsS0FBS0EsUUFBTztBQUN0QixjQUFNLEVBQUMsT0FBTyxNQUFLLElBQUk4QjtBQUN2QixjQUFNLFFBQVMsTUFBeUIsWUFBWSxTQUFTO0FBRTdELGNBQU0sU0FBUyxNQUFNLGVBQ25CLFFBQ0EsTUFBTSxNQUFNLE1BQU0sSUFBSTtBQUV4QixjQUFNLFlBQVksVUFDaEIsU0FDRSxlQUNBLFNBQ0YsU0FDRSxlQUNBO0FBRUosY0FBTSxNQUFNLFVBQVUsRUFBRSxtQkFBbUIsVUFDekMsT0FBTyxXQUFXLGdCQUFnQixLQUFLLEdBQUcsU0FBUyxJQUNuRCxPQUFPLGNBQWMsZ0JBQWdCLEtBQUssR0FBRyxTQUFTO0FBR3hELFlBQUksVUFBVSxtQkFBbUI3QixPQUFNO0FBQ3ZDLFlBQUksWUFBWSxLQUFLLFFBQUU7QUFFckIsZ0JBQU0sU0FBUyxJQUFJO0FBQ25CLGNBQUksQ0FBQyxRQUFRO0FBQ1gsWUFBQUQsU0FBUSxJQUFJO0FBQ1o7O0FBRUQsaUJBQWUsUUFBUSxFQUFFO0FBQ3pCLGlCQUFlLE9BQU87QUFDdkIsZ0JBQU0sa0JBQWtCLE9BQU8sU0FBUyxLQUFLLE1BQU07QUFDbkQsY0FBSSw0QkFBNEIsT0FBTztBQUN2QyxjQUFJO0FBQTJCLHdDQUE0QiwwQkFBMEIsS0FBSyxNQUFNO0FBQ2hHLGdCQUFNLGlCQUFpQixPQUFPLFFBQVEsS0FBSyxNQUFNO0FBQ2pELGdCQUFNLDRCQUE0QixNQUFBO0FBQUssa0JBQU0sSUFBSSxNQUFNLG9CQUFvQjtVQUFFO0FBQzdFLGdCQUFNLHlCQUF5QixNQUFBO0FBQUssa0JBQU0sSUFBSSxNQUFNLG9CQUFvQjtVQUFFO0FBQ3pFLGlCQUFlLFFBQVE7QUFDeEIsaUJBQU8sT0FBTyxPQUFPLFdBQVcsT0FBTyxxQkFBcUIsT0FBTyxVQUFVO0FBQzdFLGlCQUFPLE9BQU8sS0FBS0MsT0FBTTtBQUN6QixpQkFBTyxPQUFPLFdBQUE7QUFHWixnQkFBSSxTQUFTO0FBQ2IsbUJBQU8sS0FBSyxNQUFNLE1BQU0sV0FBVyxLQUFLLFNBQVEsSUFBSyxLQUFLLEtBQUksQ0FBRSxFQUFFLEtBQUssTUFBTSxJQUFJOztBQUVuRixpQkFBTyxRQUFRLENBQUMsYUFBUTtBQUV0QixrQkFBTSxtQkFBbUIsSUFBSSxRQUFjLENBQUMsa0JBQWtCLG9CQUFlO0FBQzNFLGlDQUFtQixLQUFLLGdCQUFnQjtBQUN4QyxrQkFBSSxVQUFVLG1CQUFtQixlQUFlO0FBQ2hELHFCQUFPLE9BQU87QUFDZCxxQkFBTyxPQUFPLFdBQUs7QUFFakIsdUJBQU8sT0FBTyxPQUFPLFdBQVcsT0FBTyxxQkFBcUIsT0FBTyxVQUFVO0FBQzdFLGlDQUFpQixLQUFLOzthQUV6QjtBQUVELGtCQUFNLGtCQUFrQixNQUFBO0FBQ3RCLGtCQUFJLElBQUksUUFBUTtBQUVkLG9CQUFJO0FBQ0YsMkJBQVE7eUJBQ0QsS0FBUDtBQUNBLHlCQUFPLEtBQUssR0FBRzs7cUJBRVo7QUFDSix1QkFBZSxPQUFPO0FBQ3ZCLHVCQUFPLFFBQVEsTUFBQTtBQUFLLHdCQUFNLElBQUksTUFBTSwwQkFBMEI7Z0JBQUU7QUFDaEUsdUJBQU8sS0FBSTs7O0FBR2YsZ0JBQUksWUFBWSxLQUFLLENBQUE4QixRQUFFO0FBSXJCLGtCQUFJLFlBQVk7QUFDaEIsOEJBQWU7YUFDaEI7QUFDRCxtQkFBTyxXQUFXO0FBQ2xCLG1CQUFPLHFCQUFxQjtBQUM1QixtQkFBTyxVQUFVO0FBQ2pCLDRCQUFlO0FBQ2YsbUJBQU87O0FBRVQsVUFBQS9CLFNBQVEsTUFBTTtXQUNiQyxPQUFNO09BQ1Y7O0FBR0gsYUFBUyxNQUFPK0IsWUFBa0I7QUFDaEMsYUFBTyxDQUFDLFlBQTJCO0FBQ2pDLGVBQU8sSUFBSSxRQUE2QixDQUFDaEMsVUFBU0MsWUFBTTtBQUN0RCxVQUFBRCxXQUFVLEtBQUtBLFFBQU87QUFDdEIsZ0JBQU0sRUFBQyxPQUFPLFFBQVEsT0FBTyxPQUFBOEIsT0FBSyxJQUFJO0FBQ3RDLGdCQUFNLGtCQUFrQixVQUFVLFdBQVcsU0FBWTtBQUN6RCxnQkFBTSxFQUFDLE9BQU8sTUFBSyxJQUFJQTtBQUN2QixnQkFBTSxRQUFTLE1BQXlCLFlBQVksU0FBUztBQUM3RCxnQkFBTSxTQUFTLE1BQU0sZUFBZSxRQUFRLE1BQU0sTUFBTSxNQUFNLElBQUk7QUFDbEUsZ0JBQU0sY0FBYyxnQkFBZ0IsS0FBSztBQUN6QyxjQUFJLFVBQVU7QUFBRyxtQkFBTzlCLFNBQVEsRUFBQyxRQUFRLENBQUEsRUFBRSxDQUFDO0FBQzVDLGNBQUlnQyxZQUFXO0FBQ2Isa0JBQU0sTUFBTSxTQUNQLE9BQWUsT0FBTyxhQUFhLGVBQWUsSUFDbEQsT0FBZSxXQUFXLGFBQWEsZUFBZTtBQUMzRCxnQkFBSSxZQUFZLFdBQVNoQyxTQUFRLEVBQUMsUUFBUSxNQUFNLE9BQU8sT0FBTSxDQUFDO0FBQzlELGdCQUFJLFVBQVUsbUJBQW1CQyxPQUFNO2lCQUNsQztBQUNMLGdCQUFJUSxTQUFRO0FBQ1osa0JBQU0sTUFBTSxVQUFVLEVBQUUsbUJBQW1CLFVBQ3pDLE9BQU8sV0FBVyxXQUFXLElBQzdCLE9BQU8sY0FBYyxXQUFXO0FBQ2xDLGtCQUFNLFNBQVMsQ0FBQTtBQUNmLGdCQUFJLFlBQVksV0FBSztBQUNuQixvQkFBTSxTQUFTLElBQUk7QUFDbkIsa0JBQUksQ0FBQztBQUFRLHVCQUFPVCxTQUFRLEVBQUMsT0FBTSxDQUFDO0FBQ3BDLHFCQUFPLEtBQUssU0FBUyxPQUFPLFFBQVEsT0FBTyxVQUFVO0FBQ3JELGtCQUFJLEVBQUVTLFdBQVU7QUFBTyx1QkFBT1QsU0FBUSxFQUFDLE9BQU0sQ0FBQztBQUM5QyxxQkFBTyxTQUFROztBQUVqQixnQkFBSSxVQUFVLG1CQUFtQkMsT0FBTTs7U0FFMUM7OztBQUlMLFdBQU87TUFDTCxNQUFNO01BQ04sUUFBUTtNQUVSO01BRUEsUUFBUyxFQUFDLE9BQU8sTUFBQVIsTUFBSSxHQUFDO0FBQ3BCLGVBQU8sSUFBSSxRQUFlLENBQUNPLFVBQVNDLFlBQU07QUFDeEMsVUFBQUQsV0FBVSxLQUFLQSxRQUFPO0FBQ3RCLGdCQUFNLFFBQVMsTUFBeUIsWUFBWSxTQUFTO0FBQzdELGdCQUFNYSxVQUFTcEIsTUFBSztBQUNwQixnQkFBTSxTQUFTLElBQUksTUFBTW9CLE9BQU07QUFDL0IsY0FBSSxXQUFXO0FBQ2YsY0FBSSxnQkFBZ0I7QUFFcEIsY0FBSTtBQUVKLGdCQUFNLGlCQUFpQixXQUFLO0FBQzFCLGtCQUFNZSxPQUFNLE1BQU07QUFDbEIsaUJBQUssT0FBT0EsS0FBSSxJQUFJLElBQUlBLEtBQUksV0FBVztBQUFNO0FBQzdDLGdCQUFJLEVBQUUsa0JBQWtCO0FBQVUsY0FBQTVCLFNBQVEsTUFBTTs7QUFFbEQsZ0JBQU0sZUFBZSxtQkFBbUJDLE9BQU07QUFFOUMsbUJBQVMsSUFBRSxHQUFHLElBQUVZLFNBQVEsRUFBRSxHQUFHO0FBQzNCLGtCQUFNLE1BQU1wQixNQUFLLENBQUM7QUFDbEIsZ0JBQUksT0FBTyxNQUFNO0FBQ2Ysb0JBQU0sTUFBTSxJQUFJQSxNQUFLLENBQUMsQ0FBQztBQUN2QixrQkFBSSxPQUFPO0FBQ1gsa0JBQUksWUFBWTtBQUNoQixrQkFBSSxVQUFVO0FBQ2QsZ0JBQUU7OztBQUdOLGNBQUksYUFBYTtBQUFHLFlBQUFPLFNBQVEsTUFBTTtTQUNuQzs7TUFHSCxJQUFLLEVBQUMsT0FBTyxJQUFHLEdBQUM7QUFDZixlQUFPLElBQUksUUFBYSxDQUFDQSxVQUFTQyxZQUFNO0FBQ3RDLFVBQUFELFdBQVUsS0FBTUEsUUFBTztBQUN2QixnQkFBTSxRQUFTLE1BQXlCLFlBQVksU0FBUztBQUM3RCxnQkFBTSxNQUFNLE1BQU0sSUFBSSxHQUFHO0FBQ3pCLGNBQUksWUFBWSxXQUFTQSxTQUFTLE1BQU0sT0FBZSxNQUFNO0FBQzdELGNBQUksVUFBVSxtQkFBbUJDLE9BQU07U0FDeEM7O01BR0gsT0FBTyxNQUFNLFNBQVM7TUFFdEIsWUFBQTRCO01BRUEsTUFBTyxFQUFDLE9BQUFDLFFBQU8sTUFBSyxHQUFDO0FBQ25CLGNBQU0sRUFBQyxPQUFPLE1BQUssSUFBSUE7QUFDdkIsZUFBTyxJQUFJLFFBQWdCLENBQUM5QixVQUFTQyxZQUFNO0FBQ3pDLGdCQUFNLFFBQVMsTUFBeUIsWUFBWSxTQUFTO0FBQzdELGdCQUFNLFNBQVMsTUFBTSxlQUFlLFFBQVEsTUFBTSxNQUFNLE1BQU0sSUFBSTtBQUNsRSxnQkFBTSxjQUFjLGdCQUFnQixLQUFLO0FBQ3pDLGdCQUFNLE1BQU0sY0FBYyxPQUFPLE1BQU0sV0FBVyxJQUFJLE9BQU8sTUFBSztBQUNsRSxjQUFJLFlBQVksS0FBSyxRQUFNRCxTQUFTLEdBQUcsT0FBc0IsTUFBTSxDQUFDO0FBQ3BFLGNBQUksVUFBVSxtQkFBbUJDLE9BQU07U0FDeEM7Ozs7QUFLUCxRQUFNLEVBQUMsUUFBUSxVQUFTLElBQUksY0FBYyxJQUFJLFFBQVE7QUFDdEQsUUFBTSxTQUFTLE9BQU8sT0FBTyxJQUFJLGlCQUFlLGtCQUFrQixXQUFXLENBQUM7QUFDOUUsUUFBTSxXQUEwQyxDQUFBO0FBQ2hELFNBQU8sUUFBUSxXQUFTLFNBQVMsTUFBTSxJQUFJLElBQUksS0FBSztBQUNwRCxTQUFPO0lBQ0wsT0FBTztJQUVQLGFBQWEsR0FBRyxZQUFZLEtBQUssRUFBRTtJQUVuQyxNQUFNLE1BQVk7QUFDaEIsWUFBTSxTQUFTLFNBQVMsSUFBSTtBQUM1QixVQUFJLENBQUM7QUFBUSxjQUFNLElBQUksTUFBTSxVQUFVLGlCQUFpQjtBQUN4RCxhQUFPLFNBQVMsSUFBSTs7SUFHdEIsU0FBUztJQUVULFNBQVMsVUFBVSxXQUFXO0lBRTlCOztBQUdKO0FDblpBLFNBQVMsc0JBQ1AsV0FDQSxhQUEwQztBQUMxQyxTQUFPLFlBQVksT0FBTyxDQUFDLE1BQU0sRUFBQyxRQUFBZ0MsUUFBTSxPQUFPLEVBQUMsR0FBRyxNQUFNLEdBQUdBLFFBQU8sSUFBSSxFQUFDLElBQUksU0FBUztBQUN2RjtBQUVBLFNBQVMsdUJBQ1AsYUFDQSxPQUNBLEVBQUMsYUFBQUMsY0FBYSxXQUFBZCxXQUFTLEdBQ3ZCLFVBQXdCO0FBRXhCLFFBQU0sU0FBUyxzQkFDYixhQUFhLE9BQU9jLGNBQWEsUUFBUSxHQUN6QyxZQUFZLE1BQU07QUFLcEIsU0FBTztJQUNMOztBQUVKO1NBRWdCLHlCQUF5QixFQUFDLFFBQVEsR0FBRSxHQUFVLFVBQXdCO0FBQ3BGLFFBQU0sUUFBUSxTQUFTO0FBQ3ZCLFFBQU0sU0FBUyx1QkFBdUIsR0FBRyxjQUFjLE9BQU8sR0FBRyxPQUFPLFFBQVE7QUFDaEYsS0FBRyxPQUFPLE9BQU87QUFDakIsS0FBRyxPQUFPLFFBQVEsV0FBSztBQUNyQixVQUFNLFlBQVksTUFBTTtBQUN4QixRQUFJLEdBQUcsS0FBSyxPQUFPLE9BQU8sS0FBSyxTQUFPLElBQUksU0FBUyxTQUFTLEdBQUc7QUFDN0QsWUFBTSxPQUFPLEdBQUcsS0FBSyxNQUFNLFNBQVM7QUFDcEMsVUFBSSxHQUFHLFNBQVMsYUFBYSxHQUFHLE9BQU87QUFDbkMsV0FBRyxTQUFTLEVBQUUsT0FBTyxNQUFNOzs7R0FHbEM7QUFDSDtTQzVCZ0IsY0FBYyxFQUFDLFFBQVEsR0FBRSxHQUFVLE1BQWdCLFlBQXNCLFVBQWtCO0FBQ3pHLGFBQVcsUUFBUSxlQUFTO0FBQzFCLFVBQU0sU0FBUyxTQUFTLFNBQVM7QUFDakMsU0FBSyxRQUFRLFNBQUc7QUFDZCxZQUFNLFdBQVcsc0JBQXNCLEtBQUssU0FBUztBQUNyRCxVQUFJLENBQUMsWUFBYSxXQUFXLFlBQVksU0FBUyxVQUFVLFFBQVk7QUFFdEUsWUFBSSxRQUFRLEdBQUcsWUFBWSxhQUFhLGVBQWUsR0FBRyxhQUFhO0FBR3JFLGtCQUFRLEtBQUssV0FBVztZQUN0QixNQUFHO0FBQXNCLHFCQUFPLEtBQUssTUFBTSxTQUFTO1lBQUU7WUFDdEQsSUFBSSxPQUFVO0FBR1osNkJBQWUsTUFBTSxXQUFXLEVBQUMsT0FBTyxVQUFVLE1BQU0sY0FBYyxNQUFNLFlBQVksS0FBSSxDQUFDOztXQUVoRztlQUNJO0FBRUwsY0FBSSxTQUFTLElBQUksSUFBSSxHQUFHLE1BQU0sV0FBVyxNQUFNOzs7S0FHcEQ7R0FDRjtBQUNIO1NBRWdCLGdCQUFnQixFQUFDLFFBQVEsR0FBRSxHQUFVLE1BQWM7QUFDakUsT0FBSyxRQUFRLFNBQUc7QUFDZCxhQUFTLE9BQU8sS0FBSztBQUNuQixVQUFJLElBQUksR0FBRyxhQUFhLEdBQUc7QUFBTyxlQUFPLElBQUksR0FBRzs7R0FFbkQ7QUFDSDtTQUVnQixrQkFBa0IsR0FBWSxHQUFVO0FBQ3RELFNBQU8sRUFBRSxLQUFLLFVBQVUsRUFBRSxLQUFLO0FBQ2pDO1NBRWdCLGFBQWEsSUFBVyxZQUFvQixpQkFBaUNqQyxTQUFNO0FBQ2pHLFFBQU0sZUFBZSxHQUFHO0FBQ3hCLFFBQU0sUUFBUSxHQUFHLG1CQUFtQixhQUFhLEdBQUcsYUFBYSxZQUFZO0FBQzdFLFFBQU0sT0FBTyxlQUFlO0FBQzVCLFFBQU0sWUFBWSxNQUFNQSxPQUFNO0FBQzlCLFFBQU0sb0JBQW9CLE1BQU0sUUFBUSxLQUFLLEtBQUs7QUFDbEQsUUFBTSxZQUFZLElBQUksYUFBYTtBQUNuQyxXQUFTLE1BQUE7QUFDUCxRQUFJLFFBQVE7QUFDWixRQUFJLFlBQVk7QUFDaEIsUUFBSSxlQUFlLEdBQUc7QUFFcEIsTUFBQVIsTUFBSyxZQUFZLEVBQUUsUUFBUSxlQUFTO0FBQ2xDLG9CQUFZLGlCQUFpQixXQUFXLGFBQWEsU0FBUyxFQUFFLFNBQVMsYUFBYSxTQUFTLEVBQUUsT0FBTztPQUN6RztBQUNELCtCQUF5QixJQUFJLGVBQWU7QUFDNUNZLG1CQUFRLE9BQU8sTUFBTSxHQUFHLEdBQUcsU0FBUyxLQUFLLEtBQUssQ0FBQyxFQUFFLE1BQU0saUJBQWlCOztBQUV4RSw2QkFBdUIsSUFBSSxZQUFZLE9BQU8sZUFBZSxFQUFFLE1BQU0saUJBQWlCO0dBQ3pGO0FBQ0g7U0FJZ0IsdUJBQ2QsRUFBQyxRQUFRLEdBQUUsR0FDWCxZQUNBLE9BQ0EsaUJBQStCO0FBSS9CLFFBQU0sUUFBNEIsQ0FBQTtBQUNsQyxRQUFNLFdBQVcsR0FBRztBQUNwQixNQUFJLGVBQWUsR0FBRyxZQUFZLGtCQUFrQixJQUFJLEdBQUcsT0FBTyxlQUFlO0FBQ2pGLE1BQUksMkJBQTJCO0FBRS9CLFFBQU0sWUFBWSxTQUFTLE9BQU8sT0FBSyxFQUFFLEtBQUssV0FBVyxVQUFVO0FBQ25FLFlBQVUsUUFBUSxhQUFPO0FBQ3ZCLFVBQU0sS0FBSyxNQUFBO0FBQ1QsWUFBTSxZQUFZO0FBQ2xCLFlBQU0sWUFBWSxRQUFRLEtBQUs7QUFDL0IsaUNBQTJCLElBQUksV0FBVyxlQUFlO0FBQ3pELGlDQUEyQixJQUFJLFdBQVcsZUFBZTtBQUV6RCxxQkFBZSxHQUFHLFlBQVk7QUFFOUIsWUFBTSxPQUFPLGNBQWMsV0FBVyxTQUFTO0FBRS9DLFdBQUssSUFBSSxRQUFRLFdBQUs7QUFDcEIsb0JBQVksaUJBQWlCLE1BQU0sQ0FBQyxHQUFHLE1BQU0sQ0FBQyxFQUFFLFNBQVMsTUFBTSxDQUFDLEVBQUUsT0FBTztPQUMxRTtBQUVELFdBQUssT0FBTyxRQUFRLFlBQU07QUFDeEIsWUFBSSxPQUFPLFVBQVU7QUFDbkIsZ0JBQU0sSUFBSSxXQUFXLFFBQVEsMENBQTBDO2VBQ2xFO0FBQ0wsZ0JBQU0sUUFBUSxnQkFBZ0IsWUFBWSxPQUFPLElBQUk7QUFFckQsaUJBQU8sSUFBSSxRQUFRLFNBQU8sU0FBUyxPQUFPLEdBQUcsQ0FBQztBQUU5QyxpQkFBTyxPQUFPLFFBQVEsU0FBRztBQUN2QixrQkFBTSxZQUFZLElBQUksSUFBSTtBQUMxQixxQkFBUyxPQUFPLEdBQUc7V0FDcEI7QUFFRCxpQkFBTyxJQUFJLFFBQVEsYUFBVyxNQUFNLFlBQVksT0FBTyxDQUFDOztPQUUzRDtBQUVELFlBQU0saUJBQWlCLFFBQVEsS0FBSztBQUVwQyxVQUFJLGtCQUFrQixRQUFRLEtBQUssVUFBVSxZQUFZO0FBRXZELGlDQUF5QixJQUFJLGVBQWU7QUFDNUMsY0FBTSxrQkFBa0IsQ0FBQTtBQUV4QixtQ0FBMkI7QUFHM0IsWUFBSSxnQkFBZ0IsYUFBYSxTQUFTO0FBQzFDLGFBQUssSUFBSSxRQUFRLFdBQUs7QUFDcEIsd0JBQWMsS0FBSyxJQUFJLFVBQVUsS0FBSztTQUN2QztBQU1ELHdCQUFnQixJQUFJLENBQUMsR0FBRyxZQUFZLFNBQVMsQ0FBQztBQUM5QyxzQkFBYyxJQUFJLENBQUMsR0FBRyxZQUFZLFNBQVMsR0FBR1osTUFBSyxhQUFhLEdBQUcsYUFBYTtBQUNoRixjQUFNLFNBQVM7QUFHZixjQUFNLHdCQUF3QixnQkFBZ0IsY0FBYztBQUM1RCxZQUFJLHVCQUF1QjtBQUN6QixrQ0FBdUI7O0FBR3pCLFlBQUk7QUFDSixjQUFNLGtCQUFrQlksYUFBUSxPQUFPLE1BQUE7QUFFckMsd0JBQWMsZUFBZSxLQUFLO0FBQ2xDLGNBQUksYUFBYTtBQUNmLGdCQUFJLHVCQUF1QjtBQUV6QixrQkFBSSxjQUFjLHdCQUF3QixLQUFLLE1BQU0sSUFBSTtBQUN6RCwwQkFBWSxLQUFLLGFBQWEsV0FBVzs7O1NBRzlDO0FBQ0QsZUFBUSxlQUFlLE9BQU8sWUFBWSxTQUFTLGFBQ2pEQSxhQUFRLFFBQVEsV0FBVyxJQUFJLGdCQUFnQixLQUFLLE1BQUksV0FBVzs7S0FFeEU7QUFDRCxVQUFNLEtBQUssY0FBUTtBQUNqQixVQUFJLENBQUMsNEJBQTRCLENBQUMsMkJBQTJCO0FBQzNELGNBQU0sWUFBWSxRQUFRLEtBQUs7QUFFL0IsNEJBQW9CLFdBQVcsUUFBUTs7QUFHekMsc0JBQWdCLElBQUksQ0FBQyxHQUFHLFlBQVksU0FBUyxDQUFDO0FBQzlDLG9CQUFjLElBQUksQ0FBQyxHQUFHLFlBQVksU0FBUyxHQUFHLEdBQUcsYUFBYSxHQUFHLFNBQVM7QUFDMUUsWUFBTSxTQUFTLEdBQUc7S0FDbkI7R0FDRjtBQUdELFdBQVMsV0FBUTtBQUNmLFdBQU8sTUFBTSxTQUFTQSxhQUFRLFFBQVEsTUFBTSxNQUFLLEVBQUcsTUFBTSxRQUFRLENBQUMsRUFBRSxLQUFLLFFBQVEsSUFDaEZBLGFBQVEsUUFBTzs7QUFHbkIsU0FBTyxTQUFRLEVBQUcsS0FBSyxNQUFBO0FBQ3JCLHdCQUFvQixjQUFjLGVBQWU7R0FDbEQ7QUFDSDtTQWdCZ0IsY0FBYyxXQUFxQixXQUFtQjtBQUNwRSxRQUFNLE9BQW1CO0lBQ3ZCLEtBQUssQ0FBQTtJQUNMLEtBQUssQ0FBQTtJQUNMLFFBQVEsQ0FBQTs7QUFFVixNQUFJO0FBQ0osT0FBSyxTQUFTLFdBQVc7QUFDdkIsUUFBSSxDQUFDLFVBQVUsS0FBSztBQUFHLFdBQUssSUFBSSxLQUFLLEtBQUs7O0FBRTVDLE9BQUssU0FBUyxXQUFXO0FBQ3ZCLFVBQU0sU0FBUyxVQUFVLEtBQUssR0FDNUIsU0FBUyxVQUFVLEtBQUs7QUFDMUIsUUFBSSxDQUFDLFFBQVE7QUFDWCxXQUFLLElBQUksS0FBSyxDQUFDLE9BQU8sTUFBTSxDQUFDO1dBQ3hCO0FBQ0wsWUFBTSxTQUFTO1FBQ2IsTUFBTTtRQUNOLEtBQUs7UUFDTCxVQUFVO1FBQ1YsS0FBSyxDQUFBO1FBQ0wsS0FBSyxDQUFBO1FBQ0wsUUFBUSxDQUFBOztBQUVWLFVBSU0sTUFBSSxPQUFPLFFBQVEsV0FBUyxRQUU1QixNQUFJLE9BQU8sUUFBUSxXQUFTLE9BRzdCLE9BQU8sUUFBUSxTQUFTLE9BQU8sUUFBUSxRQUFRLENBQUMsWUFDckQ7QUFFRSxlQUFPLFdBQVc7QUFDbEIsYUFBSyxPQUFPLEtBQUssTUFBTTthQUNsQjtBQUVMLGNBQU0sYUFBYSxPQUFPO0FBQzFCLGNBQU0sYUFBYSxPQUFPO0FBQzFCLFlBQUk7QUFDSixhQUFLLFdBQVcsWUFBWTtBQUMxQixjQUFJLENBQUMsV0FBVyxPQUFPO0FBQUcsbUJBQU8sSUFBSSxLQUFLLE9BQU87O0FBRW5ELGFBQUssV0FBVyxZQUFZO0FBQzFCLGdCQUFNLFNBQVMsV0FBVyxPQUFPLEdBQy9CLFNBQVMsV0FBVyxPQUFPO0FBQzdCLGNBQUksQ0FBQztBQUFRLG1CQUFPLElBQUksS0FBSyxNQUFNO21CQUMxQixPQUFPLFFBQVEsT0FBTztBQUFLLG1CQUFPLE9BQU8sS0FBSyxNQUFNOztBQUUvRCxZQUFJLE9BQU8sSUFBSSxTQUFTLEtBQUssT0FBTyxJQUFJLFNBQVMsS0FBSyxPQUFPLE9BQU8sU0FBUyxHQUFHO0FBQzlFLGVBQUssT0FBTyxLQUFLLE1BQU07Ozs7O0FBSy9CLFNBQU87QUFDVDtTQUVnQixZQUNkLFVBQ0EsV0FDQSxTQUNBLFNBQW9CO0FBRXBCLFFBQU0sUUFBUSxTQUFTLEdBQUcsa0JBQ3hCLFdBQ0EsUUFBUSxVQUNOLEVBQUUsU0FBUyxRQUFRLFNBQVMsZUFBZSxRQUFRLEtBQUksSUFDdkQsRUFBRSxlQUFlLFFBQVEsS0FBSSxDQUFFO0FBRW5DLFVBQVEsUUFBUSxTQUFPLFNBQVMsT0FBTyxHQUFHLENBQUM7QUFDM0MsU0FBTztBQUNUO1NBRWdCLG9CQUFvQixXQUFxQixVQUF3QjtBQUMvRSxFQUFBWixNQUFLLFNBQVMsRUFBRSxRQUFRLGVBQVM7QUFDL0IsUUFBSSxDQUFDLFNBQVMsR0FBRyxpQkFBaUIsU0FBUyxTQUFTLEdBQUc7QUFDckQsa0JBQVksVUFBVSxXQUFXLFVBQVUsU0FBUyxFQUFFLFNBQVMsVUFBVSxTQUFTLEVBQUUsT0FBTzs7R0FFOUY7QUFDSDtTQUVnQixvQkFBb0IsV0FBcUIsVUFBd0I7QUFDL0UsR0FBQSxFQUFHLE1BQU0sS0FBSyxTQUFTLEdBQUcsZ0JBQWdCLEVBQUUsUUFBUSxlQUNsRCxVQUFVLFNBQVMsS0FBSyxRQUFRLFNBQVMsR0FBRyxrQkFBa0IsU0FBUyxDQUFDO0FBQzVFO1NBRWdCLFNBQVMsT0FBdUIsS0FBYztBQUM1RCxRQUFNLFlBQVksSUFBSSxNQUFNLElBQUksU0FBUyxFQUFFLFFBQVEsSUFBSSxRQUFRLFlBQVksSUFBSSxNQUFLLENBQUU7QUFDeEY7QUFFQSxTQUFTLGtCQUNQLElBQ0EsT0FDQSxVQUF3QjtBQUV4QixRQUFNLGVBQWUsQ0FBQTtBQUNyQixRQUFNLGVBQWUsTUFBTSxNQUFNLGtCQUFrQixDQUFDO0FBQ3BELGVBQWEsUUFBUSxlQUFTO0FBQzVCLFVBQU0sUUFBUSxTQUFTLFlBQVksU0FBUztBQUM1QyxRQUFJLFVBQVUsTUFBTTtBQUNwQixVQUFNLFVBQVUsZ0JBQ2QsZ0JBQWdCLE9BQU8sR0FDdkIsV0FBVyxJQUNYLE9BQ0EsT0FDQSxDQUFDLENBQUMsTUFBTSxlQUNSLFdBQVcsT0FBTyxZQUFZLFVBQzlCLElBQUk7QUFFTixVQUFNLFVBQXVCLENBQUE7QUFDN0IsYUFBUyxJQUFJLEdBQUcsSUFBSSxNQUFNLFdBQVcsUUFBUSxFQUFFLEdBQUc7QUFDaEQsWUFBTSxXQUFXLE1BQU0sTUFBTSxNQUFNLFdBQVcsQ0FBQyxDQUFDO0FBQ2hELGdCQUFVLFNBQVM7QUFDbkIsVUFBSSxRQUFRLGdCQUNWLFNBQVMsTUFDVCxTQUNBLENBQUMsQ0FBQyxTQUFTLFFBQ1gsQ0FBQyxDQUFDLFNBQVMsWUFDWCxPQUNBLFdBQVcsT0FBTyxZQUFZLFVBQzlCLEtBQUs7QUFFUCxjQUFRLEtBQUssS0FBSzs7QUFFcEIsaUJBQWEsU0FBUyxJQUFJLGtCQUFrQixXQUFXLFNBQVMsT0FBTztHQUN4RTtBQUNELFNBQU87QUFDVDtTQUVnQixpQkFBaUIsRUFBQyxRQUFRLEdBQUUsR0FBVSxPQUFvQixVQUF3QjtBQUNoRyxLQUFHLFFBQVEsTUFBTSxVQUFVO0FBQzNCLFFBQU0sZUFBZSxHQUFHLFlBQVksa0JBQWtCLElBQUksT0FBTyxRQUFRO0FBQ3pFLEtBQUcsY0FBYyxNQUFNLE1BQU0sa0JBQWtCLENBQUM7QUFDaEQsZ0JBQWMsSUFBSSxDQUFDLEdBQUcsVUFBVSxHQUFHQSxNQUFLLFlBQVksR0FBRyxZQUFZO0FBQ3JFO1NBRWdCLHNCQUFzQixJQUFXLFVBQXdCO0FBQ3ZFLFFBQU0sa0JBQWtCLGtCQUFrQixJQUFJLEdBQUcsT0FBTyxRQUFRO0FBQ2hFLFFBQU0sT0FBTyxjQUFjLGlCQUFpQixHQUFHLFNBQVM7QUFDeEQsU0FBTyxFQUFFLEtBQUssSUFBSSxVQUFVLEtBQUssT0FBTyxLQUFLLFFBQU0sR0FBRyxJQUFJLFVBQVUsR0FBRyxPQUFPLE1BQU07QUFDdEY7U0FFZ0IsMkJBQTJCLEVBQUMsUUFBUSxHQUFFLEdBQVUsUUFBa0IsVUFBd0I7QUFFeEcsUUFBTSxhQUFhLFNBQVMsR0FBRztBQUUvQixXQUFTLElBQUksR0FBRyxJQUFJLFdBQVcsUUFBUSxFQUFFLEdBQUc7QUFDMUMsVUFBTSxZQUFZLFdBQVcsQ0FBQztBQUM5QixVQUFNLFFBQVEsU0FBUyxZQUFZLFNBQVM7QUFDNUMsT0FBRyxhQUFhLFlBQVk7QUFFNUIsYUFBUyxJQUFJLEdBQUcsSUFBSSxNQUFNLFdBQVcsUUFBUSxFQUFFLEdBQUc7QUFDaEQsWUFBTSxZQUFZLE1BQU0sV0FBVyxDQUFDO0FBQ3BDLFlBQU0sVUFBVSxNQUFNLE1BQU0sU0FBUyxFQUFFO0FBQ3ZDLFlBQU0sWUFBWSxPQUFPLFlBQVksV0FBVyxVQUFVLE1BQU0sTUFBTSxPQUFPLEVBQUUsS0FBSyxHQUFHLElBQUk7QUFDM0YsVUFBSSxPQUFPLFNBQVMsR0FBRztBQUNyQixjQUFNLFlBQVksT0FBTyxTQUFTLEVBQUUsVUFBVSxTQUFTO0FBQ3ZELFlBQUksV0FBVztBQUNiLG9CQUFVLE9BQU87QUFDakIsaUJBQU8sT0FBTyxTQUFTLEVBQUUsVUFBVSxTQUFTO0FBQzVDLGlCQUFPLFNBQVMsRUFBRSxVQUFVLFNBQVMsSUFBSTs7Ozs7QUFPakQsTUFBSSxPQUFPLGNBQWMsZUFBZSxTQUFTLEtBQUssVUFBVSxTQUFTLEtBQ3ZFLENBQUMsb0JBQW9CLEtBQUssVUFBVSxTQUFTLEtBQzdDLFFBQVEscUJBQXFCLG1CQUFtQixRQUFRLHFCQUN4RCxDQUFBLEVBQUcsT0FBTyxVQUFVLFVBQVUsTUFBTSxlQUFlLENBQUMsRUFBRSxDQUFDLElBQUksS0FDN0Q7QUFDRSxPQUFHLGFBQWE7O0FBRXBCO1NBRWdCLGlCQUFpQixtQkFBeUI7QUFDeEQsU0FBTyxrQkFBa0IsTUFBTSxHQUFHLEVBQUUsSUFBSSxDQUFDLE9BQU8sYUFBUTtBQUN0RCxZQUFRLE1BQU0sS0FBSTtBQUNsQixVQUFNLE9BQU8sTUFBTSxRQUFRLGdCQUFnQixFQUFFO0FBRTdDLFVBQU0sVUFBVSxNQUFNLEtBQUssSUFBSSxJQUFJLEtBQUssTUFBTSxZQUFZLEVBQUUsQ0FBQyxFQUFFLE1BQU0sR0FBRyxJQUFJO0FBRTVFLFdBQU8sZ0JBQ0wsTUFDQSxXQUFXLE1BQ1gsS0FBSyxLQUFLLEtBQUssR0FDZixLQUFLLEtBQUssS0FBSyxHQUNmLE9BQU8sS0FBSyxLQUFLLEdBQ2pCQyxTQUFRLE9BQU8sR0FDZixhQUFhLENBQUM7R0FFakI7QUFDSDtJQ3ZZYSxnQkFBTztFQVVsQixpQkFBaUIsUUFBZ0QsV0FBbUI7QUFDbEYsSUFBQUQsTUFBSyxNQUFNLEVBQUUsUUFBUSxlQUFTO0FBQzVCLFVBQUksT0FBTyxTQUFTLE1BQU0sTUFBTTtBQUM1QixZQUFJLFVBQVUsaUJBQWlCLE9BQU8sU0FBUyxDQUFDO0FBQ2hELFlBQUksVUFBVSxRQUFRLE1BQUs7QUFDM0IsWUFBSSxRQUFRO0FBQU8sZ0JBQU0sSUFBSSxXQUFXLE9BQU8sb0NBQW9DO0FBQ25GLGdCQUFRLFFBQVEsU0FBRztBQUNmLGNBQUksSUFBSTtBQUFNLGtCQUFNLElBQUksV0FBVyxPQUFPLHNEQUFzRDtBQUNoRyxjQUFJLENBQUMsSUFBSTtBQUFTLGtCQUFNLElBQUksV0FBVyxPQUFPLHNEQUFzRDtTQUN2RztBQUNELGtCQUFVLFNBQVMsSUFBSSxrQkFBa0IsV0FBVyxTQUFTLE9BQU87O0tBRXpFOztFQUdILE9BQU8sUUFBeUM7QUFDOUMsVUFBTSxLQUFLLEtBQUs7QUFDaEIsU0FBSyxLQUFLLGVBQWUsS0FBSyxLQUFLLGVBQ2pDLE9BQU8sS0FBSyxLQUFLLGNBQWMsTUFBTSxJQUNyQztBQUNGLFVBQU0sV0FBVyxHQUFHO0FBR3BCLFVBQU0sYUFBeUMsQ0FBQTtBQUMvQyxRQUFJLFdBQVcsQ0FBQTtBQUNmLGFBQVMsUUFBUSxhQUFPO0FBQ3RCLGFBQU8sWUFBWSxRQUFRLEtBQUssWUFBWTtBQUM1QyxpQkFBWSxRQUFRLEtBQUssV0FBVyxDQUFBO0FBQ3BDLGNBQVEsaUJBQWlCLFlBQVksUUFBUTtLQUM5QztBQUVELE9BQUcsWUFBWTtBQUVmLG9CQUFnQixJQUFJLENBQUMsR0FBRyxZQUFZLElBQUksR0FBRyxZQUFZLFNBQVMsQ0FBQztBQUNqRSxrQkFBYyxJQUFJLENBQUMsR0FBRyxZQUFZLElBQUksR0FBRyxZQUFZLFdBQVcsS0FBSyxLQUFLLE1BQU0sR0FBR0EsTUFBSyxRQUFRLEdBQUcsUUFBUTtBQUMzRyxPQUFHLGNBQWNBLE1BQUssUUFBUTtBQUM5QixXQUFPOztFQUdULFFBQVEsaUJBQWdFO0FBQ3RFLFNBQUssS0FBSyxpQkFBaUIsZ0JBQWdCLEtBQUssS0FBSyxrQkFBa0JNLE1BQUssZUFBZTtBQUMzRixXQUFPOzs7U0NsREsseUJBQXlCLElBQVM7QUFDaEQsU0FBTyxxQkFDTCxRQUFRLFdBRVIsU0FBU29DLFNBQXVCLGVBQXFCO0FBQ25ELFNBQUssS0FBSztBQUNWLFNBQUssT0FBTztNQUNWLFNBQVM7TUFDVCxjQUFjO01BQ2QsVUFBVSxDQUFBO01BQ1YsUUFBUSxDQUFBO01BQ1IsZ0JBQWdCOztHQUVuQjtBQUVMO0FDdEJBLFNBQVMsZ0JBQWdCZixZQUF1QmMsY0FBMkI7QUFDekUsTUFBSSxZQUFZZCxXQUFVLFlBQVk7QUFDdEMsTUFBSSxDQUFDLFdBQVc7QUFDZCxnQkFBWUEsV0FBVSxZQUFZLElBQUksSUFBSWdCLFFBQU0sWUFBWTtNQUMxRCxRQUFRLENBQUE7TUFDUixXQUFBaEI7TUFDQSxhQUFBYztLQUNEO0FBQ0QsY0FBVSxRQUFRLENBQUMsRUFBRSxPQUFPLEVBQUUsU0FBUyxPQUFNLENBQUU7O0FBRWpELFNBQU8sVUFBVSxNQUFNLFNBQVM7QUFDbEM7QUFFQSxTQUFTLG1CQUFtQmQsWUFBcUI7QUFDL0MsU0FBT0EsY0FBYSxPQUFPQSxXQUFVLGNBQWM7QUFDckQ7U0FFZ0IsaUJBQWlCLEVBQy9CLFdBQUFBLFlBQ0EsYUFBQWMsYUFBVyxHQUNVO0FBQ3JCLFNBQU8sbUJBQW1CZCxVQUFTLElBQy9CLFFBQVEsUUFBUUEsV0FBVSxVQUFTLENBQUUsRUFBRSxLQUFLLENBQUMsVUFDM0MsTUFFRyxJQUFJLENBQUMsU0FBUyxLQUFLLElBQUksRUFFdkIsT0FBTyxDQUFDLFNBQVMsU0FBUyxVQUFVLENBQUMsSUFFMUMsZ0JBQWdCQSxZQUFXYyxZQUFXLEVBQUUsYUFBWSxFQUFHLFlBQVc7QUFDeEU7U0FFZ0IsbUJBQ2QsRUFBRSxXQUFBZCxZQUFXLGFBQUFjLGFBQVcsR0FDeEIsTUFBWTtBQUVaLEdBQUMsbUJBQW1CZCxVQUFTLEtBQzNCLFNBQVMsY0FDVCxnQkFBZ0JBLFlBQVdjLFlBQVcsRUFBRSxJQUFJLEVBQUMsS0FBSSxDQUFDLEVBQUUsTUFBTW5DLElBQUc7QUFDakU7U0FFZ0IsbUJBQ2QsRUFBRSxXQUFBcUIsWUFBVyxhQUFBYyxhQUFXLEdBQ3hCLE1BQVk7QUFFWixHQUFDLG1CQUFtQmQsVUFBUyxLQUMzQixTQUFTLGNBQ1QsZ0JBQWdCQSxZQUFXYyxZQUFXLEVBQUUsT0FBTyxJQUFJLEVBQUUsTUFBTW5DLElBQUc7QUFDbEU7U0NyRGdCLElBQUssSUFBRTtBQVNyQixTQUFPLFNBQVMsV0FBQTtBQUNkLFFBQUksYUFBYTtBQUNqQixXQUFPLEdBQUU7R0FDVjtBQUNIO0FDVkEsU0FBUyxXQUFXO0FBQ2hCLE1BQUksV0FBVyxDQUFDLFVBQVUsaUJBQ3RCLFdBQVcsS0FBSyxVQUFVLFNBQVMsS0FDbkMsQ0FBQyxpQkFBaUIsS0FBSyxVQUFVLFNBQVM7QUFFOUMsTUFBSSxDQUFDLFlBQVksQ0FBQyxVQUFVO0FBQ3hCLFdBQU8sUUFBUSxRQUFPO0FBQzFCLE1BQUk7QUFDSixTQUFPLElBQUksUUFBUSxTQUFVQyxVQUFTO0FBQ2xDLFFBQUksU0FBUyxXQUFZO0FBQUUsYUFBTyxVQUFVLFVBQVMsRUFBRyxRQUFRQSxRQUFPO0lBQUU7QUFDekUsaUJBQWEsWUFBWSxRQUFRLEdBQUc7QUFDcEMsV0FBTTtFQUNkLENBQUssRUFBRSxRQUFRLFdBQVk7QUFBRSxXQUFPLGNBQWMsVUFBVTtFQUFFLENBQUU7QUFDaEU7U0NIZ0IsVUFBVyxJQUFTO0FBQ2xDLFFBQU0sUUFBUSxHQUFHO0FBQ2pCLFFBQU0sRUFBQyxXQUFBb0IsV0FBUyxJQUFJLEdBQUc7QUFDdkIsTUFBSSxNQUFNLGlCQUFpQixHQUFHO0FBQzFCLFdBQU8sTUFBTSxlQUFlLEtBQVksTUFBTSxNQUFNLGNBQ2xELFVBQVcsTUFBTSxXQUFXLElBQzVCLEVBQUU7QUFDUmlCLFlBQWdCLE1BQU0sY0FBYyxlQUFlQyxrQkFBdUI7QUFDMUUsUUFBTSxnQkFBZ0I7QUFDdEIsUUFBTSxjQUFjO0FBQ3BCLFFBQU0sZUFBZTtBQUNyQixRQUFNLGdCQUFnQixNQUFNO0FBRTVCLFdBQVMsbUJBQWdCO0FBR3ZCLFFBQUksTUFBTSxrQkFBa0I7QUFBZSxZQUFNLElBQUksV0FBVyxlQUFlLHlCQUF5Qjs7QUFJMUcsTUFBSSxpQkFBaUIsTUFBTSxnQkFFdkIscUJBQThDLE1BQzlDLGFBQWE7QUFFakIsUUFBTSxZQUFZLE1BQU0sSUFBSWpDLGFBQVEsQ0FBQ0wsVUFBU0MsWUFBTTtBQU1sRCxxQkFBZ0I7QUFFaEIsUUFBSSxDQUFDbUI7QUFBVyxZQUFNLElBQUksV0FBVyxXQUFVO0FBQy9DLFVBQU0sU0FBUyxHQUFHO0FBRWxCLFVBQU0sTUFBTSxNQUFNLGFBQ2hCQSxXQUFVLEtBQUssTUFBTSxJQUNyQkEsV0FBVSxLQUFLLFFBQVEsS0FBSyxNQUFNLEdBQUcsUUFBUSxFQUFFLENBQUM7QUFDbEQsUUFBSSxDQUFDO0FBQUssWUFBTSxJQUFJLFdBQVcsV0FBVTtBQUN6QyxRQUFJLFVBQVUsbUJBQW1CbkIsT0FBTTtBQUN2QyxRQUFJLFlBQVksS0FBSyxHQUFHLGNBQWM7QUFDdEMsUUFBSSxrQkFBa0IsS0FBTSxPQUFDO0FBQ3pCLDJCQUFxQixJQUFJO0FBQ3pCLFVBQUksTUFBTSxjQUFjLENBQUMsR0FBRyxTQUFTLGNBQWM7QUFJL0MsWUFBSSxVQUFVO0FBQ2QsMkJBQW1CLE1BQUs7QUFFeEIsWUFBSSxPQUFPLE1BQUs7QUFDaEIsY0FBTSxTQUFTbUIsV0FBVSxlQUFlLE1BQU07QUFDOUMsZUFBTyxZQUFZLE9BQU8sVUFBVSxLQUFLLE1BQUE7QUFDckMsVUFBQW5CLFFBQVEsSUFBSSxXQUFXLGVBQWUsWUFBWSxxQkFBcUIsQ0FBQztTQUMzRTthQUNFO0FBQ0gsMkJBQW1CLFVBQVUsbUJBQW1CQSxPQUFNO0FBQ3RELFlBQUksU0FBUyxFQUFFLGFBQWEsS0FBSyxJQUFJLEdBQUcsRUFBRSxJQUFJLElBQUksRUFBRTtBQUNwRCxxQkFBYSxTQUFTO0FBQ3RCLFdBQUcsT0FBTyxRQUFRLElBQUk7QUFDdEIscUJBQWEsSUFBSSxTQUFTLElBQUksb0JBQW9CQSxPQUFNOztPQUU3REEsT0FBTTtBQUVULFFBQUksWUFBWSxLQUFNLE1BQUE7QUFFbEIsMkJBQXFCO0FBQ3JCLFlBQU0sUUFBUSxHQUFHLE9BQU8sUUFBUSxJQUFJO0FBRXBDLFlBQU0sbUJBQW1CLE1BQU0sTUFBTSxnQkFBZ0I7QUFDckQsVUFBSSxpQkFBaUIsU0FBUztBQUFHLFlBQUk7QUFDbkMsZ0JBQU0sV0FBVyxNQUFNLFlBQVksb0JBQW9CLGdCQUFnQixHQUFHLFVBQVU7QUFDcEYsY0FBSSxNQUFNO0FBQVksNkJBQWlCLElBQUksT0FBTyxRQUFRO2VBQ3JEO0FBQ0QsdUNBQTJCLElBQUksR0FBRyxXQUFXLFFBQVE7QUFDckQsZ0JBQUksQ0FBQyxzQkFBc0IsSUFBSSxRQUFRLEdBQUc7QUFDdEMsc0JBQVEsS0FBSyxvSEFBb0g7OztBQUd6SSxtQ0FBeUIsSUFBSSxRQUFRO2lCQUM5QixHQUFQOztBQVNGLGtCQUFZLEtBQUssRUFBRTtBQUVuQixZQUFNLGtCQUFrQixLQUFLLFFBQUU7QUFDM0IsY0FBTSxVQUFVO0FBQ2hCLFdBQUcsR0FBRyxlQUFlLEVBQUUsS0FBSyxFQUFFO09BQ2pDO0FBRUQsWUFBTSxVQUFVLEtBQUssUUFBRTtBQUNuQixXQUFHLEdBQUcsT0FBTyxFQUFFLEtBQUssRUFBRTtPQUN6QjtBQUVELFVBQUk7QUFBWSwyQkFBbUIsR0FBRyxPQUFPLE1BQU07QUFFbkQsTUFBQUQsU0FBTztPQUVSQyxPQUFNO0dBQ1YsRUFBRSxNQUFNLFNBQUc7QUFDVixRQUFJLE9BQU8sSUFBSSxTQUFTLGtCQUFrQixNQUFNLGlCQUFpQixHQUFHO0FBR2xFLFlBQU07QUFDTixjQUFRLEtBQUsscURBQXFEO0FBQ2xFLGFBQU8sVUFBUztXQUNYO0FBQ0wsYUFBT0ksYUFBUSxPQUFPLEdBQUc7O0dBRTVCO0FBR0QsU0FBT0EsYUFBUSxLQUFLO0lBQ2xCO0tBQ0MsT0FBTyxjQUFjLGNBQWNBLGFBQVEsUUFBTyxJQUFLa0MsU0FBa0IsR0FBSSxLQUFLLFNBQVM7R0FDN0YsRUFBRSxLQUFLLE1BQUE7QUFLSixxQkFBZ0I7QUFDaEIsVUFBTSxvQkFBb0IsQ0FBQTtBQUMxQixXQUFPbEMsYUFBUSxRQUFRLElBQUksTUFBSSxHQUFHLEdBQUcsTUFBTSxLQUFLLEdBQUcsR0FBRyxDQUFDLENBQUMsRUFBRSxLQUFLLFNBQVMsaUJBQWM7QUFDbEYsVUFBSSxNQUFNLGtCQUFrQixTQUFTLEdBQUc7QUFFcEMsWUFBSSxhQUFhLE1BQU0sa0JBQWtCLE9BQU8saUJBQWlCTixJQUFHO0FBQ3BFLGNBQU0sb0JBQW9CLENBQUE7QUFDMUIsZUFBT00sYUFBUSxRQUFRLElBQUksTUFBSSxXQUFXLEdBQUcsR0FBRyxDQUFDLENBQUMsRUFBRSxLQUFLLGNBQWM7O0tBRTlFO0dBQ0osRUFBRSxRQUFRLE1BQUE7QUFDUCxVQUFNLG9CQUFvQjtBQUMxQixVQUFNLGdCQUFnQjtHQUN6QixFQUFFLEtBQUssTUFBQTtBQUVKLFdBQU87R0FDVixFQUFFLE1BQU0sU0FBRztBQUNSLFVBQU0sY0FBYztBQUNwQixRQUFJO0FBRUYsNEJBQXNCLG1CQUFtQixNQUFLO2FBQzlDLElBQUE7SUFBTTtBQUNSLFFBQUksa0JBQWtCLE1BQU0sZUFBZTtBQUd6QyxTQUFHLE9BQU07O0FBRVgsV0FBTyxVQUFXLEdBQUc7R0FDeEIsRUFBRSxRQUFRLE1BQUE7QUFDUCxVQUFNLGVBQWU7QUFDckIsbUJBQWM7R0FDakI7QUFDSDtTQzdLZ0IsY0FBZSxVQUF1QjtBQUNwRCxNQUFJLFdBQVcsWUFBVSxTQUFTLEtBQUssTUFBTSxHQUN6QyxVQUFVLFdBQVMsU0FBUyxNQUFNLEtBQUssR0FDdkMsWUFBWSxLQUFLLFFBQVEsR0FDekIsVUFBVSxLQUFLLE9BQU87QUFFMUIsV0FBUyxLQUFLLFNBQW1CO0FBQzdCLFdBQU8sQ0FBQyxRQUFJO0FBQ1IsVUFBSSxPQUFPLFFBQVEsR0FBRyxHQUNsQixRQUFRLEtBQUs7QUFFakIsYUFBTyxLQUFLLE9BQU8sUUFDZCxDQUFDLFNBQVMsT0FBTyxNQUFNLFNBQVMsYUFDN0JYLFNBQVEsS0FBSyxJQUFJLFFBQVEsSUFBSSxLQUFLLEVBQUUsS0FBSyxXQUFXLE9BQU8sSUFBSSxVQUFVLEtBQUssSUFDOUUsTUFBTSxLQUFLLFdBQVcsT0FBTzs7O0FBSTdDLFNBQU8sS0FBSyxRQUFRLEVBQUM7QUFDdkI7U0NQZ0IsdUJBQXVCLE1BQXVCLGFBQWEsV0FBUztBQUVsRixNQUFJLElBQUksVUFBVTtBQUNsQixNQUFJLElBQUk7QUFBRyxVQUFNLElBQUksV0FBVyxnQkFBZ0IsbUJBQW1CO0FBR25FLE1BQUlDLFFBQU8sSUFBSSxNQUFNLElBQUksQ0FBQztBQUMxQixTQUFPLEVBQUU7QUFBRyxJQUFBQSxNQUFLLElBQUksQ0FBQyxJQUFJLFVBQVUsQ0FBQztBQUVyQyxjQUFZQSxNQUFLLElBQUc7QUFDcEIsTUFBSSxTQUFTLFFBQVFBLEtBQUk7QUFDekIsU0FBTyxDQUFDLE1BQU0sUUFBUSxTQUFTO0FBQ2pDO1NBRWdCLHNCQUNkLElBQ0EsTUFDQSxZQUNBLG1CQUNBLFdBQXFDO0FBRXJDLFNBQU9VLGFBQVEsUUFBTyxFQUFHLEtBQUssTUFBQTtBQUU1QixVQUFNLFlBQVksSUFBSSxhQUFhO0FBR25DLFVBQU0sUUFBUSxHQUFHLG1CQUFtQixNQUFNLFlBQVksR0FBRyxXQUFXLGlCQUFpQjtBQUVyRixVQUFNLFlBQVk7TUFDaEI7TUFDQTs7QUFHRixRQUFJLG1CQUFtQjtBQUVyQixZQUFNLFdBQVcsa0JBQWtCO1dBQzlCO0FBQ0wsVUFBSTtBQUNGLGNBQU0sT0FBTTtBQUNaLFdBQUcsT0FBTyxpQkFBaUI7ZUFDcEIsSUFBUDtBQUNBLFlBQUksR0FBRyxTQUFTLFNBQVMsZ0JBQWdCLEdBQUcsT0FBTSxLQUFNLEVBQUUsR0FBRyxPQUFPLGlCQUFpQixHQUFHO0FBQ3RGLGtCQUFRLEtBQUssMEJBQTBCO0FBQ3ZDLGFBQUcsT0FBTTtBQUNULGlCQUFPLEdBQUcsS0FBSSxFQUFHLEtBQUssTUFBTSxzQkFDMUIsSUFDQSxNQUNBLFlBQ0EsTUFDQSxTQUFTLENBQ1Y7O0FBRUgsZUFBTyxVQUFVLEVBQUU7OztBQUt2QixVQUFNLG1CQUFtQixnQkFBZ0IsU0FBUztBQUNsRCxRQUFJLGtCQUFrQjtBQUNwQiw4QkFBdUI7O0FBR3pCLFFBQUk7QUFDSixVQUFNLGtCQUFrQkEsYUFBUSxPQUFPLE1BQUE7QUFFckMsb0JBQWMsVUFBVSxLQUFLLE9BQU8sS0FBSztBQUN6QyxVQUFJLGFBQWE7QUFDZixZQUFJLGtCQUFrQjtBQUVwQixjQUFJLGNBQWMsd0JBQXdCLEtBQUssTUFBTSxJQUFJO0FBQ3pELHNCQUFZLEtBQUssYUFBYSxXQUFXO21CQUNoQyxPQUFPLFlBQVksU0FBUyxjQUFjLE9BQU8sWUFBWSxVQUFVLFlBQVk7QUFFNUYsd0JBQWMsY0FBYyxXQUFXOzs7T0FHMUMsU0FBUztBQUNaLFlBQVEsZUFBZSxPQUFPLFlBQVksU0FBUyxhQUVqREEsYUFBUSxRQUFRLFdBQVcsRUFBRSxLQUFLLE9BQUssTUFBTSxTQUMzQyxJQUNFLFVBQVUsSUFBSSxXQUFXLGdCQUN6Qiw0REFBNEQsQ0FBQyxDQUFDLElBRWhFLGdCQUFnQixLQUFLLE1BQU0sV0FBVyxHQUN4QyxLQUFLLE9BQUM7QUFFTixVQUFJO0FBQW1CLGNBQU0sU0FBUTtBQUdyQyxhQUFPLE1BQU0sWUFBWSxLQUFLLE1BQU0sQ0FBQztLQUN0QyxFQUFFLE1BQU0sT0FBQztBQUNSLFlBQU0sUUFBUSxDQUFDO0FBQ2YsYUFBTyxVQUFVLENBQUM7S0FDbkI7R0FDRjtBQUNIO1NDN0VnQixJQUFLLEdBQWdCLE9BQVlJLFFBQWE7QUFDNUQsUUFBTSxTQUFTZixTQUFRLENBQUMsSUFBSSxFQUFFLE1BQUssSUFBSyxDQUFDLENBQUM7QUFDMUMsV0FBUyxJQUFFLEdBQUcsSUFBRWUsUUFBTyxFQUFFO0FBQUcsV0FBTyxLQUFLLEtBQUs7QUFDN0MsU0FBTztBQUNUO1NBR2dCLDZCQUE4QixNQUFZO0FBQ3hELFNBQU87SUFDTCxHQUFHO0lBQ0gsTUFBTSxXQUFpQjtBQUNyQixZQUFNLFFBQVEsS0FBSyxNQUFNLFNBQVM7QUFDbEMsWUFBTSxFQUFDLE9BQU0sSUFBSTtBQUNqQixZQUFNLGNBQXNELENBQUE7QUFDNUQsWUFBTSxvQkFBb0MsQ0FBQTtBQUUxQyxlQUFTLGtCQUFtQixTQUFtQyxTQUFpQixlQUEwQjtBQUN4RyxjQUFNLGVBQWUsZ0JBQWdCLE9BQU87QUFDNUMsY0FBTSxZQUFhLFlBQVksWUFBWSxJQUFJLFlBQVksWUFBWSxLQUFLLENBQUE7QUFDNUUsY0FBTSxZQUFZLFdBQVcsT0FBTyxJQUFHLE9BQU8sWUFBWSxXQUFXLElBQUksUUFBUTtBQUNqRixjQUFNLFlBQVksVUFBVTtBQUM1QixjQUFNLGVBQWU7VUFDbkIsR0FBRztVQUNIO1VBQ0E7VUFDQTtVQUNBLFlBQVksZ0JBQWdCLE9BQU87VUFDbkMsUUFBUSxDQUFDLGFBQWEsY0FBYzs7QUFFdEMsa0JBQVUsS0FBSyxZQUFZO0FBQzNCLFlBQUksQ0FBQyxhQUFhLGNBQWM7QUFDOUIsNEJBQWtCLEtBQUssWUFBWTs7QUFFckMsWUFBSSxZQUFZLEdBQUc7QUFDakIsZ0JBQU0saUJBQWlCLGNBQWMsSUFDbkMsUUFBUSxDQUFDLElBQ1QsUUFBUSxNQUFNLEdBQUcsWUFBWSxDQUFDO0FBQ2hDLDRCQUFrQixnQkFBZ0IsVUFBVSxHQUFHLGFBQWE7O0FBRTlELGtCQUFVLEtBQUssQ0FBQyxHQUFFLE1BQU0sRUFBRSxVQUFVLEVBQUUsT0FBTztBQUM3QyxlQUFPOztBQUdULFlBQU0sYUFBYSxrQkFBa0IsT0FBTyxXQUFXLFNBQVMsR0FBRyxPQUFPLFVBQVU7QUFDcEYsa0JBQVksS0FBSyxJQUFJLENBQUMsVUFBVTtBQUNoQyxpQkFBVyxTQUFTLE9BQU8sU0FBUztBQUNsQywwQkFBa0IsTUFBTSxTQUFTLEdBQUcsS0FBSzs7QUFHM0MsZUFBUyxjQUFjLFNBQWlDO0FBQ3RELGNBQU1rQixVQUFTLFlBQVksZ0JBQWdCLE9BQU8sQ0FBQztBQUNuRCxlQUFPQSxXQUFVQSxRQUFPLENBQUM7O0FBRzNCLGVBQVMsZUFBZ0IsT0FBdUIsU0FBZTtBQUM3RCxlQUFPO1VBQ0wsTUFBTSxNQUFNLFNBQUksUUFFZCxNQUFNO1VBQ1IsT0FBTyxJQUFJLE1BQU0sT0FBTyxNQUFNLFlBQVksS0FBSyxVQUFVLEtBQUssU0FBUyxPQUFPO1VBQzlFLFdBQVc7VUFDWCxPQUFPLElBQUksTUFBTSxPQUFPLE1BQU0sWUFBWSxLQUFLLFVBQVUsS0FBSyxTQUFTLE9BQU87VUFDOUUsV0FBVzs7O0FBTWYsZUFBUyxpQkFBa0IsS0FBdUI7QUFDaEQsY0FBTSxRQUFRLElBQUksTUFBTTtBQUN4QixlQUFPLE1BQU0sWUFBWTtVQUN2QixHQUFHO1VBQ0gsT0FBTztZQUNMO1lBQ0EsT0FBTyxlQUFlLElBQUksTUFBTSxPQUFPLE1BQU0sT0FBTzs7WUFFcEQ7O0FBR04sWUFBTSxTQUFzQjtRQUMxQixHQUFHO1FBQ0gsUUFBUTtVQUNOLEdBQUc7VUFDSDtVQUNBLFNBQVM7VUFDVCxtQkFBbUI7O1FBR3JCLE1BQU0sS0FBRztBQUNQLGlCQUFPLE1BQU0sTUFBTSxpQkFBaUIsR0FBRyxDQUFDOztRQUcxQyxNQUFNLEtBQUc7QUFDUCxpQkFBTyxNQUFNLE1BQU0saUJBQWlCLEdBQUcsQ0FBQzs7UUFHMUMsV0FBVyxLQUFHO0FBQ1osZ0JBQU0sRUFBQyxTQUFTLFdBQVcsVUFBUyxJQUFLLElBQUksTUFBTTtBQUNuRCxjQUFJLENBQUM7QUFBVyxtQkFBTyxNQUFNLFdBQVcsR0FBRztBQUUzQyxtQkFBUyxvQkFBb0IsUUFBb0I7QUFDL0MscUJBQVMsVUFBVyxLQUFTO0FBQzNCLHFCQUFPLE9BQ0wsT0FBTyxTQUFTLElBQUksS0FBSyxJQUFJLFVBQVUsS0FBSyxVQUFVLEtBQUssU0FBUyxPQUFPLENBQUMsSUFDNUUsSUFBSSxTQUNGLE9BQU8sU0FDTCxPQUFPLElBQUksTUFBTSxHQUFHLFNBQVMsRUFDMUIsT0FBTyxJQUFJLFVBQ1IsS0FBSyxVQUNMLEtBQUssU0FBUyxPQUFPLENBQUMsSUFFOUIsT0FBTyxTQUFROztBQUVyQixrQkFBTSxnQkFBZ0IsT0FBTyxPQUFPLFFBQVE7Y0FDMUMsVUFBVSxFQUFDLE9BQU8sVUFBUztjQUMzQixvQkFBb0I7Z0JBQ2xCLE1BQU0sS0FBVWEsYUFBZTtBQUM3Qix5QkFBTyxtQkFBbUIsSUFBSSxLQUFLLEtBQUssU0FBUyxPQUFPLEdBQUdBLFdBQVU7OztjQUd6RSxZQUFZO2dCQUNWLE1BQUc7QUFDRCx5QkFBTyxPQUFPOzs7Y0FHbEIsS0FBSztnQkFDSCxNQUFHO0FBQ0Qsd0JBQU0sTUFBTSxPQUFPO0FBQ25CLHlCQUFPLGNBQWMsSUFDbkIsSUFBSSxDQUFDLElBQ0wsSUFBSSxNQUFNLEdBQUcsU0FBUzs7O2NBRzVCLE9BQU87Z0JBQ0wsTUFBRztBQUNELHlCQUFPLE9BQU87OzthQUduQjtBQUNELG1CQUFPOztBQUdULGlCQUFPLE1BQU0sV0FBVyxpQkFBaUIsR0FBRyxDQUFDLEVBQzFDLEtBQUssWUFBVSxVQUFVLG9CQUFvQixNQUFNLENBQUM7OztBQUczRCxhQUFPOzs7QUFHYjtBQUVPLElBQU0seUJBQThDO0VBQ3pELE9BQU87RUFDUCxNQUFNO0VBQ04sT0FBTztFQUNQLFFBQVE7O1NDMUxNLGNBQWMsR0FBUSxHQUFRLElBQVUsTUFBYTtBQUVuRSxPQUFLLE1BQU0sQ0FBQTtBQUNYLFNBQU8sUUFBUTtBQUNmLEVBQUEvQyxNQUFLLENBQUMsRUFBRSxRQUFRLENBQUMsU0FBSTtBQUNuQixRQUFJLENBQUMsT0FBTyxHQUFHLElBQUksR0FBRztBQUVwQixTQUFHLE9BQU8sSUFBSSxJQUFJO1dBQ2I7QUFDTCxVQUFJLEtBQUssRUFBRSxJQUFJLEdBQ2IsS0FBSyxFQUFFLElBQUk7QUFDYixVQUFJLE9BQU8sT0FBTyxZQUFZLE9BQU8sT0FBTyxZQUFZLE1BQU0sSUFBSTtBQUNoRSxjQUFNLGFBQWEsWUFBWSxFQUFFO0FBQ2pDLGNBQU0sYUFBYSxZQUFZLEVBQUU7QUFFakMsWUFBSSxlQUFlLFlBQVk7QUFDN0IsYUFBRyxPQUFPLElBQUksSUFBSSxFQUFFLElBQUk7bUJBQ2YsZUFBZSxVQUFVO0FBRWxDLHdCQUFjLElBQUksSUFBSSxJQUFJLE9BQU8sT0FBTyxHQUFHO21CQUNsQyxPQUFPLElBQUk7QUFLcEIsYUFBRyxPQUFPLElBQUksSUFBSSxFQUFFLElBQUk7O2lCQUVqQixPQUFPO0FBQUksV0FBRyxPQUFPLElBQUksSUFBSSxFQUFFLElBQUk7O0dBRWpEO0FBQ0QsRUFBQUEsTUFBSyxDQUFDLEVBQUUsUUFBUSxDQUFDLFNBQUk7QUFDbkIsUUFBSSxDQUFDLE9BQU8sR0FBRyxJQUFJLEdBQUc7QUFDcEIsU0FBRyxPQUFPLElBQUksSUFBSSxFQUFFLElBQUk7O0dBRTNCO0FBQ0QsU0FBTztBQUNUO1NDOUJnQixpQkFDZCxZQUNBLEtBQWlJO0FBR2pJLE1BQUksSUFBSSxTQUFTO0FBQVUsV0FBTyxJQUFJO0FBQ3RDLFNBQU8sSUFBSSxRQUFRLElBQUksT0FBTyxJQUFJLFdBQVcsVUFBVTtBQUN6RDtBQ0tPLElBQU0sa0JBQXVDO0VBQ2xELE9BQU87RUFDUCxNQUFNO0VBQ04sT0FBTztFQUNQLFFBQVEsQ0FBQyxjQUFzQjtJQUM3QixHQUFHO0lBQ0gsTUFBTSxXQUFpQjtBQUNyQixZQUFNLFlBQVksU0FBUyxNQUFNLFNBQVM7QUFDMUMsWUFBTSxFQUFDLFdBQVUsSUFBSSxVQUFVO0FBRS9CLFlBQU0sa0JBQStCO1FBQ25DLEdBQUc7UUFDSCxPQUFPLEtBQUc7QUFDUixnQkFBTSxVQUFVLElBQUk7QUFHcEIsZ0JBQU0sRUFBQyxVQUFVLFVBQVUsU0FBUSxJQUFJLFFBQVEsTUFBTSxTQUFTLEVBQUU7QUFDaEUsa0JBQVEsSUFBSSxNQUFJO1lBQ2QsS0FBSztBQUNILGtCQUFJLFNBQVMsU0FBU007QUFBSztBQUMzQixxQkFBTyxRQUFRLFNBQVMsYUFBYSxNQUFJLGVBQWUsR0FBRyxHQUFHLElBQUk7WUFDcEUsS0FBSztBQUNILGtCQUFJLFNBQVMsU0FBU0EsUUFBTyxTQUFTLFNBQVNBO0FBQUs7QUFDcEQscUJBQU8sUUFBUSxTQUFTLGFBQWEsTUFBSSxlQUFlLEdBQUcsR0FBRyxJQUFJO1lBQ3BFLEtBQUs7QUFDSCxrQkFBSSxTQUFTLFNBQVNBO0FBQUs7QUFDM0IscUJBQU8sUUFBUSxTQUFTLGFBQWEsTUFBSSxlQUFlLEdBQUcsR0FBRyxJQUFJO1lBQ3BFLEtBQUs7QUFDSCxrQkFBSSxTQUFTLFNBQVNBO0FBQUs7QUFDM0IscUJBQU8sUUFBUSxTQUFTLGFBQWEsTUFBSSxZQUFZLEdBQUcsR0FBRyxJQUFJOztBQUduRSxpQkFBTyxVQUFVLE9BQU8sR0FBRztBQUczQixtQkFBUyxlQUFlNkIsTUFBOEQ7QUFDcEYsa0JBQU1hLFdBQVUsSUFBSTtBQUNwQixrQkFBTWhELFFBQU9tQyxLQUFJLFFBQVEsaUJBQWlCLFlBQVlBLElBQUc7QUFDekQsZ0JBQUksQ0FBQ25DO0FBQU0sb0JBQU0sSUFBSSxNQUFNLGNBQWM7QUFFekMsWUFBQW1DLE9BQU1BLEtBQUksU0FBUyxTQUFTQSxLQUFJLFNBQVMsUUFDdkMsRUFBQyxHQUFHQSxNQUFLLE1BQUFuQyxNQUFJLElBQ2IsRUFBQyxHQUFHbUMsS0FBRztBQUNULGdCQUFJQSxLQUFJLFNBQVM7QUFBVSxjQUFBQSxLQUFJLFNBQVMsQ0FBQyxHQUFHQSxLQUFJLE1BQU07QUFDdEQsZ0JBQUlBLEtBQUk7QUFBTSxjQUFBQSxLQUFJLE9BQU8sQ0FBQyxHQUFHQSxLQUFJLElBQUk7QUFFckMsbUJBQU8sa0JBQWtCLFdBQVdBLE1BQUtuQyxLQUFJLEVBQUUsS0FBTSxvQkFBYztBQUNqRSxvQkFBTSxXQUFXQSxNQUFLLElBQUksQ0FBQyxLQUFLLE1BQUM7QUFDL0Isc0JBQU0sZ0JBQWdCLGVBQWUsQ0FBQztBQUN0QyxzQkFBTSxNQUFNLEVBQUUsU0FBUyxNQUFNLFdBQVcsS0FBSTtBQUM1QyxvQkFBSW1DLEtBQUksU0FBUyxVQUFVO0FBRXpCLDJCQUFTLEtBQUssS0FBSyxLQUFLLEtBQUssZUFBZWEsUUFBTzsyQkFDMUNiLEtBQUksU0FBUyxTQUFTLGtCQUFrQixRQUFXO0FBRTVELHdCQUFNLHNCQUFzQixTQUFTLEtBQUssS0FBSyxLQUFLLEtBQUtBLEtBQUksT0FBTyxDQUFDLEdBQUdhLFFBQU87QUFDL0Usc0JBQUksT0FBTyxRQUFRLHVCQUF1QixNQUFNO0FBQzlDLDBCQUFNO0FBQ04sb0JBQUFiLEtBQUksS0FBSyxDQUFDLElBQUk7QUFDZCx3QkFBSSxDQUFDLFdBQVcsVUFBVTtBQUN4QixtQ0FBYUEsS0FBSSxPQUFPLENBQUMsR0FBRyxXQUFXLFNBQVMsR0FBRzs7O3VCQUdsRDtBQUVMLHdCQUFNLGFBQWEsY0FBYyxlQUFlQSxLQUFJLE9BQU8sQ0FBQyxDQUFDO0FBQzdELHdCQUFNLG9CQUFvQixTQUFTLEtBQUssS0FBSyxLQUFLLFlBQVksS0FBSyxlQUFlYSxRQUFPO0FBQ3pGLHNCQUFJLG1CQUFtQjtBQUNyQiwwQkFBTSxpQkFBaUJiLEtBQUksT0FBTyxDQUFDO0FBQ25DLDJCQUFPLEtBQUssaUJBQWlCLEVBQUUsUUFBUSxhQUFPO0FBQzVDLDBCQUFJLE9BQU8sZ0JBQWdCLE9BQU8sR0FBRztBQUVuQyx1Q0FBZSxPQUFPLElBQUksa0JBQWtCLE9BQU87NkJBQzlDO0FBRUwscUNBQWEsZ0JBQWdCLFNBQVMsa0JBQWtCLE9BQU8sQ0FBQzs7cUJBRW5FOzs7QUFHTCx1QkFBTztlQUNSO0FBQ0QscUJBQU8sVUFBVSxPQUFPQSxJQUFHLEVBQUUsS0FBSyxDQUFDLEVBQUMsVUFBVSxTQUFTLGFBQWEsV0FBVSxNQUFDO0FBQzdFLHlCQUFTLElBQUUsR0FBRyxJQUFFbkMsTUFBSyxRQUFRLEVBQUUsR0FBRztBQUNoQyx3QkFBTSxVQUFVLFVBQVUsUUFBUSxDQUFDLElBQUlBLE1BQUssQ0FBQztBQUM3Qyx3QkFBTSxNQUFNLFNBQVMsQ0FBQztBQUN0QixzQkFBSSxXQUFXLE1BQU07QUFDbkIsd0JBQUksV0FBVyxJQUFJLFFBQVEsU0FBUyxDQUFDLENBQUM7eUJBQ2pDO0FBQ0wsd0JBQUksYUFBYSxJQUFJO3NCQUNuQm1DLEtBQUksU0FBUyxTQUFTLGVBQWUsQ0FBQyxJQUNwQ0EsS0FBSSxPQUFPLENBQUMsSUFDWjs7OztBQUlSLHVCQUFPLEVBQUMsVUFBVSxTQUFTLGFBQWEsV0FBVTtlQUNuRCxFQUFFLE1BQU0sV0FBSztBQUNaLHlCQUFTLFFBQVEsU0FBTyxJQUFJLFdBQVcsSUFBSSxRQUFRLEtBQUssQ0FBQztBQUN6RCx1QkFBTyxRQUFRLE9BQU8sS0FBSztlQUM1QjthQUNGOztBQUdILG1CQUFTLFlBQVlBLE1BQTZCO0FBQ2hELG1CQUFPLGdCQUFnQkEsS0FBSSxPQUFPQSxLQUFJLE9BQU8sR0FBSzs7QUFHcEQsbUJBQVMsZ0JBQWdCLE9BQTBCLE9BQXVCLE9BQWE7QUFFckYsbUJBQU8sVUFBVSxNQUFNLEVBQUMsT0FBTyxRQUFRLE9BQU8sT0FBTyxFQUFDLE9BQU8sWUFBWSxNQUFLLEdBQUcsTUFBSyxDQUFDLEVBQ3RGLEtBQUssQ0FBQyxFQUFDLE9BQU0sTUFBQztBQUdiLHFCQUFPLGVBQWUsRUFBQyxNQUFNLFVBQVUsTUFBTSxRQUFRLE1BQUssQ0FBQyxFQUFFLEtBQUssU0FBRztBQUNuRSxvQkFBSSxJQUFJLGNBQWM7QUFBRyx5QkFBTyxRQUFRLE9BQU8sSUFBSSxTQUFTLENBQUMsQ0FBQztBQUM5RCxvQkFBSSxPQUFPLFNBQVMsT0FBTztBQUN6Qix5QkFBTyxFQUFDLFVBQVUsQ0FBQSxHQUFJLGFBQWEsR0FBRyxZQUFZLE9BQVM7dUJBQ3REO0FBQ0wseUJBQU8sZ0JBQWdCLE9BQU8sRUFBQyxHQUFHLE9BQU8sT0FBTyxPQUFPLE9BQU8sU0FBUyxDQUFDLEdBQUcsV0FBVyxLQUFJLEdBQUcsS0FBSzs7ZUFFckc7YUFDRjs7OztBQU1QLGFBQU87Ozs7QUFLYixTQUFTLGtCQUNQLE9BQ0EsS0FDQSxlQUFvQjtBQUVwQixTQUFPLElBQUksU0FBUyxRQUNoQixRQUFRLFFBQVEsQ0FBQSxDQUFFLElBQ2xCLE1BQU0sUUFBUSxFQUFFLE9BQU8sSUFBSSxPQUFPLE1BQU0sZUFBZSxPQUFPLFlBQVcsQ0FBRTtBQUNqRjtTQzNKZ0Isd0JBQ2RuQyxPQUNBLE9BQ0EsT0FBZTtBQUVmLE1BQUk7QUFDRixRQUFJLENBQUM7QUFBTyxhQUFPO0FBQ25CLFFBQUksTUFBTSxLQUFLLFNBQVNBLE1BQUs7QUFBUSxhQUFPO0FBQzVDLFVBQU0sU0FBZ0IsQ0FBQTtBQUl0QixhQUFTLElBQUksR0FBRyxJQUFJLEdBQUcsSUFBSSxNQUFNLEtBQUssVUFBVSxJQUFJQSxNQUFLLFFBQVEsRUFBRSxHQUFHO0FBQ3BFLFVBQUksSUFBSSxNQUFNLEtBQUssQ0FBQyxHQUFHQSxNQUFLLENBQUMsQ0FBQyxNQUFNO0FBQUc7QUFDdkMsYUFBTyxLQUFLLFFBQVEsVUFBVSxNQUFNLE9BQU8sQ0FBQyxDQUFDLElBQUksTUFBTSxPQUFPLENBQUMsQ0FBQztBQUNoRSxRQUFFOztBQUdKLFdBQU8sT0FBTyxXQUFXQSxNQUFLLFNBQVMsU0FBUztXQUNoRCxJQUFBO0FBQ0EsV0FBTzs7QUFFWDtBQUVPLElBQU0sZ0NBQW9EO0VBQy9ELE9BQU87RUFDUCxPQUFPO0VBQ1AsUUFBUSxDQUFDLFNBQUk7QUFDWCxXQUFPO01BQ0wsT0FBTyxDQUFDLGNBQVM7QUFDZixjQUFNLFFBQVEsS0FBSyxNQUFNLFNBQVM7QUFDbEMsZUFBTztVQUNMLEdBQUc7VUFDSCxTQUFTLENBQUMsUUFBRztBQUNYLGdCQUFJLENBQUMsSUFBSSxPQUFPO0FBQ2QscUJBQU8sTUFBTSxRQUFRLEdBQUc7O0FBRTFCLGtCQUFNLGVBQWUsd0JBQ25CLElBQUksTUFDSixJQUFJLE1BQU0sUUFBUSxHQUNsQixJQUFJLFVBQVUsT0FBTztBQUV2QixnQkFBSSxjQUFjO0FBQ2hCLHFCQUFPWSxhQUFRLFFBQVEsWUFBWTs7QUFFckMsbUJBQU8sTUFBTSxRQUFRLEdBQUcsRUFBRSxLQUFLLENBQUMsUUFBRztBQUNqQyxrQkFBSSxNQUFNLFFBQVEsSUFBSTtnQkFDcEIsTUFBTSxJQUFJO2dCQUNWLFFBQVEsSUFBSSxVQUFVLFVBQVUsVUFBVSxHQUFHLElBQUk7O0FBRW5ELHFCQUFPO2FBQ1I7O1VBRUgsUUFBUSxDQUFDLFFBQUc7QUFFVixnQkFBSSxJQUFJLFNBQVM7QUFBTyxrQkFBSSxNQUFNLFFBQVEsSUFBSTtBQUM5QyxtQkFBTyxNQUFNLE9BQU8sR0FBRzs7Ozs7OztBQzdDbkMsU0FBUyxhQUFhLE1BQTZEO0FBQ2pGLFNBQU8sRUFBRSxVQUFVO0FBQ3JCO0lBSWFxQyxZQUFXLFNBQVMsWUFBaUIsSUFBUTtBQUN4RCxNQUFJLE1BQU07QUFFUixXQUFPLE1BQU0sVUFBVSxTQUFTLEVBQUMsR0FBRSxHQUFHLE1BQU0sWUFBWSxJQUFJLFVBQVUsU0FBUyxJQUFJLEtBQUssV0FBVSxJQUFJLEVBQUMsR0FBRSxFQUFDLENBQUM7U0FDdEc7QUFFTCxVQUFNLEtBQUssSUFBSUEsVUFBUTtBQUN2QixRQUFJLGNBQWUsT0FBTyxZQUFhO0FBQ3JDLGFBQU8sSUFBSSxVQUFVOztBQUV2QixXQUFPOztBQUVYO0FBRUEsTUFBTUEsVUFBUyxXQUFXO0VBQ3hCLElBQUksVUFBaUU7QUFDbkUsZ0JBQVksTUFBTSxRQUFRO0FBQzFCLFdBQU87O0VBRVQsT0FBTyxLQUFrQjtBQUN2QixhQUFTLE1BQU0sS0FBSyxHQUFHO0FBQ3ZCLFdBQU87O0VBRVQsUUFBUWpELE9BQXFCO0FBQzNCLElBQUFBLE1BQUssUUFBUSxTQUFPLFNBQVMsTUFBTSxLQUFLLEdBQUcsQ0FBQztBQUM1QyxXQUFPOztFQUdULENBQUMsY0FBYyxJQUFDO0FBQ2QsV0FBTyxvQkFBb0IsSUFBSTs7Q0FFbEM7QUFFRCxTQUFTLFNBQVMsUUFBc0JrRCxPQUFxQixJQUFpQjtBQUM1RSxRQUFNLE9BQU8sSUFBSUEsT0FBTSxFQUFFO0FBR3pCLE1BQUksTUFBTSxJQUFJO0FBQUc7QUFHakIsTUFBSSxPQUFPO0FBQUcsVUFBTSxXQUFVO0FBRTlCLE1BQUksYUFBYSxNQUFNO0FBQUcsV0FBTyxPQUFPLFFBQVEsRUFBRSxNQUFBQSxPQUFNLElBQUksR0FBRyxFQUFDLENBQUU7QUFDbEUsUUFBTSxPQUFPLE9BQU87QUFDcEIsUUFBTSxRQUFRLE9BQU87QUFDckIsTUFBSSxJQUFJLElBQUksT0FBTyxJQUFJLElBQUksR0FBRztBQUM1QixXQUNJLFNBQVMsTUFBTUEsT0FBTSxFQUFFLElBQ3RCLE9BQU8sSUFBSSxFQUFFLE1BQUFBLE9BQU0sSUFBSSxHQUFHLEdBQUcsR0FBRyxNQUFNLEdBQUcsS0FBSTtBQUNsRCxXQUFPLFVBQVUsTUFBTTs7QUFFekIsTUFBSSxJQUFJQSxPQUFNLE9BQU8sRUFBRSxJQUFJLEdBQUc7QUFDNUIsWUFDSSxTQUFTLE9BQU9BLE9BQU0sRUFBRSxJQUN2QixPQUFPLElBQUksRUFBRSxNQUFBQSxPQUFNLElBQUksR0FBRyxHQUFHLEdBQUcsTUFBTSxHQUFHLEtBQUk7QUFDbEQsV0FBTyxVQUFVLE1BQU07O0FBS3pCLE1BQUksSUFBSUEsT0FBTSxPQUFPLElBQUksSUFBSSxHQUFHO0FBQzlCLFdBQU8sT0FBT0E7QUFDZCxXQUFPLElBQUk7QUFDWCxXQUFPLElBQUksUUFBUSxNQUFNLElBQUksSUFBSTs7QUFHbkMsTUFBSSxJQUFJLElBQUksT0FBTyxFQUFFLElBQUksR0FBRztBQUMxQixXQUFPLEtBQUs7QUFDWixXQUFPLElBQUk7QUFDWCxXQUFPLElBQUksT0FBTyxJQUFJLE9BQU8sRUFBRSxJQUFJLElBQUk7O0FBRXpDLFFBQU0saUJBQWlCLENBQUMsT0FBTztBQUUvQixNQUFJLFFBQVEsQ0FBQyxPQUFPLEdBQUc7QUFHckIsZ0JBQVksUUFBUSxJQUFJOztBQUcxQixNQUFJLFNBQVMsZ0JBQWdCO0FBRzNCLGdCQUFZLFFBQVEsS0FBSzs7QUFFN0I7U0FFZ0IsWUFBWSxRQUFzQixRQUErRDtBQUMvRyxXQUFTLGFBQ1BDLFNBQ0EsRUFBRSxNQUFBRCxPQUFNLElBQUksR0FBRyxFQUFDLEdBQTZGO0FBRTdHLGFBQVNDLFNBQVFELE9BQU0sRUFBRTtBQUN6QixRQUFJO0FBQUcsbUJBQWFDLFNBQVEsQ0FBQztBQUM3QixRQUFJO0FBQUcsbUJBQWFBLFNBQVEsQ0FBQzs7QUFHL0IsTUFBRyxDQUFDLGFBQWEsTUFBTTtBQUFHLGlCQUFhLFFBQVEsTUFBTTtBQUN2RDtTQUVnQixjQUNkLFdBQ0EsV0FBdUI7QUFHckIsUUFBTSxLQUFLLG9CQUFvQixTQUFTO0FBQ3hDLE1BQUksY0FBYyxHQUFHLEtBQUk7QUFDekIsTUFBSSxZQUFZO0FBQU0sV0FBTztBQUM3QixNQUFJLElBQUksWUFBWTtBQUdwQixRQUFNLEtBQUssb0JBQW9CLFNBQVM7QUFDeEMsTUFBSSxjQUFjLEdBQUcsS0FBSyxFQUFFLElBQUk7QUFDaEMsTUFBSSxJQUFJLFlBQVk7QUFFcEIsU0FBTyxDQUFDLFlBQVksUUFBUSxDQUFDLFlBQVksTUFBTTtBQUM3QyxRQUFJLElBQUksRUFBRyxNQUFNLEVBQUUsRUFBRSxLQUFLLEtBQUssSUFBSSxFQUFHLElBQUksRUFBRSxJQUFJLEtBQUs7QUFBRyxhQUFPO0FBQy9ELFFBQUksRUFBRSxNQUFNLEVBQUcsSUFBSSxJQUFJLElBQ2xCLEtBQUssY0FBYyxHQUFHLEtBQUssRUFBRyxJQUFJLEdBQUcsUUFDckMsS0FBSyxjQUFjLEdBQUcsS0FBSyxFQUFFLElBQUksR0FBRzs7QUFFN0MsU0FBTztBQUNUO1NBVWdCLG9CQUNkLE1BQW1DO0FBRW5DLE1BQUksUUFBK0IsYUFBYSxJQUFJLElBQUksT0FBTyxFQUFFLEdBQUcsR0FBRyxHQUFHLEtBQUk7QUFFOUUsU0FBTztJQUNMLEtBQUssS0FBSTtBQUNQLFlBQU0sY0FBYyxVQUFVLFNBQVM7QUFDdkMsYUFBTyxPQUFPO0FBQ1osZ0JBQVEsTUFBTSxHQUFDO1VBQ2IsS0FBSztBQUdILGtCQUFNLElBQUk7QUFDVixnQkFBSSxhQUFhO0FBQ2YscUJBQU8sTUFBTSxFQUFFLEtBQUssSUFBSSxLQUFLLE1BQU0sRUFBRSxJQUFJLElBQUk7QUFDM0Msd0JBQVEsRUFBRSxJQUFJLE9BQU8sR0FBRyxNQUFNLEVBQUUsR0FBRyxHQUFHLEVBQUM7bUJBQ3BDO0FBQ0wscUJBQU8sTUFBTSxFQUFFO0FBQUcsd0JBQVEsRUFBRSxJQUFJLE9BQU8sR0FBRyxNQUFNLEVBQUUsR0FBRyxHQUFHLEVBQUM7O1VBRzdELEtBQUs7QUFFSCxrQkFBTSxJQUFJO0FBQ1YsZ0JBQUksQ0FBQyxlQUFlLElBQUksS0FBSyxNQUFNLEVBQUUsRUFBRSxLQUFLO0FBQzFDLHFCQUFPLEVBQUUsT0FBTyxNQUFNLEdBQUcsTUFBTSxNQUFLO1VBQ3hDLEtBQUs7QUFFSCxnQkFBSSxNQUFNLEVBQUUsR0FBRztBQUNiLG9CQUFNLElBQUk7QUFDVixzQkFBUSxFQUFFLElBQUksT0FBTyxHQUFHLE1BQU0sRUFBRSxHQUFHLEdBQUcsRUFBQztBQUN2Qzs7VUFHSixLQUFLO0FBQ0gsb0JBQVEsTUFBTTs7O0FBR3BCLGFBQU8sRUFBRSxNQUFNLEtBQUk7OztBQUd6QjtBQUVBLFNBQVMsVUFBVSxRQUF3Qjs7QUFDekMsUUFBTSxVQUFRLEtBQUEsT0FBTyxPQUFDLFFBQUEsT0FBQSxTQUFBLFNBQUEsR0FBRSxNQUFLLFFBQU0sS0FBQSxPQUFPLE9BQUMsUUFBQSxPQUFBLFNBQUEsU0FBQSxHQUFFLE1BQUs7QUFDbEQsUUFBTSxJQUFJLE9BQU8sSUFBSSxNQUFNLE9BQU8sS0FBSyxNQUFNO0FBQzdDLE1BQUksR0FBRztBQXNCTCxVQUFNLElBQUksTUFBTSxNQUFNLE1BQU07QUFDNUIsVUFBTSxZQUFZLEVBQUUsR0FBRyxPQUFNO0FBSTdCLFVBQU0sZUFBZSxPQUFPLENBQUM7QUFDN0IsV0FBTyxPQUFPLGFBQWE7QUFDM0IsV0FBTyxLQUFLLGFBQWE7QUFDekIsV0FBTyxDQUFDLElBQUksYUFBYSxDQUFDO0FBQzFCLGNBQVUsQ0FBQyxJQUFJLGFBQWEsQ0FBQztBQUM3QixXQUFPLENBQUMsSUFBSTtBQUNaLGNBQVUsSUFBSSxhQUFhLFNBQVM7O0FBRXRDLFNBQU8sSUFBSSxhQUFhLE1BQU07QUFDaEM7QUFFQSxTQUFTLGFBQWEsRUFBRSxHQUFHLEVBQUMsR0FBcUM7QUFDL0QsVUFBUSxJQUFLLElBQUksS0FBSyxJQUFJLEVBQUUsR0FBRyxFQUFFLENBQUMsSUFBSSxFQUFFLElBQUssSUFBSSxFQUFFLElBQUksS0FBSztBQUM5RDtBQzFOTyxJQUFNLDBCQUE4QztFQUN6RCxPQUFPO0VBQ1AsT0FBTztFQUNQLFFBQVEsQ0FBQyxTQUFJO0FBQ1gsVUFBTSxTQUFTLEtBQUssT0FBTztBQUMzQixVQUFNLGFBQWEsSUFBSUYsVUFBUyxLQUFLLFNBQVMsS0FBSyxPQUFPO0FBRTFELFdBQU87TUFDTCxHQUFHO01BQ0gsT0FBTyxDQUFDLGNBQVM7QUFDZixjQUFNLFFBQVEsS0FBSyxNQUFNLFNBQVM7QUFDbEMsY0FBTSxFQUFFLE9BQU0sSUFBSztBQUNuQixjQUFNLEVBQUUsV0FBVSxJQUFLO0FBQ3ZCLGNBQU0sRUFBRSxZQUFZLFNBQVEsSUFBSztBQUNqQyxjQUFNLGFBQTBCO1VBQzlCLEdBQUc7VUFDSCxRQUFRLENBQUMsUUFBRztBQUNWLGtCQUFNLFFBQVEsSUFBSTtBQUdsQixrQkFBTSxlQUNKLE1BQU0saUJBQWlCLE1BQU0sZUFBZSxDQUFBO0FBQzlDLGtCQUFNLGNBQWMsQ0FBQyxjQUFpQjtBQUNwQyxvQkFBTSxPQUFPLFNBQVMsVUFBVSxhQUFhO0FBQzdDLHFCQUFRLGFBQWEsSUFBSSxNQUN0QixhQUFhLElBQUksSUFBSSxJQUFJQSxVQUFROztBQUV0QyxrQkFBTSxhQUFhLFlBQVksRUFBRTtBQUNqQyxrQkFBTSxlQUFlLFlBQVksT0FBTztBQUV4QyxrQkFBTSxFQUFFLE1BQUF4QyxNQUFJLElBQUs7QUFDakIsZ0JBQUksQ0FBQ1QsT0FBTSxPQUFPLElBQ2hCLElBQUksU0FBUyxnQkFDVCxDQUFDLElBQUksS0FBSyxJQUNWLElBQUksU0FBUyxXQUNiLENBQUMsSUFBSSxJQUFJLElBQ1QsSUFBSSxPQUFPLFNBQVMsS0FDcEIsQ0FBQyxDQUFBLEdBQUksSUFBSSxNQUFNLElBQ2YsQ0FBQTtBQUNOLGtCQUFNLFdBQVcsSUFBSSxNQUFNLFFBQVE7QUFDbkMsbUJBQU8sTUFBTSxPQUFPLEdBQUcsRUFBRSxLQUFLLENBQUMsUUFBRztBQUdoQyxrQkFBSUMsU0FBUUQsS0FBSSxHQUFHO0FBRWpCLG9CQUFJUyxVQUFTO0FBQVUsa0JBQUFULFFBQU8sSUFBSTtBQUVsQywyQkFBVyxRQUFRQSxLQUFJO0FBR3ZCLHNCQUFNLFVBQVUsd0JBQXdCQSxPQUFNLFFBQVE7QUFHdEQsb0JBQUksQ0FBQyxXQUFXUyxVQUFTLE9BQU87QUFHOUIsK0JBQWEsUUFBUVQsS0FBSTs7QUFFM0Isb0JBQUksV0FBVyxTQUFTO0FBRXRCLHVDQUFxQixhQUFhLFFBQVEsU0FBUyxPQUFPOzt5QkFFbkRBLE9BQU07QUFFZixzQkFBTSxRQUFRLEVBQUUsTUFBTUEsTUFBSyxPQUFPLElBQUlBLE1BQUssTUFBSztBQUNoRCw2QkFBYSxJQUFJLEtBQUs7QUFFdEIsMkJBQVcsSUFBSSxLQUFLO3FCQUNmO0FBSUwsMkJBQVcsSUFBSSxVQUFVO0FBQ3pCLDZCQUFhLElBQUksVUFBVTtBQUMzQix1QkFBTyxRQUFRLFFBQVEsU0FBTyxZQUFZLElBQUksSUFBSSxFQUFFLElBQUksVUFBVSxDQUFDOztBQUVyRSxxQkFBTzthQUNSOzs7QUFJTCxjQUFNLFdBQWtELENBQUMsRUFDdkQsT0FBTyxFQUFFLE9BQU8sTUFBSyxFQUFFLE1BSUU7O0FBQUssaUJBQUE7WUFDOUI7WUFDQSxJQUFJaUQsV0FBUyxLQUFBLE1BQU0sV0FBSyxRQUFBLE9BQUEsU0FBQSxLQUFJLEtBQUssVUFBUyxLQUFBLE1BQU0sV0FBSyxRQUFBLE9BQUEsU0FBQSxLQUFJLEtBQUssT0FBTzs7O0FBR3ZFLGNBQU0sa0JBR0Y7VUFDRixLQUFLLENBQUMsUUFBUSxDQUFDLFlBQVksSUFBSUEsVUFBUyxJQUFJLEdBQUcsQ0FBQztVQUNoRCxTQUFTLENBQUMsUUFBUSxDQUFDLFlBQVksSUFBSUEsVUFBUSxFQUFHLFFBQVEsSUFBSSxJQUFJLENBQUM7VUFDL0QsT0FBTztVQUNQLE9BQU87VUFDUCxZQUFZOztBQUdkLFFBQUFqRCxNQUFLLGVBQWUsRUFBRSxRQUFRLFlBQU07QUFDbEMscUJBQVcsTUFBTSxJQUFJLFNBQ25CLEtBSzJCO0FBRTNCLGtCQUFNLEVBQUUsT0FBTSxJQUFLO0FBQ25CLGdCQUFJLFFBQVE7QUFLVixvQkFBTSxjQUFjLENBQUMsY0FBaUI7QUFDcEMsc0JBQU0sT0FBTyxTQUFTLFVBQVUsYUFBYTtBQUM3Qyx1QkFBUSxPQUFPLElBQUksTUFDaEIsT0FBTyxJQUFJLElBQUksSUFBSWlELFVBQVE7O0FBRWhDLG9CQUFNLGFBQWEsWUFBWSxFQUFFO0FBQ2pDLG9CQUFNLGVBQWUsWUFBWSxPQUFPO0FBQ3hDLG9CQUFNLENBQUMsY0FBYyxhQUFhLElBQUksZ0JBQWdCLE1BQU0sRUFBRSxHQUFHO0FBRWpFLDBCQUFZLGFBQWEsUUFBUSxFQUFFLEVBQUUsSUFBSSxhQUFhO0FBQ3RELGtCQUFJLENBQUMsYUFBYSxjQUFjO0FBVTlCLG9CQUFJLFdBQVcsU0FBUztBQUt0QiwrQkFBYSxJQUFJLFVBQVU7dUJBQ3RCO0FBSUwsd0JBQU0sY0FDSixXQUFXLFdBQ1gsWUFDQyxJQUEyQixVQUM1QixNQUFNLE1BQU07b0JBQ1YsR0FBSTtvQkFDSixRQUFRO21CQUNUO0FBRUgseUJBQU8sTUFBTSxNQUFNLEVBQUUsTUFBTSxNQUFNLFNBQVMsRUFBRSxLQUFLLENBQUMsUUFBRztBQUNuRCx3QkFBSSxXQUFXLFNBQVM7QUFDdEIsMEJBQUksWUFBYSxJQUEyQixRQUFRO0FBTWxELCtCQUFPLFlBQVksS0FDakIsQ0FBQyxFQUFFLFFBQVEsY0FBYSxNQUF1QjtBQUM3QyxxQ0FBVyxRQUFRLGFBQWE7QUFDaEMsaUNBQU87eUJBQ1I7O0FBS0wsNEJBQU0sUUFBUyxJQUEyQixTQUNyQyxJQUE0QixPQUFPLElBQUksVUFBVSxJQUNqRCxJQUE0QjtBQUNqQywwQkFBSyxJQUEyQixRQUFRO0FBR3RDLG1DQUFXLFFBQVEsS0FBSzs2QkFDbkI7QUFRTCxxQ0FBYSxRQUFRLEtBQUs7OytCQUVuQixXQUFXLGNBQWM7QUFLbEMsNEJBQU0sU0FBOEI7QUFDcEMsNEJBQU0sYUFBYyxJQUFnQztBQUNwRCw2QkFDRSxVQUNBLE9BQU8sT0FBTyxRQUFRO3dCQUNwQixLQUFLOzBCQUNILE1BQUc7QUFDRCx5Q0FBYSxPQUFPLE9BQU8sVUFBVTtBQUNyQyxtQ0FBTyxPQUFPOzs7d0JBR2xCLFlBQVk7MEJBQ1YsTUFBRztBQUNELGtDQUFNLE9BQU8sT0FBTztBQUNwQix5Q0FBYSxPQUFPLElBQUk7QUFDeEIsbUNBQU87Ozt3QkFHWCxPQUFPOzBCQUNMLE1BQUc7QUFDRCwwQ0FBYyxXQUFXLE9BQU8sT0FBTyxVQUFVO0FBQ2pELG1DQUFPLE9BQU87Ozt1QkFHbkI7O0FBR0wsMkJBQU87bUJBQ1I7Ozs7QUFJUCxtQkFBTyxNQUFNLE1BQU0sRUFBRSxNQUFNLE1BQU0sU0FBUzs7U0FFN0M7QUFDRCxlQUFPOzs7OztBQU1mLFNBQVMscUJBQ1AsYUFDQSxRQUNBLFNBQ0EsU0FBMEI7QUFFMUIsV0FBUyxpQkFBaUIsSUFBZTtBQUN2QyxVQUFNLFdBQVcsWUFBWSxHQUFHLFFBQVEsRUFBRTtBQUMxQyxhQUFTLFdBQVcsS0FBUTtBQUMxQixhQUFPLE9BQU8sT0FBTyxHQUFHLFdBQVcsR0FBRyxJQUFJOztBQUU1QyxVQUFNLGVBQWUsQ0FBQyxRQUFhLEdBQUcsY0FBY2hELFNBQVEsR0FBRyxJQUUzRCxJQUFJLFFBQVEsQ0FBQW1ELFNBQU8sU0FBUyxPQUFPQSxJQUFHLENBQUMsSUFFdkMsU0FBUyxPQUFPLEdBQUc7QUFFdkIsS0FBQyxXQUFXLFNBQVMsUUFBUSxDQUFDLEdBQUcsTUFBQztBQUNoQyxZQUFNLFNBQVMsV0FBVyxXQUFXLFFBQVEsQ0FBQyxDQUFDO0FBQy9DLFlBQU0sU0FBUyxXQUFXLFdBQVcsUUFBUSxDQUFDLENBQUM7QUFDL0MsVUFBSSxJQUFJLFFBQVEsTUFBTSxNQUFNLEdBQUc7QUFFN0IsWUFBSSxVQUFVO0FBQU0sdUJBQWEsTUFBTTtBQUN2QyxZQUFJLFVBQVU7QUFBTSx1QkFBYSxNQUFNOztLQUUxQzs7QUFFSCxTQUFPLFFBQVEsUUFBUSxnQkFBZ0I7QUFDekM7SUNqT2FULGdCQUFLO0VBNkJoQixZQUFZLE1BQWMsU0FBc0I7QUFqQmhELFNBQUEsZUFBMEYsQ0FBQTtBQU0xRixTQUFBLFFBQWdCO0FBWWQsVUFBTSxPQUFRQSxRQUFrQztBQUNoRCxTQUFLLFdBQVcsVUFBVTtNQUV4QixRQUFTQSxRQUFrQztNQUMzQyxVQUFVO01BRVYsV0FBVyxLQUFLO01BQ2hCLGFBQWEsS0FBSztNQUNsQixHQUFHOztBQUVMLFNBQUssUUFBUTtNQUNYLFdBQVcsUUFBUTtNQUNuQixhQUFhLFFBQVE7O0FBRXZCLFVBQU0sRUFDSixPQUFNLElBQ0o7QUFDSixTQUFLLFlBQVksQ0FBQTtBQUNqQixTQUFLLFlBQVksQ0FBQTtBQUNqQixTQUFLLGNBQWMsQ0FBQTtBQUNuQixTQUFLLGFBQWEsQ0FBQTtBQUNsQixTQUFLLFFBQVE7QUFDYixTQUFLLFNBQVM7QUFDZCxVQUFNLFFBQXNCO01BQzFCLGFBQWE7TUFDYixlQUFlO01BQ2YsbUJBQW1CO01BQ25CLGNBQWM7TUFDZCxnQkFBZ0JyQztNQUNoQixnQkFBZ0I7TUFDaEIsWUFBWUE7TUFDWixlQUFlO01BQ2YsWUFBWTtNQUNaLGdCQUFnQjs7QUFFbEIsVUFBTSxpQkFBaUIsSUFBSU0sYUFBUSxDQUFBTCxhQUFPO0FBQ3hDLFlBQU0saUJBQWlCQTtLQUN4QjtBQUNELFVBQU0sZ0JBQWdCLElBQUlLLGFBQVEsQ0FBQyxHQUFHSixZQUFNO0FBQzFDLFlBQU0sYUFBYUE7S0FDcEI7QUFDRCxTQUFLLFNBQVM7QUFDZCxTQUFLLE9BQU87QUFDWixTQUFLLEtBQUssT0FBTyxNQUFNLFlBQVksV0FBVyxpQkFBaUIsU0FBUyxFQUFFLE9BQU8sQ0FBQyxpQkFBaUJGLElBQUcsRUFBQyxDQUFFO0FBQ3pHLFNBQUssR0FBRyxNQUFNLFlBQVksU0FBUyxLQUFLLEdBQUcsTUFBTSxXQUFXLENBQUErQyxlQUFTO0FBQ25FLGFBQU8sQ0FBQyxZQUFZLFlBQU87QUFDeEJWLGdCQUFrQyxJQUFJLE1BQUE7QUFDckMsZ0JBQU1XLFNBQVEsS0FBSztBQUNuQixjQUFJQSxPQUFNLGNBQWM7QUFFdEIsZ0JBQUksQ0FBQ0EsT0FBTTtBQUFhMUMsMkJBQVEsUUFBTyxFQUFHLEtBQUssVUFBVTtBQUV6RCxnQkFBSTtBQUFTLGNBQUF5QyxXQUFVLFVBQVU7cUJBQ3hCQyxPQUFNLG1CQUFtQjtBQUVsQyxZQUFBQSxPQUFNLGtCQUFrQixLQUFLLFVBQVU7QUFDdkMsZ0JBQUk7QUFBUyxjQUFBRCxXQUFVLFVBQVU7aUJBQzVCO0FBRUwsWUFBQUEsV0FBVSxVQUFVO0FBRXBCLGtCQUFNLEtBQUs7QUFDWCxnQkFBSSxDQUFDO0FBQVMsY0FBQUEsV0FBVSxTQUFTRSxlQUFXO0FBQzFDLG1CQUFHLEdBQUcsTUFBTSxZQUFZLFVBQVU7QUFDbEMsbUJBQUcsR0FBRyxNQUFNLFlBQVlBLFlBQVc7ZUFDcEM7O1NBRUo7O0tBRUo7QUFHRCxTQUFLLGFBQWEsNEJBQTRCLElBQUk7QUFDbEQsU0FBSyxRQUFRLHVCQUF1QixJQUFJO0FBQ3hDLFNBQUssY0FBYyw2QkFBNkIsSUFBSTtBQUNwRCxTQUFLLFVBQVUseUJBQXlCLElBQUk7QUFDNUMsU0FBSyxjQUFjLDZCQUE2QixJQUFJO0FBS3BELFNBQUssR0FBRyxpQkFBaUIsUUFBRTtBQUt6QixVQUFJLEdBQUcsYUFBYTtBQUNsQixnQkFBUSxLQUFLLGlEQUFpRCxLQUFLLDhDQUE4Qzs7QUFFakgsZ0JBQVEsS0FBSyxnREFBZ0QsS0FBSyxxREFBcUQ7QUFDekgsV0FBSyxNQUFLO0tBT1g7QUFDRCxTQUFLLEdBQUcsV0FBVyxRQUFFO0FBQ25CLFVBQUksQ0FBQyxHQUFHLGNBQWMsR0FBRyxhQUFhLEdBQUc7QUFDdkMsZ0JBQVEsS0FBSyxpQkFBaUIsS0FBSyxvQkFBb0I7O0FBRXZELGdCQUFRLEtBQUssWUFBWSxLQUFLLHFEQUFxRCxHQUFHLGFBQWEsSUFBSTtLQUMxRztBQUVELFNBQUssVUFBVSxVQUFVLFFBQVEsV0FBaUM7QUFFbEUsU0FBSyxxQkFBcUIsQ0FDeEIsTUFDQSxZQUNBLFVBQ0Esc0JBQW9DLElBQUksS0FBSyxZQUFZLE1BQU0sWUFBWSxVQUFVLEtBQUssU0FBUyw2QkFBNkIsaUJBQWlCO0FBRW5KLFNBQUssaUJBQWlCLFFBQUU7QUFDdEIsV0FBSyxHQUFHLFNBQVMsRUFBRSxLQUFLLEVBQUU7QUFFMUIsa0JBQ0csT0FBTyxPQUFLLEVBQUUsU0FBUyxLQUFLLFFBQVEsTUFBTSxRQUFRLENBQUMsRUFBRSxPQUFPLE9BQU8sRUFDbkUsSUFBSSxPQUFLLEVBQUUsR0FBRyxlQUFlLEVBQUUsS0FBSyxFQUFFLENBQUM7O0FBSTVDLFNBQUssSUFBSSxzQkFBc0I7QUFDL0IsU0FBSyxJQUFJLGVBQWU7QUFDeEIsU0FBSyxJQUFJLHVCQUF1QjtBQUNoQyxTQUFLLElBQUksNkJBQTZCO0FBRXRDLFNBQUssTUFBTSxPQUFPLE9BQU8sTUFBTSxFQUFDLE1BQU0sRUFBQyxPQUFPLEtBQUksRUFBQyxDQUFDO0FBR3BELFdBQU8sUUFBUSxXQUFTLE1BQU0sSUFBSSxDQUFDOztFQUdyQyxRQUFRLGVBQXFCO0FBQzNCLFFBQUksTUFBTSxhQUFhLEtBQUssZ0JBQWdCO0FBQUssWUFBTSxJQUFJLFdBQVcsS0FBSyx3Q0FBd0M7QUFDbkgsb0JBQWdCLEtBQUssTUFBTSxnQkFBZ0IsRUFBRSxJQUFJO0FBQ2pELFFBQUksS0FBSyxTQUFTLEtBQUssT0FBTztBQUM1QixZQUFNLElBQUksV0FBVyxPQUFPLDBDQUEwQztBQUN4RSxTQUFLLFFBQVEsS0FBSyxJQUFJLEtBQUssT0FBTyxhQUFhO0FBQy9DLFVBQU0sV0FBVyxLQUFLO0FBQ3RCLFFBQUksa0JBQWtCLFNBQVMsT0FDN0IsT0FBSyxFQUFFLEtBQUssWUFBWSxhQUFhLEVBQUUsQ0FBQztBQUMxQyxRQUFJO0FBQWlCLGFBQU87QUFDNUIsc0JBQWtCLElBQUksS0FBSyxRQUFRLGFBQWE7QUFDaEQsYUFBUyxLQUFLLGVBQWU7QUFDN0IsYUFBUyxLQUFLLGlCQUFpQjtBQUMvQixvQkFBZ0IsT0FBTyxDQUFBLENBQUU7QUFFekIsU0FBSyxPQUFPLGFBQWE7QUFDekIsV0FBTzs7RUFHVCxXQUFjLElBQW9CO0FBQ2hDLFdBQVEsS0FBSyxVQUFVLEtBQUssT0FBTyxnQkFBZ0IsSUFBSSxjQUFjLEtBQUssUUFBUyxHQUFFLElBQUssSUFBSTNDLGFBQVcsQ0FBQ0wsVUFBU0MsWUFBTTtBQUN2SCxVQUFJLEtBQUssT0FBTyxjQUFjO0FBRzVCLGVBQU9BLFFBQU8sSUFBSSxXQUFXLGVBQWUsS0FBSyxPQUFPLFdBQVcsQ0FBQzs7QUFFdEUsVUFBSSxDQUFDLEtBQUssT0FBTyxlQUFlO0FBQzlCLFlBQUksQ0FBQyxLQUFLLFNBQVMsVUFBVTtBQUMzQixVQUFBQSxRQUFPLElBQUksV0FBVyxlQUFjLENBQUU7QUFDdEM7O0FBRUYsYUFBSyxLQUFJLEVBQUcsTUFBTUYsSUFBRzs7QUFFdkIsV0FBSyxPQUFPLGVBQWUsS0FBS0MsVUFBU0MsT0FBTTtLQUNoRCxFQUFFLEtBQUssRUFBRTs7RUFHWixJQUFJLEVBQUMsT0FBTyxRQUFBZ0MsU0FBUSxPQUFPLEtBQUksR0FBcUI7QUFDbEQsUUFBSTtBQUFNLFdBQUssTUFBTSxFQUFDLE9BQU8sS0FBSSxDQUFDO0FBQ2xDLFVBQU0sY0FBYyxLQUFLLGFBQWEsS0FBSyxNQUFNLEtBQUssYUFBYSxLQUFLLElBQUksQ0FBQTtBQUM1RSxnQkFBWSxLQUFLLEVBQUMsT0FBTyxRQUFBQSxTQUFRLE9BQU8sU0FBUyxPQUFPLEtBQUssT0FBTyxLQUFJLENBQUM7QUFDekUsZ0JBQVksS0FBSyxDQUFDLEdBQUcsTUFBTSxFQUFFLFFBQVEsRUFBRSxLQUFLO0FBRzVDLFdBQU87O0VBS1QsTUFBTSxFQUFDLE9BQU8sTUFBTSxRQUFBQSxRQUFNLEdBQStEO0FBQ3ZGLFFBQUksU0FBUyxLQUFLLGFBQWEsS0FBSyxHQUFHO0FBQ3JDLFdBQUssYUFBYSxLQUFLLElBQUksS0FBSyxhQUFhLEtBQUssRUFBRSxPQUFPLFFBQ3pEQSxVQUFTLEdBQUcsV0FBV0EsVUFDdkIsT0FBTyxHQUFHLFNBQVMsT0FDbkIsS0FBSzs7QUFFVCxXQUFPOztFQUdULE9BQUk7QUFDRixXQUFPLFVBQVUsSUFBSTs7RUFHdkIsU0FBTTtBQUNKLFVBQU0sUUFBUSxLQUFLO0FBQ25CLFVBQU0sTUFBTSxZQUFZLFFBQVEsSUFBSTtBQUNwQyxRQUFJLE9BQU87QUFBRyxrQkFBWSxPQUFPLEtBQUssQ0FBQztBQUN2QyxRQUFJLEtBQUssT0FBTztBQUNkLFVBQUk7QUFBRSxhQUFLLE1BQU0sTUFBSztlQUFhLEdBQVA7TUFBVTtBQUN0QyxXQUFLLE9BQU8sUUFBUTs7QUFHdEIsVUFBTSxpQkFBaUIsSUFBSTVCLGFBQVEsQ0FBQUwsYUFBTztBQUN4QyxZQUFNLGlCQUFpQkE7S0FDeEI7QUFDRCxVQUFNLGdCQUFnQixJQUFJSyxhQUFRLENBQUMsR0FBR0osWUFBTTtBQUMxQyxZQUFNLGFBQWFBO0tBQ3BCOztFQUdILFFBQUs7QUFDSCxTQUFLLE9BQU07QUFDWCxVQUFNLFFBQVEsS0FBSztBQUNuQixTQUFLLFNBQVMsV0FBVztBQUN6QixVQUFNLGNBQWMsSUFBSSxXQUFXLGVBQWM7QUFDakQsUUFBSSxNQUFNO0FBQ1IsWUFBTSxXQUFXLE1BQU0sV0FBVzs7RUFHdEMsU0FBTTtBQUNKLFVBQU0sZUFBZSxVQUFVLFNBQVM7QUFDeEMsVUFBTSxRQUFRLEtBQUs7QUFDbkIsV0FBTyxJQUFJSSxhQUFRLENBQUNMLFVBQVNDLFlBQU07QUFDakMsWUFBTSxXQUFXLE1BQUE7QUFDZixhQUFLLE1BQUs7QUFDVixZQUFJLE1BQU0sS0FBSyxNQUFNLFVBQVUsZUFBZSxLQUFLLElBQUk7QUFDdkQsWUFBSSxZQUFZLEtBQUssTUFBQTtBQUNuQiw2QkFBbUIsS0FBSyxPQUFPLEtBQUssSUFBSTtBQUN4QyxVQUFBRCxTQUFPO1NBQ1I7QUFDRCxZQUFJLFVBQVUsbUJBQW1CQyxPQUFNO0FBQ3ZDLFlBQUksWUFBWSxLQUFLOztBQUd2QixVQUFJO0FBQWMsY0FBTSxJQUFJLFdBQVcsZ0JBQWdCLHNDQUFzQztBQUM3RixVQUFJLE1BQU0sZUFBZTtBQUN2QixjQUFNLGVBQWUsS0FBSyxRQUFRO2FBQzdCO0FBQ0wsaUJBQVE7O0tBRVg7O0VBR0gsWUFBUztBQUNQLFdBQU8sS0FBSzs7RUFHZCxTQUFNO0FBQ0osV0FBTyxLQUFLLFVBQVU7O0VBR3hCLGdCQUFhO0FBQ1gsVUFBTSxjQUFjLEtBQUssT0FBTztBQUNoQyxXQUFPLGVBQWdCLFlBQVksU0FBUzs7RUFHOUMsWUFBUztBQUNQLFdBQU8sS0FBSyxPQUFPLGdCQUFnQjs7RUFHckMsb0JBQWlCO0FBQ2YsV0FBTyxLQUFLLE9BQU87O0VBR3JCLElBQUksU0FBTTtBQUNSLFdBQU9SLE1BQUssS0FBSyxVQUFVLEVBQUUsSUFBSSxVQUFRLEtBQUssV0FBVyxJQUFJLENBQUM7O0VBR2hFLGNBQVc7QUFDVCxVQUFNRSxRQUFPLHVCQUF1QixNQUFNLE1BQU0sU0FBUztBQUN6RCxXQUFPLEtBQUssYUFBYSxNQUFNLE1BQU1BLEtBQUk7O0VBRzNDLGFBQWEsTUFBdUIsUUFBZ0MsV0FBbUI7QUFDckYsUUFBSSxvQkFBb0IsSUFBSTtBQUU1QixRQUFJLENBQUMscUJBQXFCLGtCQUFrQixPQUFPLFFBQVEsS0FBSyxRQUFRLEdBQUcsTUFBTTtBQUFJLDBCQUFvQjtBQUN6RyxVQUFNLG1CQUFtQixLQUFLLFFBQVEsR0FBRyxNQUFNO0FBQy9DLFdBQU8sS0FBSyxRQUFRLEtBQUssRUFBRSxFQUFFLFFBQVEsS0FBSyxFQUFFO0FBQzVDLFFBQUksU0FDQTtBQUVKLFFBQUk7QUFJQSxtQkFBYSxPQUFPLElBQUksV0FBSztBQUN6QixZQUFJLFlBQVksaUJBQWlCLEtBQUssUUFBUSxNQUFNLE9BQU87QUFDM0QsWUFBSSxPQUFPLGNBQWM7QUFBVSxnQkFBTSxJQUFJLFVBQVUsaUZBQWlGO0FBQ3hJLGVBQU87T0FDVjtBQUtELFVBQUksUUFBUSxPQUFPLFNBQVM7QUFDMUIsa0JBQVU7ZUFDSCxRQUFRLFFBQVEsUUFBUTtBQUMvQixrQkFBVTs7QUFFUixjQUFNLElBQUksV0FBVyxnQkFBZ0IsK0JBQStCLElBQUk7QUFFNUUsVUFBSSxtQkFBbUI7QUFFbkIsWUFBSSxrQkFBa0IsU0FBUyxZQUFZLFlBQVksV0FBVztBQUM5RCxjQUFJLGtCQUFrQjtBQUVsQixnQ0FBb0I7O0FBRW5CLGtCQUFNLElBQUksV0FBVyxlQUFlLHdGQUF3Rjs7QUFFckksWUFBSSxtQkFBbUI7QUFDbkIscUJBQVcsUUFBUSxlQUFTO0FBQ3hCLGdCQUFJLHFCQUFxQixrQkFBa0IsV0FBVyxRQUFRLFNBQVMsTUFBTSxJQUFJO0FBQzdFLGtCQUFJLGtCQUFrQjtBQUVsQixvQ0FBb0I7O0FBRW5CLHNCQUFNLElBQUksV0FBVyxlQUFlLFdBQVcsWUFDaEQsc0NBQXNDOztXQUVqRDs7QUFFTCxZQUFJLG9CQUFvQixxQkFBcUIsQ0FBQyxrQkFBa0IsUUFBUTtBQUVwRSw4QkFBb0I7OzthQUd2QixHQUFQO0FBQ0UsYUFBTyxvQkFDSCxrQkFBa0IsU0FBUyxNQUFNLENBQUMsR0FBR00sWUFBTTtBQUFNLFFBQUFBLFFBQU8sQ0FBQztNQUFFLENBQUMsSUFDNUQsVUFBVyxDQUFDOztBQUdwQixVQUFNLG1CQUFtQixzQkFBc0IsS0FBSyxNQUFNLE1BQU0sU0FBUyxZQUFZLG1CQUFtQixTQUFTO0FBQ2pILFdBQVEsb0JBQ0osa0JBQWtCLFNBQVMsU0FBUyxrQkFBa0IsTUFBTSxJQUM1RCxJQUFJLFFBSUEsT0FBTyxJQUFJLFdBQVcsTUFBSSxLQUFLLFdBQVcsZ0JBQWdCLENBQUMsSUFDM0QsS0FBSyxXQUFZLGdCQUFnQjs7RUFLM0MsTUFBTSxXQUFpQjtBQUNyQixRQUFJLENBQUMsT0FBTyxLQUFLLFlBQVksU0FBUyxHQUFHO0FBQ3ZDLFlBQU0sSUFBSSxXQUFXLGFBQWEsU0FBUywwQkFBMEI7O0FBQ3ZFLFdBQU8sS0FBSyxXQUFXLFNBQVM7OztBQ3RicEMsSUFBTSxtQkFDSixPQUFPLFdBQVcsZUFBZSxnQkFBZ0IsU0FDN0MsT0FBTyxhQUNQO0lBRU9nRCxvQkFBVTtFQUtyQixZQUFZSCxZQUFrRDtBQUM1RCxTQUFLLGFBQWFBOztFQVNwQixVQUFVLEdBQVMsT0FBYSxVQUFjO0FBQzVDLFdBQU8sS0FBSyxXQUNWLENBQUMsS0FBSyxPQUFPLE1BQU0sYUFBYSxFQUFFLE1BQU0sR0FBRyxPQUFPLFNBQVEsSUFBSyxDQUFDOztFQUlwRSxDQUFDLGdCQUFnQixJQUFDO0FBQ2hCLFdBQU87OztTQzdCSyx1QkFDZCxRQUNBLFFBQXdCO0FBRXhCLEVBQUFyRCxNQUFLLE1BQU0sRUFBRSxRQUFRLFVBQUk7QUFDdkIsVUFBTSxXQUFXLE9BQU8sSUFBSSxNQUFNLE9BQU8sSUFBSSxJQUFJLElBQUlpRCxVQUFRO0FBQzdELGdCQUFZLFVBQVUsT0FBTyxJQUFJLENBQUM7R0FDbkM7QUFDRCxTQUFPO0FBQ1Q7U0NLZ0IsVUFBYSxTQUE2QjtBQUN4RCxNQUFJLFdBQVc7QUFDZixNQUFJLGVBQWtCO0FBQ3RCLFFBQU0sYUFBYSxJQUFJTyxZQUFjLENBQUMsYUFBUTtBQUM1QyxVQUFNLG1CQUFtQixnQkFBZ0IsT0FBTztBQUNoRCxhQUFTLFFBQVEsUUFBd0I7QUFDdkMsVUFBSSxrQkFBa0I7QUFDcEIsZ0NBQXVCOztBQUV6QixZQUFNLE9BQU8sTUFBTSxTQUFTLFNBQVMsRUFBRSxRQUFRLE9BQU8sS0FBSSxDQUFFO0FBQzVELFlBQU0sS0FBSyxJQUFJLFFBRVgsT0FBTyxJQUFJLFdBQVcsSUFBSSxJQUMxQixLQUFJO0FBQ1IsVUFBSSxrQkFBa0I7QUFDbkIsV0FBb0IsS0FDbkIseUJBQ0EsdUJBQXVCOztBQUczQixhQUFPOztBQUdULFFBQUksU0FBUztBQUViLFFBQUksWUFBOEIsQ0FBQTtBQUNsQyxRQUFJLGFBQStCLENBQUE7QUFFbkMsVUFBTSxlQUE2QjtNQUNqQyxJQUFJLFNBQU07QUFDUixlQUFPOztNQUVULGFBQWEsTUFBQTtBQUNYLGlCQUFTO0FBQ1QscUJBQWEsZUFBZSxZQUFZLGdCQUFnQjs7O0FBSTVELGFBQVMsU0FBUyxTQUFTLE1BQU0sWUFBWTtBQUU3QyxRQUFJLFdBQVcsT0FDYixtQkFBbUI7QUFFckIsYUFBUyxlQUFZO0FBQ25CLGFBQU94RCxNQUFLLFVBQVUsRUFBRSxLQUN0QixDQUFDLFFBQ0MsVUFBVSxHQUFHLEtBQUssY0FBYyxVQUFVLEdBQUcsR0FBRyxXQUFXLEdBQUcsQ0FBQyxDQUFDOztBQUl0RSxVQUFNLG1CQUFtQixDQUFDLFVBQXVCO0FBQy9DLDZCQUF1QixXQUFXLEtBQUs7QUFDdkMsVUFBSSxhQUFZLEdBQUk7QUFDbEIsZ0JBQU87OztBQUlYLFVBQU0sVUFBVSxNQUFBO0FBQ2QsVUFBSSxZQUFZO0FBQVE7QUFDeEIsa0JBQVksQ0FBQTtBQUNaLFlBQU0sU0FBMkIsQ0FBQTtBQUNqQyxZQUFNLE1BQU0sUUFBUSxNQUFNO0FBQzFCLFVBQUksQ0FBQyxrQkFBa0I7QUFDckIscUJBQWEsa0NBQWtDLGdCQUFnQjtBQUMvRCwyQkFBbUI7O0FBRXJCLGlCQUFXO0FBQ1gsY0FBUSxRQUFRLEdBQUcsRUFBRSxLQUNuQixDQUFDLFdBQU07QUFDTCxtQkFBVztBQUNYLHVCQUFlO0FBQ2YsbUJBQVc7QUFDWCxZQUFJO0FBQVE7QUFDWixZQUFJLGFBQVksR0FBSTtBQUVsQixrQkFBTztlQUNGO0FBQ0wsc0JBQVksQ0FBQTtBQUVaLHVCQUFhO0FBQ2IsbUJBQVMsUUFBUSxTQUFTLEtBQUssTUFBTTs7U0FHekMsQ0FBQyxRQUFHO0FBQ0YsbUJBQVc7QUFDWCxtQkFBVztBQUNYLGlCQUFTLFNBQVMsU0FBUyxNQUFNLEdBQUc7QUFDcEMscUJBQWEsWUFBVztPQUN6Qjs7QUFJTCxZQUFPO0FBQ1AsV0FBTztHQUNSO0FBQ0QsYUFBVyxXQUFXLE1BQU07QUFDNUIsYUFBVyxXQUFXLE1BQU07QUFDNUIsU0FBTztBQUNUO0FDakhPLElBQUk7QUFFWCxJQUFJO0FBQ0YsWUFBVTtJQUVSLFdBQVcsUUFBUSxhQUFhLFFBQVEsZ0JBQWdCLFFBQVEsbUJBQW1CLFFBQVE7SUFDM0YsYUFBYSxRQUFRLGVBQWUsUUFBUTs7U0FFdkMsR0FBUDtBQUNBLFlBQVUsRUFBRSxXQUFXLE1BQU0sYUFBYSxLQUFJOztBQ3lCaEQsSUFBTSxRQUFReUQ7QUFLZCxNQUFNLE9BQU87RUFJWCxHQUFHO0VBS0gsT0FBTyxjQUFvQjtBQUN6QixVQUFNLEtBQUssSUFBSSxNQUFNLGNBQWMsRUFBQyxRQUFRLENBQUEsRUFBRSxDQUFDO0FBQy9DLFdBQU8sR0FBRyxPQUFNOztFQU1sQixPQUFPLE1BQVk7QUFDakIsV0FBTyxJQUFJLE1BQU0sTUFBTSxFQUFFLFFBQVEsQ0FBQSxFQUFFLENBQUUsRUFBRSxLQUFJLEVBQUcsS0FBSyxRQUFFO0FBQ25ELFNBQUcsTUFBSztBQUNSLGFBQU87S0FDUixFQUFFLE1BQU0sdUJBQXVCLE1BQU0sS0FBSzs7RUFNN0MsaUJBQWlCLElBQUU7QUFDakIsUUFBSTtBQUNGLGFBQU8saUJBQWlCLE1BQU0sWUFBWSxFQUFFLEtBQUssRUFBRTthQUNuRCxJQUFBO0FBQ0EsYUFBTyxVQUFVLElBQUksV0FBVyxXQUFVLENBQUU7OztFQUtoRCxjQUFXO0FBQ1QsYUFBUyxNQUFNLFNBQU87QUFDcEIsYUFBTyxNQUFNLE9BQU87O0FBRXRCLFdBQU87O0VBR1Qsa0JBQWtCLFdBQVM7QUFzQnpCLFdBQU8sSUFBSSxRQUNULE9BQU8sSUFBSSxXQUFXLFNBQVMsSUFDL0IsVUFBUzs7RUFHYjtFQUVBLE9BQU8sU0FBVSxhQUFxQjtBQUNwQyxXQUFPLFdBQUE7QUFDTCxVQUFJO0FBQ0YsWUFBSSxLQUFLLGNBQWMsWUFBWSxNQUFNLE1BQU0sU0FBUyxDQUFDO0FBQ3pELFlBQUksQ0FBQyxNQUFNLE9BQU8sR0FBRyxTQUFTO0FBQzVCLGlCQUFPN0MsYUFBUSxRQUFRLEVBQUU7QUFDM0IsZUFBTztlQUNBLEdBQVA7QUFDQSxlQUFPLFVBQVUsQ0FBQzs7OztFQUt4QixPQUFPLFNBQVUsYUFBYVYsT0FBTSxNQUFJO0FBQ3RDLFFBQUk7QUFDRixVQUFJLEtBQUssY0FBYyxZQUFZLE1BQU0sTUFBTUEsU0FBUSxDQUFBLENBQUUsQ0FBQztBQUMxRCxVQUFJLENBQUMsTUFBTSxPQUFPLEdBQUcsU0FBUztBQUM1QixlQUFPVSxhQUFRLFFBQVEsRUFBRTtBQUMzQixhQUFPO2FBQ0EsR0FBUDtBQUNBLGFBQU8sVUFBVSxDQUFDOzs7RUFLdEIsb0JBQW9CO0lBQ2xCLEtBQUssTUFBTSxJQUFJLFNBQVM7O0VBRzFCLFNBQVMsU0FBVSxtQkFBbUIsaUJBQWU7QUFFbkQsVUFBTSxVQUFVQSxhQUFRLFFBQ3RCLE9BQU8sc0JBQXNCLGFBQzNCLE1BQU0sa0JBQWtCLGlCQUFpQixJQUN6QyxpQkFBaUIsRUFDbEIsUUFBUSxtQkFBbUIsR0FBSztBQUluQyxXQUFPLElBQUksUUFDVCxJQUFJLE1BQU0sUUFBUSxPQUFPLElBQ3pCOztFQUlKLFNBQVNBO0VBTVQsT0FBTztJQUNMLEtBQUssTUFBTWdDO0lBQ1gsS0FBSyxXQUFLO0FBQ1JjLGVBQWUsT0FBTyxVQUFVLFVBQVUsTUFBTSxPQUFPLHFCQUFxQjs7O0VBS2hGO0VBQ0E7RUFDQTtFQUNBO0VBRUE7RUFDQSxJQUFJO0VBQ0o7RUFDQTtFQUVBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0EsTUFBTXZEO0VBRU47RUFFQSxRQUFRLENBQUE7RUFFUjtFQUdBO0VBY0EsY0FBYztFQUdkLFFBQVE7RUFDUixTQUFTLGNBQWMsTUFBTSxHQUFHLEVBQzdCLElBQUksT0FBSyxTQUFTLENBQUMsQ0FBQyxFQUNwQixPQUFPLENBQUMsR0FBRyxHQUFHLE1BQU0sSUFBSyxJQUFJLEtBQUssSUFBSSxJQUFJLElBQUksQ0FBQyxDQUFFO0NBWXJEO0FBRUQsTUFBTSxTQUFTLFVBQVUsTUFBTSxhQUFhLFdBQVc7QUNyT3ZELElBQUksT0FBTyxrQkFBa0IsZUFBZSxPQUFPLHFCQUFxQixhQUFhO0FBQ25GLGVBQWEsa0NBQWtDLGtCQUFZO0FBQ3pELFFBQUksQ0FBQyxvQkFBb0I7QUFDdkIsVUFBSTtBQUNKLFVBQUksWUFBWTtBQUNkLGdCQUFRLFNBQVMsWUFBWSxhQUFhO0FBQzFDLGNBQU0sZ0JBQWdCLGdDQUFnQyxNQUFNLE1BQU0sWUFBWTthQUN6RTtBQUNMLGdCQUFRLElBQUksWUFBWSxnQ0FBZ0M7VUFDdEQsUUFBUTtTQUNUOztBQUVILDJCQUFxQjtBQUNyQixvQkFBYyxLQUFLO0FBQ25CLDJCQUFxQjs7R0FFeEI7QUFDRCxtQkFBaUIsZ0NBQWdDLENBQUMsRUFBQyxPQUFNLE1BQWdDO0FBQ3ZGLFFBQUksQ0FBQyxvQkFBb0I7QUFDdkIsdUJBQWlCLE1BQU07O0dBRTFCOztTQUdhLGlCQUFpQixhQUE2QjtBQUM1RCxNQUFJLFFBQVE7QUFDWixNQUFJO0FBQ0YseUJBQXFCO0FBQ3JCLGlCQUFhLGVBQWUsS0FBSyxXQUFXOztBQUU1Qyx5QkFBcUI7O0FBRXpCO0FBRU8sSUFBSSxxQkFBcUI7QUMvQmhDLElBQUksT0FBTyxxQkFBcUIsYUFBYTtBQUMzQyxRQUFNLEtBQUssSUFBSSxpQkFBaUIsOEJBQThCO0FBVTlELE1BQUksT0FBUSxHQUFXLFVBQVUsWUFBWTtBQUMxQyxPQUFXLE1BQUs7O0FBTW5CLGVBQWEsa0NBQWtDLENBQUMsaUJBQVk7QUFDMUQsUUFBSSxDQUFDLG9CQUFvQjtBQUN2QixTQUFHLFlBQVksWUFBWTs7R0FFOUI7QUFLRCxLQUFHLFlBQVksQ0FBQyxPQUFFO0FBQ2hCLFFBQUksR0FBRztBQUFNLHVCQUFpQixHQUFHLElBQUk7O1dBRTlCLE9BQU8sU0FBUyxlQUFlLE9BQU8sY0FBYyxhQUFhO0FBTzFFLGVBQWEsa0NBQWtDLENBQUMsaUJBQVk7QUFDMUQsUUFBSTtBQUNGLFVBQUksQ0FBQyxvQkFBb0I7QUFDdkIsWUFBSSxPQUFPLGlCQUFpQixhQUFhO0FBRXZDLHVCQUFhLFFBQ1gsZ0NBQ0EsS0FBSyxVQUFVO1lBQ2IsTUFBTSxLQUFLLE9BQU07WUFDakI7V0FDRCxDQUFDOztBQUdOLFlBQUksT0FBTyxLQUFLLFNBQVMsTUFBTSxVQUFVO0FBRXZDLFdBQUMsR0FBRyxLQUFLLFNBQVMsRUFBRSxTQUFTLEVBQUUscUJBQXFCLEtBQUksQ0FBRSxDQUFDLEVBQUUsUUFDM0QsQ0FBQyxXQUNDLE9BQU8sWUFBWTtZQUNqQixNQUFNO1lBQ047V0FDRCxDQUFDOzs7YUFJVixJQUFBO0lBQU07R0FDVDtBQUtELE1BQUksT0FBTyxxQkFBcUIsYUFBYTtBQUN6QyxxQkFBaUIsV0FBVyxDQUFDLE9BQWdCO0FBQzdDLFVBQUksR0FBRyxRQUFRLGdDQUFnQztBQUM3QyxjQUFNLE9BQU8sS0FBSyxNQUFNLEdBQUcsUUFBUTtBQUNuQyxZQUFJO0FBQU0sMkJBQWlCLEtBQUssWUFBWTs7S0FFL0M7O0FBTUgsUUFBTSxjQUFjLEtBQUssWUFBWSxVQUFVO0FBQy9DLE1BQUksYUFBYTtBQUVmLGdCQUFZLGlCQUFpQixXQUFXLHVCQUF1Qjs7O0FBSW5FLFNBQVMsd0JBQXdCLEVBQUUsS0FBSSxHQUFnQjtBQUNyRCxNQUFJLFFBQVEsS0FBSyxTQUFTLGdDQUFnQztBQUN4RCxxQkFBaUIsS0FBSyxZQUFZOztBQUV0QztBQ2hGQSxhQUFhLGtCQUFrQjtBQUcvQnVELFNBQWVkLE9BQWEscUJBQXFCOzs7QUNMMUMsSUFBTSwrQkFBTixNQUFtQztBQUFBLEVBU3hDLFlBQVksS0FBYTtBQUZ6QixvQkFBb0I7QUFHbEIsU0FBSyxNQUFNO0FBQ1gsU0FBSyxLQUFLLElBQUksUUFBTSxlQUFlLEtBQUssR0FBRztBQUMzQyxTQUFLLEdBQUcsUUFBUSxDQUFDLEVBQUUsT0FBTztBQUFBLE1BQ3hCLFlBQVk7QUFBQSxNQUNaLGVBQWU7QUFBQSxJQUNqQixDQUFDO0FBQ0QsU0FBSyxHQUFHLEdBQUcsU0FBUyxNQUFNO0FBQ3hCLFVBQUcsS0FBSyxVQUFVO0FBQ2hCLGFBQUssR0FBRyxLQUFLO0FBQUEsTUFDZjtBQUFBLElBQ0YsQ0FBQztBQUNELFNBQUssZ0JBQWdCLEtBQUssR0FBRyxXQUFXLFlBQVk7QUFDcEQsU0FBSyxjQUFjLEtBQUssR0FBRyxXQUFXLGVBQWU7QUFBQSxFQUN2RDtBQUFBLEVBRUEsUUFBTztBQUNMLFNBQUssV0FBVztBQUNoQixTQUFLLEdBQUcsTUFBTTtBQUFBLEVBQ2hCO0FBQUEsRUFFQSxJQUFJZSxNQUFtQjtBQUNyQixRQUFHQSxnQkFBZSxnQkFBZTtBQUMvQixhQUFPLEtBQUssY0FBYyxJQUFJO0FBQUEsUUFDNUIsTUFBTUEsS0FBSTtBQUFBLFFBQ1YsU0FBU0EsS0FBSTtBQUFBLFFBQ2IsZUFBZSxlQUFlO0FBQUEsTUFDaEMsQ0FBQztBQUFBLElBQ0g7QUFDQSxRQUFHQSxnQkFBZSxjQUFhO0FBQzdCLGFBQU8sS0FBSyxZQUFZLElBQUk7QUFBQSxRQUMxQixNQUFNQSxLQUFJO0FBQUEsUUFDVixTQUFTQSxLQUFJO0FBQUEsUUFDYixlQUFlLGVBQWU7QUFBQSxNQUNoQyxDQUFDO0FBQUEsSUFDSDtBQUFBLEVBQ0Y7QUFBQSxFQUVBLFVBQVVDLE9BQWM7QUFDdEIsV0FBTyxLQUFLLGNBQWMsT0FBT0EsS0FBSTtBQUFBLEVBQ3ZDO0FBQUEsRUFFQSxNQUFNLGFBQWFBLE9BQWM7QUFDL0IsV0FBTyxLQUFLLGNBQWMsSUFBSUEsS0FBSTtBQUFBLEVBQ3BDO0FBQUEsRUFFQSxhQUFhO0FBQ1gsV0FBTyxLQUFLLGNBQWMsUUFBUTtBQUFBLEVBQ3BDO0FBQUEsRUFFQSxhQUFhQSxPQUFjO0FBQ3pCLFdBQU8sS0FBSyxZQUFZLE9BQU9BLEtBQUk7QUFBQSxFQUNyQztBQUFBLEVBRUEsZ0JBQWdCO0FBQ2QsV0FBTyxLQUFLLFlBQVksUUFBUTtBQUFBLEVBQ2xDO0FBQUEsRUFFQSxNQUFNLGdCQUFnQkEsT0FBYztBQUNsQyxXQUFPLEtBQUssWUFBWSxJQUFJQSxLQUFJO0FBQUEsRUFDbEM7QUFBQSxFQUdBLE1BQU0sV0FBVztBQUNmLFdBQU8sVUFBVSxlQUFlLEtBQUssWUFBWSxJQUFJO0FBQ3JELFdBQU8sVUFBVSxlQUFlLEtBQUssY0FBYyxJQUFJO0FBQUEsRUFDekQ7QUFFRjs7O0E3RDdEQSxJQUFNLG1CQUEwQztBQUFBLEVBQzlDLFVBQVU7QUFBQSxFQUNWLGlCQUFpQjtBQUFBLEVBQ2pCLFlBQVk7QUFBQSxFQUNaLFlBQVk7QUFBQSxFQUNaLE1BQU07QUFBQSxFQUNOLFdBQVc7QUFBQSxFQUNYLFNBQVM7QUFBQSxFQUNULE1BQU07QUFBQSxFQUNOLE1BQU07QUFBQSxFQUNOLE1BQU07QUFBQSxJQUNKLE1BQU07QUFBQSxJQUNOLE9BQU87QUFBQSxFQUNUO0FBQUEsRUFDQSxVQUFVO0FBQUEsRUFDVixPQUFPO0FBQUEsRUFDUCxTQUFTO0FBQUEsRUFDVCxjQUFjO0FBQUEsSUFDWixPQUFPLG9CQUFJLElBQXdEO0FBQUEsSUFDbkUsU0FBUyxvQkFBSSxJQUF3RDtBQUFBLEVBQ3ZFO0FBQ0Y7QUFFQSxJQUFNLGlCQUFvQztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBVXhDLFVBQVU7QUFBQSxFQUNWLGlCQUFpQjtBQUFBLEVBQ2pCLFlBQVk7QUFBQSxFQUNaLFlBQVk7QUFBQSxFQUNaLE1BQU07QUFBQSxFQUNOLFdBQVc7QUFBQSxFQUNYLFNBQVM7QUFDWDtBQUVPLElBQU0sa0JBQWtCLE9BQU8sV0FBNEI7QUF6RWxFO0FBMEVFLFFBQU0sY0FBYyxNQUFNLFlBQVksTUFBTTtBQUU1QyxRQUFNLGNBQXdCLE9BQU8sT0FBTyxDQUFDLEdBQUcsa0JBQWtCLGFBQWEsZ0JBQWdCO0FBQUEsSUFDN0YsU0FBUyxPQUFPLFNBQVM7QUFBQSxFQUMzQixDQUFDO0FBRUQsY0FBWSxPQUFNLGdEQUFhLFFBQWIsWUFBb0IsT0FBTyxJQUFJO0FBRWpELFFBQU0sUUFBUSxZQUFZLGFBQWE7QUFDdkMsYUFBVyxPQUFPLE1BQU0sS0FBSyxHQUFHO0FBQzlCLFFBQUcsSUFBSSxTQUFTLElBQUksR0FBRztBQUNyQixZQUFNLFFBQUksZ0NBQWMsR0FBRyxHQUFHLE1BQU0sSUFBSSxHQUFHLENBQUU7QUFDN0MsWUFBTSxPQUFPLEdBQUc7QUFBQSxJQUNsQjtBQUFBLEVBQ0Y7QUFFQSxRQUFNLFVBQVUsWUFBWSxhQUFhO0FBQ3pDLGFBQVcsT0FBTyxRQUFRLEtBQUssR0FBRztBQUNoQyxRQUFHLElBQUksU0FBUyxJQUFJLEdBQUc7QUFDckIsY0FBUSxRQUFJLGdDQUFjLEdBQUcsR0FBRyxRQUFRLElBQUksR0FBRyxDQUFFO0FBQ2pELGNBQVEsT0FBTyxHQUFHO0FBQUEsSUFDcEI7QUFBQSxFQUNGO0FBRUEsT0FBSSwyQ0FBYSxRQUFPLFlBQVksYUFBYSxNQUFNLFNBQVMsS0FBSyxZQUFZLGFBQWEsUUFBUSxTQUFTLEdBQUc7QUFDaEgsVUFBTSxLQUFLLElBQUksNkJBQTZCLFlBQVksR0FBRztBQUMzRCxVQUFNLE9BQU8sTUFBTSxHQUFHLFdBQVc7QUFDakMsU0FBSyxRQUFRLENBQUFDLFNBQU87QUFDbEIsa0JBQVksYUFBYSxNQUFNLFFBQUksZ0NBQWNBLEtBQUksSUFBSSxHQUFHLEVBQUUsZUFBZUEsS0FBSSxlQUFlLFNBQVNBLEtBQUksUUFBUSxDQUFDO0FBQUEsSUFDeEgsQ0FBQztBQUNELFVBQU1DLFdBQVUsTUFBTSxHQUFHLGNBQWM7QUFDdkMsSUFBQUEsU0FBUSxRQUFRLENBQUFELFNBQU87QUFDckIsa0JBQVksYUFBYSxRQUFRLFFBQUksZ0NBQWNBLEtBQUksSUFBSSxHQUFHLEVBQUUsZUFBZUEsS0FBSSxlQUFlLFNBQVNBLEtBQUksUUFBUSxDQUFDO0FBQUEsSUFDMUgsQ0FBQztBQUNELGlCQUFhLGFBQWEsTUFBTTtBQUNoQyxVQUFNLEdBQUcsU0FBUztBQUFBLEVBQ3BCO0FBRUEsZUFBYSxhQUFhLE1BQU07QUFFaEMsTUFBSSxlQUFlLFlBQVksV0FBVyxZQUFZLFNBQVM7QUFDN0Qsa0JBQWMsT0FBTyxLQUFLLHFCQUFxQixtR0FBbUc7QUFBQSxFQUNwSjtBQUVBLFNBQU87QUFFVDtBQUVPLElBQU0sY0FBYyxPQUFPLFdBQW1CO0FBMUhyRDtBQTJIRSxRQUFNLFdBQVcsTUFBTSxPQUFPLFNBQVM7QUFDdkMsTUFBSSxVQUFVO0FBQ1osYUFBUyxlQUFlO0FBQUEsTUFDdEIsT0FBTyxJQUFJLEtBQUksY0FBUyxpQkFBVCxtQkFBdUIsS0FBSztBQUFBLE1BQzNDLFNBQVMsSUFBSSxLQUFJLGNBQVMsaUJBQVQsbUJBQXVCLE9BQU87QUFBQSxJQUNqRDtBQUFBLEVBQ0Y7QUFDQSxTQUFPO0FBQ1Q7QUFHTyxJQUFNLG1CQUFlLDJCQUFTLE9BQU8sVUFBb0IsV0FBNEI7QUFFMUYsUUFBTSxhQUFhLEtBQUssTUFBTSxLQUFLLFVBQVUsUUFBUSxDQUFDO0FBRXRELGFBQVcsZUFBZTtBQUFBLElBQ3hCLE9BQU8sTUFBTSxLQUFLLFNBQVMsYUFBYSxNQUFNLFFBQVEsQ0FBQztBQUFBLElBQ3ZELFNBQVMsTUFBTSxLQUFLLFNBQVMsYUFBYSxRQUFRLFFBQVEsQ0FBQztBQUFBLEVBQzdEO0FBRUEsU0FBTyxTQUFTLFVBQVU7QUFDNUIsR0FBRyxLQUFNLElBQUk7QUFFTixJQUFNLGlCQUFpQixPQUFPLElBQWlCLFdBQTRCO0FBQ2hGLEtBQUcsTUFBTTtBQUVULFFBQU0sV0FBVyxNQUFNLFlBQVksTUFBTTtBQUV6QyxLQUFHLFNBQVMsTUFBTSxFQUFFLE1BQU0sVUFBVSxDQUFDO0FBRXJDLE1BQUkseUJBQVEsRUFBRSxFQUNYLFFBQVEsY0FBYyxFQUN0QixRQUFRLCtDQUErQyxFQUN2RCxRQUFRLENBQUNFLFVBQVM7QUFDakIsSUFBQUEsTUFBSyxTQUFTLFNBQVMsSUFBSTtBQUMzQixJQUFBQSxNQUFLLFNBQVMsT0FBTyxVQUFVO0FBQzdCLGVBQVMsT0FBTztBQUNoQixtQkFBYSxVQUFVLE1BQU07QUFBQSxJQUMvQixDQUFDO0FBQUEsRUFDSCxDQUFDO0FBRUgsUUFBTSxjQUFjLElBQUkseUJBQVEsRUFBRTtBQUNsQyxjQUFZLFFBQVEsYUFBYTtBQUNqQyxjQUFZLFFBQVEsOEVBQThFO0FBQ2xHLGNBQVksUUFBUSxDQUFBQSxVQUFRO0FBQzFCLElBQUFBLE1BQUssU0FBUyxTQUFTLElBQUk7QUFDM0IsSUFBQUEsTUFBSyxTQUFTLE9BQU0sVUFBUztBQUMzQixlQUFTLE9BQU87QUFDaEIsbUJBQWEsVUFBVSxNQUFNO0FBQUEsSUFDL0IsQ0FBQztBQUVELGdCQUFZLGVBQWUsWUFBVTtBQUNuQyxhQUFPLFFBQVEsUUFBUTtBQUN2QixhQUFPLFFBQVEsWUFBWTtBQUN6QixjQUFNLFNBQVMsTUFBTSx5QkFBeUIsT0FBTyxHQUFHO0FBQ3hELFlBQUksUUFBUTtBQUNWLFVBQUFBLE1BQUssU0FBUyxPQUFPLElBQUk7QUFDekIsbUJBQVMsT0FBTyxPQUFPO0FBQ3ZCLHVCQUFhLFVBQVUsTUFBTTtBQUFBLFFBQy9CO0FBQUEsTUFDRixDQUFDO0FBQUEsSUFDSCxDQUFDO0FBQUEsRUFDSCxDQUFDO0FBR0QsS0FBRyxTQUFTLE1BQU0sRUFBRSxNQUFNLG9CQUFvQixDQUFDO0FBQy9DLE1BQUksU0FBUyxLQUFLLFNBQVMsU0FBUztBQUNsQyxPQUFHLFNBQVMsT0FBTyxFQUFFLE1BQU0sdUxBQXVMLENBQUM7QUFDbk4sT0FBRyxTQUFTLEdBQUc7QUFDZixPQUFHLFNBQVMsT0FBTyxFQUFFLE1BQU0sK0JBQStCLFNBQVMsMkJBQTJCLENBQUM7QUFDL0YsT0FBRyxTQUFTLEdBQUc7QUFFZixRQUFJLHlCQUFRLEVBQUUsRUFDWCxRQUFRLFdBQVcsRUFDbkIsVUFBVSxZQUFVO0FBQ25CLGFBQU8sY0FBYyx1QkFBdUI7QUFDNUMsYUFBTyxPQUFPO0FBQ2QsYUFBTyxRQUFRLENBQUMsTUFBTTtBQUNwQixlQUFPLEtBQUssc0NBQXNDLFNBQVMsS0FBSztBQUFBLE1BQ2xFLENBQUM7QUFBQSxJQUNILENBQUM7QUFFSCxRQUFJLGVBQWU7QUFDbkIsUUFBSSx5QkFBUSxFQUFFLEVBQ1gsUUFBUSwyQkFBMkIsRUFDbkMsUUFBUSwyR0FBMkcsRUFDbkgsUUFBUSxDQUFDQSxVQUFTO0FBQ2pCLE1BQUFBLE1BQUssZUFBZSxhQUFhO0FBQ2pDLE1BQUFBLE1BQUssU0FBUyxDQUFDLFVBQVU7QUFDdkIsdUJBQWU7QUFBQSxNQUNqQixDQUFDO0FBQUEsSUFDSCxDQUFDLEVBQ0EsVUFBVSxZQUFVO0FBQ25CLGFBQU8sY0FBYyxTQUFTO0FBQzlCLGFBQU8sUUFBUSxPQUFPLE1BQU07QUFDMUIsY0FBTSxPQUFPLFVBQU0sNkJBQVc7QUFBQSxVQUM1QixLQUFLLFNBQVM7QUFBQSxVQUNkLFFBQVE7QUFBQSxVQUNSLGFBQWE7QUFBQSxVQUNiLE1BQU0sS0FBSyxVQUFVO0FBQUEsWUFDbkIsT0FBTztBQUFBLFlBQ1AsS0FBSyxTQUFTO0FBQUEsVUFDaEIsQ0FBQztBQUFBLFFBRUgsQ0FBQyxFQUFFO0FBQ0gsWUFBSSxRQUFRLEtBQUssTUFBTTtBQUNyQixtQkFBUyxPQUFPLEtBQUs7QUFDckIsdUJBQWEsVUFBVSxNQUFNLEdBQzNCLE1BQU0sZUFBZSxJQUFJLE1BQU07QUFBQSxRQUNuQztBQUFBLE1BQ0YsQ0FBQztBQUFBLElBQ0gsQ0FBQztBQUFBLEVBRUwsV0FBVyxTQUFTLEtBQUssU0FBUyxnQkFBZ0I7QUFDaEQsT0FBRyxTQUFTLE9BQU8sRUFBRSxNQUFNLG9GQUFvRixDQUFDO0FBQ2hILE9BQUcsU0FBUyxHQUFHO0FBQ2YsT0FBRyxTQUFTLE9BQU8sRUFBRSxNQUFNLCtCQUErQixTQUFTLDJCQUEyQixDQUFDO0FBQy9GLE9BQUcsU0FBUyxHQUFHO0FBQUEsRUFDakI7QUFFQSxNQUFJLHlCQUFRLEVBQUUsRUFDWCxRQUFRLDJCQUEyQixFQUNuQyxRQUFRLHdHQUF3RyxFQUNoSCxVQUFVLENBQUMsV0FBVztBQUNyQixXQUFPLGNBQWMsU0FBUztBQUM5QixXQUFPLFFBQVEsT0FBTyxNQUFNO0FBQzFCLDhCQUF3QixNQUFNO0FBQzlCLHFCQUFlLElBQUksTUFBTTtBQUFBLElBQzNCLENBQUM7QUFBQSxFQUNILENBQUM7QUFFSCxLQUFHLFNBQVMsTUFBTSxFQUFFLE1BQU0sT0FBTyxDQUFDO0FBQ2xDLFFBQU0sTUFBTSxHQUFHLFVBQVU7QUFDekIsTUFBSSxXQUFXLEVBQUUsTUFBTSx5QkFBeUIsQ0FBQztBQUNqRCxNQUFJLFNBQVMsS0FBSztBQUFBLElBQ2hCLE1BQU07QUFBQSxJQUNOLE1BQU07QUFBQSxNQUNKLE1BQU07QUFBQSxJQUNSO0FBQUEsRUFDRixDQUFDO0FBQ0QsTUFBSSxXQUFXLEVBQUUsTUFBTSxJQUFJLENBQUM7QUFFOUI7QUFFTyxJQUFNLG9CQUFvQixDQUFDLFdBQTRCO0FBQzVELFNBQU8sSUFBSSxjQUFjLGtDQUFpQjtBQUFBLElBQ3hDLE1BQU0sVUFBVTtBQUNkLFlBQU0sZUFBZSxLQUFLLGFBQWEsTUFBTTtBQUFBLElBQy9DO0FBQUEsRUFDRixFQUFFLE9BQU8sS0FBSyxNQUFNO0FBQ3RCOzs7QThEM1FBLElBQUFDLG1CQUE4QjtBQVd2QixJQUFNLE1BQU0sT0FBT0MsTUFBbUIsV0FBNEI7QUFDdkUsTUFBSUEsZ0JBQWUsZ0JBQWdCO0FBQ2pDLFdBQU8sU0FBUyxhQUFhLE1BQU0sSUFBSUEsS0FBSSxNQUFNO0FBQUEsTUFDL0MsU0FBU0EsS0FBSTtBQUFBLE1BQ2IsZUFBZSxlQUFlO0FBQUEsSUFDaEMsQ0FBQztBQUFBLEVBQ0g7QUFDQSxNQUFJQSxnQkFBZSxjQUFjO0FBQy9CLFdBQU8sU0FBUyxhQUFhLFFBQVEsSUFBSUEsS0FBSSxNQUFNO0FBQUEsTUFDakQsU0FBU0EsS0FBSTtBQUFBLE1BQ2IsZUFBZSxlQUFlO0FBQUEsSUFDaEMsQ0FBQztBQUFBLEVBQ0g7QUFDQSxlQUFhLE9BQU8sVUFBVSxNQUFNO0FBQ3RDO0FBRU8sSUFBTSxZQUFZLE9BQU9DLE9BQWMsV0FBNEI7QUFDeEUsU0FBTyxTQUFTLGFBQWEsTUFBTSxXQUFPLGdDQUFjQSxLQUFJLENBQUM7QUFDN0QsZUFBYSxPQUFPLFVBQVUsTUFBTTtBQUN0QztBQUVPLElBQU0sZUFBZSxDQUFDQSxPQUFjLFdBQTRCO0FBQ3JFLFNBQU8sT0FBTyxTQUFTLGFBQWEsTUFBTSxJQUFJQSxLQUFJO0FBQ3BEO0FBRU8sSUFBTSxVQUFVLE9BQU8sU0FBaUIsU0FBaUIsV0FBNEI7QUFDMUYsUUFBTSxRQUFRLE9BQU8sU0FBUyxhQUFhO0FBQzNDLFFBQU0sUUFBUSxNQUFNLElBQUksT0FBTztBQUMvQixNQUFJLE9BQU87QUFDVCxVQUFNLE9BQU8sT0FBTztBQUNwQixVQUFNLElBQUksU0FBUyxLQUFLO0FBQ3hCLGlCQUFhLE9BQU8sVUFBVSxNQUFNO0FBQUEsRUFDdEM7QUFDRjtBQUVPLElBQU0sZUFBZSxPQUFPQSxPQUFjLFdBQTRCO0FBQzNFLFNBQU8sU0FBUyxhQUFhLFFBQVEsT0FBT0EsS0FBSTtBQUNoRCxlQUFhLE9BQU8sVUFBVSxNQUFNO0FBQ3RDO0FBRU8sSUFBTSxrQkFBa0IsQ0FBQ0EsT0FBYyxXQUE2QjtBQUN6RSxTQUFPLE9BQU8sU0FBUyxhQUFhLFFBQVEsSUFBSUEsS0FBSTtBQUN0RDtBQUVPLElBQU0sYUFBYSxPQUFPLFNBQWlCLFNBQWlCLFdBQTRCO0FBQzdGLFFBQU0sd0JBQW9CLGdDQUFjLE9BQU87QUFDL0MsUUFBTSx3QkFBb0IsZ0NBQWMsT0FBTztBQUMvQyxRQUFNLFFBQVEsT0FBTyxTQUFTLGFBQWE7QUFDM0MsUUFBTSxRQUFRLE1BQU0sSUFBSSxpQkFBaUI7QUFDekMsTUFBSSxPQUFPO0FBQ1QsVUFBTSxPQUFPLGlCQUFpQjtBQUM5QixVQUFNLElBQUksbUJBQW1CLEtBQUs7QUFDbEMsaUJBQWEsT0FBTyxVQUFVLE1BQU07QUFBQSxFQUN0QztBQUNGOzs7QS9EMURBLElBQU0sZUFBZSxDQUFDLElBQTBCLElBQW1CLFFBQXNCLFdBQTRCO0FBYnJIO0FBZUUsTUFBSSxDQUFFLENBQUMsT0FBTyxhQUFZLFlBQU8sbUJBQVAsbUJBQXVCLElBQUksRUFBRSxTQUFTLEdBQUcsTUFBTTtBQUFJO0FBRTdFLFFBQU0sY0FBYyxHQUFHLFFBQVE7QUFFL0IsY0FBWSxRQUFRLE9BQU8sTUFBTSxRQUFRO0FBQ3ZDLFdBQU8sSUFBSSxhQUFhLEtBQUssU0FBUyxTQUFTLE1BQU0sVUFBVSxHQUFHLElBQUksT0FBTyxXQUFXLEVBQUUsSUFBSSxHQUFHLENBQVc7QUFFNUcsUUFBSSxLQUFLLFdBQVcsT0FBTztBQUN6QixZQUFNLGVBQWUsR0FBRyxJQUFJLE9BQU8sV0FBVyxFQUFFLElBQUksR0FBRztBQUN2RCxZQUFNLGVBQW9CLFVBQUssT0FBTyxNQUFNLFlBQVk7QUFDeEQsWUFBTSxPQUFPLE9BQU8sSUFBSSxNQUFNLHNCQUFzQixZQUFZO0FBQ2hFLFVBQUksTUFBTTtBQUVSLG1CQUFXLFVBQVUsS0FBSyxPQUFPLDRCQUE0QjtBQUU3RCxjQUFNLGNBQW1CLFVBQVUsYUFBUSxZQUFZLEdBQVEsY0FBUyxjQUFtQixhQUFRLFlBQVksQ0FBQyxJQUFJLE1BQU0scUJBQXFCLElBQVMsYUFBUSxZQUFZLENBQUM7QUFDN0ssY0FBTSxzQkFBMkIsVUFBSyxPQUFPLEtBQUssTUFBTSxXQUFXO0FBQ25FLGVBQU8sZ0JBQWdCLEVBQUUsSUFBSSxLQUFLLFdBQVc7QUFDN0MsdUJBQWUsY0FBYyxLQUFLLHFCQUFxQixNQUFNO0FBQUEsTUFDL0QsT0FBTztBQUNMLG1CQUFXLG1DQUFtQyxZQUFZO0FBQzFELGNBQU0sYUFBYSxnQkFBcUIsV0FBTSxZQUFZLEVBQUUsS0FBSyxNQUFNO0FBQ3ZFLGNBQU0sZUFBZSxjQUFjLEtBQUssY0FBYyxNQUFNO0FBQUEsTUFDOUQ7QUFBQSxJQUNGLFdBQVcsS0FBSyxXQUFXLFVBQVU7QUFDbkMsWUFBTSxVQUFVLEdBQUcsSUFBSSxPQUFPLFdBQVcsRUFBRSxJQUFJLEdBQUc7QUFDbEQsWUFBTUMsWUFBVyxlQUFlLFNBQVMsR0FBRztBQUM1QyxVQUFJLENBQUNBO0FBQVU7QUFDZixhQUFPLElBQUksWUFBWUEsVUFBUyxPQUFPLFFBQVEsR0FBRztBQUNsRCxZQUFNQyxVQUFTLGFBQWEsMEJBQTBCRCxVQUFTLElBQUk7QUFDbkUsVUFBSSxDQUFDQztBQUFRO0FBQ2IsVUFBSSxrQkFBdUIsVUFBS0EsUUFBTyxLQUFLLE1BQU0sT0FBTztBQUN6RCxZQUFNLGFBQWEsZ0JBQXFCLFdBQU0sZUFBZSxFQUFFLEtBQUssTUFBTTtBQUUxRSxZQUFNLGdCQUFnQixlQUFlLFdBQVcsZUFBZTtBQUMvRCxVQUFJLGVBQWU7QUFDakIsbUJBQVcsVUFBVSxVQUFVLDRCQUE0QjtBQUMzRCxjQUFNLGNBQW1CLFVBQVUsYUFBUSxPQUFPLEdBQVEsY0FBUyxTQUFjLGFBQVEsT0FBTyxDQUFDLElBQUksTUFBTSxxQkFBcUIsSUFBUyxhQUFRLE9BQU8sQ0FBQztBQUN6SixjQUFNLHNCQUEyQixVQUFLQSxRQUFPLEtBQUssTUFBTSxXQUFXO0FBQ25FLFFBQUFBLFFBQU8sZ0JBQWdCLEVBQUUsSUFBSSxLQUFLLFdBQVc7QUFDN0MsdUJBQWUsY0FBYyxLQUFLLHFCQUFxQixNQUFNO0FBQUEsTUFDL0QsT0FBTztBQUNMLGNBQU0sT0FBTyxJQUFJLFlBQVksV0FBV0QsVUFBUyxNQUFNLGVBQWU7QUFBQSxNQUN4RTtBQUFBLElBQ0YsV0FBVyxLQUFLLFdBQVcsVUFBVTtBQUNuQyxZQUFNQSxZQUFXLGVBQWUsU0FBUyxHQUFHO0FBQzVDLFVBQUksQ0FBQ0E7QUFBVTtBQUNmLGFBQU8sSUFBSSxZQUFZQSxVQUFTLE9BQU8sUUFBUSxHQUFHO0FBQ2xELFlBQU0sT0FBTyxPQUFPLElBQUksTUFBTSxzQkFBc0JBLFVBQVMsSUFBSTtBQUNqRSxVQUFJLENBQUM7QUFBTTtBQUNYLGFBQU8sSUFBSSxNQUFNLE9BQU8sSUFBSTtBQUFBLElBQzlCO0FBQUEsRUFDRixDQUFDO0FBQ0g7QUFFTyxJQUFNLGdCQUFOLGNBQTJCLGFBQWE7QUFBQSxFQWtLckMsWUFBWSxNQUFlLFFBQXlCLE1BQWM7QUFDeEUsVUFBTSxNQUFNO0FBQ1osU0FBSyxPQUFPO0FBQ1osU0FBSyxRQUFRLEtBQUs7QUFDbEIsU0FBSyxPQUFPLHNCQUFRLElBQU0sSUFBSTtBQUM5QixTQUFLLGdCQUFnQixFQUFFLFFBQVEsQ0FBQyxJQUFJLE9BQU87QUFDekMsbUJBQWEsSUFBSSxJQUFJLE1BQU0sTUFBTTtBQUFBLElBQ25DLENBQUM7QUFDRCxTQUFLLEtBQUssR0FBRyxVQUFVLENBQUMsUUFBb0IsUUFBYSxNQUFhLE9BQXNCO0FBQzFGLFVBQUksR0FBRyxTQUFTLEtBQUssU0FBUztBQUM1QixlQUFPLFdBQVcsV0FBVyxNQUFNLE1BQU07QUFBQSxNQUMzQztBQUFBLElBQ0YsQ0FBQztBQUNELGtCQUFhLGVBQWUsS0FBSyxJQUFJO0FBQ3JDLHFCQUFpQixLQUFLLE1BQU0sTUFBTTtBQUFBLEVBQ3BDO0FBQUEsRUE1S0EsYUFBYSxZQUFZLE1BQWUsUUFBeUI7QUFDL0QsZUFBVyw0QkFBNEIsS0FBSyxPQUFPO0FBQ25ELFVBQU0sUUFBUSxLQUFLLG9CQUFvQixJQUFJO0FBRzNDLGVBQVcsUUFBUSxPQUFPO0FBQ3hCLFVBQUksZUFBZSxXQUFXLEtBQUssSUFBSSxHQUFHO0FBQ3hDLG1CQUFXLGdGQUFnRjtBQUMzRjtBQUFBLE1BQ0Y7QUFBQSxJQUNGO0FBRUEsVUFBTSxPQUFPLE1BQU0sUUFBUSxJQUFJLE1BQU0sSUFBSSxDQUFDLFNBQVM7QUFDakQsYUFBTyxlQUFlLFVBQVUsTUFBTTtBQUFBLFFBQ3BDLFdBQVc7QUFBQSxNQUNiLEdBQUcsTUFBTTtBQUFBLElBQ1gsQ0FBQyxDQUFDO0FBRUYsVUFBTSxTQUFTLElBQUksY0FBYSxNQUFNLE1BQU07QUFFNUMsZUFBV0UsUUFBTyxNQUFNO0FBQ3RCLFVBQUlBLE1BQUs7QUFDUCxlQUFPLFlBQVlBLElBQUc7QUFBQSxNQUN4QjtBQUFBLElBQ0Y7QUFFQSxXQUFPLEtBQUssUUFBUSxvQkFBb0IsRUFBRSxPQUFPLEdBQUcsS0FBSyxJQUFJO0FBRTdELFVBQU0sT0FBTyxlQUFlO0FBRTVCLFVBQU0sSUFBSSxRQUFRLE1BQU07QUFDeEIsVUFBTSxPQUFPLG1CQUFtQjtBQUNoQyxXQUFPLGdCQUFnQjtBQUV2QixjQUFVLFVBQVUsVUFBVSxPQUFPLFNBQVMsV0FBVyxXQUFXLE9BQU8sT0FBTztBQUNsRixlQUFXLFVBQVUsT0FBTyxhQUFhLEtBQUssMERBQTBELENBQUM7QUFFekcsV0FBTztBQUFBLEVBQ1Q7QUFBQSxFQUVBLGFBQWEsU0FBUyxRQUFzQixRQUF5QjtBQUNuRSxVQUFNQyxZQUFXLE9BQU8sS0FBSztBQUM3QixVQUFNLE9BQU8sUUFBUTtBQUNyQixVQUFNLE9BQU8sSUFBSSxNQUFNLE9BQU8sT0FBTyxNQUFNLElBQUk7QUFDL0MsV0FBTyxNQUFNLEtBQUssYUFBYSxPQUFPLFNBQVMsV0FBVyxXQUFXLE9BQU8sU0FBUyxRQUFRQSxTQUFRO0FBQUEsRUFDdkc7QUFBQSxFQUVBLGFBQWEsYUFBYSxLQUFhLFFBQXlCQSxXQUFpRDtBQUMvRyxVQUFNQyxNQUFLLElBQUksTUFBTSxHQUFHLEVBQUUsSUFBSTtBQUM5QixRQUFJLENBQUNBLE9BQU0sQ0FBQ0EsSUFBRyxNQUFNLGdFQUFnRSxHQUFHO0FBQ3RGLGlCQUFXLHlCQUF5QjtBQUNwQztBQUFBLElBQ0Y7QUFFQSxRQUFJLGFBQWFEO0FBQ2pCLFVBQU0sZ0JBQWdCLE1BQU0sT0FBTyxXQUFXLGdCQUFnQkMsR0FBRTtBQUdoRSxRQUFJLENBQUNELFdBQVU7QUFDYixVQUFJLGtCQUFrQiwwQkFBMEIscUJBQXFCO0FBQ3JFLFlBQU0sZ0JBQWdCLGNBQWMsUUFBUSxvQkFBb0IsRUFBRSxTQUFTO0FBQzNFLFVBQUksaUJBQWlCLElBQUk7QUFDdkIsY0FBTSxlQUFlLE9BQU8sSUFBSSxNQUFNLHNCQUEyQixVQUFLLE9BQU8sU0FBUyxNQUFNLGFBQWEsQ0FBQztBQUMxRyxZQUFJLENBQUMsY0FBYztBQUNqQiw0QkFBa0I7QUFBQSxRQUNwQixPQUFPO0FBQ0wsNEJBQWtCLGNBQWMscUJBQXFCLEtBQUs7QUFBQSxRQUM1RDtBQUFBLE1BQ0Y7QUFFQSxtQkFBa0IsVUFBSyxPQUFPLFNBQVMsTUFBTSxlQUFlO0FBQUEsSUFDOUQ7QUFFQSxVQUFNLFNBQVMsTUFBTSxjQUFhLGdCQUFnQixZQUFhLE1BQU07QUFFckUsUUFBSSxDQUFDLFFBQVE7QUFDWCxhQUFPLFdBQVcsNkJBQTZCLFVBQVU7QUFBQSxJQUMzRDtBQUFDO0FBRUQsVUFBTSxRQUF1QixDQUFDO0FBQzlCLFVBQU0sY0FBYyxjQUFjLE9BQU8sV0FBVztBQUVwRCxlQUFXLFNBQVMsWUFBWSxRQUFRLEdBQUc7QUFDekMsVUFBSSxVQUFVLE1BQU0sQ0FBQztBQUVyQixVQUFJLE1BQU0sYUFBUyxnQ0FBYyxPQUFPLENBQUMsR0FBRztBQUMxQyxzQkFBVSxnQ0FBbUIsVUFBVSxhQUFRLE9BQU8sR0FBUSxjQUFTLFNBQWMsYUFBUSxPQUFPLENBQUMsSUFBSSxNQUFNLHFCQUFxQixJQUFTLGFBQVEsT0FBTyxDQUFDLENBQUM7QUFDOUosb0JBQVksSUFBSSxNQUFNLENBQUMsR0FBRyxPQUFPO0FBQUEsTUFDbkM7QUFDQSxZQUFNLGVBQWUsY0FBYyxNQUFNLENBQUMsR0FBUSxVQUFLLFlBQWEsT0FBTyxHQUFHLE1BQU07QUFDcEYsWUFBTSxTQUFLLGdDQUFjLE9BQU8sQ0FBQztBQUFBLElBQ25DO0FBRUEsVUFBTSxVQUFVLElBQUksY0FBYSxRQUFRLFFBQVEsYUFBYTtBQUM5RCxZQUFRLFdBQVdDO0FBRW5CLFVBQU0sSUFBSSxTQUFTLE1BQU07QUFDekIsVUFBTSxRQUFRLG1CQUFtQjtBQUNqQyxRQUFJLFFBQVEsbUJBQW1CO0FBQzdCLFVBQUksQ0FBQyxRQUFRLGtCQUFrQjtBQUFRLGNBQU0sUUFBUSxrQkFBa0I7QUFDdkUsY0FBUSxlQUFlO0FBQ3ZCLGNBQVEsZ0JBQWdCO0FBQUEsSUFDMUI7QUFDQSxXQUFPO0FBQUEsRUFDVDtBQUFBLEVBRUEsYUFBYSx5QkFBeUIsS0FBMkIsUUFBeUI7QUFDeEYsUUFBSSxLQUFLLFdBQVcsSUFBSSxJQUFJO0FBQUc7QUFDL0IsUUFBSTtBQUNKLGNBQVUsT0FBTyxJQUFJLE1BQU0sc0JBQXNCLElBQUksSUFBSTtBQUN6RCxRQUFJLG1CQUFtQix3QkFBTztBQUM1QixpQkFBVyxjQUFjLElBQUksT0FBTyxtQ0FBbUM7QUFDdkU7QUFBQSxJQUNGO0FBQ0EsUUFBSSxFQUFFLG1CQUFtQiwyQkFBVTtBQUNqQyxpQkFBVyxtQkFBbUIsSUFBSSxPQUFPLDhCQUE4QjtBQUN2RSxnQkFBVSxNQUFNLEtBQUssZ0JBQWdCLElBQUksTUFBTSxNQUFNO0FBQUEsSUFDdkQ7QUFDQSxRQUFJLEVBQUUsbUJBQW1CLDJCQUFVO0FBQ2pDLGlCQUFXLDZCQUE2QixJQUFJLE9BQU8sR0FBRztBQUN0RDtBQUFBLElBQ0Y7QUFFQSxVQUFNLFNBQVMsSUFBSSxjQUFhLFNBQVMsTUFBTTtBQUMvQyxXQUFPLFdBQVcsSUFBSTtBQUN0QixVQUFNLFFBQVEsTUFBTSxPQUFPLG1CQUFtQjtBQUM5QyxRQUFJLE9BQU87QUFDVCxVQUFJLE1BQU0sVUFBVSxNQUFNLE1BQU0sWUFBWTtBQUMxQyxlQUFPLGVBQWU7QUFDdEIsZUFBTyxnQkFBZ0I7QUFBQSxNQUN6QjtBQUFBLElBQ0Y7QUFDQSxXQUFPO0FBQUEsRUFDVDtBQUFBLEVBRUEsT0FBTyxXQUFXQyxPQUFjO0FBQzlCLFdBQU8sTUFBTSxXQUFXQSxLQUFJO0FBQUEsRUFDOUI7QUFBQSxFQUVBLE9BQU8sU0FBU0QsS0FBWTtBQUMxQixXQUFPLE1BQU0sU0FBU0EsR0FBRTtBQUFBLEVBQzFCO0FBQUEsRUFHQSxPQUFPLFNBQVM7QUFDZCxXQUFPLE1BQU0sT0FBTztBQUFBLEVBQ3RCO0FBQUEsRUFFQSxPQUFPLDBCQUEwQixLQUFhO0FBQzVDLFVBQU0scUJBQWlCLGdDQUFjLEdBQUc7QUFDeEMsVUFBTSxVQUFVLEtBQUssT0FBTztBQUM1QixlQUFXLFVBQVUsU0FBUztBQUM1QixVQUFJLE9BQU8sS0FBSyxTQUFTO0FBQWdCO0FBQ3pDLFVBQUksT0FBTyxjQUFjLGNBQWM7QUFBRyxlQUFPO0FBQUEsSUFDbkQ7QUFBQSxFQUNGO0FBQUEsRUFtQkEsa0JBQWtCO0FBQ2hCLFdBQU8sS0FBSyxLQUFLLE9BQU8sV0FBVztBQUFBLEVBQ3JDO0FBQUEsRUFHQSxxQkFBcUIsS0FBYTtBQUNoQyxVQUFNLHFCQUFpQixnQ0FBYyxHQUFHO0FBQ3hDLGVBQVcsU0FBUyxLQUFLLGdCQUFnQixFQUFFLFFBQVEsR0FBcUQ7QUFDdEcsVUFBSSxNQUFNLENBQUMsTUFBTTtBQUFnQixlQUFPLE1BQU0sQ0FBQztBQUFBLElBQ2pEO0FBQUEsRUFDRjtBQUFBLEVBRUEsV0FBVyxTQUFpQixTQUFpQjtBQUMzQyxVQUFNLGtCQUF1QixjQUFTLEtBQUssS0FBSyxNQUFNLE9BQU87QUFDN0QsVUFBTSxrQkFBdUIsY0FBUyxLQUFLLEtBQUssTUFBTSxPQUFPO0FBRTdELFVBQU1BLE1BQUssS0FBSyxxQkFBcUIsZUFBZTtBQUNwRCxRQUFJQSxLQUFJO0FBQ04sV0FBSyxnQkFBZ0IsRUFBRSxJQUFJQSxTQUFJLGdDQUFjLGVBQWUsQ0FBQztBQUFBLElBQy9EO0FBQ0EsV0FBT0E7QUFBQSxFQUNUO0FBQUEsRUFFQSxnQkFBd0I7QUFDdEIsVUFBTSxhQUFhLFVBQVUsTUFBTSxLQUFLLEtBQUssZ0JBQWdCLENBQUMsQ0FBQztBQUMvRCxXQUFPLGNBQWMsVUFBVTtBQUFBLEVBQ2pDO0FBQUEsRUFFQSxZQUFZRixNQUFxQjtBQUUvQixRQUFJLEtBQUssZ0JBQWdCLEVBQUUsSUFBSUEsS0FBSSxPQUFPO0FBQUc7QUFFN0MsVUFBTSxlQUFvQixjQUFTLEtBQUssS0FBSyxNQUFNQSxLQUFJLElBQUk7QUFDM0QsUUFBSSxhQUFhLFdBQVcsSUFBSTtBQUFHO0FBQ25DLFNBQUssZ0JBQWdCLEVBQUUsSUFBSUEsS0FBSSxTQUFTLFlBQVk7QUFBQSxFQUN0RDtBQUFBLEVBRUEsZUFBZUEsTUFBcUI7QUFDbEMsU0FBSyxnQkFBZ0IsRUFBRSxPQUFPQSxLQUFJLE9BQU87QUFBQSxFQUMzQztBQUFBLEVBRUEsY0FBYyxRQUFnQjtBQUM1QixVQUFNLGVBQW9CLGNBQVMsS0FBSyxLQUFLLE1BQU0sTUFBTTtBQUN6RCxXQUFPLENBQUUsYUFBYSxXQUFXLElBQUk7QUFBQSxFQUN2QztBQUFBLEVBRUEsT0FBZSxvQkFBb0IsUUFBK0I7QUFDaEUsVUFBTSxRQUFRLE9BQU8sU0FBUyxRQUFRLENBQUMsVUFBVTtBQUMvQyxVQUFJLGlCQUFpQix3QkFBTztBQUMxQixZQUFJLE1BQU0sY0FBYyxNQUFNO0FBQzVCLGlCQUFPO0FBQUEsUUFDVDtBQUFBLE1BQ0Y7QUFDQSxVQUFJLGlCQUFpQiwwQkFBUztBQUM1QixlQUFPLEtBQUssb0JBQW9CLEtBQUs7QUFBQSxNQUN2QztBQUNBLGFBQU8sQ0FBQztBQUFBLElBQ1YsQ0FBQztBQUNELFdBQU87QUFBQSxFQUNUO0FBQUEsRUFFQSxNQUFNLHFCQUFxQixRQUFpQjtBQUMxQyxVQUFNLFVBQVUsS0FBSztBQUNyQixTQUFLLE9BQU87QUFDWixTQUFLLFlBQVEsZ0NBQWMsT0FBTyxJQUFJO0FBQ3RDLGVBQVcsU0FBUyxPQUFPLE1BQU0sS0FBSyxNQUFNO0FBQUEsRUFDOUM7QUFBQSxFQUVBLE1BQU0sZ0JBQWdCLGNBQXNCO0FBQzFDLFVBQU0sZUFBb0IsVUFBSyxLQUFLLEtBQUssTUFBTSxZQUFZO0FBQzNELFFBQUksT0FBTyxLQUFLLE9BQU8sSUFBSSxNQUFNLHNCQUFzQixZQUFZO0FBQ25FLFFBQUksUUFBUSxnQkFBZ0I7QUFBTyxhQUFPO0FBRTFDLFVBQU0sU0FBUyxNQUFNLGNBQWEsZ0JBQXFCLFdBQU0sWUFBWSxFQUFFLEtBQUssS0FBSyxNQUFNO0FBQzNGLFFBQUksQ0FBQyxRQUFRO0FBQ1gsaUJBQVcsdUJBQXVCO0FBQ2xDO0FBQUEsSUFDRjtBQUNBLFdBQU8sTUFBTSxLQUFLLE9BQU8sSUFBSSxNQUFNLE9BQU8sY0FBYyxFQUFFO0FBQUEsRUFDNUQ7QUFBQSxFQUVBLGFBQWEsZ0JBQWdCLGNBQXNCLFFBQWtEO0FBQ25HLFFBQUksU0FBUyxPQUFPLElBQUksTUFBTSwwQkFBc0IsZ0NBQWMsWUFBWSxDQUFDO0FBQy9FLFFBQUksVUFBVSxrQkFBa0I7QUFBUyxhQUFPO0FBQ2hELFVBQU0sV0FBVyxhQUFhLE1BQVcsUUFBRztBQUM1QyxhQUFTLFFBQVEsR0FBRyxRQUFRLFNBQVMsUUFBUSxTQUFTO0FBQ3BELFlBQU0sVUFBVSxTQUFTLE1BQU0sR0FBRyxRQUFRLENBQUMsRUFBRSxLQUFVLFFBQUc7QUFDMUQsZUFBUyxPQUFPLElBQUksTUFBTSwwQkFBc0IsZ0NBQWMsT0FBTyxDQUFDO0FBQ3RFLFVBQUksQ0FBQyxRQUFRO0FBQ1gsaUJBQVMsTUFBTSxPQUFPLElBQUksTUFBTSxpQkFBYSxnQ0FBYyxPQUFPLENBQUM7QUFBQSxNQUNyRTtBQUFBLElBQ0Y7QUFDQSxXQUFPO0FBQUEsRUFDVDtBQUFBLEVBRUEsbUJBQW1CLE1BQWE7QUFDOUIsVUFBTSxxQkFBaUIsZ0NBQWMsS0FBSyxJQUFJO0FBQzlDLGVBQVcsU0FBUyxLQUFLLGdCQUFnQixFQUFFLE9BQU8sR0FBRztBQUNuRCxVQUFJLG1CQUF3QixVQUFLLEtBQUssS0FBSyxNQUFNLEtBQUs7QUFBRyxlQUFPO0FBQUEsSUFDbEU7QUFDQSxXQUFPO0FBQUEsRUFDVDtBQUFBLEVBRUEsa0JBQWtCO0FBQ2hCLFdBQU8sTUFBTSxnQkFBZ0IsQ0FBQyxhQUFhO0FBRXpDLFlBQU0sZ0JBQWdCLE1BQU07QUFBQSxNQUU1QjtBQUVBLFdBQUssaUJBQWlCLE9BQU8sV0FBVyxlQUFlLEdBQUs7QUFDNUQsZUFBUyxJQUFJLEdBQUcsVUFBVSxPQUFPLFFBQW9CLFFBQWFBLE1BQVksT0FBc0I7QUFDbEcsWUFBSSxLQUFLLGtCQUFrQixNQUFNO0FBQy9CLGlCQUFPLGFBQWEsS0FBSyxjQUFjO0FBQUEsUUFDekM7QUFDQSxhQUFLLGlCQUFpQixPQUFPLFdBQVcsZUFBZSxHQUFLO0FBQUEsTUFDOUQsQ0FBQztBQUFBLElBQ0gsQ0FBQztBQUFBLEVBQ0g7QUFBQSxFQUVBLE1BQU0scUJBQXFCO0FBalg3QjtBQWtYSSxRQUFJLEtBQUs7QUFBb0IsYUFBTyxLQUFLO0FBQ3pDLFVBQU1FLE9BQUsscUJBQWdCLEtBQUssTUFBTSxLQUFLLE1BQU0sTUFBdEMsbUJBQXlDO0FBQ3BELFFBQUksQ0FBQ0E7QUFBSTtBQUNULFNBQUsscUJBQXFCLElBQUkscUJBQXFCLGFBQWEsd0JBQXdCQSxLQUFJLEtBQUssSUFBSTtBQUNyRyxXQUFPLEtBQUs7QUFBQSxFQUNkO0FBQUEsRUFFQSxNQUFNLFVBQVU7QUFDZCxVQUFNLFVBQVUsZ0JBQWdCLEtBQUssTUFBTSxLQUFLLE1BQU07QUFDdEQsUUFBSSxTQUFTO0FBQ1gsbUJBQWEsS0FBSyxNQUFNLEtBQUssTUFBTTtBQUFBLElBQ3JDO0FBRUEsUUFBSSxLQUFLLG9CQUFvQjtBQUMzQixZQUFNLEtBQUssbUJBQW1CLFVBQVU7QUFDeEMsWUFBTSxLQUFLLG1CQUFtQixRQUFRO0FBQUEsSUFDeEM7QUFHQSxTQUFLLGdCQUFnQixFQUFFLFFBQVEsQ0FBQ0MsT0FBYyxZQUFvQjtBQXJZdEU7QUFzWU0sMkJBQWUsU0FBUyxPQUFPLE1BQS9CLG1CQUFrQztBQUFBLElBQ3BDLENBQUM7QUFFRCxTQUFLLFFBQVE7QUFDYix3QkFBb0IsS0FBSyxNQUFNLEtBQUssTUFBTTtBQUFBLEVBQzVDO0FBQUEsRUFFQSxVQUFVO0FBQ1IsVUFBTSxRQUFRO0FBQ2Qsa0JBQWEsZUFBZSxPQUFPLGNBQWEsZUFBZSxRQUFRLElBQUksR0FBRyxDQUFDO0FBQUEsRUFDakY7QUFFRjtBQTVVTyxJQUFNLGVBQU47QUFBTSxhQUdNLGlCQUFzQyxJQUFJLE1BQW9COzs7QWdFekVqRixJQUFNLFlBQVksSUFBSSxNQUFNLHFEQUFxRDtBQUNqRixJQUFNLG1CQUFtQixJQUFJLE1BQU0sc0JBQXNCO0FBQ3pELElBQU0sYUFBYSxJQUFJLE1BQU0sMkJBQTJCO0FBRXhELElBQUksY0FBb0QsU0FBVSxTQUFTLFlBQVksR0FBRyxXQUFXO0FBQ2pHLFdBQVMsTUFBTSxPQUFPO0FBQUUsV0FBTyxpQkFBaUIsSUFBSSxRQUFRLElBQUksRUFBRSxTQUFVQyxVQUFTO0FBQUUsTUFBQUEsU0FBUSxLQUFLO0FBQUEsSUFBRyxDQUFDO0FBQUEsRUFBRztBQUMzRyxTQUFPLEtBQUssTUFBTSxJQUFJLFVBQVUsU0FBVUEsVUFBU0MsU0FBUTtBQUN2RCxhQUFTLFVBQVUsT0FBTztBQUFFLFVBQUk7QUFBRSxhQUFLLFVBQVUsS0FBSyxLQUFLLENBQUM7QUFBQSxNQUFHLFNBQVMsR0FBUDtBQUFZLFFBQUFBLFFBQU8sQ0FBQztBQUFBLE1BQUc7QUFBQSxJQUFFO0FBQzFGLGFBQVMsU0FBUyxPQUFPO0FBQUUsVUFBSTtBQUFFLGFBQUssVUFBVSxPQUFPLEVBQUUsS0FBSyxDQUFDO0FBQUEsTUFBRyxTQUFTLEdBQVA7QUFBWSxRQUFBQSxRQUFPLENBQUM7QUFBQSxNQUFHO0FBQUEsSUFBRTtBQUM3RixhQUFTLEtBQUssUUFBUTtBQUFFLGFBQU8sT0FBT0QsU0FBUSxPQUFPLEtBQUssSUFBSSxNQUFNLE9BQU8sS0FBSyxFQUFFLEtBQUssV0FBVyxRQUFRO0FBQUEsSUFBRztBQUM3RyxVQUFNLFlBQVksVUFBVSxNQUFNLFNBQVMsY0FBYyxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUM7QUFBQSxFQUN4RSxDQUFDO0FBQ0w7QUFDQSxJQUFNLFlBQU4sTUFBZ0I7QUFBQSxFQUNaLFlBQVksUUFBUSxlQUFlLFlBQVk7QUFDM0MsU0FBSyxTQUFTO0FBQ2QsU0FBSyxlQUFlO0FBQ3BCLFNBQUssU0FBUyxDQUFDO0FBQ2YsU0FBSyxtQkFBbUIsQ0FBQztBQUFBLEVBQzdCO0FBQUEsRUFDQSxRQUFRLFNBQVMsR0FBRyxXQUFXLEdBQUc7QUFDOUIsUUFBSSxVQUFVO0FBQ1YsWUFBTSxJQUFJLE1BQU0sa0JBQWtCLDBCQUEwQjtBQUNoRSxXQUFPLElBQUksUUFBUSxDQUFDQSxVQUFTQyxZQUFXO0FBQ3BDLFlBQU1DLFFBQU8sRUFBRSxTQUFBRixVQUFTLFFBQUFDLFNBQVEsUUFBUSxTQUFTO0FBQ2pELFlBQU0sSUFBSSxpQkFBaUIsS0FBSyxRQUFRLENBQUMsVUFBVSxZQUFZLE1BQU0sUUFBUTtBQUM3RSxVQUFJLE1BQU0sTUFBTSxVQUFVLEtBQUssUUFBUTtBQUVuQyxhQUFLLGNBQWNDLEtBQUk7QUFBQSxNQUMzQixPQUNLO0FBQ0QsYUFBSyxPQUFPLE9BQU8sSUFBSSxHQUFHLEdBQUdBLEtBQUk7QUFBQSxNQUNyQztBQUFBLElBQ0osQ0FBQztBQUFBLEVBQ0w7QUFBQSxFQUNBLGFBQWEsWUFBWTtBQUNyQixXQUFPLFlBQVksTUFBTSxXQUFXLFFBQVEsV0FBVyxVQUFVLFNBQVMsR0FBRyxXQUFXLEdBQUc7QUFDdkYsWUFBTSxDQUFDLE9BQU8sT0FBTyxJQUFJLE1BQU0sS0FBSyxRQUFRLFFBQVEsUUFBUTtBQUM1RCxVQUFJO0FBQ0EsZUFBTyxNQUFNLFNBQVMsS0FBSztBQUFBLE1BQy9CLFVBQ0E7QUFDSSxnQkFBUTtBQUFBLE1BQ1o7QUFBQSxJQUNKLENBQUM7QUFBQSxFQUNMO0FBQUEsRUFDQSxjQUFjLFNBQVMsR0FBRyxXQUFXLEdBQUc7QUFDcEMsUUFBSSxVQUFVO0FBQ1YsWUFBTSxJQUFJLE1BQU0sa0JBQWtCLDBCQUEwQjtBQUNoRSxRQUFJLEtBQUssc0JBQXNCLFFBQVEsUUFBUSxHQUFHO0FBQzlDLGFBQU8sUUFBUSxRQUFRO0FBQUEsSUFDM0IsT0FDSztBQUNELGFBQU8sSUFBSSxRQUFRLENBQUNGLGFBQVk7QUFDNUIsWUFBSSxDQUFDLEtBQUssaUJBQWlCLFNBQVMsQ0FBQztBQUNqQyxlQUFLLGlCQUFpQixTQUFTLENBQUMsSUFBSSxDQUFDO0FBQ3pDLHFCQUFhLEtBQUssaUJBQWlCLFNBQVMsQ0FBQyxHQUFHLEVBQUUsU0FBQUEsVUFBUyxTQUFTLENBQUM7QUFBQSxNQUN6RSxDQUFDO0FBQUEsSUFDTDtBQUFBLEVBQ0o7QUFBQSxFQUNBLFdBQVc7QUFDUCxXQUFPLEtBQUssVUFBVTtBQUFBLEVBQzFCO0FBQUEsRUFDQSxXQUFXO0FBQ1AsV0FBTyxLQUFLO0FBQUEsRUFDaEI7QUFBQSxFQUNBLFNBQVMsT0FBTztBQUNaLFNBQUssU0FBUztBQUNkLFNBQUssZUFBZTtBQUFBLEVBQ3hCO0FBQUEsRUFDQSxRQUFRLFNBQVMsR0FBRztBQUNoQixRQUFJLFVBQVU7QUFDVixZQUFNLElBQUksTUFBTSxrQkFBa0IsMEJBQTBCO0FBQ2hFLFNBQUssVUFBVTtBQUNmLFNBQUssZUFBZTtBQUFBLEVBQ3hCO0FBQUEsRUFDQSxTQUFTO0FBQ0wsU0FBSyxPQUFPLFFBQVEsQ0FBQyxVQUFVLE1BQU0sT0FBTyxLQUFLLFlBQVksQ0FBQztBQUM5RCxTQUFLLFNBQVMsQ0FBQztBQUFBLEVBQ25CO0FBQUEsRUFDQSxpQkFBaUI7QUFDYixTQUFLLG9CQUFvQjtBQUN6QixXQUFPLEtBQUssT0FBTyxTQUFTLEtBQUssS0FBSyxPQUFPLENBQUMsRUFBRSxVQUFVLEtBQUssUUFBUTtBQUNuRSxXQUFLLGNBQWMsS0FBSyxPQUFPLE1BQU0sQ0FBQztBQUN0QyxXQUFLLG9CQUFvQjtBQUFBLElBQzdCO0FBQUEsRUFDSjtBQUFBLEVBQ0EsY0FBYyxNQUFNO0FBQ2hCLFVBQU0sZ0JBQWdCLEtBQUs7QUFDM0IsU0FBSyxVQUFVLEtBQUs7QUFDcEIsU0FBSyxRQUFRLENBQUMsZUFBZSxLQUFLLGFBQWEsS0FBSyxNQUFNLENBQUMsQ0FBQztBQUFBLEVBQ2hFO0FBQUEsRUFDQSxhQUFhLFFBQVE7QUFDakIsUUFBSSxTQUFTO0FBQ2IsV0FBTyxNQUFNO0FBQ1QsVUFBSTtBQUNBO0FBQ0osZUFBUztBQUNULFdBQUssUUFBUSxNQUFNO0FBQUEsSUFDdkI7QUFBQSxFQUNKO0FBQUEsRUFDQSxzQkFBc0I7QUFDbEIsUUFBSSxLQUFLLE9BQU8sV0FBVyxHQUFHO0FBQzFCLGVBQVMsU0FBUyxLQUFLLFFBQVEsU0FBUyxHQUFHLFVBQVU7QUFDakQsY0FBTSxVQUFVLEtBQUssaUJBQWlCLFNBQVMsQ0FBQztBQUNoRCxZQUFJLENBQUM7QUFDRDtBQUNKLGdCQUFRLFFBQVEsQ0FBQyxXQUFXLE9BQU8sUUFBUSxDQUFDO0FBQzVDLGFBQUssaUJBQWlCLFNBQVMsQ0FBQyxJQUFJLENBQUM7QUFBQSxNQUN6QztBQUFBLElBQ0osT0FDSztBQUNELFlBQU0saUJBQWlCLEtBQUssT0FBTyxDQUFDLEVBQUU7QUFDdEMsZUFBUyxTQUFTLEtBQUssUUFBUSxTQUFTLEdBQUcsVUFBVTtBQUNqRCxjQUFNLFVBQVUsS0FBSyxpQkFBaUIsU0FBUyxDQUFDO0FBQ2hELFlBQUksQ0FBQztBQUNEO0FBQ0osY0FBTSxJQUFJLFFBQVEsVUFBVSxDQUFDLFdBQVcsT0FBTyxZQUFZLGNBQWM7QUFDekUsU0FBQyxNQUFNLEtBQUssVUFBVSxRQUFRLE9BQU8sR0FBRyxDQUFDLEdBQ3BDLFFBQVMsWUFBVSxPQUFPLFFBQVEsQ0FBRTtBQUFBLE1BQzdDO0FBQUEsSUFDSjtBQUFBLEVBQ0o7QUFBQSxFQUNBLHNCQUFzQixRQUFRLFVBQVU7QUFDcEMsWUFBUSxLQUFLLE9BQU8sV0FBVyxLQUFLLEtBQUssT0FBTyxDQUFDLEVBQUUsV0FBVyxhQUMxRCxVQUFVLEtBQUs7QUFBQSxFQUN2QjtBQUNKO0FBQ0EsU0FBUyxhQUFhLEdBQUcsR0FBRztBQUN4QixRQUFNLElBQUksaUJBQWlCLEdBQUcsQ0FBQyxVQUFVLEVBQUUsWUFBWSxNQUFNLFFBQVE7QUFDckUsSUFBRSxPQUFPLElBQUksR0FBRyxHQUFHLENBQUM7QUFDeEI7QUFDQSxTQUFTLGlCQUFpQixHQUFHLFdBQVc7QUFDcEMsV0FBUyxJQUFJLEVBQUUsU0FBUyxHQUFHLEtBQUssR0FBRyxLQUFLO0FBQ3BDLFFBQUksVUFBVSxFQUFFLENBQUMsQ0FBQyxHQUFHO0FBQ2pCLGFBQU87QUFBQSxJQUNYO0FBQUEsRUFDSjtBQUNBLFNBQU87QUFDWDtBQUVBLElBQUksY0FBb0QsU0FBVSxTQUFTLFlBQVksR0FBRyxXQUFXO0FBQ2pHLFdBQVMsTUFBTSxPQUFPO0FBQUUsV0FBTyxpQkFBaUIsSUFBSSxRQUFRLElBQUksRUFBRSxTQUFVQSxVQUFTO0FBQUUsTUFBQUEsU0FBUSxLQUFLO0FBQUEsSUFBRyxDQUFDO0FBQUEsRUFBRztBQUMzRyxTQUFPLEtBQUssTUFBTSxJQUFJLFVBQVUsU0FBVUEsVUFBU0MsU0FBUTtBQUN2RCxhQUFTLFVBQVUsT0FBTztBQUFFLFVBQUk7QUFBRSxhQUFLLFVBQVUsS0FBSyxLQUFLLENBQUM7QUFBQSxNQUFHLFNBQVMsR0FBUDtBQUFZLFFBQUFBLFFBQU8sQ0FBQztBQUFBLE1BQUc7QUFBQSxJQUFFO0FBQzFGLGFBQVMsU0FBUyxPQUFPO0FBQUUsVUFBSTtBQUFFLGFBQUssVUFBVSxPQUFPLEVBQUUsS0FBSyxDQUFDO0FBQUEsTUFBRyxTQUFTLEdBQVA7QUFBWSxRQUFBQSxRQUFPLENBQUM7QUFBQSxNQUFHO0FBQUEsSUFBRTtBQUM3RixhQUFTLEtBQUssUUFBUTtBQUFFLGFBQU8sT0FBT0QsU0FBUSxPQUFPLEtBQUssSUFBSSxNQUFNLE9BQU8sS0FBSyxFQUFFLEtBQUssV0FBVyxRQUFRO0FBQUEsSUFBRztBQUM3RyxVQUFNLFlBQVksVUFBVSxNQUFNLFNBQVMsY0FBYyxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUM7QUFBQSxFQUN4RSxDQUFDO0FBQ0w7QUFDQSxJQUFNLFFBQU4sTUFBWTtBQUFBLEVBQ1IsWUFBWSxhQUFhO0FBQ3JCLFNBQUssYUFBYSxJQUFJLFVBQVUsR0FBRyxXQUFXO0FBQUEsRUFDbEQ7QUFBQSxFQUNBLFVBQVU7QUFDTixXQUFPLFlBQVksTUFBTSxXQUFXLFFBQVEsV0FBVyxXQUFXLEdBQUc7QUFDakUsWUFBTSxDQUFDLEVBQUUsUUFBUSxJQUFJLE1BQU0sS0FBSyxXQUFXLFFBQVEsR0FBRyxRQUFRO0FBQzlELGFBQU87QUFBQSxJQUNYLENBQUM7QUFBQSxFQUNMO0FBQUEsRUFDQSxhQUFhLFVBQVUsV0FBVyxHQUFHO0FBQ2pDLFdBQU8sS0FBSyxXQUFXLGFBQWEsTUFBTSxTQUFTLEdBQUcsR0FBRyxRQUFRO0FBQUEsRUFDckU7QUFBQSxFQUNBLFdBQVc7QUFDUCxXQUFPLEtBQUssV0FBVyxTQUFTO0FBQUEsRUFDcEM7QUFBQSxFQUNBLGNBQWMsV0FBVyxHQUFHO0FBQ3hCLFdBQU8sS0FBSyxXQUFXLGNBQWMsR0FBRyxRQUFRO0FBQUEsRUFDcEQ7QUFBQSxFQUNBLFVBQVU7QUFDTixRQUFJLEtBQUssV0FBVyxTQUFTO0FBQ3pCLFdBQUssV0FBVyxRQUFRO0FBQUEsRUFDaEM7QUFBQSxFQUNBLFNBQVM7QUFDTCxXQUFPLEtBQUssV0FBVyxPQUFPO0FBQUEsRUFDbEM7QUFDSjs7O0FDaExBLElBQU0saUJBQWlDLHVCQUFPLE9BQU87QUFBQSxFQUNuRCxhQUFhO0FBQUEsRUFDYixjQUFjO0FBQUEsRUFDZCxnQkFBZ0I7QUFBQSxFQUNoQixlQUFlO0FBQUEsRUFDZixzQkFBc0I7QUFBQSxFQUN0QixhQUFhO0FBQUEsRUFDYixjQUFjO0FBQ2hCLENBQUM7QUFDRCxTQUFTLGVBQWUsU0FBUztBQUMvQixNQUFJLG1DQUFTO0FBQ1gsV0FBTztBQUNULFFBQU0sV0FBVztBQUFBLElBQ2YsR0FBRztBQUFBLElBQ0gsR0FBRztBQUFBLEVBQ0w7QUFDQSxTQUFPLGVBQWUsVUFBVSxjQUFjLEVBQUUsT0FBTyxNQUFNLFlBQVksTUFBTSxDQUFDO0FBQ2hGLFNBQU87QUFDVDtBQUVBLElBQU0sY0FBYztBQUNwQixJQUFNLGNBQWM7QUFDcEIsSUFBTSxhQUFhO0FBQ25CLFNBQVMsV0FBVyxJQUFJRyxPQUFNO0FBQzVCLFNBQU8sQ0FBQyxJQUFJQSxLQUFJO0FBQ2xCO0FBQ0EsU0FBUyxTQUFTLE9BQU8sT0FBTyxTQUFTLGlCQUFpQixNQUFNLGNBQWM7QUFDNUUsUUFBTSxXQUFXLGVBQWUsT0FBTztBQUN2QyxNQUFJLE9BQU8sZ0JBQWdCLGFBQWE7QUFDdEMsUUFBSSxTQUFTLGVBQWU7QUFDMUIscUJBQWUsT0FBTztBQUFBO0FBRXRCLHNCQUFnQyxvQkFBSSxLQUFLLEdBQUcsUUFBUSxJQUFJLFNBQVMsY0FBYztBQUFBLEVBQ25GO0FBQ0EsUUFBTSxXQUFXO0FBQ2pCLE1BQUksU0FBUyxRQUFRLFNBQVM7QUFDNUIsVUFBTSxJQUFJLE1BQU0seUJBQXlCO0FBQzNDLE1BQUksVUFBVSxPQUFPO0FBQ25CLFFBQUk7QUFDRixhQUFPLENBQUMsV0FBVyxZQUFZLEtBQUssQ0FBQztBQUN2QyxXQUFPLENBQUM7QUFBQSxFQUNWO0FBQ0EsUUFBTSxhQUFhO0FBQ25CLE1BQUksZUFBZSxpQkFBaUIsT0FBTyxLQUFLO0FBQ2hELFFBQU0sZUFBZSxNQUFNLFVBQVUsR0FBRyxZQUFZO0FBQ3BELFVBQVEsTUFBTSxVQUFVLFlBQVk7QUFDcEMsVUFBUSxNQUFNLFVBQVUsWUFBWTtBQUNwQyxpQkFBZSxpQkFBaUIsT0FBTyxLQUFLO0FBQzVDLFFBQU0sZUFBZSxNQUFNLFVBQVUsTUFBTSxTQUFTLFlBQVk7QUFDaEUsVUFBUSxNQUFNLFVBQVUsR0FBRyxNQUFNLFNBQVMsWUFBWTtBQUN0RCxVQUFRLE1BQU0sVUFBVSxHQUFHLE1BQU0sU0FBUyxZQUFZO0FBQ3RELFFBQU0sUUFBUSxZQUFZLE9BQU8sT0FBTyxVQUFVLFlBQVksUUFBUTtBQUN0RSxNQUFJO0FBQ0YsVUFBTSxRQUFRLFdBQVcsWUFBWSxZQUFZLENBQUM7QUFDcEQsTUFBSTtBQUNGLFVBQU0sS0FBSyxXQUFXLFlBQVksWUFBWSxDQUFDO0FBQ2pELG1CQUFpQixLQUFLO0FBQ3RCLFNBQU87QUFDVDtBQUNBLFNBQVMsWUFBWSxPQUFPLE9BQU8sU0FBUyxZQUFZLFVBQVU7QUFDaEUsTUFBSTtBQUNKLE1BQUksQ0FBQyxPQUFPO0FBQ1YsV0FBTyxDQUFDLFdBQVcsYUFBYSxLQUFLLENBQUM7QUFBQSxFQUN4QztBQUNBLE1BQUksQ0FBQyxPQUFPO0FBQ1YsV0FBTyxDQUFDLFdBQVcsYUFBYSxLQUFLLENBQUM7QUFBQSxFQUN4QztBQUNBLFFBQU0sV0FBVyxNQUFNLFNBQVMsTUFBTSxTQUFTLFFBQVE7QUFDdkQsUUFBTSxZQUFZLE1BQU0sU0FBUyxNQUFNLFNBQVMsUUFBUTtBQUN4RCxRQUFNLElBQUksU0FBUyxRQUFRLFNBQVM7QUFDcEMsTUFBSSxNQUFNLElBQUk7QUFDWixZQUFRLENBQUMsV0FBVyxhQUFhLFNBQVMsVUFBVSxHQUFHLENBQUMsQ0FBQyxHQUFHLFdBQVcsWUFBWSxTQUFTLEdBQUcsV0FBVyxhQUFhLFNBQVMsVUFBVSxJQUFJLFVBQVUsTUFBTSxDQUFDLENBQUM7QUFDaEssUUFBSSxNQUFNLFNBQVMsTUFBTTtBQUN2QixZQUFNLENBQUMsRUFBRSxDQUFDLElBQUksTUFBTSxDQUFDLEVBQUUsQ0FBQyxJQUFJO0FBQzlCLFdBQU87QUFBQSxFQUNUO0FBQ0EsTUFBSSxVQUFVLFdBQVcsR0FBRztBQUMxQixXQUFPLENBQUMsV0FBVyxhQUFhLEtBQUssR0FBRyxXQUFXLGFBQWEsS0FBSyxDQUFDO0FBQUEsRUFDeEU7QUFDQSxRQUFNLEtBQUssY0FBYyxPQUFPLE9BQU8sT0FBTztBQUM5QyxNQUFJLElBQUk7QUFDTixVQUFNLFVBQVUsR0FBRyxDQUFDO0FBQ3BCLFVBQU0sVUFBVSxHQUFHLENBQUM7QUFDcEIsVUFBTSxVQUFVLEdBQUcsQ0FBQztBQUNwQixVQUFNLFVBQVUsR0FBRyxDQUFDO0FBQ3BCLFVBQU0sYUFBYSxHQUFHLENBQUM7QUFDdkIsVUFBTSxVQUFVLFNBQVMsU0FBUyxTQUFTLFNBQVMsWUFBWSxRQUFRO0FBQ3hFLFVBQU0sVUFBVSxTQUFTLFNBQVMsU0FBUyxTQUFTLFlBQVksUUFBUTtBQUN4RSxXQUFPLFFBQVEsT0FBTyxDQUFDLFdBQVcsWUFBWSxVQUFVLENBQUMsR0FBRyxPQUFPO0FBQUEsRUFDckU7QUFDQSxNQUFJLGNBQWMsTUFBTSxTQUFTLE9BQU8sTUFBTSxTQUFTO0FBQ3JELFdBQU8sYUFBYSxPQUFPLE9BQU8sU0FBUyxRQUFRO0FBQ3JELFNBQU8sV0FBVyxPQUFPLE9BQU8sU0FBUyxRQUFRO0FBQ25EO0FBQ0EsU0FBUyxhQUFhLE9BQU8sT0FBTyxTQUFTLFVBQVU7QUFDckQsUUFBTSxJQUFJLGlCQUFpQixPQUFPLEtBQUs7QUFDdkMsVUFBUSxFQUFFO0FBQ1YsVUFBUSxFQUFFO0FBQ1YsUUFBTSxZQUFZLEVBQUU7QUFDcEIsUUFBTSxRQUFRLFNBQVMsT0FBTyxPQUFPLFNBQVMsT0FBTyxRQUFRO0FBQzdELG1CQUFpQixPQUFPLFNBQVM7QUFDakMsc0JBQW9CLEtBQUs7QUFDekIsUUFBTSxLQUFLLFdBQVcsWUFBWSxFQUFFLENBQUM7QUFDckMsTUFBSSxVQUFVO0FBQ2QsTUFBSSxlQUFlO0FBQ25CLE1BQUksZUFBZTtBQUNuQixNQUFJLGNBQWM7QUFDbEIsTUFBSSxjQUFjO0FBQ2xCLFNBQU8sVUFBVSxNQUFNLFFBQVE7QUFDN0IsWUFBUSxNQUFNLE9BQU8sRUFBRSxDQUFDLEdBQUc7QUFBQSxNQUN6QixLQUFLO0FBQ0g7QUFDQSx1QkFBZSxNQUFNLE9BQU8sRUFBRSxDQUFDO0FBQy9CO0FBQUEsTUFDRixLQUFLO0FBQ0g7QUFDQSx1QkFBZSxNQUFNLE9BQU8sRUFBRSxDQUFDO0FBQy9CO0FBQUEsTUFDRixLQUFLO0FBQ0gsWUFBSSxnQkFBZ0IsS0FBSyxnQkFBZ0IsR0FBRztBQUMxQyxnQkFBTSxPQUFPLFVBQVUsZUFBZSxjQUFjLGVBQWUsWUFBWTtBQUMvRSxvQkFBVSxVQUFVLGVBQWU7QUFDbkMsZ0JBQU0sVUFBVSxTQUFTLGFBQWEsYUFBYSxTQUFTLE9BQU8sUUFBUTtBQUMzRSxtQkFBUyxJQUFJLFFBQVEsU0FBUyxHQUFHLEtBQUssR0FBRztBQUN2QyxrQkFBTSxPQUFPLFNBQVMsR0FBRyxRQUFRLENBQUMsQ0FBQztBQUNyQyxvQkFBVSxVQUFVLFFBQVE7QUFBQSxRQUM5QjtBQUNBLHVCQUFlO0FBQ2YsdUJBQWU7QUFDZixzQkFBYztBQUNkLHNCQUFjO0FBQ2Q7QUFBQSxJQUNKO0FBQ0E7QUFBQSxFQUNGO0FBQ0EsUUFBTSxJQUFJO0FBQ1YsU0FBTztBQUNUO0FBQ0EsU0FBUyxXQUFXLE9BQU8sT0FBTyxTQUFTLFVBQVU7QUFDbkQsUUFBTSxlQUFlLE1BQU07QUFDM0IsUUFBTSxlQUFlLE1BQU07QUFDM0IsUUFBTSxRQUFRLEtBQUssTUFBTSxlQUFlLGdCQUFnQixDQUFDO0FBQ3pELFFBQU0sV0FBVztBQUNqQixRQUFNLFdBQVcsSUFBSTtBQUNyQixRQUFNLEtBQUssSUFBSSxNQUFNLFFBQVE7QUFDN0IsUUFBTSxLQUFLLElBQUksTUFBTSxRQUFRO0FBQzdCLFdBQVMsSUFBSSxHQUFHLElBQUksVUFBVSxLQUFLO0FBQ2pDLE9BQUcsQ0FBQyxJQUFJO0FBQ1IsT0FBRyxDQUFDLElBQUk7QUFBQSxFQUNWO0FBQ0EsS0FBRyxXQUFXLENBQUMsSUFBSTtBQUNuQixLQUFHLFdBQVcsQ0FBQyxJQUFJO0FBQ25CLFFBQU0sUUFBUSxlQUFlO0FBQzdCLFFBQU0sUUFBUSxRQUFRLE1BQU07QUFDNUIsTUFBSSxVQUFVO0FBQ2QsTUFBSSxRQUFRO0FBQ1osTUFBSSxVQUFVO0FBQ2QsTUFBSSxRQUFRO0FBQ1osV0FBUyxJQUFJLEdBQUcsSUFBSSxPQUFPLEtBQUs7QUFDOUIsU0FBcUIsb0JBQUksS0FBSyxHQUFHLFFBQVEsSUFBSTtBQUMzQztBQUNGLGFBQVMsS0FBSyxDQUFDLElBQUksU0FBUyxNQUFNLElBQUksT0FBTyxNQUFNLEdBQUc7QUFDcEQsWUFBTSxZQUFZLFdBQVc7QUFDN0IsVUFBSTtBQUNKLFVBQUksT0FBTyxDQUFDLEtBQUssT0FBTyxLQUFLLEdBQUcsWUFBWSxDQUFDLElBQUksR0FBRyxZQUFZLENBQUM7QUFDL0QsYUFBSyxHQUFHLFlBQVksQ0FBQztBQUFBO0FBRXJCLGFBQUssR0FBRyxZQUFZLENBQUMsSUFBSTtBQUMzQixVQUFJLEtBQUssS0FBSztBQUNkLGFBQU8sS0FBSyxnQkFBZ0IsS0FBSyxnQkFBZ0IsTUFBTSxPQUFPLEVBQUUsTUFBTSxNQUFNLE9BQU8sRUFBRSxHQUFHO0FBQ3RGO0FBQ0E7QUFBQSxNQUNGO0FBQ0EsU0FBRyxTQUFTLElBQUk7QUFDaEIsVUFBSSxLQUFLLGNBQWM7QUFDckIsaUJBQVM7QUFBQSxNQUNYLFdBQVcsS0FBSyxjQUFjO0FBQzVCLG1CQUFXO0FBQUEsTUFDYixXQUFXLE9BQU87QUFDaEIsY0FBTSxZQUFZLFdBQVcsUUFBUTtBQUNyQyxZQUFJLGFBQWEsS0FBSyxZQUFZLFlBQVksR0FBRyxTQUFTLE1BQU0sSUFBSTtBQUNsRSxnQkFBTSxLQUFLLGVBQWUsR0FBRyxTQUFTO0FBQ3RDLGNBQUksTUFBTSxJQUFJO0FBQ1osbUJBQU8sZ0JBQWdCLE9BQU8sT0FBTyxTQUFTLElBQUksSUFBSSxRQUFRO0FBQUEsVUFDaEU7QUFBQSxRQUNGO0FBQUEsTUFDRjtBQUFBLElBQ0Y7QUFDQSxhQUFTLEtBQUssQ0FBQyxJQUFJLFNBQVMsTUFBTSxJQUFJLE9BQU8sTUFBTSxHQUFHO0FBQ3BELFlBQU0sWUFBWSxXQUFXO0FBQzdCLFVBQUk7QUFDSixVQUFJLE9BQU8sQ0FBQyxLQUFLLE9BQU8sS0FBSyxHQUFHLFlBQVksQ0FBQyxJQUFJLEdBQUcsWUFBWSxDQUFDO0FBQy9ELGFBQUssR0FBRyxZQUFZLENBQUM7QUFBQTtBQUVyQixhQUFLLEdBQUcsWUFBWSxDQUFDLElBQUk7QUFDM0IsVUFBSSxLQUFLLEtBQUs7QUFDZCxhQUFPLEtBQUssZ0JBQWdCLEtBQUssZ0JBQWdCLE1BQU0sT0FBTyxlQUFlLEtBQUssQ0FBQyxNQUFNLE1BQU0sT0FBTyxlQUFlLEtBQUssQ0FBQyxHQUFHO0FBQzVIO0FBQ0E7QUFBQSxNQUNGO0FBQ0EsU0FBRyxTQUFTLElBQUk7QUFDaEIsVUFBSSxLQUFLLGNBQWM7QUFDckIsaUJBQVM7QUFBQSxNQUNYLFdBQVcsS0FBSyxjQUFjO0FBQzVCLG1CQUFXO0FBQUEsTUFDYixXQUFXLENBQUMsT0FBTztBQUNqQixjQUFNLFlBQVksV0FBVyxRQUFRO0FBQ3JDLFlBQUksYUFBYSxLQUFLLFlBQVksWUFBWSxHQUFHLFNBQVMsTUFBTSxJQUFJO0FBQ2xFLGdCQUFNLEtBQUssR0FBRyxTQUFTO0FBQ3ZCLGdCQUFNLEtBQUssV0FBVyxLQUFLO0FBQzNCLGVBQUssZUFBZTtBQUNwQixjQUFJLE1BQU0sSUFBSTtBQUNaLG1CQUFPLGdCQUFnQixPQUFPLE9BQU8sU0FBUyxJQUFJLElBQUksUUFBUTtBQUFBLFVBQ2hFO0FBQUEsUUFDRjtBQUFBLE1BQ0Y7QUFBQSxJQUNGO0FBQUEsRUFDRjtBQUNBLFNBQU8sQ0FBQyxXQUFXLGFBQWEsS0FBSyxHQUFHLFdBQVcsYUFBYSxLQUFLLENBQUM7QUFDeEU7QUFDQSxTQUFTLGdCQUFnQixPQUFPLE9BQU8sU0FBUyxHQUFHLEdBQUcsVUFBVTtBQUM5RCxRQUFNLFNBQVMsTUFBTSxVQUFVLEdBQUcsQ0FBQztBQUNuQyxRQUFNLFNBQVMsTUFBTSxVQUFVLEdBQUcsQ0FBQztBQUNuQyxRQUFNLFNBQVMsTUFBTSxVQUFVLENBQUM7QUFDaEMsUUFBTSxTQUFTLE1BQU0sVUFBVSxDQUFDO0FBQ2hDLFFBQU0sUUFBUSxTQUFTLFFBQVEsUUFBUSxTQUFTLE9BQU8sUUFBUTtBQUMvRCxRQUFNLFNBQVMsU0FBUyxRQUFRLFFBQVEsU0FBUyxPQUFPLFFBQVE7QUFDaEUsU0FBTyxNQUFNLE9BQU8sTUFBTTtBQUM1QjtBQUNBLFNBQVMsaUJBQWlCLE9BQU8sT0FBTztBQUN0QyxRQUFNLFlBQVksQ0FBQztBQUNuQixRQUFNLFdBQVcsQ0FBQztBQUNsQixNQUFJLFdBQVc7QUFDZixZQUFVLENBQUMsSUFBSTtBQUNmLFdBQVMsc0JBQXNCQSxPQUFNO0FBQ25DLFFBQUksUUFBUTtBQUNaLFFBQUksWUFBWTtBQUNoQixRQUFJLFVBQVU7QUFDZCxRQUFJLGtCQUFrQixVQUFVO0FBQ2hDLFdBQU8sVUFBVUEsTUFBSyxTQUFTLEdBQUc7QUFDaEMsZ0JBQVVBLE1BQUssUUFBUSxNQUFNLFNBQVM7QUFDdEMsVUFBSSxZQUFZO0FBQ2Qsa0JBQVVBLE1BQUssU0FBUztBQUMxQixVQUFJLE9BQU9BLE1BQUssVUFBVSxXQUFXLFVBQVUsQ0FBQztBQUNoRCxVQUFJLFNBQVMsaUJBQWlCLE9BQU8sVUFBVSxlQUFlLEtBQUssVUFBVSxJQUFJLElBQUksU0FBUyxJQUFJLE1BQU0sUUFBUTtBQUM5RyxpQkFBUyxPQUFPLGFBQWEsU0FBUyxJQUFJLENBQUM7QUFBQSxNQUM3QyxPQUFPO0FBQ0wsWUFBSSxvQkFBb0IsVUFBVTtBQUNoQyxpQkFBT0EsTUFBSyxVQUFVLFNBQVM7QUFDL0Isb0JBQVVBLE1BQUs7QUFBQSxRQUNqQjtBQUNBLGlCQUFTLE9BQU8sYUFBYSxlQUFlO0FBQzVDLGlCQUFTLElBQUksSUFBSTtBQUNqQixrQkFBVSxpQkFBaUIsSUFBSTtBQUFBLE1BQ2pDO0FBQ0Esa0JBQVksVUFBVTtBQUFBLElBQ3hCO0FBQ0EsV0FBTztBQUFBLEVBQ1Q7QUFDQSxRQUFNLFNBQVMsc0JBQXNCLEtBQUs7QUFDMUMsYUFBVztBQUNYLFFBQU0sU0FBUyxzQkFBc0IsS0FBSztBQUMxQyxTQUFPLEVBQUUsUUFBUSxRQUFRLFVBQVU7QUFDckM7QUFDQSxTQUFTLGlCQUFpQixPQUFPLFdBQVc7QUFDMUMsV0FBUyxJQUFJLEdBQUcsSUFBSSxNQUFNLFFBQVEsS0FBSztBQUNyQyxVQUFNLFFBQVEsTUFBTSxDQUFDLEVBQUUsQ0FBQztBQUN4QixVQUFNQSxRQUFPLENBQUM7QUFDZCxhQUFTLElBQUksR0FBRyxJQUFJLE1BQU0sUUFBUTtBQUNoQyxNQUFBQSxNQUFLLENBQUMsSUFBSSxVQUFVLE1BQU0sV0FBVyxDQUFDLENBQUM7QUFDekMsVUFBTSxDQUFDLEVBQUUsQ0FBQyxJQUFJQSxNQUFLLEtBQUssRUFBRTtBQUFBLEVBQzVCO0FBQ0Y7QUFDQSxTQUFTLGlCQUFpQixPQUFPLE9BQU87QUFDdEMsTUFBSSxDQUFDLFNBQVMsQ0FBQyxTQUFTLE1BQU0sT0FBTyxDQUFDLE1BQU0sTUFBTSxPQUFPLENBQUM7QUFDeEQsV0FBTztBQUNULE1BQUksYUFBYTtBQUNqQixNQUFJLGFBQWEsS0FBSyxJQUFJLE1BQU0sUUFBUSxNQUFNLE1BQU07QUFDcEQsTUFBSSxhQUFhO0FBQ2pCLE1BQUksZUFBZTtBQUNuQixTQUFPLGFBQWEsWUFBWTtBQUM5QixRQUFJLE1BQU0sVUFBVSxjQUFjLFVBQVUsTUFBTSxNQUFNLFVBQVUsY0FBYyxVQUFVLEdBQUc7QUFDM0YsbUJBQWE7QUFDYixxQkFBZTtBQUFBLElBQ2pCLE9BQU87QUFDTCxtQkFBYTtBQUFBLElBQ2Y7QUFDQSxpQkFBYSxLQUFLLE9BQU8sYUFBYSxjQUFjLElBQUksVUFBVTtBQUFBLEVBQ3BFO0FBQ0EsU0FBTztBQUNUO0FBQ0EsU0FBUyxpQkFBaUIsT0FBTyxPQUFPO0FBQ3RDLE1BQUksQ0FBQyxTQUFTLENBQUMsU0FBUyxNQUFNLE9BQU8sTUFBTSxTQUFTLENBQUMsTUFBTSxNQUFNLE9BQU8sTUFBTSxTQUFTLENBQUM7QUFDdEYsV0FBTztBQUNULE1BQUksYUFBYTtBQUNqQixNQUFJLGFBQWEsS0FBSyxJQUFJLE1BQU0sUUFBUSxNQUFNLE1BQU07QUFDcEQsTUFBSSxhQUFhO0FBQ2pCLE1BQUksYUFBYTtBQUNqQixTQUFPLGFBQWEsWUFBWTtBQUM5QixRQUFJLE1BQU0sVUFBVSxNQUFNLFNBQVMsWUFBWSxNQUFNLFNBQVMsVUFBVSxNQUFNLE1BQU0sVUFBVSxNQUFNLFNBQVMsWUFBWSxNQUFNLFNBQVMsVUFBVSxHQUFHO0FBQ25KLG1CQUFhO0FBQ2IsbUJBQWE7QUFBQSxJQUNmLE9BQU87QUFDTCxtQkFBYTtBQUFBLElBQ2Y7QUFDQSxpQkFBYSxLQUFLLE9BQU8sYUFBYSxjQUFjLElBQUksVUFBVTtBQUFBLEVBQ3BFO0FBQ0EsU0FBTztBQUNUO0FBQ0EsU0FBUyxrQkFBa0IsT0FBTyxPQUFPO0FBQ3ZDLFFBQU0sZUFBZSxNQUFNO0FBQzNCLFFBQU0sZUFBZSxNQUFNO0FBQzNCLE1BQUksaUJBQWlCLEtBQUssaUJBQWlCO0FBQ3pDLFdBQU87QUFDVCxNQUFJLGVBQWU7QUFDakIsWUFBUSxNQUFNLFVBQVUsZUFBZSxZQUFZO0FBQUEsV0FDNUMsZUFBZTtBQUN0QixZQUFRLE1BQU0sVUFBVSxHQUFHLFlBQVk7QUFDekMsUUFBTSxjQUFjLEtBQUssSUFBSSxjQUFjLFlBQVk7QUFDdkQsTUFBSSxVQUFVO0FBQ1osV0FBTztBQUNULE1BQUksT0FBTztBQUNYLE1BQUlDLFVBQVM7QUFDYixTQUFPLE1BQU07QUFDWCxVQUFNLFVBQVUsTUFBTSxVQUFVLGNBQWNBLE9BQU07QUFDcEQsVUFBTSxRQUFRLE1BQU0sUUFBUSxPQUFPO0FBQ25DLFFBQUksVUFBVTtBQUNaLGFBQU87QUFDVCxJQUFBQSxXQUFVO0FBQ1YsUUFBSSxVQUFVLEtBQUssTUFBTSxVQUFVLGNBQWNBLE9BQU0sTUFBTSxNQUFNLFVBQVUsR0FBR0EsT0FBTSxHQUFHO0FBQ3ZGLGFBQU9BO0FBQ1AsTUFBQUE7QUFBQSxJQUNGO0FBQUEsRUFDRjtBQUNGO0FBQ0EsU0FBUyxjQUFjLE9BQU8sT0FBTyxTQUFTO0FBQzVDLE1BQUksUUFBUSxlQUFlLEdBQUc7QUFDNUIsV0FBTztBQUFBLEVBQ1Q7QUFDQSxRQUFNLFdBQVcsTUFBTSxTQUFTLE1BQU0sU0FBUyxRQUFRO0FBQ3ZELFFBQU0sWUFBWSxNQUFNLFNBQVMsTUFBTSxTQUFTLFFBQVE7QUFDeEQsTUFBSSxTQUFTLFNBQVMsS0FBSyxVQUFVLFNBQVMsSUFBSSxTQUFTO0FBQ3pELFdBQU87QUFDVCxXQUFTLGVBQWUsV0FBVyxZQUFZLEdBQUc7QUFDaEQsVUFBTSxPQUFPLFVBQVUsVUFBVSxHQUFHLElBQUksS0FBSyxNQUFNLFVBQVUsU0FBUyxDQUFDLENBQUM7QUFDeEUsUUFBSSxJQUFJO0FBQ1IsUUFBSSxjQUFjO0FBQ2xCLFFBQUksaUJBQWlCLGlCQUFpQixrQkFBa0I7QUFDeEQsWUFBUSxJQUFJLFdBQVcsUUFBUSxNQUFNLElBQUksQ0FBQyxPQUFPLElBQUk7QUFDbkQsWUFBTSxlQUFlLGlCQUFpQixVQUFVLFVBQVUsQ0FBQyxHQUFHLFdBQVcsVUFBVSxDQUFDLENBQUM7QUFDckYsWUFBTSxlQUFlLGlCQUFpQixVQUFVLFVBQVUsR0FBRyxDQUFDLEdBQUcsV0FBVyxVQUFVLEdBQUcsQ0FBQyxDQUFDO0FBQzNGLFVBQUksWUFBWSxTQUFTLGVBQWUsY0FBYztBQUNwRCxzQkFBYyxXQUFXLFVBQVUsSUFBSSxjQUFjLENBQUMsSUFBSSxXQUFXLFVBQVUsR0FBRyxJQUFJLFlBQVk7QUFDbEcsMEJBQWtCLFVBQVUsVUFBVSxHQUFHLElBQUksWUFBWTtBQUN6RCwwQkFBa0IsVUFBVSxVQUFVLElBQUksWUFBWTtBQUN0RCwyQkFBbUIsV0FBVyxVQUFVLEdBQUcsSUFBSSxZQUFZO0FBQzNELDJCQUFtQixXQUFXLFVBQVUsSUFBSSxZQUFZO0FBQUEsTUFDMUQ7QUFBQSxJQUNGO0FBQ0EsUUFBSSxZQUFZLFNBQVMsS0FBSyxVQUFVO0FBQ3RDLGFBQU8sQ0FBQyxpQkFBaUIsaUJBQWlCLGtCQUFrQixrQkFBa0IsV0FBVztBQUFBO0FBRXpGLGFBQU87QUFBQSxFQUNYO0FBQ0EsUUFBTSxNQUFNLGVBQWUsVUFBVSxXQUFXLEtBQUssS0FBSyxTQUFTLFNBQVMsQ0FBQyxDQUFDO0FBQzlFLFFBQU0sTUFBTSxlQUFlLFVBQVUsV0FBVyxLQUFLLEtBQUssU0FBUyxTQUFTLENBQUMsQ0FBQztBQUM5RSxNQUFJO0FBQ0osTUFBSSxDQUFDLE9BQU8sQ0FBQyxLQUFLO0FBQ2hCLFdBQU87QUFBQSxFQUNULFdBQVcsQ0FBQyxLQUFLO0FBQ2YsU0FBSztBQUFBLEVBQ1AsV0FBVyxDQUFDLEtBQUs7QUFDZixTQUFLO0FBQUEsRUFDUCxPQUFPO0FBQ0wsU0FBSyxJQUFJLENBQUMsRUFBRSxTQUFTLElBQUksQ0FBQyxFQUFFLFNBQVMsTUFBTTtBQUFBLEVBQzdDO0FBQ0EsTUFBSSxTQUFTLFNBQVMsU0FBUztBQUMvQixNQUFJLE1BQU0sU0FBUyxNQUFNLFFBQVE7QUFDL0IsY0FBVSxHQUFHLENBQUM7QUFDZCxjQUFVLEdBQUcsQ0FBQztBQUNkLGNBQVUsR0FBRyxDQUFDO0FBQ2QsY0FBVSxHQUFHLENBQUM7QUFBQSxFQUNoQixPQUFPO0FBQ0wsY0FBVSxHQUFHLENBQUM7QUFDZCxjQUFVLEdBQUcsQ0FBQztBQUNkLGNBQVUsR0FBRyxDQUFDO0FBQ2QsY0FBVSxHQUFHLENBQUM7QUFBQSxFQUNoQjtBQUNBLFFBQU0sYUFBYSxHQUFHLENBQUM7QUFDdkIsU0FBTyxDQUFDLFNBQVMsU0FBUyxTQUFTLFNBQVMsVUFBVTtBQUN4RDtBQUNBLFNBQVMsb0JBQW9CLE9BQU87QUFDbEMsTUFBSSxVQUFVO0FBQ2QsUUFBTSxhQUFhLENBQUM7QUFDcEIsTUFBSSxtQkFBbUI7QUFDdkIsTUFBSSxlQUFlO0FBQ25CLE1BQUksVUFBVTtBQUNkLE1BQUkscUJBQXFCO0FBQ3pCLE1BQUksb0JBQW9CO0FBQ3hCLE1BQUkscUJBQXFCO0FBQ3pCLE1BQUksb0JBQW9CO0FBQ3hCLFNBQU8sVUFBVSxNQUFNLFFBQVE7QUFDN0IsUUFBSSxNQUFNLE9BQU8sRUFBRSxDQUFDLE1BQU0sWUFBWTtBQUNwQyxpQkFBVyxrQkFBa0IsSUFBSTtBQUNqQywyQkFBcUI7QUFDckIsMEJBQW9CO0FBQ3BCLDJCQUFxQjtBQUNyQiwwQkFBb0I7QUFDcEIscUJBQWUsTUFBTSxPQUFPLEVBQUUsQ0FBQztBQUFBLElBQ2pDLE9BQU87QUFDTCxVQUFJLE1BQU0sT0FBTyxFQUFFLENBQUMsTUFBTTtBQUN4Qiw4QkFBc0IsTUFBTSxPQUFPLEVBQUUsQ0FBQyxFQUFFO0FBQUE7QUFFeEMsNkJBQXFCLE1BQU0sT0FBTyxFQUFFLENBQUMsRUFBRTtBQUN6QyxVQUFJLGdCQUFnQixhQUFhLFVBQVUsS0FBSyxJQUFJLG9CQUFvQixpQkFBaUIsS0FBSyxhQUFhLFVBQVUsS0FBSyxJQUFJLG9CQUFvQixpQkFBaUIsR0FBRztBQUNwSyxjQUFNLE9BQU8sV0FBVyxtQkFBbUIsQ0FBQyxHQUFHLEdBQUcsV0FBVyxhQUFhLFlBQVksQ0FBQztBQUN2RixjQUFNLFdBQVcsbUJBQW1CLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxJQUFJO0FBQ2pEO0FBQ0E7QUFDQSxrQkFBVSxtQkFBbUIsSUFBSSxXQUFXLG1CQUFtQixDQUFDLElBQUk7QUFDcEUsNkJBQXFCO0FBQ3JCLDRCQUFvQjtBQUNwQiw2QkFBcUI7QUFDckIsNEJBQW9CO0FBQ3BCLHVCQUFlO0FBQ2Ysa0JBQVU7QUFBQSxNQUNaO0FBQUEsSUFDRjtBQUNBO0FBQUEsRUFDRjtBQUNBLE1BQUk7QUFDRixxQkFBaUIsS0FBSztBQUN4Qiw4QkFBNEIsS0FBSztBQUNqQyxZQUFVO0FBQ1YsU0FBTyxVQUFVLE1BQU0sUUFBUTtBQUM3QixRQUFJLE1BQU0sVUFBVSxDQUFDLEVBQUUsQ0FBQyxNQUFNLGVBQWUsTUFBTSxPQUFPLEVBQUUsQ0FBQyxNQUFNLGFBQWE7QUFDOUUsWUFBTSxXQUFXLE1BQU0sVUFBVSxDQUFDLEVBQUUsQ0FBQztBQUNyQyxZQUFNLFlBQVksTUFBTSxPQUFPLEVBQUUsQ0FBQztBQUNsQyxZQUFNLGtCQUFrQixrQkFBa0IsVUFBVSxTQUFTO0FBQzdELFlBQU0sa0JBQWtCLGtCQUFrQixXQUFXLFFBQVE7QUFDN0QsVUFBSSxtQkFBbUIsaUJBQWlCO0FBQ3RDLFlBQUksbUJBQW1CLFNBQVMsU0FBUyxLQUFLLG1CQUFtQixVQUFVLFNBQVMsR0FBRztBQUNyRixnQkFBTSxPQUFPLFNBQVMsR0FBRyxXQUFXLFlBQVksVUFBVSxVQUFVLEdBQUcsZUFBZSxDQUFDLENBQUM7QUFDeEYsZ0JBQU0sVUFBVSxDQUFDLEVBQUUsQ0FBQyxJQUFJLFNBQVMsVUFBVSxHQUFHLFNBQVMsU0FBUyxlQUFlO0FBQy9FLGdCQUFNLFVBQVUsQ0FBQyxFQUFFLENBQUMsSUFBSSxVQUFVLFVBQVUsZUFBZTtBQUMzRDtBQUFBLFFBQ0Y7QUFBQSxNQUNGLE9BQU87QUFDTCxZQUFJLG1CQUFtQixTQUFTLFNBQVMsS0FBSyxtQkFBbUIsVUFBVSxTQUFTLEdBQUc7QUFDckYsZ0JBQU0sT0FBTyxTQUFTLEdBQUcsV0FBVyxZQUFZLFNBQVMsVUFBVSxHQUFHLGVBQWUsQ0FBQyxDQUFDO0FBQ3ZGLGdCQUFNLFVBQVUsQ0FBQyxFQUFFLENBQUMsSUFBSTtBQUN4QixnQkFBTSxVQUFVLENBQUMsRUFBRSxDQUFDLElBQUksVUFBVSxVQUFVLEdBQUcsVUFBVSxTQUFTLGVBQWU7QUFDakYsZ0JBQU0sVUFBVSxDQUFDLEVBQUUsQ0FBQyxJQUFJO0FBQ3hCLGdCQUFNLFVBQVUsQ0FBQyxFQUFFLENBQUMsSUFBSSxTQUFTLFVBQVUsZUFBZTtBQUMxRDtBQUFBLFFBQ0Y7QUFBQSxNQUNGO0FBQ0E7QUFBQSxJQUNGO0FBQ0E7QUFBQSxFQUNGO0FBQ0Y7QUFDQSxJQUFNLHdCQUF3QjtBQUM5QixJQUFNLG1CQUFtQjtBQUN6QixJQUFNLGtCQUFrQjtBQUN4QixJQUFNLHFCQUFxQjtBQUMzQixJQUFNLHVCQUF1QjtBQUM3QixTQUFTLDRCQUE0QixPQUFPO0FBQzFDLFdBQVMseUJBQXlCLEtBQUssS0FBSztBQUMxQyxRQUFJLENBQUMsT0FBTyxDQUFDLEtBQUs7QUFDaEIsYUFBTztBQUFBLElBQ1Q7QUFDQSxVQUFNLFFBQVEsSUFBSSxPQUFPLElBQUksU0FBUyxDQUFDO0FBQ3ZDLFVBQU0sUUFBUSxJQUFJLE9BQU8sQ0FBQztBQUMxQixVQUFNLG1CQUFtQixNQUFNLE1BQU0scUJBQXFCO0FBQzFELFVBQU0sbUJBQW1CLE1BQU0sTUFBTSxxQkFBcUI7QUFDMUQsVUFBTSxjQUFjLG9CQUFvQixNQUFNLE1BQU0sZ0JBQWdCO0FBQ3BFLFVBQU0sY0FBYyxvQkFBb0IsTUFBTSxNQUFNLGdCQUFnQjtBQUNwRSxVQUFNLGFBQWEsZUFBZSxNQUFNLE1BQU0sZUFBZTtBQUM3RCxVQUFNLGFBQWEsZUFBZSxNQUFNLE1BQU0sZUFBZTtBQUM3RCxVQUFNLGFBQWEsY0FBYyxJQUFJLE1BQU0sa0JBQWtCO0FBQzdELFVBQU0sYUFBYSxjQUFjLElBQUksTUFBTSxvQkFBb0I7QUFDL0QsUUFBSSxjQUFjLFlBQVk7QUFDNUIsYUFBTztBQUFBLElBQ1QsV0FBVyxjQUFjLFlBQVk7QUFDbkMsYUFBTztBQUFBLElBQ1QsV0FBVyxvQkFBb0IsQ0FBQyxlQUFlLGFBQWE7QUFDMUQsYUFBTztBQUFBLElBQ1QsV0FBVyxlQUFlLGFBQWE7QUFDckMsYUFBTztBQUFBLElBQ1QsV0FBVyxvQkFBb0Isa0JBQWtCO0FBQy9DLGFBQU87QUFBQSxJQUNUO0FBQ0EsV0FBTztBQUFBLEVBQ1Q7QUFDQSxNQUFJLFVBQVU7QUFDZCxTQUFPLFVBQVUsTUFBTSxTQUFTLEdBQUc7QUFDakMsUUFBSSxNQUFNLFVBQVUsQ0FBQyxFQUFFLENBQUMsTUFBTSxjQUFjLE1BQU0sVUFBVSxDQUFDLEVBQUUsQ0FBQyxNQUFNLFlBQVk7QUFDaEYsVUFBSSxZQUFZLE1BQU0sVUFBVSxDQUFDLEVBQUUsQ0FBQztBQUNwQyxVQUFJLE9BQU8sTUFBTSxPQUFPLEVBQUUsQ0FBQztBQUMzQixVQUFJLFlBQVksTUFBTSxVQUFVLENBQUMsRUFBRSxDQUFDO0FBQ3BDLFlBQU0sZUFBZSxpQkFBaUIsV0FBVyxJQUFJO0FBQ3JELFVBQUksY0FBYztBQUNoQixjQUFNLGVBQWUsS0FBSyxVQUFVLEtBQUssU0FBUyxZQUFZO0FBQzlELG9CQUFZLFVBQVUsVUFBVSxHQUFHLFVBQVUsU0FBUyxZQUFZO0FBQ2xFLGVBQU8sZUFBZSxLQUFLLFVBQVUsR0FBRyxLQUFLLFNBQVMsWUFBWTtBQUNsRSxvQkFBWSxlQUFlO0FBQUEsTUFDN0I7QUFDQSxVQUFJLGdCQUFnQjtBQUNwQixVQUFJLFdBQVc7QUFDZixVQUFJLGdCQUFnQjtBQUNwQixVQUFJLFlBQVkseUJBQXlCLFdBQVcsSUFBSSxJQUFJLHlCQUF5QixNQUFNLFNBQVM7QUFDcEcsYUFBTyxLQUFLLE9BQU8sQ0FBQyxNQUFNLFVBQVUsT0FBTyxDQUFDLEdBQUc7QUFDN0MscUJBQWEsS0FBSyxPQUFPLENBQUM7QUFDMUIsZUFBTyxLQUFLLFVBQVUsQ0FBQyxJQUFJLFVBQVUsT0FBTyxDQUFDO0FBQzdDLG9CQUFZLFVBQVUsVUFBVSxDQUFDO0FBQ2pDLGNBQU0sUUFBUSx5QkFBeUIsV0FBVyxJQUFJLElBQUkseUJBQXlCLE1BQU0sU0FBUztBQUNsRyxZQUFJLFNBQVMsV0FBVztBQUN0QixzQkFBWTtBQUNaLDBCQUFnQjtBQUNoQixxQkFBVztBQUNYLDBCQUFnQjtBQUFBLFFBQ2xCO0FBQUEsTUFDRjtBQUNBLFVBQUksTUFBTSxVQUFVLENBQUMsRUFBRSxDQUFDLE1BQU0sZUFBZTtBQUMzQyxZQUFJLGVBQWU7QUFDakIsZ0JBQU0sVUFBVSxDQUFDLEVBQUUsQ0FBQyxJQUFJO0FBQUEsUUFDMUIsT0FBTztBQUNMLGdCQUFNLE9BQU8sVUFBVSxHQUFHLENBQUM7QUFDM0I7QUFBQSxRQUNGO0FBQ0EsY0FBTSxPQUFPLEVBQUUsQ0FBQyxJQUFJO0FBQ3BCLFlBQUksZUFBZTtBQUNqQixnQkFBTSxVQUFVLENBQUMsRUFBRSxDQUFDLElBQUk7QUFBQSxRQUMxQixPQUFPO0FBQ0wsZ0JBQU0sT0FBTyxVQUFVLEdBQUcsQ0FBQztBQUMzQjtBQUFBLFFBQ0Y7QUFBQSxNQUNGO0FBQUEsSUFDRjtBQUNBO0FBQUEsRUFDRjtBQUNGO0FBQ0EsU0FBUyxzQkFBc0IsT0FBTyxVQUFVLENBQUMsR0FBRztBQUNsRCxRQUFNO0FBQUEsSUFDSixlQUFlLGVBQWU7QUFBQSxFQUNoQyxJQUFJO0FBQ0osTUFBSSxVQUFVO0FBQ2QsUUFBTSxhQUFhLENBQUM7QUFDcEIsTUFBSSxtQkFBbUI7QUFDdkIsTUFBSSxlQUFlO0FBQ25CLE1BQUksVUFBVTtBQUNkLE1BQUksVUFBVTtBQUNkLE1BQUksVUFBVTtBQUNkLE1BQUksV0FBVztBQUNmLE1BQUksV0FBVztBQUNmLFNBQU8sVUFBVSxNQUFNLFFBQVE7QUFDN0IsUUFBSSxNQUFNLE9BQU8sRUFBRSxDQUFDLE1BQU0sWUFBWTtBQUNwQyxVQUFJLE1BQU0sT0FBTyxFQUFFLENBQUMsRUFBRSxTQUFTLGlCQUFpQixZQUFZLFdBQVc7QUFDckUsbUJBQVcsa0JBQWtCLElBQUk7QUFDakMsa0JBQVU7QUFDVixrQkFBVTtBQUNWLHVCQUFlLE1BQU0sT0FBTyxFQUFFLENBQUM7QUFBQSxNQUNqQyxPQUFPO0FBQ0wsMkJBQW1CO0FBQ25CLHVCQUFlO0FBQUEsTUFDakI7QUFDQSxpQkFBVyxXQUFXO0FBQUEsSUFDeEIsT0FBTztBQUNMLFVBQUksZUFBZSxZQUFZQyxPQUFNO0FBQ25DLGVBQU9BLE1BQUssT0FBTyxPQUFPLEVBQUU7QUFBQSxNQUM5QjtBQUNBLFVBQUksTUFBTSxPQUFPLEVBQUUsQ0FBQyxNQUFNO0FBQ3hCLG1CQUFXO0FBQUE7QUFFWCxtQkFBVztBQUNiLFVBQUksaUJBQWlCLFdBQVcsV0FBVyxZQUFZLFlBQVksYUFBYSxTQUFTLGVBQWUsS0FBSyxhQUFhLFNBQVMsU0FBUyxVQUFVLFFBQVEsTUFBTSxJQUFJO0FBQ3RLLGNBQU0sT0FBTyxXQUFXLG1CQUFtQixDQUFDLEdBQUcsR0FBRyxXQUFXLGFBQWEsWUFBWSxDQUFDO0FBQ3ZGLGNBQU0sV0FBVyxtQkFBbUIsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLElBQUk7QUFDakQ7QUFDQSx1QkFBZTtBQUNmLFlBQUksV0FBVyxTQUFTO0FBQ3RCLHFCQUFXLFdBQVc7QUFDdEIsNkJBQW1CO0FBQUEsUUFDckIsT0FBTztBQUNMO0FBQ0Esb0JBQVUsbUJBQW1CLElBQUksV0FBVyxtQkFBbUIsQ0FBQyxJQUFJO0FBQ3BFLHFCQUFXLFdBQVc7QUFBQSxRQUN4QjtBQUNBLGtCQUFVO0FBQUEsTUFDWjtBQUFBLElBQ0Y7QUFDQTtBQUFBLEVBQ0Y7QUFDQSxNQUFJO0FBQ0YscUJBQWlCLEtBQUs7QUFDMUI7QUFDQSxTQUFTLGlCQUFpQixPQUFPO0FBQy9CLFFBQU0sS0FBSyxXQUFXLFlBQVksRUFBRSxDQUFDO0FBQ3JDLE1BQUksVUFBVTtBQUNkLE1BQUksZUFBZTtBQUNuQixNQUFJLGVBQWU7QUFDbkIsTUFBSSxjQUFjO0FBQ2xCLE1BQUksY0FBYztBQUNsQixNQUFJO0FBQ0osU0FBTyxVQUFVLE1BQU0sUUFBUTtBQUM3QixZQUFRLE1BQU0sT0FBTyxFQUFFLENBQUMsR0FBRztBQUFBLE1BQ3pCLEtBQUs7QUFDSDtBQUNBLHVCQUFlLE1BQU0sT0FBTyxFQUFFLENBQUM7QUFDL0I7QUFDQTtBQUFBLE1BQ0YsS0FBSztBQUNIO0FBQ0EsdUJBQWUsTUFBTSxPQUFPLEVBQUUsQ0FBQztBQUMvQjtBQUNBO0FBQUEsTUFDRixLQUFLO0FBQ0gsWUFBSSxlQUFlLGVBQWUsR0FBRztBQUNuQyxjQUFJLGlCQUFpQixLQUFLLGlCQUFpQixHQUFHO0FBQzVDLDJCQUFlLGlCQUFpQixhQUFhLFdBQVc7QUFDeEQsZ0JBQUksaUJBQWlCLEdBQUc7QUFDdEIsa0JBQUksVUFBVSxlQUFlLGVBQWUsS0FBSyxNQUFNLFVBQVUsZUFBZSxlQUFlLENBQUMsRUFBRSxDQUFDLE1BQU0sWUFBWTtBQUNuSCxzQkFBTSxVQUFVLGVBQWUsZUFBZSxDQUFDLEVBQUUsQ0FBQyxLQUFLLFlBQVksVUFBVSxHQUFHLFlBQVk7QUFBQSxjQUM5RixPQUFPO0FBQ0wsc0JBQU0sT0FBTyxHQUFHLEdBQUcsV0FBVyxZQUFZLFlBQVksVUFBVSxHQUFHLFlBQVksQ0FBQyxDQUFDO0FBQ2pGO0FBQUEsY0FDRjtBQUNBLDRCQUFjLFlBQVksVUFBVSxZQUFZO0FBQ2hELDRCQUFjLFlBQVksVUFBVSxZQUFZO0FBQUEsWUFDbEQ7QUFDQSwyQkFBZSxpQkFBaUIsYUFBYSxXQUFXO0FBQ3hELGdCQUFJLGlCQUFpQixHQUFHO0FBQ3RCLG9CQUFNLE9BQU8sRUFBRSxDQUFDLElBQUksWUFBWSxVQUFVLFlBQVksU0FBUyxZQUFZLElBQUksTUFBTSxPQUFPLEVBQUUsQ0FBQztBQUMvRiw0QkFBYyxZQUFZLFVBQVUsR0FBRyxZQUFZLFNBQVMsWUFBWTtBQUN4RSw0QkFBYyxZQUFZLFVBQVUsR0FBRyxZQUFZLFNBQVMsWUFBWTtBQUFBLFlBQzFFO0FBQUEsVUFDRjtBQUNBLHFCQUFXLGVBQWU7QUFDMUIsZ0JBQU0sT0FBTyxTQUFTLGVBQWUsWUFBWTtBQUNqRCxjQUFJLFlBQVksUUFBUTtBQUN0QixrQkFBTSxPQUFPLFNBQVMsR0FBRyxXQUFXLGFBQWEsV0FBVyxDQUFDO0FBQzdEO0FBQUEsVUFDRjtBQUNBLGNBQUksWUFBWSxRQUFRO0FBQ3RCLGtCQUFNLE9BQU8sU0FBUyxHQUFHLFdBQVcsYUFBYSxXQUFXLENBQUM7QUFDN0Q7QUFBQSxVQUNGO0FBQ0E7QUFBQSxRQUNGLFdBQVcsWUFBWSxLQUFLLE1BQU0sVUFBVSxDQUFDLEVBQUUsQ0FBQyxNQUFNLFlBQVk7QUFDaEUsZ0JBQU0sVUFBVSxDQUFDLEVBQUUsQ0FBQyxLQUFLLE1BQU0sT0FBTyxFQUFFLENBQUM7QUFDekMsZ0JBQU0sT0FBTyxTQUFTLENBQUM7QUFBQSxRQUN6QixPQUFPO0FBQ0w7QUFBQSxRQUNGO0FBQ0EsdUJBQWU7QUFDZix1QkFBZTtBQUNmLHNCQUFjO0FBQ2Qsc0JBQWM7QUFDZDtBQUFBLElBQ0o7QUFBQSxFQUNGO0FBQ0EsTUFBSSxNQUFNLE1BQU0sU0FBUyxDQUFDLEVBQUUsQ0FBQyxNQUFNO0FBQ2pDLFVBQU0sSUFBSTtBQUNaLE1BQUksVUFBVTtBQUNkLFlBQVU7QUFDVixTQUFPLFVBQVUsTUFBTSxTQUFTLEdBQUc7QUFDakMsUUFBSSxNQUFNLFVBQVUsQ0FBQyxFQUFFLENBQUMsTUFBTSxjQUFjLE1BQU0sVUFBVSxDQUFDLEVBQUUsQ0FBQyxNQUFNLFlBQVk7QUFDaEYsVUFBSSxNQUFNLE9BQU8sRUFBRSxDQUFDLEVBQUUsVUFBVSxNQUFNLE9BQU8sRUFBRSxDQUFDLEVBQUUsU0FBUyxNQUFNLFVBQVUsQ0FBQyxFQUFFLENBQUMsRUFBRSxNQUFNLE1BQU0sTUFBTSxVQUFVLENBQUMsRUFBRSxDQUFDLEdBQUc7QUFDbEgsY0FBTSxPQUFPLEVBQUUsQ0FBQyxJQUFJLE1BQU0sVUFBVSxDQUFDLEVBQUUsQ0FBQyxJQUFJLE1BQU0sT0FBTyxFQUFFLENBQUMsRUFBRSxVQUFVLEdBQUcsTUFBTSxPQUFPLEVBQUUsQ0FBQyxFQUFFLFNBQVMsTUFBTSxVQUFVLENBQUMsRUFBRSxDQUFDLEVBQUUsTUFBTTtBQUNsSSxjQUFNLFVBQVUsQ0FBQyxFQUFFLENBQUMsSUFBSSxNQUFNLFVBQVUsQ0FBQyxFQUFFLENBQUMsSUFBSSxNQUFNLFVBQVUsQ0FBQyxFQUFFLENBQUM7QUFDcEUsY0FBTSxPQUFPLFVBQVUsR0FBRyxDQUFDO0FBQzNCLGtCQUFVO0FBQUEsTUFDWixXQUFXLE1BQU0sT0FBTyxFQUFFLENBQUMsRUFBRSxVQUFVLEdBQUcsTUFBTSxVQUFVLENBQUMsRUFBRSxDQUFDLEVBQUUsTUFBTSxNQUFNLE1BQU0sVUFBVSxDQUFDLEVBQUUsQ0FBQyxHQUFHO0FBQ2pHLGNBQU0sVUFBVSxDQUFDLEVBQUUsQ0FBQyxLQUFLLE1BQU0sVUFBVSxDQUFDLEVBQUUsQ0FBQztBQUM3QyxjQUFNLE9BQU8sRUFBRSxDQUFDLElBQUksTUFBTSxPQUFPLEVBQUUsQ0FBQyxFQUFFLFVBQVUsTUFBTSxVQUFVLENBQUMsRUFBRSxDQUFDLEVBQUUsTUFBTSxJQUFJLE1BQU0sVUFBVSxDQUFDLEVBQUUsQ0FBQztBQUNwRyxjQUFNLE9BQU8sVUFBVSxHQUFHLENBQUM7QUFDM0Isa0JBQVU7QUFBQSxNQUNaO0FBQUEsSUFDRjtBQUNBO0FBQUEsRUFDRjtBQUNBLE1BQUk7QUFDRixxQkFBaUIsS0FBSztBQUMxQjs7O0FySnZwQk8sSUFBTSxrQkFBTixjQUE2QixhQUFhO0FBQUEsRUErTXZDLFlBQVksTUFJakIsUUFBeUI7QUF4TzlCO0FBeU9JLFVBQU0sTUFBTTtBQXZNZCxTQUFRLFFBQVEsSUFBSTtBQXdNbEIsUUFBSSxLQUFLLE1BQU07QUFDYixXQUFLLFlBQVEsZ0NBQWMsS0FBSyxJQUFJO0FBQ3BDLFlBQU0sT0FBTyxLQUFLLE9BQU8sSUFBSSxNQUFNLDBCQUFzQixnQ0FBYyxLQUFLLElBQUksQ0FBQztBQUNqRixVQUFLLGdCQUFnQix3QkFBUTtBQUMzQixhQUFLLFFBQVE7QUFBQSxNQUNmLE9BQU87QUFDTCxtQkFBVywwQkFBMEI7QUFBQSxNQUN2QztBQUFBLElBQ0Y7QUFDQSxRQUFJLEtBQUssSUFBSTtBQUNYLFdBQUssV0FBVyxLQUFLO0FBQUEsSUFDdkI7QUFHQSxTQUFLLFFBQU8sVUFBSyxTQUFMLFlBQWEsSUFBTSxJQUFJO0FBQ25DLFNBQUssS0FBSyxHQUFHLFVBQVUsQ0FBQyxRQUFvQixRQUFhLE1BQWEsT0FBc0I7QUFDMUYsVUFBSSxHQUFHLFNBQVMsS0FBSyxhQUFhO0FBQ2hDLGVBQU8sV0FBVyxXQUFXLE1BQU0sTUFBTTtBQUFBLE1BQzNDO0FBQUEsSUFDRixDQUFDO0FBRUQsb0JBQWUsZUFBZSxLQUFLLElBQUk7QUFDdkMsU0FBSyxjQUFjLElBQUksZ0JBQTZCO0FBQ3BELFNBQUssWUFBWSxHQUFHLFVBQVUsTUFBTTtBQUNsQyxVQUFJLEtBQUssWUFBWSxTQUFTLEtBQUssS0FBSyxpQkFBaUI7QUFDdkQsYUFBSyxnQkFBZ0IsVUFBVSxjQUFjLENBQUMsQ0FBQztBQUFBLE1BQ2pEO0FBQUEsSUFDRixDQUFDO0FBRUQsU0FBSyxtQkFBbUIsRUFBRSxRQUFRLFlBQVk7QUFDNUMsVUFBSSxLQUFLLFNBQVMsS0FBSyxZQUFZLFNBQVMsR0FBRztBQUM3Qyx1Q0FBUyxNQUFNO0FBQ2IsZUFBSyxNQUFNLGFBQWEsWUFBWTtBQUNsQyxrQkFBTSxjQUFjLEtBQUssU0FBUztBQUNsQyxrQkFBTSxjQUFjLE1BQU0sS0FBSyxPQUFPLElBQUksTUFBTSxLQUFLLEtBQUssS0FBSztBQUMvRCxnQkFBSSxlQUFlLGFBQWE7QUFDOUIsbUJBQUssaUNBQWlDLElBQUksS0FBSyxFQUFFLFFBQVE7QUFDekQsb0JBQU0sS0FBSyxPQUFPLElBQUksTUFBTSxPQUFPLEtBQUssT0FBTyxhQUFhO0FBQUEsZ0JBQzFELE9BQU8sS0FBSztBQUFBLGNBQ2QsQ0FBQztBQUFBLFlBQ0g7QUFBQSxVQUNGLENBQUM7QUFBQSxRQUNILEdBQUcsS0FBTSxJQUFJLEVBQUU7QUFBQSxNQUNqQjtBQUFBLElBQ0YsQ0FBQztBQUVELFNBQUssT0FBTyxjQUFjLEtBQUssT0FBTyxJQUFJLE1BQU0sR0FBRyxVQUFVLE9BQU8sU0FBUztBQUczRSxVQUFJLEtBQUssU0FBUyxRQUFRLEtBQUssWUFBWSxTQUFTLEtBQUssS0FBSyxLQUFLLEtBQUssU0FBUyxLQUFLLGdDQUFnQztBQUVwSCxhQUFLLE1BQU0sYUFBYSxZQUFZO0FBQ2xDLGdCQUFNLGNBQWMsS0FBSyxTQUFTO0FBQ2xDLGdCQUFNLGNBQWMsTUFBTSxLQUFLLE9BQU8sSUFBSSxNQUFNLEtBQUssS0FBSyxLQUFLO0FBQy9ELGNBQUksZUFBZSxhQUFhO0FBQzlCLGtCQUFNLFFBQVEsU0FBSyxhQUFhLFdBQVc7QUFDM0Msa0NBQXNCLEtBQUs7QUFDM0Isa0JBQU0sVUFBVSxLQUFLLG1CQUFtQjtBQUN4QyxnQkFBSSxNQUFNO0FBQ1YsaUJBQUssS0FBSyxTQUFTLE1BQU07QUFDdkIseUJBQVcsUUFBUSxPQUFPO0FBQ3hCLHNCQUFNQyxRQUFPLEtBQUssQ0FBQztBQUNuQixzQkFBTUMsVUFBU0QsTUFBSztBQUNwQix3QkFBUSxLQUFLLENBQUMsR0FBRztBQUFBLGtCQUVmLEtBQUs7QUFDSDtBQUNFLDZCQUFPQztBQUFBLG9CQUNUO0FBQ0E7QUFBQSxrQkFFRixLQUFLO0FBQ0g7QUFDRSw4QkFBUSxPQUFPLEtBQUtBLE9BQU07QUFBQSxvQkFDNUI7QUFDQTtBQUFBLGtCQUVGLEtBQUs7QUFDSDtBQUNFLDhCQUFRLE9BQU8sS0FBS0QsS0FBSTtBQUN4Qiw2QkFBT0M7QUFBQSxvQkFDVDtBQUNBO0FBQUEsZ0JBQ0o7QUFBQSxjQUNGO0FBQUEsWUFDRixDQUFDO0FBQUEsVUFDSDtBQUFBLFFBQ0YsQ0FBQztBQUFBLE1BQ0g7QUFBQSxJQUNGLENBQUMsQ0FBQztBQUVGLHFCQUFpQixLQUFLLE1BQU0sS0FBSyxNQUFNO0FBQUEsRUFDekM7QUFBQSxFQWpTQSxhQUFhLFNBQVMsTUFBb0IsUUFBeUIsT0FBTyxFQUFFLFdBQVcsTUFBTSxHQUFHO0FBQzlGLFFBQUksQ0FBQyxLQUFLO0FBQU07QUFDaEIsUUFBSSxLQUFLLFdBQVcsS0FBSyxLQUFLLElBQUk7QUFBRztBQUNyQyxVQUFNQyxPQUFNLE1BQU0sS0FBSyxVQUFVLEtBQUssTUFBTSxNQUFNLE1BQU07QUFDeEQsUUFBSUEsTUFBSztBQUNQLE1BQUFBLEtBQUksZ0JBQWdCO0FBQ3BCLFVBQUlBLEtBQUksZUFBZUEsS0FBSSxpQkFBaUI7QUFDMUMsUUFBQUEsS0FBSSxpQkFBaUIsRUFBRSxPQUFPLEdBQUdBLEtBQUksZ0JBQWdCLFVBQVUsU0FBUyxRQUFRLENBQUMsQ0FBQztBQUFBLE1BQ3BGLE9BQU87QUFDTCxRQUFBQSxLQUFJLGtCQUFrQjtBQUN0QixnQkFBUSxLQUFLLElBQUk7QUFBQSxNQUNuQjtBQUNBLGdCQUFVLFVBQVUsVUFBVSxPQUFPLFNBQVMsV0FBVyxTQUFTQSxLQUFJLE9BQU87QUFDN0UsaUJBQVcsK0JBQStCQSxLQUFJLE9BQU8sNkJBQTZCO0FBQUEsSUFDcEY7QUFDQSxXQUFPQTtBQUFBLEVBQ1Q7QUFBQSxFQUVBLGFBQWEsMkJBQTJCLElBQTRCLFFBQXlCO0FBQzNGLFFBQUksS0FBSyxXQUFXLEdBQUcsSUFBSTtBQUFHO0FBRzlCLFVBQU0sT0FBTyxPQUFPLElBQUksTUFBTSwwQkFBc0IsZ0NBQWMsR0FBRyxJQUFJLENBQUM7QUFDMUUsUUFBSSxDQUFDLE1BQU07QUFDVCxpQkFBVyxVQUFVLEdBQUcsT0FBTyw4QkFBOEI7QUFDN0QsWUFBTSxhQUFhLGdCQUFxQixjQUFRLEdBQUcsSUFBSSxHQUFHLE1BQU07QUFDaEUsWUFBTUMsUUFBTyxNQUFNLE9BQU8sSUFBSSxNQUFNLE9BQU8sR0FBRyxNQUFNLEVBQUU7QUFDdEQsVUFBSSxDQUFDQSxPQUFNO0FBQ1QsbUJBQVcseUJBQXlCLEdBQUcsT0FBTyxHQUFHO0FBQ2pEO0FBQUEsTUFDRjtBQUFBLElBRUY7QUFFQSxVQUFNRCxPQUFNLElBQUksZ0JBQWU7QUFBQSxNQUM3QixNQUFNLEdBQUc7QUFBQSxJQUNYLEdBQUcsTUFBTTtBQUNULElBQUFBLEtBQUksZUFBZTtBQUNuQixJQUFBQSxLQUFJLFdBQVcsR0FBRztBQUNsQixVQUFNQSxLQUFJLG1CQUFtQjtBQUU3QixJQUFBQSxLQUFJLGVBQWU7QUFFbkIsV0FBTyxtQkFBbUIsSUFBSSxDQUFDQSxLQUFJLE9BQU8sQ0FBQztBQUMzQyxXQUFPQTtBQUFBLEVBQ1Q7QUFBQSxFQUVBLGFBQWEsYUFBYSxLQUFhLFFBQXlEO0FBQzlGLFVBQU1FLE1BQUssSUFBSSxNQUFNLEdBQUcsRUFBRSxJQUFJO0FBQzlCLFFBQUksQ0FBQ0EsT0FBTSxDQUFDQSxJQUFHLE1BQU0sZ0VBQWdFLEdBQUc7QUFDdEYsaUJBQVcseUJBQXlCO0FBQ3BDO0FBQUEsSUFDRjtBQUVBLFVBQU0sY0FBYyxnQkFBZSxTQUFTQSxHQUFFO0FBQzlDLFFBQUksYUFBYTtBQUNmLGlCQUFXLG1DQUFtQyxZQUFZLElBQUk7QUFDOUQ7QUFBQSxJQUNGO0FBRUEsVUFBTSxjQUFjLE1BQU0sT0FBTyxVQUFVLG1CQUFtQkEsR0FBRTtBQUVoRSxVQUFNLE9BQU8sSUFBTSxJQUFJO0FBRXZCLGVBQVcsNEJBQTRCO0FBRXZDLFVBQU1GLE9BQU0sSUFBSSxnQkFBZTtBQUFBLE1BQzdCLElBQUFFO0FBQUEsTUFDQTtBQUFBLElBQ0YsR0FBRyxNQUFNO0FBSVQsVUFBTSxJQUFJLFFBQWMsQ0FBQ0MsYUFBWTtBQUNuQyxNQUFBSCxLQUFJLGdCQUFnQjtBQUNwQixVQUFJLGFBQWE7QUFDZixRQUFBQSxLQUFJLGVBQWU7QUFBQSxNQUNyQjtBQUNBLFdBQUssS0FBSyxVQUFVLE1BQU07QUFDeEIsUUFBQUcsU0FBUTtBQUFBLE1BQ1YsQ0FBQztBQUFBLElBQ0gsQ0FBQztBQUVELFVBQU0sY0FBY0gsS0FBSSxLQUFLLFFBQVEsa0JBQWtCLEVBQUUsU0FBUztBQUNsRSxRQUFJLGtCQUFrQixzQkFBc0JFLE9BQU0scUJBQXFCO0FBQ3ZFLFFBQUksZUFBZSxJQUFJO0FBQ3JCLFlBQU0sYUFBYSxPQUFPLElBQUksTUFBTSwwQkFBc0IsZ0NBQWMsV0FBVyxDQUFDO0FBQ3BGLFVBQUksQ0FBQyxZQUFZO0FBQ2YsMEJBQWtCO0FBQUEsTUFDcEIsT0FBTztBQUNMLDBCQUFrQixjQUFjLHFCQUFxQixLQUFLO0FBQUEsTUFDNUQ7QUFBQSxJQUNGO0FBRUEsVUFBTSxTQUFTLE9BQU8sU0FBUyxRQUFRLE9BQU8sSUFBSSxZQUFZLGlCQUFpQixJQUFJLGVBQWUsRUFBRTtBQUNwRyxVQUFNLFdBQWdCLFdBQUssUUFBUSxlQUFlO0FBQ2xELFVBQU0sU0FBUyxNQUFNLGFBQWEsZ0JBQXFCLGNBQVEsUUFBUSxHQUFHLE1BQU07QUFDaEYsVUFBTSxPQUFPLE1BQU0sT0FBTyxJQUFJLE1BQU0sT0FBTyxVQUFVRixLQUFJLFNBQVMsQ0FBQztBQUNuRSxxQkFBaUIsS0FBSyxNQUFNLE1BQU07QUFDbEMsSUFBQUEsS0FBSSxRQUFRO0FBQ1osSUFBQUEsS0FBSSxRQUFRLEtBQUs7QUFFakIsUUFBSSxhQUFhO0FBQ2YsTUFBQUEsS0FBSSxlQUFlO0FBQ25CLFlBQU0sSUFBSUEsTUFBSyxNQUFNO0FBQ3JCLFlBQU1BLEtBQUksbUJBQW1CO0FBQzdCLGFBQU8sbUJBQW1CLElBQUksQ0FBQ0EsS0FBSSxPQUFPLENBQUM7QUFBQSxJQUM3QztBQUVBLFVBQU0sT0FBTyxNQUFNLGlCQUFpQixNQUFNLE9BQU8sSUFBSSxTQUFTO0FBQzlELElBQUFBLEtBQUksa0JBQWtCO0FBRXRCLElBQUFBLEtBQUksbUJBQW1CLEtBQUssRUFBRTtBQUM5QixZQUFRLElBQUk7QUFDWixlQUFXLHVCQUF1QkEsS0FBSSxPQUFPLEdBQUc7QUFDaEQsV0FBT0E7QUFBQSxFQUVUO0FBQUEsRUFFQSxhQUFhLGNBQWNFLEtBQVlFLFdBQWtCLFFBQXlCO0FBQ2hGLFVBQU0scUJBQWlCLGdDQUFjQSxTQUFRO0FBQzdDLFVBQU0sY0FBYyxnQkFBZSxTQUFTRixHQUFFO0FBQzlDLFFBQUksYUFBYTtBQUNmLGlCQUFXLG1DQUFtQyxZQUFZLElBQUk7QUFDOUQ7QUFBQSxJQUNGO0FBQ0EsVUFBTSxhQUFhLGdCQUFxQixjQUFRLGNBQWMsR0FBRyxNQUFNO0FBQ3ZFLGVBQVcsOEJBQThCLGNBQWM7QUFDdkQsVUFBTSxPQUFPLE1BQU0sT0FBTyxXQUFXLGdCQUFnQkEsR0FBRTtBQUN2RCxVQUFNRixPQUFNLElBQUksZ0JBQWU7QUFBQSxNQUM3QixJQUFBRTtBQUFBLE1BQUksTUFBTTtBQUFBLElBQ1osR0FBRyxNQUFNO0FBQ1QsSUFBQUYsS0FBSSxRQUFRO0FBRVosVUFBTSxPQUFPLE1BQU0sT0FBTyxJQUFJLE1BQU0sT0FBTyxnQkFBZ0IsS0FBSyxRQUFRLFNBQVMsRUFBRSxTQUFTLENBQUM7QUFDN0YsSUFBQUEsS0FBSSxRQUFRO0FBRVosSUFBQUEsS0FBSSxlQUFlO0FBQ25CLFVBQU1BLEtBQUksYUFBYTtBQUN2QixVQUFNQSxLQUFJLG1CQUFtQjtBQUM3QixxQkFBaUJBLEtBQUksTUFBTSxNQUFNO0FBQUEsRUFDbkM7QUFBQSxFQUdBLGFBQWEsVUFBVSxNQUFhLE1BQStCLFFBQXlCO0FBQzFGLFFBQUksQ0FBQyxDQUFDLE1BQU0sSUFBSSxFQUFFLFNBQVMsS0FBSyxTQUFTO0FBQUc7QUFDNUMsVUFBTSxXQUFXLGdCQUFlLFdBQVcsS0FBSyxJQUFJO0FBQ3BELFFBQUk7QUFBVSxhQUFPO0FBRXJCLFVBQU1BLE9BQU0sSUFBSSxnQkFBZSxFQUFFLE1BQU0sS0FBSyxLQUFLLEdBQUcsTUFBTTtBQUMxRCxVQUFNLFVBQVUsaUJBQWlCLEtBQUssTUFBTSxPQUFPLEdBQUc7QUFFdEQsUUFBSSxRQUFRLFNBQVMsR0FBRztBQUN0QixZQUFNLFVBQVcsT0FBTyxJQUFJLFVBQVUsWUFBWSxRQUFRLENBQUMsQ0FBQyxFQUFFLEtBQXNCLE9BQU8sU0FBUztBQUNwRyxNQUFBQSxLQUFJLG1CQUFtQixFQUFFLE9BQU8sR0FBRyxPQUFPO0FBQUEsSUFDNUMsT0FBTztBQUNMLFlBQU0sVUFBVSxNQUFNLE9BQU8sSUFBSSxNQUFNLEtBQUssSUFBSTtBQUNoRCxNQUFBQSxLQUFJLG1CQUFtQixFQUFFLE9BQU8sR0FBRyxPQUFPO0FBQUEsSUFDNUM7QUFFQSxJQUFBQSxLQUFJLEtBQUssUUFBUSxrQkFBa0IsRUFBRSxPQUFPLEdBQUcsS0FBSyxJQUFJO0FBRXhELFFBQUksS0FBSyxXQUFXO0FBQ2xCLFlBQU1BLEtBQUksZUFBZTtBQUN6QixZQUFNQSxLQUFJLGFBQWE7QUFFdkIsTUFBQUEsS0FBSSxtQkFBbUI7QUFBQSxJQUN6QixPQUFPO0FBQ0wsTUFBQUEsS0FBSSxXQUFXLGVBQWU7QUFBQSxJQUNoQztBQUVBLGVBQVdFLE9BQU0sU0FBUztBQUN4QixNQUFBRixLQUFJLG1CQUFtQkUsR0FBRTtBQUFBLElBQzNCO0FBRUEsZUFBVywyQkFBMkIsS0FBSyxNQUFNO0FBQ2pELFdBQU9GO0FBQUEsRUFDVDtBQUFBLEVBRUEsT0FBTyxXQUFXSyxPQUFjO0FBQzlCLFdBQU8sTUFBTSxXQUFXQSxLQUFJO0FBQUEsRUFDOUI7QUFBQSxFQUVBLE9BQU8sU0FBU0gsS0FBWTtBQUMxQixXQUFPLE1BQU0sU0FBU0EsR0FBRTtBQUFBLEVBQzFCO0FBQUEsRUFFQSxPQUFPLFNBQVM7QUFDZCxXQUFPLE1BQU0sT0FBTztBQUFBLEVBQ3RCO0FBQUEsRUFzR0EsSUFBSSxPQUFPO0FBQ1QsV0FBTyxLQUFLO0FBQUEsRUFDZDtBQUFBLEVBRUEsZ0JBQWdCO0FBQ2QsVUFBTUosUUFBTyxLQUFLLG1CQUFtQixFQUFFLFNBQVM7QUFDaEQsV0FBTyxjQUFjQSxLQUFJO0FBQUEsRUFDM0I7QUFBQSxFQUVBLGtCQUFrQjtBQUNoQixXQUFPLE1BQU0sZ0JBQWdCLENBQUMsYUFBYTtBQUV6QyxlQUFTLFVBQVUsbUJBQW1CLFFBQVE7QUFBQSxRQUM1QyxNQUFNLEtBQUssT0FBTyxTQUFTO0FBQUEsUUFDM0IsT0FBTyxnQkFBZSxXQUFXO0FBQUEsUUFDakMsWUFBWSxnQkFBZSxXQUFXO0FBQUEsTUFDeEMsQ0FBQztBQUdELGVBQVMsVUFBVSxHQUFHLFVBQVUsT0FBTyxRQUEwRDtBQTNWdkc7QUE0VlEsY0FBTSxXQUFVLFNBQUksWUFBSixZQUFlLENBQUM7QUFDaEMsWUFBSSxXQUFXLFFBQVEsU0FBUyxHQUFHO0FBQ2pDLGdCQUFNLGlCQUFpQixRQUFRLElBQUksQ0FBQ0ksUUFBTztBQUN6QyxtQkFBT0EsSUFBRyxRQUFRLENBQUM7QUFBQSxVQUNyQixDQUFDO0FBRUQsZ0JBQU0sUUFBUSxLQUFLLGlCQUFpQixFQUFFLFNBQVM7QUFDL0MsY0FBSSxTQUFTLFNBQVMsVUFBVSxTQUFTLFNBQVMsR0FBRztBQUNuRCxnQkFBSSxlQUFlLFNBQVMsS0FBSyxLQUFLLENBQUMsS0FBSyxhQUFhO0FBQ3ZELHlCQUFXLHdCQUF3QixLQUFLLE9BQU8sbUJBQW1CO0FBQ2xFLG9CQUFNLEtBQUssUUFBUTtBQUFBLFlBQ3JCO0FBQUEsVUFDRjtBQUFBLFFBQ0Y7QUFHQSxjQUFNLFNBQVEsU0FBSSxVQUFKLFlBQWEsQ0FBQztBQUM1QixZQUFJLFNBQVMsTUFBTSxTQUFTLEdBQUc7QUFDN0IsZ0JBQU0sU0FBUyxTQUFTLFVBQVUsVUFBVTtBQUM1QyxxQkFBVyxPQUFPLE9BQU87QUFDdkIsa0JBQU0sT0FBTyxPQUFPLElBQUksR0FBRztBQUMzQixnQkFBSSxRQUFRLEtBQUssUUFBUSxTQUFPLFVBQUssb0JBQUwsbUJBQXNCLFVBQVUsV0FBVTtBQUN4RSx5QkFBVyxJQUFHLFVBQUssU0FBTCxtQkFBVyxzQkFBc0IsS0FBSyxRQUFRLEdBQUs7QUFBQSxZQUNuRTtBQUFBLFVBQ0Y7QUFBQSxRQUNGO0FBQUEsTUFDRixDQUFDO0FBQUEsSUF5QkgsQ0FBQztBQUFBLEVBRUg7QUFBQSxFQUVBLE1BQU0sbUJBQW1CLE1BQWE7QUFDcEMsVUFBTSxVQUFVLEtBQUs7QUFDckIsU0FBSyxRQUFRO0FBQ2IsU0FBSyxZQUFRLGdDQUFjLEtBQUssSUFBSTtBQUNwQyxRQUFJLEtBQUssZ0JBQWdCO0FBQ3ZCLFdBQUssMkJBQTJCO0FBQ2hDLFdBQUssa0JBQWtCO0FBQUEsSUFDekI7QUFDQSxVQUFNLFFBQVEsU0FBUyxLQUFLLE1BQU0sS0FBSyxNQUFNO0FBQzdDLHdCQUFvQixTQUFTLEtBQUssTUFBTTtBQUN4QyxxQkFBaUIsS0FBSyxNQUFNLEtBQUssTUFBTTtBQUFBLEVBQ3pDO0FBQUEsRUFFQSxNQUFNLGVBQWU7QUFDbkIsUUFBSSxDQUFDLEtBQUssY0FBYztBQUN0QixXQUFLLGVBQWU7QUFDcEIsWUFBTSxJQUFJLE1BQU0sS0FBSyxNQUFNO0FBQzNCLFdBQUssT0FBTyxtQkFBbUIsSUFBSSxDQUFDLEtBQUssT0FBTyxDQUFDO0FBQUEsSUFDbkQ7QUFBQSxFQUNGO0FBQUEsRUFFQSxJQUFJLGNBQWM7QUFDaEIsV0FBTyxLQUFLO0FBQUEsRUFDZDtBQUFBLEVBRUEsV0FBVztBQUNULFdBQU8sS0FBSyxtQkFBbUIsRUFBRSxTQUFTO0FBQUEsRUFDNUM7QUFBQSxFQUVBLHFCQUFxQjtBQUNuQixXQUFPLEtBQUssS0FBSyxRQUFRLFNBQVM7QUFBQSxFQUNwQztBQUFBLEVBRUEsbUJBQW1CO0FBQ2pCLFdBQU8sS0FBSyxLQUFLLFFBQVEsT0FBTztBQUFBLEVBQ2xDO0FBQUEsRUFFQSxNQUFNLHFCQUFxQjtBQXhiN0I7QUF5YkksUUFBSSxLQUFLO0FBQW9CLGFBQU8sS0FBSztBQUN6QyxVQUFNQSxPQUFNLGtCQUFhLEtBQUssTUFBTSxLQUFLLE1BQU0sTUFBbkMsbUJBQXVDO0FBQ25ELFFBQUksQ0FBQ0E7QUFBSTtBQUNULFVBQU0sV0FBVyxJQUFJLHFCQUFxQixhQUFhLHdCQUF3QkEsS0FBSSxLQUFLLElBQUk7QUFDNUYsU0FBSyxxQkFBcUI7QUFDMUIsUUFBSSxDQUFDLFNBQVM7QUFBUSxZQUFNLFNBQVM7QUFFckMsV0FBTyxLQUFLO0FBQUEsRUFDZDtBQUFBLEVBRUEsbUJBQW1CLFFBQWdCO0FBRWpDLFVBQU0saUJBQWlCLEtBQUssZ0JBQWdCO0FBQzVDLFFBQUksQ0FBQztBQUFnQjtBQUVyQixRQUFJLEtBQUssWUFBWSxJQUFJLE1BQU07QUFBRztBQUVsQyxVQUFNLFFBQVEsS0FBSyxPQUFPLElBQUksSUFBSSxNQUFNO0FBQ3hDLFFBQUksQ0FBQztBQUFPO0FBSVosUUFBSSxNQUFNLFFBQVEsS0FBSztBQUFPO0FBQzlCLFFBQUksTUFBTSxXQUFXO0FBQ25CLFlBQU0sS0FBSyxtQkFBbUIsTUFBTTtBQUNsQyxhQUFLLG1CQUFtQixNQUFNO0FBQUEsTUFDaEMsQ0FBQztBQUNEO0FBQUEsSUFDRjtBQUVBLFVBQU0sT0FBTyxLQUFLLE9BQU8sSUFBSSxVQUFVLFlBQVksTUFBTTtBQUN6RCxRQUFJLENBQUM7QUFBTTtBQUNYLFVBQU0sT0FBTyxLQUFLO0FBQ2xCLFVBQU0sU0FBUyxLQUFLO0FBRXBCLFdBQU8sU0FBUyxLQUFLLFNBQVMsQ0FBQztBQUUvQixVQUFNLGNBQWMsSUFBTSxZQUFZLEtBQUssbUJBQW1CLENBQUM7QUFFL0QsVUFBTSxZQUFZLFFBQVEsS0FBSyxtQkFBbUIsR0FBRyxlQUFlLFdBQVcsRUFBRSxZQUFZLENBQUM7QUFDOUYsVUFBTSxjQUFjLElBQUkseUJBQVk7QUFFcEMsVUFBTSxhQUFjLE9BQWU7QUFDbkMsZUFBVyxTQUFTO0FBQUEsTUFDbEIsU0FBUywwQkFBWSxhQUFhLEdBQUcsWUFBWSxHQUFHLFNBQVMsQ0FBQztBQUFBLElBQ2hFLENBQUM7QUFFRCxTQUFLLFlBQVksSUFBSSxRQUFRLFdBQVc7QUFHeEMsVUFBTSxLQUFLLG1CQUFtQixNQUFNO0FBQ2xDLFdBQUssd0JBQXdCLE1BQU07QUFFbkMsWUFBTSxLQUFLLG1CQUFtQixNQUFNO0FBQ2xDLGFBQUssbUJBQW1CLE1BQU07QUFBQSxNQUNoQyxDQUFDO0FBQUEsSUFDSCxDQUFDO0FBRUQsV0FBTztBQUFBLEVBQ1Q7QUFBQSxFQUVBLHdCQUF3QixRQUFnQjtBQUN0QyxVQUFNLE9BQU8sS0FBSyxPQUFPLElBQUksVUFBVSxZQUFZLE1BQU07QUFDekQsUUFBSSxNQUFNO0FBQ1IsVUFBSTtBQUNGLGNBQU0sU0FBVSxLQUFLLEtBQXNCO0FBQzNDLGNBQU0sYUFBYyxPQUFlO0FBQ25DLGNBQU0sY0FBYyxLQUFLLFlBQVksSUFBSSxNQUFNO0FBQy9DLFlBQUksYUFBYTtBQUNmLHFCQUFXLFNBQVM7QUFBQSxZQUNsQixTQUFTLFlBQVksWUFBWSxDQUFDLENBQUM7QUFBQSxVQUNyQyxDQUFDO0FBQUEsUUFDSDtBQUFBLE1BQ0YsU0FBUyxPQUFQO0FBQ0EsYUFBSyxPQUFPLElBQUkscUJBQXFCO0FBQUEsTUFDdkM7QUFBQSxJQUNGO0FBQ0EsU0FBSyxZQUFZLE9BQU8sTUFBTTtBQUFBLEVBQ2hDO0FBQUEsRUFFQSxvQkFBb0I7QUFDbEIsUUFBSSxLQUFLO0FBQWdCO0FBQ3pCLFVBQU0sT0FBTyxJQUFJLHNCQUFLO0FBQ3RCLFNBQUssUUFBUSxDQUFDLFNBQVM7QUFDckIsV0FBSyxTQUFTLFdBQVc7QUFDekIsV0FBSyxRQUFRLE1BQU07QUFDakIsa0JBQVUsVUFBVSxVQUFVLEtBQUssT0FBTyxTQUFTLFdBQVcsU0FBUyxLQUFLLE9BQU87QUFDbkYsbUJBQVcsMkJBQTJCO0FBQUEsTUFDeEMsQ0FBQztBQUFBLElBQ0gsQ0FBQztBQUVELFNBQUssUUFBUSxDQUFDLFNBQVM7QUFDckIsV0FBSyxTQUFTLHFCQUFxQjtBQUNuQyxXQUFLLFFBQVEsWUFBWTtBQUN2QixjQUFNLEtBQUssUUFBUTtBQUFBLE1BQ3JCLENBQUM7QUFBQSxJQUNILENBQUM7QUFFRCxVQUFNLFNBQVMsS0FBSyxPQUFPLGlCQUFpQjtBQUM1QyxXQUFPLFNBQVMsZUFBZTtBQUMvQixXQUFPLFNBQVMsUUFBUSxFQUFFLE1BQU0sY0FBYyxLQUFLLE9BQU8sSUFBSSxDQUFDO0FBQy9ELFdBQU8sYUFBYSxDQUFDLFVBQVU7QUFDN0IsV0FBSyxpQkFBaUIsS0FBSztBQUFBLElBQzdCLENBQUM7QUFDRCxTQUFLLGlCQUFpQjtBQUFBLEVBQ3hCO0FBQUEsRUFFQSw2QkFBNkI7QUFDM0IsUUFBSSxDQUFDLEtBQUs7QUFBZ0I7QUFDMUIsU0FBSyxlQUFlLE9BQU87QUFDM0IsU0FBSyxpQkFBaUI7QUFBQSxFQUN4QjtBQUFBLEVBRUEsTUFBTSxVQUFVO0FBQ2QsVUFBTSxVQUFVLGFBQWEsS0FBSyxNQUFNLEtBQUssTUFBTTtBQUNuRCxRQUFJLFNBQVM7QUFDWCxnQkFBVSxLQUFLLE1BQU0sS0FBSyxNQUFNO0FBQUEsSUFDbEM7QUFDQSxRQUFJLEtBQUssb0JBQW9CO0FBQzNCLFlBQU0sS0FBSyxtQkFBbUIsVUFBVTtBQUFBLElBQzFDO0FBQ0EsU0FBSyxRQUFRO0FBQ2Isd0JBQW9CLEtBQUssTUFBTSxLQUFLLE1BQU07QUFBQSxFQUM1QztBQUFBLEVBR0EsVUFBVTtBQUNSLFFBQUksQ0FBQyxLQUFLLGFBQWE7QUFDckIsaUJBQVcsK0JBQStCLEtBQUssT0FBTyxHQUFHO0FBQUEsSUFDM0Q7QUFDQSxlQUFXLE9BQU8sS0FBSyxZQUFZLE1BQU07QUFDdkMsV0FBSyx3QkFBd0IsR0FBRztBQUFBLElBQ2xDO0FBQ0EsU0FBSyxZQUFZLFFBQVE7QUFDekIsVUFBTSxRQUFRO0FBQ2QsU0FBSywyQkFBMkI7QUFDaEMsb0JBQWUsZUFBZSxPQUFPLGdCQUFlLGVBQWUsUUFBUSxJQUFJLEdBQUcsQ0FBQztBQUFBLEVBQ3JGO0FBQ0Y7QUE5aUJPLElBQU0saUJBQU47QUFBTSxlQUVJLGFBQWEsV0FBVyxhQUFhLElBQUksV0FBVyxNQUFNO0FBRjlELGVBV00saUJBQXdDLElBQUksTUFBc0I7OztBc0pSckYsSUFBTSxnQkFBZ0IsQ0FBQyxTQUFpQjtBQXhCeEM7QUF5QkUsUUFBTSxVQUFVLEtBQUssTUFBTSxJQUFJO0FBQy9CLGFBQVdJLE9BQU0sUUFBUSxNQUFNO0FBQzdCLHlCQUFlLFNBQVNBLEdBQUUsTUFBMUIsbUJBQTZCO0FBQzdCLHVCQUFhLFNBQVNBLEdBQUUsTUFBeEIsbUJBQTJCO0FBQUEsRUFDN0I7QUFDRjtBQUVBLElBQU1DLFdBQVUsQ0FBQyxXQUErQjtBQUM5QyxNQUFJLE9BQU8saUJBQWlCLE9BQU8sT0FBTyxNQUFNO0FBQzlDLFVBQU0sWUFBWSxJQUFJLFVBQVUsT0FBTyxHQUFHO0FBQzFDLFdBQU8sS0FBSztBQUNaLFdBQU8sZUFBZTtBQUN0QixXQUFPLGNBQWM7QUFFckIsY0FBVSxZQUFZLENBQUMsVUFBVTtBQUMvQixhQUFPLHdCQUE2QixZQUFZO0FBQ2hELG9CQUFjLE1BQU0sSUFBSTtBQUFBLElBQzFCO0FBRUEsY0FBVSxVQUFVLENBQUMsVUFBVTtBQUM3QixhQUFPLEtBQUssb0JBQW9CLENBQUMsT0FBTyxNQUFNLENBQUM7QUFBQSxJQUNqRDtBQUVBLGNBQVUsVUFBVSxDQUFDLFVBQVU7QUFDN0IsYUFBTyxLQUFLLG9CQUFvQixDQUFDLE9BQU8sTUFBTSxDQUFDO0FBQy9DLGFBQU8sS0FBSztBQUNaLGFBQU8sZUFBZTtBQUN0QixVQUFJLE9BQU8sYUFBYTtBQUN0QixlQUFPLGNBQWM7QUFFckIsZUFBTyxLQUFLLFVBQVUsQ0FBQztBQUFBLFVBQ3JCLFFBQVE7QUFBQSxRQUNWLENBQUMsQ0FBQztBQUFBLE1BRUosT0FBTztBQUNMLGVBQU87QUFBQSxNQUNUO0FBR0E7QUFBQSxRQUNFQTtBQUFBLFFBQ0s7QUFBQSxVQUNFLElBQUksR0FBRyxPQUFPLHdCQUF3QixJQUFJO0FBQUEsVUFDL0MsT0FBTztBQUFBLFFBQ1Q7QUFBQSxRQUNBO0FBQUEsTUFDRjtBQUFBLElBQ0Y7QUFDQSxjQUFVLFNBQVMsTUFBTTtBQUN2QixhQUFPLHdCQUE2QixZQUFZO0FBQ2hELGFBQU8sZUFBZTtBQUN0QixhQUFPLGNBQWM7QUFDckIsYUFBTywyQkFBMkI7QUFDbEMsYUFBTyxLQUFLLFVBQVUsQ0FBQztBQUFBLFFBQ3JCLFFBQVE7QUFBQSxNQUNWLENBQUMsQ0FBQztBQUVGLGFBQU8sS0FBSyxLQUFLLFVBQVU7QUFBQSxRQUN6QixNQUFNO0FBQUEsUUFDTixNQUFNLE1BQU0sS0FBSyxPQUFPLE1BQU07QUFBQSxNQUNoQyxDQUF5QixDQUFDO0FBQUEsSUFFNUI7QUFDQSxXQUFPLEtBQUssVUFBVSxDQUFDO0FBQUEsTUFDckIsUUFBUTtBQUFBLElBQ1YsQ0FBQyxDQUFDO0FBQUEsRUFDSjtBQUNGO0FBRU8sSUFBTSxxQkFBTixjQUFpQyxhQUFxQjtBQUFBLEVBYzNELFlBQVksS0FBYSxPQUlyQjtBQUFBLElBQ0EsU0FBUztBQUFBLElBQ1QsZ0JBQWdCO0FBQUEsSUFDaEIsZ0JBQWdCO0FBQUEsRUFDbEIsR0FBRztBQUNILFVBQU07QUFDTixTQUFLLGlCQUFpQixLQUFLO0FBQzNCLFNBQUssTUFBTTtBQUVYLFNBQUssY0FBYztBQUNuQixTQUFLLGVBQWU7QUFDcEIsU0FBSywyQkFBMkI7QUFFaEMsU0FBSyxLQUFLO0FBQ1YsU0FBSyx3QkFBd0I7QUFDN0IsU0FBSyxnQkFBZ0IsS0FBSztBQUMxQixTQUFLLGtCQUFrQjtBQUV2QixTQUFLLFNBQVMsb0JBQUksSUFBWTtBQUU5QixRQUFJLEtBQUssaUJBQWlCLEdBQUc7QUFDM0IsV0FBSyxrQkFBbUIsT0FBTyxZQUFZLE1BQU07QUFDL0MsWUFBSSxLQUFLLE1BQU0sS0FBSyxHQUFHLGVBQWUsVUFBVSxNQUFNO0FBQ3BELGVBQUssS0FBSyxLQUFLLFVBQVU7QUFBQSxZQUN2QixNQUFNO0FBQUEsWUFDTixNQUFNLE1BQU0sS0FBSyxLQUFLLE1BQU07QUFBQSxVQUM5QixDQUF5QixDQUFDO0FBQUEsUUFDNUI7QUFBQSxNQUNGLEdBQUcsS0FBSyxjQUFjO0FBQUEsSUFDeEI7QUFFQSxRQUFJLEtBQUssU0FBUztBQUNoQixXQUFLLFFBQVE7QUFBQSxJQUNmO0FBQUEsRUFDRjtBQUFBLEVBRUEsS0FBSyxNQUFjO0FBcEpyQjtBQXFKSSxRQUFJLEtBQUssTUFBTSxLQUFLLEdBQUcsZUFBZSxLQUFLLEdBQUcsY0FBYyxLQUFLLEdBQUcsZUFBZSxLQUFLLEdBQUcsTUFBTTtBQUMvRixXQUFLLEdBQUcsTUFBTTtBQUFBLElBQ2hCO0FBQ0EsUUFBSTtBQUNGLGlCQUFLLE9BQUwsbUJBQVMsS0FBSztBQUFBLElBQ2hCLFNBQVMsR0FBUDtBQUNBLGlCQUFLLE9BQUwsbUJBQVM7QUFBQSxJQUNYO0FBQUEsRUFDRjtBQUFBLEVBR0EsVUFBVTtBQUNSLFFBQUksS0FBSyxvQkFBb0IsR0FBRztBQUM5QixvQkFBYyxLQUFLLGVBQWU7QUFBQSxJQUNwQztBQUNBLFNBQUssV0FBVztBQUNoQixVQUFNLFFBQVE7QUFBQSxFQUNoQjtBQUFBLEVBRUEsYUFBYTtBQUNYLFNBQUssZ0JBQWdCO0FBQ3JCLFFBQUksS0FBSyxPQUFPLE1BQU07QUFDcEIsV0FBSyxHQUFHLE1BQU07QUFBQSxJQUNoQjtBQUFBLEVBQ0Y7QUFBQSxFQUVBLFVBQVU7QUFDUixTQUFLLGdCQUFnQjtBQUNyQixRQUFJLENBQUMsS0FBSyxlQUFlLEtBQUssT0FBTyxNQUFNO0FBQ3pDLE1BQUFBLFNBQVEsSUFBSTtBQUFBLElBQ2Q7QUFBQSxFQUNGO0FBQUEsRUFFQSxJQUFJLEtBQW9CO0FBQ3RCLGVBQVdELE9BQU0sS0FBSztBQUNwQixXQUFLLE9BQU8sSUFBSUEsR0FBRTtBQUFBLElBQ3BCO0FBQ0EsU0FBSyxLQUFLLEtBQUssVUFBVTtBQUFBLE1BQ3ZCLE1BQU07QUFBQSxNQUNOLE1BQU07QUFBQSxJQUNSLENBQXlCLENBQUM7QUFBQSxFQUM1QjtBQUFBLEVBRUEsT0FBTyxLQUFvQjtBQUN6QixlQUFXQSxPQUFNLEtBQUs7QUFDcEIsV0FBSyxPQUFPLE9BQU9BLEdBQUU7QUFBQSxJQUN2QjtBQUNBLFNBQUssS0FBSyxLQUFLLFVBQVU7QUFBQSxNQUN2QixNQUFNO0FBQUEsTUFDTixNQUFNO0FBQUEsSUFDUixDQUF5QixDQUFDO0FBQUEsRUFDNUI7QUFDRjs7O0FDek1BLElBQUFFLG9CQUFpQztBQUVqQyxvQkFBd0I7QUFHakIsSUFBTSx1QkFBdUIsT0FBTyxXQUE0QjtBQUVyRSxNQUFJLDJCQUFTLGNBQWM7QUFDekIsVUFBTSxzQkFBUSxlQUFlLFFBQVEsSUFBSSxFQUFFLEtBQUssNkJBQTZCLFFBQVEsT0FBTyxTQUFTLE9BQU8sU0FBUyxLQUFLLFVBQVUscUJBQXFCLFFBQVEsS0FBSyxVQUFVLE1BQU0sWUFBWSxNQUFNLFlBQVksaUJBQWlCLENBQUM7QUFDdE8sVUFBTSxzQkFBUSxlQUFlLFFBQVEsSUFBSSxFQUFFLEtBQUsseUJBQXlCLFFBQVEsT0FBTyxTQUFTLE9BQU8sU0FBUyxLQUFLLFVBQVUsYUFBYSxRQUFRLEtBQUssVUFBVSxNQUFNLFlBQVksTUFBTSxZQUFZLGlCQUFpQixDQUFDO0FBQUEsRUFDNU4sV0FDUywyQkFBUyxhQUFhO0FBQzdCLFVBQU0sZUFBZSxJQUFJLElBQUksT0FBTyxTQUFTLFNBQVM7QUFDdEQsaUJBQWEsYUFBYSxPQUFPLE9BQU8sT0FBTyxTQUFTLEdBQUc7QUFDM0QsV0FBTyxTQUFTLFlBQVksYUFBYSxTQUFTO0FBQUEsRUFDcEQ7QUFDRjs7O0FDaEJBLElBQUFDLG9CQUEyQjtBQUdwQixJQUFNLFlBQU4sTUFBZ0I7QUFBQSxFQUdyQixZQUNVLE1BSVQ7QUFKUztBQUFBLEVBSVI7QUFBQSxFQUVGLE1BQU0seUJBQTBCO0FBQzlCLFVBQU0sT0FBTyxVQUFNLDhCQUFXO0FBQUEsTUFDNUIsS0FBSyxLQUFLLEtBQUs7QUFBQSxNQUNmLFFBQVE7QUFBQSxNQUNSLGFBQWE7QUFBQSxNQUNiLE1BQU0sS0FBSyxVQUFVO0FBQUEsUUFDbkIsS0FBSyxLQUFLLEtBQUs7QUFBQSxNQUNqQixDQUFDO0FBQUEsSUFDSCxDQUFDLEVBQUU7QUFFSCxRQUFJLENBQUMsUUFBUSxDQUFDLEtBQUssSUFBSTtBQUNyQixpQkFBVyw0QkFBNEI7QUFDdkM7QUFBQSxJQUNGO0FBQ0EsV0FBTztBQUFBLEVBQ1Q7QUFBQSxFQUVBLE1BQU0sbUJBQW9CQyxLQUFZO0FBQ3BDLFVBQU0sT0FBTyxVQUFNLDhCQUFXO0FBQUEsTUFDNUIsS0FBSyxLQUFLLEtBQUssc0JBQXNCLE1BQU1BO0FBQUEsTUFDM0MsUUFBUTtBQUFBLE1BQ1IsYUFBYTtBQUFBLElBQ2YsQ0FBQyxFQUFFO0FBRUgsUUFBSSxDQUFDLE1BQU07QUFDVCxpQkFBVyw0QkFBNEI7QUFDdkM7QUFBQSxJQUNGO0FBQ0EsV0FBTyxDQUFDLENBQUMsS0FBSztBQUFBLEVBQ2hCO0FBQ0Y7OztBQ3RDTyxJQUFNLGVBQWUsT0FBTyxLQUFhLFdBQTBEO0FBQ3hHLFFBQU0sY0FBYyxJQUFJLE1BQU0sR0FBRztBQUNqQyxNQUFJLDJDQUFhLFNBQVMsT0FBTztBQUMvQixXQUFPLGVBQWUsYUFBYSxLQUFLLE1BQU07QUFBQSxFQUNoRDtBQUNBLE1BQUksMkNBQWEsU0FBUyxTQUFTO0FBQ2pDLFdBQU8sYUFBYSxhQUFhLEtBQUssTUFBTTtBQUFBLEVBQzlDO0FBQ0Y7OztBQ1pBLElBQUFDLG9CQUFvQztBQUVwQyxJQUFNLHlCQUFOLGNBQXFDLHdCQUFNO0FBQUEsRUFJekMsWUFBWSxLQUFVLElBQTJDO0FBQy9ELFVBQU0sR0FBRztBQUNULFNBQUssS0FBSztBQUFBLEVBQ1o7QUFBQSxFQUVBLE1BQU0sU0FBUztBQUNiLFFBQUksMEJBQVEsS0FBSyxTQUFTLEVBQUUsUUFBUSx3QkFBd0IsRUFBRSxXQUFXO0FBRXpFLFFBQUksMEJBQVEsS0FBSyxTQUFTLEVBQUUsVUFBVSxZQUFVO0FBQzlDLGFBQU8sY0FBYyx3QkFBd0I7QUFDN0MsYUFBTyxPQUFPO0FBQ2QsYUFBTyxRQUFRLE1BQU07QUFDbkIsYUFBSyxNQUFNO0FBQ1gsYUFBSyxHQUFHO0FBQUEsVUFDTixXQUFXO0FBQUEsUUFDYixDQUFDO0FBQUEsTUFDSCxDQUFDO0FBQUEsSUFDSCxDQUFDLEVBQUUsUUFBUSxvRkFBb0Y7QUFFL0YsUUFBSSwwQkFBUSxLQUFLLFNBQVMsRUFBRSxVQUFVLFlBQVU7QUFDOUMsYUFBTyxjQUFjLG1CQUFtQjtBQUN4QyxhQUFPLE9BQU87QUFDZCxhQUFPLFFBQVEsTUFBTTtBQUNuQixhQUFLLE1BQU07QUFDWCxhQUFLLEdBQUc7QUFBQSxVQUNOLFdBQVc7QUFBQSxRQUNiLENBQUM7QUFBQSxNQUNILENBQUM7QUFBQSxJQUNILENBQUMsRUFBRSxRQUFRLHlJQUF5STtBQUFBLEVBQ3RKO0FBQ0Y7QUFFTyxJQUFNLHVCQUF1QixDQUFDLFFBQWE7QUFDaEQsU0FBTyxJQUFJLFFBQXFDLENBQUNDLGFBQVk7QUFDM0QsUUFBSSx1QkFBdUIsS0FBSyxDQUFDLFdBQVc7QUFDMUMsTUFBQUEsU0FBUSxNQUFNO0FBQUEsSUFDaEIsQ0FBQyxFQUFFLEtBQUs7QUFBQSxFQUNWLENBQUM7QUFDSDs7O0FDNUNBLElBQUFDLG9CQUFvQztBQVlwQyxJQUFNLGlCQUFOLGNBQTZCLHdCQUFNO0FBQUEsRUFNakMsWUFBWSxLQUFVLE1BQVksSUFBNkI7QUFDN0QsVUFBTSxHQUFHO0FBQ1QsU0FBSyxLQUFLO0FBQ1YsU0FBSyxTQUFTLEtBQUs7QUFDbkIsU0FBSyxPQUFPO0FBQUEsRUFDZDtBQUFBLEVBRUEsTUFBTSxTQUFTO0FBQ2IsUUFBSSwwQkFBUSxLQUFLLFNBQVMsRUFBRSxRQUFRLEtBQUssS0FBSyxNQUFNLEVBQUUsV0FBVztBQUVqRSxRQUFJLDBCQUFRLEtBQUssU0FBUyxFQUFFLFFBQVEsQ0FBQUMsVUFBUTtBQUMxQyxNQUFBQSxNQUFLLFNBQVMsS0FBSyxPQUFPLElBQUksR0FDNUJBLE1BQUssU0FBUyxDQUFDLFVBQVU7QUFDdkIsYUFBSyxPQUFPLE9BQU87QUFBQSxNQUNyQixDQUFDO0FBQ0gsTUFBQUEsTUFBSyxRQUFRLFlBQVksQ0FBQyxPQUFPO0FBQy9CLFlBQUksR0FBRyxRQUFRLFNBQVM7QUFDdEIsYUFBRyxlQUFlO0FBQ2xCLGVBQUssTUFBTTtBQUNYLGVBQUssR0FBRyxLQUFLLE1BQU07QUFBQSxRQUNyQjtBQUFBLE1BQ0Y7QUFBQSxJQUNGLENBQUMsRUFBRSxRQUFRLEtBQUssS0FBSyxXQUFXO0FBRWhDLFVBQU0sVUFBVSxJQUFJLDBCQUFRLEtBQUssU0FBUztBQUUxQyxZQUFRLFVBQVUsWUFBVTtBQUMxQixhQUFPLGNBQWMsUUFBUTtBQUM3QixhQUFPLFFBQVEsTUFBTTtBQUNuQixhQUFLLE1BQU07QUFBQSxNQUNiLENBQUM7QUFBQSxJQUNILENBQUM7QUFFRCxZQUFRLFVBQVUsWUFBVTtBQUMxQixhQUFPLGNBQWMsSUFBSTtBQUN6QixhQUFPLE9BQU87QUFDZCxhQUFPLFFBQVEsTUFBTTtBQUNuQixhQUFLLE1BQU07QUFDWCxhQUFLLEdBQUcsS0FBSyxNQUFNO0FBQUEsTUFDckIsQ0FBQztBQUFBLElBQ0gsQ0FBQztBQUFBLEVBRUg7QUFDRjtBQUVPLElBQU0sZ0JBQWdCLENBQUMsS0FBVSxTQUFlO0FBQ3JELFNBQU8sSUFBSSxRQUF1QixDQUFDQyxhQUFZO0FBQzdDLFFBQUksZUFBZSxLQUFLLE1BQU0sQ0FBQyxPQUFPO0FBQ3BDLE1BQUFBLFNBQVEsRUFBRTtBQUFBLElBQ1osQ0FBQyxFQUFFLEtBQUs7QUFBQSxFQUNWLENBQUM7QUFDSDtBQUVPLElBQU0sZUFBZSxDQUFDLFFBQWE7QUFDeEMsU0FBTyxjQUFjLEtBQUs7QUFBQSxJQUN4QixhQUFhO0FBQUEsSUFDYixRQUFRO0FBQUEsSUFDUixTQUFTO0FBQUEsTUFDUCxNQUFNO0FBQUEsSUFDUjtBQUFBLEVBQ0YsQ0FBQztBQUNIO0FBRU8sSUFBTSxnQkFBZ0IsQ0FBQyxRQUFhO0FBQ3pDLFNBQU8sY0FBYyxLQUFLO0FBQUEsSUFDeEIsYUFBYTtBQUFBLElBQ2IsUUFBUTtBQUFBLElBQ1IsU0FBUztBQUFBLE1BQ1AsTUFBTTtBQUFBLElBQ1I7QUFBQSxFQUNGLENBQUM7QUFDSDs7O0FDekVPLElBQU0seUJBQXlCO0FBRS9CLElBQU0sY0FBYztBQUNwQixJQUFNLGNBQWM7QUFDcEIsSUFBTSxTQUFTO0FBQ2YsSUFBTSxlQUFlO0FBQ3JCLElBQU0seUJBQXlCO0FBQy9CLElBQU0seUJBQXlCO0FBQy9CLElBQU0sMEJBQTBCO0FBRXZDLElBQU1DLDJCQUEwQjtBQUloQyxJQUFNQyxXQUFVLENBQUMsYUFBeUM7QUFDeEQsTUFBSSxTQUFTLGlCQUFpQixTQUFTLE9BQU8sTUFBTTtBQUNsRCxVQUFNLFlBQVksSUFBSSxVQUFVLFNBQVMsR0FBRztBQUM1QyxjQUFVLGFBQWE7QUFDdkIsYUFBUyxLQUFLO0FBQ2QsYUFBUyxlQUFlO0FBQ3hCLGFBQVMsY0FBYztBQUV2QixjQUFVLFlBQVksQ0FBQyxVQUFVO0FBdkNyQztBQXdDTSxlQUFTLHdCQUE2QixZQUFZO0FBQ2xELFlBQU0sT0FBTyxJQUFJLFdBQVcsTUFBTSxJQUFJO0FBQ3RDLFVBQUksS0FBSyxVQUFVO0FBQUc7QUFDdEIsWUFBTSxVQUFtQixjQUFjLElBQUk7QUFDM0MsWUFBTSxjQUF1QixZQUFZLE9BQU87QUFDaEQsVUFBSSxnQkFBZ0Isd0JBQXdCO0FBQzFDLGNBQU0sa0JBQTJCLFlBQVksT0FBTztBQUNwRCxnQkFBUSxpQkFBaUI7QUFBQSxVQUN2QixLQUFLO0FBQ0g7QUFDRSxvQkFBTSxTQUFrQixjQUFjLE9BQU87QUFDN0Msb0JBQU1DLE1BQWMsY0FBYyxPQUFPO0FBQ3pDLG9CQUFNLFdBQW9CLGNBQWMsT0FBTztBQUMvQyx1QkFBUyxLQUFLLHFCQUFxQixDQUFDLFFBQVFBLEtBQUksUUFBUSxDQUFDO0FBQUEsWUFDM0Q7QUFDQTtBQUFBLFVBQ0YsS0FBSztBQUFhO0FBQ2hCLG9CQUFNQSxNQUFjLGNBQWMsT0FBTztBQUN6QyxvQkFBTSxTQUFrQixrQkFBa0IsT0FBTztBQUNqRCxvQkFBTSxPQUFnQixjQUFjLE9BQU87QUFDM0Msb0JBQU1DLFFBQU0sb0JBQWUsU0FBU0QsR0FBRSxNQUExQixZQUErQixhQUFhLFNBQVNBLEdBQUU7QUFDbkUsa0JBQUlDLFFBQU8sUUFBUUEsS0FBSSxjQUFjLEdBQUc7QUFDdEMseUJBQVMsY0FBY0EsTUFBSyxNQUFNO0FBQUEsY0FDcEM7QUFBQSxZQUNGO0FBQUU7QUFBQSxVQUNGLEtBQUs7QUFBYTtBQUNoQixvQkFBTUQsTUFBYyxjQUFjLE9BQU87QUFDekMsb0JBQU0sU0FBa0Isa0JBQWtCLE9BQU87QUFDakQsb0JBQU0sT0FBZ0IsY0FBYyxPQUFPO0FBQzNDLG9CQUFNQyxRQUFNLG9CQUFlLFNBQVNELEdBQUUsTUFBMUIsWUFBK0IsYUFBYSxTQUFTQSxHQUFFO0FBQ25FLGtCQUFJQyxNQUFLO0FBQ1AsZ0JBQUUsWUFBWUEsS0FBSSxNQUFNLFFBQVEsUUFBUTtBQUN4Qyx5QkFBUyxLQUFLLFVBQVUsQ0FBQ0QsS0FBSSxJQUFJLENBQUM7QUFBQSxjQUNwQztBQUFBLFlBQ0Y7QUFDRTtBQUFBLFVBQ0YsS0FBSztBQUF5QjtBQUM1QixvQkFBTUEsTUFBYyxjQUFjLE9BQU87QUFDekMsb0JBQU0sU0FBa0Isa0JBQWtCLE9BQU87QUFDakQsb0JBQU0sV0FBb0IsY0FBYyxPQUFPO0FBQy9DLHVCQUFTLEtBQUsscUJBQXFCLENBQUNBLEtBQUksUUFBUSxRQUFRLENBQUM7QUFBQSxZQUMzRDtBQUFFO0FBQUEsVUFDRjtBQUNFLG9CQUFRLElBQUksYUFBYTtBQUN6QjtBQUFBLFFBQ0o7QUFBQSxNQUNGO0FBQUEsSUFDRjtBQUVBLGNBQVUsVUFBVSxDQUFDLFVBQVU7QUFDN0IsZUFBUyxLQUFLLG9CQUFvQixDQUFDLE9BQU8sUUFBUSxDQUFDO0FBQUEsSUFDckQ7QUFFQSxjQUFVLFVBQVUsQ0FBQyxVQUFVO0FBQzdCLGVBQVMsS0FBSyxvQkFBb0IsQ0FBQyxPQUFPLFFBQVEsQ0FBQztBQUNuRCxlQUFTLEtBQUs7QUFDZCxlQUFTLGVBQWU7QUFDeEIsVUFBSSxTQUFTLGFBQWE7QUFDeEIsaUJBQVMsY0FBYztBQUN2QixpQkFBUyxLQUFLLFVBQVUsQ0FBQztBQUFBLFVBQ3ZCLFFBQVE7QUFBQSxRQUNWLENBQUMsQ0FBQztBQUFBLE1BQ0osT0FBTztBQUNMLGlCQUFTO0FBQUEsTUFDWDtBQUNBO0FBQUEsUUFDRUQ7QUFBQSxRQUNLO0FBQUEsVUFDRSxJQUFJLEdBQUcsU0FBUyx3QkFBd0IsSUFBSTtBQUFBLFVBQ2pELFNBQVM7QUFBQSxRQUNYO0FBQUEsUUFDQTtBQUFBLE1BQ0Y7QUFBQSxJQUNGO0FBRUEsY0FBVSxTQUFTLFlBQVk7QUFDN0IsZUFBUyx3QkFBNkIsWUFBWTtBQUNsRCxlQUFTLGVBQWU7QUFDeEIsZUFBUyxjQUFjO0FBQ3ZCLGVBQVMsMkJBQTJCO0FBQ3BDLGVBQVMsS0FBSyxVQUFVLENBQUM7QUFBQSxRQUN2QixRQUFRO0FBQUEsTUFDVixDQUFDLENBQUM7QUFFRixpQkFBVyxVQUFVLGFBQWEsT0FBTyxHQUFHO0FBQzFDLFlBQUksT0FBTyxtQkFBbUI7QUFDNUIsY0FBSSxDQUFDLE9BQU8sa0JBQWtCO0FBQVEsa0JBQU0sT0FBTyxrQkFBa0I7QUFDckUsaUJBQU8sZUFBZTtBQUFBLFFBQ3hCO0FBQUEsTUFDRjtBQUVBLGlCQUFXRSxRQUFPLGVBQWUsT0FBTyxHQUFHO0FBQ3pDLFlBQUlBLEtBQUksZUFBZUEsS0FBSSxtQkFBbUI7QUFDNUMsY0FBSSxDQUFDQSxLQUFJLGtCQUFrQjtBQUFRLGtCQUFNQSxLQUFJLGtCQUFrQjtBQUMvRCxVQUFBQSxLQUFJLGVBQWU7QUFBQSxRQUNyQjtBQUFBLE1BQ0Y7QUFBQSxJQUVGO0FBRUEsYUFBUyxLQUFLLFVBQVUsQ0FBQztBQUFBLE1BQ3ZCLFFBQVE7QUFBQSxJQUNWLENBQUMsQ0FBQztBQUFBLEVBQ0o7QUFDRjtBQWdCTyxJQUFNLDZCQUFOLGNBQXlDLGFBQXFCO0FBQUEsRUFvQm5FLFlBQVksV0FBbUI7QUFBQSxJQUM3QixVQUFVO0FBQUEsSUFDVixpQkFBaUI7QUFBQSxJQUNqQixpQkFBaUI7QUFBQSxFQUNuQixJQUEwSyxDQUFDLEdBQUc7QUFDNUssVUFBTTtBQUNOLFNBQUssTUFBTTtBQUNYLFNBQUssaUJBQWlCO0FBQ3RCLFNBQUssY0FBYztBQUNuQixTQUFLLGVBQWU7QUFDcEIsU0FBSyxrQkFBa0I7QUFDdkIsU0FBSywyQkFBMkI7QUFDaEMsU0FBSyxVQUFVO0FBQ2YsU0FBSyxLQUFLO0FBQ1YsU0FBSyx3QkFBd0I7QUFDN0IsU0FBSyxnQkFBZ0I7QUFDckIsU0FBSyxrQkFBa0I7QUFFdkIsU0FBSyxpQkFBa0IsT0FBTyxZQUFZLE1BQU07QUFDOUMsVUFDRSxLQUFLLGVBQ0xILDJCQUNLLFlBQVksSUFBSSxLQUFLLHVCQUMxQjtBQUNBLFFBQUMsS0FBSyxHQUFLLE1BQU07QUFBQSxNQUNuQjtBQUFBLElBQ0YsR0FBR0EsMkJBQTBCLEVBQUU7QUFDL0IsUUFBSSxTQUFTO0FBQ1gsV0FBSyxRQUFRO0FBQUEsSUFDZjtBQUFBLEVBQ0Y7QUFBQSxFQUVBLGNBQWNHLE1BQW1CO0FBQy9CLFVBQU0sVUFBbUIsY0FBYztBQUN2QyxJQUFTLGFBQWEsU0FBUyxzQkFBc0I7QUFDckQsSUFBUyxhQUFhLFNBQVMsV0FBVztBQUMxQyxJQUFTLGVBQWUsU0FBU0EsS0FBSSxPQUFPO0FBQzVDLElBQVMsbUJBQW1CLFNBQVcsa0JBQWtCQSxLQUFJLElBQUksQ0FBQztBQUNsRSxJQUFTLGVBQWUsU0FBU0EsS0FBSSxjQUFjLENBQUM7QUFDcEQsU0FBSyxZQUFxQixhQUFhLE9BQU8sQ0FBQztBQUFBLEVBQ2pEO0FBQUEsRUFFQSxjQUFjQSxNQUFtQixRQUFxQjtBQUNwRCxVQUFNLFVBQW1CLGNBQWM7QUFDdkMsSUFBUyxhQUFhLFNBQVMsc0JBQXNCO0FBQ3JELElBQVMsYUFBYSxTQUFTLFdBQVc7QUFDMUMsSUFBUyxlQUFlLFNBQVNBLEtBQUksT0FBTztBQUM1QyxJQUFTLG1CQUFtQixTQUFXLG9CQUFvQkEsS0FBSSxNQUFNLE1BQU0sQ0FBQztBQUM1RSxJQUFTLGVBQWUsU0FBU0EsS0FBSSxjQUFjLENBQUM7QUFDcEQsU0FBSyxZQUFxQixhQUFhLE9BQU8sQ0FBQztBQUFBLEVBQ2pEO0FBQUEsRUFFQSxXQUFXQSxNQUFtQixRQUFvQjtBQUNoRCxVQUFNLFVBQW1CLGNBQWM7QUFDdkMsSUFBUyxhQUFhLFNBQVMsc0JBQXNCO0FBQ3JELElBQVMsYUFBYSxTQUFTLE1BQU07QUFDckMsSUFBUyxlQUFlLFNBQVNBLEtBQUksT0FBTztBQUM1QyxJQUFTLG1CQUFtQixTQUFTLE1BQU07QUFDM0MsSUFBUyxlQUFlLFNBQVNBLEtBQUksY0FBYyxDQUFDO0FBQ3BELFNBQUssWUFBcUIsYUFBYSxPQUFPLENBQUM7QUFBQSxFQUNqRDtBQUFBLEVBRUEsa0JBQWtCLFNBQWlCLFFBQW9CLFVBQWtCO0FBQ3ZFLFVBQU0sVUFBbUIsY0FBYztBQUN2QyxJQUFTLGFBQWEsU0FBUyxzQkFBc0I7QUFDckQsSUFBUyxhQUFhLFNBQVMsTUFBTTtBQUNyQyxJQUFTLGVBQWUsU0FBUyxPQUFPO0FBQ3hDLElBQVMsbUJBQW1CLFNBQVMsTUFBTTtBQUMzQyxJQUFTLGVBQWUsU0FBUyxRQUFRO0FBQ3pDLFNBQUssWUFBcUIsYUFBYSxPQUFPLENBQUM7QUFBQSxFQUNqRDtBQUFBLEVBRUEsZ0JBQWdCQSxNQUFtQixRQUFnQjtBQUNqRCxVQUFNLFVBQW1CLGNBQWM7QUFDdkMsSUFBUyxhQUFhLFNBQVMsc0JBQXNCO0FBQ3JELElBQVMsYUFBYSxTQUFTLFlBQVk7QUFDM0MsSUFBUyxlQUFlLFNBQVMsTUFBTTtBQUN2QyxJQUFTLG1CQUFtQixTQUFXLG9CQUFvQkEsS0FBSSxJQUFJLENBQUM7QUFDcEUsSUFBUyxlQUFlLFNBQVNBLEtBQUksY0FBYyxDQUFDO0FBQ3BELFNBQUssWUFBcUIsYUFBYSxPQUFPLENBQUM7QUFBQSxFQUNqRDtBQUFBLEVBRUEsd0JBQXdCRCxLQUFZO0FBQ2xDLFVBQU0sVUFBbUIsY0FBYztBQUN2QyxJQUFTLGFBQWEsU0FBUyxzQkFBc0I7QUFDckQsSUFBUyxhQUFhLFNBQVMsc0JBQXNCLEdBQzFDLGVBQWUsU0FBU0EsR0FBRTtBQUNyQyxTQUFLLFlBQXFCLGFBQWEsT0FBTyxDQUFDO0FBQUEsRUFDakQ7QUFBQSxFQUVBLFlBQVksS0FBa0I7QUFDNUIsUUFBSSxLQUFLLGVBQWUsS0FBSyxNQUFNLEtBQUssR0FBRyxlQUFlLFVBQVUsTUFBTTtBQUN4RSxXQUFLLEdBQUcsS0FBSyxHQUFHO0FBQUEsSUFDbEI7QUFBQSxFQUNGO0FBQUEsRUFFQSxnQkFBZ0IsT0FBZTtBQUM3QixXQUFPLElBQUksUUFBZSxDQUFBRSxhQUFXO0FBQ25DLFlBQU0sVUFBVSxDQUFDLFVBQWtCLFFBQW9CLGFBQXFCO0FBQzFFLFlBQUksU0FBUyxVQUFVO0FBQ3JCLGVBQUssSUFBSSxxQkFBcUIsT0FBTztBQUNyQyxnQkFBTUQsT0FBTSxJQUFNLElBQUk7QUFDdEIsVUFBRSxZQUFZQSxNQUFLLE1BQU07QUFHekIsZ0JBQU0sT0FBTyxNQUFNLEtBQUtBLEtBQUksT0FBTyxXQUFXLENBQUM7QUFDL0MsY0FBSSxLQUFLLFNBQVMsR0FBRztBQUNuQixrQkFBTSxhQUFhLFVBQVUsTUFBTSxLQUFLLElBQUksQ0FBQztBQUM3QyxrQkFBTSxpQkFBaUIsY0FBYyxVQUFVO0FBQy9DLGdCQUFJLGtCQUFrQixVQUFVO0FBQzlCLG1CQUFLLGtCQUFrQixPQUFTLG9CQUFvQkEsSUFBRyxHQUFHLGNBQWM7QUFBQSxZQUMxRTtBQUFBLFVBQ0Y7QUFDQSxVQUFBQyxTQUFRRCxJQUFHO0FBQUEsUUFDYjtBQUFBLE1BQ0Y7QUFDQSxXQUFLLEdBQUcscUJBQXFCLE9BQU87QUFDcEMsV0FBSyx3QkFBd0IsS0FBSztBQUFBLElBQ3BDLENBQUM7QUFBQSxFQUNIO0FBQUEsRUFFQSxVQUFVO0FBQ1IsUUFBSSxLQUFLLG9CQUFvQixHQUFHO0FBQzlCLG9CQUFjLEtBQUssZUFBZTtBQUFBLElBQ3BDO0FBQ0Esa0JBQWMsS0FBSyxjQUFjO0FBQ2pDLFNBQUssV0FBVztBQUNoQixVQUFNLFFBQVE7QUFBQSxFQUNoQjtBQUFBLEVBRUEsYUFBYTtBQUNYLFNBQUssZ0JBQWdCO0FBQ3JCLFFBQUksS0FBSyxPQUFPLE1BQU07QUFDcEIsV0FBSyxHQUFHLE1BQU07QUFBQSxJQUNoQjtBQUFBLEVBQ0Y7QUFBQSxFQUVBLFVBQVU7QUFDUixTQUFLLGdCQUFnQjtBQUNyQixRQUFJLENBQUMsS0FBSyxlQUFlLEtBQUssT0FBTyxNQUFNO0FBQ3pDLE1BQUFGLFNBQVEsSUFBSTtBQUFBLElBQ2Q7QUFBQSxFQUNGO0FBQ0Y7OztBbktwVEEsSUFBQUksUUFBc0I7QUFFdEIsSUFBcUIsa0JBQXJCLGNBQTZDLHlCQUFPO0FBQUEsRUFRbkQsTUFBTSxTQUFTO0FBRWQsVUFBTSxTQUFTO0FBRWYsV0FBTyxXQUFXLE1BQU0sZ0JBQWdCLE1BQU07QUFFOUMsVUFBTSxxQkFBcUIsTUFBTTtBQUVqQyxXQUFPLE1BQU0sSUFBSSxnQkFBK0I7QUFDaEQsV0FBTyxZQUFZLElBQUksVUFBVTtBQUFBLE1BQ2hDLEtBQUssT0FBTyxTQUFTO0FBQUEsTUFDckIscUJBQXFCLE9BQU8sU0FBUztBQUFBLElBQ3RDLENBQUM7QUFFRCxXQUFPLHFCQUFxQixJQUFJLG1CQUFtQixPQUFPLFNBQVMsU0FBUztBQUFBLE1BQzNFLGdCQUFnQjtBQUFBLE1BQ2hCLFNBQVM7QUFBQSxNQUNULGdCQUFnQjtBQUFBLElBQ2pCLENBQUM7QUFFRCxXQUFPLElBQUksR0FBRyxPQUFPLENBQUMsS0FBSyxTQUFTO0FBN0N0QztBQThDRywyQkFBZSxXQUFXLEtBQUssSUFBSSxNQUFuQyxtQkFBc0MsbUJBQW1CO0FBQ3pELFdBQUssR0FBRyxjQUFjLENBQUMsWUFBWTtBQS9DdEMsWUFBQUM7QUFnREksY0FBTUMsT0FBTSxlQUFlLFdBQVcsT0FBTztBQUM3QyxZQUFJQSxNQUFLO0FBQ1IsVUFBQUEsS0FBSSx3QkFBd0IsR0FBRztBQUMvQixnQkFBTSxRQUFRLGVBQWUsU0FBUyxPQUFPLEdBQUc7QUFDaEQsY0FBSSxNQUFNLFdBQVcsS0FBSyxDQUFDQSxLQUFJLGFBQWE7QUFDM0MsWUFBQUEsS0FBSSxRQUFRO0FBQUEsVUFDYjtBQUFBLFFBQ0Q7QUFDQSxTQUFBRCxNQUFBLGVBQWUsV0FBVyxLQUFLLElBQUksTUFBbkMsZ0JBQUFBLElBQXNDLG1CQUFtQjtBQUFBLE1BQzFELENBQUM7QUFBQSxJQUNGLENBQUM7QUFFRCxXQUFPLElBQUksR0FBRyxVQUFVLE9BQU8sS0FBSyxTQUFTO0FBQzVDLFlBQU1DLE9BQU0sZUFBZSxXQUFXLEtBQUssSUFBSTtBQUMvQyxVQUFJLENBQUNBO0FBQUs7QUFDVixNQUFBQSxLQUFJLHdCQUF3QixHQUFHO0FBQy9CLFlBQU0sUUFBUSxlQUFlLEtBQUssTUFBTSxPQUFPLEdBQUc7QUFDbEQsVUFBSSxNQUFNLFdBQVcsR0FBRztBQUN2QixZQUFJQSxRQUFPLENBQUNBLEtBQUksYUFBYTtBQUM1QixnQkFBTUEsS0FBSSxRQUFRO0FBQUEsUUFDbkI7QUFBQSxNQUNEO0FBQ0EsV0FBSyxRQUFRO0FBQUEsSUFDZCxDQUFDO0FBRUQsV0FBTyxJQUFJLFVBQVU7QUFBQSxNQUNwQixZQUFZO0FBQ1gsYUFBSyxhQUFhLElBQUksMkJBQTJCLEtBQUssU0FBUyxJQUFJO0FBQ25FLG1CQUFXLFFBQVEsT0FBTyxTQUFTLGFBQWEsT0FBTztBQUN0RCxnQkFBTSxlQUFlLDJCQUEyQixFQUFFLE1BQU0sS0FBSyxDQUFDLEdBQUcsZUFBZSxLQUFLLENBQUMsRUFBRSxlQUFlLFNBQVMsS0FBSyxDQUFDLEVBQUUsUUFBUSxHQUFHLE1BQU07QUFBQSxRQUMxSTtBQUNBLG1CQUFXLFVBQVUsT0FBTyxTQUFTLGFBQWEsU0FBUztBQUMxRCxnQkFBTSxhQUFhLHlCQUF5QixFQUFFLE1BQU0sT0FBTyxDQUFDLEdBQUcsZUFBZSxPQUFPLENBQUMsRUFBRSxlQUFlLFNBQVMsT0FBTyxDQUFDLEVBQUUsUUFBUSxHQUFHLE1BQU07QUFBQSxRQUM1STtBQUNBLGlDQUF5QixPQUFPLElBQUksV0FBVyxPQUFPLEdBQUc7QUFDekQsZUFBTyxjQUFjLE9BQU8sSUFBSSxVQUFVLEdBQUcsaUJBQWlCLE1BQU07QUFDbkUsbUNBQXlCLE9BQU8sSUFBSSxXQUFXLE9BQU8sR0FBRztBQUFBLFFBQzFELENBQUMsQ0FBQztBQUFBLE1BQ0g7QUFBQSxJQUNEO0FBRUEsV0FBTyxjQUFjLE9BQU8sSUFBSSxVQUFVLEdBQUcsYUFBYSxDQUFDLE1BQU0sU0FBUztBQUN6RSxVQUFJLGdCQUFnQiwyQkFBUztBQUU1QixjQUFNLGVBQWUsYUFBYSxXQUFXLEtBQUssSUFBSTtBQUN0RCxZQUFJLENBQUMsY0FBYztBQUNsQixjQUFJLENBQUMsYUFBYSwwQkFBMEIsS0FBSyxJQUFJLEtBQUssT0FBTyxTQUFTLEtBQUssU0FBUyxRQUFRO0FBQy9GLGlCQUFLLFFBQVEsQ0FBQyxTQUFTO0FBQ3RCLG1CQUFLLFNBQVMsY0FBYztBQUM1QixtQkFBSyxRQUFRLE9BQU87QUFDcEIsbUJBQUssUUFBUSxNQUFNO0FBQ2xCLDZCQUFhLFlBQVksTUFBTSxNQUFNO0FBQUEsY0FDdEMsQ0FBQztBQUFBLFlBQ0YsQ0FBQztBQUFBLFVBQ0Y7QUFBQSxRQUNELE9BQU87QUFDTixlQUFLLFFBQVEsVUFBUTtBQUNwQixpQkFBSyxTQUFTLG9CQUFvQjtBQUNsQyxpQkFBSyxRQUFRLE9BQU87QUFDcEIsaUJBQUssUUFBUSxNQUFNO0FBQ2xCLHdCQUFVLFVBQVUsVUFBVSxPQUFPLFNBQVMsV0FBVyxXQUFXLGFBQWEsT0FBTztBQUFBLFlBQ3pGLENBQUM7QUFBQSxVQUNGLENBQUM7QUFDRCxlQUFLLFFBQVEsVUFBUTtBQUNwQixpQkFBSyxTQUFTLDBCQUEwQjtBQUN4QyxpQkFBSyxRQUFRLGdCQUFnQjtBQUM3QixpQkFBSyxRQUFRLFlBQVk7QUFDeEIsb0JBQU0sYUFBYSxRQUFRO0FBQUEsWUFDNUIsQ0FBQztBQUFBLFVBQ0YsQ0FBQztBQUNELGVBQUssUUFBUSxVQUFRO0FBQ3BCLGlCQUFLLFNBQVMsNEJBQTRCO0FBQzFDLGlCQUFLLFFBQVEsWUFBWTtBQUN6QixpQkFBSyxRQUFRLFlBQVk7QUFDeEIsb0JBQU0sYUFBYSxTQUFTLGNBQWMsTUFBTTtBQUFBLFlBQ2pELENBQUM7QUFBQSxVQUNGLENBQUM7QUFBQSxRQUNGO0FBQUEsTUFDRCxPQUFPO0FBQ04sY0FBTSxpQkFBaUIsZUFBZSxXQUFXLEtBQUssSUFBSTtBQUMxRCxjQUFNLGVBQWUsYUFBYSwwQkFBMEIsS0FBSyxJQUFJO0FBQ3JFLFlBQUksZ0JBQWdCO0FBQ25CLGVBQUssUUFBUSxVQUFRO0FBQ3BCLGlCQUFLLFNBQVMsb0JBQW9CO0FBQ2xDLGlCQUFLLFFBQVEsT0FBTztBQUNwQixpQkFBSyxRQUFRLE1BQU07QUFDbEIsd0JBQVUsVUFBVSxVQUFVLE9BQU8sU0FBUyxXQUFXLFNBQVMsZUFBZSxPQUFPO0FBQUEsWUFDekYsQ0FBQztBQUFBLFVBQ0YsQ0FBQztBQUNELGNBQUksQ0FBQyxjQUFjO0FBQ2xCLGlCQUFLLFFBQVEsVUFBUTtBQUNwQixtQkFBSyxTQUFTLDRCQUE0QjtBQUMxQyxtQkFBSyxRQUFRLGdCQUFnQjtBQUM3QixtQkFBSyxRQUFRLFlBQVk7QUFDeEIsc0JBQU0sZUFBZSxRQUFRO0FBQUEsY0FDOUIsQ0FBQztBQUFBLFlBQ0YsQ0FBQztBQUFBLFVBQ0Y7QUFBQSxRQUNEO0FBQUEsTUFDRDtBQUFBLElBQ0QsQ0FBQyxDQUFDO0FBRUYsV0FBTyxXQUFXO0FBQUEsTUFDakIsSUFBSTtBQUFBLE1BQ0osTUFBTTtBQUFBLE1BQ04sY0FBYyxVQUFVO0FBQ3ZCLGNBQU0sT0FBTyxPQUFPLElBQUksVUFBVSxvQkFBb0IsOEJBQVk7QUFDbEUsWUFBSSxDQUFDO0FBQU0saUJBQU87QUFDbEIsY0FBTSxPQUFPLEtBQUs7QUFDbEIsWUFBSSxDQUFDO0FBQU0saUJBQU87QUFDbEIsY0FBTUEsT0FBTSxlQUFlLFdBQVcsS0FBSyxJQUFJO0FBQy9DLFlBQUlBO0FBQUssaUJBQU87QUFDaEIsWUFBSTtBQUFVLGlCQUFPO0FBRXJCLFlBQUksT0FBTyxTQUFTLEtBQUssU0FBUyxRQUFRO0FBQ3pDLCtCQUFxQixPQUFPLEdBQUcsRUFBRSxLQUFLLFlBQVU7QUFDL0MsZ0JBQUksQ0FBQztBQUFRO0FBQ2IsMkJBQWUsU0FBUyxNQUFNLFFBQVEsRUFBRSxXQUFXLE9BQU8sVUFBVSxDQUFDLEVBQUUsS0FBSyxDQUFBQSxTQUFPO0FBQ2xGLGtCQUFJLENBQUNBLE1BQUs7QUFDVCx1QkFBTyxXQUFXLDBCQUEwQjtBQUFBLGNBQzdDO0FBQUEsWUFDRCxDQUFDO0FBQUEsVUFDRixDQUFDO0FBQUEsUUFDRixPQUFPO0FBQ04seUJBQWUsU0FBUyxNQUFNLFFBQVEsRUFBRSxXQUFXLE1BQU0sQ0FBQyxFQUFFLEtBQUssQ0FBQUEsU0FBTztBQUN2RSxnQkFBSSxDQUFDQSxNQUFLO0FBQ1QscUJBQU8sV0FBVywwQkFBMEI7QUFBQSxZQUM3QztBQUFBLFVBQ0QsQ0FBQztBQUFBLFFBQ0Y7QUFBQSxNQUNEO0FBQUEsSUFDRCxDQUFDO0FBRUQsV0FBTyxXQUFXO0FBQUEsTUFDakIsSUFBSTtBQUFBLE1BQ0osTUFBTTtBQUFBLE1BQ04scUJBQXFCLENBQUMsVUFBVSxRQUFRLFFBQVE7QUFDL0MsY0FBTSxPQUFPLElBQUk7QUFDakIsWUFBSSxDQUFDO0FBQU0saUJBQU87QUFDbEIsY0FBTUEsT0FBTSxlQUFlLFdBQVcsS0FBSyxJQUFJO0FBQy9DLFlBQUksQ0FBQ0EsUUFBT0EsS0FBSTtBQUFhLGlCQUFPO0FBQ3BDLFlBQUk7QUFBVSxpQkFBTztBQUNyQixRQUFBQSxLQUFJLFFBQVEsRUFBRSxLQUFLLE1BQU07QUFBQSxRQUFFLENBQUM7QUFBQSxNQUM3QjtBQUFBLElBQ0QsQ0FBQztBQUVELFdBQU8sV0FBVztBQUFBLE1BQ2pCLElBQUk7QUFBQSxNQUNKLE1BQU07QUFBQSxNQUNOLFVBQVUsWUFBWTtBQUNyQixjQUFNLE1BQU0sTUFBTSxhQUFhLE9BQU8sR0FBRztBQUN6QyxZQUFJLE9BQU8sSUFBSSxNQUFNO0FBQ3BCLGdCQUFNLGFBQWEsSUFBSSxNQUFNLE1BQU07QUFBQSxRQUNwQztBQUFBLE1BQ0Q7QUFBQSxJQUNELENBQUM7QUFFRCxRQUFJLE9BQU8sU0FBUyxPQUFPO0FBQzFCLGFBQU8sV0FBVztBQUFBLFFBQ2pCLElBQUk7QUFBQSxRQUNKLE1BQU07QUFBQSxRQUNOLFVBQVUsWUFBWTtBQWpOMUI7QUFrTkssZ0JBQU0sTUFBTSxNQUFNLE9BQU8sVUFBVSxVQUFVO0FBQzdDLHFCQUFXLE1BQU0sS0FBSztBQUNyQixpQkFBSSxRQUFHLFNBQUgsbUJBQVMsV0FBVyxlQUFlO0FBQ3RDLHFCQUFPLFVBQVUsZUFBZSxHQUFHLElBQUk7QUFBQSxZQUN4QztBQUFBLFVBQ0Q7QUFBQSxRQUNEO0FBQUEsTUFDRCxDQUFDO0FBQUEsSUFDRjtBQUVBLFdBQU8sY0FBYyxPQUFPLElBQUksTUFBTSxHQUFHLFVBQVUsT0FBTyxNQUFNLFlBQVk7QUFDM0UsVUFBSSxnQkFBZ0IseUJBQU87QUFDMUIsY0FBTUEsT0FBTSxlQUFlLFdBQVcsT0FBTztBQUM3QyxZQUFJQSxNQUFLO0FBQ1IsZ0JBQU1BLEtBQUksbUJBQW1CLElBQUk7QUFBQSxRQUNsQztBQUVBLGNBQU0sa0JBQWtCLGFBQWEsMEJBQTBCLE9BQU87QUFDdEUsY0FBTSxrQkFBa0IsYUFBYSwwQkFBMEIsS0FBSyxJQUFJO0FBRXhFLFlBQUksbUJBQW1CLGlCQUFpQjtBQUN2QyxjQUFJLG9CQUFvQixpQkFBaUI7QUFDeEMsNEJBQWdCLFdBQVcsU0FBUyxLQUFLLElBQUk7QUFBQSxVQUM5QyxPQUFPO0FBQ04sa0JBQU0sU0FBUyxNQUFNLGVBQWUsVUFBVSxNQUFNLEVBQUUsV0FBVyxLQUFLLEdBQUcsTUFBTTtBQUMvRSxnQkFBSSxRQUFRO0FBQ1gsOEJBQWdCLFlBQVksTUFBTTtBQUFBLFlBQ25DO0FBQ0EsZ0JBQUlBLE1BQUs7QUFBQSxZQUdUO0FBQUEsVUFDRDtBQUFBLFFBQ0QsV0FBVyxtQkFBbUIsQ0FBQyxpQkFBaUI7QUFDL0MsY0FBSUEsTUFBSztBQUNSLHVCQUFXLHlGQUF5RjtBQUVwRyxrQkFBTSxhQUFhLGdCQUFxQixjQUFRLE9BQU8sR0FBRyxNQUFNO0FBQ2hFLGtCQUFNQyxRQUFPLE1BQU0sT0FBTyxJQUFJLE1BQU0sT0FBTyxTQUFTLEVBQUU7QUFDdEQsZ0JBQUksQ0FBQ0EsT0FBTTtBQUNWLHlCQUFXLHlCQUF5QixVQUFVLEdBQUc7QUFDakQ7QUFBQSxZQUNEO0FBQ0EsWUFBQUQsS0FBSSxtQkFBbUJDLEtBQUk7QUFDM0IsWUFBQUQsS0FBSSxlQUFlO0FBQUEsVUFDcEI7QUFBQSxRQUNELFdBQVcsQ0FBQyxtQkFBbUIsaUJBQWlCO0FBQy9DLGdCQUFNQSxPQUFNLE1BQU0sZUFBZSxVQUFVLE1BQU0sRUFBRSxXQUFXLEtBQUssR0FBRyxNQUFNO0FBQzVFLGNBQUlBLE1BQUs7QUFDUiw0QkFBZ0IsWUFBWUEsSUFBRztBQUFBLFVBQ2hDO0FBQUEsUUFDRDtBQUFBLE1BQ0QsV0FBVyxnQkFBZ0IsMkJBQVM7QUFDbkMsY0FBTSxTQUFTLGFBQWEsV0FBVyxPQUFPO0FBQzlDLFlBQUksUUFBUTtBQUNYLGdCQUFNLE9BQU8scUJBQXFCLElBQUk7QUFBQSxRQUN2QztBQUFBLE1BQ0Q7QUFBQSxJQUNELENBQUMsQ0FBQztBQUVGLFdBQU8sY0FBYyxPQUFPLElBQUksTUFBTSxHQUFHLFVBQVUsT0FBTyxTQUFTO0FBQ2xFLGFBQU8sSUFBSSx5QkFBeUIsS0FBSyxJQUFJO0FBQzdDLFVBQUksZ0JBQWdCLDJCQUFTO0FBQzVCLGNBQU0sU0FBUyxhQUFhLFdBQVcsS0FBSyxJQUFJO0FBQ2hELHlDQUFRO0FBQ1I7QUFBQSxNQUNELFdBQVcsZ0JBQWdCLHlCQUFPO0FBQ2pDLGNBQU0sU0FBUyxhQUFhLDBCQUEwQixLQUFLLElBQUk7QUFDL0QsWUFBSSxDQUFDLFFBQVE7QUFDWixnQkFBTUEsT0FBTSxlQUFlLFdBQVcsS0FBSyxJQUFJO0FBQy9DLGNBQUlBLE1BQUs7QUFDUixrQkFBTUEsS0FBSSxRQUFRO0FBQUEsVUFDbkI7QUFBQSxRQUNEO0FBQUEsTUFDRDtBQUFBLElBa0JELENBQUMsQ0FBQztBQUVGLFdBQU8sSUFBSSxVQUFVO0FBQUEsTUFDcEIsTUFBTTtBQUNMLGVBQU8sY0FBZSxPQUFPLElBQUksTUFBTSxHQUFHLFVBQVUsT0FBTyxTQUFTO0FBQ25FLGNBQUksRUFBRSxnQkFBZ0I7QUFBUTtBQUM5QixnQkFBTSxTQUFTLGFBQWEsMEJBQTBCLEtBQUssSUFBSTtBQUMvRCxjQUFJLENBQUM7QUFBUTtBQUNiLGNBQUksT0FBTyxtQkFBbUIsSUFBSTtBQUFHO0FBQ3JDLGNBQUksZUFBZSxXQUFXLEtBQUssSUFBSTtBQUFHO0FBRTFDLGNBQUksT0FBTyxTQUFTLGFBQWEsTUFBTSxRQUFJLGlDQUFjLEtBQUssSUFBSSxDQUFDO0FBQUc7QUFFdEUsZ0JBQU1BLE9BQU0sTUFBTSxlQUFlLFVBQVUsTUFBTTtBQUFBLFlBQ2hELFdBQVc7QUFBQSxVQUNaLEdBQUcsTUFBTTtBQUNULGNBQUlBLE1BQUs7QUFDUixtQkFBTyxZQUFZQSxJQUFHO0FBQUEsVUFDdkI7QUFBQSxRQUNELENBQUMsQ0FBRTtBQUFBLE1BQ0o7QUFBQSxJQUNEO0FBRUEsVUFBTSxjQUFjLGtCQUFrQixNQUFNO0FBRTVDLFFBQUksQ0FBQyxPQUFPLFNBQVMsTUFBTTtBQUMxQixZQUFNLE9BQU8sTUFBTSxjQUFjLE9BQU8sR0FBRztBQUMzQyxVQUFJLFFBQVEsS0FBSyxNQUFNO0FBQ3RCLGFBQUssU0FBUyxPQUFPLEtBQUs7QUFDMUIscUJBQWEsS0FBSyxVQUFVLE1BQU07QUFBQSxNQUNuQztBQUFBLElBQ0Q7QUFDQSxXQUFPLGNBQWMsV0FBVztBQUFBLEVBQ2pDO0FBQUEsRUFFQSxXQUFXO0FBQ1YsbUJBQWUsT0FBTyxFQUFFLFFBQVEsQ0FBQ0EsU0FBUTtBQUN4QyxNQUFBQSxLQUFJLFFBQVE7QUFBQSxJQUNiLENBQUM7QUFDRCxpQkFBYSxPQUFPLEVBQUUsUUFBUSxZQUFVO0FBQ3ZDLGFBQU8sUUFBUTtBQUFBLElBQ2hCLENBQUM7QUFDRCxTQUFLLG1CQUFtQixRQUFRO0FBQUEsRUFDakM7QUFBQSxFQUVBLElBQUksU0FBaUI7QUFDcEIsUUFBSSxLQUFLLFNBQVMsT0FBTztBQUN4QixjQUFRLElBQUksT0FBTztBQUFBLElBQ3BCO0FBQUEsRUFDRDtBQUVEOzs7QUQvVkEsSUFBTyxlQUFROyIsCiAgIm5hbWVzIjogWyJtb2R1bGUiLCAibW9kdWxlIiwgInNlbGYiLCAibW9kdWxlIiwgIlhYSCIsICJoMzIiLCAibW9kdWxlIiwgIm1vZHVsZSIsICJtb2R1bGUiLCAibiIsICJ0IiwgInIiLCAiYSIsICJlIiwgIm8iLCAiZCIsICJzIiwgImwiLCAiYyIsICJmIiwgInUiLCAicCIsICJpIiwgImgiLCAibSIsICJnIiwgIl8iLCAiaW1wb3J0X29ic2lkaWFuIiwgImlzTmFOIiwgIm1hcCIsICJjcmVhdGUiLCAiY3JlYXRlIiwgImFyZ3MiLCAiaW1wb3J0X29ic2lkaWFuIiwgImlzTmFOIiwgInBhcnNlSW50IiwgImtleXMiLCAiY3JlYXRlIiwgImNyZWF0ZSIsICJjcmVhdGUiLCAibGVuZ3RoIiwgImxlbmd0aCIsICJhcmdzIiwgImxlbmd0aCIsICJsZW5ndGgiLCAiY3JlYXRlIiwgImZvckVhY2giLCAidGV4dCIsICJmb3JFYWNoIiwgImZyYWdtZW50IiwgImNyZWF0ZSIsICJjcmVhdGUiLCAiYXJncyIsICJjcmVhdGUiLCAiYXJncyIsICJzdHlsZSIsICJjcmVhdGUiLCAiY3JlYXRlTW9kdWxlTG9nZ2VyIiwgImRlbCIsICJpZCIsICJsZW5ndGgiLCAiaSIsICJjcmVhdGUiLCAicmVzb2x2ZSIsICJkb2MiLCAidHlwZSIsICJpZCIsICJhbnkiLCAiaSIsICJkb2MiLCAidHlwZSIsICJ0eXBlIiwgImRvYyIsICJ0eXBlIiwgImNyZWF0ZSIsICJpZCIsICJkb2MiLCAidHlwZSIsICJjcmVhdGUiLCAic3RydWN0IiwgImRvYyIsICJ0eXBlIiwgImkiLCAiaGFzQ29udGVudCIsICJjcmVhdGUiLCAia2V5cyIsICJwYXRoIiwgInR5cGUiLCAidHlwZSIsICJkb2MiLCAiY3JlYXRlIiwgImxlbmd0aCIsICJtYXAiLCAibGVuZ3RoIiwgImNvdW50IiwgImRvYyIsICJ0ZXh0IiwgInR5cGUiLCAiZWxlbWVudCIsICJmcmFnbWVudCIsICJjcmVhdGUiLCAia2V5cyIsICJpZCIsICJpdGVtIiwgInRleHQiLCAia2V5cyIsICJ0ZXh0IiwgImNtVmlldyIsICJjbVN0YXRlIiwgImluc2VydFRleHQiLCAiY21WaWV3IiwgImNtU3RhdGUiLCAiY3JlYXRlIiwgImlkIiwgImNtU3RhdGUiLCAiY21WaWV3IiwgImltcG9ydF9zdGF0ZSIsICJwYXRoIiwgImltcG9ydF9vYnNpZGlhbiIsICJwYXRoIiwgImNyZWF0ZSIsICJkb2MiLCAiZG9jIiwgImNyZWF0ZSIsICJkYXRhIiwgImNyZWF0ZU1vZHVsZUxvZ2dlciIsICJkb2MiLCAiYWRkIiwgIlBlZXIiLCAiZW5jb2RlciIsICJjcmVhdGUiLCAiZGF0YSIsICJpbXBvcnRfb2JzaWRpYW4iLCAicGF0aCIsICJkb2MiLCAiaWQiLCAicmVzb2x2ZSIsICJwYXRoIiwgImNyZWF0ZSIsICJyZXNvbHZlIiwgInJlamVjdCIsICJ0cmFuc2FjdCIsICJjcmVhdGUiLCAicmVzb2x2ZSIsICJyZWplY3QiLCAidHJhbnNhY3QiLCAiZG9jIiwgImNyZWF0ZSIsICJyZXNvbHZlIiwgInRyYW5zYWN0IiwgInBhdGgiLCAiaW1wb3J0X29ic2lkaWFuIiwgImltcG9ydF9vYnNpZGlhbiIsICJpbXBvcnRfb2JzaWRpYW4iLCAiaW1wb3J0X29ic2lkaWFuIiwgInJlc29sdmUiLCAia2V5cyIsICJpc0FycmF5IiwgImFyZ3MiLCAiYXNhcCIsICJhbnkiLCAiRGV4aWVFcnJvciIsICJub3AiLCAicmVzb2x2ZSIsICJyZWplY3QiLCAidHlwZSIsICJwcm9wcyIsICJ0cmFucyIsICJQcm9taXNlIiwgImkiLCAiYWRkIiwgIlRhYmxlIiwgImNvdW50IiwgImN0eCIsICJDb2xsZWN0aW9uIiwgImNtcCIsICJsZW5ndGgiLCAiZGlyZWN0aW9uIiwgIm1pbiIsICJtYXgiLCAiYWRkUmFuZ2UiLCAicmFuZ2VzIiwgIldoZXJlQ2xhdXNlIiwgImluZGV4ZWREQiIsICJUcmFuc2FjdGlvbiIsICJwIiwgImRiIiwgInRhYmxlcyIsICJrZXlQYXRoIiwgImNvbXBvdW5kIiwgInJlc3VsdCIsICJyZXEiLCAib3BlbkN1cnNvciIsICJxdWVyeSIsICJldiIsICJoYXNHZXRBbGwiLCAiY3JlYXRlIiwgIklEQktleVJhbmdlIiwgIlZlcnNpb24iLCAiRGV4aWUiLCAiRGVidWcuZGVidWciLCAiRGVidWcuZ2V0RXJyb3JXaXRoU3RhY2siLCAic2FmYXJpMTRXb3JrYXJvdW5kIiwgInByaW1hcnlLZXkiLCAiZHhUcmFucyIsICJSYW5nZVNldCIsICJmcm9tIiwgInRhcmdldCIsICJrZXkiLCAic3Vic2NyaWJlIiwgInN0YXRlIiwgInVuc3Vic2NyaWJlIiwgIk9ic2VydmFibGUiLCAiX0RleGllIiwgIkRlYnVnLnNldERlYnVnIiwgImRvYyIsICJwYXRoIiwgImRvYyIsICJmb2xkZXJzIiwgInRleHQiLCAiaW1wb3J0X29ic2lkaWFuIiwgImRvYyIsICJwYXRoIiwgImRvY3VtZW50IiwgImZvbGRlciIsICJkb2MiLCAibG9jYXRpb24iLCAiaWQiLCAicGF0aCIsICJyZXNvbHZlIiwgInJlamVjdCIsICJ0YXNrIiwgInRleHQiLCAibGVuZ3RoIiwgImFyZ3MiLCAidGV4dCIsICJsZW5ndGgiLCAiZG9jIiwgImZpbGUiLCAiaWQiLCAicmVzb2x2ZSIsICJsb2NhdGlvbiIsICJwYXRoIiwgImlkIiwgInNldHVwV1MiLCAiaW1wb3J0X29ic2lkaWFuIiwgImltcG9ydF9vYnNpZGlhbiIsICJpZCIsICJpbXBvcnRfb2JzaWRpYW4iLCAicmVzb2x2ZSIsICJpbXBvcnRfb2JzaWRpYW4iLCAidGV4dCIsICJyZXNvbHZlIiwgIm1lc3NhZ2VSZWNvbm5lY3RUaW1lb3V0IiwgInNldHVwV1MiLCAiaWQiLCAiZG9jIiwgInJlc29sdmUiLCAicGF0aCIsICJfYSIsICJkb2MiLCAiZmlsZSJdCn0K
